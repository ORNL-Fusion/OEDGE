C
C
      SUBROUTINE EIRSRT(LSTOP,LTIME,DELTAT,FLUXES,
     .                  B2BRM,B2RD,B2Q,B2VP)

      USE PRECISION
      USE PARMMOD
      USE BRASPOI
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CINIT
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CTRCEI
      USE CCOUPL
      USE CGEOM
      USE CSDVI
      USE CSDVI_BGK
      USE CSDVI_COP
      USE COMPRT
      USE COMNNL
      USE COMSOU
      USE COUTAU
      USE COMXS
      USE CSPEI
      USE BRASCL

      IMPLICIT NONE
C
      REAL(DP), INTENT(IN) :: FLUXES(NSTRA)
      REAL(DP), INTENT(IN) :: DELTAT, B2BRM, B2RD, B2Q, B2VP
      LOGICAL, INTENT(IN) :: LSTOP, LTIME

      REAL(DP) :: FLUXS(NSTRA)
      REAL(DP) :: FTABEI1, FEELEI1, FLXI, ESIG, RESET_SECOND, DUMMY,
     .          SECOND_OWN, DTIMVO
      INTEGER :: IN, IAEI, IRDS, IIDS, ICPV, IMDS, IFIRST, K, JC, NDXY,
     .           J, IRC, NREC10, NREC11
      REAL(DP), ALLOCATABLE :: OUTAU(:)
      INTEGER, ALLOCATABLE :: IHELP(:)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
C
      SAVE
      DATA IFIRST/0/
C
      IF (LTIME) THEN
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        DUMMY=RESET_SECOND()
        IF(IFIRST.EQ.0) THEN
C
          CALL GRSTRT(35,8)
C
C  READ FORMATTED INPUT FILE IUNIN
C  AND RUN EIRENE FOR ONE TIME-CYCLE: ITIMV=1
C  WITH OR WITHOUT INITIAL DISTRIBUTION ON FILE FT15 (NFILE-J FLAG)
C  AS FINAL STRATUM
C  EXPECT PLASMA DATA ON FORT.31 (NLPLAS=.FALSE.)
C
          CALL EIRENE(DELTAT,.FALSE.,.FALSE.,1)
C
C  EIRENE RUN DONE. CENSUS ARRAY WRITTEN
C  NOW ITIMV=ITIMV+1, NLPLAS=.TRUE.
C
          DO 3 ISTRA=1,NSTRAI
            FLUXS(ISTRA)=FLUX(ISTRA)
3         CONTINUE
          IFIRST=1
        ELSE
C
C  NOW: NLPLAS=.TRUE., I.E., PLASMA DATA EXPECTED ON BRAEIR
C  NOW: ITIMV=ITIMV+1
C  BUT: COMMON BRAEIR REDONE IN EXTERNAL CODE.
C  REACTIVATE INDEX MAPPING, EVEN WITHOUT READING INPUT BLOCK 14 AGAIN
          NCUTB_SAVE=NCUTB
C
          DTIMVO=DTIMV
          DTIMVN=DELTAT
C
C-----------------------------------------------------------------------
C
C  STRATA 1 TO NTARGI ARE SCALED IN PLASMA CODE  (RECYCLING STRATA)
C
C     RETURN TO PLASMA CODE THE PROFILES PER UNIT SOURCE STRENGTH
C     IE. THE PROFILES ARE SCALED BY 1./FLUX(ISTRA) BEFORE RETURN
C
C  STRATA NTARGI+1 TO NSTRAI-1  ARE SCALED BY EIRENE
C
C     (EG. GAS PUFF, VOLUME RECOMBINATION, ETC.)
C     THEY MAY BE RESCALED BY PLASMA CODE FACTORS: FLUXES(ISTRA)
C     RETURN TO PLASMA CODE THE PROFILES SCALED WITH
C     SOURCE STRENGTH: FLUX(ISTRA) (AMP)
C
C  STRATUM NSTRAI IS RESCALED WITH RATIO OF OLD TO NEW TIMESTEP
C
C     RETURN TO PLASMA CODE THE PROFILES WITH FLUX(ISTRA) (AMP)
C
          DO ISTRA=NTARGI+1,NSTRAI-1
            IF (FLUXES(ISTRA).NE.0.) THEN
              FLUX(ISTRA)=FLUXS(ISTRA)*FLUXES(ISTRA)*ELCHA
            ELSE
              FLUX(ISTRA)=FLUXS(ISTRA)
            ENDIF
          ENDDO
C
          IF (DTIMVN.NE.DTIMVO) THEN
            FLUX(NSTRAI)=FLUX(NSTRAI)*DTIMVO/DTIMVN
C
            WRITE (6,*) 'FLUX IS RESCALED BY DTIMV_OLD/DTIMV_NEW '
            CALL MASR1('FLUX    ',FLUX(NSTRAI))
            CALL LEER(1)
          ENDIF
C
C-----------------------------------------------------------------------
C
          DTIMV=DTIMVN
C
C  RUN EIRENE ON TIMESTEP DTIMV
C  THEN CALL INTERFACING ROUTINE AT ENTRY IF3COP (FROM EIRENE MAIN)
C
          IITER=1
          IPRNLI=0
          CALL EIRENE_COUPLE (LSTOP)
          IF (LSTOP) THEN
            CALL GREND
          ENDIF
        ENDIF
        CALL LEER(2)
        WRITE(*,*) 'EIRENE USED ',SECOND_OWN(),' CPU SECONDS'
        CALL LEER(2)
C
        RETURN
C
      ELSEIF (.NOT.LTIME) THEN
C
C  SHORT CYCLE, SEMI-IMPLICIT COUPLING
C
        IF (IFIRST.GE.1) GOTO 10000
C
        CALL ALLOC_COMUSR(1)
        CALL SETPRM
C
        NREC10=1500
        OPEN (UNIT=10,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC10)
        NREC11=NOUTAU
        OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
C
        IRC=3
        READ (11,REC=IRC) RCCPL
        ALLOCATE (IHELP(NOUTAU))
        JC=0
        IRC=IRC+1
        READ (11,REC=IRC) IHELP
        DO K=1,NPTRGT
          DO J=1,10*NSTEP
            JC=JC+1
            ICCPL1(J,K)=IHELP(JC)
            IF (JC == NOUTAU) THEN
              IRC=IRC+1
              READ (11,REC=IRC) IHELP
              JC=0
            END IF
          END DO
        END DO
        DEALLOCATE (IHELP)
        IRC=IRC+1
        READ (11,REC=IRC) ICCPL2
        IRC=IRC+1
        READ (11,REC=IRC) LCCPL
        IF (LTRCFL)
     .    WRITE (6,*) 'READ DATA FOR SHORT CYCLE, SAVED ON  FT11 ',IRC
C
        NLPLG=LNLPLG
        NLDRFT=LNLDRF
        TRCFLE=LTRCFL
        NSTRAI=NSTRI
        DO 1 ISTRA=1,NSTRAI
          NLVOL(ISTRA)=LNLVOL(ISTRA)
1       CONTINUE
        NMODE=NMODEI
        NFILEN=NFILNN
C
C
        INDPRO(1)=6
        INDPRO(2)=6
        INDPRO(3)=6
        INDPRO(4)=6
        INDPRO(5)=6
C
        INDGRD(1)=6
        INDGRD(2)=1
        INDGRD(3)=1
C
        CALL SETCON
        CALL RGEOM(TRCFLE)
        CALL RPLAM(TRCFLE)
C
        IF (TRCFLE) WRITE (6,*) 'READ DATA FOR EIRENE RECALL OPTION'
        IRC=1
        READ (11,REC=IRC) LOGATM,LOGION,LOGMOL,LOGPLS
        IF (TRCFLE)
     .    WRITE (6,*) 'DATA FOR RECALL OPTION READ FROM  FT11, IRC=1 '
        IRC=2
        ALLOCATE (OUTAU(NOUTAU))
        CALL WRITE_COUTAU (OUTAU)
        READ (11,REC=IRC) OUTAU
        DEALLOCATE (OUTAU)
        IF (TRCFLE)
     .    WRITE (6,*) 'DATA FOR RECALL OPTION READ FROM  FT11, IRC=2 '
C
        CALL INTER0
C
        NDXY=(NDXA-1)*NR1ST+NDYA
C
!PB        IF (.NOT.ALLOCATED(SPLODA)) CALL ALLOC_BRASCL
        CALL ALLOC_BRASCL
        CALL INIT_BRASCL1
C
C  INITIAL: ATOMS, EI-PROCESSES
C
        DO 21 IATM=1,NATMI
        DO 21 IPLS=1,NPLSI
        DO 21 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 21
          DO 22 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
22        CONTINUE
21      CONTINUE
        DO 23 IPLS=1,NPLSI
          DO 24 IN=1,NDXY
            SEIODA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLS,IN)+EDRIFT(IPLS,IN))
24        CONTINUE
23      CONTINUE
C
        DO 25 IATM=1,NATMI
        DO 25 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          DO 25 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
25      CONTINUE
C
C  INITIAL: TEST IONS, EI-PROCESSES
C
        DO 26 IION=1,NIONI
        DO 26 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          DO 26 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODI(IN,IION)=SEEODI(IN,IION)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODI(IN,IION)=SEEODI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
26      CONTINUE
C
        DO 27 IION=1,NIONI
        DO 27 IPLS=1,NPLSI
        DO 27 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 27
          DO 28 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ENDIF
28        CONTINUE
27      CONTINUE
C
        DO 29 IION=1,NIONI
        DO 29 IPLS=1,NPLSI
        DO 29 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 30 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODI(IN,IION)=SEIODI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODI(IN,IION)=SEIODI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
30        CONTINUE
29      CONTINUE
C
C
C  INITIAL: MOLECULES, EI-PROCESSES
C
        DO 35 IMOL=1,NMOLI
        DO 35 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 35 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            ENDIF
35      CONTINUE
C
        DO 47 IMOL=1,NMOLI
        DO 47 IPLS=1,NPLSI
        DO 47 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 47
          DO 48 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
48        CONTINUE
47      CONTINUE
C
        DO 49 IMOL=1,NMOLI
        DO 49 IPLS=1,NPLSI
        DO 49 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 50 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
50        CONTINUE
49      CONTINUE
C
C
C
        DO 60 ISTRA=1,NSTRAI
          IF (ISTRA.EQ.IESTR) THEN
C  NOTHING TO BE DONE
          ELSEIF ((NFILEN.EQ.1.OR.NFILEN.EQ.2).AND.ISTRA.NE.IESTR) THEN
            IESTR=ISTRA
            CALL RSTRT(ISTRA,NSTRAI,NESTM1,NESTM2,ESTIMV,ESTIMS,
     .                 NSDVI1,SDVI1,NSDVI2,SDVI2,
     .                 NSDVC1,SIGMAC,NSDVC2,SGMCS,
     .                 NSBGK,SIGMA_BGK,NBGV_STAT,SGMS_BGK,
     .                 NSCOP,SIGMA_COP,NCPV_STAT,SGMS_COP,TRCFLE)
            IF (NLSYMP(ISTRA).OR.NLSYMT(ISTRA)) THEN
              CALL SYMET(ESTIMV,NTALV,NRTAL,NR1TAL,NP2TAL,NT3TAL,
     .                   NADDV,NFIRST,NLSYMP(ISTRA),NLSYMT(ISTRA))
            ENDIF
          ELSE
            WRITE (6,*) 'ERROR IN EIRSRT: STRATUM ISTRA= ',ISTRA
            WRITE (6,*) 'IS NOT AVAILABLE. EXIT CALLED'
            CALL EXIT
          ENDIF
C
C  SAVE EIRENE TALLIES, SCALE PER UNIT FLUX (AMP), ON COMMON BRASCL
C  WTOTP IS NEGATIVE IN EIRENE (SINK FOR IONS)
C  ALL STRATA WHICH ARE NOT SPECIFIED BY INPUT BLOCK 14 (FROM
C  PLASMA CODE DATA) ARE NOT RESCALED HERE
C
          IF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).NE.0.) THEN
            FLXI=-1./WTOTP(0,ISTRA)
          ELSEIF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).EQ.0.) THEN
            GOTO 60
          ELSEIF (ISTRA.GT.NTARGI) THEN
            FLXI=1.
          ENDIF

          NULLIFY(PAPLS(ISTRA)%PMUL)
          NULLIFY(PMPLS(ISTRA)%PMUL)
          NULLIFY(PIPLS(ISTRA)%PMUL)

          NULLIFY(EAELS(ISTRA)%PSIM)
          NULLIFY(EMELS(ISTRA)%PSIM)
          NULLIFY(EIELS(ISTRA)%PSIM)
          NULLIFY(EAPLS(ISTRA)%PSIM)
          NULLIFY(EMPLS(ISTRA)%PSIM)
          NULLIFY(EIPLS(ISTRA)%PSIM)

          NULLIFY(PDENAS(ISTRA)%PMUL)
          NULLIFY(PDENMS(ISTRA)%PMUL)
          NULLIFY(PDENIS(ISTRA)%PMUL)
          NULLIFY(EDENAS(ISTRA)%PMUL)

          NULLIFY(COPVS(ISTRA)%PMUL)

          DO IPLS=1,NPLSI
!pb         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PAPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PAPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PAPLS(ISTRA)%PMUL
                PAPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PMPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PMPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PMPLS(ISTRA)%PMUL
                PMPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PIPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PIPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PIPLS(ISTRA)%PMUL
                PIPLS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
!PB       DO IN=1,NDXY
          DO IN=1,NSBOX_TAL
            IF (EAEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAEL(IN)*FLXI
              CPSIM%NXTSIM => EAELS(ISTRA)%PSIM
              EAELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMEL(IN)*FLXI
              CPSIM%NXTSIM => EMELS(ISTRA)%PSIM
              EMELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIEL(IN)*FLXI
              CPSIM%NXTSIM => EIELS(ISTRA)%PSIM
              EIELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EAPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAPL(IN)*FLXI
              CPSIM%NXTSIM => EAPLS(ISTRA)%PSIM
              EAPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMPL(IN)*FLXI
              CPSIM%NXTSIM => EMPLS(ISTRA)%PSIM
              EMPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIPL(IN)*FLXI
              CPSIM%NXTSIM => EIPLS(ISTRA)%PSIM
              EIPLS(ISTRA)%PSIM => CPSIM
            ENDIF
          ENDDO
          DO IATM=1,NATMI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => PDENAS(ISTRA)%PMUL
                PDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (EDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = EDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => EDENAS(ISTRA)%PMUL
                EDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IMOL=1,NMOLI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENM(IMOL,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IMOL
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENM(IMOL,IN)*FLXI
                CPMUL%NXTMUL => PDENMS(ISTRA)%PMUL
                PDENMS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IION=1,NIONI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENI(IION,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IION
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENI(IION,IN)*FLXI
                CPMUL%NXTMUL => PDENIS(ISTRA)%PMUL
                PDENIS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO ICPV=1,NCPVI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (COPV(ICPV,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = ICPV
                CPMUL%ICM = IN
                CPMUL%VALUEM = COPV(ICPV,IN)*FLXI
                CPMUL%NXTMUL => COPVS(ISTRA)%PMUL
                COPVS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
C
C
60      CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI,0)
C
        IFIRST=IFIRST+1
        RETURN
C
10000   CONTINUE
C
        NCUTB_SAVE=NCUTB
        CALL INTER1
C
        CALL PLASMA
C
        CALL PLASMA_DERIV
C
        CALL SETAMD
C
!pb        IF (.NOT.ALLOCATED(SPLNWA)) CALL ALLOC_BRASCL
        CALL ALLOC_BRASCL
        CALL INIT_BRASCL2
C
C  NEW: ATOMS, EI PROCESSES
C
        DO 101 IATM=1,NATMI
        DO 101 IPLS=1,NPLSI
          DO 102 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 101
            DO 102 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
              ELSE
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
              END IF
102       CONTINUE
101     CONTINUE
C
        DO 103 IPLS=1,NPLSI
          DO 104 IN=1,NDXY
            SEINWA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLS,IN)+EDRIFT(IPLS,IN))
104       CONTINUE
103     CONTINUE
C
        DO 105 IATM=1,NATMI
          DO 105 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            DO 105 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
105     CONTINUE
C
C  NEW: TEST IONS, EI PROCESSES
C
        DO 106 IION=1,NIONI
          DO 106 IIDS=1,NIDSI(IION)
            IRDS=LGIEI(IION,IIDS)
            DO 106 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWI(IN,IION)=SEENWI(IN,IION)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWI(IN,IION)=SEENWI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
106     CONTINUE
C
        DO 107 IION=1,NIONI
        DO 107 IPLS=1,NPLSI
        DO 107 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 107
          DO 108 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
108       CONTINUE
107     CONTINUE
C
        DO 109 IION=1,NIONI
        DO 109 IPLS=1,NPLSI
        DO 109 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 110 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWI(IN,IION)=SEINWI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWI(IN,IION)=SEINWI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
110       CONTINUE
109     CONTINUE
C
C  NEW: MOLECULES, EI PROCESSES
C
        DO 115 IMOL=1,NMOLI
        DO 115 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 116 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
116       CONTINUE
115     CONTINUE
C
        DO 117 IMOL=1,NMOLI
        DO 117 IPLS=1,NPLSI
        DO 117 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 117
          DO 118 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
118       CONTINUE
117     CONTINUE
C
        DO 119 IMOL=1,NMOLI
        DO 119 IPLS=1,NPLSI
        DO 119 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 120 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
120       CONTINUE
119     CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI,0)
C
        IFIRST=IFIRST+1

        IF (LSTOP) THEN
          CALL DEALLOC_COMUSR
          CALL DEALLOC_CESTIM
          CALL DEALLOC_BRASCL
          CALL DEALLOC_BRASPOI
        END IF

        RETURN
C
      ENDIF

      END


      SUBROUTINE IF0PRM(IUNIN)

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CINIT

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: IUNIN
      INTEGER :: NFLA, NCUTB, NCUTL, NDXA, NDYA, IPL, NTARGI, IT, IPRT,
     .           NAINB, IAIN, NAOTB, IAOT, NECKEN, NTRIAN, NRKNOT, 
     .           NTRII, NCOPI
      INTEGER, ALLOCATABLE :: NTGPRT(:)
      CHARACTER(72) :: ZEILE

      READ (IUNIN,*)
      READ (IUNIN,'(3I6)') NFLA,NCUTB,NCUTL
      DO IPL=1,NPLS
        READ (IUNIN,*) 
      END DO
      READ (IUNIN,'(2I6)') NDXA,NDYA
C  NUMBER OF TARGET SOURCES ON B2 SURFACES: NTARGI
      READ (IUNIN,'(I6)') NTARGI
C  NUMBER OF PARTS PER TARGET SOURCE
      IF (NTARGI.GT.0) THEN
        ALLOCATE (NTGPRT(NTARGI))
        READ (IUNIN,'(12I6)') (NTGPRT(IT),IT=1,NTARGI)
        NPTRGT=SUM(NTGPRT)
        DO IT=1,NTARGI
          DO IPRT=1,NTGPRT(IT)
 331        READ (IUNIN,'(A72)') ZEILE
            IF (ZEILE(1:1).EQ.'*') THEN
              GOTO 331
            ENDIF
          END DO
        END DO
        DEALLOCATE (NTGPRT)
      END IF
      READ (IUNIN,*)
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM B2 INTO EIRENE
C  HERE: B2 VOLUME TALLIES
      READ (IUNIN,'(I6)') NAINB
      NAIN = MAX(NAIN,NAINB)
      DO IAIN=1,NAINB
        READ (IUNIN,*) 
        READ (IUNIN,*) 
        READ (IUNIN,*) 
      END DO
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM EIRENE INTO B2
C  HERE: EIRENE SURFACE TALLIES
      READ (IUNIN,'(I6)') NAOTB
      DO IAOT=1,NAOTB
        READ (IUNIN,*) 
      END DO
C
C READING BLOCK 14 FROM FORMATTED INPUT FILE (IUNIN) FINISHED
C
C
C  DEFINE ADDITIONAL TALLIES FOR COUPLING (UPDATED IN SUBR. UPTCOP
C                                              AND IN SUBR. COLLIDE)
      NCOPI=4
      NCPVI=NCOPI*NPLS
      NCOP = NCOPI
      NCPV = NCPVI
C
C SAVE SOME MORE INPUT DATA FOR SHORT CYCLE ON COMMON CCOUPL
      NDX = NDXA
      NDY = NDYA
      NFL = NFLA
      NDXP = NDX+1
      NDYP = NDY+1
      
      RETURN
      END
C
C
      SUBROUTINE INDMAP(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG)
C
C     INDEX MAPPING FOR BRAAMS DATA FIELDS. DATA IN DUMMY ZONES
C     (CUTS OR BOUNDARY ZONES) MAY BE NEEDED AND THUS ARE KEPT
C     AND DUBLICATED IN CASE NCUTL GT NCUTB
C
C     NCUTB= NUMBER OF CELLS IN IX DIRECTION PER CUT IN BRAAMS
C     NCUTL= NUMBER OF CELLS IN IX DIRECTION PER CUT IN LINDA (AND
C            THUS ALSO IN EIRENE) GEOMETRY

      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: NPOINT(2,*)
      INTEGER, INTENT(IN) :: NDX, NDY, NFL, NDXA, NDYA, NFLA, NCUTB,
     .                       NCUTL, NPPLG
      REAL(DP), INTENT(INOUT) :: FIELD(0:NDX+1,0:NDY+1,NFL),
     .                         DUMMY(0:NDX+1,0:NDY+1)
      INTEGER :: IX, IPART, IY, IF, IENDD, INB, IINID, IINIV, IENDV
C
C  LOOP FOR THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=FIELD(IX,IY,IF)
C
C
C      NDX DIRECTION: IX=0: NOT MODIFIED
C                     IX=I(CUT): USE CUT VALUE
C                     IX=I(LAST X ZONE): MOVE TO NDXA+1
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(IX,IY)=FIELD(INB,IY,IF)
213         CONTINUE
            DUMMY(IINID,IY) = FIELD(INB+1,IY,IF)
            IF (IENDD.NE.IINID) DUMMY(IENDD,IY) = FIELD(INB+NCUTB,IY,IF)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN SUBR. INDMAP: THIS SUBR. IS VALID ONLY'
      WRITE (6,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT
991   WRITE (6,*) 'ERROR IN SUBR. INDMAP: INCONSISTENCY IN NUMBER OF '
      WRITE (6,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED.  '
      WRITE (6,*) 'NCUTL = ',NCUTL, ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT
      END
C
C
      SUBROUTINE INDMPI(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG,NSTR,ISTR)
C
C     INDEX MAPPING: INVERS TO SUBR. INDMAP
C
      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: NPOINT(2,*)
      INTEGER, INTENT(IN) :: NDX, NDY, NFL, NDXA, NDYA, NFLA, NCUTB,
     .                       NCUTL, NPPLG, NSTR, ISTR
      REAL(DP), INTENT(INOUT) :: FIELD(0:NDX+1,0:NDY+1,NFL,NSTR),
     .                         DUMMY(0:NDX+1,0:NDY+1)
      INTEGER :: IX, IY, IF, IENDD, IPART, INB, IINID, IINIV, IENDV
C
C  LOOP OVER THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=0.
C
C
C      NDX DIRECTION
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(INB,IY)=FIELD(IX,IY,IF,ISTR)
213         CONTINUE
            DUMMY(INB+1,IY)=FIELD(IINID,IY,IF,ISTR)
            IF (IENDD.NE.IINID)
     .          DUMMY(INB+NCUTB,IY)=FIELD(IENDD,IY,IF,ISTR)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF,ISTR)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN SUBR. INDMPI: THIS SUBR. IS VALID ONLY'
      WRITE (6,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT
991   WRITE (6,*) 'ERROR IN SUBR. INDMPI: INCONSISTENCY IN NUMBER OF'
      WRITE (6,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED. '
      WRITE (6,*) 'NCUTL = ',NCUTL, ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT
      END
C
C   EIRENE CODE SEGMENT COUPLE_$, $ MAY CURRENTLY STAND FOR B2,
C                                                           B2.5,
C                                                           DIVIMP,
C                                                           TRANSP,
C                                                           DUMMY
C
C   THIS VERSION: $=B2,  NOV. 2000
C
C   UPDATES:
C   OPTION TO EVALUATE B-FIELD VECTORS FROM GRIDADAP FILE FT29
C   FOR NON-ORTHOGONAL GRIDS
C
C   THIS CODE SEGMENT CONTAINES VARIOUS SUBROUTINES NEEDED FOR
C   INTERFACING THE EIRENE CODE TO PLASMA FLUID CODES.
C   IT READS GEOMETRICAL DATA (MESHES) FROM FILE FT30
C   AND PRODUCES THE EIRENE INPUT DATA (BLOCK 2).
C   IT READS PLASMA BACKGROUND DATA FROM FILE FT31 OR COMMON BLOCKS,
C   IT MAY (OPTIONAL) ALSO READ PLASMA DATA FROM FILE FT13
C   WRITTEN IN A PREVIOUS EIRENE RUN (E.G. IN ORDER TO ITERATE
C   IN SOME BACKGROUND SPECIES)
C   IT THEN PRODUCES INPUT DATA FOR EIRENE
C   INPUT BLOCK 5 (PLASMA DATA) AND BLOCK 7 (SURFACE RECYCLING SOURCES)
C
C
C   THIS PARTICULAR VERSION LINKS EIRENE TO THE B2   2D MULTIFLUID EDGE
C   PLASMA TRANSPORT CODE.
C
C   IT WAS WRITTEN BY D.REITER AND P.BOERNER, KFA-JUELICH
C   E-MAIL: D.REITER @ KFA-JUELICH.DE
C
C
C
C   MOST OF THE FORTRAN IN THIS CODE SEGMENT HAS BEEN DEVELOPED
C   UNDER KFA-NET CONTRACT NO. 428/90-8/FU-D
C
C   FINAL REPORT BY: D.REITER(1), P.BOERNER(1), B.KUEPPERS(1),
C                    M.BAELMANS(2) AND G.P.MADDISON(3)
C                    (1992)
C   1): KFA-JUELICH GMBH
C   2): UNIV. LEUVEN, ERM, KFA-JUELICH
C   3): AEA TECHNOLOGY, FUSION, CULHAM, UKAEA FUSION ASSOCIATION
C
*DK COUPLE
C
      SUBROUTINE INFCOP
C
C     THIS SUBROUTINE DEFINES THE PLASMA MODEL IN CASE OF A COUPLED
C     NEUTRAL-PLASMA CALCULATION
C
C     THE ENTRY "IF0COP" RECEIVES GEOMETRICAL INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF1COP" RECEIVES PLASMA INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF2COP" PREPARES THE SOURCE SAMPLING DISTRIBUTION
C     FROM THE EXTERNAL DATA, AND MAY OVERWRITE OTHER INPUT
C     DATA FROM BLOCKS 1 TO 13 AS WELL
C
C     THE ENTRIES "IF3COP, IF4COP" RETURN  RESULTS TO AN EXTERNAL CODE
C
      USE PRECISION
      USE PARMMOD
      USE BRASPOI
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CPLOT
      USE CINIT
      USE CPOLYG
      USE CGRID
      USE CZT1
      USE CTRCEI
      USE CCOUPL
      USE CGEOM
      USE CSDVI
      USE CSDVI_BGK
      USE CSDVI_COP
      USE COMPRT
      USE COMNNL
      USE COMSOU
      USE CSTEP
      USE CTEXT
      USE CLGIN
      USE COUTAU
      USE COMXS
      USE CSPEI
      USE CTRIG
      USE BRAEIR
      USE EIRBRA
      USE BRASCL

      IMPLICIT NONE
C
C  GEOMETRICAL DATA FROM GRIDADAP
      REAL(DP), ALLOCATABLE ::
     R  ALPHXB(:,:), ALPHYB(:,:), XAISO(:,:)

      REAL(DP), ALLOCATABLE, SAVE ::
     R  PUX(:),      PUY(:),      PVX(:),      PVY(:)

      INTEGER, ALLOCATABLE ::
     I  IAISO(:,:)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
      REAL(DP) :: SEES0(NSTRA), SEIS0(NSTRA)
      REAL(DP) :: CHPM(NPLS,NRAD), CHEEM(NRAD), CHEIM(NRAD),
     .          CHMOM(NPLS,NRAD)
      REAL(DP) :: DI(NPLS), VP(NPLS)
      REAL(DP) :: PPPL(NPLS,NRAD), CPPV(NCPV,NRAD), 
     .            EPPL(NRAD), EPEL(NRAD)
C
      REAL(DP) :: PUXE(NRAD), PUYE(NRAD), PUXN(NRAD), PUYN(NRAD),
     R          TORL(NSTRA,NGITT), EFLX(NSTRA),
     R          DUMMY(0:NDXP,0:NDYP),
     R          ESHT(NSTEP,NGITT), ORI(NSTEP,NGITT),
     R          SFNIT(0:NSTEP), SFEIT(0:NSTEP),
     R          SFEET(0:NSTEP), SHEAE(0:NSTEP), SHEAI(0:NSTEP)

      REAL(DP) :: SCALM, SCALE, SCALI, CHEIS, SEES, SEIS, TEST, 
     .          SFEISY, SFEESY, FTABRC1, FEELRC1, RECADD,
     .          EEADD, PIADD, SIGNUM, SMOCL, CHEES, EIADD, SNICL, 
     .          SSE, BALANI, BALANE, SSEE, SSN, SSI, BALANN, RE, RI,
     .          RN, TOTI, TOTE, TOTN, SFEENY, SFNINY, SFEIWX, 
     .          SFNIEX, SSNI, SSEI, SFNIWX, SFEIEX, SFEEEX, VVBC,
     .          UUBC, UPBC, RBC, UDBC, VL, V, T, BX, BY, BZ, BN,
     .          DELTE_PARA, DELTI_PARA, DELY, DELTI_PERP, TES, TIS,
     .          DELTE_PERP, ALX, ALE, ALW, ALS, ALN, AL, ETOT,
     .          RESSEE, FLX, ESUM, DR, VR, VTEST, EADD, EMAXW, SI,
     .          PARWI, PERWI, SUMM, SUMN, SUMEI, SUMEE, FLXI, CHP,
     .          CNDYNP, CHI, CHE, CS, STEP, THMAX, EESHT, EEMAX,
     .          RP1, DELX, PNORM, PVYS, PVXS, PUPV, RRBS, PUYS, PUXS,
     .          VPX, VPY, VT, PARW, PERW, PN1, OR, VPZ, GAMMA, CUR, TE,
     .          SFNISY, SFEEWX, SFEINY, PM1, SHEATH, RESSEI, DRR
      INTEGER :: NRWL(NSTRA)
      INTEGER :: J, IRC, JC, INC, IADD, IP, ITARG, IO, IFL, NPES,
     .           IIPLS, IG, IGITT, IEPLS, NPEC, NPBC, NPBS, NTGPRI,
     .           IT, I, IPRT, IAOT, IAIN, IREAD, IPL, INN,
     .           IFRST, ITRG, IMODE, IERROR, LTARG, IN, IX, IY, NEND,
     .           NINI, NCOPI, NPLP, NDX2, NRED, IO29, NDXY, IFIRST,
     .           ISTRAI, IRRC, K, IR, IIRC, ICPV, IF, IDEZ, I34, 
     .           NREC11, NEM
      INTEGER, INTENT(IN) :: ISTRAA, ISTRAE, NEW_ITER
C
      LOGICAL :: LSHORT, LSTOP, LSTP
C
C  READ PLASMA PARAMETERS, RESCALE THEM IF NECESSARY
C  AND TRANSFER THEM TO EIRENE VIA
C  EIRENE FUNCTION "PROFR"  THROUGH EQUIVALENCE ON ARRAY SMESTV
C
      REAL(DP), POINTER ::
     .  TEINTF(:),TIINTF(:,:),DIINTF(:,:),
     .  VXINTF(:,:),VYINTF(:,:),VZINTF(:,:),
     .  BXINTF(:),BYINTF(:),BZINTF(:),BFINTF(:),
     .  VLINTF(:),ADINTF(:,:)

      REAL(DP), ALLOCATABLE, SAVE ::
     . CHPS(:),    SNIS(:),    CHMOS(:),  SMOS(:),  SCALN(:),
     . SNIS0(:,:), SMOS0(:,:),
     . RESSNI(:),  RESSMO(:)

      INTEGER, ALLOCATABLE :: IHELP(:)
C
      CHARACTER(10) :: CHR
      CHARACTER(6)  :: CITARG
      CHARACTER(72) :: ZEILE
c slmod begin (sl)
      INTEGER :: IDUM1,IDUM2,IDUM3,I1,L,IS,JJ,J1,ICOUNT,ISTS,IADV,IALVI,
     .           NUMSURF
      REAL(DP) :: DEF,DEJ,TEF,TEI,SUM1,TOTVOL,CONV,RDUMD2P,RATIO2
      CHARACTER(12) :: CDUM1

c...  Allocate dynamically:
      REAL(DP)  SNID  (0:NDXP,0:NDYP,NFL ),
     R          PDENAD(0:NDXP,0:NDYP,NATM),
     R          PDENMD(0:NDXP,0:NDYP,NMOL),
     R          PDENID(0:NDXP,0:NDYP,NION),     
     R          PADDVD(0:NDXP,0:NDYP,NADV),
C additional variablecddess added by K. Krieger, IPP/96
     R          EDENAD(0:NDXP,0:NDYP,NATM),
     R          EDENMD(0:NDXP,0:NDYP,NMOL),
     R          EDENID(0:NDXP,0:NDYP,NION),
     R          HYDREC(0:NDXP,0:NDYP),
     R          ESOURC(0:NDXP,0:NDYP),
     R          SOURCM(0:NDXP,0:NDYP,NFL )
      REAL*8 
     .  MULREC(0:NDXP,0:NDYP,NFL),MULION(0:NDXP,0:NDYP,NFL),
     .  MULQER(0:NDXP,0:NDYP,NFL),MULQEI(0:NDXP,0:NDYP,NFL)
      REAL*8
     .  PINREC(NPLS,NRAD),PINQIR(NRAD),
     .  PINMPR(NPLS,NRAD),PINQER(NRAD)

c...  Need the SAVE?
      REAL(DP), ALLOCATABLE, SAVE ::
     .  BGKDI(:,:,:,:),BGKTI(:,:,:,:),BGKVX (:,:,:,:),
     .  BGKVY(:,:,:,:),BGKVZ(:,:,:,:)

c...  Allocate dynamically:
      REAL(DP) DNEB(0:NDXP,0:NDYP,NFL)

c...   For passing electron density to setup routines (currently 
c      out-of-order):
c      COMMON /DENICOM/ DEINTF 
c      REAL*8           DEINTF(NPLS,NRAD)

C...  TEMP: For D2+ density calculation:
      CHARACTER FILNAM*8,H123*4,REAC*9,CRC*3
      REAL*8 RH2PH2(0:8,0:8)
c slmod end
C
      DATA LTARG/0/
C
C
      SAVE
C
      ENTRY IF0COP
C
c slmod begin (sl)
      ALLOCATE (BGKDI(0:NDXP,0:NDYP,NFL,NBMLT))
      ALLOCATE (BGKTI(0:NDXP,0:NDYP,NFL,NBMLT))
      ALLOCATE (BGKVX(0:NDXP,0:NDYP,NFL,NBMLT))
      ALLOCATE (BGKVY(0:NDXP,0:NDYP,NFL,NBMLT))
      ALLOCATE (BGKVZ(0:NDXP,0:NDYP,NFL,NBMLT))

      BGKDI=0.0D0
      BGKTI=0.0D0
      BGKVX=0.0D0
      BGKVY=0.0D0
      BGKVZ=0.0D0
c...JUELICH-AIX
      PINREC=0.0D0
      PINMPR=0.0D0
      PINQIR=0.0D0
      PINQER=0.0D0
c slmod end
      LSHORT=.FALSE.
C
      GOTO 99990
C
C  TO INITIALIZE THE SHORT CYCLING, THE GEOMETRY HAS TO BE
C  DEFINED ONCE (ENTRY: INTER0)
C
      ENTRY INTER0
      LSHORT=.TRUE.
99990 CONTINUE
C
      IERROR=0
C
      IMODE=IABS(NMODE)
C
      IF (.NOT.LSHORT.AND.ITIMV.LE.1) THEN
        WRITE (6,*) '        SUBROUTINE INFCOP IS CALLED  '
C  READ INPUT DATA OF BLOCK 14
C  SAVE INPUT DATA OF BLOCK 14 FOR SHORT CYCLE ON COMMON CCOUPL
        CALL LEER(1)
        CALL ALLOC_CCOUPL(1)
        READ (IUNIN,'(5L1)') LSYMET,LBALAN
        IF (TRCINT)
     .  WRITE (6,*) ' LSYMET,LBALAN = ',LSYMET,LBALAN
        READ (IUNIN,'(3I6)') NFLA,NCUTB,NCUTL
        NCUTB_SAVE=NCUTB
        IF (TRCINT) THEN
          WRITE (6,*) ' NFLA,NCUTB,NCUTL = ',NFLA,NCUTB,NCUTL
          WRITE (6,*) ' IPLS,IFLB(IPLS),FCTE(IPLS),BMASS(IPLS)'
        ENDIF
        DO 20 IPL=1,NPLSI
          READ (IUNIN,'(2I6,2E12.4)') I,IFLB(IPL),FCTE(IPL),BMASS(IPL)
          IF (TRCINT)
     .    WRITE (6,*) IPL,IFLB(IPL),FCTE(IPL),BMASS(IPL)
20      CONTINUE
        READ (IUNIN,'(2I6)') NDXA,NDYA
        IF (TRCINT) WRITE (6,*) 'NDXA,NDYA ',NDXA,NDYA
C  NUMBER OF TARGET SOURCES ON B2 SURFACES: NTARGI
        READ (IUNIN,'(I6)') NTARGI
        WRITE (6,*) '        NTARGI= ',NTARGI
        CALL LEER(1)
        IF (NTARGI.GT.NSTEP) THEN
          CALL MASPRM ('NSTEP',5,NSTEP,'NTARGI',6,NTARGI,IERROR)
          WRITE (6,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT
        ENDIF
C  NUMBER OF PARTS PER TARGET SOURCE
        IF (NTARGI.GT.0) READ (IUNIN,'(12I6)') (NTGPRT(IT),IT=1,NTARGI)
        DO 22 IT=1,NTARGI
          IF (NTGPRT(IT).GT.NGITT) THEN
            NTGPRI=NTGPRT(IT)
            CALL MASPRM ('NGITT',5,NGITT,'NTGPRT',6,NTGPRI,IERROR)
            WRITE (6,*) 'EXIT CALLED FROM SUBR. INFCOP '
            CALL EXIT
          ENDIF
22      CONTINUE
C  ALL INDICES: AFTER INDEX MAPPING
C  NDT: INDEX OF X-CELL (EAST OR NORTH SURFACE OF BRAAMS CELL) OF TARGET
C  NINCT: DIRECTION OF OUTER TARGET NORMAL WITH RESPECT TO POSITIVE DIR.
C  NIXY: SOURCE ON Y SURFACE: NIXY=1; SOURCE ON X SURFACE: NIXY=2
C  NTIN,NTEN: SOURCE RANGE FROM GRIDPOINT NTIN TO GRIDPOINT NTEN
        IF (TRCINT)
     .  WRITE (6,*) '    IT,  NDT,NINCT, NIXY, NTIN, NTEN',
     .              ',NIFLG, NPTC,NSPZI,NSPZE,NEMOD'
        DO 30 IT=1,NTARGI
          DO 33 IPRT=1,NTGPRT(IT)
331         READ (IUNIN,'(A72)') ZEILE
            IREAD=1
            IF (ZEILE(1:1).EQ.'*') THEN
C             WRITE (6,......)
              GOTO 331
            ENDIF
            READ (ZEILE,'(12I6)') I,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                              NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                              NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                              NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                              NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IREAD=0
            NSPZI(IT,IPRT)=MAX0(1,NSPZI(IT,IPRT))
            NSPZE(IT,IPRT)=MIN0(NFLA,NSPZE(IT,IPRT))
            IF (NSPZE(IT,IPRT).LT.NSPZI(IT,IPRT)) THEN
              WRITE (6,*) 'WARNING FROM INFCOP: '
              WRITE (6,*) 'ITARG,IPRT : ',IT,IPRT
              WRITE (6,*) 'NSPZI,NSPZE MODIFIED TO 1,NFLA, RESP.'
              NSPZI(IT,IPRT)=1
              NSPZE(IT,IPRT)=NFLA
            ENDIF
            IF (TRCINT)
     .      WRITE (6,'(1X,12I6)') IT,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                               NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                               NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                               NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                               NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IF (NIXY(IT,IPRT).EQ.1) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NR1ST.OR.
     .            NTEN(IT,IPRT).GT.NR1ST) THEN
                WRITE (6,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT
              ENDIF
            ELSEIF (NIXY(IT,IPRT).EQ.2) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NP2ND.OR.
     .            NTEN(IT,IPRT).GT.NP2ND) THEN
                WRITE (6,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT
              ENDIF
            ENDIF
33        CONTINUE
          IF (TRCINT) CALL LEER(1)
30      CONTINUE
        READ (IUNIN,'(6E12.4)')  CHGP,CHGEE,CHGEI,CHGMOM
        IF (TRCINT) WRITE (6,*) 'CHGP,CHGEE,CHGEI,CHGMOM ',
     .                           CHGP,CHGEE,CHGEI,CHGMOM
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM B2 INTO EIRENE
C  HERE: B2 VOLUME TALLIES
        READ (IUNIN,'(I6)') NAINB
        NAIN = MAX(NAIN,NAINB)
        CALL ALLOC_CCOUPL(2)
        WRITE (6,*) '        NAINI = ',NAINB
        IF (NAINB.GT.NAIN) THEN
          CALL MASPRM ('NAIN',4,NAIN,'NAINB',5,NAINB,IERROR)
          WRITE (6,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT
        ENDIF
        IF (TRCINT.AND.NAINB.GT.0)
     .      WRITE (6,*) 'I,NAINS(IAIN),NAINT(IAIN)'
        DO 40 IAIN=1,NAINB
          READ (IUNIN,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
          READ (IUNIN,'(A72)') TXTPLS(IAIN,12)
          READ (IUNIN,'(2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          IF (TRCINT) THEN
            WRITE (6,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
            WRITE (6,'(1X,A72)') TXTPLS(IAIN,12)
            WRITE (6,'(1X,2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          ENDIF
40      CONTINUE
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM EIRENE INTO B2
C  HERE: EIRENE SURFACE TALLIES
        READ (IUNIN,'(I6)') NAOTB
        WRITE (6,*) '        NAOTI = ',NAOTB
        IF (NAOTB.GT.NLIMPS) THEN
          CALL MASPRM ('NLIMPS',6,NLIMPS,'NAOTB',5,NAOTB,IERROR)
          WRITE (6,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT
        ENDIF
        IF (TRCINT.AND.NAOTB.GT.0)
     .      WRITE (6,*) 'I,NAOTS(IAOT),NAOTT(IAOT)'
        DO 50 IAOT=1,NAOTB
          READ (IUNIN,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          IF (TRCINT) THEN
            WRITE (6,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          ENDIF
50      CONTINUE
      ENDIF
C
C READING BLOCK 14 FROM FORMATTED INPUT FILE (IUNIN) FINISHED
C
C
C  DEFINE ADDITIONAL TALLIES FOR COUPLING (UPDATED IN SUBR. UPTCOP
C                                              AND IN SUBR. COLLIDE)
      NCOPI=0
      IF (NMODE.GT.0) NCOPI=4
      NCPVI=NCOPI*NPLSI
      NCOP = NCOPI
C
C  CLEAR WORK ARRAY RWK FOR DATA TRANSFER INTO EIRENE
C
      NINI=1
      NEND=6+5*NPLS+NAIN

      IF (NCPVI.GT.NCPV) THEN
        WRITE (6,*) 'PARAMETER ERR. FROM INTERFACING SUBROUTINE INFCOP:'
        CALL MASPRM('NCOP',4,NCOP,'NCOPI',5,NCOPI,IERROR)
        CALL EXIT
      ENDIF
C
!      IF (NEND.GE.NIDV) THEN
!        WRITE (6,*) 'PARAMETER ERROR IN SUBR. INFCOP. NIDV TOO SMALL'
!        WRITE (6,*) 'CHECK IF NSMSTRA IS SET TO 0 '
!        CALL EXIT
!      ENDIF

!      SMESTV(NINI:NEND,:) = 0.D0
C
C SAVE SOME MORE INPUT DATA FOR SHORT CYCLE ON COMMON CCOUPL
      NDX = NDXA
      NDY = NDYA
      NFL = NFLA
      NDXP = NDX+1
      NDYP = NDY+1
      LNLPLG=NLPLG
      LNLDRF=NLDRFT
      LTRCFL=TRCFLE
      NSTRI=NSTRAI
      DO 60 ISTRA=1,NSTRAI
        LNLVOL(ISTRA)=NLVOL(ISTRA)
60    CONTINUE
      NMODEI=NMODE
      NFILNN=NFILEN
C
      IF (NCPVI.EQ.0) GOTO 70
      DO IPLS=1,NPLSI
        ICPVE(IPLS)=1
        ICPRC(IPLS)=1
        TXTTAL(IPLS,NTALM)=
     .  'ENERGY WEIGHTED CX RATE OF ATOMS WITH IPLS                  '
        TXTSPC(IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(IPLS,NTALM)='AMP                       '
C
        ICPVE(NPLSI+IPLS)=3
        ICPRC(NPLSI+IPLS)=1
        TXTTAL(NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM ATOMS, FOR IPLS             '
        TXTSPC(NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
        ICPVE(2*NPLSI+IPLS)=3
        ICPRC(2*NPLSI+IPLS)=2
        TXTTAL(2*NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM MOLECULES, FOR IPLS         '
        TXTSPC(2*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(2*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
        ICPVE(3*NPLSI+IPLS)=3
        ICPRC(3*NPLSI+IPLS)=3
        TXTTAL(3*NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM TEST IONS, FOR IPLS         '
        TXTSPC(3*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(3*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
      ENDDO
C
70    CONTINUE
C
C
C  TRANSFER GEOMETRY
C
      IF (.NOT.(INDGRD(1).EQ.6.OR.INDGRD(2).EQ.6.OR.INDGRD(3).EQ.6))
     .RETURN
C
      OPEN (UNIT=29,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 29
C
      OPEN (UNIT=30,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 30
C
C  READ IN DATA TO SET UP GEOMETRY FOR NEUTRAL GAS TRANSPORT CODE
C  STATEMENT NUMBER 1000 ---> 1999
C
C  AT PRESENT THE DATA COME FROM THE FILE FT30
C  THIS PART WILL HAVE TO BE MODIFIED AS SOON AS BRAAMS PROVIDES
C  CELL VERTICES AND CUT DESCRIPTION
C
1000  CONTINUE
C
C  ACTUAL MESH SIZE USED IN THIS RUN: FIRST CARD OF GEOMETRY DATA FILE
C
C
      IF (NDYA.NE.NR1ST-1.OR.NDYA.GT.NDY) THEN
        WRITE (6,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (6,*) ' NDYA MUST BE = NR1ST-1 AND <= NDY'
        WRITE (6,*) ' NDYA,NR1ST-1,NDY = ',NDYA,NR1ST-1,NDY
        CALL EXIT
      ELSEIF (NDXA.NE.NP2ND-1.OR.NDXA.GT.NDX) THEN
        WRITE (6,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (6,*) ' NDXA MUST BE = NP2ND-1 AND <= NDX'
        WRITE (6,*) ' NDXA,NP2ND-1,NDX = ',NDXA,NP2ND-1,NDX
        CALL EXIT
      ENDIF
C
C  EACH FLUXSURFACE IS GIVEN BY A POLYGON OF LENGTH NDXA+1, I.E.
C  WITH NDXA SEGMENTS. THERE ARE NDYA+1 POLYGONS
C  READ IN POLYGONS CELL BY CELL. IX IS INDEX ALONG ONE POLYGON
C                                 IY IS INDEX PERP. TO THE POLYGONS
C
C
C         DIRECTION  OF INCREASING IY ("RADIAL")
C PERP.      ^                 ^ PERP.
C POLYG.NO.IX|      (VV,SY,    | POLYG.NO.IX+1
C            |       FNIY)     |
C            |       ^         |
C            |       |         |
C         X3,Y3      |        X4,Y4
C            ________X__________   -----> ALONG POLYGON NO. (IY+1)
C            |  CELL NO.(IX,IY)|
C            |                 |
C            |       X         X-----> (UU,UP,FNIX,SX)
C            |                 |
C            | (TE,TI,NI,PR,RR,|
C            |  VOL,GX,GY)     |
C            -------------------   -----> ALONG POLYGON NO. (IY)
C         X1,Y1               X2,Y2
C                                         DIRECTION OF INCREASING IX ("POLOIDAL")
C
C
      NPOINT = 0
      ALLOCATE (PUX(NRAD))
      ALLOCATE (PUY(NRAD))
      ALLOCATE (PVX(NRAD))
      ALLOCATE (PVY(NRAD))
C
c slmod begin (sl)
c...  Call customized DIVIMP geometry transfer file if GEOMOPT set.  Perhaps
c     just replace GEOMD with GEODIV since DIVIMP is no longer used with
c     a version of EIRENE that reads the SONNET file:
      IF (GEOMOPT.EQ.1) THEN
        CALL GEODIV(NDXA,NDYA,NPLP,NR1ST,PUX,PUY,PVX,PVY,NBMLT)
      ELSE
        CALL GEOMD (NDXA,NDYA,NPLP,NR1ST,PUX,PUY,PVX,PVY)
      ENDIF
c
c      CALL GEOMD (NDXA,NDYA,NPLP,NR1ST,
c     .            PUX,PUY,PVX,PVY)
c slmod end
C
      IF (NDXA+1.NE.NRPLG) THEN
        WRITE (6,*) 'ERROR IN INFCOP: NRPLG.NE.NDXA+1'
        WRITE (6,*) 'NDXA+1,NRPLG ',NDXA+1,NRPLG
        CALL EXIT
      ENDIF
      IF (NPLP.NE.NPPLG) THEN
        WRITE (6,*) 'ERROR IN INFCOP: NPPLG.NE.NPLP'
        WRITE (6,*) 'NPLP,NPPLG ',NPLP,NPPLG
        CALL EXIT
      ENDIF
C
C  READ ADDITIONAL GEOMETRICAL DATA (MESH DISTORTION, DEAD CELLS)
C  SAME FORMAT AS FORT.31, I.E., INDEX MAPPING MAY BE NECESSARY
      READ (29,'(A)',IOSTAT=IO29) CHR
      IF (IO29.EQ.0) THEN
        REWIND 29
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED

        ALLOCATE (ALPHXB(0:NDXP,0:NDYP))
        ALLOCATE (ALPHYB(0:NDXP,0:NDYP))
        ALLOCATE (XAISO(0:NDXP,0:NDYP))
        ALLOCATE (IAISO(0:NDXP,0:NDYP))

        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHXB)
        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHYB)
        DO IY=NDYA+1,0,-1
          READ (29,'(500I1)') (IAISO(IX,IY),IX=0,NDX2+1)
        ENDDO
C
        IF (NCUTL.EQ.NCUTB) GOTO 1020
C
C CONVERT IAISO TO REAL, FOR INDMAP 
        XAISO=IAISO
        CALL INDMAP (XAISO,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
C IAISO BACK TO INTEGER
        IAISO=XAISO
C
        CALL INDMAP (ALPHXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
        CALL INDMAP (ALPHYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
1020    CONTINUE
C
        DO IY=1,NDYA
          DO IX =1,NDXA
            IN=IY+(IX-1)*NR1ST
            ALE=ALPHXB(IX,IY)
            ALW=ALPHXB(IX-1,IY)
            IF (MAX(ALE,ALW)-MIN(ALE,ALW) > PIA) THEN
              AL=MIN(ALE,ALW)
              ALW=MAX(ALE,ALW)
              ALE=AL+PI2A
            END IF
            ALN=ALPHYB(IX,IY)
            ALS=ALPHYB(IX,IY-1)
            ALX=0.25D0*(ALE+ALW+ALN+ALS)
            PUX(IN)=COS(ALX)
            PUY(IN)=SIN(ALX)
            PUXE(IN)=COS(ALE)
            PUYE(IN)=SIN(ALE)
            PUXN(IN)=COS(ALN)
            PUYN(IN)=SIN(ALN)
            PVX(IN)=-PUY(IN)
            PVY(IN)=PUX(IN)
          END DO
        END DO
C
        DO IY=1,NDYA
          DO IX =1,NDXA
            IN=IY+(IX-1)*NR1ST
            NSTGRD(IN)=ABS(IAISO(IX,IY)-1)
          END DO
        END DO

        DEALLOCATE (ALPHXB)
        DEALLOCATE (ALPHYB)
        DEALLOCATE (XAISO)
        DEALLOCATE (IAISO)
C
      ELSE
        CALL LEER(1)
        WRITE (6,*) ' NO FILE FORT.29 WITH MODIFIED GRID INFO. FOUND '
        WRITE (6,*) ' OLD VERSION CALCULATION MAGN. FIELD FROM ',
     .               'GRID IS USED '
        WRITE (6,*) ' GRID IS ASSUMED TO BE ORTHOGONAL '
      END IF
C
C  TRANSFER FLAGS
C
      NAINI=NAINB
C
      RETURN
C
C   GEOMETRY DEFINITION PART FINISHED
C
      ENTRY IF1COP
C
C   NOW READ THE PLASMA STATE GIVEN BY BRAAMS
C   AT PRESENT THE DATA COME FROM THE FILE FT31
C   FURTHERMORE: SCALING TO EIRENE UNITS AND INDEX MAPPING
C   STATEMENT NO. 2000 ---> 2999
C
C  IN CASE OF "SHORT CYCLE" THE PLASMA STATE IS TRANSFERRED VIA COMMON
C
      LSHORT=.FALSE.
      CALL LEER(1)
      WRITE (6,*) 'IF1COP CALLED '
C  SKIP READING PLASMA, IF NLPLAS
      IF (NLPLAS) GOTO 2100
C
      GOTO 99991
C
C  IN CASE OF "SHORT CYCLE" OR TIME DEP. MODE
C  THE PLASMA STATE IS TRANSFERRED VIA COMMON
C  ONLY SCALING TO EIRENE UNITS AND INDEX MAPPING NEEDS TO BE DONE HERE
C
      ENTRY INTER1
      LSHORT=.TRUE.
      GOTO 2100
C
99991 CONTINUE
C
C
C  TRANSFER PROFILES
C
c slmod begin
c...  INDPRO=7 is used when plasma quantities are specified on the
c     vacuum grid:
      IF (.NOT.(INDPRO(1).EQ.6.OR.INDPRO(2).EQ.6.OR.INDPRO(3).EQ.6.OR.
     .          INDPRO(4).EQ.6.OR.
     .          INDPRO(1).EQ.7.OR.INDPRO(2).EQ.7.OR.INDPRO(3).EQ.7.OR.
     .          INDPRO(4).EQ.7)) RETURN
c
c      IF (.NOT.(INDPRO(1).EQ.6.OR.INDPRO(2).EQ.6.OR.INDPRO(3).EQ.6.OR.
c     .          INDPRO(4).EQ.6)) RETURN
c slmod end
C
      IF (NLPLAS) WRITE (6,*) 'PLASMA DATA EXPECTED ON BRAEIR'
      IF (.NOT.NLPLAS) WRITE (6,*) 'PLASMA DATA EXPECTED ON FORT.31'
C
      OPEN (UNIT=31,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 31
C
      IF (NFLA.GT.NFL) THEN
        WRITE (6,*) ' PARAMETER ERROR DETECTED IN INFCOP '
        WRITE (6,*) ' NFLA MUST BE <= NFL'
        WRITE (6,*) ' NFLA,NFL = ',NFLA,NFL
        CALL EXIT
      ENDIF

!PB      IF (.NOT.ALLOCATED(DNIB)) CALL ALLOC_BRAEIR
      CALL ALLOC_BRAEIR(NDXP,NDYP,NFL)
C
C  B2-BRAAMS CODE SPECIFIC BEGIN
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,DNIB)
c slmod begin
c...  Passing electron density to EIRENE from DIVIMP:
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,DNEB)
c slmod end
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UUB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,VVB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TEB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TIB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,PRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UPB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,RRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIXB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEYB)
c slmod begin
c...  Should not be loading based on NFL?
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,MULREC)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,MULION)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,MULQER)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,MULQEI)
c...  NBMLT is not the standard parameter for the degree of toroidal
c     resolution on the standard grid, but I am using it as such
c     in order to avoid full toroidal resolution (NLTRA+NLTOR):
      DO IT=1,NBMLT 
        CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,BGKDI(0,0,1,IT))
        CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,BGKTI(0,0,1,IT))
        CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,BGKVX(0,0,1,IT))
        CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,BGKVY(0,0,1,IT))
        CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,BGKVZ(0,0,1,IT))
      ENDDO
c slmod end
C
C  OPTIONAL ARRAYS: VOLB, BFELDB,FNIX_YB, FNIY_XB
      VOLB = 0.D0
      BFELDB = 0.D0
      FNIX_YB = 0.D0
      FNIY_XB = 0.D0
c slmod begin
c...  These quantities are not currently passed from DIVIMP, 
c     but I guess they should be!?
      WRITE(0,*) 'NOT PASSING VOLB,BFELDB,FNIX_YB OR FNIY_XB '//
     .           'FROM DIVIMP'
c
cC  CELL VOLUMES AS USED IN B2
c      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,VOLB)
cC  MAGNETIC FIELD STRENGTH (TESLA)
c      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,BFELDB)
cC  X-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A Y-FLUX TOO
c      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIX_YB)
cC  Y-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A X-FLUX TOO
c      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIY_XB)
c slmod end
C
2100  CONTINUE
C
C  NO INDEX MAPPING REQUIRED, IF NEW TIMESTEP ON SAME PLASMA
C  BRAEIR NOT MODIFIED SINCE LAST CALL TO IF1COP
      IF (NCUTB_SAVE.EQ.NCUTL) THEN
        WRITE (6,*) 'NO INDEX MAPPING DONE'
      ELSE
        WRITE (6,*) 'INDEX MAPPING DONE ', NCUTB_SAVE,NCUTB,NCUTL
      ENDIF
      CALL LEER(1)
C
C  INDEX MAPPING : NDY DIRECTION
C
C  INDEX MAPPING : NDX DIRECTION
C  SET THE NUMBER OF COLUMNS PER CUT FROM NCUTB (BRAAMS IMPLEMENTATION)
C  TO WHAT IS FOUND FROM THE EIRENE GEOMETRY FILE (NCUTL)
C
      IF (NCUTL.EQ.NCUTB_SAVE) GOTO 2101
C  FIRST THE ZONE CENTERED DATA
      CALL INDMAP (DNIB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
c slmod begin
c...  Assign electron density passed from DIVIMP:
      CALL INDMAP (DNEB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
c slmod end
      CALL INDMAP (TEB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (TIB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (RRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (PRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
c slmod begin
      CALL INDMAP (MULREC,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (MULION,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (MULQER,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (MULQEI,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
c...  Cavalier use of NBMLT (there should be a parameter check that NBLMT
c     is valid for the array declarations):
      DO IT=1,NBMLT 
        CALL INDMAP (BGKDI(0,0,1,IT),DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPLP)
        CALL INDMAP (BGKTI(0,0,1,IT),DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPLP)
        CALL INDMAP (BGKVX(0,0,1,IT),DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPLP)
        CALL INDMAP (BGKVY(0,0,1,IT),DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPLP)
        CALL INDMAP (BGKVZ(0,0,1,IT),DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPLP)
      ENDDO
c slmod end
C  NOW THE SURFACE CENTERED DATA
      CALL INDMAP (FNIXB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIYB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UUB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (VVB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UPB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (VOLB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (BFELDB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIX_YB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIY_XB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
C
2101  CONTINUE
C
C  INDICATE, THAT NOW BRAEIR CONTAINS DATA AFTER INDEX-MAPPING
      NCUTB_SAVE=NCUTL
C
C  RESET 2D ARRAYS ONTO 1D EIRENE ARRAYS, RESCALE TO EIRENE UNITS
C  AND CONVERT BRAAMS VECTORS INTO CARTHESIAN EIRENE VECTORS
C
      SMESTV(NINI:NEND,:) = 0.D0
C
      TEINTF => SMESTV(1+0+0*NPLS             , :)
      TIINTF => SMESTV(1+1+0*NPLS : 1+0+1*NPLS, :)
      DIINTF => SMESTV(1+1+1*NPLS : 1+0+2*NPLS, :)
      VXINTF => SMESTV(1+1+2*NPLS : 1+0+3*NPLS, :)
      VYINTF => SMESTV(1+1+3*NPLS : 1+0+4*NPLS, :)
      VZINTF => SMESTV(1+1+4*NPLS : 1+0+5*NPLS, :)
      BXINTF => SMESTV(1+1+5*NPLS             , :)
      BYINTF => SMESTV(1+2+5*NPLS             , :)
      BZINTF => SMESTV(1+3+5*NPLS             , :)
      BFINTF => SMESTV(1+4+5*NPLS             , :)
      VLINTF => SMESTV(1+5+5*NPLS             , :)
      ADINTF => SMESTV(1+6+5*NPLS : 6+5*NPLS+NAIN, :)
c slmod begin
c...  Assign data to additional cells.  Move up to where the rest 
c     of the plasma file is read, and copy into local variables, 
c     and then assign to DIINTF, etc.:
      READ(31,'(A10)',ERR=2099,END=2099) CDUM1
      IF (CDUM1(1:10).EQ.' ADDITIONA') THEN
        READ(31,*) 
        DO IPLS = 1, NPLSI
          READ(31,*)
          DO IN = NSURF+1, NSBOX
            READ(31,*)
     .        IDUM1,
     .        DIINTF(IPLS,IN),TIINTF(IPLS,IN),
     .        VXINTF(IPLS,IN),VYINTF(IPLS,IN),VZINTF(IPLS,IN)
c...        Set the bulk electron temperature to the temperature
c           of the first bulk ion species.  As mentioned elsewhere,
c           the assumption that D+ is the first species needs to be
c           removed:
            IF (IPLS.EQ.1.AND.IN.GT.NSURF+1) TEINTF(IN)=TIINTF(IPLS,IN)
          ENDDO
        ENDDO
      ELSE
        BACKSPACE 31
      ENDIF
2099  CONTINUE
c...  Load time-to-ionisation parameters from the transfer file (out-of-order):
c      CALL USRTI0
c slmod end
C
C  UNITS CONVERSION FACTORS
      T=1./ELCHA
      V=1.E2
      VL=1.E6
      DO 2105 IPLS=1,NPLSI
        D(IPLS)=1.E-6*FCTE(IPLS)
        FL(IPLS)=ELCHA*FCTE(IPLS)
2105  CONTINUE
C
      DO 2110 IY=1,NDYA
        DO 2120 IX =1,NDXA
          IN=IY+(IX-1)*NR1ST
          TEINTF(IN)=TEB(IX,IY)*T
C
C  ONLY ONE ION TEMPERATURE AVAILABLE FROM PLASMA FLUID CODE,
C  SEE LOOP 2150 BELOW
          TIINTF(1,IN)=TIB(IX,IY)*T
C
          BX=PUX(IN)*RRB(IX,IY)+PVX(IN)*0.
          BY=PUY(IN)*RRB(IX,IY)+PVY(IN)*0.
          BZ=SQRT(1.-RRB(IX,IY)**2)
          BN=SQRT(BX*BX+BY*BY+BZ*BZ)
c slmod begin
          BXINTF(IN)=BX/(BN+EPS10)
          BYINTF(IN)=BY/(BN+EPS10)
          BZINTF(IN)=BZ/(BN+EPS10)
c...      Should be referencing IRRC (or something).  The "1" works at present, but 
c         only because the first bulk ion in the EIRENE input file is D+ (standard):
          TABRCM(1,IN)=MULREC(IX,IY,1)
          TABREM(1,IN)=MULQER(IX,IY,1)
          TABDSM(1,IN)=MULION(IX,IY,1)
          TABDEM(1,IN)=MULQEI(IX,IY,1)
c
c          BXINTF(IN)=BX/BN
c          BYINTF(IN)=BY/BN
c          BZINTF(IN)=BZ/BN
c slmod end
          VLINTF(IN)=VOLB(IX,IY)*VL
2120    CONTINUE
2110  CONTINUE
C
C  SET SAME ION TEMPERATURE FOR ALL EIRENE BACKGROUND SPECIES
C
      DO 2150 IPLS=1,NPLSI
      DO 2150 IY=1,NDYA
        DO 2150 IX =1,NDXA
          IN=IY+(IX-1)*NR1ST
          TIINTF(IPLS,IN)=TIINTF(1,IN)
2150  CONTINUE
C
      IREAD=0
      DO 2200 IPLS=1,NPLSI
        IF (IFLB(IPLS).GT.0) THEN
          DO 2201 IFL=1,NFLA
            IF (IFLB(IPLS).NE.IFL) GOTO 2201
            DO 2210 IY=1,NDYA
              DO 2220 IX = 1,NDXA
                IN=IY+(IX-1)*NR1ST
                DIINTF(IPLS,IN)=DNIB(IX,IY,IFL)*D(IPLS)
c slmod begin
c...             Specify the electron density separately from the bluk ion
c                density (out-of-order):
c                DEINTF(IPLS,IN)=DNEB(IX,IY,IFL)*D(IPLS)
c slmod end
                UUBC=0.5*(UUB(IX-1,IY,IFL)+UUB(IX,IY,IFL))
                UPBC=0.5*(UPB(IX-1,IY,IFL)+UPB(IX,IY,IFL))
                VVBC=0.5*(VVB(IX,IY-1,IFL)+VVB(IX,IY,IFL))
C  UDBC: DIAMAGNETIC VELOCITY, SHOULD BE ZERO IN B2, AND NONZERO IN EB2
C        NOTE: IN LINEAR DEVICES: RRB=1
                IF (RRB(IX,IY).LT.1.D0) THEN
                  RBC=SQRT(1.-RRB(IX,IY)**2)
                  UDBC=1./RBC*(UUBC-RRB(IX,IY)*UPBC)
                ELSE
                  RBC=0.
                  UDBC=0.
                ENDIF
                VXINTF(IPLS,IN)=(PUX(IN)*UUBC+PVX(IN)*VVBC)*V
                VYINTF(IPLS,IN)=(PUY(IN)*UUBC+PVY(IN)*VVBC)*V
                VZINTF(IPLS,IN)=(RBC*UPBC-RRB(IX,IY)*UDBC)*V
2220          CONTINUE
2210        CONTINUE
C  EIRENE BACKGROUND SPECIES "IPLS" FILLED WITH B2 DATA "IFL"
2201      CONTINUE
c slmod begin
C       Limited data (BGK relevant data only) for "IPLS" in plasma code
C       files.  The format or values of this data was not altered from that of the 
c       previous EIRENE run (the "-20" shift should be replaced with something
c       better).  See also the MODUSR routine:
        ELSEIF (IFLB(IPLS).LT.-20) THEN
          DO IT=1,NBMLT
            DO IY=1,NDYA
              DO IX =1,NDXA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                DIINTF(IPLS,IN)=BGKDI(IX,IY,IPLS,IT)
                VXINTF(IPLS,IN)=BGKVX(IX,IY,IPLS,IT)
                VYINTF(IPLS,IN)=BGKVY(IX,IY,IPLS,IT)
                VZINTF(IPLS,IN)=BGKVZ(IX,IY,IPLS,IT)
                TIINTF(IPLS,IN)=BGKTI(IX,IY,IPLS,IT)
              ENDDO
            ENDDO
          ENDDO
c slmod end
C  NO DATA FOR "IPLS" IN B2 FILES
        ELSEIF (IFLB(IPLS).EQ.-13) THEN
C  READ DATA FOR "IPLS" FROM EIRENE DUMP FILE FT13
          IF (IREAD.EQ.0) THEN
            OPEN (UNIT=13,ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
            REWIND 13
            READ (13,IOSTAT=IO) TEIN,TIIN,DEIN,DIIN,VXIN,VYIN,VZIN
            IREAD=1
            IF (TRCFLE) WRITE (6,*) 'READ 13: RCMUSR, IO= ',IO
            CLOSE (UNIT=13)
          ENDIF
          IF (IO.EQ.0) THEN
            DIINTF(IPLS,:)=DIIN(IPLS,:)
            VXINTF(IPLS,:)=VXIN(IPLS,:)
            VYINTF(IPLS,:)=VYIN(IPLS,:)
            VZINTF(IPLS,:)=VZIN(IPLS,:)
            TIINTF(IPLS,:)=TIIN(IPLS,:)
          ENDIF
        ELSE
C  SET PARAMETERS FOR SPECIES IPLS TO ZERO
C  NOTHING TO BE DONE HERE
        ENDIF
2200  CONTINUE
c slmod begin
      DEALLOCATE (BGKDI)
      DEALLOCATE (BGKTI)
      DEALLOCATE (BGKVX)
      DEALLOCATE (BGKVY)
      DEALLOCATE (BGKVZ)
c slmod end
C  B2-BRAAMS CODE SPECIFIC END
C
C
C  READ OTHER B2 ARRAYS INTO EIRENE, FOR PRINTOUT AND PLOTTING
C
      DO 2300 IAIN=1,NAINB
        IF (NAINT(IAIN).EQ.1.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2321 IY=1,NDYA
          DO 2321 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=DNIB(IX,IY,NAINS(IAIN))
2321      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.2.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2322 IY=1,NDYA
          DO 2322 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=UUB(IX,IY,NAINS(IAIN))
2322      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.3.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2323 IY=1,NDYA
          DO 2323 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=VVB(IX,IY,NAINS(IAIN))
2323      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.6) THEN
          DO 2326 IY=1,NDYA
          DO 2326 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=PRB(IX,IY)
2326      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.7.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2327 IY=1,NDYA
          DO 2327 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=UPB(IX,IY,NAINS(IAIN))
2327      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.8) THEN
          DO 2328 IY=1,NDYA
          DO 2328 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=RRB(IX,IY)
2328      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.9.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2329 IY=1,NDYA
          DO 2329 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FNIXB(IX,IY,NAINS(IAIN))+
     .                      FNIX_YB(IX,IY,NAINS(IAIN))
2329      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.10.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2330 IY=1,NDYA
          DO 2330 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FNIYB(IX,IY,NAINS(IAIN))+
     .                      FNIY_XB(IX,IY,NAINS(IAIN))
2330      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.11) THEN
          DO 2331 IY=1,NDYA
          DO 2331 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEIXB(IX,IY)
2331      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.12) THEN
          DO 2332 IY=1,NDYA
          DO 2332 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEIYB(IX,IY)
2332      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.13) THEN
          DO 2333 IY=1,NDYA
          DO 2333 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEEXB(IX,IY)
2333      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.14) THEN
          DO 2334 IY=1,NDYA
          DO 2334 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEEYB(IX,IY)
2334      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.15) THEN
          DO 2335 IY=1,NDYA
          DO 2335 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=VOLB(IX,IY)
2335      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.16) THEN
          DO 2336 IY=1,NDYA
          DO 2336 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=BFELDB(IX,IY)
2336      CONTINUE
        ENDIF
2300  CONTINUE
C
      RETURN
C
2999  CONTINUE
C
C  PLASMA PROFILES ARE NOW READ IN
C
      ENTRY IF2COP(ITRG)
      ITARG=ITRG
      IF (ITARG.GT.NTARGI) THEN
        CALL LEER(1)
        WRITE (6,*) 'SOURCE DATA FOR STRATUM ISTRA= ',ITARG
        WRITE (6,*) 'CANNOT BE DEFINED IN IF2COP. CHANGE INDSRC(ISTRA)'
        CALL LEER(1)
        RETURN
      ENDIF
C
C  NEXT DEFINE FLUXES, TEMPERATURES AND VELOCITIES AT THE TARGETS
C  (FLUXES IN AMP/(CM ALONG TARGET), TEMPERATURES IN EV, VELOCITIES IN CM/SEC)
C   FNIXB*FL (FNIYB*FL) ARE GIVEN IN AMP
C  STATEMENT NO 3000 ---> 3999
C
3000  CONTINUE
C
      IF (TRCINT.AND.LTARG.EQ.0) THEN
        LTARG=1
        WRITE (6,*) 'ITARG: TARGET NUMBER '
        WRITE (6,*) 'IPRT : SUBSECTION OF TARGET '
        WRITE (6,*) 'NPBS : BRAAMS (SURFACE) X-CELL INDEX OF TARGET '
        WRITE (6,*) 'NPBC : BRAAMS (ZONE) P-CELL INDEX OF TARGET '
        WRITE (6,*) 'NPES : POLOIDAL SURFACE INDEX OF TARGET'
        WRITE (6,*) '       IN EIRENE MESH'
        WRITE (6,*) 'NPEC : 1ST POLOIDAL CELL INDEX OF EIRENE MESH'
        WRITE (6,*) '       SEEN BY MONTE CARLO HISTORIES'
      ENDIF
C
      DO 3005 IPLS=1,NPLSI
      DO 3005 IGITT=1,NGITT
        FLSTEP(IPLS,ITARG,IGITT)=0.
3005  CONTINUE
C
      RRSTEP(ITARG,1)=0.
      IG=0
      IIPLS=NPLSI
      IEPLS=1
      DO 3040 IPRT=1,NTGPRT(ITARG)
C  NINCT= 1: PLASMA FLUX IN SAME   DIRECTION AS B2 CO-ORDINATE
C  NINCT=-1: PLASMA FLUX IN OPPOS. DIRECTION AS B2 CO-ORDINATE
C  BRAAMS X-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (SURFACE CENTERED, EAST OR NORTH) (AFTER INDEX MAPPING)
C  (E.G. SURFACE NO.0 AND SURFACE NO. NX) AT TARGETS.
        NPBS=NDT(ITARG,IPRT)
C  BRAAMS P-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (ZONE CENTERED) (AFTER INDEX MAPPING)
C
C  THIS LINE, IF B2-BOUNDARY CONDITIONS ARE COMPUTED FROM GUARD CELLS
C  (E.G. CELL NO.0 AND CELL NO. NX+1) AT TARGETS.
        NPBC=NPBS+MAX0(0,NINCT(ITARG,IPRT))
C
C  1ST EIRENE CELL ALONG TARGET
        NPEC=NPBS-MIN0(0,NINCT(ITARG,IPRT))
C  EIRENE SURFACE NUMBER AT TARGET
        NPES=NPBS+1
        IF (TRCINT) THEN
          WRITE (6,*) 'ITARG,IPRT,NPBS,NPBC,NPES,NPEC ',
     .                 ITARG,IPRT,NPBS,NPBC,NPES,NPEC
        ENDIF
C
C  FIRST: SOURCES AT POLOIDAL (Y) SURFACES (EAST OR WEST CELL FACES)
        IF (NIXY(ITARG,IPRT).EQ.2) GOTO 3020
C
        DO IY=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(NPBC,IY)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  RRSTEP IS THE ARC LENGTH ALONG THE TARGET (CM)
c slmod begin
          IF (GRIDOPT.EQ.1) THEN
            RRSTEP(ITARG,IG+1) = RRSTEP(ITARG,IG) +
     .                      SQRT((XVERT(IY,NPES,2)-XVERT(IY,NPES,1))**2+
     .                           (YVERT(IY,NPES,2)-YVERT(IY,NPES,1))**2)
c...        TEMP:
            DUM = RRSTEP(ITARG,IG) +
     .             SQRT((XPOL(IY+1,NPES)-XPOL(IY,NPES))**2+
     .                  (YPOL(IY+1,NPES)-YPOL(IY,NPES))**2)
            CALL CHECKNUM('ZOLA1',IG,NPES,RRSTEP(ITARG,IG+1),DUM)
          ELSE
            RRSTEP(ITARG,IG+1)= RRSTEP(ITARG,IG) +
     .                         SQRT((XPOL(IY+1,NPES)-XPOL(IY,NPES))**2+
     .                              (YPOL(IY+1,NPES)-YPOL(IY,NPES))**2)
          ENDIF
c
c          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
c     .                       SQRT((XPOL(IY+1,NPES)-XPOL(IY,NPES))**2+
c     .                            (YPOL(IY+1,NPES)-YPOL(IY,NPES))**2)
c slmod end
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
          IRSTEP(ITARG,IG)=IY
          IPSTEP(ITARG,IG)=NPEC
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=200000+NPES
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
c slmod begin
          IF (GRIDOPT.EQ.1) THEN
            TORL(ITARG,IG)=PIA*(XVERT(IY,NPES,2)+XVERT(IY,NPES,1))
c...        TEMP:
            DUM = 2.*PIA*0.5*(XPOL(IY+1,NPES)+XPOL(IY,NPES))
            CALL CHECKNUM('ZOLA2',ITARG,IG,TORL(ITARG,IG),DUM)
          ELSE
            TORL(ITARG,IG)=2.*PIA*0.5*(XPOL(IY+1,NPES)+XPOL(IY,NPES))
          ENDIF
c
c           TORL(ITARG,IG)=2.*PIA*0.5*(XPLG(IY+1,NPES)+
c    .                                 XPLG(IY,NPES))
c slmod end
          DO 3013 IPLS=1,NPLSI
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLS,ITARG,IG) = TIB(NPBC,IY)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE 
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3013
            DISTEP(IPLS,ITARG,IG)=DNIB(NPBC,IY,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELY=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELY.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                                FNIXB(NPBS,IY,IFL))*FL(IPLS)/DELY
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
C  USE SIGN FROM "MAIN" CONTRIBUTION TO DECIDE ORIENTATION OF SEC. CONTR.
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIX_YB(NPBS,IY,IFL))*
     .                   FL(IPLS)/DELY
                ENDIF
C  SET ION ENERGY FLUXES FROM B2-BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLS,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG)+
     .                                  FL(IPLS)/DELY*
     .            (TIS*delti_perp*ABS(Fnix_yb(npbs,iy,ifl))+
     .             TIS*delti_para*ABS(fnixb  (npbs,iy,ifl))+
     .             TES*delte_para*ABS(fnixb  (npbs,iy,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PV VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        DATA FOR POLOIDAL POLYGON NPES
            IN=IY+(NPEC-1)*NR1ST
c slmod begin
            IF (GRIDOPT.EQ.1) THEN
              PVXS =XVERT(IY,NPES,2)-XVERT(IY,NPES,1)
              PVYS =YVERT(IY,NPES,2)-YVERT(IY,NPES,1)
c...          TEMP:
              DUM =XPOL(IY+1,NPES)-XPOL(IY,NPES)
              CALL CHECKNUM('ZOLA3',IY,NPES,PVXS,DUM)
              DUM =YPOL(IY+1,NPES)-YPOL(IY,NPES)
              CALL CheckNum('ZOLA3.1',IY,NPES,PVYS,DUM)
            ELSE
              PVXS=XPOL(IY+1,NPES)-XPOL(IY,NPES)
              PVYS=YPOL(IY+1,NPES)-YPOL(IY,NPES)
            ENDIF
c
c            PVXS=XPOL(IY+1,NPES)-XPOL(IY,NPES)
c            PVYS=YPOL(IY+1,NPES)-YPOL(IY,NPES)
c slmod end
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
C  ORTHONORMALIZE PU VECTOR WITH RESPECT TO PV
            PUPV=PUX(IN)*PVXS+PUY(IN)*PVYS
            PUXS=PUX(IN)-PUPV*PVXS
            PUYS=PUY(IN)-PUPV*PVYS
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
            VXSTEP(IPLS,ITARG,IG)=
     .            (PUXS*UUB(NPBS,IY,IFL)+PVXS*VVB(NPBS,IY,IFL))*V
            VYSTEP(IPLS,ITARG,IG)=
     .            (PUYS*UUB(NPBS,IY,IFL)+PVYS*VVB(NPBS,IY,IFL))*V
            RRBS=UUB(NPBS,IY,IFL)/(UPB(NPBS,IY,IFL)+EPS60)
            VZSTEP(IPLS,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(NPBS,IY,IFL))*V
3013      CONTINUE
        ENDDO
C
        GOTO 3030
C
3020    CONTINUE
C
C  SECOND: SOURCES AT RADIAL (X) SURFACES
C
        DO IX=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(IX,NPBC)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
c slmod begin - grid
           IF (GRIDOPT.EQ.1) THEN
             RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .                  SQRT((XVERT(NPES,IX+1,1)-XVERT(NPES,IX,1))**2+
     .                       (YVERT(NPES,IX+1,1)-YVERT(NPES,IX,1))**2)
c...         TEMP:           
             DUM=RRSTEP(ITARG,IG) +
     .                      SQRT((XPOL(NPES,IX+1)-XPOL(NPES,IX))**2+
     .                           (YPOL(NPES,IX+1)-YPOL(NPES,IX))**2)
             CALL CHECKNUM('ZOLA4',ITARG,IG+1,RRSTEP(ITARG,IG+1),DUM)
           ELSE
             RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .                    SQRT((XPOL(NPES,IX+1)-XPOL(NPES,IX))**2+
     .                         (YPOL(NPES,IX+1)-YPOL(NPES,IX))**2)
           ENDIF
c
c          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
c     .                     SQRT((XPOL(NPES,IX+1)-XPOL(NPES,IX))**2+
c     .                          (YPOL(NPES,IX+1)-YPOL(NPES,IX))**2)
c slmod end
          IRSTEP(ITARG,IG)=NPEC
          IPSTEP(ITARG,IG)=IX
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=100000+NPES
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
c slmod begin
          IF (GRIDOPT.EQ.1) THEN
            TORL(IX,ITARG)=PIA*(XVERT(NPES,IX+1,1)+XVERT(NPES,IX,1))
c...        TEMP:
            DUM =2.*PIA*0.5*(XPOL(NPES,IX+1)+XPOL(NPES,IX))
            CALL CHECKNUM('ZOLA5',NPES,IX,TORL(ITARG,IG),DUM)
          ELSE
            TORL(ITARG,IG)=2.*PIA*0.5*(XPOL(NPES,IX+1)+
     .                                 XPOL(NPES,IX))
          ENDIF
c
c          TORL(ITARG,IG)=2.*PIA*0.5*(XPOL(NPES,IX+1)+
c     .                               XPOL(NPES,IX))
c slmod end
          DO 3023 IPLS=1,NPLSI
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLS,ITARG,IG) = TIB(IX,NPBC)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE (EV)
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3023
            DISTEP(IPLS,ITARG,IG)=DNIB(IX,NPBC,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELX=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELX.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                                FNIYB(IX,NPBS,IFL))*FL(IPLS)/DELX
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIY_XB(IX,NPBS,IFL))*
     .                   FL(IPLS)/DELX
                ENDIF
C  SET ION ENERGY FLUXES FROM B2 BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLS,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG) +
     .                                  FL(IPLS)/DELX*
     .            (TIS*delti_perp*ABS(Fniyb  (ix,npbs,ifl))+
     .             TIS*delti_para*ABS(fniy_xb(ix,npbs,ifl))+
     .             TES*delte_para*ABS(fniy_xb(ix,npbs,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PU VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        RADIAL POLYGON NPES DATA
            IN=NPEC+(IX-1)*NR1ST
c slmod begin
            IF (GRIDOPT.EQ.1) THEN
              PUXS=XVERT(NPES,IX+1,1)-XVERT(NPES,IX,1)
              PUYS=YVERT(NPES,IX+1,1)-YVERT(NPES,IX,1)
c...          TEMP:
              DUM=XPOL(NPES,IX+1)-XPOL(NPES,IX)
              CALL CHECKNUM('ZOLA6',NPES,IX,PUXS,DUM)
              DUM=YPOL(NPES,IX+1)-YPOL(NPES,IX)
              CALL CHECKNUM('ZOLA7',NPES,IX,PUYS,DUM)
            ELSE
              PUXS=XPOL(NPES,IX+1)-XPOL(NPES,IX)
              PUYS=YPOL(NPES,IX+1)-YPOL(NPES,IX)
            ENDIF
c
c            PUXS=XPOL(NPES,IX+1)-XPOL(NPES,IX)
c            PUYS=YPOL(NPES,IX+1)-YPOL(NPES,IX)
c slmod end
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
C  ORTHONORMALIZE PV VECTOR WITH RESPECT TO PU
            PUPV=PUXS*PVX(IN)+PUYS*PVY(IN)
            PVXS=PVX(IN)-PUPV*PUXS
            PVYS=PVY(IN)-PUPV*PUYS
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
            VXSTEP(IPLS,ITARG,IG)=
     .            (PUXS*UUB(IX,NPBS,IFL)+PVXS*VVB(IX,NPBS,IFL))*V
            VYSTEP(IPLS,ITARG,IG)=
     .            (PUYS*UUB(IX,NPBS,IFL)+PVYS*VVB(IX,NPBS,IFL))*V
            RRBS=UUB(IX,NPBS,IFL)/(UPB(IX,NPBS,IFL)+EPS60)
            VZSTEP(IPLS,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(IX,NPBS,IFL))*V
3023      CONTINUE
        ENDDO
3030    CONTINUE
C
3040  CONTINUE
      NRWL(ITARG)=IG+1

C
      IF (TRCSOU) CALL LEER(2)
C
C  INITIALIZE FUNCTION STEP (FOR RANDOM SAMPLING ALONG TARGET)
C  SET SOME SOURCE PARAMETERS EXPLICITLY TO ENFORCE INPUT CONSISTENCY
C
      FLUX(ITARG)=STEP(IIPLS,IEPLS,NRWL(ITARG),ITARG)
C
c slmod begin
c...  Do not over-ride source species specification if it is set
c     to atoms:
      IF (NLATM(ITARG)) THEN
        WRITE(0,*) 'NOTE: NOT OVER-RIDING NLATM'
        WRITE(6,*) 'NOTE: NOT OVER-RIDING NLATM'
      ELSE
        NLPLS(ITARG)=.TRUE.
        NLATM(ITARG)=.FALSE.
        NLMOL(ITARG)=.FALSE.
        NLION(ITARG)=.FALSE.
      ENDIF
c
c      NLPLS(ITARG)=.TRUE.
c      NLATM(ITARG)=.FALSE.
c      NLMOL(ITARG)=.FALSE.
c      NLION(ITARG)=.FALSE.
c slmod end
C
      NLSRF(ITARG)=.TRUE.
      NLPNT(ITARG)=.FALSE.
      NLLNE(ITARG)=.FALSE.
      NLVOL(ITARG)=.FALSE.
      NLCNS(ITARG)=.FALSE.
C
      NSRFSI(ITARG)=1
      INDIM(1,ITARG)=4
      IF (INDSRC(ITARG).NE.6) THEN
        I34=IDEZ(INT(SORLIM(1,ITARG)),3,3)
        SORLIM(1,ITARG)=I34*100+04
      ELSEIF (INDSRC(ITARG).EQ.6) THEN
C  SORLIM MAY NOT BE KNOWN
        SORLIM(1,ITARG)=0204
      ENDIF
      SORIND(1,ITARG)=ITARG
C  IN CASE INDIM=4: INSOR,... ARE REDUNDANT
      NRSOR(1,ITARG)=-1
      NPSOR(1,ITARG)=-1
      IF (INDSRC(ITARG).LT.6) THEN
        WRITE (6,*) 'MESSAGE FROM IF2COP: '
        WRITE (6,*) 'SOURCE STRENGTH AND SPATIAL DISTRIBUTION FOR '
        WRITE (6,*) 'STRATUM ',ISTRA,' MODIFIED.'
        CALL MASR1('FLUX=   ',FLUX(ISTRA))
        WRITE (6,*) 'USE STEP FUNCTION ISTEP= ',ITARG,' FROM BLOCK 14'
        CALL LEER(1)
      ENDIF
C
      IF (INDSRC(ITARG).EQ.6) THEN
C  DEFINE SOURCE FOR TARGET RECYCLING STRATUM ITARG
C  ASSUME NOW: ITARG=ISTRA
C  DEFAULTS ARE ALREADY SET IN SUBR. INPUT.
C
        CALL FTCRI(ITARG,CITARG)
        TXTSOU(ITARG)= 'SURFACE RECYCLING SOURCE NO.'//CITARG
        NPTS(ITARG)=NPTC(ITARG,1)
        NINITL(ITARG)=ITARG*1001
        NSPEZ(ITARG)=-1
        SORIFL(1,ITARG)=NIFLG(ITARG,1)
        SORWGT(1,ITARG)=1.
C  USE ENERGY FLUXES SPECIFIED HERE, IE., SORENE, SORENI ARE REDUNDANT
        NEMODS(ITARG)=-3
        NAMODS(ITARG)=1
C
C  USE POLYGON MESH, IE., SORAD1,...,SORAD4 ARE REDUNDANT.
        SORAD5(1,ITARG)=ZIA
        SORAD6(1,ITARG)=ZAA
C
C  VELOCITY SPACE DISTRIBUTION
        SORCOS(ITARG)=1.
        SORMAX(ITARG)=0.
C
C
C  DO 2028 LOOP FROM SUBR. INPUT
        THMAX=MAX(0._DP,MIN(PIHA,SORMAX(ITARG)*DEGRAD))
        IF (NAMODS(ITARG).EQ.1) THEN
          RP1=SORCOS(ITARG)+1.
          SORCOS(ITARG)=1./RP1
          IF (ABS(COS(THMAX)).LE.EPS10) THEN
            SORMAX(ITARG)=1.
          ELSE
            SORMAX(ITARG)=1.-COS(THMAX)**RP1
          ENDIF
        ELSEIF (NAMODS(ITARG).EQ.2) THEN
          SORCOS(ITARG)=SORCOS(ITARG)*DEGRAD
          SORMAX(ITARG)=THMAX
        ENDIF
        NLSYMT(0)=NLSYMT(0).AND.NLSYMT(ITARG)
        NLSYMP(0)=NLSYMP(0).AND.NLSYMP(ITARG)
C
      ENDIF
C
C  SOURCE DEFINITION FOR TARGET RECYCLING STRATUM ITARG COMPLETED
C
3999  CONTINUE
C
C  TARGET DATA ARE DEFINED NOW
C
C
C  COMPUTE EXACT SURFACE ENERGY FLUXES FOR COMPARISON WITH SAMPLED
C  E-FLUX "ETOTP". THIS IS ONLY FOR DIAGNOSTICS PURPOSES
C  E.G. TO CHECK CONSISTENCY OF BOUNDARY CONDITIONS
C  STATEMENT NO. 6000 ---> 6500
C
      IF (.NOT.TRCSOU) GOTO 6500
C
      EEMAX=0.
      EESHT=0.
C
      DO 6011 IG=1,NRWL(ITARG)-1
        OR=ORI(ITARG,IG)
C
C  COMPUTE SHEATH POTENTIAL ESHT(ITARG,IG)
C  USE ALL NPLSI SPECIES, NOT JUST IFL=NSPZI,NSPZE
C
        ESHT(ITARG,IG)=0.D0
        NEM=IABS(NEMODS(ITARG))
        IF (NEM.EQ.3.OR.NEM.EQ.5.OR.NEM.EQ.7) THEN
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
            IY=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            DO 6005 IPL=1,NPLSI
              PM1=(PPLNX(IY,NPES)*VXSTEP(IPL,ITARG,IG)+
     .             PPLNY(IY,NPES)*VYSTEP(IPL,ITARG,IG))*OR
              VPZ=VZSTEP(IPL,ITARG,IG)
              VP(IPL)=SQRT(PM1**2+VPZ**2)
              DI(IPL)=DISTEP(IPL,ITARG,IG)
6005        CONTINUE
            TE=TESTEP(ITARG,IG)
            CUR=0.
            GAMMA=0.
            ESHT(ITARG,IG)=SHEATH(TE,DI,VP,NCHRGP,GAMMA,CUR,NPLSI,
     .                           -ITARG)
          ELSEIF (IGSTEP(ITARG,IG).LT.200000) THEN
            IX=IPSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-100000
            DO 6006 IPL=1,NPLSI
              PM1=(PPLNX(NPES,IX)*VXSTEP(IPL,ITARG,IG)+
     .             PPLNY(NPES,IX)*VYSTEP(IPL,ITARG,IG))*OR
              VPZ=VZSTEP(IPL,ITARG,IG)
              VP(IPL)=SQRT(PM1**2+VPZ**2)
              DI(IPL)=DISTEP(IPL,ITARG,IG)
6006        CONTINUE
            TE=TESTEP(ITARG,IG)
            CUR=0.
            GAMMA=0.
            ESHT(ITARG,IG)=SHEATH(TE,DI,VP,NCHRGP,GAMMA,CUR,NPLSI,
     .                           -ITARG)
          ENDIF
        ENDIF
C
        DO 6009 IPLS=1,NPLSI
          IF (FLSTEP(IPLS,ITARG,IG).EQ.0.D0) GOTO 6009
C
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
C  CHECK BOHM CRITERION AT "POLOIDAL" TARGET SURFACE COMPONENTS
            IY=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            VT=SQRT(2.*TISTEP(IPLS,ITARG,IG)/BMASS(IPLS))*CVEL2A
C  VELOCITY COMPONENT NORMAL TO POLOIDAL TARGET SURFACE
C  I.E., POLOIDAL COMPONENT V-POL
C  ASSUMING ORTHOGONAL TARGET
            PM1=(PPLNX(IY,NPES)*VXSTEP(IPLS,ITARG,IG)+
     .           PPLNY(IY,NPES)*VYSTEP(IPLS,ITARG,IG))*OR
C  VELOCITY COMPONENT PARALLEL TO POLOIDAL TARGET SURFACE
C  I.E., RADIAL PLUS TOROIDAL COMPONENT, V-RAD + V-TOR
C  AGAIN: ASSUMING ORTHOGONAL TARGET
            VPX=VXSTEP(IPLS,ITARG,IG)-PM1*PPLNX(IY,NPES)*OR
            VPY=VYSTEP(IPLS,ITARG,IG)-PM1*PPLNY(IY,NPES)*OR
            VPZ=VZSTEP(IPLS,ITARG,IG)-0.
            PN1=SQRT(VPX**2+VPY**2+VPZ**2)
            PERW=0.
            PARW=0.
            IF (VT.GT.0.) THEN
              PERW=PM1/VT
              PARW=PN1/VT
            ENDIF
C
            CS=SQRT((1.*TISTEP(IPLS,ITARG,IG)+
     .                  TESTEP(ITARG,IG))/BMASS(IPLS))*CVEL2A
C THE MACH NUMBER BOUNDARY CONDITION ONLY AFFECTS THE PARALLEL TO B
C MOMENTUM, I.E., NOT THE RADIAL VELOCITY
            VTEST=SQRT(PM1**2+VPZ**2)
            VTEST=VTEST/(CS+EPS60)
            VR=SQRT(VPX**2+VPY**2)
            WRITE (6,*) 'IPLS,ITARG,IG,MACH ',IPLS,ITARG,IG,VTEST
C           WRITE (6,*) 'POL., TOR., RAD. ',PM1,VPZ,VR
            CALL LEER(1)
          ENDIF
C
C  BOHM CRITERION CHECK DONE
C
C  NEXT: TARGET ENERGY FLUXES
          DRR=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
          IF (NEMODS(ITARG).GT.0) THEN
C  ENERGY FLUX DEFINED IN INPUT BLOCK 7
            IF (NEMODS(ITARG).EQ.1) THEN
              EADD=SORENI(ITARG)
            ELSEIF (NEMODS(ITARG).EQ.2.OR.NEMODS(ITARG).EQ.3) THEN
              EADD=SORENI(ITARG)*TISTEP(IPLS,ITARG,IG)+SORENE(ITARG)*
     .             TESTEP(ITARG,IG)
            ELSEIF (NEMODS(ITARG).GE.4) THEN
              IF (IGSTEP(ITARG,IG).LT.200000) THEN
                EADD=0.
                WRITE (6,*) 'INVALID OPTION FOUND IN IF2COP '
                WRITE (6,*) 'POSSIBLE ERROR IN TARGET ENERGY FLUX '
                WRITE (6,*) 'ITARG,IG ',ITARG,IG
              ELSE
                PERWI=PERW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
                PARWI=PARW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
                EADD=EMAXW(TISTEP(IPLS,ITARG,IG),PERWI,PARWI)
              ENDIF
            ENDIF
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).LT.0) THEN
C  ENERGY FLUX DEFINED BY B2-BOUNDARY CONDITIONS
            EEMAX=EEMAX+ELSTEP(IPLS,ITARG,IG)*DRR
          ENDIF
C  SUM SHEATH ACCELERATION
          EADD=NCHRGP(IPLS)*ESHT(ITARG,IG)
          ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
          EESHT=EESHT+ESUM*DRR
6009    CONTINUE
        GOTO 6011
6010    CONTINUE
C  TO BE WRITTEN
6011  CONTINUE
C
      CALL LEER(1)
      WRITE (6,*) 'TARGET DATA: TARGET NO. ITARG=ISTRA= ',ITARG
      WRITE (6,*) 
     .' IG,  ARC,     P-FLUX,   E-FLUX,     TE,       TI,    SHEATH/TE'
      DO 6100 IG=1,NRWL(ITARG)-1
        WRITE (6,'(1X,I3,1P,6E11.3)')
     .             IG,RRSTEP(ITARG,IG),FLSTEP(0,ITARG,IG),
     .             ELSTEP(0,ITARG,IG),
     .             TESTEP(ITARG,IG),TISTEP(1,ITARG,IG),
     .             ESHT(ITARG,IG)/(TESTEP(ITARG,IG)+EPS60)
6100  CONTINUE
      WRITE (6,'(1X,I3,1P,1E11.3)') NRWL(ITARG),
     .                                 RRSTEP(ITARG,NRWL(ITARG))
      CALL MASR1 ('EEMAX    ',EEMAX)
      CALL MASR1 ('EESHT    ',EESHT)
C
      ETOT=EEMAX+EESHT
      EFLX(ITARG)=EEMAX+EESHT
      WRITE (6,*) 'PARTICLE FLUX(IPLS), IPLS=1,NPLSI '
      WRITE (6,'(1X,1P,6E12.4)') (FLTOT(ISPZ,ITARG),ISPZ=1,NPLSI)
      CALL LEER(1)
      WRITE (6,*) 'ENERGY FLUX '
      WRITE (6,'(1X,1P,1E12.4)') EFLX(ITARG)
      CALL LEER(2)
C
6300  CONTINUE
C
C  SET SOME OTHER DATA SPECIFIC FOR EIRENE CODE REQUIREMENTS
C  STATEMENT NO. 6500 ---> 6999
C
6500  CONTINUE
C
C
      RETURN
999   CONTINUE
      WRITE (6,*) 'ERROR IN IF2COP: NGITT TOO SMALL '
      CALL EXIT
      RETURN
C
C
      ENTRY IF3COP(ISTRAA,ISTRAE,NEW_ITER)
C
C
      WRITE (6,*) ' IF3COP IS CALLED, ISTRAA,ISTRAE '
      WRITE (6,*) ISTRAA,ISTRAE
      LSHORT=.FALSE.
      LSTOP=.TRUE.
      IFIRST=0
      NDXY=(NDXA-1)*NR1ST+NDYA
      GOTO 99992
C
      ENTRY INTER3(LSTP,IFRST,ISTRAA,ISTRAE,NEW_ITER)
      WRITE(0,*) 'ENTERING INTER3'
C
C  ENTRY FOR SHORT CYCLE FROM SUBR. EIRSRT
C
C  IFIRST=0: RESTORE DATA FROM A PREVIOUS EIRENE RUN, SET REFERENCE
C            DATA FOR "STOP-CRITERION" SNIS,SEES,SEIS
C  IFIRST>0: MODIFY SOURCE TERMS ACCORDING TO NEW PLASMA CONDITIONS,
C            COMPARE INTEGRALS WITH SNIS,...., AND DECIDE TO STOP OR
C            CONTINUE SHORT CYCLE (LSTOP)
C
      LSHORT=.TRUE.
      LSTOP=LSTP
      IFIRST=IFRST
      NDXY=(NDXA-1)*NR1ST+NDYA
C
99992 CONTINUE

      IF (.NOT.ALLOCATED(CHPS)) THEN
        ALLOCATE (CHPS(NFL))
        ALLOCATE (SNIS(0:NFL))
        ALLOCATE (CHMOS(NFL))
        ALLOCATE (SMOS(0:NFL))
        ALLOCATE (SCALN(0:NFL))
        ALLOCATE (SNIS0(NSTRA,0:NFL))
        ALLOCATE (SMOS0(NSTRA,0:NFL))
        ALLOCATE (RESSNI(NFL))
        ALLOCATE (RESSMO(NFL))
        CALL ALLOC_BRASPOI
        CALL ALLOC_EIRBRA(NDXP,NDYP,NFL,NSTRA)
      ENDIF
C
!      IF ((ISTRAA.NE.ISTRAE).OR.(ISTRAA.EQ.1).OR.(ISETRES == 0)) THEN
!        ISETRES = 1
      IF (NEW_ITER == 0) THEN
        RESSNI = 0.D0
        RESSMO = 0.D0
        RESSEE = 0.D0
        RESSEI = 0.D0
      ENDIF

      DO 10000 ISTRAI=ISTRAA,ISTRAE
C
        IF (XMCP(ISTRAI).LE.1.) GOTO 10000
C
        IF (LSHORT) GOTO 7000
C
C  READ DATA FROM STRATUM NO. ISTRAI BACK INTO WORKING SPACE
C  IF REQUIRED
C
        IF (ISTRAI.EQ.IESTR) THEN
C  NOTHING TO BE DONE
        ELSEIF (NFILEN.EQ.1.OR.NFILEN.EQ.2) THEN
          IESTR=ISTRAI
          CALL RSTRT(ISTRAI,NSTRAI,NESTM1,NESTM2,ESTIMV,ESTIMS,
     .               NSDVI1,SDVI1,NSDVI2,SDVI2,
     .               NSDVC1,SIGMAC,NSDVC2,SGMCS,
     .               NSBGK,SIGMA_BGK,NBGV_STAT,SGMS_BGK,
     .               NSCOP,SIGMA_COP,NCPV_STAT,SGMS_COP,TRCFLE)
        ELSE
          WRITE (6,*) 'ERROR IN INFCOP: STRATUM ISTRAI= ',ISTRAI
          WRITE (6,*) 'IS NOT AVAILABLE. EXIT CALLED'
          CALL EXIT
        ENDIF
C
C  DATA TRANSFER BACK FROM EIRENE TO EXTERNAL CODE
C  STATEMENT NO 7000 ---> 7999
C
7000    CONTINUE
C
C  SCALE SURFACE SOURCES PER UNIT FLUX, FOR OTHER SOURCES USE
C  EIRENE SCALINGS
        IF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).NE.0.) THEN
C  FLUX FROM EIRENE TO PLASMA CODE: NEGATIVE
          FLX=-WTOTP(0,ISTRAI)
          FLXI=1./FLX
        ELSEIF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).EQ.0.) THEN
          WRITE (6,*) 'NO PLASMA FLUX FROM STRATUM NO. ISTRAI= ',ISTRAI
          WRITE (6,*) 'NO DATA RETURNED TO PLASMA CODE FOR THIS STRATUM'
c slmod begin
c...      TEMP: (why is this here?)
          STOP 'THIS BRANCH REALLY DOES DO SOMETHING'
          GOTO 7700
c
c          GOTO 7999
c slmod end
        ELSEIF (ISTRAI.GT.NTARGI) THEN
          FLXI=1.
        ENDIF
C
C  FIRSTLY INITIALIZE SOURCE TERM ARRAYS
C
        DO 7100 IX=0,NDXA+1
          DO 7150 IY=0,NDYA+1
            SEE(IX,IY,ISTRAI)=0.
            SEI(IX,IY,ISTRAI)=0.
7150      CONTINUE
7100    CONTINUE
        DO 7210 IF=1,NFLA
          DO 7220 IX=0,NDXA+1
            DO 7230 IY=0,NDYA+1
              SNI(IX,IY,IF,ISTRAI)=0.
              SMO(IX,IY,IF,ISTRAI)=0.
7230        CONTINUE
7220      CONTINUE
7210    CONTINUE
C
        DO 7300 IPLS=1,NPLSI
        DO 7300 IN=1,NDXY
          CHPM(IPLS,IN)=0.
          CHMOM(IPLS,IN)=0.
7300    CONTINUE
        DO 7301 IN=1,NDXY
          CHEEM(IN)=0.
          CHEIM(IN)=0.
7301    CONTINUE
C
        IF (.NOT.LSHORT) GOTO 7400

        COPV=0.D0
        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IN=CPMUL%ICM
          COPV(ICPV,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT IONISATION OF ATOMS
C                        AND BULK ION CHARGE EXCHANGE WITH ATOMS
C

        PAPL=0.D0
        CPMUL => PAPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PAPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EAEL=0.D0
        CPSIM => EAELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EAPL=0.D0
        CPSIM => EAPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7310

        CPMUL => PDENAS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IATM=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWA(IN,IATM,IPLS)-SPLODA(IN,IATM,IPLS))*ELCHA
            PAPL(IPLS,IN)=PAPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          ENDDO
          CHE=CPMUL%VALUEM*
     .        (SEENWA(IN,IATM)-SEEODA(IN,IATM))*ELCHA
          EAEL(IN)=EAEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IF (ICPV.LE.NPLSI) THEN
            IPLS=ICPV
            IN=CPMUL%ICM
            CHI=CPMUL%VALUEM*
     .          (SEINWA(IN,IPLS)-SEIODA(IN,IPLS))*ELCHA
            EAPL(IN)=EAPL(IN)+CHI
            CHEIM(IN)=CHEIM(IN)+CHI
          ENDIF
          CPMUL => CPMUL%NXTMUL
        ENDDO

7310    CONTINUE

C
C  CORRECTION FOR ELECTRON IMPACT IONISATION AND CX OF ATOMS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS
C

        PIPL=0.D0
        CPMUL => PIPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PIPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EIEL=0.D0
        CPSIM => EIELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EIPL=0.D0
        CPSIM => EIPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7330

        CPMUL => PDENIS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IION=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM *
     .          (SPLNWI(IN,IION,IPLS)-SPLODI(IN,IION,IPLS))*ELCHA
            PIPL(IPLS,IN)=PIPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM *
     .        (SEENWI(IN,IION)-SEEODI(IN,IION))*ELCHA
          EIEL(IN)=EIEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CHI=CPMUL%VALUEM *
     .        (SEINWI(IN,IION)-SEIODI(IN,IION))*ELCHA
          EIPL(IN)=EIPL(IN)+CHI
          CHEIM(IN)=CHEIM(IN)+CHI
          CPMUL => CPMUL%NXTMUL
        ENDDO

7330    CONTINUE
C
C
C  CORRECTION FOR TEST IONS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT COLLISIONS
C             OF MOLECULES
C

        PMPL=0.D0
        CPMUL => PMPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PMPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EMEL=0.D0
        CPSIM => EMELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EMPL=0.D0
        CPSIM => EMPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7350

        CPMUL => PDENMS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IMOL=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWM(IN,IMOL,IPLS)-SPLODM(IN,IMOL,IPLS))*ELCHA
            PMPL(IPLS,IN)=PMPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM*
     .        (SEENWM(IN,IMOL)-SEEODM(IN,IMOL))*ELCHA
          EMEL(IN)=EMEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

7350    CONTINUE
C
C  CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS FINISHED
C
C  SHORT LOOP CORRECTION FINISHED
C
7400    CONTINUE
C
C
C  ADD CONTRIBUTIONS FROM VOLUME RECOMBINATION SOURCE
C
        PPPL =0.D0
        CPPV = 0.D0
        EPPL = 0.D0
        EPEL = 0.D0

        IF (NLVOL(ISTRAI)) THEN
C
          DO 7473 IPLS=1,NPLSI
            ICPV=NPLSI+IPLS
            CNDYNP=AMUA*RMASSP(IPLS)
            DO 7472 IIRC=1,NPRCI(IPLS)
              IRRC=LGPRC(IPLS,IIRC)
              SUMN=0.0
              SUMM=0.0
              SUMEI=0.0
              SUMEE=0.0
              DO 7471 IR=1,NR1ST-1
              DO 7471 K=1,NPPLG
              DO 7471 IP=NPOINT(1,K),NPOINT(2,K)-1
                IN=(IP-1)*NR1ST+IR
                INC=NCLTAL(IN)
                IF (NSTORDR >= NRAD) THEN
                  RECADD=-TABRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                  EEADD=  EELRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                ELSE
                  RECADD=-FTABRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                  EEADD=  FEELRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                END IF
                PPPL(IPLS,INC)=PPPL(IPLS,INC)+RECADD
                SUMN=SUMN+RECADD*VOL(IN)
                PIADD=PARMOM(IPLS,IN)*RECADD
                CPPV(ICPV,INC)=CPPV(ICPV,INC)+PIADD
                SUMM=SUMM+PIADD*VOL(IN)
                EIADD=(1.5*TIIN(IPLS,IN)+EDRIFT(IPLS,IN))*RECADD
                EPPL(INC)=EPPL(INC)+EIADD
                SUMEI=SUMEI+EIADD*VOL(IN)
                EPEL(INC)=EPEL(INC)+EEADD
                SUMEE=SUMEE+EEADD*VOL(IN)
7471          CONTINUE
              WRITE (6,*) 'IPLS,IRRC ',IPLS,IRRC
              CALL MASR4('SUMN, SUMM, SUMEI, SUMEE        ',
     .                     SUMN,SUMM,SUMEI,SUMEE)
7472        CONTINUE
7473      CONTINUE
        ENDIF
C
        IF (.NOT.LSYMET) GOTO 7500
C
C  SECONDLY SYMMETRISE EIRENE ARRAYS ACCORDING TO SYMMETRY IN MODEL
C
C
C   THIRDLY WRITE EIRENE ARRAYS (1D) ONTO BRAAMS ARRAYS (2D)
C   AND RESCALE TO PROPER UNITS: #/CELL/STRATUM FLUX
C   # STANDS FOR PARTICLES (SNI), MOMENTUM (SMO)
C   AND ENERGY (SEE,SEI)
C
7500    CONTINUE
        DO 7510 IFL=1,NFLA
          CHPS(IFL)=0.
          SNIS(IFL)=0.
          CHMOS(IFL)=0.
          SMOS(IFL)=0.
          DO 7510 IPLS=1,NPLSI
            IF (IFLB(IPLS).NE.IFL) GOTO 7510
            DO 7520 IX=1,NDXA
              DO 7530 IY=1,NDYA
                INN=IY+(IX-1)*NR1ST
                IN=NCLTAL(INN)
                SNICL=(PAPL(IPLS,IN)+PMPL(IPLS,IN)+PIPL(IPLS,IN)+
     .                 PPPL(IPLS,IN))*VOLTAL(IN)
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)+SNICL
                SNIS(IFL)=SNIS(IFL)+SNICL
                CHPS(IFL)=CHPS(IFL)+CHPM(IPLS,IN)*VOLTAL(IN)
                RESSNI(IFL)=RESSNI(IFL)+ABS(SIGMA_COP(NCPVI+IPLS,IN)*
     .                      SNICL/100.D0)
7530          CONTINUE
7520        CONTINUE
            DO 7539 IADD=NPLSI,3*NPLSI,NPLSI
            IF (NCPVI.LT.IADD+NPLSI) GOTO 7539
            DO 7536 IX=1,NDXA
              DO 7533 IY=1,NDYA
                IN=IY+(IX-1)*NR1ST
                INC=NCLTAL(IN)
                SIGNUM=SIGN(1._DP,BVIN(IPLS,IN))
                SMOCL=(COPV(IADD+IPLS,INC)+CPPV(IADD+IPLS,INC))*
     .                VOLTAL(INC)*1.D-5*SIGNUM
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)+SMOCL
                SMOS(IFL)=SMOS(IFL)+SMOCL
                CHMOS(IFL)=CHMOS(IFL)+CHMOM(IPLS,INC)*VOLTAL(INC)
                RESSMO(IFL)=RESSMO(IFL)+ABS(SIGMA_COP(IADD+IPLS,INC)*
     .                      SMOCL/100.D0*1.D5)
7533          CONTINUE
7536        CONTINUE
7539        CONTINUE
7510    CONTINUE

C
        CHEES=0.
        CHEIS=0.
        SEES=0.
        SEIS=0.
        DO 7540 IX=1,NDXA
          DO 7545 IY=1,NDYA
            INN=IY+(IX-1)*NR1ST
            IN=NCLTAL(INN)
            SEE(IX,IY,ISTRAI)=(EAEL(IN)+EMEL(IN)+EIEL(IN)+EPEL(IN))*
     .                        VOLTAL(IN)
            CHEES=CHEES+CHEEM(IN)*VOLTAL(IN)
            SEES=SEES+SEE(IX,IY,ISTRAI)
            RESSEE=RESSEE+ABS(SIGMA_COP(NCPVI+NPLSI+1,IN)*
     .             SEE(IX,IY,ISTRAI)/100.D0)
            SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*ELCHA
            SEI(IX,IY,ISTRAI)=(EAPL(IN)+EMPL(IN)+EIPL(IN)+EPPL(IN))*
     .                        VOLTAL(IN)
            CHEIS=CHEIS+CHEIM(IN)*VOLTAL(IN)
            SEIS=SEIS+SEI(IX,IY,ISTRAI)
            RESSEI=RESSEI+ABS(SIGMA_COP(NCPVI+NPLSI+2,IN)*
     .             SEI(IX,IY,ISTRAI)/100.D0)
            SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*ELCHA
7545      CONTINUE
7540    CONTINUE
C
C   NEXT:
C   IF LSHORT: CRITERION TO STOP SHORT CYCLE,
C   IF NOT LSHORT: RESCALE SURFACE SOURCE STRATA
C                  UNITS: # PER UNIT TARGET PLATE FLUX
C
        IF (LSHORT.AND.IFIRST.EQ.0) THEN
C
          SNIS0(ISTRAI,0)=0.
          SMOS0(ISTRAI,0)=0.
          DO 7550 IFL=1,NFLA
            SNIS0(ISTRAI,0)=SNIS0(ISTRAI,0)+SNIS(IFL)
            SNIS0(ISTRAI,IFL)=SNIS(IFL)
            SMOS0(ISTRAI,0)=SMOS0(ISTRAI,0)+SMOS(IFL)
            SMOS0(ISTRAI,IFL)=SMOS(IFL)
7550      CONTINUE
          SEES0(ISTRAI)=SEES
          SEIS0(ISTRAI)=SEIS
C
        ELSEIF (LSHORT.AND.IFIRST.GT.0) THEN
C
          SNIS(0)=0.
          DO 7551 IFL=1,NFLA
            SNIS(0)=SNIS(0)+SNIS(IFL)
            SCALN(IFL)=SNIS0(ISTRAI,IFL)/(SNIS(IFL)+EPS60)
7551      CONTINUE

          SCALN(0)=SNIS0(ISTRAI,0)/(SNIS(0)+EPS60)
C
C         SCALM=SMOS0(ISTRAI,0)/(SMOS(0)+EPS60)  ???
C         SCALE=SEES0(ISTRAI)/(SEES+EPS60)       ???
C         SCALI=SEIS0(ISTRAI)/(SEIS+EPS60)       ???
C
          SCALM=1.
          SCALE=1.
          SCALI=1.
          DO 7555 IX=0,NDXA+1
            DO 7552 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*SCALN(0)
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*SCALN(0)
7552        CONTINUE
7555      CONTINUE
          DO 7556 IFL=1,NFLA
            DO 7553 IX=0,NDXA+1
              DO 7554 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*SCALN(IFL)
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*SCALN(IFL)
7554          CONTINUE
7553        CONTINUE
7556      CONTINUE
C
          IF (LSTOP) THEN
            WRITE (6,*) 'STOP SHORT CYCLE: ALL B2 TIMESTEPS DONE '
          ELSE
            DO 7558 IFL=1,NFLA
              TEST=CHPS(IFL)/(SNIS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGP) THEN
                LSTP=.TRUE.
                WRITE (6,*) 'STOP SHORT CYCLE: PART. SOURCES: ',
     .                       SNIS(IFL),CHPS(IFL),TEST
                WRITE (6,*) 'STRATUM ISTRAI, SPECIES IFL ',ISTRAI,IFL
              ENDIF
              TEST=CHMOS(IFL)/(SMOS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGMOM) THEN
                LSTP=.TRUE.
                WRITE (6,*) 'STOP SHORT CYCLE: MOMENTUM SOURCE: ',
     .                       SMOS(IFL),CHMOS(IFL),TEST
                WRITE (6,*) 'STRATUM ISTRAI, SPECIES IFL ',ISTRAI,IFL
              ENDIF
7558        CONTINUE
            TEST=CHEES/(SEES+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEE) THEN
              LSTP=.TRUE.
              WRITE (6,*) 'STOP SHORT CYCLE: EL EN. SOURCE: ',SEES,
     .                     CHEES,TEST
              WRITE (6,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
            TEST=CHEIS/(SEIS+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEI) THEN
              LSTP=.TRUE.
              WRITE (6,*) 'STOP SHORT CYCLE: ION EN. SOURCE: ',SEIS,
     .                     CHEIS,TEST
              WRITE (6,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
          ENDIF
C
        ELSEIF (.NOT.LSHORT) THEN
C
          DO 7560 IX=0,NDXA+1
            DO 7565 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*FLXI
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*FLXI
7565        CONTINUE
7560      CONTINUE
          DO 7570 IFL=1,NFLA
            DO 7580 IX=0,NDXA+1
              DO 7590 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*FLXI
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*FLXI
7590          CONTINUE
7580        CONTINUE
7570      CONTINUE
C
        ENDIF
C
C   THIRDLY:
C   INDEX MAPPING BACK TO BRAAMS IMPLEMENTATION OF LINDA GEOMETRY
C
        IF (NCUTL.EQ.NCUTB) GOTO 7600
C
        CALL INDMPI (SNI,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SMO,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEE,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEI,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
C
7600    CONTINUE
C
7700    CONTINUE
C
c slmod begin
        IF (NITER.GT.1.AND.IITER.LT.NITER) THEN
          IF (output) WRITE(0,*) 'WAITING UNTIL LAST ITERATION '//
     .                           'TO WRITE DATA'
c...      Spagetti:
          GOTO 7999
        ELSE
          IF (output) WRITE(0,*) 'WRITING DATA FOR ISTRA = ',
     .                           istrai,iestr
        ENDIF
C
C       STRATUM IONIZATION SOURCE [ionizations/(cell*sec)]
C
        SNID=0.0D0
        IFL  = 1
        IPLS = 1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              SNID(IX,IY,IFL)=SNID(IX,IY,IFL)+
     .          (PAPL(IPLS,IN)+PMPL(IPLS,IN)+PIPL(IPLS,IN))*VOL(IN)/
     .          ELCHA
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .     CALL INDMPI (SNID,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED
        WRITE(32,*) '''[IONISATION SOURCE : STRATUM =',ISTRAI,']'''
        CALL NEUTR(32,NDX2,NDYA,1,SNID,NDX,NDY,NFL,1,1)
C
C  STRATUM NEUTRAL ATOM DENSITY [particles/cell]
C
        DO IF=1,MIN(2,NATMI)
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              PDENAD(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        PDENAD=0.0D0
        IATM = 1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              PDENAD(IX,IY,IATM)=PDENAD(IX,IY,IATM)+
     .                           PDENA(IATM,IN)*VOL(IN)
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PDENAD,DUMMY,NDX,NDY,NATM,NDXA,NDYA,NATMI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[NEUTRAL ATOM DENSITY : STRATUM =',ISTRAI,']'''
        CALL NEUTR(32,NDX2,NDYA,1,PDENAD,NDX,NDY,NATM,1,1)
C
C  STRATUM NEUTRAL MOLECULE DENSITY [particles/cell]
C
        PDENMD=0.0D0
        IMOL = 1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              PDENMD(IX,IY,IMOL)=PDENMD(IX,IY,IMOL)+
     .                           PDENM(IMOL,IN)*VOL(IN)
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PDENMD,DUMMY,NDX,NDY,NMOL,NDXA,NDYA,NMOLI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[NEUTRAL MOLECULE DENSITY : STRATUM =',ISTRAI,
     .              ']'''
        CALL NEUTR(32,NDX2,NDYA,1,PDENMD,NDX,NDY,NMOL,1,1)
c slmod end
7999  CONTINUE
C
C  DATA TRANSFER BACK TO PLASMA CODE FINISHED FOR STRATUM NO. ISTRAI
C
10000 CONTINUE
C
      RETURN
C
      ENTRY IF4COP
C
      NREC11=NOUTAU
      OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
      IRC=3
      WRITE (11,REC=IRC) RCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (6,*) 'WRITE 11  IRC= ',IRC
      IRC=3
      ALLOCATE (IHELP(NOUTAU))
      JC=0
      DO K=1,NPTRGT
        DO J=1,10*NSTEP
          JC=JC+1
          IHELP(JC)=ICCPL1(J,K)
          IF (JC == NOUTAU) THEN
            IRC=IRC+1
            WRITE (11,REC=IRC) IHELP
            IF (TRCINT.OR.TRCFLE)   WRITE (6,*) 'WRITE 11  IRC= ',IRC
            JC=0
          END IF
        END DO
      END DO
      IF (JC > 0) THEN
        IRC=IRC+1
        WRITE (11,REC=IRC) IHELP
        IF (TRCINT.OR.TRCFLE)   WRITE (6,*) 'WRITE 11  IRC= ',IRC
      END IF
      DEALLOCATE (IHELP)
      IRC=IRC+1
      WRITE (11,REC=IRC) ICCPL2
      IRC=IRC+1
      WRITE (11,REC=IRC) LCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (6,*) 'WRITE 11  IRC= ',IRC
C
      IF (LSHORT) LSTOP=LSTP
C
      IF (.NOT.LSTOP) RETURN
C
      IF (.NOT.(LBALAN)) GOTO 11000
C
C  BALANCES, SHOULD BE DONE ONLY AT THE END OF B2 RUN
C  AT THE END OF AN EIRENE RUN THE BALANCES MAY BE OFF AT LEAST AT
C  THE BEGINNING OF THE CYCLING PROCEDURE, BECAUSE THE PLASMA STILL
C  HAS TO ADJUST TO THE NEW SOURCES
C
C..................................................................................
C
C  CHECK FLUXES AT THE GRID BOUNDARY, SIGN, RECYCLING OR NON-RECYCLING BOUNDARY
C  COUNT FLUXES FROM OUTSIDE INTO GRID AS POSITIVE
C
C..................................................................................
C
C  FIRST: SOUTH EDGE: IY=0
C
C NON RECYCLING FLUXES AT SOUTH EDGE: SFEISY,SFEESY,SFNISY
      SFEISY=0.
      SFEESY=0.
      SFNISY=0.
C
      DO 10113 IX=1,NDXA
C
C IS (IX,0) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.0) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10113
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C SURFACE NORMAL IS INWARD. HENCE: TAKE ALL FLUXES F...YB POSITIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEISY=SFEISY+FEIYB(IX,0)
        SFEESY=SFEESY+FEEYB(IX,0)
        DO 10111 IF=1,NFLA
          SI=SIGN(1._DP,FNIYB(IX,0,IF))
          SFNISY=SFNISY+FNIYB(IX,0,IF)+SI*ABS(FNIY_XB(IX,0,IF))
10111   CONTINUE
10113 CONTINUE
C
      SFNISY=SFNISY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM SOUTH EDGE '
      WRITE (37,8888) SFNISY,SFEISY,SFEESY
8888  FORMAT (3E14.6)
C
C
C  SECOND: NORTH EDGE: IY=NDYA
C
C NON RECYCLING FLUXES AT NORTH EDGE: SFEINY,SFEENY,SFNINY
      SFEINY=0.
      SFEENY=0.
      SFNINY=0.
      DO 10118 IX=1,NDXA
C
C IS (IX,NDYA) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.NDYA) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10118
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C SURFACE NORMAL IS OUTWARD. HENCE: TAKE ALL FLUXES F...YB NEGATIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEINY=SFEINY-FEIYB(IX,NDYA)
        SFEENY=SFEENY-FEEYB(IX,NDYA)
        DO 10116 IF=1,NFLA
          SI=SIGN(1._DP,FNIYB(IX,NDYA,IF))
          SFNINY=SFNINY-FNIYB(IX,NDYA,IF)-SI*ABS(FNIY_XB(IX,NDYA,IF))
10116   CONTINUE
10118 CONTINUE
C
      SFNINY=SFNINY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO NORTH EDGE '
      WRITE (37,8888) SFNINY,SFEINY,SFEENY
C
C
C  THIRD: WEST EDGE: IX=0
C
C NON RECYCLING FLUXES AT WEST EDGE: SFEIWX,SFEEWX,SFNIWX
      SFEIWX=0.
      SFEEWX=0.
      SFNIWX=0.
      DO 10123 IY=1,NDYA
C
C IS (0,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
             IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.0) THEN
               IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .             IY.LT.NTEN(ITARG,IPRT)) GOTO 10123
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        SFEIWX=SFEIWX+FEIXB(0,IY)
        SFEEWX=SFEEWX+FEEXB(0,IY)
        DO 10121 IF=1,NFLA
          SI=SIGN(1._DP,FNIXB(0,IY,IF))
          SFNIWX=SFNIWX+FNIXB(0,IY,IF)+SI*ABS(FNIX_YB(0,IY,IF))
10121   CONTINUE
10123 CONTINUE
C
      SFNIWX=SFNIWX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM WEST EDGE '
      WRITE (37,8888) SFNIWX,SFEIWX,SFEEWX
C
C
C  FOURTH: EAST EDGE: IX=NDXA
C
C NON RECYCLING FLUXES AT EAST EDGE: SFEIEX,SFEEEX,SFNIEX
      SFEIEX=0.
      SFEEEX=0.
      SFNIEX=0.
      DO 10128 IY=1,NDYA
C
C IS (NDXA,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.NDXA) THEN
              IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .            IY.LT.NTEN(ITARG,IPRT)) GOTO 10128
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        SFEIEX=SFEIEX-FEIXB(NDXA,IY)
        SFEEEX=SFEEEX-FEEXB(NDXA,IY)
        DO 10126 IF=1,NFLA
          SI=SIGN(1._DP,FNIXB(NDXA,IY,IF))
          SFNIEX=SFNIEX-FNIXB(NDXA,IY,IF)-SI*ABS(FNIX_YB(NDXA,IY,IF))
10126   CONTINUE
10128 CONTINUE
C
      SFNIEX=SFNIEX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO EAST EDGE '
      WRITE (37,8888) SFNIEX,SFEIEX,SFEEEX
C
C  NEXT: FLUXES TO THOSE SURFACES, AT WHICH RECYCLING BOUNDARY 
C        CONDITIONS ARE SPECIFIED
C
10130 CONTINUE
C
      SFEIT(0)=0.
      SFEET(0)=0.
      SFNIT(0)=0.
      SHEAE(0)=0.
      SHEAI(0)=0.
      DO 10139 I=1,NTARGI
        SFEIT(I)=0.
        SFEET(I)=0.
        SFNIT(I)=0.
        SHEAE(I)=0.
        SHEAI(I)=0.
        DO IPRT=1,NTGPRT(I)
          IF (NIXY(I,IPRT).EQ.1) THEN
C  BALANCE CONTRIB. X-GRID REC. SOURCE
            DO 10132 IY=NTIN(I,IPRT),NTEN(I,IPRT)-1
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIXB(NDT(I,IPRT),IY)
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEXB(NDT(I,IPRT),IY)
              DO 10131 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF).GT.0) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)-
     .                   ABS(FNIX_YB(NDT(I,IPRT),IY,IF))
                SHEAE(I)=SHEAE(I)+TEB(NDT(I,IPRT),IY)*
     .           (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)+
     .            ABS(FNIX_YB(NDT(I,IPRT),IY,IF)))*
     .           (-2.8)
                SHEAI(I)=SHEAI(I)+TEB(NDT(I,IPRT),IY)*
     .           (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)+
     .            ABS(FNIX_YB(NDT(I,IPRT),IY,IF)))*
     .           2.8
                ELSE
                  WRITE (6,*)
     .              'WRONG ORIENTATION OF W/E-TARGET RECYCLING FLUX '
                  WRITE (6,*) 'ITARG, IPRT, IPLS, NDT, IY ',
     .                         I    , IPRT, IF,   NDT(I,IPRT), IY
                  WRITE (6,*) 'FNIX(NDT,IY) ',FNIXB(NDT(I,IPRT),IY,IF)
                ENDIF
10131         CONTINUE
10132       CONTINUE
C  BALANCE CONTRIB. FROM Y-GRID REC. SOURCE
          ELSEIF (NIXY(I,IPRT).EQ.2) THEN
            DO 10135 IX=NTIN(I,IPRT),NTEN(I,IPRT)-1
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIYB(IX,NDT(I,IPRT))
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEYB(IX,NDT(I,IPRT))
              DO 10136 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF).GT.0.) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)-
     .                   ABS(FNIY_XB(IX,NDT(I,IPRT),IF))
                SHEAE(I)=SHEAE(I)+TEB(IX,NDT(I,IPRT))*
     .           (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)+
     .            ABS(FNIY_XB(IX,NDT(I,IPRT),IF)))*
     .           (-2.8)
                SHEAI(I)=SHEAI(I)+TEB(IX,NDT(I,IPRT))*
     .           (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)+
     .            ABS(FNIY_XB(IX,NDT(I,IPRT),IF)))*
     .           2.8
                ELSE
                  WRITE (6,*)
     .              'WRONG ORIENTATION OF S/N-TARGET RECYCLING FLUX '
                  WRITE (6,*) 'ITARG, IPRT, IPLS, IX, NDT ',
     .                         I    , IPRT, IF,   IX, NDT(I,IPRT)
                  WRITE (6,*) 'FNIY(IX,NDT) ',FNIYB(IX,NDT(I,IPRT),IF)
                ENDIF
10136         CONTINUE
10135       CONTINUE
          ENDIF
        ENDDO
C
        SFNIT(I)=SFNIT(I)*ELCHA
C
C
        WRITE (37,*) 'FLUXES TO TARGET NO. ',I
        WRITE (37,8888) SFNIT(I),SFEIT(I),SFEET(I)
C
        SFEIT(0)=SFEIT(0)+SFEIT(I)
        SFEET(0)=SFEET(0)+SFEET(I)
        SFNIT(0)=SFNIT(0)+SFNIT(I)
        SHEAE(0)=SHEAE(0)+SHEAE(I)
        SHEAI(0)=SHEAI(0)+SHEAI(I)
10139 CONTINUE
C
      SSNI=0.
      SSEI=0.
      SSEE=0.
      DO 10150 ISTRA=1,NSTRAI
        IF (XMCP(ISTRA).LE.1) GOTO 10150
        FLX=0.
        IF (ISTRA.LE.NTARGI) THEN
          FLX=ABS(SFNIT(ISTRA))
        ELSE
          FLX=1.
        ENDIF
        SSN=0.
        SSI=0.
        SSE=0.
        DO 10140 IX=1,NDXA
           DO 10140 IY=1,NDYA
             DO 10141 IF=1,NFLA
               SSN=SSN+SNI(IX,IY,IF,ISTRA)
10141        CONTINUE
             SSI=SSI+SEI(IX,IY,ISTRA)
             SSE=SSE+SEE(IX,IY,ISTRA)
10140   CONTINUE
C
      WRITE (37,*) 'RECYCLING SOURCE RATES, POTENTIAL+RAD. EN. ',ISTRA
      WRITE (37,8888) SSN*FLX,SSI*FLX/ELCHA,SSE*FLX/ELCHA
C
C  TRENNEN VON RAD. UND POTENTIELLER ENERGY IM ELECTRONENKANAL.
C  DAZU ABER TEILCHENQUELLE SPEZIESAUFGELOEST NOETIG.
C
C
C
C     WRITE (37,*) 'RADIATION LOSSES VIA NEUTRAL CHANNEL ',ISTRA
C     WRITE (37,8888) 0.,0.,0.
C
        SSNI=SSNI+SSN*FLX
        SSEI=SSEI+SSI*FLX/ELCHA
        SSEE=SSEE+SSE*FLX/ELCHA
10150 CONTINUE
C
      WRITE (37,*) 'EQUILIBRATION '
      WRITE (37,8888) 0.,B2QIE,-B2QIE
C
C
      WRITE (37,*) 'BREMSSTRAHLUNG '
      WRITE (37,8888) 0.,0.,B2BREM
C
      WRITE (37,*) 'CHARGED IMPURITY RAD.,IONIZ. AND RECOMB. '
      WRITE (37,8888) 0.,0.,B2RAD
C
      WRITE (37,*) 'ELECTRIC FIELD TERMS (PRESSURE GRADIENTS)'
      WRITE (37,8888) 0.,B2VDP,-B2VDP
C
      BALANI=SFEISY+SFEINY+SFEIT(0)+SHEAI(0)+SSEI+B2QIE+B2VDP+
     .       SFEIWX+SFEIEX
      BALANE=SFEESY+SFEENY+SFEET(0)+SHEAE(0)+SSEE+B2BREM+B2RAD-B2QIE+
     .       SFEEWX+SFEEEX-B2VDP
      BALANN=SFNISY+SFNINY+SFNIWX+SFNIEX+SFNIT(0)+SSNI
C
      TOTI=ABS(SFEISY+SFEINY)+ABS(SFEIT(0))+
     .     ABS(SHEAI(0))+ABS(SSEI)
      TOTE=ABS(SFEESY+SFEENY)+ABS(SFEET(0))+
     .     ABS(SHEAE(0))+ABS(SSEE)
      TOTN=ABS(SFNISY+SFNINY)+ABS(SFNIT(0))+
     .     ABS(SSNI)
      RE=BALANE/(TOTE+EPS60)*100.
      RI=BALANI/(TOTI+EPS60)*100.
      RN=BALANN/(TOTN+EPS60)*100.
C
      CALL LEER (1)
      IF (LBALAN) THEN
        WRITE (6,*) 'B2-EIRENE GLOBAL BALANCES '
        WRITE (6,*) 'PARTICLE FLUXES (SFNI..) IN AMP'
        WRITE (6,*) 'ENERGY FLUXES (SFEI..,SFEE..,) IN WATT'
        CALL LEER(1)
        WRITE (6,*) ' NON RECYCLING FLUXES AT SOUTH EDGE '
        CALL MASR3(' SFEISY,SFEESY,SFNISY   ',SFEISY,SFEESY,SFNISY)
        WRITE (6,*) ' NON RECYCLING FLUXES AT NORTH EDGE'
        CALL MASR3(' SFEINY,SFEENY,SFNINY   ',SFEINY,SFEENY,SFNINY)
        WRITE (6,*) ' NON RECYCLING FLUXES AT WEST EDGE '
        CALL MASR3(' SFEIWX,SFEEWX,SFNIWX   ',SFEIWX,SFEEWX,SFNIWX)
        WRITE (6,*) ' NON RECYCLING FLUXES AT EAST EDGE '
        CALL MASR3(' SFEIEX,SFEEEX,SFNIEX   ',SFEIEX,SFEEEX,SFNIEX)
        CALL MASRR1 (' TARGETS,EI',SFEIT(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,EE',SFEET(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,NI',SFNIT(1),NTARGI,5)
        CALL MASR3(' TOTALS, EI,EE,NI       ',SFEIT(0),
     .                                     SFEET(0),SFNIT(0))
        WRITE (6,*) ' NEUTRAL PLASMA INTERACTION: '
        CALL MASR3(' SSEI,SSEE,SSNI         ',SSEI,SSEE,SSNI)
        WRITE (6,*) ' VOLUMETRIC ENERGY SINKS FOR ELECTRONS, FROM B2 '
        CALL MASR4(' B2BREM,B2RAD,-B2QIE,-B2VDP     ',
     .               B2BREM,B2RAD,-B2QIE,-B2VDP)
        WRITE (6,*) ' TARGET SHEATH CONTRIBUTIONS,ELECTRONS AND IONS '
        CALL MASRR1 (' TARGETS,EI',SHEAI(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,EE',SHEAE(1),NTARGI,5)
        CALL MASR2(' TOTALS,EI,EE    ',SHEAI(0),SHEAE(0))
        CALL LEER(1)
        CALL MASR3(' BALANI,BALANE,BALANN   ',BALANI,BALANE,BALANN)
        CALL MASR3(' REL. ERR.(%) RI,RE,RN  ',RI,RE,RN)
        CALL LEER(1)
        WRITE (6,*) ' NOISE FROM SOURCE TERMS '
        RESSNI(1:NFLA) = RESSNI(1:NFLA)/ELCHA
        CALL MASR4(' RESSEE,RESSEI,RESSNI,RESSMO    ',
     .        RESSEE,RESSEI,SUM(RESSNI(1:NFLA)),SUM(RESSMO(1:NFLA)))
        CALL LEER(1)
        WRITE (6,*) ' RESSNI-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSNI    ',RESSNI(1),NFLA,5)
        WRITE (6,*) ' RESSMO-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSMO    ',RESSMO(1),NFLA,5)
      ENDIF
C
      CALL LEER (1)
C
11000 CONTINUE
C
c slmod begin
C  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C  WRITE THE SOURCE TERMS FOR THE DIVIMP-CODE ONTO FILE NO.32,
C  ONLY SUM OVER STRATA
C  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C
      IF (.NOT.LSHORT) THEN

        IF (NITER.GT.1.AND.IITER.LT.NITER) THEN
          IF (output)
     .    WRITE(0,*) 'WAITING UNTIL LAST ITERATION TO WRITE DATA'
c...spagetti
          GOTO 8999
        ENDIF



C
C  MOMENTUM SOURCE CHANNEL DATA [kg*m/s/cell]
C
        ISTRA=0
        IESTR=ISTRA



c        IF (.FALSE.)
c     .    CALL RSTRT(ISTRA,NSTRAI,NESTIM,NSDVI,ESTIM,SDVI,
c     .               NSBGK,SDVI_BGK,NSCOP,SDVI_COP,TRCFLE)

c        CALL RSTRT(ISTRA,NSTRAI,NESTIM,NSDVI,ESTIM,SDVI,TRCFLE)

        IF (output)
     .  WRITE(0,*) 'MOMENTUM CHANNEL 14 IS BOGUS!'

c...    DIVIMP only reads NMOMCHA-1 channels at the moment:
        DO I1 = 1, MIN(NMOMCHA,14)

          DO IF=1,NFLA
            DO IX=0,NDXA+1
              DO IY=0,NDYA+1
                SOURCM(IX,IY,IF)=0.
              ENDDO
            ENDDO
          ENDDO

          WRITE(32,*) '''[MOMENTUM SOURCE : CHANNEL =',I1,']'''

          DO IFL=1,1
            DO IPLS=1,NPLSI
              IF (IFLB(IPLS).NE.IFL) CYCLE
              ICPV=NPLSI+IPLS
              DO IT=1,NBMLT
                DO IX=1,NDXA
                  DO IY=1,NDYA
                    IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                    SIGNUM=SIGN(1.D0,
     .              VXIN(IPLS,IN)*BXIN(IN)+
     .              VYIN(IPLS,IN)*BYIN(IN)+
     .              VZIN(IPLS,IN)*BZIN(IN))

c... Used to be COPV2, but COPV3 is now the sum over strata for COPV2 (which
c    contains the data for each stratum): 
                    SOURCM(IX,IY,IFL)=SOURCM(IX,IY,IFL)+
     .                COPV3(ICPV,IN,I1)*
     .                VOL(IN)*1.0D-05*SIGNUM/ELCHA

                    IF     (DABS(SOURCM(IX,IY,IFL)).LT. 1.0D-37) THEN
                      SOURCM(IX,IY,IFL) =  0.0D+00
                    ELSEIF (DABS(SOURCM(IX,IY,IFL)).LT.-1.0D+37) THEN
                      SOURCM(IX,IY,IFL) = -1.0D+37
                    ELSEIF (DABS(SOURCM(IX,IY,IFL)).GT. 1.0D+37) THEN
                      SOURCM(IX,IY,IFL) =  1.0D+37
                    ENDIF

                  ENDDO
                ENDDO
              ENDDO
            ENDDO
          ENDDO
          IF (NCUTL.NE.NCUTB)
     .        CALL INDMPI (SOURCM,DUMMY,NDX,NDY,NFL,NDXA,NDYA,1,
     .                     NCUTB,NCUTL,NPOINT,NPPLG,1,1)
          CALL NEUTR(32,NDX2,NDYA,1,SOURCM,NDX,NDY,NFL,1,1)
        ENDDO










c        ISTRA=0
c        IESTR=ISTRA

c        CALL RSTRT(ISTRA,NSTRAI,NESTIM,NSDVI,ESTIM,SDVI,
c     .             NSBGK,SDVI_BGK,NSCOP,SDVI_COP,TRCFLE)
c        CALL RSTRT(ISTRA,NSTRAI,NESTIM,NSDVI,ESTIM,SDVI,TRCFLE)

C
C  PUT IN STORAGE FOR STRATUM NO. 1

c        ISTRA=1

c
c July 17, 97 - This is where the EIRENE quantities are
c written to file 32... make sure the numbers are correct...
c
       WRITE(6,*)
       WRITE(6,*) '=============================='
       WRITE(6,*)
       WRITE(6,*) 'NATMI      : ',NATMI
       WRITE(6,*) 'NDXA       : ',NDXA
       WRITE(6,*) 'NDYA       : ',NDYA
       WRITE(6,*) 'NR1ST      : ',NR1ST
       WRITE(6,*) 'NDX        : ',NDX
       WRITE(6,*) 'NDY        : ',NDY
       WRITE(6,*) 'NATM       : ',NATM
       WRITE(6,*) 'NCUTB      : ',NCUTB
       WRITE(6,*) 'NCUTL      : ',NCUTL
       WRITE(6,*) 'NPPLG      : ',NPPLG
       WRITE(6,*)
       WRITE(6,*) '=============================='
       WRITE(6,*)

c..    Only write the first 2 ion species:

C
C  IONIZATION SOURCE [ionizations/(cell*sec)]
C
        DO IF=1,NFLA
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
            SNID(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO


        WRITE(32,*) '''[IONISATION]'''
        DO 10510 IFL=1,NFLA

          DO IPLS=1,NPLSI
            IF (IFLB(IPLS).NE.IFL) GOTO 10510

            SUM1 = 0.0

            DO IT=1,NBMLT
              DO IY=1,NDYA
                DO IX=1,NDXA
                  IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD


                  SNID(IX,IY,IFL)=SNID(IX,IY,IFL)+
     .              (PAPL(IPLS,IN)+PMPL(IPLS,IN)+PIPL(IPLS,IN))*VOL(IN)/
     .              ELCHA

                  SUM1 = SUM1 + (PAPL(IPLS,IN)+PMPL(IPLS,IN)+
     .                           PIPL(IPLS,IN))*VOL(IN)/ELCHA

                ENDDO
              ENDDO
            ENDDO
            WRITE(6,*) 'IONISATION INTEGRAL= ',IFL,SUM1
          ENDDO

10510   CONTINUE

        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (SNID,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED
c...    Only write the first 2 ion species to the transfer file:
c        CALL NEUTR(32,NDX2,NDYA,2,SNID,NDX,NDY,NFL,1,1)
        CALL NEUTR(32,NDX2,NDYA,NFLA,SNID,NDX,NDY,NFL,1,1)
C
C  MOMENTUM SOURCE TERM [kg*m/s/cell]
C
        DO IF=1,NFLA
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              SOURCM(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[MOMENTUM]'''

        SUM1=0.0        

        DO 10511 IFL=1,NFLA
          DO 10511 IPLS=1,NPLSI
            IF (IFLB(IPLS).NE.IFL) GOTO 10511
            ICPV=NPLSI+IPLS
            DO IT=1,NBMLT
              DO IX=1,NDXA
                DO IY=1,NDYA
                  IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                  SIGNUM=SIGN(1.D0,
     .            VXIN(IPLS,IN)*BXIN(IN)+
     .            VYIN(IPLS,IN)*BYIN(IN)+
     .            VZIN(IPLS,IN)*BZIN(IN))
c...bug: The momentum term should have been divided by unit charge
c...Recombination momentum term (see above) should not be included here
c   because the volume normalization is not consistent in the
c   cylindrical approximation.
                  SOURCM(IX,IY,IFL)=SOURCM(IX,IY,IFL)+
     .                COPV(ICPV,IN)*VOL(IN)*1.0D-05*SIGNUM/
     .                ELCHA

c                SUM1 = SUM1 + copv3(icpv,in,0)
c                DO I1 = 1, NMOMCHA
c                  IF (I1.EQ.14) CYCLE
c                  SUM1 = SUM1 + COPV2(icpv,IN,0)
c                ENDDO
c                WRITE(6,'(A,2I6,1P,3E12.4,0P)') 'COPV,COPV2=',icpv,in,
c     .            copv(icpv,in),sum1,copv(icpv,in)/(sum1+EPS30)
c                SOURCM(IX,IY,IFL)=COPV(ICPV,IN)*VOL(IN)*1.e-5*signum

                ENDDO
              ENDDO
            ENDDO
10511   CONTINUE
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (SOURCM,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
c...    Only write the first 2 ion species to the transfer file:
c        CALL NEUTR(32,NDX2,NDYA,2,SOURCM,NDX,NDY,NFL,1,1)
        CALL NEUTR(32,NDX2,NDYA,NFLA,SOURCM,NDX,NDY,NFL,1,1)
C
C  NEUTRAL ATOM DENSITY [particles/cell]
C
        IF (NATMI.GT.2) THEN
          WRITE(0,*) 'ONLY PASSING 1ST AND 2ND ATOMIC INDEX TO DIVIMP'
          WRITE(6,*) 'ONLY PASSING 1ST AND 2ND ATOMIC INDEX TO DIVIMP'
        ENDIF

        DO IF=1,MIN(2,NATMI)
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
            PDENAD(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[NEUTRAL ATOM DENSITY]'''
        IF (output) WRITE(0,*) '''[NEUTRAL ATOM DENSITY]'''
        DO IATM=1,MIN(2,NATMI)
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                PDENAD(IX,IY,IATM)=PDENAD(IX,IY,IATM)+
     .                             PDENA(IATM,IN)*VOL(IN)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PDENAD,DUMMY,NDX,NDY,NATM,NDXA,NDYA,
     .                   MIN(2,NATMI),
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,MIN(2,NATMI),PDENAD,NDX,NDY,NATM,1,1)
C
C  NEUTRAL MOLECULE DENSITY [particles/cell]
C
        DO IF=1,NMOLI
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
            PDENMD(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        DO IMOL=1,NMOLI
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                PDENMD(IX,IY,IMOL)=PDENMD(IX,IY,IMOL)+
     .                             PDENM(IMOL,IN)*VOL(IN)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[NEUTRAL MOLECULE DENISTY]'''
        IF (output) WRITE(0,*) '''[NEUTRAL MOLECULE DENISTY]'''
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PDENMD,DUMMY,NDX,NDY,NMOL,NDXA,NDYA,NMOLI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,NMOLI,PDENMD,NDX,NDY,NMOL,1,1)
C
C  IONIZED MOLECULE DENSITY [particles/cell]
C
        DO IF=1,NIONI
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              PDENID(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        FILNAM='AMJUEL  '
        H123  ='H.12'
        REAC  ='2.0c     '
        CRC   ='OT '
        WRITE(0,*) 'CALLING SLREAC'
        CALL SLREAC(NREACI+1,FILNAM,H123,REAC,CRC)
        WRITE(0,*) 'CALLING SLREAC - DONE'
        DO I=1,9
          DO J=1,9
            RH2PH2(I-1,J-1)=CREAC(I,J,NREACI+1)
          ENDDO
        ENDDO
        IF (NIONI.NE.1) THEN
          WRITE(0,*) 'ERROR: NIONI=1 REQUIRED FOR DIVIMP'
          STOP
        ENDIF
        DO IION=1,NIONI
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                DEF=LOG(DEIN(IN)*1.D-8+EPS10)
                TEF=LOG(TEIN(IN)      +EPS10)
                RATIO2=0.0D0
                DO J=0,8
                  DEJ=DEF**J
                  DO I=0,8
                    TEI=TEF**I
                    RATIO2=RATIO2+RH2PH2(I,J)*TEI*DEJ
                  ENDDO
                ENDDO
                RATIO2=EXP(RATIO2)
                PDENID(IX,IY,IION)=PDENID(IX,IY,IION)+
     .                             PDENM(IION,IN)*RATIO2*VOL(IN)

c         WRITE(6,'(A,2I6,1P,4E12.4,0P)')
c     .     'IONMOL:',ix,iy,PDENID(IX,IY,IION),RATIO2,PDENM(IION,IN),
c     .             PDENI(1,IN)
c                PDENID(IX,IY,IION)=PDENI(IION,IN)*VOL(IN)

              ENDDO
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[IONISED MOLECULE DENISTY]'''
        IF (output) WRITE(0,*) '''[IONISED MOLECULE DENISTY]'''
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PDENID,DUMMY,NDX,NDY,NION,NDXA,NDYA,NIONI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,NIONI,PDENID,NDX,NDY,NION,1,1)

c...Code from HALFA.F:
c        FILNAM='AMJUEL  '
c        H123='H.12'
c        REAC='2.0c     '
c        CRC='OT '
c        CALL SLREAC(NREACI+1,FILNAM,H123,REAC,CRC)
c        DO I=1,9
c          DO J=1,9
c            RH2PH2(I-1,J-1)=CREAC(I,J,NREACI+1)
c          ENDDO
c        ENDDO
c        DO IION=1,NIONI
c          DO IX=1,NDXA
c            DO IY=1,NDYA
c              NCELL=IY+(IX-1)*NR1ST
c
c              TE=TEIN(NCELL)
c              DE=DEIN(NCELL)
c
c              DEF=LOG(DE*1.D-8)
c              TEF=LOG(TE)
c
c              RATIO2=0
c              DO J=0,8
c                DEJ=DEF**J
c                DO I=0,8
c                  TEI=TEF**I
c                  RATIO2=RATIO2+RH2PH2(I,J)*TEI*DEJ
c                ENDDO
c              ENDDO
c              RATIO2=EXP(RATIO2)
c              WRITE(6,'(A,3I6,1P,3E12.4,0P)')
c     .              'RATIO2 A= ',iy,ix,ncell,ratio2,
c     .              PDENM(1,NCELL)*RATIO2*VOL(NCELL),PDENID(IX,IY,1)
c            ENDDO
c          ENDDO
c        ENDDO

C
C  AVERAGE NEUTRAL ATOM ENERGY [eV]
C
        DO IF=1,MIN(2,NATMI)
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              EDENAD(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        DO IATM=1,MIN(2,NATMI)
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD

c...  THIS SHOULD BE AN AVERAGE OVER TOROIDAL SECTIONS, NOT A SUMMATION!

                IF (PDENA(IATM,IN).NE.0.) 
     .            EDENAD(IX,IY,IATM)=EDENAD(IX,IY,IATM)+
     .                               EDENA(IATM,IN)/PDENA(IATM,IN)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[NEUTRAL ATOM ENERGY]'''
        IF (output) WRITE(0,*) '''[NEUTRAL ATOM ENERGY]'''
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (EDENAD,DUMMY,NDX,NDY,NATM,NDXA,NDYA,
     .                   MIN(2,NATMI),
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,MIN(2,NATMI),EDENAD,NDX,NDY,NATM,1,1)
C
C  AVERAGE NEUTRAL MOLECULE ENERGY [eV]
C
        IF (output) WRITE(0,*) '''[AVERAGE NEUTRAL MOLECULE ENERGY]'''

        DO IF=1,NMOLI
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              EDENMD(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        DO IMOL=1,NMOLI
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD

c...  THIS SHOULD BE AN AVERAGE OVER TOROIDAL SECTIONS, NOT A SUMMATION!

                IF (PDENM(IMOL,IN).NE.0.) 
     .            EDENMD(IX,IY,IMOL)=EDENMD(IX,IY,IMOL)+
     .                               EDENM(IMOL,IN)/PDENM(IMOL,IN)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (EDENMD,DUMMY,NDX,NDY,NMOL,NDXA,NDYA,NMOLI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,NMOLI,EDENMD,NDX,NDY,NMOL,1,1)

C
C  AVERAGE IONIZED MOLECULE ENERGY [eV]
C
        IF (output) WRITE(0,*) '''[AVERAGE IONISED MOLECULE ENERGY]'''
        DO IF=1,NIONI
          DO IX=0,NDXA+1
            DO IY=0,NDYA+1
              EDENID(IX,IY,IF)=0.
            ENDDO
          ENDDO
        ENDDO
        DO IION=1,NIONI
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
c...RH2PH2 must be assigned -- as it currently is in the above block:
                DEF=LOG(DEIN(IN)*1.D-8+EPS10)
                TEF=LOG(TEIN(IN)+EPS10)
                RATIO2=0.0D0
                DO J=0,8
                  DEJ=DEF**J
                  DO I=0,8
                    TEI=TEF**I
                    RATIO2=RATIO2+RH2PH2(I,J)*TEI*DEJ
                  ENDDO
                ENDDO
                RATIO2=EXP(RATIO2)

c...  THIS SHOULD BE AN AVERAGE OVER TOROIDAL SECTIONS, NOT A SUMMATION!


                IF (PDENM(IION,IN)*RATIO2.NE.0.0D0) 
     .            EDENID(IX,IY,IION)=EDENID(IX,IY,IION)+
     .              EDENI(IION,IN) / (PDENM(IION,IN) * RATIO2)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (EDENID,DUMMY,NDX,NDY,NION,NDXA,NDYA,NIONI,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,NIONI,EDENID,NDX,NDY,NION,1,1)
C
C  H-ALPHA SOURCE RATE [photons/(cell*sec)]
C
        IF (output) WRITE(0,*) '''[H-ALPHA SOURCE RATE]'''
        DO ix = 1, NADV
          DO iy = 1, NRAD
            addv(ix,iy) = 0.0
          ENDDO
        ENDDO
        WRITE(0,*) 'CALLING HALPHA'
        CALL HALPHA(0,1,2,3,4,5,6,7)
        WRITE(0,*) 'CALLING HALPHA - DONE'


        PADDVD=0.0D0

c...JUELICH-AIX
        DO IADV=1,5
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                IF (NLTRZ) THEN
c...              Using toroidal volumes:
                  PADDVD(IX,IY,IADV)=PADDVD(IX,IY,IADV)+ADDV(IADV,IN)*
     .                               VOL2(IN)
                ELSE
                  PADDVD(IX,IY,IADV)=PADDVD(IX,IY,IADV)+
     .                               ADDV(IADV,IN)*VOL(IN)
                ENDIF
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[Halpha source]'' '
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PADDVD,DUMMY,NDX,NDY,NADV,NDXA,NDYA,5,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,5,PADDVD,NDX,NDY,NADV,1,1)
C
C  H-GAMMA SOURCE RATE [photons/(cell*sec)]
C
        IF (output) WRITE(0,*) '''[H_GAMMA SOURCE RATE]'''

        DO ix = 1, NADV
          DO iy = 1, NRAD
            addv(ix,iy) = 0.0
          ENDDO
        ENDDO
        WRITE(0,*) 'CALLING HGAMMA'
        CALL HGAMMA(0,1,2,3,4,5,6)
        WRITE(0,*) 'CALLING HGAMMA - DONE'

        PADDVD=0.0D0

        DO IADV=1,5
          DO IT=1,NBMLT
            DO IX=1,NDXA
              DO IY=1,NDYA
               IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                IF (NLTRZ) THEN
c...              Using toroidal volumes:
                  PADDVD(IX,IY,IADV)= PADDVD(IX,IY,IADV)+ADDV(IADV,IN)*
     .                                VOL2(IN)
                ELSE
                  PADDVD(IX,IY,IADV)=PADDVD(IX,IY,IADV)+
     .                               ADDV(IADV,IN)*VOL(IN)
                ENDIF
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        WRITE(32,*) '''[Hgamma source]'' '
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (PADDVD,DUMMY,NDX,NDY,NADV,NDXA,NDYA,5,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,5,PADDVD,NDX,NDY,NADV,1,1)
C
C  HYDROGEN RECOMBINATION SOURCE RATE [recombinations/(cell*sec)]
C
c        WRITE(0,*) 'WARNING: RECOMBINATION DATA UNAVAILABLE'

        IF (output) WRITE(0,*) '''[HYDROGEN RECOMBINATION RATE]'''

        HYDREC=0.0D0
c        DO IX=0,NDXA+1
c          DO IY=0,NDYA+1
c            HYDREC(IX,IY)=0.
c          ENDDO
c        ENDDO

c...JUELICH-AIX
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              IPLS = 1
              DO IIRC=1,NPRCI(IPLS)
                IRRC=LGPRC(IPLS,IIRC)
                IF (NLTRZ) THEN
c...              Using toroidal volumes:
                  HYDREC(IX,IY)=HYDREC(IX,IY)+
     .                          TABRC1(IRRC,IN)*DIIN(1,IN)*VOL2(IN)
                ELSE
                  HYDREC(IX,IY)=HYDREC(IX,IY)+
     .                          TABRC1(IRRC,IN)*DIIN(1,IN)*VOL(IN)
                ENDIF
c                HYDREC(IX,IY)=HYDREC(IX,IY)+
c     .                        TABRC1(IRRC,IN)*DIIN(1,IN)*VOL(IN)
c                HYDREC(IX,IY)=HYDREC(IX,IY)+
c     .                        TABPRC(1,IREC,IN)*DIIN(1,IN)*VOL(IN)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (HYDREC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[Recombination]'' '
        CALL NEUTR(32,NDX2,NDYA,1,HYDREC,NDX,NDY,1,1,1)
C
C  ION ENERGY SOURCE TERM [Watt/cell]
C
        IF (output) WRITE(0,*) '''[PINQI]'''

        DO IX=0,NDXA+1
          DO IY=0,NDYA+1
            ESOURC(IX,IY)=0.
          ENDDO
        ENDDO
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
c...Recombination power term should not be included here because
c   because the volume normalization is not consistent in the
c   cylindrical approximation.
              ESOURC(IX,IY)=ESOURC(IX,IY)+(EAPL(IN)+EMPL(IN)+EIPL(IN))*
     .                                    VOL(IN)
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (ESOURC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,1,ESOURC,NDX,NDY,1,1,1)
C
C  ELECTRON ENERGY SOURCE TERM [Watt/cell]
C
        IF (output) WRITE(0,*) '''[PINQE]'''

        DO IX=0,NDXA+1
          DO IY=0,NDYA+1
            ESOURC(IX,IY)=0.
          ENDDO
        ENDDO
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
c...Recombination power term should not be included here because
c   because the volume normalization is not consistent in the
c   cylindrical approximation.
              ESOURC(IX,IY)=ESOURC(IX,IY)+
     .                      (EAEL(IN)+EMEL(IN)+EIEL(IN))*VOL(IN)

c            WRITE(6,'(A,2I4,1P,5E12.4,0P,I6)')
c     .        ' ELEC POW : ',ix,iy,
c     .        eael(in)*vol(in),
c     .        emel(in)*vol(in),
c     .        eiel(in)*vol(in),
c     .        esourc(ix,iy),vol(in),in

            ENDDO
          ENDDO
        ENDDO
c        WRITE(32,*) '''[PINQe]'' '
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (ESOURC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        CALL NEUTR(32,NDX2,NDYA,1,ESOURC,NDX,NDY,1,1,1)
C







        IF (output) WRITE(0,*) 'MOVING ON...'


c
c RECOMBINATION RELATED QUANTITIES
c
c
c
c
        PINREC=0.0D0
        PINMPR=0.0D0
        PINQIR=0.0D0
        PINQER=0.0D0

        HYDREC=0.0D0
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              IPLS=1
              IF (NLTRZ) THEN
c...            Using toroidal volumes:
                HYDREC(IX,IY)=HYDREC(IX,IY)-PINREC(IPLS,IN)*VOL2(IN)
              ELSE
                HYDREC(IX,IY)=HYDREC(IX,IY)-PINREC(IPLS,IN)*VOL(IN)
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (HYDREC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[Recombination: particle source]'' '
        CALL NEUTR(32,NDX2,NDYA,1,HYDREC,NDX,NDY,1,1,1)

        HYDREC=0.0D0
        IPLS=1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              SIGNUM=SIGN(1.D0,
     .        VXIN(IPLS,IN)*BXIN(IN)+
     .        VYIN(IPLS,IN)*BYIN(IN)+
     .        VZIN(IPLS,IN)*BZIN(IN))
              IF (NLTRZ) THEN
c...            Using toroidal volumes:
                IF (VOL2(IN).NE.0.0) 
     .            HYDREC(IX,IY)=HYDREC(IX,IY)+PINMPR(IPLS,IN)*
     .                          1.0D-05*SIGNUM/ELCHA*VOL2(IN)
              ELSE
                IF (VOL(IN).NE.0.0) 
     .            HYDREC(IX,IY)=HYDREC(IX,IY)+PINMPR(IPLS,IN)*
     .                          1.0D-05*SIGNUM/ELCHA*VOL(IN)
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (HYDREC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[Recombination: momentum source]'' '
        CALL NEUTR(32,NDX2,NDYA,1,HYDREC,NDX,NDY,1,1,1)

        HYDREC=0.0D0
        IPLS=1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              IF (NLTRZ) THEN
c...            Using toroidal volumes:
                HYDREC(IX,IY)=HYDREC(IX,IY)+PINQIR(IN)*VOL2(IN)
              ELSE
                HYDREC(IX,IY)=HYDREC(IX,IY)+PINQIR(IN)*VOL(IN)
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .    CALL INDMPI(HYDREC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[Recombination: ion energy source]'' '
        CALL NEUTR(32,NDX2,NDYA,1,HYDREC,NDX,NDY,1,1,1)

        HYDREC=0.0D0
        IPLS=1
        DO IT=1,NBMLT
          DO IX=1,NDXA
            DO IY=1,NDYA
              IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
              IF (NLTRZ) THEN
c...            Using toroidal volumes:
                HYDREC(IX,IY)=HYDREC(IX,IY)+PINQER(IN)*VOL2(IN)
              ELSE
                HYDREC(IX,IY)=HYDREC(IX,IY)+PINQER(IN)*VOL(IN)
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        IF (NCUTL.NE.NCUTB)
     .    CALL INDMPI(HYDREC,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        WRITE(32,*) '''[Recombination: electron energy source]'' '
        CALL NEUTR(32,NDX2,NDYA,1,HYDREC,NDX,NDY,1,1,1)

      ENDIF

c...
c
c
c
c
      WRITE(32,*) '[IONISATION - ATOMS]'
      SNID=0.0D0
      DO 11510 IFL=1,NFLA
        DO IPLS=1,NPLSI
          IF (IFLB(IPLS).NE.IFL) GOTO 11510
          DO IT=1,NBMLT
            DO IY=1,NDYA
              DO IX=1,NDXA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                SNID(IX,IY,IFL)=SNID(IX,IY,IFL)+PAPL(IPLS,IN)*VOL(IN)/
     .                          ELCHA
              ENDDO
            ENDDO
          ENDDO
        ENDDO
11510 CONTINUE
      IF (NCUTL.NE.NCUTB)
     .    CALL INDMPI (SNID,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                 NCUTB,NCUTL,NPOINT,NPPLG,1,1)
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL NEUTR(32,NDX2,NDYA,1,SNID,NDX,NDY,NFL,1,1)
c      CALL NEUTR(32,NDX2,NDYA,NFLA,SNID,NDX,NDY,NFL,1,1)

      WRITE(32,*) '[IONISATION - MOLECULES]'
      SNID=0.0D0
      DO 11515 IFL=1,NFLA
        DO IPLS=1,NPLSI
          IF (IFLB(IPLS).NE.IFL) GOTO 11515
          DO IT=1,NBMLT
            DO IY=1,NDYA
              DO IX=1,NDXA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                SNID(IX,IY,IFL)=SNID(IX,IY,IFL)+PMPL(IPLS,IN)*VOL(IN)/
     .                          ELCHA
              ENDDO
            ENDDO
          ENDDO
        ENDDO
11515 CONTINUE
      IF (NCUTL.NE.NCUTB)
     .    CALL INDMPI (SNID,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                 NCUTB,NCUTL,NPOINT,NPPLG,1,1)
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL NEUTR(32,NDX2,NDYA,1,SNID,NDX,NDY,NFL,1,1)
c      CALL NEUTR(32,NDX2,NDYA,NFLA,SNID,NDX,NDY,NFL,1,1)

      WRITE(32,*) '[IONISATION - TEST IONS]'
      SNID=0.0D0
      DO 11520 IFL=1,NFLA
        DO IPLS=1,NPLSI
          IF (IFLB(IPLS).NE.IFL) GOTO 11520
          DO IT=1,NBMLT
            DO IY=1,NDYA
              DO IX=1,NDXA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                SNID(IX,IY,IFL)=SNID(IX,IY,IFL)+PIPL(IPLS,IN)*VOL(IN)/
     .                          ELCHA
              ENDDO
            ENDDO
          ENDDO
        ENDDO
11520 CONTINUE
      IF (NCUTL.NE.NCUTB)
     .    CALL INDMPI (SNID,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                 NCUTB,NCUTL,NPOINT,NPPLG,1,1)
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL NEUTR(32,NDX2,NDYA,1,SNID,NDX,NDY,NFL,1,1)
c      CALL NEUTR(32,NDX2,NDYA,NFLA,SNID,NDX,NDY,NFL,1,1)

c...  Algebraic volume tallies:
      DO IALVI = 1, NALVI
        SNID=0.0D0
        IF     (TXTTAL(IALVI,NTALR)(70:72).EQ.'vol') THEN
c...      Pass the tally per cell, not the tally per volume:
          DO IT=1,NBMLT
            DO IY=1,NDYA
              DO IX=1,NDXA
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                SNID(IX,IY,1)=SNID(IX,IY,1)+ALGV(IALVI,IN)*VOL(IN)
              ENDDO
            ENDDO
          ENDDO
        ELSEIF (TXTTAL(IALVI,NTALR)(70:72).EQ.'n  ') THEN
c...      Average tally over NBLOCK regions based on the volume
c         of the cell and the total volume of that cell group over
c         all regions:
          IF (NBMLT.GT.1) 
     .      WRITE(0,*) 'MAKE SURE NON VOLUME SCALED TALLIES WORK '//
     .                 'PROPERLY FOR MORE THAN ONE NBLOCK'
          DO IY=1,NDYA
            DO IX=1,NDXA
              TOTVOL=0.0D0
              DO IT=1,NBMLT
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                TOTVOL=TOTVOL+VOL(IN)
              ENDDO
              IF (TOTVOL.LE.1.0D-20) CYCLE
              DO IT=1,NBMLT
                IN=IY+(IX-1)*NR1ST+(IT-1)*NSTRD
                SNID(IX,IY,1)=SNID(IX,IY,1)+
     .                        ALGV(IALVI,IN)*VOL(IN)/TOTVOL
              ENDDO
            ENDDO
          ENDDO
        ELSE
          WRITE(0,*) 'ERROR: UNRECOGNIZED ALGEBRAIC TALLY SCALING'
          WRITE(6,*) 'ERROR: UNRECOGNIZED ALGEBRAIC TALLY SCALING'
          CALL EXIT
        ENDIF

        IF (NCUTL.NE.NCUTB)
     .      CALL INDMPI (SNID,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .                   NCUTB,NCUTL,NPOINT,NPPLG,1,1)
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED
        WRITE(32,'(A,I3)') 'ALGEBRAIC TALLY',ialvi
        CALL NEUTR(32,NDX2,NDYA,1,SNID,NDX,NDY,1,1,1)
      ENDDO







c...  Attempting to output surface fluxes:

      CONV = 100.0D0

      WRITE(32,*) '[SURFACE FLUXES]'
      WRITE(32,8990) '* NUMBER OF SURFACES, NLIMI+2(NR1ST-1)='

      NUMSURF = NLIMI+2*(NR1ST-1)
c...  Count radial surface segments:
      DO ISTS = 1, NSTSI
        IF (INUMP(ISTS,1).EQ.1.OR.INUMP(ISTS,1).EQ.NR1ST)
     .    NUMSURF = NUMSURF + (IRPTE(ISTS,2) - IRPTA(ISTS,2))
      ENDDO

      WRITE(32,8991) NUMSURF
c      WRITE(32,8991) NLIMI+2*(NR1ST-1)

      DO I = 1, NLIMI
        WRITE(32,8994) I,ILIIN(I),
     .    P1(1,I)/CONV,P1(2,I)/CONV,P1(3,I)/CONV,
     .    P2(1,I)/CONV,P2(2,I)/CONV,P2(3,I)/CONV
      ENDDO
c...  Target co-ordinates are "switched" and unswitched in DIVIMP. 
c     Low IK index (inner) target:
      J1 = 1
      DO I = 1, NR1ST-1
        IF (GRIDOPT.EQ.1) THEN
          WRITE(32,8994)
     .      I,0,XVERT(I,J1,2)/CONV,YVERT(I,J1,2)/CONV,-1.0D+18,
     .          XVERT(I,J1,1)/CONV,YVERT(I,J1,1)/CONV,+1.0D+18
        ELSE
          WRITE(32,8994)
     .      I,0,XPOL(I+1,J1)/CONV,YPOL(I+1,J1)/CONV,-1.0D+18,
     .          XPOL(I  ,J1)/CONV,YPOL(I  ,J1)/CONV,+1.0D+18
        ENDIF
      ENDDO
c...  High IK index (outer) target:
      J1 = NPOINT(2,NPPLG)
      DO I = 1, NR1ST-1
        IF (GRIDOPT.EQ.1) THEN
          WRITE(32,8994)
     .      I,0,XVERT(I,J1,1)/CONV,YVERT(I,J1,1)/CONV,-1.0D+18,
     .          XVERT(I,J1,2)/CONV,YVERT(I,J1,2)/CONV,+1.0D+18
        ELSE
          WRITE(32,8994)
     .      I,0,XPOL(I  ,J1)/CONV,YPOL(I  ,J1)/CONV,-1.0D+18,
     .          XPOL(I+1,J1)/CONV,YPOL(I+1,J1)/CONV,+1.0D+18
        ENDIF
      ENDDO
c...  Radial surfaces:
      DO ICOUNT = 1, 2
        IF (ICOUNT.EQ.1) THEN
          J = 1
          K = 1
          L = 1
        ELSE
          J = NR1ST
          K = 2
          L = NR1ST - 1
        ENDIF
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,1).EQ.J) THEN
            DO I = IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              IF (GRIDOPT.EQ.1) THEN
                WRITE(32,8994)
     .            I,0,XVERT(L,I  ,K)/CONV,YVERT(L,I  ,K)/CONV,-1.0D+18,
     .                XVERT(L,I+1,K)/CONV,YVERT(L,I+1,K)/CONV,+1.0D+18
              ELSE
                WRITE(32,8994)
     .            I,0,XPOL(J,I  )/CONV,YPOL(J,I  )/CONV,-1.0D+18,
     .                XPOL(J,I+1)/CONV,YPOL(J,I+1)/CONV,+1.0D+18
              ENDIF
            ENDDO
          ENDIF
        ENDDO
      ENDDO



      CONV = 1.602E-19

      IF (NGSTAL.EQ.0) THEN
        WRITE(0,*) 'NOT PASSING SURFACE FLUXES TO DIVIMP'
c        WRITE(0,*) 
c        WRITE(0,*) '****************************************'
c        WRITE(0,*) '* NOT PASSING SURFACE FLUXES TO DIVIMP *'
c        WRITE(0,*) '****************************************'
c        WRITE(0,*) 
      ENDIF

      WRITE(32,8990) '* NEUTRAL ATOM SPECIES, NATMI (NUMBER OF '//
     .               'SPECIES)= '
      WRITE(32,8991) NATMI
      DO I = 1, NLIMI
        WRITE(32,8993) I,I,(POTAT (IATM,I)/CONV,IATM=1,NATMI),
     .                     (EOTAT (IATM,I)/CONV,IATM=1,NATMI),
     .                     (PRFAAT(IATM,I)/CONV,IATM=1,NATMI),
     .                     (ERFAAT(IATM,I)/CONV,IATM=1,NATMI)
      ENDDO
      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.1) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993)
     .            I1,MSURFG,(POTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (EOTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (PRFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (ERFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI)
                IR = IR + 1
              ENDIF
            ENDDO
          ENDIF
        ENDDO
      ENDDO
      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.NP2ND) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993)
     .            I1,MSURFG,(POTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (EOTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (PRFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                      (ERFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI)
                IR = IR + 1
              ENDIF
            ENDDO
          ENDIF
        ENDDO
      ENDDO

c...  Output atomic fluxes for grid boundary radial surfaces:
      DO ICOUNT = 1, 2
        IF (ICOUNT.EQ.1) THEN
          J = 1
        ELSE
          J = NR1ST
        ENDIF
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,1).EQ.J) THEN
            DO I1 = IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              WRITE(32,8993)
     .          I1,MSURFG,(POTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                    (EOTAT (IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                    (PRFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI),
     .                    (ERFAAT(IATM,MSURFG)/CONV,IATM=1,NATMI)
            ENDDO
          ENDIF
        ENDDO
      ENDDO


      WRITE(32,8990) '* NEUTRAL MOLECULE SPECIES, NMOLI (NUMBER OF '//
     .               'SPECIES)= '
      WRITE(32,8991) NMOLI
      DO I = 1, NLIMI
        WRITE(32,8993) I,I,(POTML (IMOL,I)/CONV,IMOL=1,NMOLI),
     .                     (EOTML (IMOL,I)/CONV,IMOL=1,NMOLI),
     .                     (PRFMML(IMOL,I)/CONV,IMOL=1,NMOLI),
     .                     (ERFMML(IMOL,I)/CONV,IMOL=1,NMOLI)
      ENDDO
      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.1) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993)
     .            I1,MSURFG,(POTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (EOTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (PRFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (ERFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI)
                IR = IR + 1
              ENDIF
            ENDDO
          ENDIF
        ENDDO
      ENDDO
      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.NP2ND) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993)
     .            I1,MSURFG,(POTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (EOTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (PRFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                      (ERFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI)
                IR = IR + 1
              ENDIF
            ENDDO
          ENDIF
        ENDDO
      ENDDO

c...  Output molecular fluxes for grid boundary radial surfaces:
      DO ICOUNT = 1, 2
        IF (ICOUNT.EQ.1) THEN
          J = 1
        ELSE
          J = NR1ST
        ENDIF
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,1).EQ.J) THEN
            DO I1 = IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              WRITE(32,8993)
     .          I1,MSURFG,(POTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                    (EOTML (IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                    (PRFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI),
     .                    (ERFMML(IMOL,MSURFG)/CONV,IMOL=1,NMOLI)
            ENDDO
          ENDIF
        ENDDO
      ENDDO

c...Currently, these are zero:
c      WRITE(32,8990) '* TEST ION SPECIES           '
c      WRITE(32,8990) '* NIONI (NUMBER OF SPECIES)= '
c      WRITE(32,8991) NIONI
c      DO I = 1, NLIMI
c        WRITE(32,8992) I,(POTIO (IION,I)/CONV,IION=1,NIONI),
c     .                   (EOTIO (IION,I)/CONV,IION=1,NIONI)
c     .                   (PRFIIO(IION,I)/CONV,IION=1,NIONI),
c     .                   (ERFIIO(IION,I)/CONV,IION=1,NIONI)
c      ENDDO

      WRITE(32,8990) '* BULK ION SPECIES, NPLSI (NUMBER OF SPECIES)= '
      WRITE(32,8991) NPLSI
      DO I = 1, NLIMI
        WRITE(32,8993) I,I,(POTPL (IPLS,I)/CONV,IPLS=1,NPLSI),
     .                     (EOTPL (IPLS,I)/CONV,IPLS=1,NPLSI)
      ENDDO
      SUM1 = 0.0D0
      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.1) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
c...bug
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
c              MSURFG=NLIM+NSTSI+MSURFG+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993) I1,MSURFG,
     .                         (POTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI),
     .                         (EOTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI)
c                WRITE(0,*) 'IR1= ',IR
                IR = IR + 1
              ENDIF

              SUM1 = SUM1 + POTPL(1,MSURFG)
            ENDDO
          ENDIF
        ENDDO
      ENDDO

c      WRITE(0,*) 'SUM= ',sum1
      sum1 = 0.0

      IR = 1
      DO WHILE (IR.LT.NR1ST)
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,2).EQ.NP2ND) THEN
            DO I1 = IRPTA(ISTS,1),IRPTE(ISTS,1)-1
c...bug
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
c              MSURFG=NLIM+NSTSI+MSURFG+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              IF (I1.EQ.IR) THEN
                WRITE(32,8993) I1,MSURFG,
     .                         (POTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI),
     .                         (EOTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI)
c                WRITE(0,*) 'IR2= ',ir
                IR = IR + 1
              ENDIF

              SUM1 = SUM1 + POTPL(1,MSURFG)
            ENDDO
          ENDIF
        ENDDO
      ENDDO

      WRITE(6,*) 'SUM= ',sum1


c...  Output molecular fluxes for grid boundary radial surfaces:
      DO ICOUNT = 1, 2
        IF (ICOUNT.EQ.1) THEN
          J = 1
        ELSE
          J = NR1ST
        ENDIF
        DO ISTS = 1, NSTSI
          IF (INUMP(ISTS,1).EQ.J) THEN
            DO I1 = IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              MSURFG=NLIM+NSTSI+I1+(ISTS-1)*NGITT
              IF (NGSTAL.EQ.0) MSURFG=1
              WRITE(32,8993) I1,MSURFG,
     .                       (POTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI),
     .                       (EOTPL(IPLS,MSURFG)/CONV,IPLS=1,NPLSI)
            ENDDO
          ENDIF
        ENDDO
      ENDDO




c      DO I = 1, NLIMI
c        WRITE(32,8992) I,(POTPL(IPLS,I)/CONV,IPLS=1,NPLSI),
c     .                   (EOTPL(IPLS,I)/CONV,IPLS=1,NPLSI)
c      ENDDO
c      WRITE(32,8990) '  TARGET SURFACES'
c      WRITE(32,*) NR1st,np2nd,nt3rd
c      DO ists = 1, nstsi
c        WRITE(32,8991) ists,
c     .    IRPTA(ISTS,1),IRPTE(ISTS,1),IRPTA(ISTS,2),IRPTA(ISTS,2),
c     .    IRPTA(ISTS,3),IRPTE(ISTS,3),INUMP(ISTS,1),INUMP(ISTS,2),
c     .    INUMP(ISTS,3)
c      ENDDO


c      DO I = 1, NR1ST-1
c         MSURFG = I
c         MSURFG = NLIM + NSTSI + MSURFG + (ISTS - 1) * NGITT
c         MSURFG=NRCELL+(NTCELL-1)*NR1P2
c        WRITE(32,8993) I,MSURFG,(POTPL(IPLS,MSURFG),IPLS=1,NPLSI),
c     .                          (EOTPL(IPLS,MSURFG),IPLS=1,NPLSI)
c      ENDDO


      WRITE(32,'(A)') '[PUMPING SURFACES]'

c...  Count the number of surfaces that are pumping particles:
      ICOUNT = 0
      DO J=1,NLIMPS
        DO IS=1,NSPTOT
          IF (SPUMP(IS,J).GT.0.) ICOUNT = ICOUNT + 1
        ENDDO
      ENDDO
      WRITE(32,*) ICOUNT

c...  Output pumped fluxes (AMPS):
      WRITE(32,'(1X,A6,2X,A10,2A24)') 'NO.','SPECIES','SURFACE AREA'//
     .                                ' (CM**2)','PUMPED FLUX (AMPS)'
      DO J=1,NLIMPS
        JJ=J
        IF (J.GT.NLIM) JJ=-(J-NLIM)
        DO IS=1,NSPTOT
          IF (SPUMP(IS,J).GT.0.) THEN 
            WRITE (32,'(1X,I6,2X,A10,1P,2E24.6,0P,I6)') 
     .        JJ,''''//TEXTS(IS)//'''',SAREA(J),SPUMP(IS,J),J
          ENDIF
        ENDDO
      ENDDO

      WRITE(32,*) '[ADDITIONAL CELL TALLIES]'    
      WRITE(32,*) NRADD
      WRITE(32,8976) 'VOLUME','IONISATION'
      WRITE(32,8976) '(m-3)' ,'(s-1 m-3)'
c...  Quantities on additional cells:
c ASSUMPTION: IPLS is 'D' -- ADD A CHECK SOMEWHERE TO MAKE SURE THIS IS THE CASE
      IPLS=1
      IION=1

c...  Problem around hear with a bizzare SIGFPE crash. No descernable
c     explanation for it.  Turned of Ktrap=fp when compiling to get rid of it.  Need
c     someone with more smarts to figure it out:

      DO IN = NSURF+1, NSURF+NRADD
        RATIO2=0.0D0
        IF (DEIN(IN).GT.0.0D0.AND.TEIN(IN).GT.0.0D0) THEN
c...      RH2PH2 defined above:
          DEF=DLOG(DEIN(IN)*1.D-8+EPS10)
          TEF=DLOG(TEIN(IN)      +EPS10)
          DO J=0,8
            DEJ=DEF**J
            DO I=0,8
              TEI=TEF**I
              RATIO2=RATIO2+RH2PH2(I,J)*TEI*DEJ
            ENDDO
          ENDDO
c          WRITE(0,*) 'RATIO2:',ratio2
          RATIO2=DEXP(RATIO2)
        ENDIF
        RDUMD2P=PDENM(IION,IN)*RATIO2

        WRITE(32,8975) IN-NSURF,
     .    1.0D-06*VOL(IN),
     .    1.0D+06*(PAPL(IPLS,IN)+PMPL(IPLS,IN)+PIPL(IPLS,IN))/ELCHA,
c...    D2+ density:
     .    1.0D+06*RDUMD2P,
     .    0.0D0,
     .    0.0D0
c     .    1.0D+06*RDUMD2P,
c     .    1.0D+06*(PAIO(IPLS,IN)+PMIO(IPLS,IN)+PIIO(IPLS,IN))/ELCHA,
c     .    1.0D+06*PIIO(1,IN),DEIN(IN)/PIIO(1,IN)
      ENDDO
8975  FORMAT(I6,1P,E12.4,2X,10(E14.4:))
8976  FORMAT(6X,   A12  ,2X,10(A14  :))



c...  Output time-to-ionisation statistics (OFF FOR NOW):
c      IF (timnum.GT.0) CALL USRTI2


c...  Write time to surface (absorbing surfaces only) from
c     UPSUSR:
      WRITE(6,*)
      WRITE(6,*) 'TIME-TO-SURFACE FOR ABSORBING ADDITIONAL SURFACES:'
      WRITE(6,'(5X,A8,2A20)') 'SURFACE','COUNT','AVERAGE TIME (s)'
      DO MSURF=1,NLIMI
        IF (ILIIN(MSURF).EQ.2) 
     .    WRITE(6,'(5X,I8,1P,2E20.2,0P)')
     .      MSURF,slADDS(0,MSURF),
     .      slADDS(1,MSURF)/(slADDS(0,MSURF)+EPS30)
      ENDDO



8990  FORMAT(A)
8991  FORMAT(12(I6:))
8992  FORMAT(I6,1P,12(E12.4:))
8993  FORMAT(2I6,1P,12(E12.4:))
8994  FORMAT(2I6,1P,12(E15.7:))

      IF (output) WRITE(0,*) 'DONE'

8999  CONTINUE








C  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


c slmod end
      RETURN
C
      END
C
C
      SUBROUTINE MSHPROJ(X1,Y1,X2,Y2,X3,Y3,X4,Y4,PUX,PUY,PVX,PVY,
     .                   NDXA,NR1ST,IY)

      USE PRECISION
      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: X1(*), Y1(*), X2(*), Y2(*),
     .                      X3(*), Y3(*), X4(*), Y4(*)
      REAL(DP), INTENT(OUT) :: PUX(*), PUY(*), PVX(*), PVY(*)
      INTEGER, INTENT(IN) :: NDXA, NR1ST, IY
      REAL(DP) :: D12, D34, D13, D24, EPS60, PUPV, PVPV, DVX, DVY,
     .          DUX, DUY
      INTEGER :: IX, IN

      EPS60 = 1.E-60_DP
C
C
      DO 1 IX=1,NDXA
C
C  CALCULATE THE NORM OF THE VECTORS (POINT2-POINT1),....
C
        D12 = SQRT((X2(IX)-X1(IX))*(X2(IX)-X1(IX))+(Y2(IX)-Y1(IX))*
     .        (Y2(IX)-Y1(IX)))+EPS60
        D34 = SQRT((X4(IX)-X3(IX))*(X4(IX)-X3(IX))+(Y4(IX)-Y3(IX))*
     .        (Y4(IX)-Y3(IX)))+EPS60
        D13 = SQRT((X3(IX)-X1(IX))*(X3(IX)-X1(IX))+(Y3(IX)-Y1(IX))*
     .        (Y3(IX)-Y1(IX)))+EPS60
        D24 = SQRT((X4(IX)-X2(IX))*(X4(IX)-X2(IX))+(Y4(IX)-Y2(IX))*
     .        (Y4(IX)-Y2(IX)))+EPS60
C
C  CALCULATE THE BISSECTING VECTORS, BUT NOT NORMALISED YET
C
        DUX = (X2(IX)-X1(IX))/D12 + (X4(IX)-X3(IX))/D34
        DUY = (Y2(IX)-Y1(IX))/D12 + (Y4(IX)-Y3(IX))/D34
        DVX = (X3(IX)-X1(IX))/D13 + (X4(IX)-X2(IX))/D24
        DVY = (Y3(IX)-Y1(IX))/D13 + (Y4(IX)-Y2(IX))/D24
C
C  CALCULATE THE COMPONENTS OF THE TWO UNIT VECTOR (= PROJECTION RATE)
C
        IN=IY+(IX-1)*NR1ST
        PUX(IN) = DUX/(SQRT(DUX*DUX+DUY*DUY)+EPS60)
        PUY(IN) = DUY/(SQRT(DUX*DUX+DUY*DUY)+EPS60)
        PVX(IN) = DVX/(SQRT(DVX*DVX+DVY*DVY)+EPS60)
        PVY(IN) = DVY/(SQRT(DVX*DVX+DVY*DVY)+EPS60)
C
C  ORTHOGONORMALIZE, CONSERVE ORIENTATION (E.SCHMIDT)
C
        PUPV=PUX(IN)*PVX(IN)+PUY(IN)*PVY(IN)
        PVX(IN)=PVX(IN)-PUPV*PUX(IN)
        PVY(IN)=PVY(IN)-PUPV*PUY(IN)
        PVPV=SQRT(PVX(IN)*PVX(IN)+PVY(IN)*PVY(IN))+EPS60
        PVX(IN)=PVX(IN)/PVPV
        PVY(IN)=PVY(IN)/PVPV
C
1     CONTINUE
      RETURN
      END
C
C
*//NEUTR//
C=======================================================================
C          S U B R O U T I N E   N E U T R
C=======================================================================
      SUBROUTINE NEUTR(KARD,NDIMX,NDIMY,NDIMF,DUMMY,LDMX,LDMY,LDMF,
     .                 LDNS,IS)

      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: KARD, NDIMX, NDIMY, NDIMF, LDMX, LDMY,
     .                       LDMF, LDNS, IS
      REAL(DP), INTENT(IN) :: DUMMY(0:LDMX+1,0:LDMY+1,LDMF,LDNS)
      INTEGER :: ND1, LIM, IX, IY, III, IF
C
      ND1 = NDIMX
      LIM = (ND1/5)*5 - 4
      DO  500  IF = 1,NDIMF
        DO  110  IY = 1,NDIMY
          DO  100  IX = 1,LIM,5
  100     WRITE(KARD,910) (DUMMY(IX-1+III,IY,IF,IS),III = 1,5)
          IF( (LIM+4).EQ.ND1 )   GOTO 110
          WRITE(KARD,910) (DUMMY(IX,IY,IF,IS),IX = LIM+5,ND1)
  110   CONTINUE
  500 CONTINUE
      RETURN
  910 FORMAT(5(E16.8))
*//END NEUTR//
      END
C
*//PLASM//
C=======================================================================
C          S U B R O U T I N E   P L A S M
C=======================================================================
      SUBROUTINE PLASM(KARD,NDIMX,NDIMY,NDIMF,N,M,NF,DUMMY)

      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: KARD, NDIMX, NDIMY, NDIMF, N, M, NF
      REAL(DP), INTENT(OUT) :: DUMMY(0:N+1,0:M+1,NF)
      INTEGER :: ND1, LIM, IF, III, IX, IY
c slmod begin
      CHARACTER(80) :: COMMENT2
c...  Read and output the header line for each data block (only for DIVIMP):
      READ (31,'(A)') COMMENT2
      WRITE( 6,'(A)') 'PLASM: '//comment2
c slmod end
      ND1 = NDIMX + 2
      LIM = (ND1/5)*5 - 4
      DO    110  IF = 1,NDIMF
      DO    110  IY = 0,NDIMY+1
      DO    100  IX = 1,LIM,5
100     READ(KARD,910,END=500) (DUMMY(-1+IX-1+III,IY,IF),III = 1,5)
        IF( (LIM+4).EQ.ND1 )     GOTO 110
        READ(KARD,910,END=500) (DUMMY(-1+IX,IY,IF),IX = LIM+5,ND1)
110   CONTINUE
500   RETURN
910   FORMAT(5(E16.8))
*//END PLASM//
      END
C
C
      SUBROUTINE STATIS_COP

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CGRID
      USE CSDVI
      USE CSDVI_COP
      USE COUTAU

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: XN, FSIG, ZFLUX
      INTEGER, INTENT(IN) :: NBIN, NRIN, NPIN, NTIN, NSIN
      LOGICAL, INTENT(IN) :: LP, LT

      REAL(DP) :: XNM, SD2, DS, ZFLUXQ, SD2S, SDS, SDI, SDE, D2S, SG,
     .          DSA, DD, D, SG2, DA, SD1, SD1S
      INTEGER :: IPLS, NSB, IR, ICO, IPL, NP2, NR1, ICPV, NT3
C
      SAVE
C
      ENTRY STATS0_COP
C
      RETURN

C
      ENTRY STATS1_COP(NBIN,NRIN,NPIN,NTIN,NSIN,LP,LT)
      NSB=NBIN
      NR1=NRIN
      NP2=NPIN
      NT3=NTIN
C
C
      IF (NCPVI.EQ.0) RETURN
C
C
C
C  STATISTICS FOR MOMENTUM SOURCES
      DO 1012 ICPV=NPLSI+1,NCPVI
C
        IF (LMETSP(NSPAN(NTALM)+ICPV-1)) THEN
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SD1=COPV(ICPV,IR)-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR)=COPV(ICPV,IR)
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
1012  CONTINUE
C
C  STATISTICS FOR PARTICLE SOURCES
      ICPV=NCPVI
      DO IPL = 1,NPLSI
        IF (LMETSP(NSPAN(11)+IPL-1) .OR.
     .      LMETSP(NSPAN(16)+IPL-1) .OR.
     .      LMETSP(NSPAN(21)+IPL-1) ) THEN
          ICPV = NCPVI + IPL
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SDS=PAPL(IPL,IR)+PIPL(IPL,IR)+PMPL(IPL,IR)
            SD1=SDS-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR)=SDS
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
      END DO
C
C  STATISTICS FOR ELECTRON AND ION ENERGY SOURCES
      ICPV=NCPVI+NPLSI
      SD1S=0.
      SD2S=0.
      DO ICO = 1,NCLMT
        IR = ICLMT(ICO)
        SDE=EAEL(IR)+EIEL(IR)+EMEL(IR)
        SDI=EAPL(IR)+EIPL(IR)+EMPL(IR)
        SD1=SDE-SDVIA_COP(ICPV+1,IR)
        SD2=SDI-SDVIA_COP(ICPV+2,IR)
        SD1S=SD1S+SD1
        SD2S=SD2S+SD2
        SDVIA_COP(ICPV+1,IR) = SDE
        SDVIA_COP(ICPV+2,IR) = SDI
        SIGMA_COP(ICPV+1,IR)=SIGMA_COP(ICPV+1,IR)+SD1*SD1
        SIGMA_COP(ICPV+2,IR)=SIGMA_COP(ICPV+2,IR)+SD2*SD2
      END DO
      SGMS_COP(ICPV+1)=SGMS_COP(ICPV+1)+SD1S*SD1S

C
C
1020  CONTINUE
      RETURN
C
      ENTRY STATS2_COP(XN,FSIG,ZFLUX)
C
C  1. FALL  ALLE BEITRAEGE GLEICHES VORZEICHEN: SIG ZWISCHEN 0 UND 1
C           (=1, FALLS NUR EIN BEITRAG UNGLEICH 0, ODER (KUENSTLICH
C            ERZWUNGEN) FALLS GAR KEIN BEITRAG UNGLEICH NULL)
C  2. FALL  NEGATIVE UND POSITIVE BEITRAGE KOMMEN VOR:
C           LT. FORMEL SIND AUCH WERTE GROESSER 1  MOEGLICH.
C
      XNM=XN-1.
      IF (XNM.LE.0.) RETURN
      ZFLUXQ=ZFLUX*ZFLUX
C
      IF (NCPVI.EQ.0) GOTO 2200
C
C  STATISTICS FOR MOMENTUM SOURCES
      DO 2112 ICPV=NPLSI+1,NCPVI
C
        DS=SUM(COPV(ICPV,1:NSB))
        DO 2111 IR=1,NSB
          D=COPV(ICPV,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
2111    CONTINUE
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
2112  CONTINUE
C
C  STATISTICS FOR PARTICLE SOURCES
      ICPV = NCPVI
      DO IPLS=1,NPLSI
C
        ICPV = ICPV + 1
        DS=SUM(PAPL(IPLS,1:NSB))+SUM(PIPL(IPLS,1:NSB))+
     .     SUM(PMPL(IPLS,1:NSB))
        DO IR=1,NSB
          D=PAPL(IPLS,IR)+PMPL(IPLS,IR)+PIPL(IPLS,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
      END DO
C
C  STATISTICS FOR ELECTRON ENERGY SOURCES
        DS=SUM(EAEL(1:NSB))+SUM(EIEL(1:NSB))+SUM(EMEL(1:NSB))
        DO IR=1,NSB
          D=EAEL(IR)+EMEL(IR)+EIEL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV+1,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+1,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+1,IR)=STV_COP(ICPV+1,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+1,IR)=EE_COP(ICPV+1,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV+1)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+1)=SG*FSIG
C
        STVS_COP(ICPV+1)=STVS_COP(ICPV+1)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+1)=EES_COP(ICPV+1)+DS*ZFLUX/XN
C
C  STATISTICS FOR ION ENERGY SOURCES
        DS=SUM(EAPL(1:NSB))+SUM(EIPL(1:NSB))+SUM(EMPL(1:NSB))
        DO IR=1,NSB
          D=EAPL(IR)+EMPL(IR)+EIPL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV+2,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+2,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+2,IR)=STV_COP(ICPV+2,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+2,IR)=EE_COP(ICPV+2,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV+2)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+2)=SG*FSIG
C
        STVS_COP(ICPV+2)=STVS_COP(ICPV+2)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+2)=EES_COP(ICPV+2)+DS*ZFLUX/XN
C
2200  CONTINUE
      RETURN
      END
C
C
      SUBROUTINE UPSCOP
      RETURN
      END
C
C
      SUBROUTINE UPTCOP(XSTOR2,XSTORV2,WV)
C
C  USER SUPPLIED TRACKLENGTH ESTIMATOR, VOLUME AVERAGED
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CGEOM
      USE COMPRT
      USE CSDVI
      USE COMXS

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: XSTOR2(MSTOR1,MSTOR2,N2ND+N3RD),
     .                      XSTORV2(NSTORV,N2ND+N3RD), WV
      REAL(DP) :: P, WTRSIG, EION, V0_PARB, DIST, WTR, MOMPARA
      INTEGER :: IAEL, IRELM IPL2, IAEI, IRDS, IBGK, IICX, IIEI, IIEL,
     .           IMEL, IPL1, I, IPL, IIO, IRD, IP, IR, IML, IAT, IFIRST,
     .           IRCX, IADD, ICOU, NMTSP, IACX, IRDD, IMCX, IMEI, IPL2,
     .           IREL
      REAL(DP), ALLOCATABLE, SAVE ::
     . CNDYNA(:), CNDYNM(:), CNDYNI(:)
CDR
      REAL(DP), ALLOCATABLE, SAVE ::
     . VPX(:),    VPY(:),    VRX(:),    VRY(:)
CDR
      DATA IFIRST/0/
      SAVE
      IF (IFIRST.EQ.0) THEN
c slmod begin
        WRITE(0,*) 'COPV2 NOT PROCESSED IN UPTCOP'
c slmod end
        IFIRST=1
        ALLOCATE (CNDYNA(NATM))
        ALLOCATE (CNDYNM(NMOL))
        ALLOCATE (CNDYNI(NION))
        ALLOCATE (VPX(NRAD))
        ALLOCATE (VPY(NRAD))
        ALLOCATE (VRX(NRAD))
        ALLOCATE (VRY(NRAD))
        DO 11 IAT=1,NATMI
11        CNDYNA(IAT)=AMUA*RMASSA(IAT)
        DO 12 IML=1,NMOLI
12        CNDYNM(IML)=AMUA*RMASSM(IML)
        DO 13 IIO=1,NIONI
13        CNDYNI(IIO)=AMUA*RMASSI(IIO)
C
CDR
CDR  PROVIDE A RADIAL UNIT VECTOR PER CELL
CDR  VPX,VPY,  NEEDED FOR PROJECTING PARTICLE VELOCITIES
C
CDR  SAME FOR POLOIDAL UNIT VECTOR VRX,VRY
C
        DO 1 I=1,NRAD
          VPX(I)=0.
          VPY(I)=0.
          VRX(I)=0.
          VRY(I)=0.
1       CONTINUE
        DO 2 IR=1,NR1STM
          DO 2 IP=1,NP2NDM
            IRD=IR+(IP-1)*NR1P2
            VPX(IRD)=PLNX(IR,IP)
            VPY(IRD)=PLNY(IR,IP)
            VRX(IRD)=PPLNX(IR,IP)
            VRY(IRD)=PPLNY(IR,IP)
2       CONTINUE
C
        NMTSP=NATMI+NMOLI+NIONI+NPLSI+NADVI+NALVI
C
      ENDIF
C
C  WV=WEIGHT/VEL
C
C  ATOMS
      IF (ITYP.EQ.1) THEN
        DO 20 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
          IRDD=NCLTAL(IRD)
C
          IF (LGVAC(IRD,0)) GOTO 20
C
          XSTOR(:,:) = XSTOR2(:,:,ICOU)
          XSTORV(:) = XSTORV2(:,ICOU)
C
C  1,NPLSI:
C              PARTICLE CHARGE EXCHANGE RATE DUE TO IPLS: #/S
C              WITH ATOM SPECIES IATM=1,NATMI, PER ION
C  EACH RATE IS WEIGHTED WITH THE FACTOR (E0/EI-1), E0 BEING
C  THE NEUTRAL PARTCILE ENERGY, EI THE MEAN PLASMA ION ENERGY
C  THESE RATES ARE SCALED IN THE SHORT CYCLE WITH EI*NI
C
C
          IF (NCPVI.LT.NPLSI) GOTO 20
C
          IF (LGACX(IATM,0,0).EQ.0) GOTO 51
          DO 52 IACX=1,NACXI(IATM)
            IRCX=LGACX(IATM,IACX,0)
            IPLS=LGACX(IATM,IACX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 52
            EION=1.5*TIIN(IPLS,IRD)+EDRIFT(IPLS,IRD)
            WTRSIG=WTR*SIGVCX(IRCX)/DIIN(IPLS,IRD)
c slmod begin
           COPV (IPLS,IRD     )=COPV (IPLS,IRD     )+WTRSIG*(E0/EION-1.)
           COPV2(IPLS,IRD,IN01)=COPV2(IPLS,IRD,IN01)+WTRSIG*(E0/EION-1.)
c
c            COPV(IPLS,IRD)=COPV(IPLS,IRD)+WTRSIG*(E0/EION-1.)
c slmod end
            LMETSP(NMTSP+IPLS)=.TRUE.
52        CONTINUE
51        CONTINUE
C
C.........................................
C
C   MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C.........................................
C
C
C  CONTRIBUTIONS FROM ATOMS
C  NPLSI+1, 2*NPLSI:
C
          IF (NCPVI.LT.2*NPLSI) GOTO 20
C
          IADD=NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNA(IATM)
C
          IF (LGACX(IATM,0,0).EQ.0) GOTO 59
          DO 56 IACX=1,NACXI(IATM)
            IRCX=LGACX(IATM,IACX,0)
            IPLS=LGACX(IATM,IACX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 56
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 56
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHA
C
            MOMPARA=PARMOM(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*MOMPARA
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                        SIGN(1._DP,BVIN(IPLS,IRD))
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
56        CONTINUE
59        CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 61 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 62 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  WTRSIG=WTR*SIGVEI(IRDS)*P
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
                  COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                            SIGN(1._DP,BVIN(IPL,IRD))
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
62            CONTINUE
            ENDIF
61        CONTINUE
C
C  ION IMPACT IONIZATION CONTRIBUTION: NOT INCLUDED
C
C
C  ELASTIC CONTRIBUTION FROM ATOMS
C
C
          IF (LGAEL(IATM,0,0).EQ.0) GOTO 80
C  DEFAULT TRACKLENGTH ESTIMATOR (BGK APPROXIMATION)
          DO 81  IAEL=1,NAELI(IATM)
            IREL=LGAEL(IATM,IAEL,0)
            IPLS=LGAEL(IATM,IAEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 81
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 81
C
            MOMPARA=PARMOM(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
C
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                      SIGN(1._DP,BVIN(IPLS,IRD))
            LMETSP(NMTSP+IPL2)=.TRUE.
81        CONTINUE
80      CONTINUE
C
20      CONTINUE
C
C  MOLECULES
      ELSEIF (ITYP.EQ.2) THEN
C
        DO 200 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
          IRDD=NCLTAL(IRD)
C
          IF (LGVAC(IRD,0)) GOTO 200
C
          XSTOR(:,:) = XSTOR2(:,:,ICOU)
          XSTORV(:) = XSTORV2(:,ICOU)
C
C             MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C
C
C
C  CONTRIBUTIONS FROM MOLECULES
C  2*NPLSI+1, 3*NPLSI:
C
          IF (NCPVI.LT.3*NPLSI) GOTO 200
C
          IADD=2*NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNM(IMOL)
C
          IF (LGMCX(IMOL,0,0).EQ.0) GOTO 590
          DO 560 IMCX=1,NMCXI(IMOL)
            IRCX=LGMCX(IMOL,IMCX,0)
            IPLS=LGMCX(IMOL,IMCX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 560
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 560
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHM
C
            MOMPARA=PARMOM(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*MOMPARA
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                        SIGN(1._DP,BVIN(IPLS,IRD))
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
560       CONTINUE
590       CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 610 IMEI=1,NMDSI(IMOL)
            IRDS=LGMEI(IMOL,IMEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 620 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  WTRSIG=WTR*SIGVEI(IRDS)*P
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
                  COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                            SIGN(1._DP,BVIN(IPL,IRD))
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
620           CONTINUE
            ENDIF
610       CONTINUE
C
C
C  ELASTIC CONTRIBUTION FROM MOLECULES
C
C
          IF (LGMEL(IMOL,0,0).EQ.0) GOTO 800
C  DEFAULT TRACKLENGTH ESTIMATOR
          DO 810 IMEL=1,NMELI(IMOL)
            IREL=LGMEL(IMOL,IMEL,0)
            IPLS=LGMEL(IMOL,IMEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 810
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 810
C
            MOMPARA=PARMOM(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
C
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                      SIGN(1._DP,BVIN(IPLS,IRD))
            LMETSP(NMTSP+IPL2)=.TRUE.
810       CONTINUE
800     CONTINUE
C
C
200     CONTINUE
C
C  TEST IONS
C
      ELSEIF (ITYP.EQ.3) THEN
C
        DO 2000 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
          IRDD=NCLTAL(IRD)
C
          IF (LGVAC(IRD,0)) GOTO 2000
C
          XSTOR(:,:) = XSTOR2(:,:,ICOU)
          XSTORV(:) = XSTORV2(:,ICOU)
C
C             MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C
C
C
C  CONTRIBUTIONS FROM TEST IONS
C  3*NPLSI+1, 4*NPLSI:
C
          IF (NCPVI.LT.4*NPLSI) GOTO 2000
C
          IADD=3*NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNI(IION)
C
          IF (LGICX(IION,0,0).EQ.0) GOTO 5900
          DO 5600 IICX=1,NICXI(IION)
            IRCX=LGICX(IION,IICX,0)
            IPLS=LGICX(IION,IICX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 5600
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 5600
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHI
C
            MOMPARA=PARMOM(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
C
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*MOMPARA
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                        SIGN(1._DP,BVIN(IPLS,IRD))
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
5600      CONTINUE
5900      CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 6100 IIEI=1,NIDSI(IION)
            IRDS=LGIEI(IION,IIEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 6200 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  WTRSIG=WTR*SIGVEI(IRDS)*P
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
                  COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                            SIGN(1._DP,BVIN(IPL,IRD))
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
6200          CONTINUE
            ENDIF
6100      CONTINUE
C
C
C  ELASTIC CONTRIBUTION FROM TEST IONS
C
          IF (LGIEL(IION,0,0).EQ.0) GOTO 8000
C  DEFAULT TRACKLENGTH ESTIMATOR
          DO 8100 IIEL=1,NIELI(IION)
            IREL=LGIEL(IION,IIEL,0)
            IPLS=LGIEL(IION,IIEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 8100
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 8100
C
            MOMPARA=PARMOM(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
C
            IPL1=IADD+IPLS
            COPV(IPL1,IRDD)=COPV(IPL1,IRDD)-WTRSIG*MOMPARA
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV(IPL2,IRDD)=COPV(IPL2,IRDD)+WTRSIG*V0_PARB*
     .                      SIGN(1._DP,BVIN(IPLS,IRD))
            LMETSP(NMTSP+IPL2)=.TRUE.
8100      CONTINUE
8000    CONTINUE
C
C
2000    CONTINUE
C
C
      ENDIF
C
      RETURN
      END
