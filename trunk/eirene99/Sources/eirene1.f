C
C
C     EIRENE VERSION 2/99
C
C
      PROGRAM EIRENE_MAIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c slmod begin - debug - tr
      INCLUDE 'PARMMOD'
      INCLUDE 'CGRID'
      INCLUDE 'COMUSR'

      COMMON /MULCOM/ IOPT1

c slmod begin - temp
c...TEMP 
      COMMON /SLTEMP1/ e0sum,e0num,e0avg
      REAL*8           e0sum,e0num,e0avg

      COMMON /DELTAE0COM/ DELTAE0,NDELTAE0
      REAL*8              DELTAE0,NDELTAE0


c slmod end

c...sltmp
c      INCLUDE 'CCOUPL'
c      INCLUDE 'COMXS'
c      INCLUDE 'CSTEP'
c      INCLUDE 'CLGIN'
      INCLUDE 'CGEOM'


      NDELTAE0=0.0D0
      DELTAE0=0.0D0

c      WRITE(0,*) 'NLIMPS=',nlimps
c      WRITE(0,*) 'NLIMPB=',nlimpb
c      WRITE(0,*) 'NOPTIM=',noptim

c      WRITE(0,*) 'EIRENE99 STARTED'
 
c      output = .TRUE.
      output = .FALSE.

      IF (output) THEN
c      WRITE(0,*) 'RUNNING NEW VERSION - SMALL GRID ONLY PLEASE '//
c     .           '(ARRAYS NEED ENLARGING)'
c      WRITE(0,*) 'UPDATE NMOMCHA'
c      WRITE(0,*) 'NON-DEFAULT SURFACE OVER_RIDE TURNED OFF'
c      WRITE(0,*) '!!! RANDOM NUMBER SEED SELECTION TURNED OFF !!!'
      WRITE(0,*) 'ACCOUNT FOR NGHPLS'
      WRITE(0,*) 'NEED MOMENTUM CHANNEL FOR TEST IONS'
c      WRITE(0,*) 'FIND OUT WHAT CHCTRC IS'
c      WRITE(0,*) 'SORT OUT RRSTEP (IS IT IMPORTANT? OLD?)'
c      WRITE(0,*) 'ARE POLOIDAL SURFACES CORRECT?'
      ENDIF

      IOPT1=1

      EIRTORFRAC=1.0D0

      IF (output) THEN
        WRITE(0,*) 'MARK: IOPT1= ',IOPT1
        WRITE(6,*) 'MARK: IOPT1= ',IOPT1
      ENDIF

      rdum1 = reset_second()
c slmod end
C
      CALL GRSTRT(35,8)
C
      VOLCOR2=1.0D0

      DT=0.D0
      CALL EIRENE(DT,.FALSE.)
C
c slmod begin - debug - not tr
      IF (debugopt.NE.0) THEN
        WRITE(0,*) 'Total geometry checks: ',CHKCNT,
     .    '  errors: ',CHKERR
        WRITE(0,*)
      ENDIF


c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,6E12.4,0P)')
c     .      'DIIN: ',IX,IY,J,(diin(i1,j),i1=1,6)
c        ENDDO
c      ENDDO
c
c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,6E12.4,0P)')
c     .      'TIIN: ',IX,IY,J,(Tiin(i1,j),i1=1,6)
c        ENDDO
c      ENDDO
c
c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,6E12.4,0P)')
c     .      'vxIN: ',IX,IY,J,(vxin(i1,j),i1=1,6)
c        ENDDO
c      ENDDO
c
c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,6E12.4,0P)')
c     .      'vyIN: ',IX,IY,J,(vyin(i1,j),i1=1,6)
c        ENDDO
c      ENDDO
c
c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,6E12.4,0P)')
c     .      'vzIN: ',IX,IY,J,(vzin(i1,j),i1=1,6)
c        ENDDO
c      ENDDO
c

c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,2E12.4,0P,F6.2,1P,E10.2,0P)')
c     .      'TABRCM: ',IX,IY,J,tabrc1(1,J)/dein(j),TABRCM(1,J),
c     .      tein(j),dein(j)
c        ENDDO
c      ENDDO

c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,2E12.4,0P,F6.2,1P,E10.2,0P)')
c     .      'TABREM: ',IX,IY,J,eelrc1(1,J)/dein(j),TABREM(1,J),
c     .      tein(j),dein(j)
c        ENDDO
c      ENDDO


c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,3E12.4,0P)')
c     .      'TABDSM: ',IX,IY,J,tabds1(1,J),TABDSM(1,J),dein(j)
c        ENDDO
c      ENDDO

c      WRITE(6,*)
c      DO IY=1,NDYA
c        DO IX =1,NDXA
c          j=IY+(IX-1)*NR1ST
c          WRITE(6,'(A,3I4,1P,3E12.4,0P)')
c     .      'TABDEM: ',IX,IY,J,eelds1(1,J),TABDEM(1,J),dein(j)
c        ENDDO
c      ENDDO


      WRITE(32,'(A)') '[LAST LINE]'


c      WRITE(0,*) 'E0AVG=',e0sum/(e0num+1.0D-10)

c      WRITE(0,*) 'CALLING: GREND from EIRENE_MAIN'

c          WRITE(6,*) 'ADDCEL END: ',nsurf+nradd,nsbox
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .          IPLS,IN,
c     .          DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .          VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .          VZIN(IPLS,IN),
c     .          BXIN(IN),BYIN(IN),BZIN(IN)
c            ENDDO
c          ENDDO

c          WRITE(6,*) 'STDCEL END: ',nsurf,nsbox
c          DO IPLS = 1, NPLSI
c            DO IN = 1, NSURF
c              WRITE(6,'(2I6,1P,10E10.2,0P)') 
c     .          IPLS,IN,
c     .          DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .          VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .          VZIN(IPLS,IN),
c     .          BXIN(IN),BYIN(IN),BZIN(IN),
c     .          AREA(IN),VOL(IN)
c            ENDDO
c          ENDDO

c          WRITE(6,*) 'TABEL3 END: '
c          DO IN = NSURF+1, NSURF+NRADD
c            WRITE(6,'(I6,1P,4E10.2,0P)') 
c     .        IN,(TABEL3(I1,IN,1),I1=1,4)
c          ENDDO


c        DO J=1,NSURF
c          WRITE(6,*) 'tiin2:',j,tein(j)
c        ENDDO

      WRITE(0,*)
      WRITE(6,*) 'AVERAGE DELTAE0=',deltae0/ndeltae0


c slmod end
      CALL GREND
C
      STOP
      END
C
C
      SUBROUTINE EIRENE(DT,NLMODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  DT >  0.      : RUN EIRENE FOR A TIMESTEP DT (S),
C  DT <= 0.      : RUN EIRENE IN QUASI STEADY STATE MODE
C  NLMODE=.FALSE.: STAND ALONE EIRENE RUN
C  NLMODE=.TRUE. : CALLED FROM INTERFACING ROUTINE EIRSRT
C                  PLASMA DATA ON COMMON BRAEIR IN SUBROUTINE INFCOP.
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMUSR'
      INCLUDE 'CAI'
      INCLUDE 'CPLOT'
      INCLUDE 'CTRCEI'
      INCLUDE 'CLOGAU'
      INCLUDE 'COMSIG'
      INCLUDE 'CUPD'
      INCLUDE 'COMSOU'
      INCLUDE 'COMXS'
      INCLUDE 'CTEXT'
      INCLUDE 'COMPRT'
      INCLUDE 'COMNNL'
      INCLUDE 'CCOUPL'
      INCLUDE 'COUTAU'
      INCLUDE 'CRECH'
      INCLUDE 'CSDVI'
      INCLUDE 'CSDVI_BGK'
c slmod begin - bug? - not tr
c I think that CGRID was omitted, but was needed.
      INCLUDE 'CESTIM'
      INCLUDE 'CGRID'
c slmod end
      DIMENSION RCMDTA(NMDTA),ICMDTA(MMDTA)
      EQUIVALENCE (RCMDTA(1),TABDS1(1,1))
      EQUIVALENCE (ICMDTA(1),MODCOL(1,1,1,0))
      LOGICAL NLMODE
C
C               1.         INITIALIZE PACKAGE
C
      NRAPS=60
      IRAPS=0
      IITER=1
      ITIMV=1
      IPRNLI=0
      DTIMVN=DT
      NLPLAS=NLMODE
C
100   CONTINUE
C
C  CHECK PARAMETER STATEMENTS, STORAGE REQUIREMENTS
C
      CALL SETPRM
C
C   SET DEFAULTS
C
      CALL SETCON
      CALL SETTXT
C
C  READ FORMATTED INPUT FILE OR RESTART FOR NEXT ITERATION
C
      ENTRY EIRENE_COUPLE
C
101   CONTINUE
c slmod begin - tr (modified)
      IF (output) THEN
        WRITE(0,*) 'BLANKING COPV2'
        WRITE(6,*) 'BLANKING COPV2'
      ENDIF

      IF (.FALSE.) THEN
        IN01 =  1
        IN02 =  2 
        IN03 =  3 
        IN04 =  4 
        IN05 =  5 
        IN06 =  6 
        IN07 =  7
        IN08 =  8
        IN09 =  9
        IN10 = 10
        IN11 = 11
        IN12 = 12
        IN13 = 13
        IN14 = 14
        IN15 = 15
      ELSE
        IN01 =  1
        IN02 =  1 
        IN03 =  1 
        IN04 =  1 
        IN05 =  1 
        IN06 =  1 
        IN07 =  1
        IN08 =  1
        IN09 =  1
        IN10 =  1
        IN11 =  1
        IN12 =  1
        IN13 =  1
        IN14 =  1
        IN15 =  1
      ENDIF


      DO I1 = 1, NCPV
        DO I2 = 1, NRAD
          DO I3 = 0, NMOMCHA
            COPV2(I1,I2,I3) = 0.0D0
            COPV3(I1,I2,I3) = 0.0D0
          ENDDO
        ENDDO
      ENDDO

c slmod end
      TIMI=SECOND_OWN()
C
      CALL INPUT
C
      TIME=SECOND_OWN()
      WRITE (6,*) 'CPU-TIME CONSUMED IN INPUT: ',TIME-TIMI,' SEC'
      CALL LEER(1)
C
C  SET UP SPLITTING SURFACES, IMPORTANCE FUNCTION AND OTHER DATA
C  FOR NONANALOG METHODS
C
      IF (.NOT.NLANA) THEN
        CALL NANALG
      ELSEIF (NLANA) THEN
C  TURN OF ALL NON-ANALOG SAMPLING
        CALL MASBOX('NON-ANALOG SAMPLING DE-ACTIVATED')
C 1: NO SPLITTING AND RUSSIAN ROULETTE
        WRITE (6,*) 'SUBROUTINE NANALG NOT CALLED '
C 2: SPECIES SOURCE SAMPLING
        DO ISTRA=1,NSTRAI
          NSPEZ(ISTRA)=MAX(0,NSPEZ(ISTRA))
        ENDDO
        WRITE (6,*) 'NON-ANALOG SOURCE SPECIES SAMPLING TURNED OFF'
C 3: SUPPRESION OF ABSORPTION AT SURFACES TURNED OFF
        WMINS=1.D30
        WRITE (6,*) 'SUPPRESION OF ABSORPTION AT SURFACES TURNED OFF'
C 4: SUPPRESION OF ABSORPTION AT COLLISIONS TURNED OFF
        WMINV=1.D30
        WRITE (6,*) 'SUPPRESION OF ABSORPTION AT COLLISIONS TURNED OFF'
        CALL LEER(2)
      ENDIF
C
      TIMI=SECOND_OWN()
C
C
C  PARAMETERS FOR BGK ITERATIONS
C
      NRBG=NBGV
      NBGVI=NRBGI
      NFSTVI(NTALB)=NBGVI
      NBGVI_STAT=0
      IF (NSIGI_BGK > 0) NBGVI_STAT=NBGVI+2*(NATMI+NMOLI)
      IF (NBGVI_STAT > NBGV_STAT) THEN
        CALL MASPRM('NBGVI_STAT',10,NBGVI_STAT,
     .              'NBGV_STAT',9,NBGV_STAT,IERROR)
        CALL EXIT
      END IF
C
      IF (TRCAMD) THEN
        CALL LEER(1)
        WRITE (6,*) 'NRCXI,NRCX ',NRCXI,NRCX
        WRITE (6,*) 'NRELI,NREL ',NRELI,NREL
        WRITE (6,*) 'NRPII,NRPI ',NRPII,NRPI
        WRITE (6,*) 'NREII,NREI ',NREII,NRDS
        WRITE (6,*) 'NRRCI,NREC ',NRRCI,NREC
        CALL LEER(1)
      ENDIF
C
C
C  READ EIRENE STATISTICAL RECOMMENDATIONS FROM PREVIOUS RUN,
C  AND CARRY THEM OUT
C
      IF (NFILEK.EQ.2.OR.NFILEK.EQ.3) THEN
        CALL RREC
        WRITE (6,*) 'STRATIFIED SOURCE SAMPLING:'
        WRITE (6,*) 'NPTS(ISTRA) ARE MODIFIED, DUE TO NFILEK.GE.2 '
        DO 162 ISTRA=1,NSTRAI
          WRITE (6,*) ISTRA,' NPTS(INP)= ',NPTS(ISTRA),
     .                      ' NPTS(MOD)= ',NRECOM(ISTRA)
          NPTS(ISTRA)=NRECOM(ISTRA)
162     CONTINUE
      ENDIF
C
C  PUT SELECTED EIRENE ATOMIC DATA FIELDS ONTO ADIN-ARRAY FOR OUTPUT
C
      DO 170 IAIN=1,NAINI
        NS=NAINS(IAIN)
        NA=NAINT(IAIN)
C
        IF (NSTORDR < NRAD) GOTO 170
        IF (NA.EQ.20) THEN
          DO 1720 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=TABDS1(NS,ICELL)
1720      CONTINUE
        ELSEIF (NA.EQ.21) THEN
          DO 1721 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=EELDS1(NS,ICELL)
1721      CONTINUE
        ELSEIF (NA.EQ.22) THEN
          DO 1722 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=TABCX3(NS,ICELL,1)
1722      CONTINUE
        ELSEIF (NA.EQ.23) THEN
          DO 1723 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=EPLCX3(NS,ICELL,1)
1723      CONTINUE
        ELSEIF (NA.EQ.24) THEN
          DO 1724 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=TABEL3(NS,ICELL,1)
1724      CONTINUE
        ELSEIF (NA.EQ.25) THEN
          DO 1725 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=EPLEL3(NS,ICELL,1)
1725      CONTINUE
        ELSEIF (NA.EQ.26) THEN
          DO 1726 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=TABPI3(NS,ICELL,1)
1726      CONTINUE
        ELSEIF (NA.EQ.27) THEN
          DO 1727 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=EPLPI3(NS,ICELL,1)
1727      CONTINUE
        ELSEIF (NA.EQ.28) THEN
          DO 1728 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=TABRC1(NS,ICELL)
1728      CONTINUE
        ELSEIF (NA.EQ.29) THEN
          DO 1729 ICELL=1,NSBOX
            ADIN(IAIN,ICELL)=EELRC1(NS,ICELL)
1729      CONTINUE
        ENDIF
170   CONTINUE
C
C  PRINT VOLUME AVERAGED INPUT TALLIES.
C
      CALL OUTPLA
C
      TIME=SECOND_OWN()
      WRITE (6,*) 'CPU-TIME CONSUMED IN XSECT: ',TIME-TIMI,' SEC'
      CALL LEER(1)
C
C               2.         PLOT GEOMETRY
C
200   CONTINUE
      CALL PLT2D
C
C               3.         MONTE CARLO CALCULATION
C
300   CONTINUE
c slmod begin - debug - not tr
      IF (debugopt.NE.0) THEN
c        WRITE(0,*)
c        WRITE(0,*) '=================================='
c        WRITE(0,*)
c        WRITE(0,*) 'grid option            ',gridopt
c        WRITE(0,*) 'geometry source option ',geomopt
c        WRITE(0,*) 'geometry check option  ',gchkopt
c        WRITE(0,*) 'addusr option          ',addopt
c        WRITE(0,*) 'neutral wall option    ',neutopt
c        WRITE(0,*) 'debug option           ',debugopt
c        WRITE(0,*) 'print option           ',printopt
c        WRITE(0,*)
c        WRITE(0,*) '=================================='
c        WRITE(0,*)

        WRITE(0,*) 'EIRENE: Calling MCARLO'
      ENDIF
c slmod end
      CALL MCARLO
C
C               4.         OUTPUT , INTERFACE  AND PLOTTING
C
400   CONTINUE
C
C  OUTPUT FOR SELECTED STRATA AND/OR SUM OVER STRATA
C
      DO 450 ISTRA=1,NSTRAI
        IF (TRCSRC(ISTRA).OR.(NSTRAI.EQ.1.AND.TRCSRC(0)))
     .      CALL OUTEIR(ISTRA)
        IF (PLTSRC(ISTRA).OR.(NSTRAI.EQ.1.AND.PLTSRC(0)))
     .      CALL PLTEIR(ISTRA)
450   CONTINUE
C
      IF ((NSTRAI.GT.1) .AND. (NSMSTRA==1))  THEN
        IF (TRCSRC(0)) CALL OUTEIR(0)
        IF (PLTSRC(0)) CALL PLTEIR(0)
      ENDIF
C
C  WRITE FILES FOR RAPS GRAPHICS
C
      IF (IRAPS.GT.0) THEN
        CALL RPSOUT
        NRAPS=60
        IRAPS=0
      ENDIF
C
C  LAST CALL TO INTERFACING ROUTINE (GLOBAL BALANCES, ETC)
C
      IF (NMODE.GT.0) CALL IF4COP
C
C  CALL DIAGNOSTIC MODULE (COMPUTE LINE INTEGRALS FROM EIRENE TALLIES)
C
      IF (NCHORI.GT.0) CALL DIAGNO
C
      IF (NFILEN.EQ.2.OR.NFILEN.EQ.7) RETURN
C
C  CALL WRREC TO EVALUATE EIRENE STATISTICAL RECOMMENDATIONS
C  FOR NEXT RUN  AND WRITE THEM ON FT 14
C
      IF (NFILEK.EQ.1.OR.NFILEK.EQ.3) THEN
        CALL WRREC
      ENDIF
C
C  ITERATIVE MONTE CARLO PROBLEM: EIRENE RECALL OPTION
C
C  SUBROUTINE MODUSR IS A USER SUPPLIED SUBROUTINE, WHICH MAY BE USED
C  TO MODIFY SOME OF THE INPUT VARIABLES FOR THE NEXT ITERATION STEP.
C  MODUSR IS ALSO CALLED AFTER THE LAST ITERATION TO ALLOW
C  WRITING OF DATA ONTO SOME FILE AFTER EACH ITERATION
C
c slmod begin - tr (modified)
c          WRITE(6,*) 'DIIN CHECK 5: ',1,1,DIIN(1,1),nsurf+nradd,nsbox
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,*) 'CHECK5: ',IPLS,IN,
c     .                              DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .                              VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .                              VZIN(IPLS,IN)
c            ENDDO
c          ENDDO



      IF (NITER.GE.1.AND.IITER.LE.NITER) THEN
        CALL MODUSR
C  OUTPUT EIRENE BGK ADDITIONAL CELL DATA TO DIVIMP
        CALL ASDUSR
        IITER=IITER+1
        IF (IITER.LE.NITER) THEN
          DUMMY=RESET_SECOND()
          IPRNLI=0
c slmod begin - tr
C  RESET PARTICLE TRACK OUTPUT STREAM
          CLOSE(80)
          OPEN(UNIT=80,ACCESS='SEQUENTIAL',STATUS='REPLACE')
c slmod end
          GOTO 101
        ENDIF
      ELSEIF (NITER.EQ.0) THEN
C  OUTPUT EIRENE BGK ADDITIONAL CELL DATA TO DIVIMP
        CALL ASDUSR
      ENDIF
c
c      IF (NITER.GE.1.AND.IITER.LE.NITER) THEN
c        CALL MODUSR
c        IITER=IITER+1
c        IF (IITER.LE.NITER) THEN
c          DUMMY=RESET_SECOND()
c          IPRNLI=0
c          GOTO 101
c        ENDIF
c      ENDIF
c slmod end
C
C  SUBROUTINE STOSS IS A SUBROUTINE, IN WHICH BINARY COLLISION
C  EVENTS BETWEEN TEST PARTICLES ARE CARRIED OUT
C  STOSS IS ALSO CALLED AFTER THE LAST "TIMESTEP"
C
      IF (NTIME.GE.1) THEN
C  COLLISIONS BETWEEN TEST PARTICLES
C  MODIFY BACKGROUND (TIME DEP. MODE)
C       CALL STOSS
        CALL TMSTEP
        ITIMV=ITIMV+1
        IF (ITIMV.LE.NTIME) THEN
C  DO ONE MORE COMPLETE TIME-CYCLE IN THIS EIRENE RUN
          DUMMY=RESET_SECOND()
          IITER=1
          IPRNLI=0
          GOTO 101
        ENDIF
      ENDIF
C
      RETURN
      END
C
C  *************************
C  *                       *
C  * INITIALIZATION PHASE  *
C  *                       *
C  *************************
C
C      SUBROUTINE SETPRM
C      SUBROUTINE SETCON
C      SUBROUTINE SETTXT
C      SUBROUTINE INPUT
C      SUBROUTINE GRID
C      SUBROUTINE VOLUME
C      SUBROUTINE PLASMA
C      SUBROUTINE PLASMA_DERIV
C      SUBROUTINE PROFN(PRO,PRO0,PROS,P,Q,E,SEP,PROVAC)
C      SUBROUTINE PROFE(PRO,PRO0,RINP,A1,E,SEP,PROVAC)
C      SUBROUTINE PROFS(PRO,PRO0,PROS,SEP,PROVAC)
C      SUBROUTINE PROFR(PRO,INDEX,NSPZI,NSPZ1,NDAT)
C
      SUBROUTINE SETPRM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CESTIM'
      INCLUDE 'COUTAU'
      INCLUDE 'COMXS'
      INCLUDE 'CSDVI'
      INCLUDE 'COMUSR'
      INCLUDE 'CGEOM'
      INCLUDE 'CGRID'
      INCLUDE 'CPOLYG'
      INCLUDE 'CSPEI'
      INCLUDE 'CLGIN'
      DIMENSION OUTAU(NOUTAU),ESTIM(NESTIM),SDVI(NSDVI)
      EQUIVALENCE
     .  (OUTAU(1),PDENAI(0,0)),(ESTIM(1),PDENA(1,1)),
     .  (SDVI(1),SIGMA(1,1))
      DIMENSION PLPRM(NPLPRM)
      EQUIVALENCE (PLPRM(1),TEIN(1))
      DIMENSION RCMUSR(NUSR),RCMDTA(NMDTA),RCMAMF(NAMF)
      DIMENSION ICMUSR(MUSR),ICMDTA(MMDTA),ICMAMF(MAMF)
      EQUIVALENCE (RCMUSR(1),TEIN(1)),
     .            (RCMDTA(1),TABDS1(1,1)),
     .            (RCMAMF(1),CREAC(1,0,1))
      EQUIVALENCE (ICMUSR(1),NSPA),
     .            (ICMDTA(1),MODCOL(1,1,1,0)),
     .            (ICMAMF(1),NREACI)
      DIMENSION RCGM(NCGM),RCGRD(NCGRD),RCPLYG(NCPLYG),RCLGN(NLGIN)
      DIMENSION ICGM(MCGM),ICGRD(MCGRD),ICPLYG(MCPLYG),ICLGN(MLGIN)
      EQUIVALENCE (RCGM(1),VOLADD(1)),
     .            (RCGRD(1),RSURF(1)),
     .            (RCPLYG(1),VPLX(1,1)),
     .            (RCLGN(1),RLWMN(0))
      EQUIVALENCE (ICGRD(1),LEVGEO),
     .            (ICGM(1),NPOINT(1,1)),
     .            (ICPLYG(1),NRPLG),
     .            (ICLGN(1),ILSWCH(0))
      DIMENSION XSTOR(NSTOR)
      EQUIVALENCE (XSTOR(1),SIGVCX(1))
C
c slmod begin - tr (modified)
      IF (output) THEN
      WRITE(0,*) 'SETTING TABRCM = 1.0'
      WRITE(6,*) 'SETTING TABRCM = 1.0'
      ENDIF

      CALL DSET(TABRCM(1,1),NREC*NSTORDR,1.0D0)
      IF (output) WRITE(0,*) 'A'
      CALL DSET(TABREM(1,1),NREC*NSTORDR,1.0D0)
      IF (output) WRITE(0,*) 'B'
      CALL DSET(TABDSM(1,1),NRDS*NSTORDR,1.0D0)
      IF (output) WRITE(0,*) 'C'
      CALL DSET(TABDEM(1,1),NRDS*NSTORDR,1.0D0)

      IF (output) WRITE(0,*) 'DONE'
c slmod end
      IF (NRAD.LT.NLIMPS) THEN
        WRITE (6,*) 'POSSIBLE STORAGE CONFLICT. NRAD .LT. NLIMPS '
        WRITE (6,*) 'INCREASE PARAMETER NRAD. EXIT CALLED'
        CALL EXIT
      ENDIF
C
      IF (NSTORDT.LT.1 .OR. NSTORDT.GT.9) THEN
        WRITE (6,*) 'POSSIBLE STORAGE CONFLICT. NSTORDT OUT OF RANGE '
        CALL EXIT
      ENDIF
C
C   LEADING DIMENSIONS OF FIELDS IN COMMON BLOCK CESTIM AND COUTAU
C
      NFIRST(1)=NATM
      NFIRST(2)=NMOL
      NFIRST(3)=NION
      NFIRST(4)=NATM
      NFIRST(5)=NMOL
      NFIRST(6)=NION
      NFIRST(7)=0
      NFIRST(8)=NATM
      NFIRST(9)=NMOL
      NFIRST(10)=NION
      NFIRST(11)=NPLS
      NFIRST(12)=0
      NFIRST(13)=NATM
      NFIRST(14)=NMOL
      NFIRST(15)=NION
      NFIRST(16)=NPLS
      NFIRST(17)=0
      NFIRST(18)=NATM
      NFIRST(19)=NMOL
      NFIRST(20)=NION
      NFIRST(21)=NPLS
      NFIRST(22)=0
      NFIRST(23)=0
      NFIRST(24)=0
      NFIRST(25)=0
      NFIRST(26)=0
      NFIRST(27)=0
      NFIRST(28)=0
      NFIRST(29)=0
      NFIRST(30)=0
      NFIRST(31)=0
      NFIRST(32)=0
      NFIRST(33)=0
      NFIRST(34)=0
      NFIRST(35)=0
      NFIRST(36)=0
      NFIRST(NTALA)=NADV
      NFIRST(NTALC)=NCLV
      NFIRST(NTALT)=NSNV
      NFIRST(NTALM)=NCPV
      NFIRST(NTALB)=NBGV
      NFIRST(NTALR)=NALV
C  GENERATION LIMIT TALLIES
      NFIRST(NTALV-8)=NATM
      NFIRST(NTALV-7)=NMOL
      NFIRST(NTALV-6)=NION
      NFIRST(NTALV-5)=NATM
      NFIRST(NTALV-4)=NMOL
      NFIRST(NTALV-3)=NION
      NFIRST(NTALV-2)=NATM
      NFIRST(NTALV-1)=NMOL
      NFIRST(NTALV-0)=NION
C
C  NTALV=51 ?
C
      DO 1 J=1,NTALV
        NFRSTI(J)=NFIRST(J)+1
        NFIRST(J)=MAX0(1,NFIRST(J))
1     CONTINUE
C
      NADDI(1)=0
      NADDV(1)=0
      DO 2 J=2,NTALV
        NADDI(J)=NADDI(J-1)+NFRSTI(J-1)
2       NADDV(J)=NADDV(J-1)+NFIRST(J-1)
C
      NTEST=NADDV(NTALV)+NFIRST(NTALV)
      NTESTI=NADDI(NTALV)+NFRSTI(NTALV)
      NTEST=NTEST*NRAD
      NTESTI=NTESTI*NSTRAP
      IF (NTEST.NE.NESTM1) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NESTM1'
        WRITE (6,*) 'NTEST, NESTM1 ',NTEST,NESTM1
        CALL EXIT
      ENDIF
      IF (NTESTI.NE.NOUTA1) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NOUTA1'
        WRITE (6,*) 'NTESTI, NOUTA1 ',NTESTI,NOUTA1
        CALL EXIT
      ENDIF
C
C  CHECK LENGTH OF ARRAYS, WHICH ARE EQUIVALENZED TO OTHER ARRAYS
C
      SAVE=WGHT(NSPZMC,NRAD)
      WGHT(NSPZMC,NRAD)=1.234567
      IF (PLPRM(NPLPRM).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NPLPRM?'
        CALL EXIT
      ENDIF
      WGHT(NSPZMC,NRAD)=SAVE
C
      SAVE=COV(NCV,NHST)
      COV(NCV,NHST)=1.234567
      IF (SDVI(NSDVI).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NSDVI?'
        CALL EXIT
      ENDIF
      COV(NCV,NHST)=SAVE
C
      SAVE=VGENI(NION,NRAD)
      VGENI(NION,NRAD)=1.234567
      IF (ESTIM(NESTM1).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NESTM1?'
        CALL EXIT
      ENDIF
      VGENI(NION,NRAD)=SAVE
C
c slmod begin - new - no tr
c...  (Attempted) Addition of COPV2 to CESTIM:
c      SAVE=COPV2(NCPV,NRAD,NMOMCHA)
c      COPV2(NCPV,NRAD,NMOMCHA)=1.234567
c      IF (ESTIM(NESTIM).NE.1.234567) THEN
c        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NESTIM?'
c        CALL EXIT
c      ENDIF
c      COPV2(NCPV,NRAD,NMOMCHA)=SAVE
c
      SAVE=SPUMP(NSPZ,NLMPGS)
      SPUMP(NSPZ,NLMPGS)=1.234567
      IF (ESTIM(NESTIM).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NESTIM?'
        CALL EXIT
      ENDIF
      SPUMP(NSPZ,NLMPGS)=SAVE
c slmod end
C
      SAVE=VGENII(NION,NSTRA)
      VGENII(NION,NSTRA)=1.234567
      IF (OUTAU(NOUTA1).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NOUTA1?'
        CALL EXIT
      ENDIF
      VGENII(NION,NSTRA)=SAVE
C
      SAVE=SPUMPI(NSPZ,NSTRA)
      SPUMPI(NSPZ,NSTRA)=1.234567
      IF (OUTAU(NOUTA1+NOUTA2).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NOUTA2?'
        CALL EXIT
      ENDIF
      SPUMPI(NSPZ,NSTRA)=SAVE
C
      SAVE=FISCL(NSTRA)
      FISCL(NSTRA)=1.234567
      IF (OUTAU(NOUTAU).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NOUTAU?'
        CALL EXIT
      ENDIF
      FISCL(NSTRA)=SAVE
C
C  NOW ATOMIC DATA ARRAYS: COMXS
C
      SAVE=ZMFPI
      ZMFPI=1.234567
      IF (XSTOR(NSTOR).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NSTOR?'
        CALL EXIT
      ENDIF
      ZMFPI=SAVE
C
      SAVE=ADDEL(NREL,NPLS)
      ADDEL(NREL,NPLS)=1.234567
      IF (RCMDTA(NTAB).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NTAB?'
        CALL EXIT
      ENDIF
      ADDEL(NREL,NPLS)=SAVE
C
      SAVE=EPLDS(NRDS,2)
      EPLDS(NRDS,2)=1.234567
      IF (RCMDTA(NMDTA).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NMDTA?'
        CALL EXIT
      ENDIF
      EPLDS(NRDS,2)=SAVE
C
      ISAVE=LGIPI(NION,NRPI,1)
      LGIPI(NION,NRPI,1)=1234567
      IF (ICMDTA(MMDTA).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MMDTA?'
        CALL EXIT
      ENDIF
      LGIPI(NION,NRPI,1)=ISAVE
C
      SAVE=FREACP(NPLS,NREAC)
      FREACP(NPLS,NREAC)=1.234567
      IF (RCMAMF(NAMF).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NAMF?'
        CALL EXIT
      ENDIF
      FREACP(NPLS,NREAC)=SAVE
C
      ISAVE=IBGKI(NION,NREAC)
      IBGKI(NION,NREAC)=1234567
      IF (ICMAMF(MAMF).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MAMF?'
        CALL EXIT
      ENDIF
      IBGKI(NION,NREAC)=ISAVE
C
C  NOW ARRAYS FROM COMUSR:
C
      ISAVE=ISPEZI(NSPZ,4)
      ISPEZI(NSPZ,4)=1234567
      IF (ICMUSR(MUSR).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MUSR?'
        CALL EXIT
      ENDIF
      ISPEZI(NSPZ,4)=ISAVE
C
      SAVE=XPOINT(2,NPPART)
      XPOINT(2,NPPART)=1.234567
      IF (RCGM(NCGM).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NCGM?'
        CALL EXIT
      ENDIF
      XPOINT(2,NPPART)=SAVE
C
      ISAVE=NGHPOL(4,N1STS,N2NDPLG)
      NGHPOL(4,N1STS,N2NDPLG)=1234567
      IF (ICGM(MCGM).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MCGM?'
        CALL EXIT
      ENDIF
      NGHPOL(4,N1STS,N2NDPLG)=ISAVE
C
      SAVE=ZDF
      ZDF=1.234567
      IF (RCGRD(NCGRD).NE.1.234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NCGRD?'
        CALL EXIT
      ENDIF
      ZDF=SAVE
C
      ISAVE=NP2T3
      NP2T3=1234567
      IF (ICGRD(MCGRD).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MCGRD?'
        CALL EXIT
      ENDIF
      NP2T3=ISAVE
C
      ISAVE=NPPLG
      NPPLG=1234567
      IF (ICPLYG(MCPLYG).NE.1234567) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: MCPLYG?'
        CALL EXIT
      ENDIF
      NPPLG=ISAVE
C
      NFRSTW(1)=NATM
      NFRSTW(2)=NATM
      NFRSTW(3)=NATM
      NFRSTW(4)=NATM
      NFRSTW(5)=NATM
      NFRSTW(6)=NMOL
      NFRSTW(7)=NMOL
      NFRSTW(8)=NMOL
      NFRSTW(9)=NMOL
      NFRSTW(10)=NMOL
      NFRSTW(11)=NION
      NFRSTW(12)=NION
      NFRSTW(13)=NION
      NFRSTW(14)=NION
      NFRSTW(15)=NION
      NFRSTW(16)=NPLS
      NFRSTW(17)=NATM
      NFRSTW(18)=NATM
      NFRSTW(19)=NATM
      NFRSTW(20)=NATM
      NFRSTW(21)=NATM
      NFRSTW(22)=NMOL
      NFRSTW(23)=NMOL
      NFRSTW(24)=NMOL
      NFRSTW(25)=NMOL
      NFRSTW(26)=NMOL
      NFRSTW(27)=NION
      NFRSTW(28)=NION
      NFRSTW(29)=NION
      NFRSTW(30)=NION
      NFRSTW(31)=NION
      NFRSTW(32)=NPLS
      NFRSTW(33)=NATM
      NFRSTW(34)=NMOL
      NFRSTW(35)=NION
      NFRSTW(36)=NPLS
      NFRSTW(37)=0
      NFRSTW(NTLSA)=NADS
      NFRSTW(NTLSR)=NALS
      NFRSTW(40)=NSPZ
C
C  NTALS=40 ?
C
      DO 4 J=1,NTALS
        NFRTWI(J)=NFRSTW(J)+1
        NFRSTW(J)=MAX0(1,NFRSTW(J))
4     CONTINUE
C
      NDDWI(1)=0
      NADDW(1)=0
      DO 3 J=2,NTALS
        NDDWI(J)=NDDWI(J-1)+NFRTWI(J-1)
3       NADDW(J)=NADDW(J-1)+NFRSTW(J-1)
      NTEST=NADDW(NTALS)+NFRSTW(NTALS)
      NTESTI=NDDWI(NTALS)+NFRTWI(NTALS)
      NTEST=NTEST*NLMPGS
      NTESTI=NTESTI*NSTRAP
      IF (NTEST.NE.NESTM2) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NESTM2'
        WRITE (6,*) 'NTEST, NESTM2 ',NTEST,NESTM2
        CALL EXIT
      ENDIF
      IF (NTESTI.NE.NOUTA2) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NOUTA2'
        WRITE (6,*) 'NTESTI, NOUTA2 ',NTESTI,NOUTA2
        CALL EXIT
      ENDIF
C
C
      NFRSTP(1)=0
      NFRSTP(2)=NPLS
      NFRSTP(3)=0
      NFRSTP(4)=NPLS
      NFRSTP(5)=NPLS
      NFRSTP(6)=NPLS
      NFRSTP(7)=NPLS
      NFRSTP(8)=0
      NFRSTP(9)=0
      NFRSTP(10)=0
      NFRSTP(11)=NAIN
      NFRSTP(12)=NPLS
      NFRSTP(13)=0
      NFRSTP(14)=NSPZMC
C
C  NTALI=14?
C
      DO 5 J=1,NTALI
        NFRSTP(J)=MAX0(1,NFRSTP(J))
5     CONTINUE
C
      NADDP(1)=0
      DO 6 J=2,NTALI
6       NADDP(J)=NADDP(J-1)+NFRSTP(J-1)
      NTESTP=NADDP(NTALI)+NFRSTP(NTALI)
      NTESTP=NTESTP*NRAD
      IF (NTESTP.NE.NPLPRM) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NPLPRM'
        WRITE (6,*) 'NTESTP, NPLPRM ',NTESTP,NPLPRM
        CALL EXIT
      ENDIF
C
C
      IF (NID1.NE.NESTIM*NSMSTRA+NSDVI) THEN
        WRITE (6,*) 'PARAMETER ERROR DETECTED IN SETPRM: NID1'
        WRITE (6,*) 'NID1, NESTIM , NSDVI ',NID1,NESTIM,NSDVI
        CALL EXIT
      ENDIF
C
      RETURN
      END
C
      SUBROUTINE TMSTEP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C  THIS SUBROUTINE IS CALLED AFTER EACH TIME CYCLE. IT ALLOWS TO
C  MODIFY SOME PLASMA BACKGROUND AND PRIMARY SOURCE DATA (I.E., STRATA
C  ISTRA=1,NSTRAI-1) ACCORDING TO INPUT SPECIFICATIONS IN BLOCK 13.
C
C  IT THEN DEFINES THE STRATUM ISTRA=NSTRAI, I.E., THE SOURCE DUE TO
C  THE INITIAL CONDITION AT THE BEGINNING OF THE NEXT TIMESTEP.
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'COMNNL'
      INCLUDE 'COMSOU'
      INCLUDE 'COUTAU'
      INCLUDE 'CTEXT'
      INCLUDE 'CTRCEI'
      INCLUDE 'CPLOT'
      INCLUDE 'COMUSR'
      INCLUDE 'CLGIN'
      INCLUDE 'CCONA'
      INCLUDE 'CLOGAU'
      DIMENSION SGMTOT(NSTRA),FLX(NSTRA)
C
C  STEP 1
C
C  REDUCE REDUNDANT PRINTOUT
      TRCPLT=.FALSE.
      TRCGRD=.FALSE.
      PLTSRC(NSTRAI)=.FALSE.
      DO 120 ISTR=1,NSTRAI-1
        PLTSRC(NSTRAI)=PLTSRC(NSTRAI).OR.PLTSRC(ISTR)
120   CONTINUE
C
C  SPEED UP GEOMETRY
C
C  STEP 2
C
C  MODIFY BACKGROUND DATA AS COMPARED TO PREVIOUS ITERATION
C  FOR TIME DEP. MODE
C
C  STARTING TIME FOR NEXT TIMESTEP
C
      TIME0=TIME0+DTIMV
C
C  CALL USER SUPPLIED ROUTINE TIMUSR
C  E.G.: FILL COMMON BRAEIR WITH NEW PLASMA, IF NMODE.NE.0
C  BE CAREFUL: NO INDEX MAPPING IS DONE, UNLESS
C  NCUTL.NE.NCUTB
      CALL TMSUSR(TIME0)
      NLPLAS=.TRUE.
C
C  STEP 3
C
C  SET SOURCE DUE TO INITIAL CONDITION FOR NEXT TIME CYCLE
C
C  SOURCE STRENGTH OF INITIAL DISTRIBUTION IN NEW TIME CYCLE
      IPRNL=IPRNLI
      IPRNLI=0
      IF (NPTST.LE.0) THEN
        NPTS(NSTRAI)=IPRNL
      ELSEIF (NPTST.GT.0) THEN
        NPTS(NSTRAI)=NPTST
      ENDIF
      FLUX(NSTRAI)=0.
      RPARTW(0)=0.0
      DO 130 ISTR=1,NSTRAI
        SGMTOT(ISTR)=0.0
        FLX(ISTR)=0.0
130   CONTINUE
C
      IPANO=IPART(1,1)
      ISTRO=IPART(1,18)
      ADDS=0.
      DO 140  I=1,IPRNL
C
        IPAN=IPART(I,1)
        ISTR=IPART(I,18)
        NCELL=IPART(I,9)
        ITYP=IPART(I,10)
        WEIGHT=RPART(I,9)
        IF (ITYP.EQ.1) THEN
          IATM=IPART(I,11)
          RPART(I,9)=RPART(I,9)*FASCL(ISTR)
          ADD=WEIGHT*FLXFAC(ISTR)*NPRT(IATM)
          RPARTW(I)=RPARTW(I-1)+WEIGHT*FLXFAC(ISTR)
        ELSEIF (ITYP.EQ.2) THEN
          IMOL=IPART(I,12)
          RPART(I,9)=RPART(I,9)*FMSCL(ISTR)
          ADD=WEIGHT*FLXFAC(ISTR)*NPRT(NSPA+IMOL)
          RPARTW(I)=RPARTW(I-1)+WEIGHT*FLXFAC(ISTR)
        ELSEIF (ITYP.EQ.3) THEN
          IION=IPART(I,13)
          RPART(I,9)=RPART(I,9)*FISCL(ISTR)
          ADD=WEIGHT*FLXFAC(ISTR)*NPRT(NSPAM+IION)
          RPARTW(I)=RPARTW(I-1)+WEIGHT*FLXFAC(ISTR)
        ENDIF
        IF (IPAN.NE.IPANO.OR.I.EQ.IPRNL) THEN
          FLUX(NSTRAI)=FLUX(NSTRAI)+ADDS
          FLX(ISTRO)=FLX(ISTRO)+ADDS
          SGMTOT(ISTRO)=SGMTOT(ISTRO)+ADDS*ADDS
          IPANO=IPAN
          ISTRO=ISTR
          ADDS=0.
        ENDIF
        ADDS=ADDS+ADD
140   CONTINUE
C
C  VARIANCE OF CENSUS FLUX: ACCOUNT FOR SOURCE STRATIFICATION
C
      SGMTQ1=0.
      SGMREL=0.
      DO 150 ISTR=1,NSTRAI
        IF (XMCP(ISTR).GT.1.) THEN
          FCT=XMCP(ISTR)/(XMCP(ISTR)-1.)
          FLXQ=FLX(ISTR)*FLX(ISTR)
          SGMTQ1=SGMTQ1+(SGMTOT(ISTR)-FLXQ/XMCP(ISTR))*FCT
        ENDIF
150   CONTINUE
      IF (SGMTQ1.GT.0.D0) THEN
        SGMTQN=SQRT(SGMTQ1)
        SGMREL=SGMTQN/(FLUX(NSTRAI)+EPS60)*100.
      ENDIF
C
      IF (FLUX(NSTRAI).GT.0) THEN
        NSRFSI(NSTRAI)=1
        SORWGT(1,NSTRAI)=1.D0
      ENDIF
C
      DO J=1,NPARTT
        DO I=1,IPRNL
          RPARTC(I,J)=RPART(I,J)
        ENDDO
      ENDDO
      DO J=1,MPARTT
        DO I=1,IPRNL
          IPARTC(I,J)=IPART(I,J)
        ENDDO
      ENDDO
      DO I=1,IPRNL
        IPARTC(I,18)=NSTRAI
      ENDDO
C
C  CALL WRSNAP TO WRITE SNAPSHOT POPULATION
C  FOR NEXT RUN ON FT 15
C
      IF ((NFILEJ.EQ.1.OR.NFILEJ.EQ.3).AND.ITIMV.EQ.NTIME) THEN
        CALL WRSNAP
        WRITE (6,*) 'CENSUS ARRAY, FLUX AND TOTAL TIMESTEP STORED '
      ENDIF
C
      CALL LEER(2)
      WRITE (6,*) 'TIME CYCLE COMPLETED, NEXT TIME CYCLE PREPARED '
      WRITE (6,*) 'NEXT TIME CYCLE RUNS FROM TIM1 TO TIM2:  '
      CALL MASR2('TIM1, TIM2      ',TIME0,TIME0+DTIMV)
      CALL MASJ1('IPRNL   ',IPRNL)
      CALL MASR1('FLUX    ',FLUX(NSTRAI))
      CALL MASR1('+-%     ',SGMREL)
C
      RETURN
      END
C
      SUBROUTINE SETCON
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CCONA'
C   CONSTANTS
      ELCHA=1.6022D-19
      EVKEL=8.6173D-5
      PMASSA=1.0073
      PMASSE=5.448D-4
C  ATOMIC MASS UNIT (G)
      AMUA=1.6606D-24
C  NUMERICAL PRECISION PARAMETERS
      EPS60=1.D-60
      EPS30=1.D-30
      EPS12=1.D-12
      EPS6=1.D-6
      EPS5=1.D-5
C
      PIA=4.*ATAN(1.)
      PI2A=2.*PIA
      PIHA=PIA/2.
      PISQ=SQRT(PIA)
      PIAI=1./PIA
C
      SQ2=SQRT(2.)
      SQ2I=1./SQ2
      DEGRAD=PIA/180.
      RADDEG=180./PIA
C  EIRENE UNITS CONVERSIONS
      AMUAKG=AMUA*1.D-3
      CVEL2A=SQRT(1.D4*ELCHA/AMUAKG)
C  VEL(CM/S)=CVELAA*SQRT(E0(EV)/RMASS(AMU)), CVELAA=1.38912E6
      CVELAA=SQ2*CVEL2A
      CVELI2=1./CVELAA/CVELAA
      EFACT=CVELI2*PMASSA
      EFCT23=EFACT*2./3.
C
C  IONIZATION POTENTIAL OF NEUTRAL HYDROGEN ATOM
      EIONH=13.6
C  IONIZATION POTENTIAL OF NEUTRAL HYDROGEN MOLECULE
      EIONH2=15.4
C  IONIZATION POTENTIAL OF NEUTRAL HELIUM ATOM
      EIONHE=24.588
C
      RETURN
C
      END
C
      SUBROUTINE SETTXT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CTEXT'
      INCLUDE 'COMUSR'
      INCLUDE 'COUTAU'
      CHARACTER*24 TEXT24
      CHARACTER*72 TEXT72
      TXTTAL(1,1)='PARTICLE DENSITY (ATOMS)                         '
      TXTTAL(1,2)='PARTICLE DENSITY (MOLECULES)                     '
      TXTTAL(1,3)='PARTICLE DENSITY (TEST IONS)                     '
      TXTTAL(1,4)='ENERGY DENSITY (ATOMS)                           '
      TXTTAL(1,5)='ENERGY DENSITY (MOLECULES)                       '
      TXTTAL(1,6)='ENERGY DENSITY (TEST IONS)                       '
      TXTTAL(1,7)=
     . 'PARTICLE SOURCE (ELECTRONS) FROM ATOM-PLASMA INTERACTION    '
      TXTTAL(1,8)=
     . 'PARTICLE SOURCE (ATOMS) FROM ATOM-PLASMA INTERACTION        '
      TXTTAL(1,9)=
     . 'PARTICLE SOURCE (MOLECULES) FROM ATOM-PLASMA INTERACTION    '
      TXTTAL(1,10)=
     . 'PARTICLE SOURCE (TEST IONS) FROM ATOM-PLASMA INTERACTION    '
      TXTTAL(1,11)=
     . 'PARTICLE SOURCE (BULK IONS) FROM ATOM-PLASMA INTERACTION    '
      TXTTAL(1,12)=
     . 'PARTICLE SOURCE (ELECTRONS) FROM MOLECULE-PLASMA INTERACTION'
      TXTTAL(1,13)=
     . 'PARTICLE SOURCE (ATOMS) FROM MOLECULE-PLASMA INTERACTION    '
      TXTTAL(1,14)=
     . 'PARTICLE SOURCE (MOLECULES) FROM MOLECULE-PLASMA INTERACTION'
      TXTTAL(1,15)=
     . 'PARTICLE SOURCE (TEST IONS) FROM MOLECULE-PLASMA INTERACTION'
      TXTTAL(1,16)=
     . 'PARTICLE SOURCE (BULK IONS) FROM MOLECULE-PLASMA INTERACTION'
      TXTTAL(1,17)=
     . 'PARTICLE SOURCE (ELECTRONS) FROM TEST ION-PLASMA INTERACTION'
      TXTTAL(1,18)=
     . 'PARTICLE SOURCE (ATOMS) FROM TEST ION-PLASMA INTERACTION    '
      TXTTAL(1,19)=
     . 'PARTICLE SOURCE (MOLECULES) FROM TEST ION-PLASMA INTERACTION'
      TXTTAL(1,20)=
     . 'PARTICLE SOURCE (TEST IONS) FROM TEST ION-PLASMA INTERACTION'
      TXTTAL(1,21)=
     . 'PARTICLE SOURCE (BULK IONS) FROM TEST ION-PLASMA INTERACTION'
      TXTTAL(1,22)=
     . 'ENERGY SOURCE (ELECTRONS) FROM ATOM-PLASMA INTERACTION      '
      TXTTAL(1,23)=
     . 'ENERGY SOURCE (ATOMS) FROM ATOM-PLASMA INTERACTION          '
      TXTTAL(1,24)=
     . 'ENERGY SOURCE (MOLECULES) FROM ATOM-PLASMA INTERACTION      '
      TXTTAL(1,25)=
     . 'ENERGY SOURCE (TEST IONS) FROM ATOM-PLASMA INTERACTION      '
      TXTTAL(1,26)=
     . 'ENERGY SOURCE (BULK IONS) FROM ATOM-PLASMA INTERACTION      '
      TXTTAL(1,27)=
     . 'ENERGY SOURCE (ELECTRONS) FROM MOLECULE-PLASMA INTERACTION  '
      TXTTAL(1,28)=
     . 'ENERGY SOURCE (ATOMS) FROM MOLECULE-PLASMA INTERACTION      '
      TXTTAL(1,29)=
     . 'ENERGY SOURCE (MOLECULES) FROM MOLECULE-PLASMA INTERACTION  '
      TXTTAL(1,30)=
     . 'ENERGY SOURCE (TEST IONS) FROM MOLECULE-PLASMA INTERACTION  '
      TXTTAL(1,31)=
     . 'ENERGY SOURCE (BULK IONS) FROM MOLECULE-PLASMA INTERACTION  '
      TXTTAL(1,32)=
     . 'ENERGY SOURCE (ELECTRONS) FROM TEST ION-PLASMA INTERACTION  '
      TXTTAL(1,33)=
     . 'ENERGY SOURCE (ATOMS) FROM TEST ION-PLASMA INTERACTION      '
      TXTTAL(1,34)=
     . 'ENERGY SOURCE (MOLECULES) FROM TEST ION-PLASMA INTERACTION  '
      TXTTAL(1,35)=
     . 'ENERGY SOURCE (TEST IONS) FROM TEST ION-PLASMA INTERACTION  '
      TXTTAL(1,36)=
     . 'ENERGY SOURCE (BULK IONS) FROM TEST ION-PLASMA INTERACTION  '
      TXTTAL(1,NTALA)=
     . 'TO BE READ                                                  '
      TXTTAL(1,NTALC)=
     . 'TO BE READ                                                  '
      TXTTAL(1,NTALM)=
     . 'TO BE DEFINED IN SUBR. INFCOP                               '
      TXTTAL(1,NTALR)=
     . 'TO BE READ                                                  '
      TXTTAL(1,NTALB)=
     . 'TO BE DEFINED IN ROUTINE FOR BGK ITERATION                  '
      TXTTAL(1,NTALV-8)=
     . 'PARTICLE SINK (ATOMS) DUE TO GENERATION LIMIT               '
      TXTTAL(1,NTALV-7)=
     . 'PARTICLE SINK (MOLECULES) DUE TO GENERATION LIMIT           '
      TXTTAL(1,NTALV-6)=
     . 'PARTICLE SINK (TEST IONS) DUE TO GENERATION LIMIT           '
      TXTTAL(1,NTALV-5)=
     . 'ENERGY SINK (ATOMS) DUE TO GENERATION LIMIT                 '
      TXTTAL(1,NTALV-4)=
     . 'ENERGY SINK (MOLECULES) DUE TO GENERATION LIMIT             '
      TXTTAL(1,NTALV-3)=
     . 'ENERGY SINK (TEST IONS) DUE TO GENERATION LIMIT             '
      TXTTAL(1,NTALV-2)=
     . 'MOMENTUM SINK (ATOMS) DUE TO GENERATION LIMIT               '
      TXTTAL(1,NTALV-1)=
     . 'MOMENTUM SINK (MOLECULES) DUE TO GENERATION LIMIT           '
      TXTTAL(1,NTALV-0)=
     . 'MOMENTUM SINK (TEST IONS) DUE TO GENERATION LIMIT           '
C
      DO 1 J=1,NTALV
        DO 1 I=2,N1MX
          TEXT72=TXTTAL(1,J)
          TXTTAL(I,J)=TEXT72
1     CONTINUE
C
      TXTUNT(1,1)='CM**-3                  '
      TXTUNT(1,2)='CM**-3                  '
      TXTUNT(1,3)='CM**-3                  '
      TXTUNT(1,4)='EV*CM**-3               '
      TXTUNT(1,5)='EV*CM**-3               '
      TXTUNT(1,6)='EV*CM**-3               '
      TXTUNT(1,7)='AMP*CM**-3              '
      TXTUNT(1,8)='AMP*CM**-3              '
      TXTUNT(1,9)='AMP*CM**-3              '
      TXTUNT(1,10)='AMP*CM**-3              '
      TXTUNT(1,11)='AMP*CM**-3              '
      TXTUNT(1,12)='AMP*CM**-3              '
      TXTUNT(1,13)='AMP*CM**-3              '
      TXTUNT(1,14)='AMP*CM**-3              '
      TXTUNT(1,15)='AMP*CM**-3              '
      TXTUNT(1,16)='AMP*CM**-3              '
      TXTUNT(1,17)='AMP*CM**-3              '
      TXTUNT(1,18)='AMP*CM**-3              '
      TXTUNT(1,19)='AMP*CM**-3              '
      TXTUNT(1,20)='AMP*CM**-3              '
      TXTUNT(1,21)='AMP*CM**-3              '
      TXTUNT(1,22)='WATT*CM**-3             '
      TXTUNT(1,23)='WATT*CM**-3             '
      TXTUNT(1,24)='WATT*CM**-3             '
      TXTUNT(1,25)='WATT*CM**-3             '
      TXTUNT(1,26)='WATT*CM**-3             '
      TXTUNT(1,27)='WATT*CM**-3             '
      TXTUNT(1,28)='WATT*CM**-3             '
      TXTUNT(1,29)='WATT*CM**-3             '
      TXTUNT(1,30)='WATT*CM**-3             '
      TXTUNT(1,31)='WATT*CM**-3             '
      TXTUNT(1,32)='WATT*CM**-3             '
      TXTUNT(1,33)='WATT*CM**-3             '
      TXTUNT(1,34)='WATT*CM**-3             '
      TXTUNT(1,35)='WATT*CM**-3             '
      TXTUNT(1,36)='WATT*CM**-3             '
      TXTUNT(1,NTALA)='TO BE READ              '
      TXTUNT(1,NTALC)='TO BE READ              '
      TXTUNT(1,NTALM)='TO BE DEFINED IN INFCOP '
      TXTUNT(1,NTALR)='TO BE READ              '
      TXTUNT(1,NTALB)='TO BE DEFINED IN BGK    '
C  GENERATION LIMIT TALLIES
      TXTUNT(1,NTALV-8)='AMP*CM**-3              '
      TXTUNT(1,NTALV-7)='AMP*CM**-3              '
      TXTUNT(1,NTALV-6)='AMP*CM**-3              '
      TXTUNT(1,NTALV-5)='EV*CM**-3               '
      TXTUNT(1,NTALV-4)='EV*CM**-3               '
      TXTUNT(1,NTALV-3)='EV*CM**-3               '
      TXTUNT(1,NTALV-2)='CM/S*CM**-3             '
      TXTUNT(1,NTALV-1)='CM/S*CM**-3             '
      TXTUNT(1,NTALV-0)='CM/S*CM**-3             '
      DO 2 J=1,NTALV
        DO 2 I=2,N1MX
          TEXT24=TXTUNT(1,J)
          TXTUNT(I,J)=TEXT24
2     CONTINUE
C
      TXTPLS(1,1)='PLASMA TEMPERATURE                               '
      TXTPLS(1,2)='PLASMA TEMPERATURE                               '
      TXTPLS(1,3)='PLASMA DENSITY (BULK PARTICLES)                  '
      TXTPLS(1,4)='PLASMA DENSITY (BULK PARTICLES)                  '
      TXTPLS(1,5)='DRIFT VELOCITY IN X-DIRECTION (BULK IONS)        '
      TXTPLS(1,6)='DRIFT VELOCITY IN Y-DIRECTION (BULK IONS)        '
      TXTPLS(1,7)='DRIFT VELOCITY IN Z-DIRECTION (BULK IONS)        '
      TXTPLS(1,8)='MAGN. FIELD UNIT VECTOR, X DIRECTION             '
      TXTPLS(1,9)='MAGN. FIELD UNIT VECTOR, Y DIRECTION             '
      TXTPLS(1,10)='MAGN. FIELD UNIT VECTOR, Z DIRECTION             '
      TXTPLS(1,11)='TO BE READ                                       '
      TXTPLS(1,12)='BULK ION KINETIC DRIFT ENERGY                    '
      TXTPLS(1,13)='ZONE VOLUMES                                     '
      TXTPLS(1,14)='SPACE-SPECIES WEIGHT FUNCTION                    '
C
      DO 3 J=1,NTALI
        DO 3 I=2,N1MX
          TEXT72=TXTPLS(1,J)
          TXTPLS(I,J)=TEXT72
3     CONTINUE
C
      TXTPUN(1,1)='EV                      '
      TXTPUN(1,2)='EV                      '
      TXTPUN(1,3)='CM**-3                  '
      TXTPUN(1,4)='CM**-3                  '
      TXTPUN(1,5)='CM/SEC                  '
      TXTPUN(1,6)='CM/SEC                  '
      TXTPUN(1,7)='CM/SEC                  '
      TXTPUN(1,8)=' ---                    '
      TXTPUN(1,9)=' ---                    '
      TXTPUN(1,10)=' ---                    '
      TXTPUN(1,11)='TO BE READ              '
      TXTPUN(1,12)='EV                      '
      TXTPUN(1,13)='CM**3                   '
      TXTPUN(1,14)=' ---                    '
C
      DO 4 J=1,NTALI
        DO 4 I=2,N1MX
          TEXT24=TXTPUN(1,J)
          TXTPUN(I,J)=TEXT24
4     CONTINUE
      RETURN
C
      ENTRY STTXT1
C
C
      NFSTVI(1)=NATMI
      NFSTVI(2)=NMOLI
      NFSTVI(3)=NIONI
      NFSTVI(4)=NATMI
      NFSTVI(5)=NMOLI
      NFSTVI(6)=NIONI
      NFSTVI(7)=1
      NFSTVI(8)=NATMI
      NFSTVI(9)=NMOLI
      NFSTVI(10)=NIONI
      NFSTVI(11)=NPLSI
      NFSTVI(12)=1
      NFSTVI(13)=NATMI
      NFSTVI(14)=NMOLI
      NFSTVI(15)=NIONI
      NFSTVI(16)=NPLSI
      NFSTVI(17)=1
      NFSTVI(18)=NATMI
      NFSTVI(19)=NMOLI
      NFSTVI(20)=NIONI
      NFSTVI(21)=NPLSI
      NFSTVI(22)=1
      NFSTVI(23)=1
      NFSTVI(24)=1
      NFSTVI(25)=1
      NFSTVI(26)=1
      NFSTVI(27)=1
      NFSTVI(28)=1
      NFSTVI(29)=1
      NFSTVI(30)=1
      NFSTVI(31)=1
      NFSTVI(32)=1
      NFSTVI(33)=1
      NFSTVI(34)=1
      NFSTVI(35)=1
      NFSTVI(36)=1
      NFSTVI(NTALA)=NADVI
      NFSTVI(NTALC)=NCLVI
      NFSTVI(NTALT)=NSNVI
      NFSTVI(NTALM)=NCPVI
C     NFSTVI(NTALB) IS DEFINED IN SUBR. XSECT...
      NFSTVI(NTALB)=0
      NFSTVI(NTALR)=NALVI
C
C
      NFSTWI(1)=NATMI
      NFSTWI(2)=NATMI
      NFSTWI(3)=NATMI
      NFSTWI(4)=NATMI
      NFSTWI(5)=NATMI
      NFSTWI(6)=NMOLI
      NFSTWI(7)=NMOLI
      NFSTWI(8)=NMOLI
      NFSTWI(9)=NMOLI
      NFSTWI(10)=NMOLI
      NFSTWI(11)=NIONI
      NFSTWI(12)=NIONI
      NFSTWI(13)=NIONI
      NFSTWI(14)=NIONI
      NFSTWI(15)=NIONI
      NFSTWI(16)=NPLSI
      NFSTWI(17)=NATMI
      NFSTWI(18)=NATMI
      NFSTWI(19)=NATMI
      NFSTWI(20)=NATMI
      NFSTWI(21)=NATMI
      NFSTWI(22)=NMOLI
      NFSTWI(23)=NMOLI
      NFSTWI(24)=NMOLI
      NFSTWI(25)=NMOLI
      NFSTWI(26)=NMOLI
      NFSTWI(27)=NIONI
      NFSTWI(28)=NIONI
      NFSTWI(29)=NIONI
      NFSTWI(30)=NIONI
      NFSTWI(31)=NIONI
      NFSTWI(32)=NPLSI
      NFSTWI(33)=NATMI
      NFSTWI(34)=NMOLI
      NFSTWI(35)=NIONI
      NFSTWI(36)=NPLSI
      NFSTWI(37)=1
      NFSTWI(NTLSA)=NADSI
      NFSTWI(NTLSR)=NALSI
      NFSTWI(40)=1
      NFSTWI(NTALS)=NSPTOT
C
C
      NFSTPI(1)=1
      NFSTPI(2)=NPLSI
      NFSTPI(3)=1
      NFSTPI(4)=NPLSI
      NFSTPI(5)=NPLSI
      NFSTPI(6)=NPLSI
      NFSTPI(7)=NPLSI
      NFSTPI(8)=1
      NFSTPI(9)=1
      NFSTPI(10)=1
      NFSTPI(11)=NAINI
      NFSTPI(12)=NPLSI
      NFSTPI(13)=1
      NFSTPI(14)=NATMI+NMOLI+NIONI
C
C  INITIALISE SPECIES ARRAYS FOR VOLUME TALLIES

      N2=NATMI
      N3=N2+NMOLI
      N4=N3+NIONI
      N5=N4+NPLSI
      N6=N5+NADVI
      N7=N6+NALVI
      N8=N7+NCLVI
      N9=N8+NCPVI
      N10=N9+NBGVI
      N11=N10+NSNV

      NSPAN(1)=1
      NSPAN(2)=N2+1
      NSPAN(3)=N3+1
      NSPAN(4)=1
      NSPAN(5)=N2+1
      NSPAN(6)=N3+1
      NSPAN(7)=0
      NSPAN(8)=1
      NSPAN(9)=N2+1
      NSPAN(10)=N3+1
      NSPAN(11)=N4+1
      NSPAN(12)=0
      NSPAN(13)=1
      NSPAN(14)=N2+1
      NSPAN(15)=N3+1
      NSPAN(16)=N4+1
      NSPAN(17)=0
      NSPAN(18)=1
      NSPAN(19)=N2+1
      NSPAN(20)=N2+1
      NSPAN(21)=N4+1
      NSPAN(22)=0
      NSPAN(23)=0
      NSPAN(24)=0
      NSPAN(25)=0
      NSPAN(26)=0
      NSPAN(27)=0
      NSPAN(28)=0
      NSPAN(29)=0
      NSPAN(30)=0
      NSPAN(31)=0
      NSPAN(32)=0
      NSPAN(33)=0
      NSPAN(34)=0
      NSPAN(35)=0
      NSPAN(36)=0
      NSPAN(NTALA)=N5+1
      NSPAN(NTALC)=N7+1
      NSPAN(NTALT)=N10+1
      NSPAN(NTALM)=N8+1
      NSPAN(NTALB)=N9+1
      NSPAN(NTALR)=N6+1
C  GENERATION LIMIT TALLIES
      NSPAN(NTALV-8)=1
      NSPAN(NTALV-7)=N2+1
      NSPAN(NTALV-6)=N3+1
      NSPAN(NTALV-5)=1
      NSPAN(NTALV-4)=N2+1
      NSPAN(NTALV-3)=N3+1
      NSPAN(NTALV-2)=1
      NSPAN(NTALV-1)=N2+1
      NSPAN(NTALV-0)=N3+1

      NSPEN(1)=N2
      NSPEN(2)=N3
      NSPEN(3)=N4
      NSPEN(4)=N2
      NSPEN(5)=N3
      NSPEN(6)=N4
      NSPEN(7)=0
      NSPEN(8)=N2
      NSPEN(9)=N3
      NSPEN(10)=N4
      NSPEN(11)=N5
      NSPEN(12)=0
      NSPEN(13)=N2
      NSPEN(14)=N3
      NSPEN(15)=N4
      NSPEN(16)=N5
      NSPEN(17)=0
      NSPEN(18)=N2
      NSPEN(19)=N3
      NSPEN(20)=N4
      NSPEN(21)=N5
      NSPEN(22)=0
      NSPEN(23)=0
      NSPEN(24)=0
      NSPEN(25)=0
      NSPEN(26)=0
      NSPEN(27)=0
      NSPEN(28)=0
      NSPEN(29)=0
      NSPEN(30)=0
      NSPEN(31)=0
      NSPEN(32)=0
      NSPEN(33)=0
      NSPEN(34)=0
      NSPEN(35)=0
      NSPEN(36)=0
      NSPEN(NTALA)=N6
      NSPEN(NTALC)=N8
      NSPEN(NTALT)=N11
      NSPEN(NTALM)=N9
      NSPEN(NTALB)=N10
      NSPEN(NTALR)=N7
C  GENERATION LIMIT TALLIES
      NSPEN(NTALV-8)=N2
      NSPEN(NTALV-7)=N3
      NSPEN(NTALV-6)=N4
      NSPEN(NTALV-5)=N2
      NSPEN(NTALV-4)=N3
      NSPEN(NTALV-3)=N4
      NSPEN(NTALV-2)=N2
      NSPEN(NTALV-1)=N3
      NSPEN(NTALV-0)=N4

      DO 10 IATM=1,NATMI
        TXTSPC(IATM,1)=TEXTS(IATM)
        TXTSPC(IATM,4)=TEXTS(IATM)
        TXTSPC(IATM,8)=TEXTS(IATM)
        TXTSPC(IATM,13)=TEXTS(IATM)
        TXTSPC(IATM,18)=TEXTS(IATM)
        TXTSPC(IATM,NTALV-8)=TEXTS(IATM)
        TXTSPC(IATM,NTALV-5)=TEXTS(IATM)
        TXTSPC(IATM,NTALV-2)=TEXTS(IATM)
10    CONTINUE
C
      DO 20 IMOL=1,NMOLI
        ISPZ=NSPA+IMOL
        TXTSPC(IMOL,2)=TEXTS(ISPZ)
        TXTSPC(IMOL,5)=TEXTS(ISPZ)
        TXTSPC(IMOL,9)=TEXTS(ISPZ)
        TXTSPC(IMOL,14)=TEXTS(ISPZ)
        TXTSPC(IMOL,19)=TEXTS(ISPZ)
        TXTSPC(IMOL,NTALV-7)=TEXTS(ISPZ)
        TXTSPC(IMOL,NTALV-4)=TEXTS(ISPZ)
        TXTSPC(IMOL,NTALV-1)=TEXTS(ISPZ)
20    CONTINUE
C
      DO 30 IION=1,NIONI
        ISPZ=NSPAM+IION
        TXTSPC(IION,3)=TEXTS(ISPZ)
        TXTSPC(IION,6)=TEXTS(ISPZ)
        TXTSPC(IION,10)=TEXTS(ISPZ)
        TXTSPC(IION,15)=TEXTS(ISPZ)
        TXTSPC(IION,20)=TEXTS(ISPZ)
        TXTSPC(IION,NTALV-6)=TEXTS(ISPZ)
        TXTSPC(IION,NTALV-3)=TEXTS(ISPZ)
        TXTSPC(IION,NTALV-0)=TEXTS(ISPZ)
30    CONTINUE
C
      DO 40 IPLS=1,NPLSI
        ISPZ=NSPAMI+IPLS
        TXTSPC(IPLS,11)=TEXTS(ISPZ)
        TXTSPC(IPLS,16)=TEXTS(ISPZ)
        TXTSPC(IPLS,21)=TEXTS(ISPZ)
40    CONTINUE
C
      TXTSPC(1,7)='ELECTRONS               '
      TXTSPC(1,12)='ELECTRONS               '
      TXTSPC(1,17)='ELECTRONS               '
      TXTSPC(1,22)='ELECTRONS               '
      TXTSPC(1,27)='ELECTRONS               '
      TXTSPC(1,32)='ELECTRONS               '
C
      TXTSPC(1,23)='ATOMS                   '
      TXTSPC(1,28)='ATOMS                   '
      TXTSPC(1,33)='ATOMS                   '
C
      TXTSPC(1,24)='MOLECULES               '
      TXTSPC(1,29)='MOLECULES               '
      TXTSPC(1,34)='MOLECULES               '
C
      TXTSPC(1,25)='TEST IONS               '
      TXTSPC(1,30)='TEST IONS               '
      TXTSPC(1,35)='TEST IONS               '
C
      TXTSPC(1,26)='BULK IONS               '
      TXTSPC(1,31)='BULK IONS               '
      TXTSPC(1,36)='BULK IONS               '
C
      TXTPSP(1,1)='ELECTRONS               '
      TXTPSP(1,3)='ELECTRONS               '
      TXTPSP(1,8)=' ---                    '
      TXTPSP(1,9)=' ---                    '
      TXTPSP(1,10)=' ---                    '
C
      DO 50 ISPZ=1,NSPAMI
50      TXTPSP(ISPZ,14)=TEXTS(ISPZ)
C
      DO 80 IPLS=1,NPLSI
        ISPZ=NSPAMI+IPLS
        TXTPSP(IPLS,2)=TEXTS(ISPZ)
        TXTPSP(IPLS,4)=TEXTS(ISPZ)
        TXTPSP(IPLS,5)=TEXTS(ISPZ)
        TXTPSP(IPLS,6)=TEXTS(ISPZ)
        TXTPSP(IPLS,7)=TEXTS(ISPZ)
80      TXTPSP(IPLS,12)=TEXTS(ISPZ)
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   READ INPUT DATA AND SET DEFAULT VALUES
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'COMSOU'
      INCLUDE 'CSDVI'
      INCLUDE 'CSDVI_COP'
      INCLUDE 'CADGEO'
      INCLUDE 'CLGIN'
      INCLUDE 'CINIT'
      INCLUDE 'CTRCEI'
      INCLUDE 'COMUSR'
      INCLUDE 'CLOGAU'
      INCLUDE 'COMSPL'
      INCLUDE 'CCONA'
      INCLUDE 'CGRID'
      INCLUDE 'CTEXT'
      INCLUDE 'CPLOT'
      INCLUDE 'CPL3D'
      INCLUDE 'CGRPTL'
      INCLUDE 'COMSIG'
      INCLUDE 'CSPEI'
      INCLUDE 'CGEOM'
      INCLUDE 'CSTEP'
      INCLUDE 'COMNNL'
      INCLUDE 'COMXS'
      INCLUDE 'CREF'
      INCLUDE 'CZT1'
      INCLUDE 'CPOLYG'
      INCLUDE 'CTRIG'
      INCLUDE 'CCOUPL'
C
      TYPE TEMPERATURE
        DOUBLE PRECISION          :: TE, TI
        INTEGER                   :: IN, IDION
        TYPE(TEMPERATURE),POINTER :: NEXT
      END TYPE TEMPERATURE
C
      TYPE DENSITY
        DOUBLE PRECISION      :: DI
        INTEGER               :: IN, IDION
        TYPE(DENSITY),POINTER :: NEXT
      END TYPE DENSITY
C
      TYPE VELOCITY
        DOUBLE PRECISION       :: VX, VY, VZ
        INTEGER                :: IZ, IN, IDION
        TYPE(VELOCITY),POINTER :: NEXT
      END TYPE VELOCITY
C
      TYPE VOLUMEP
        DOUBLE PRECISION     :: VOL
        INTEGER              :: IN
        TYPE(VOLUMEP),POINTER :: NEXT
      END TYPE VOLUMEP
C
      TYPE(TEMPERATURE),POINTER :: TEMPLIST, TEMPCUR
      TYPE(DENSITY),POINTER :: DENLIST, DENCUR
      TYPE(VELOCITY),POINTER :: VELLIST, VELCUR
      TYPE(VOLUMEP),POINTER :: VOLLIST, VOLCUR
C
      DIMENSION AFF(3,3),AFFI(3,3),IPRSF(12)
      DIMENSION IHELP(NLIM)
      LOGICAL LHELP(NLIM)
      DIMENSION RADGEO(NADGEO),RCMSOU(NOMSOU),RCGM(NCGM),
     .          IADGEO(MADGEO),ICMSOU(MOMSOU),ICGM(MCGM)
      LOGICAL                  LCMSOU(LOMSOU)
      EQUIVALENCE (A0LM(1),RADGEO(1)),(FLUX(1),   RCMSOU(1)),
     .            (NLIMI,  IADGEO(1)),(IVLSF(1),ICMSOU(1)),
     .                                (NLPNT(1),  LCMSOU(1))
      EQUIVALENCE (VOLADD(1),RCGM(1)),
     .            (NPOINT(1,1),  ICGM(1))
      CHARACTER*10 CDATE,CTIME
      CHARACTER*72 ZEILE,FILE
      CHARACTER FILNAM*8,H123*4,REAC*9,CRC*3
      CHARACTER*60 PATH
c slmod begin - igjum3 - not tr
      LOGICAL BITGET
c slmod end
C
C  DO NOT READ ANY INPUT, IF THIS IS NOT THE VERY FIRST ITERATION
C  STEP IN THIS RUN. IITER IS THE ACTUAL ITERATION NUMBER
C  DO NOT READ ANY INPUT, IF THIS IS NOT THE VERY FIRST TIMESTEP
C  IN THIS RUN. ITIMV IS THE ACTUAL TIMESTEP NUMBER
C
C  INITIALIZE SOME DATA AND SET DEFAULTS
C
      DO 4 I=1,NSPZMC
      DO 4 J=1,NRAD
        WGHT(I,J)=1.
4     CONTINUE
C
      IREAD=1
C
C  UNIT NUMBER FOR INPUT FILE: MUST BE DIFFERENT FROM: 5,8,10,11,12
C  13,14, AND 15
      IUNIN=50
C
C  UNIT NUMBER FOR OUTPUT FILE: MUST BE DIFFERENT FROM: 5,8,10,11,12
C  13,14, AND 15 AND IUNIN
      IUNOUT=6
C
      IF (IITER.GT.1) GOTO 4000
      IF (ITIMV.GT.1) GOTO 4000
C
      DO 6 ISTEP=1,NSTEP
        ISTUF(ISTEP)=0
6     CONTINUE
C
      IREAD=0
      IERROR=0
C
      NHIST=0
      NCOV=0
      NCOVI=0
      NAINI=0
      NCPVI=0
      NBGVI=0
      MTSURF=0
C
      NLPRCS(0)=.FALSE.
      NLMACH=.FALSE.
      NLMLTI=.FALSE.
C
C  INITIALIZE GEOMETRY DATA
C
      EP1IN=0.
      EP1OT=0.
      EP1CH=0.
      EXEP1=0.
      ELLIN=1.
      ELLOT=1.
      ELLCH=1.
      EXELL=0.
      TRIIN=1.
      TRIOT=1.
      TRICH=1.
      EXTRI=0.
      PLREFL=0.
      XPCOR=0.
      YPCOR=0.
      ZPCOR=0.
      DO 8 I=1,NADGEO
        RADGEO(I)=0.
8     CONTINUE
      DO 9 I=1,MADGEO
        IADGEO(I)=0
9     CONTINUE
      DO 10 I=1,NCGM
        RCGM(I)=0.
10    CONTINUE
      DO 11 I=1,MCGM
        ICGM(I)=0
11    CONTINUE
C
C  SET DEFAULT REFLECTION MODEL
C
      DO 12 ILIMPS=0,NLIMPS
        ILIIN(ILIMPS)=1
        ILSIDE(ILIMPS)=0
        ILCOL(ILIMPS)=1
        ILTOR(ILIMPS)=0
        ILEQUI(ILIMPS)=0
        ILSWCH(ILIMPS)=0
        ISWICH(1,ILIMPS)=0
        ISWICH(2,ILIMPS)=0
        ISWICH(3,ILIMPS)=0
        ISWICH(4,ILIMPS)=0
        ISWICH(5,ILIMPS)=0
        ISWICH(6,ILIMPS)=0
        ILCELL(ILIMPS)=0
        ILACLL(ILIMPS)=0
        ILBLCK(ILIMPS)=0
        ILFIT(ILIMPS)=0
        IGFIL(ILIMPS)=0
        ILBOX(ILIMPS)=0
        ILPLG(ILIMPS)=0
        ILREF(ILIMPS)=2
        ILSPT(ILIMPS)=0
        ISRS(1,ILIMPS)=0
        ISRC(1,ILIMPS)=0
        EWALL(ILIMPS)=0.0388
        EWBIN(ILIMPS)=0.0
        FSHEAT(ILIMPS)=0.0
        TRANSP(1,ILIMPS)=0.0
        TRANSP(2,ILIMPS)=0.0
        RLWMN(ILIMPS)=1.D-5
        RLWMX(ILIMPS)=1.D5
        ZNML(ILIMPS)=5626.0
        RECYCF(1,ILIMPS)=1.
        RECYCT(1,ILIMPS)=1.
        RECPRM(1,ILIMPS)=1.
        EXPPL(1,ILIMPS)=1.
        EXPEL(1,ILIMPS)=0.5
        EXPIL(1,ILIMPS)=0.
        RECYCS(1,ILIMPS)=1.
        RECYCC(1,ILIMPS)=1.
        SPTPRM(1,ILIMPS)=0.
12    CONTINUE
      DO ILMPGS=1,NLMPGS
        SAREA(ILMPGS)=666.
        FLXOUT(ILMPGS)=0.
      ENDDO
C
C  SET DEFAULT SOURCE MODEL
C
      DO 13 J=1,NOMSOU
        RCMSOU(J)=0.
13    CONTINUE
      DO 14 J=1,MOMSOU
        ICMSOU(J)=0
14    CONTINUE
      DO 15 J=1,LOMSOU
        LCMSOU(J)=.FALSE.
15    CONTINUE
C
C  SET DEFAULTS FOR LINE OF SIGHT INTEGRATION (BLOCK 12)
C
      DO 17 J=1,NCHOR
        NSPBLC(J)=1
        NSPADD(J)=0
        NSPNEW(J)=0
17    CONTINUE
C
C  SET DEFAULT PLOT OPTIONS
C
      DO 28 J=1,100
28      NFLAGV(J)=1
      DO 29 J=1,NPTAL
        NSPTAL(J)=0
        PLTL2D(J)=.FALSE.
        PLTL3D(J)=.FALSE.
        PLTLLG(J)=.FALSE.
        PLTLER(J)=.FALSE.
        LHIST2(J)=.FALSE.
        LSMOT2(J)=.FALSE.
        LHIST3(J)=.FALSE.
        LCNTR3(J)=.FALSE.
        LRAPS3(J)=.FALSE.
        LVECT3(J)=.FALSE.
29      LSMOT3(J)=.FALSE.
C
C  SET DEFAULT A&M DATA
C
      DO 30 KK=1,NREAC
        MODCLF(KK)=0
        DO 30 J=0,9
          DO 30 I=1,9
            CREAC(I,J,KK)=0.
30    CONTINUE
C
C  SET DEFAULT 'ADDITIONAL SURFACE' DATA
C
      DO 44 I=1,NLIMPS
        IGJUM0(I)=0
        JUMLIM(I)=0
44    CONTINUE

      NBITS=BIT_SIZE(I)
      IF (NOPTM1 > NBITS) THEN
        CALL MASPRM('NOPTM1',6,NOPTM1,'NBITS',5,NBITS,IERROR)
        CALL EXIT
      END IF
      IGJUM1 = 0
      IGJUM2 = 0
      IF (NLIMPB >= NLIMPS) THEN
        DO J=1,NLIMPS
          IGJUM2(J,J) = 1
        END DO
      ELSE
c        WRITE(0,*) 'MARK: BITSET FOR IGJUM2',NLIMPB
        DO J=1,NLIMPS
          CALL BITSET (IGJUM2,0,NLIMPS,J,J,1,NBITS)
        END DO
c        WRITE(0,*) 'MARK: DONE'
      END IF
c slmod begin - igjum3 - tr (modified)
      DO 45 J=0,NOPTIM
        DO 45 I=1,NLIMPB
          IGJUM3(J,I)=0
45    CONTINUE
      DO NCELL=1,NRAD
        IGJUM4(NCELL,0)=1
        DO J=1,8
          IGJUM4(NCELL,J)=0
        ENDDO
      ENDDO
c
c      DO 45 J=0,NOPTIM
c        DO 45 I=1,NLIMPS
c          IGJUM3(J,I)=0
c45    CONTINUE
c slmod end
C
C  SET DEFAULT 'STANDARD SURFACE' DATA
C
      DO 51 ISTS=1,NSTS
        IRPTA(ISTS,1)=1
        IRPTE(ISTS,1)=MAX(2,N1ST)
        INUMP(ISTS,1)=0
C  DEFAULT POLOIDAL INDICES FOR "NON DEFAULT STANDARD SURFACES"
        IRPTA(ISTS,2)=1
        IRPTE(ISTS,2)=MAX(2,N2ND)
        INUMP(ISTS,2)=0
C  DEFAULT TOROIDAL INDICES FOR "NON DEFAULT STANDARD SURFACES"
        IRPTA(ISTS,3)=1
        IRPTE(ISTS,3)=MAX(2,N3RD)
        INUMP(ISTS,3)=0
51    CONTINUE
C
      VPLX=0.
      VPLY=0.
      VVTX=0.
      VVTY=0.
      PLNX=0.
      PLNY=0.
      PPLNX=0.
      PPLNY=0.
      BGL=0.
      BGLP=0.
C
C  SET DEFAULT DATA FOR BLOCK 13
C
      DTIMV=1.D30
      TIME0=0.
      NSNVI=0
      NTMSTP=1
C
      CALL LEER(2)
C
99    CONTINUE
C
C  READ TEXT DESCRIBING THE RUN, 100--199
C
100   CONTINUE
C
      CALL DATE_AND_TIME(CDATE,CTIME)
      READ(CDATE(1:4),*) I1
      READ(CDATE(5:6),*) I2
      READ(CDATE(7:8),*) I3
      WRITE (6,'(1X,A6,1X,2(I2,1X),I4)') 'DATE: ',I3,I2,I1
      READ(CTIME(1:2),*) I1
      READ(CTIME(3:4),*) I2
      READ(CTIME(5:6),*) I3
      WRITE (6,'(1X,A6,1X,3(I2,1X))') 'TIME: ',I1,I2,I3
      CALL LEER(2)
C
      READ (IUNIN,'(A72)') TXTRUN
      WRITE (6,'(1X,A72)') TXTRUN
      CALL LEER(1)
109   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1).EQ.'*') THEN
        WRITE (6,'(1X,A72)') ZEILE
c slmod begin - tr
c
c
c
        gchkopt = 1


c... Change this so that OPTUSR is called, or something, and zeile is read there
c    rather than have ziele checked here, since calling user specified
c    routines is more inline with EIRENE philosophy:
        IF (ZEILE(1:5).EQ.'*** 0') CALL ReadData(zeile)
c slmod end
        CALL LEER(1)
        GOTO 109
      ELSE
        READ (ZEILE,6666) NMACH,NMODE,NTCPU,NFILE,NITER0,NITER,
     .                    NTIME0,NTIME
      ENDIF
      IITER=MAX0(1,NITER0)
      ITIMV=MAX0(1,NTIME0)
      READ (IUNIN,6665) NLSCL,NLTEST,NLANA,NLDRFT,NLCRR
      NFILEN=IDEZ(NFILE,1,5)
      NFILEM=IDEZ(NFILE,2,5)
      NFILEL=IDEZ(NFILE,3,5)
      NFILEK=IDEZ(NFILE,4,5)
      NFILEJ=IDEZ(NFILE,5,5)
      CALL LEER(2)
      CALL MASAGE ('*** 1. DATA FOR OPERATING MODE                   ')
      CALL LEER(1)
      IF (NMACH.EQ.1) THEN
        CALL MASAGE ('       EIRENE RUN ON CRAY                      ')
        EPS10=1.D-10
      ELSEIF (NMACH.EQ.2) THEN
        CALL MASAGE ('       EIRENE RUN ON IBM                       ')
        EPS10=1.D-6
      ELSEIF (NMACH.EQ.3) THEN
        CALL MASAGE ('       EIRENE RUN ON FACOM                     ')
        EPS10=1.D-6
      ELSEIF (NMACH.EQ.4) THEN
        CALL MASAGE ('       EIRENE RUN ON VAX                       ')
        EPS10=1.D-6
      ENDIF
      CALL LEER(1)
      IF (NMODE.NE.0) THEN
        CALL MASAGE ('       EIRENE READS ADDITIONAL DATA FROM FILE  ')
        CALL MASAGE ('       INTERFACING ROUTINE INFCOP IS CALLED    ')
        CALL MASAGE ('       AT ENTRIES IF0COP (GEOMETRY) AND IF1COP ')
        CALL MASAGE ('       (BACKGROUND MEDIUM).                    ')
        IF (NMODE.GT.0) THEN
          CALL MASAGE ('       RETURN DATA TO EXTERNAL CODE:         ')
          CALL MASAGE ('       ENTRIES IF3COP AND IF4COP ARE         ')
          CALL MASAGE ('       CALLED AT THE END OF EACH STRATUM     ')
          CALL MASAGE ('       AND AT THE END OF THE RUN, RESP.      ')
        ELSE
          CALL MASAGE ('       NO RETURN OF DATA TO EXTERNAL CODE:   ')
          CALL MASAGE ('       ENTRIES IF3COP AND IF4COP             ')
          CALL MASAGE ('       ARE NOT CALLED                        ')
        ENDIF
        WRITE (6,*) '       NMODE= ',NMODE
      ELSE
        CALL MASAGE ('       EIRENE RUN AS STAND ALONE CODE          ')
        CALL MASAGE ('       INTERFACING ROUTINE INFCOP IS NOT CALLED')
      ENDIF
      CALL LEER(1)
      WRITE (6,*) '       EIRENE ASSUMES A TOTAL CPUTIME '
      WRITE (6,*) '       OF ',NTCPU,' SECONDS'
      CALL LEER(1)
      IF (NFILEN.EQ.1) THEN
        WRITE (6,*) '       EIRENE SAVES OUTPUT DATA '
        WRITE (6,*) '       ON FILES FT10 AND FT11 AFTER'
        WRITE (6,*) '       HAVING COMPUTED THE PARTICLE HISTORIES '
      ELSEIF (NFILEN.EQ.2) THEN
        WRITE (6,*) '       EIRENE READS OUTPUT DATA FROM '
        WRITE (6,*) '       AN EARLIER RUN FROM FILES FT10 AND FT11 '
        WRITE (6,*) '       NO NEW HISTORIES ARE COMPUTED       '
      ELSEIF (NFILEN.EQ.6) THEN
        WRITE (6,*) '       EIRENE SAVES OUTPUT DATA '
        WRITE (6,*) '       ON FILES FT10 AND FT11 AFTER'
        WRITE (6,*) '       HAVING COMPUTED THE PARTICLE HISTORIES '
        WRITE (6,*) '       FOR THE SUM OVER STRATA TALLIES ONLY '
      ELSEIF (NFILEN.EQ.7) THEN
        WRITE (6,*) '       EIRENE READS OUTPUT DATA FROM '
        WRITE (6,*) '       AN EARLIER RUN FROM FILES FT10 AND FT11 '
        WRITE (6,*) '       FOR THE SUM OVER STRATA TALLIES ONLY '
        WRITE (6,*) '       NO NEW HISTORIES ARE COMPUTED       '
      ENDIF
      CALL LEER(1)
      IF (NFILEM.EQ.1) THEN
        WRITE (6,*) '       EIRENE SAVES GEOMETRICAL DATA '
        WRITE (6,*) '       ON FILE FT12'
      ELSEIF (NFILEM.EQ.2) THEN
        WRITE (6,*) '       EIRENE READS GEOMETRICAL DATA FROM '
        WRITE (6,*) '       AN EARLIER RUN FROM FILE FT12 '
      ENDIF
      CALL LEER(1)
      IF (NFILEL.EQ.1) THEN
        WRITE (6,*) '       EIRENE SAVES PLASMA DATA, A&M DATA'
        WRITE (6,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (6,*) '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (6,*) '       LAST TIMESTEP OR ITERATION '
      ELSEIF (NFILEL.EQ.2) THEN
        WRITE (6,*) '       EIRENE READS PLASMA, A&M DATA      '
        WRITE (6,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (6,*) '       FILE FT13 '
      ELSEIF (NFILEL.EQ.3) THEN
        WRITE (6,*) '       EIRENE READS PLASMA, A&M DATA '
        WRITE (6,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (6,*) '       FILE FT13  AND '
        WRITE (6,*) '       SAVES PLASMA DATA, A&M DATA'
        WRITE (6,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (6,*) '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (6,*) '       LAST TIMESTEP OR ITERATION '
      ENDIF
      CALL LEER(1)
      IF (NFILEK.EQ.1) THEN
        WRITE (6,*) '       EIRENE SAVES DATA FOR RECOMMENDED INPUT'
        WRITE (6,*) '       MODIFICATIONS ON FILE FT14'
      ELSEIF (NFILEK.EQ.2) THEN
        WRITE (6,*) '       EIRENE READS DATA FOR RECOMMENDED INPUT'
        WRITE (6,*) '       MODIFICATIONS FROM FILE FT14, AND CARRIES'
        WRITE (6,*) '       THEM OUT IN THIS RUN'
      ELSEIF (NFILEK.EQ.3) THEN
        WRITE (6,*) '       EIRENE READS OLD DATA FOR RECOMMENDED INPUT'
        WRITE (6,*) '       MODIFICATIONS FROM FILE FT14, AND CARRIES'
        WRITE (6,*) '       THEM OUT IN THIS RUN'
        WRITE (6,*) '       EIRENE SAVES NEW DATA FOR RECOMMENDED INPUT'
        WRITE (6,*) '       MODIFICATIONS ON FILE FT14 FOR NEXT RUN'
      ENDIF
      CALL LEER(1)
      IF (NFILEJ.EQ.1) THEN
        WRITE (6,*) '       EIRENE SAVES SNAPSHOT POPULATION AT    '
        WRITE (6,*) '       END OF LAST TIMESTEP ON FILE FT15'
      ELSEIF (NFILEJ.EQ.2) THEN
        WRITE (6,*) '       EIRENE READS SNAPSHOT POPULATION FOR'
        WRITE (6,*) '       STRATUM NSTRAI+1 FOR FIRST TIMESTEP'
        WRITE (6,*) '       FROM FILE FT15'
      ELSEIF (NFILEJ.EQ.3) THEN
        WRITE (6,*) '       EIRENE READS SNAPSHOT POPULATION FOR'
        WRITE (6,*) '       STRATUM NSTRAI+1 FOR FIRST TIMESTEP '
        WRITE (6,*) '       FROM  FILE FT15 '
        WRITE (6,*) '       EIRENE SAVES NEW SNAPSHOT POPULATION'
        WRITE (6,*) '       AT END OF LAST TIMESTEP ON FILE FT15'
      ENDIF
      CALL LEER(1)
      IF (NITER.GE.1) THEN
        WRITE (6,*) '       EIRENE RUN IN ITERATIVE MODE. NUMBER OF '
        WRITE (6,*) '       ITERATIONS: ',NITER
        WRITE (6,*) '       SUBROUTINE "MODUSR" IS CALLED AFTER EACH'
        WRITE (6,*) '       ITERATION '
      ELSE
        WRITE (6,*) '       EIRENE RUN IN NONITERATIVE MODE         '
      ENDIF
      CALL LEER(1)
      IF (NTIME.GE.1) THEN
        WRITE (6,*) '       EIRENE RUN IN TIME DEP. MODE. NUMBER OF '
        WRITE (6,*) '       TIME CYCLES: ',NTIME
        WRITE (6,*) '       SUBROUTINE "TMSUSR" IS CALLED AFTER EACH'
        WRITE (6,*) '       TIME CYCLE '
      ELSE
        WRITE (6,*) '       EIRENE RUN IN STATIONARY MODE         '
      ENDIF
      CALL LEER(1)
C
C
C  READ DATA FOR STANDARD MESH, 200---299
C
200   CONTINUE
C
      READ (IUNIN,*)
      CALL MASAGE ('*** 2. DATA FOR STANDARD MESH                ')
      CALL LEER(1)
C
201   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
        WRITE (6,'(1X,A72)') ZEILE
        CALL LEER(1)
        GOTO 201
      ENDIF
      READ (ZEILE,6666) (INDGRD(J),J=1,3)
C
C INPUT SUB-BLOCK 2A
C
C  RADIAL MESH
210   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
        GOTO 210
      ENDIF
      READ (ZEILE,6665) NLRAD
      IF (NLRAD) THEN
C
        READ (IUNIN,6665) NLSLB,NLCRC,NLELL,NLTRI,NLPLG,NLFEM,NLGEN
        READ (IUNIN,6666) NR1ST,NRSEP,NRPLG,NPPLG,NRKNOT
        IF (INDGRD(1).LE.5) THEN
          IF (NLSLB.OR.NLCRC.OR.NLELL.OR.NLTRI) THEN
            READ (IUNIN,6664) RIA,RGA,RAA,RRA
            IF (RRA.GT.RAA) NR1ST=NR1ST+1
            IF (NLELL.OR.NLTRI) THEN
              READ (IUNIN,6664) EP1IN,EP1OT,EP1CH,EXEP1
              READ (IUNIN,6664) ELLIN,ELLOT,ELLCH,EXELL
              IF (NLTRI) THEN
                READ (IUNIN,6664) TRIIN,TRIOT,TRICH,EXTRI
              ENDIF
            ENDIF
          ENDIF
          IF (NLPLG) THEN
            READ(IUNIN,6664) XPCOR,YPCOR,ZPCOR,PLREFL
            READ (IUNIN,6666) (NPOINT(1,K),NPOINT(2,K),K=1,NPPLG)
            DO 212 I=1,NR1ST
              READ (IUNIN,6664) (XPOL(I,J),YPOL(I,J),    J=1,NRPLG)
212         CONTINUE
          IF (PLREFL.GT.0.D0) NR1ST=NR1ST+1
          ENDIF
          IF (NLFEM) THEN
            NTRII=NR1ST
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
            READ (IUNIN,6666) NRKNOT
            READ (IUNIN,6664) (XTRIAN(I),I=1,NRKNOT)
            READ (IUNIN,6664) (YTRIAN(I),I=1,NRKNOT)
            DO 213 ITRI=1,NTRII
              READ (IUNIN,6666) J,NECKE (1,J),NECKE (2,J),NECKE(3,J)
              READ (IUNIN,6666)   NCHBAR(1,J),NSEITE(1,J),INMTI(1,J)
              READ (IUNIN,6666)   NCHBAR(2,J),NSEITE(2,J),INMTI(2,J)
              READ (IUNIN,6666)   NCHBAR(3,J),NSEITE(3,J),INMTI(3,J)
213         CONTINUE
          ENDIF
          IF (NLGEN) THEN
            NRGEN=NR1ST
          ENDIF
        ELSEIF (INDGRD(1).EQ.6) THEN
C  IS THERE ONE MORE LINE, OR IS NLPOL THE NEXT VARIABLE
          READ (IUNIN,'(A72)') ZEILE
          IPOS1=INDEX(ZEILE,'T')
          IF (IPOS1.GT.0) THEN
            WRITE (6,*) 'ONE INPUT LINE MISSING IN BLOCK 2A '
            WRITE (6,*) 'AUTOMATIC CORRECTION PERFORMED '
            READ (ZEILE(IPOS1:IPOS1),'(L1)') NLPOL
            GOTO 222
          ENDIF
          IPOS2=INDEX(ZEILE,'F')
          IF (IPOS2.GT.0) THEN
            WRITE (6,*) 'ONE INPUT LINE MISSING IN BLOCK 2A '
            WRITE (6,*) 'AUTOMATIC CORRECTION PERFORMED '
            READ (ZEILE(IPOS2:IPOS2),'(L1)') NLPOL
            GOTO 222
          ENDIF
          IF (NLSLB.OR.NLCRC.OR.NLELL.OR.NLTRI) THEN
            READ (ZEILE,6664) RIA,RGA,RAA
          ELSEIF (NLPLG) THEN
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          ELSEIF (NLFEM) THEN
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          ENDIF
        ENDIF
      ENDIF
C
C  POLOIDAL MESH
C
C INPUT SUB-BLOCK 2B
C
220   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 220
      READ (ZEILE,6665) NLPOL
C
222   READ (IUNIN,6665) NLPLY,NLPLA,NLPLP
      READ (IUNIN,6666) NP2ND,NPSEP,NPPLA,NPPER
      IF (INDGRD(2).LE.5) THEN
        READ (IUNIN,6664) YIA,YGA,YAA,YYA
      ELSEIF (INDGRD(2).EQ.6) THEN
      ENDIF
C
C  TOROIDAL MESH
C
C INPUT SUB-BLOCK 2C
C
230   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 230
      IREAD=1
      READ (ZEILE,6665) NLTOR
      IREAD=0
C
      READ (IUNIN,6665) NLTRZ,NLTRA,NLTRT
      READ (IUNIN,6666) NT3RD,NTSEP,NTTRA,NTPER
      IF (INDGRD(3).LE.5) THEN
c slmod begin - tr
c... I don't like adding items to the input file!  Move EIRTORFRAC to block 000
        READ (IUNIN,6664) ZIA,ZGA,ZAA,ZZA,ROA,EIRTORFRAC
c
c        READ (IUNIN,6664) ZIA,ZGA,ZAA,ZZA,ROA
c slmod end
      ELSEIF (INDGRD(3).EQ.6) THEN
      ENDIF
C
C  MESH MULTIPLICATION
C
C INPUT SUB-BLOCK 2D
C
240   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 240
      IREAD=1
      READ (ZEILE,6665) NLMLT
      IREAD=0
C
      IF (NLMLT) THEN
        READ (IUNIN,6666) NBMLT
c slmod begin - tr
        IF (NBMLT.GE.MAXNTOR) THEN
          WRITE(0,*) 'ERROR: NBMLT > MAXNTOR, STOPPING'
          WRITE(0,*) 'NBMLT,MAXNTOR=',NBMLT,MAXNTOR
          WRITE(6,*) 'ERROR: NBMLT > MAXNTOR, STOPPING'
          WRITE(6,*) 'NBMLT,MAXNTOR=',NBMLT,MAXNTOR
          CALL EXIT
        ENDIF

        IF (NBMLT.GT.6) THEN
c... There is an easier way to do this, just don't know what it is at
c    the moment:
          I1 = 1
          DO WHILE (I1.LE.NBMLT)
            I2=MAX(0,MIN(6,NBMLT-I1+1))
            READ (IUNIN,6664) (VOLCOR(NM),NM=I1,I1+(I2-1))
            I1=I1+I2
          ENDDO
        ELSE
          READ (IUNIN,6664) (VOLCOR(NM),NM=1,NBMLT)
        ENDIF
c
c        READ (IUNIN,6664) (VOLCOR(NM),NM=1,NBMLT)
c slmod end
        READ (IUNIN,'(A72)') ZEILE
      ELSE
        NBMLT=1
        VOLCOR(1)=1.D0
C  FIND START OF NEXT INPUT BLOCK: 2E. SEARCH FOR *, T OR F
241     READ (IUNIN,'(A72)') ZEILE
        IPOS0=INDEX(ZEILE,'*')
        IPOS1=INDEX(ZEILE,'T')
        IPOS2=INDEX(ZEILE,'F')
        IF (IPOS0.EQ.0.AND.IPOS1.EQ.0.AND.IPOS2.EQ.0) GOTO 241
      ENDIF
      IREAD=1
C
C  ADDITIONAL CELLS OUTSIDE STANDARD MESH
C
250   IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
C
C INPUT SUB-BLOCK 2E
C
      IF (ZEILE(1:1) .EQ. '*') THEN
        IREAD=0
        GOTO 250
      ENDIF
      READ (ZEILE,6665) NLADD
      IREAD=0
C
      IF (NLADD) THEN
        READ (IUNIN,6666) NRADD
c slmod begin - tr
        IF (NRADD.GT.NADD) THEN
          WRITE(0,*) 'ERROR: NRADD > NADD, STOPPING'
          WRITE(0,*) 'NRADD,NADD=',NRADD,NADD
          WRITE(6,*) 'ERROR: NRADD > NADD, STOPPING'
          WRITE(6,*) 'NRADD,NADD=',NRADD,NADD
          STOP
        ENDIF
        IF (NRADD.GT.6) THEN
          I1 = 1
          DO WHILE (I1.LE.NRADD)
            I2=MAX(0,MIN(6,NRADD-I1+1))
            READ (IUNIN,6664) (VOLADD(NM),NM=I1,I1+(I2-1))
            I1=I1+I2
          ENDDO
        ELSE
          READ (IUNIN,6664) (VOLADD(NM),NM=1,NRADD)
        ENDIF

c        DO NM = 1, NRADD
c          WRITE(6,*) 'VOLADD: ',VOLADD(NM)
c        ENDDO

c
c        READ (IUNIN,6664) (VOLADD(NM),NM=1,NRADD)
c slmod end
      ELSE
C  FIND START OF NEXT INPUT BLOCK: 3A
252     READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:3) .NE. '***') GOTO 252
        IREAD=1
      ENDIF
C
C
C  READING FOR INPUT BLOCK 2 DONE
C
      NBMLT=MAX0(1,NBMLT)
      NR1ST=MAX0(1,NR1ST)
      NP2ND=MAX0(1,NP2ND)
      NT3RD=MAX0(1,NT3RD)
C
      IF (INDGRD(1).LE.4.AND..NOT.NLPLG) THEN
        NRPLG=0
        NPPLG=0
      ELSEIF (INDGRD(1).LE.4.AND.NLPLG) THEN
        IF (NLPOL.AND.NRPLG.NE.NP2ND) GOTO 994
      ENDIF
      IF (NLFEM.AND.INDGRD(1).LT.6) GOTO 992
      IF (NR1ST.GT.N1ST)
     .    CALL MASPRM('N1ST',4,N1ST,'NR1ST',5,NR1ST,IERROR)
      IF (NRADD.GT.NADD)
     .    CALL MASPRM('NADD',4,NADD,'NRADD',5,NRADD,IERROR)
      IF (NRPLG.GT.N2NDPLG)
     .    CALL MASPRM('N2NDPLG',9,N2NDPLG,'NRPLG',5,NRPLG,IERROR)
      IF (NPPLG.GT.NPPART)
     .    CALL MASPRM('NPPART',6,NPPART,'NPPLG',5,NPPLG,IERROR)
      IF (NP2ND.GT.N2ND)
     .    CALL MASPRM('N2ND',4,N2ND,'NP2ND',5,NP2ND,IERROR)
      IF (NT3RD.GT.N3RD)
     .    CALL MASPRM('N3RD',4,N3RD,'NT3RD',5,NT3RD,IERROR)
      IF (NTTRA.GT.NTOR.AND..NOT.NLTOR)
     .    CALL MASPRM('NTOR',4,NTOR,'NTTRA',5,NTTRA,IERROR)
      IF (NRKNOT.GT.NKNOTS)
     .    CALL MASPRM('NKNOT',5,NKNOT,'NRKNOT',6,NRKNOT,IERROR)
      IF (NTRII.GT.NTRIS)
     .    CALL MASPRM('NRTI',4,NTRI,'NTRII',5,NTRII,IERROR)
C
C  READ DATA FOR NON DEFAULT SURFACE MODELS ON STANDARD SURFACES
C  300--349
C
300   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL MASAGE('*** 3A. DATA FOR NON DEFAULT STANDARD SURFACES')
310   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 310
      IREAD=1
      READ(ZEILE,6666) NSTSI
      IREAD=0
      WRITE (6,*) '        NSTSI= ',NSTSI
      CALL LEER(1)
      IF (NSTSI.GT.NSTS)
     .    CALL MASPRM('NSTS',4,NSTS,'NSTSI',5,NSTSI,IERROR)
      DO 311 ISTS=1,NSTSI
        NLJ=NLIM+ISTS
        IF (IREAD.EQ.0) THEN
          READ (IUNIN,'(A72)') TXTSFL(NLJ)
        ELSE
          READ (ZEILE,'(A72)') TXTSFL(NLJ)
          IREAD=0
        ENDIF
        READ (IUNIN,6666) JDUMMY,IDIMP,INUMP(ISTS,IDIMP),IRPTA1,
     .                    IRPTE1,IRPTA2,IRPTE2,IRPTA3,IRPTE3
C
C  OLD INPUT VERSION BEGIN
        IF (IDIMP.EQ.1.AND.IRPTA1.NE.IRPTE1) THEN
          WRITE (6,*) 'WARNING FROM INPUT BLOCK 3A, ISTS= ',ISTS
          WRITE (6,*) 'NEW INPUT FOR IRPTA,IRPTE....'
          WRITE (6,*) 'AUTOMATIC CORRECTION CARRIED OUT '
          IRPTA2=IRPTA1
          IRPTE2=IRPTE1
          IRPTA1=INUMP(ISTS,1)
          IRPTE1=INUMP(ISTS,1)
        ENDIF
C  OLD INPUT VERSION DONE
C
C  OVERWRITE DEFAULTS FOR IRPTA, IRPTE ARRAYS
        IF (IDIMP.NE.1) THEN
          IF (IRPTA1.GT.1) IRPTA(ISTS,1)=IRPTA1
          IF (IRPTE1.LE.1.OR.IRPTE1.GT.NR1ST) THEN
            IRPTE(ISTS,1)=MAX(2,NR1ST)
          ELSE
            IRPTE(ISTS,1)=IRPTE1
          ENDIF
          IF ((IDIMP.EQ.2.AND.IRPTE2.GT.NP2ND).OR.
     .        (IDIMP.EQ.3.AND.IRPTE3.GT.NT3RD)) THEN
            WRITE (6,*) 'WARNING:'
            WRITE (6,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (6,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        IF (IDIMP.NE.2) THEN
          IF (IRPTA2.GT.1) IRPTA(ISTS,2)=IRPTA2
          IF (IRPTE2.LE.1.OR.IRPTE2.GT.NP2ND) THEN
            IRPTE(ISTS,2)=MAX(2,NP2ND)
          ELSE
            IRPTE(ISTS,2)=IRPTE2
          ENDIF
          IF ((IDIMP.EQ.1.AND.IRPTE1.GT.NR1ST).OR.
     .        (IDIMP.EQ.3.AND.IRPTE3.GT.NT3RD)) THEN
            WRITE (6,*) 'WARNING:'
            WRITE (6,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (6,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        IF (IDIMP.NE.3) THEN
          IF (IRPTA3.GT.1) IRPTA(ISTS,3)=IRPTA3
          IF (IRPTE3.LE.1.OR.IRPTE3.GT.NT3RD) THEN
            IRPTE(ISTS,3)=MAX(2,NT3RD)
          ELSE
            IRPTE(ISTS,3)=IRPTE3
          ENDIF
          IF ((IDIMP.EQ.1.AND.IRPTE1.GT.NR1ST).OR.
     .        (IDIMP.EQ.2.AND.IRPTE2.GT.NP2ND)) THEN
            WRITE (6,*) 'WARNING:'
            WRITE (6,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (6,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        READ (IUNIN,6666) ILIIN(NLJ),ILSIDE(NLJ),ILSWCH(NLJ),
     .                    ILEQUI(NLJ),ILTOR(NLJ),ILCOL(NLJ),
     .                    ILFIT(NLJ),ILCELL(NLJ),ILBOX(NLJ),
     .                    ILPLG(NLJ)
        IF (ABS(ILCOL(NLJ)).EQ.7) THEN
          WRITE (6,*) 'COLOUR FLAG ILCOL CHANGED FOR SURFACE NO. ',NLJ
          WRITE (6,*) 'COLOUR NO. 7 IS RESERVED FOR "NON-ANALOG'
          WRITE (6,*) 'SURFACES" (SPLITTING, R.R., WEIGHT WINDOWS,..)'
          ILCOL(NLJ)=ILCOL(NLJ)-2
        ENDIF
312     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1).EQ.'*') THEN
C  SKIP READING LOCAL SURFACE INTERACTION MODEL, USE: DEFAULT
          GOTO 314
        ELSEIF (ILIIN(NLJ).LE.0) THEN
          GOTO 312
        ELSE
          READ (ZEILE,6666) ILREF(NLJ),ILSPT(NLJ),ISRS(1,NLJ),
     .                      ISRC(1,NLJ)
          IREAD=0
          READ (IUNIN,6664) ZNML(NLJ),EWALL(NLJ),EWBIN(NLJ),
     .                      TRANSP(1,NLJ),TRANSP(2,NLJ),FSHEAT(NLJ)
          READ (IUNIN,6664) RECYCF(1,NLJ),RECYCT(1,NLJ),RECPRM(1,NLJ),
     .                      EXPPL(1,NLJ),EXPEL(1,NLJ),EXPIL(1,NLJ)
          READ (IUNIN,'(A72)') ZEILE
          IREAD=1
C  READ ONE MORE LINE FOR NON-DEFAULT SPUTTER MODEL
          IF (ZEILE(1:1).NE.'*') THEN
            READ (ZEILE,6664) RECYCS(1,NLJ),RECYCC(1,NLJ),SPTPRM(1,NLJ)
            IREAD=0
          ENDIF
        ENDIF
C
314     CONTINUE
C
311   CONTINUE
C
C     READ DATA FOR ADDITIONAL SURFACES 350--399
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL MASAGE ('*** 3B. DATA FOR ADDITIONAL SURFACES           ')
350   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1).EQ.'*') THEN
        WRITE (6,'(1X,A72)') ZEILE
        GOTO 350
      ENDIF
      IREAD=0
c slmod begin - tr
c...CUSTOM INPUT FILE.  IT ISN'T GREAT TO BE MODIFYING THE
c   ESTABLISHED STRUCTURE OF THE EIRENE INPUT FILE, BUT
c   I CAN'T PUT THIS EARLIER IN THE INPUT FILE SINCE DIVIMP
c   DOESN'T KNOW THE VALUE THEN.  PERHAPS I CAN PLACE IT
c   ELSEWHERE HOWEVER, IN ANOTHER TRANSFER FILE.
      READ (ZEILE,6666) NLIMI,SBGKI,CBGKI,EBGKI,HADDI,HSTDI
c
c      READ (ZEILE,6666) NLIMI
c slmod end
      WRITE (6,*) '        NLIMI= ',NLIMI
      CALL LEER(1)
C
      IF (NLIMI.GT.NLIM) THEN
        CALL MASPRM('NLIM',4,NLIM,'NLIMI',5,NLIMI,IERROR)
        WRITE (6,*) 'THIS WAS TOO MUCH: EXIT CALLED '
        CALL EXIT
      ENDIF
C
      IF (NLIMI.GT.0) THEN
        DO 353 I=1,NLIMI
          IHELP(I)=IGJUM0(I)
353     CONTINUE
351     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:3).EQ.'CH0') THEN
          IREAD=0
          CALL DEKEY (ZEILE(4:72),IHELP,1,1,1,NLIMPS)
          GOTO 351
        ENDIF
        DO 352 I=1,NLIMI
          IGJUM0(I)=IHELP(I)
352     CONTINUE
      ENDIF
C
      DO 360 I=1,NLIMI
        IF (IREAD.NE.0) THEN
          READ (ZEILE,'(A72)') TXTSFL(I)
        ELSE
          READ (IUNIN,'(A72)') TXTSFL(I)
        ENDIF
        IREAD=0
        IF (IGJUM0(I).NE.0) THEN
361       READ (IUNIN,'(A72)') ZEILE
          IREAD=1
          IF (ZEILE(1:1).EQ.'*') GOTO 369
          GOTO 361
        ENDIF
C
C   GENERAL SURFACE DATA
362     READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:3).EQ.'CH1') THEN
          IF (NLIMPB >= NLIMPS) THEN
            CALL DEKEY (ZEILE(4:72),IGJUM1,0,NLIMPS,I,NLIMPS)
          ELSE
            CALL DEKEYB (ZEILE(4:72),IGJUM1,0,NLIMPS,I,NLIMPB,NBITS)
          END IF
          GOTO 362
        ELSEIF (ZEILE(1:3).EQ.'CH2') THEN
          IF (NLIMPB >= NLIMPS) THEN
            CALL DEKEY (ZEILE(4:72),IGJUM2,0,NLIMPS,I,NLIMPS)
          ELSE
            CALL DEKEYB (ZEILE(4:72),IGJUM2,0,NLIMPS,I,NLIMPB,NBITS)
          END IF
          GOTO 362
        ELSE
          READ (ZEILE,6664) RLB(I),SAREA(I),RLWMN(I),RLWMX(I)
          IF (SAREA(I).LE.0.D0) SAREA(I)=666.
          READ (IUNIN,6666) ILIIN(I),ILSIDE(I),ILSWCH(I),
     .                      ILEQUI(I),ILTOR(I),ILCOL(I),
     .                      ILFIT(I),ILCELL(I),ILBOX(I),
     .                      ILPLG(I)
          IF (ABS(ILCOL(I)).EQ.7) THEN
            WRITE (6,*) 'COLOUR FLAG ILCOL CHANGED FOR SURFACE NO. ',I
            WRITE (6,*) 'COLOUR NO. 7 IS RESERVED FOR "NON-ANALOG'
            WRITE (6,*) 'SURFACES" (SPLITTING, R.R., WEIGHT WINDOWS,..)'
            ILCOL(I)=ILCOL(I)-2
          ENDIF
C  READ SURFACE COEFFICIENTS
          IF (RLB(I).LT.2.) THEN
            READ (IUNIN,6664) A0LM(I),A1LM(I),A2LM(I),A3LM(I),A4LM(I),
     .                        A5LM(I)
            READ (IUNIN,6664) A6LM(I),A7LM(I),A8LM(I),A9LM(I)
          ELSEIF (RLB(I).LT.3.) THEN
c slmod begin - tr
            IF (NEUTOPT.EQ.1) THEN
              READ (IUNIN,'(6E14.7)')
     .          P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),P2(3,I)
            ELSE
              READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
     .                          P2(3,I)
            ENDIF

            IF (debugopt.NE.0)
     .        WRITE(6,'(A,I3,6E14.7)') 'Neut wall: ',
     .          I,P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),P2(3,I)
          ELSEIF (RLB(I).LT.5.) THEN
c           IF (NEUTOPT.EQ.1) THEN
              READ (IUNIN,'(6E14.7)')
     .          P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),P2(3,I)
              READ (IUNIN,'(6E14.7)')
     .          P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),P4(3,I)
c           ELSE
c             READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
c    .                          P2(3,I)
c             READ (IUNIN,6664) P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),
c    .                          P4(3,I)
c           ENDIF

c
c            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
c     .                        P2(3,I)
c          ELSEIF (RLB(I).LT.5.) THEN
c            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
c     .                        P2(3,I)
c            READ (IUNIN,6664) P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),
c     .                        P4(3,I)
c slmod end
          ELSEIF (RLB(I).LT.7.) THEN

            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
     .                        P2(3,I)
            READ (IUNIN,6664) P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),
     .                        P4(3,I)
            READ (IUNIN,6664) P5(1,I),P5(2,I),P5(3,I),P6(1,I),P6(2,I),
     .                        P6(3,I)
          ENDIF
        ENDIF
C  READ BOUNDARY DATA
        IF (RLB(I).GT.0..AND.RLB(I).LT.2.) THEN
          READ (IUNIN,6664) XLIMS1(I,1),YLIMS1(I,1),ZLIMS1(I,1),
     .                      XLIMS2(I,1),YLIMS2(I,1),ZLIMS2(I,1)
        ELSEIF (RLB(I).LE.0.D0) THEN
          IH=-RLB(I)
          ILIN(I)=IDEZ(IH,1,2)
          ISCN(I)=IDEZ(IH,2,2)
          DO 363 J=1,ILIN(I)
            READ (IUNIN,6664) ALIMS(I,J),XLIMS(I,J),YLIMS(I,J),
     .                        ZLIMS(I,J)
363       CONTINUE
          DO 364 J=1,ISCN(I)
            READ (IUNIN,6664) ALIMS0(I,J),XLIMS1(I,J),YLIMS1(I,J),
     .                        ZLIMS1(I,J),XLIMS2(I,J),YLIMS2(I,J)
            READ (IUNIN,6664) ZLIMS2(I,J),XLIMS3(I,J),YLIMS3(I,J),
     .                        ZLIMS3(I,J)
364       CONTINUE
        ENDIF
C
C READ LOCAL SURFACE INTERACTION MODEL FOR SURFACE NO. I
C
367     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1).EQ.'*') THEN
C  SKIP READING LOCAL SURFACE INTERACTION MODEL, USE: DEFAULT
          GOTO 369
        ELSEIF (ZEILE(1:9).EQ.'TRANSFORM') THEN
C  TRANSFORM BLOCK
          GOTO 368
        ELSEIF (ILIIN(I).LE.0) THEN
C  TRANSPARENT: SKIP READING SURFACE INTERACTION MODEL
          GOTO 367
        ELSE
C  READ LOCAL REFLECTION MODEL
          READ (ZEILE,6666) ILREF(I),ILSPT(I),ISRS(1,I),ISRC(1,I)
          IREAD=0
          READ (IUNIN,6664) ZNML(I),EWALL(I),EWBIN(I),
     .                      TRANSP(1,I),TRANSP(2,I),FSHEAT(I)
          READ (IUNIN,6664) RECYCF(1,I),RECYCT(1,I),RECPRM(1,I),
     .                      EXPPL(1,I),EXPEL(1,I),EXPIL(1,I)
          READ (IUNIN,'(A72)') ZEILE
          IREAD=1
C  READ ONE MORE LINE FOR NON-DEFAULT SPUTTER MODEL
          IF (ZEILE(1:1).NE.'*'.AND.ZEILE(1:9).NE.'TRANSFORM') THEN
            READ (ZEILE,6664) RECYCS(1,I),RECYCC(1,I),SPTPRM(1,I)
            IREAD=0
          ENDIF
        ENDIF
C
368     IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:9).NE.'TRANSFORM') GOTO 369
C
C  TRANSFORM FROM CONVENIENT CO-ORDINATE SYSTEM TO EIRENE CO-ORDINATE
C  SYSTEM. THIS IS POSSIBLE FOR ALL SURFACES READ BY NOW, I.E. FROM
C  ITINI=1 TO ITEND=I
        IREAD=0
        READ (IUNIN,6666) ITINI,ITEND
        IF (ITINI.LT.1) ITINI=I
        IF (ITEND.GT.I) ITEND=I
        READ (IUNIN,6664) XLCOR,YLCOR,ZLCOR
        READ (IUNIN,6664) XLREF,YLREF,ZLREF
        READ (IUNIN,6664) XLROT,YLROT,ZLROT,ALROT
C  SHIFT
        XSH=XLCOR
        IF (XSH.NE.0.D0) CALL XSHADD(XSH,ITINI,ITEND)
        YSH=YLCOR
        IF (YSH.NE.0.D0) CALL YSHADD(YSH,ITINI,ITEND)
        ZSH=ZLCOR
        IF (ZSH.NE.0.D0) CALL ZSHADD(ZSH,ITINI,ITEND)
C  REFLECTION
        REFNRM=XLREF*XLREF+YLREF*YLREF+ZLREF*ZLREF
        IF (REFNRM.GT.EPS10) THEN
          CALL SETREF(AFF,AFFI,1,XLREF,YLREF,ZLREF)
          CALL ROTADD(AFF,AFFI,ITINI,ITEND)
        ENDIF
C  ROTATION
        ROTNRM=XLROT*XLROT+YLROT*YLROT+ZLROT*ZLROT
        ALR=ALROT
        IF (ALR.NE.0..AND.ROTNRM.GT.EPS10) THEN
          CALL SETROT(AFF,AFFI,1,XLROT,YLROT,ZLROT,ALROT)
          CALL ROTADD(AFF,AFFI,ITINI,ITEND)
        ENDIF
        GOTO 368
C
369     CONTINUE
C
360   CONTINUE
C
C  READ DATA FOR SPECIES SPECIFICATION AND ATOMIC PHYSICS MODULE
C  400--499
C
400   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL MASAGE ('*** 4. DATA FOR SPECIES SPECIFICATION AND   ')
      CALL MASAGE ('       ATOMIC PHYSICS MODULE                ')
      CALL LEER(1)
C
      READ (IUNIN,*)
      WRITE (6,*) '       ATOMIC REACTION CARDS, NREACI DATA FIELDS'
      READ (IUNIN,*) NREACI
      WRITE (6,*) '       NREACI= ',NREACI
      CALL LEER(1)
      IF (NREACI.GT.NREAC)
     .    CALL MASPRM('NREAC',5,NREAC,'NREACI',6,NREACI,IERROR)
C
411   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1).EQ.'*') GOTO 420
      READ (ZEILE,66661)
     .      IR,FILNAM,H123,REAC,CRC,MP,MT,DP,RMN,RMX
      IF (IR.GT.NREACI) THEN
          CALL MASPRM('NREACI',5,NREACI,'IR',2,IR,IERROR)
      ENDIF
      MASSP(IR)=MP
      MASST(IR)=MT
      DELPOT(IR)=DP
C  ASYMPTOTICS FOR CROSS SECTIONS (SECOND INDEX=1) OR RATES (SECOND
C  INDEX=2) , OVERWRITES ASYMPTOTICS IN DATA FILES, IF THERE ARE SUCH
      IF (INDEX(H123,'H.1 ').NE.0) J=1
      IF (INDEX(H123,'H.1 ').EQ.0) J=2
      RCMN(IR,J)=-20.
      RCMX(IR,J)= 20.
      IFEXMN(IR,J)=0
      IFEXMX(IR,J)=0
      IF (RMN.GT.0.D0) THEN
        READ (IUNIN,66664) IFEXMN(IR,J),(FPARM(IR,I,J),I=1,3)
        RCMN(IR,J)=LOG(RMN)
      ENDIF
      IF (RMX.GT.0.D0) THEN
        READ (IUNIN,66664) IFEXMX(IR,J),(FPARM(IR,I,J),I=4,6)
        RCMX(IR,J)=LOG(RMX)
      ENDIF
C
      CALL SLREAC (IR,FILNAM,H123,REAC,CRC)
      GOTO 411
C
420   WRITE (6,*) '*4A.   NEUTRAL ATOMS SPECIES CARDS, NATMI SPECIES'
      READ (IUNIN,*) NATMI
      WRITE (6,*) '       NATMI= ',NATMI
      CALL LEER(1)
      IF (NATMI.GT.NATM)
     .    CALL MASPRM('NATM',4,NATM,'NATMI',5,NATMI,IERROR)
C
      DO 421 IATM=1,NATMI
        ISPZ=IATM
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSA(IATM),NCHARA(IATM),
     .                       NPRT(ISPZ),NDUMM,
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),IDUMM,
     .                       NRCA(IATM),NFOLA(IATM),NGENA(IATM)
        DO 422 K=1,NRCA(IATM)
          READ (IUNIN,6666) IREACA(IATM,K),IBULKA(IATM,K),
     .                      ISCD1A(IATM,K),ISCD2A(IATM,K),
     .                      ISCDEA(IATM,K),IESTMA(IATM,K),IBGKA(IATM,K)
          READ (IUNIN,6664) EELECA(IATM,K),EBULKA(IATM,K),
     .                      ESCD1A(IATM,K),ESCD2A(IATM,K),FREACA(IATM,K)
422     CONTINUE
421   CONTINUE
C
C  READ NEUTRAL MOLECULES SPECIES CARDS
C
      READ (IUNIN,*)
      WRITE (6,*) '*4B.   NEUTRAL MOLECULE SPECIES CARDS, NMOLI SPECIES'
430   READ (IUNIN,*) NMOLI
      WRITE (6,*) '       NMOLI= ',NMOLI
      CALL LEER(1)
      IF (NMOLI.GT.NMOL)
     .    CALL MASPRM('NMOL',4,NMOL,'NMOLI',5,NMOLI,IERROR)
      NSPA=NATMI
      DO 431 IMOL=1,NMOLI
        ISPZ=NSPA+IMOL
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSM(IMOL),NCHARM(IMOL),
     .                       NPRT(ISPZ),NDUMM,
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),IDUMM,
     .                       NRCM(IMOL),NFOLM(IMOL),NGENM(IMOL)
        DO 432 K=1,NRCM(IMOL)
          READ (IUNIN,6666) IREACM(IMOL,K),IBULKM(IMOL,K),
     .                      ISCD1M(IMOL,K),ISCD2M(IMOL,K),
     .                      ISCDEM(IMOL,K),IESTMM(IMOL,K),IBGKM(IMOL,K)
          READ (IUNIN,6664) EELECM(IMOL,K),EBULKM(IMOL,K),
     .                      ESCD1M(IMOL,K),ESCD2M(IMOL,K),FREACM(IMOL,K)
432     CONTINUE
431   CONTINUE
C
C  READ TEST PARTICLE IONS SPECIES CARDS
C
      READ (IUNIN,*)
      WRITE (6,*) '*4C.   TEST IONS SPECIES CARDS, NIONI SPECIES '
440   READ (IUNIN,*) NIONI
      WRITE (6,*) '       NIONI= ',NIONI
      CALL LEER(1)
      IF (NIONI.GT.NION)
     .    CALL MASPRM('NION',4,NION,'NIONI',5,NIONI,IERROR)
      NSPAM=NATMI+NMOLI
      DO 441 IION=1,NIONI
        ISPZ=NSPAM+IION
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSI(IION),NCHARI(IION),
     .                       NPRT(ISPZ),NCHRGI(IION),
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),IDUMM,
     .                       NRCI(IION),NFOLI(IION),NGENI(IION)
        DO 442 K=1,NRCI(IION)
          READ (IUNIN,6666) IREACI(IION,K),IBULKI(IION,K),
     .                      ISCD1I(IION,K),ISCD2I(IION,K),
     .                      ISCDEI(IION,K),IESTMI(IION,K),IBGKI(IION,K)
          READ (IUNIN,6664) EELECI(IION,K),EBULKI(IION,K),
     .                      ESCD1I(IION,K),ESCD2I(IION,K),FREACI(IION,K)
442     CONTINUE
441   CONTINUE
C
C  READ DATA FOR PLASMA-BACKGROUND , 500--599
C
500   CONTINUE
C
      READ (IUNIN,'(A72)') ZEILE
C     WRITE (6,*) ZEILE
      CALL MASAGE ('*** 5. DATA FOR PLASMA BACKGROUND            ')
      CALL LEER(1)
C
C  READ BULK IONS SPECIES CARDS
C
      READ (IUNIN,'(A72)') ZEILE
C     WRITE (6,*) ZEILE
      WRITE (6,*) '*5A.   BULK ION SPECIES CARDS, NPLSI SPECIES '
510   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 510
      READ(ZEILE,6666) NPLSI
      WRITE (6,*) '       NPLSI= ',NPLSI
      CALL LEER(1)
      IF (NPLSI.GT.NPLS)
     .    CALL MASPRM('NPLS',4,NPLS,'NPLSI',5,NPLSI,IERROR)
      NSPAMI=NSPAM+NIONI
      NSPTOT=NSPAMI+NPLSI
      DO 511 IPLS=1,NPLSI
        ISPZ=NSPAMI+IPLS
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSP(IPLS),NCHARP(IPLS),
     .                       NPRT(ISPZ),NCHRGP(IPLS),
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),IDUMM,
     .                       NRCP(IPLS)
        DO 512 K=1,NRCP(IPLS)
          READ (IUNIN,6666) IREACP(IPLS,K),IBULKP(IPLS,K),
     .                      ISCD1P(IPLS,K),ISCD2P(IPLS,K),
     .                      ISCDEP(IPLS,K)
          READ (IUNIN,6664) EELECP(IPLS,K),EBULKP(IPLS,K),
     .                      ESCD1P(IPLS,K),ESCD2P(IPLS,K),FREACP(IPLS,K)
512     CONTINUE
511   CONTINUE
C
520   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
C       WRITE (6,*) ZEILE
        GOTO 520
      ENDIF
      CALL MASAGE ('*5B.   PLASMA BACKGROUND DATA                ')
      READ (ZEILE,6666) (INDPRO(J),J=1,12)
      IF (INDPRO(1).LE.5.AND.NPLSI.GT.0)
     .  READ (IUNIN,6664) TE0,TE1,TE2,TE3,TE4,TE5
      NLMLTI=INDPRO(2).LT.0
      INDPRO(2)=IABS(INDPRO(2))
      IF (INDPRO(2).LE.5.AND.NPLSI.GT.0) THEN
        IF (NLMLTI) THEN
          READ (IUNIN,6664) (TI0(I),TI1(I),TI2(I),TI3(I),TI4(I),TI5(I),
     .                       I=1,NPLSI)
        ELSE
          READ (IUNIN,6664)  TI0(1),TI1(1),TI2(1),TI3(1),TI4(1),TI5(1)
          DO 530 IPLS=2,NPLSI
            TI0(IPLS)=TI0(1)
            TI1(IPLS)=TI1(1)
            TI2(IPLS)=TI2(1)
            TI3(IPLS)=TI3(1)
            TI4(IPLS)=TI4(1)
            TI5(IPLS)=TI5(1)
530       CONTINUE
        ENDIF
      ENDIF
      IF (INDPRO(3).LE.5)
     .  READ (IUNIN,6664) (DI0(I),DI1(I),DI2(I),DI3(I),DI4(I),DI5(I),
     .                     I=1,NPLSI)
      NLMACH=INDPRO(4).LT.0
      INDPRO(4)=IABS(INDPRO(4))
      IF (INDPRO(4).LE.5) THEN
        READ (IUNIN,6664) (VX0(I),VX1(I),VX2(I),VX3(I),VX4(I),VX5(I),
     .                     I=1,NPLSI)
        READ (IUNIN,6664) (VY0(I),VY1(I),VY2(I),VY3(I),VY4(I),VY5(I),
     .                     I=1,NPLSI)
        READ (IUNIN,6664) (VZ0(I),VZ1(I),VZ2(I),VZ3(I),VZ4(I),VZ5(I),
     .                     I=1,NPLSI)
      ENDIF
      IF (INDPRO(5).EQ.5) THEN
        READ (IUNIN,6664) BX0,BX1,BX2,BX3,BX4,BX5
        READ (IUNIN,6664) BY0,BY1,BY2,BY3,BY4,BY5
        READ (IUNIN,6664) BZ0,BZ1,BZ2,BZ3,BZ4,BZ5
      ENDIF
C  READ  DATA FOR REFLECTION MODEL  600--699
C
600   CONTINUE
C
      READ (IUNIN,*)
      CALL MASAGE ('*** 6. GENERAL DATA FOR REFLECTION MODEL    ')
      CALL LEER(1)
C
610   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 610
      READ (ZEILE,6665) NLTRIM
      IF (NLTRIM) THEN
        READ (IUNIN,'(A72)') ZEILE
        IF (INDEX(ZEILE,'PATH')+INDEX(ZEILE,'path').EQ.0) THEN
C  NO PATH SPECIFIED FOR REFLECTION DATA BASE
          WRITE (6,*) ' NO PATH SPECIFIED FOR REFLECTION DATA BASE '
          WRITE (6,*) ' OLD VERSION USED '
          LTRMOL=.TRUE.
C  SKIP LINES CONTAINING SPECIFICATIONS FOR DATA BASES AND
C  CONTINUE READING
615       IF (INDEX(ZEILE,'ON')+INDEX(ZEILE,'on').EQ.0) THEN
            READ (ZEILE,6664) (DATD(IATM),IATM=1,NATMI)
            GOTO 620
          ELSE
            READ (IUNIN,'(A72)') ZEILE
            GOTO 615
          ENDIF
        ELSE
C  PATH SPECIFICATION FOR DATA BASE FOUND
          LTRMOL=.FALSE.
          READ (ZEILE(7:),'(A60)') PATH
          WRITE (6,*) ' PATH = ',PATH
          I1=0
621       IF (I1.GT.LEN(PATH)) THEN
            I1=1
            GOTO 622
          ENDIF
          I1=I1+1
          IF (PATH(I1:I1).EQ.' ') GOTO 621
622       I2=INDEX(PATH(I1:),' ')
          FILE(1:)=PATH(I1:I1+I2-1)
          WRITE (6,*) ' FILE = ',FILE
          NFLR=0
          READ (IUNIN,'(A72)') ZEILE
625       IF (INDEX(ZEILE,'ON')+INDEX(ZEILE,'on').EQ.0) THEN
            READ (ZEILE,6664) (DATD(IATM),IATM=1,NATMI)
            GOTO 620
          ELSE
           NFLR=NFLR+1
           IF (NFLR.GT.NHD6)
     .       CALL MASPRM('NHD6',4,NHD6,'NFLR',5,NFLR,IERROR)
            READ (ZEILE,'(A8)') FILNAM
            WRITE (6,*) ' NFLR =',NFLR,' FILNAM = ',FILNAM
            FILE(I2:)=FILNAM
            WRITE (6,*) ' FILE = ',FILE
            REFFIL(NFLR)=FILE
            READ (IUNIN,'(A72)') ZEILE
            GOTO 625
          ENDIF
        ENDIF
      ENDIF

      READ (IUNIN,6664) (DATD(IATM),IATM=1,NATMI)
620   READ (IUNIN,6664) (DMLD(IMOL),IMOL=1,NMOLI)
      READ (IUNIN,6664) (DIOD(IION),IION=1,NIONI)
      READ (IUNIN,6664) (DPLD(IPLS),IPLS=1,NPLSI)
      READ (IUNIN,6664) ERMIN,ERCUT,RPROB0,RINTEG(1),EINTEG(1),AINTEG(1)
c slmod begin - temp - not tr
      IF (opttest.EQ.1) THEN
        WRITE(0,*) 'SETTING ERMIN = 0.01'
        WRITE(6,*) 'SETTING ERMIN = 0.01'
        ERMIN=0.01
      ENDIF
c slmod end 
C
C  READ DATA FOR PRIMARY SOURCE  700--799
C
700   CONTINUE
C
      IF (output)
     .WRITE(6,*) 'MARK: INPUT: NFLR= ',NFLR
      READ (IUNIN,*)
      CALL MASAGE ('*** 7. DATA FOR PRIMARY SOURCES, NSTRAI STRATA   ')
C
710   READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:1) .EQ. '*') GOTO 710
      READ (ZEILE,6666) NSTRAI
      IREAD=0
      WRITE (6,*) '       NSTRAI= ',NSTRAI
      CALL LEER(1)
      IF (NSTRAI.GT.NSTRA)
     .  CALL MASPRM('NSTRA',5,NSTRA,'NSTRAI',6,NSTRAI,IERROR)
      READ (IUNIN,6666) (INDSRC(ISTRA),ISTRA=1,NSTRAI)
      READ (IUNIN,6664) ALLOC
      DO 712 ISTRA=1,NSTRAI
        IF (INDSRC(ISTRA).EQ.6) GOTO 712
        I=ISTRA
        IF (IREAD.EQ.0) THEN
          READ (IUNIN,'(A72)') TXTSOU(ISTRA)
        ELSEIF (IREAD.EQ.1) THEN
          READ (ZEILE,'(A72)') TXTSOU(ISTRA)
          IREAD=0
        ENDIF
713     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1) .EQ. '*') GOTO 713
        READ (ZEILE,6665) NLAVRP(ISTRA),NLAVRT(I),NLSYMP(I),NLSYMT(I)
        READ (IUNIN,6666) NPTS(ISTRA),NINITL(I),NEMODS(I),NAMODS(I)
        READ (IUNIN,66662) FLUX(ISTRA),SCALV(ISTRA),IVLSF(ISTRA),
     .                    ISCLS(ISTRA),ISCLT(ISTRA),ISCL1(ISTRA),
     .                    ISCL2(ISTRA),ISCL3(ISTRA),ISCLB(ISTRA),
     .                    ISCLA(ISTRA)
        READ (IUNIN,6665) NLATM(ISTRA),NLMOL(ISTRA),NLION(I),NLPLS(I)
        IF (output) WRITE(6,*) 'NLATM: ',istra,nlatm(istra)
        READ (IUNIN,6666) NSPEZ(ISTRA)
        READ (IUNIN,6665) NLPNT(ISTRA),NLLNE(ISTRA),
     .                    NLSRF(ISTRA),NLVOL(ISTRA),NLCNS(ISTRA)
C  SAME FOR POINT-, LINE-, SURFACE- AND VOLUME SOURCES
        READ (IUNIN,6666) NSRFSI(ISTRA)
        IF (NSRFSI(ISTRA).GT.NSRFS)
     .    CALL MASPRM('NSRFS',5,NSRFS,'NSRFSI(I)',9,NSRFSI(I),IERROR)
        DO 715 J=1,NSRFSI(ISTRA)
          READ (IUNIN,6666) INUM,INDIM(J,I),INSOR(J,I),
     .                      INGRDA(J,I,1),INGRDE(J,I,1),
     .                      INGRDA(J,I,2),INGRDE(J,I,2),
     .                      INGRDA(J,I,3),INGRDE(J,I,3)
          READ (IUNIN,6664) SORWGT(J,I),SORLIM(J,I),
     .                      SORIND(J,I),SOREXP(J,I),SORIFL(J,I)
          READ (IUNIN,6666) NRSOR(J,I),NPSOR(J,I),NTSOR(J,I),
     .                      NBSOR(J,I),NASOR(J,I),NISOR(J,I),ISTOR(J,I)
          READ (IUNIN,6664) SORAD1(J,I),SORAD2(J,I),SORAD3(J,I),
     .                      SORAD4(J,I),SORAD5(J,I),SORAD6(J,I)
715     CONTINUE
C  VELOCITY SPACE DISTRIBUTION
        READ (IUNIN,6664) SORENI(ISTRA),SORENE(I),SORVDX(I),SORVDY(I),
     .                    SORVDZ(ISTRA)
        READ (IUNIN,6664) SORCOS(I),SORMAX(I),SORCTX(I),SORCTY(I),
     .                    SORCTZ(ISTRA)
C
712   CONTINUE
C
      READ (IUNIN,*)
C     READ ADDITIONAL DATA FOR SOME SPECIFIC ZONES
C
800   CONTINUE
C
      CALL MASAGE ('*** 8. ADDITIONAL DATA FOR SPECIFIC ZONES ')
810   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 810
      READ (ZEILE,6666) NZADD
      IREAD=0
      WRITE (6,*) '       NZADD= ',NZADD
      CALL LEER(1)
      NULLIFY(TEMPLIST)
      NULLIFY(DENLIST)
      NULLIFY(VELLIST)
      NULLIFY(VOLLIST)
      DO 811 I=1,NZADD
        IF (IREAD.EQ.0) READ (IUNIN,*)
        IREAD=0
        READ (IUNIN,6666) INI,INE
        IF (INI.GT.NRAD.OR.INI.LE.0) GOTO 998
        IF (INE.GT.NRAD) GOTO 998
        IF (INE.LE.0) INE=INI
812     READ (IUNIN,'(A72)') ZEILE
C  IGJUM3 FLAG
        IF (ZEILE(1:3).EQ.'CH3') THEN
          INILGJ=MAX(1,MIN(NOPTIM,INI))
          INELGJ=MIN(NOPTIM,INE)
          DO 821 IN=INILGJ,INELGJ
c slmod begin - igjum3 - tr (already there)
            IF (NLIMPB >= NLIMPS) THEN
              CALL DEKEY (ZEILE(4:72),IGJUM3,0,NOPTIM,IN,NLIMPS)
            ELSE
              CALL DEKEYB (ZEILE(4:72),IGJUM3,0,NOPTIM,IN,NLIMPB,NBITS)
            ENDIF
c
c          CALL DEKEY (ZEILE(4:72),IGJUM3,0,NOPTIM,IN,NLIMPS)
c slmod end
821         CONTINUE
          GOTO 812
C  TEMPERATURE
        ELSEIF (ZEILE(1:1).EQ.'T') THEN
          DO 822 IN=INI,INE
            ALLOCATE(TEMPCUR)
            READ (ZEILE(2:72),66664) TEMPCUR%IDION,TEMPCUR%TE,
     .                               TEMPCUR%TI
            TEMPCUR%IN = IN
            TEMPCUR%NEXT => TEMPLIST
            TEMPLIST => TEMPCUR
822       CONTINUE
          GOTO 812
C  DENSITY
        ELSEIF (ZEILE(1:1).EQ.'D') THEN
          DO 823 IN=INI,INE
            ALLOCATE(DENCUR)
            READ (ZEILE(2:72),66664) DENCUR%IDION,DENCUR%DI
            DENCUR%IN = IN
            DENCUR%NEXT => DENLIST
            DENLIST => DENCUR
823       CONTINUE
          GOTO 812
C  VELOCITY (CM/SEC OR MACH)
        ELSEIF ((ZEILE(1:1).EQ.'V'.AND.ZEILE(2:2).NE.'L')
     .       .OR.ZEILE(1:1).EQ.'M') THEN
          DO 824 IN=INI,INE
            ALLOCATE(VELCUR)
            READ (ZEILE(2:72),66664) VELCUR%IDION,VELCUR%VX,VELCUR%VY,
     .                               VELCUR%VZ
            IF (ZEILE(1:1).EQ.'M') THEN
              VELCUR%IZ=1
            ELSEIF (ZEILE(1:1).EQ.'V') THEN
              VELCUR%IZ=-1
            ENDIF
            VELCUR%IN = IN
            VELCUR%NEXT => VELLIST
            VELLIST => VELCUR
824       CONTINUE
          GOTO 812
C  VOLUME
        ELSEIF (ZEILE(1:2).EQ.'VL') THEN
          DO 825 IN=INI,INE
            ALLOCATE(VOLCUR)
            READ (ZEILE(3:72),6664) VOLCUR%VOL
            VOLCUR%IN = IN
            VOLCUR%NEXT => VOLLIST
            VOLLIST => VOLCUR
825       CONTINUE
          GOTO 812
        ELSEIF (ZEILE(1:1).EQ.'*') THEN
          IREAD=1
          GOTO 811
        ELSE
          GOTO 998
        ENDIF
811   CONTINUE

C
C  READ DATA FOR STATISTICS AND NONANALOG MODEL, 900--999
C
900   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL MASAGE ('*** 9. DATA FOR STATISTIC AND NONANALOG MODEL   ')
C
910   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 910
C  DATA FOR CONDITIONAL EXPECTATION ESTIMATOR
      READ (ZEILE,6665) (NLPRCA(J),J=1,NATM),(NLPRCM(J),J=1,NMOL),
     .                  (NLPRCI(J),J=1,NION)
      READ (IUNIN,6666) NPRCSF
      NPRCSF=MIN0(NLIMPS,NPRCSF)
      IPRCSF=1
911   CONTINUE
      IF (IPRCSF.LE.NPRCSF) THEN
        READ (IUNIN,6666) (IPRSF(J),J=1,12)
        DO J=1,12
        IF (IPRSF(J).GT.0.AND.IPRSF(J).LE.NLIMPS)
     .     NLPRCS(IPRSF(J))=.TRUE.
        ENDDO
        IPRCSF=IPRCSF+12
        GOTO 911
      ENDIF
C  DATA FOR SPLITTING AND RUSSIAN ROULETTE
      READ (IUNIN,6666) MAXLEV,MAXRAD,MAXPOL,MAXTOR,MAXADD
      MXL=15
      IF (MAXLEV.GT.MXL)
     .    CALL MASPRM('MXL',3,MXL,'MAXLEV',6,MAXLEV,IERROR)
      IF (ABS(MAXRAD).GT.N1ST)
     .    CALL MASPRM('N1ST',4,N1ST,'MAXRAD',6,MAXRAD,IERROR)
      IF (MAXPOL.GT.N2ND)
     .    CALL MASPRM('N2ND',4,N2ND,'MAXPOL',6,MAXPOL,IERROR)
      IF (MAXTOR.GT.N3RD)
     .    CALL MASPRM('N3RD',4,N3RD,'MAXTOR',6,MAXTOR,IERROR)
      IF (MAXADD.GT.NLIM)
     .    CALL MASPRM('NLIM',4,NLIM,'MAXADD',6,MAXADD,IERROR)
      DO IN=1,MAXRAD
        READ (IUNIN,66665) ID,NSSPL(IN),PRMSPL(IN)
      ENDDO
      DO IN=1,MAXPOL
        READ (IUNIN,66665) ID,NSSPL(N1ST+IN),PRMSPL(N1ST+IN)
      ENDDO
      DO IN=1,MAXTOR
        READ (IUNIN,66665) ID,NSSPL(N1ST+N2ND+IN),PRMSPL(N1ST+N2ND+IN)
      ENDDO
      DO IN=1,MAXADD
        READ (IUNIN,66665) ID,NSSPL(N1ST+N2ND+N3RD+IN),
     .                        PRMSPL(N1ST+N2ND+N3RD+IN)
      ENDDO
C  DATA FOR BIAS SAMPLING
      READ (IUNIN,6664) WMINV,WMINS,WMINC
      WMINV=MAX(WMINV,EPS60)
      WMINS=MAX(WMINS,EPS60)
      WMINC=MAX(WMINC,EPS60)
      READ (IUNIN,6664) SPLPAR
C  DATA FOR STANDARD DEVIATION
      READ (IUNIN,*)
      CALL LEER(1)
      WRITE (6,*) '       CARDS FOR STANDARD DEVIATION '
      READ (IUNIN,6666) NSIGVI,NSIGSI,NSIGCI,NSIGI_BGK,NSIGI_COP
      WRITE (6,*) '       NSIGVI,NSIGSI,NSIGCI= ',NSIGVI,NSIGSI,NSIGCI
      CALL LEER(1)
      IF (NSIGVI.GT.NSD)
     .    CALL MASPRM('NSD',3,NSD,'NSIGVI',6,NSIGVI,IERROR)
      IF (NSIGSI.GT.NSDW)
     .    CALL MASPRM('NSDW',4,NSDW,'NSIGSI',6,NSIGSI,IERROR)
      IF (NSIGCI.GT.NCV)
     .    CALL MASPRM('NCV',3,NCV,'NSIGCI',6,NSIGCI,IERROR)
      DO 913 J=1,NSIGVI
        READ (IUNIN,6666) IGH(J),IIH(J)
913   CONTINUE
      DO 914 J=1,NSIGSI
        READ (IUNIN,6666) IGHW(J),IIHW(J)
914   CONTINUE
      DO 915 J=1,NSIGCI
        READ (IUNIN,6666) IGHC(1,J),IIHC(1,J),IGHC(2,J),IIHC(2,J)
915   CONTINUE
C
C   READ DATA FOR ADDITIONAL AND SURFACE AVERAGED TALLIES
      READ (IUNIN,*)
      CALL MASAGE ('*** 10. DATA FOR ADDITIONAL TALLIES, COLLISION   ')
      CALL MASAGE ('        ESTIMATORS  AND ALGEBRAIC EXPRESSIONS    ')
C
1010  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1010
      READ (ZEILE,6666) NADVI,NCLVI,NALVI,NADSI,NALSI
      WRITE (6,*) '        NADVI,NCLVI,NALVI= ',
     .                     NADVI,NCLVI,NALVI
      WRITE (6,*) '        NADSI,NALSI= ',
     .                     NADSI,NALSI
      CALL LEER(1)
C
      IF (NADVI.GT.NADV)
     .  CALL MASPRM('NADV',4,NADV,'NADVI',5,NADVI,IERROR)
      IF (NCLVI.GT.NCLV)
     .  CALL MASPRM('NCLV',4,NCLV,'NCLVI',5,NCLVI,IERROR)
      IF (NALVI.GT.NALV)
     .  CALL MASPRM('NALV',4,NALV,'NALVI',5,NALVI,IERROR)
      IF (NADSI.GT.NADS)
     .  CALL MASPRM('NADS',4,NADS,'NADSI',5,NADSI,IERROR)
C
1000  CONTINUE
C
      READ (IUNIN,*)
      CALL MASAGE('*** 10A. DATA FOR ADDITIONAL TALLIES           ')
      DO 1020 J=1,NADVI
1021    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1021
        READ (ZEILE,6666) IADVE(J),IADVS(J),IADVT(J),IADRC(J)
        READ (IUNIN,'(A72)') TXTTAL(J,NTALA)
        READ (IUNIN,'(2A24)') TXTSPC(J,NTALA),TXTUNT(J,NTALA)
1020  CONTINUE
      READ (IUNIN,*)
      CALL MASAGE('*** 10B. DATA FOR COLLISION ESTIMATORS         ')
      DO 1030 J=1,NCLVI
1031    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1031
        READ (ZEILE,6666) ICLVE(J),ICLVS(J),ICLVT(J),ICLRC(J)
        READ (IUNIN,'(A72)') TXTTAL(J,NTALC)
        READ (IUNIN,'(2A24)') TXTSPC(J,NTALC),TXTUNT(J,NTALC)
1030  CONTINUE
      READ (IUNIN,*)
      CALL MASAGE('*** 10C. DATA FOR ALGEBRAIC EXPRESSIONS     ')
      DO 1040 J=1,NALVI
1041    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1041
        READ (ZEILE,'(A72)') CHRTAL(J)
        READ (IUNIN,'(A72)') TXTTAL(J,NTALR)
        READ (IUNIN,'(2A24)') TXTSPC(J,NTALR),TXTUNT(J,NTALR)
1040  CONTINUE
C
      READ (IUNIN,*)
      CALL MASAGE('*** 10D. DATA FOR ADDITIONAL SURFACE TALLIES   ')
      DO 1050 J=1,NADSI
1051    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1051
        READ (ZEILE,6666) IADSE(J),IADSS(J),IADST(J),IADSC(J)
        READ (IUNIN,'(A72)') TXTTLS(J,NTLSA)
        READ (IUNIN,'(2A24)') TXTSPS(J,NTLSA),TXTUNS(J,NTLSA)
1050  CONTINUE
C
      READ (IUNIN,*)
      CALL MASAGE('*** 10E. DATA FOR ALGEBRAIC SURFACE TALLIES ')
      DO 1060 J=1,NALSI
1061    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1061
        READ (ZEILE,'(A72)') CHRTLS(J)
        READ (IUNIN,'(A72)') TXTTLS(J,NTLSR)
        READ (IUNIN,'(2A24)') TXTSPS(J,NTLSR),TXTUNS(J,NTLSR)
1060  CONTINUE
C
C   READ DATA FOR NUMERICAL AND GRAPHICAL OUTPUT 1100--1199
C
1100  CONTINUE
C
      READ (IUNIN,*)
      CALL LEER(1)
      CALL MASAGE ('*** 11. DATA FOR NUMERICAL AND GRAPHICAL OUTPUT  ')
C
1110  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1110
      READ (ZEILE,6665) TRCPLT,TRCHST,TRCNAL,TRCREA,TRCSIG,
     .                  TRCGRD,TRCSUR,TRCREF,TRCFLE,TRCAMD,
     .                  TRCINT,TRCLST,TRCSOU,TRCREC,TRCTIM,
     .                  TRCBLA,TRCBLM,TRCBLI,TRCBLP,TRCBLE
      READ (IUNIN,'(A72)') ZEILE
      READ (ZEILE,6665) (TRCSRC(J),J=0,NSTRA)
c      READ (IUNIN,6665) (TRCSRC(J),J=0,NSTRA)
C
      READ (IUNIN,6666) NVOLPR
      NVOLPR=MIN(NVOLPR,100)
      WRITE (6,*) '        NVOLPR= ',NVOLPR
      CALL LEER(1)
      DO 1120 J=1,NVOLPR
        READ (IUNIN,6666) NTLV,NFLGV,NSPZV1,NSPZV2
        IF (NTLV.LT.-NTALI.OR.NTLV.GT.NTALV) GOTO 990
        NPRTLV(J)=NTLV
        NFLAGV(J)=NFLGV
        NSPEZV(J,1)=NSPZV1
        NSPEZV(J,2)=NSPZV2
1120  CONTINUE
C
      READ (IUNIN,6666) NSURPR
      NSURPR=MIN(NSURPR,100)
      WRITE (6,*) '        NSURPR= ',NSURPR
      CALL LEER(1)
      DO 1130 J=1,NSURPR
        READ (IUNIN,6666) NTLS,NFLGS,NSPZS1,NSPZS2
        IF (NTLS.LT.0) NTLS=NLIM+IABS(NTLS)
        IF (NTLS.EQ.0.AND.NLIM+NSTSI.LT.NLIMPS) NTLS=NLIM+NSTSI+1
        IF (NTLS.LE.0.OR.NTLS.GT.NLIMPS) GOTO 991
        NPRTLS(J)=NTLS
        NFLAGS(NTLS)=NFLGS
        NSPEZS(NTLS,1)=NSPZS1
        NSPEZS(NTLS,2)=NSPZS2
1130  CONTINUE
1131  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1131
C  2D GEOMETRY PLOT
      READ (ZEILE,6665) PL1ST,PL2ND,PL3RD,PLADD,PLHST,
     .                  PLCUT(1),PLCUT(2),PLCUT(3),PLBOX,PLSTOR,
     .                  PLNUMV,PLNUMS,PLARR
      READ (IUNIN,6666) NPLINR,NPLOTR,NPLDLR,NPLINP,NPLOTP,NPLDLP,
     .                  NPLINT,NPLOTT,NPLDLT
C  3D GEOMETRY PLOT
      DO 1140 J=1,5
        READ (IUNIN,6662) PL3A(J),TEXTLA(J),IPLTA(J),
     .                (IPLAA(J,I),IPLEA(J,I),I=1,IPLTA(J))
1140   CONTINUE
      DO 1141 J=1,3
        READ (IUNIN,6662) PL3S(J),TEXTLS(J),IPLTS(J),
     .                (IPLAS(J,I),IPLES(J,I),I=1,IPLTS(J))
1141  CONTINUE
C
      READ (IUNIN,6664) CH2MX,CH2MY,      CH2X0,CH2Y0,CH2Z0
      READ (IUNIN,6664) CH3MX,CH3MY,CH3MZ,CH3X0,CH3Y0,CH3Z0
      READ (IUNIN,6664) ANGLE1,ANGLE2,ANGLE3
C
C  PARTICLE HISTORY PLOTS IN 2D OR 3D GEOMETRY PLOTS
      READ (IUNIN,6666) I1TRC,I2TRC,(ISYPLT(J),J=1,8),ILINIE
C
1151  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1151
C  DATA FOR PLOTS OF VOLUME AVERAGED TALLIES
      READ (ZEILE,6666) NVOLPL
      WRITE (6,*) '        NVOLPL= ',NVOLPL
      CALL LEER(1)
C
      IF (NVOLPL.GT.NPTAL)
     .  CALL MASPRM('NPTAL',5,NPTAL,'NVOLPT',6,NVOLPL,IERROR)
C
      IF (NVOLPL.LE.0) GOTO 1175
      READ (IUNIN,6665) (PLTSRC(J),J=0,NSTRA)
      DO 1150 J=1,NVOLPL
1152    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1152
        READ (ZEILE,6666) NSP
        IF (NSP.GT.NPLT)
     .    CALL MASPRM('NPLT',4,NPLT,'NSP',3,NSP,IERROR)
        NSPTAL(J)=NSP
        READ (IUNIN,6665) PLTL2D(J),PLTL3D(J),PLTLLG(J),PLTLER(J)
        READ (IUNIN,6664) TALZMI(J),TALZMA(J),TALXMI(J),TALXMA(J),
     .                    TALYMI(J),TALYMA(J)
        IF (PLTL2D(J)) THEN
          READ (IUNIN,6665) LHIST2(J),LSMOT2(J)
          DO 1160 I=1,NSPTAL(J)
            READ (IUNIN,6666) ISPTAL(J,I),NTL,
     .                        NPLIN2(J,I),NPLOT2(J,I),NPLDL2(J,I)
            IF (NTL.LT.-NTALI.OR.NTL.GT.NTALV.OR.NTL.EQ.0) GOTO 990
            NPTALI(J,I)=NTL
1160      CONTINUE
        ENDIF
        IF (PLTL3D(J)) THEN
          READ (IUNIN,6665) LHIST3(J),LCNTR3(J),LSMOT3(J),
     .                      LRAPS3(J),LVECT3(J),LRPVC3(J)
          READ (IUNIN,6665) LPRAD3(J),LPPOL3(J),LPTOR3(J)
          DO 1161 I=1,NSPTAL(J)
            READ (IUNIN,6666) ISPTAL(J,I),NTL,IPROJ3(J,I),
     .                        NPLI13(J,I),NPLO13(J,I),
     .                        NPLI23(J,I),NPLO23(J,I)
            IF (NTL.LT.-NTALI.OR.NTL.GT.NTALV.OR.NTL.EQ.0) GOTO 990
            NPTALI(J,I)=NTL
1161      CONTINUE
          READ (IUNIN,6664) TALW1(J),TALW2(J),FCABS1(J),FCABS2(J)
          IF (FCABS1(J).LE.0.0D0) FCABS1(J)=1.0D0
          IF (FCABS2(J).LE.0.0D0) FCABS2(J)=1.0D0
        ENDIF
1150  CONTINUE
C
C  SKIP INPUT LINES, UNTIL INPUT BLOCK 12 STARTS
1175  READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:3) .EQ. '***') GOTO 1205
      GOTO 1175
C
C  READ DATA FOR DIAGNOSTIC MODULE  1200--1299
C
1200  CONTINUE
C
1205  CALL MASAGE ('*** 12. DATA FOR DIAGNOSTIC MODULE              ')
1210  READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:1) .EQ. '*') GOTO 1210
      READ (ZEILE,6666) NCHORI,NCHENI
      WRITE (6,*) '        NCHORI,NCHENI= ',NCHORI,NCHENI
      CALL LEER(1)
      IF (NCHORI.GT.NCHOR)
     .    CALL MASPRM('NCHOR',5,NCHOR,'NCHORI',6,NCHORI,IERROR)
      IF (IABS(NCHENI).GT.NCHEN)
     .    CALL MASPRM('NCHEN',5,NCHEN,'IABS(NCHENI)',12,IABS(NCHENI),
     .                 IERROR)
      IF (NCHORI.LE.0) GOTO 1230
      DO 1220 ICHORI=1,NCHORI
        READ (IUNIN,'(A72)') TXTSIG(ICHORI)
        READ (IUNIN,6666) NCHTAL(ICHORI),NSPSCL(ICHORI),NSPNEW(ICHORI)
        READ (IUNIN,6666) NSPSTR(ICHORI),NSPSPZ(ICHORI),
     .                    NSPINI(ICHORI),NSPEND(ICHORI),
     .                    NSPBLC(ICHORI),NSPADD(ICHORI)
        READ (IUNIN,6664) EMIN1(ICHORI),EMAX1(ICHORI)
        READ (IUNIN,66664) IPIVOT(ICHORI),
     .                     XPIVOT(ICHORI),YPIVOT(ICHORI),ZPIVOT(ICHORI)
        READ (IUNIN,66664) ICHORD(ICHORI),
     .                     XCHORD(ICHORI),YCHORD(ICHORI),ZCHORD(ICHORI)
1220  CONTINUE
      READ (IUNIN,6665) PLCHOR,PLSPEC
1230  CONTINUE
C  SKIP READING REST OF THIS BLOCK
      READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:3).NE.'***') GOTO 1230
      IREAD=1
C
C  READ DATA FOR NONLINEAR MODE  1300--1399
C
1300  CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL MASAGE ('*** 13. DATA FOR ITERATIVE AND TIME DEP. OPTION ')
C
      READ (IUNIN,6666) NPRNLI
      WRITE (6,*) '        NPRNLI= ',NPRNLI
      CALL LEER(1)
      IF (NPRNLI.LE.0) GOTO 1350
      IF (NPRNLI.GT.NPRNL)
     .    CALL MASPRM('NPRNL',5,NPRNL,'NPRNLI',6,NPRNLI,IERROR)
      READ (IUNIN,6666) NPTST,NTMSTP
      READ (IUNIN,6664) DTIMV,TIME0
C   READ DATA FOR SNAPSHOT TALLIES
      READ (IUNIN,*)
      CALL MASAGE ('*** 13A. DATA FOR SNAPSHOT TALLIES           ')
      READ (IUNIN,6666) NSNVI
      WRITE (6,*) '        NSNVI= ',NSNVI
      CALL LEER(1)
      IF (NSNVI.GT.NSNV)
     .  CALL MASPRM('NSNV',4,NSNV,'NSNVI',5,NSNVI,IERROR)
      DO 1320 J=1,NSNVI
1321    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1321
        READ (ZEILE,6666) ISNVE(J),ISNVS(J),ISNVT(J),ISNRC(J)
        READ (IUNIN,'(A72)') TXTTAL(J,NTALT)
        READ (IUNIN,'(2A24)') TXTSPC(J,NTALT),TXTUNT(J,NTALT)
1320  CONTINUE
C
      IF (NTIME.LE.0) THEN
        WRITE (6,*) 'ERROR IN INPUT: TIME DEP. MODE BUT NTIME.LE.0'
        CALL EXIT
      ENDIF
1350  CONTINUE
C  SKIP READING REST OF THIS BLOCK
      READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:3).NE.'***') GOTO 1350
      IREAD=1
C
      IF (NTIME.GE.1) THEN
C  DEFINE ONE MORE SURFACE
        NSTSI=NSTSI+1
C  CHECK STORAGE
        CALL LEER(1)
        IF (NSTSI.GT.NSTS) THEN
          CALL MASPRM('NSTS',4,NSTS,'NSTSI',5,NSTSI,IERROR)
          CALL EXIT
        ENDIF
C
C  SET DEFAULTS FOR "TIME SURFACE"
C
        TXTSFL(NLIM+NSTSI)='"TIME SURFACE"                           '
        ILIIN(NLIM+NSTSI)=2
C
        IF (NFILEJ.EQ.2.OR.NFILEJ.EQ.3) THEN
C
C  SET DEFAULTS FOR SOURCE DUE TO INITIAL CONDITION, VALID ONLY FOR
C  FIRST TIMESTEP. MODIFIED FOR LATER TIMESTEPS IN SUBR. TMSTEP
C
C  DEFINE ONE MORE STRATUM
          NSTRAI=NSTRAI+1
C  CHECK STORAGE
          IF (NSTRAI.GT.NSTRA) THEN
            CALL MASPRM('NSTRA',5,NSTRA,'NSTRAI',6,NSTRAI,IERROR)
            CALL EXIT
          ENDIF
C
          TXTSOU(NSTRAI)='SOURCE DUE TO INITIAL CONDITION          '
C  SOURCE DISTRIBUTION SAMPLED FROM CENSUS ARRAYS RPARTC,IPARTC
          NLCNS(NSTRAI)=.TRUE.
          NLPNT(NSTRAI)=.FALSE.
          NLLNE(NSTRAI)=.FALSE.
          NLSRF(NSTRAI)=.FALSE.
          NLVOL(NSTRAI)=.FALSE.
C  DO NOT CALL IF2COP(NSTRAI)
          INDSRC(NSTRAI)=-1
C
          NLAVRP(NSTRAI)=.FALSE.
          NLAVRT(NSTRAI)=.FALSE.
          NLSYMP(NSTRAI)=.FALSE.
          NLSYMT(NSTRAI)=.FALSE.
          NPTS(NSTRAI)=0
          NINITL(NSTRAI)=2000*NINITL(NSTRAI-1)+1
          NEMODS(NSTRAI)=1
          NAMODS(NSTRAI)=1
          FLUX(NSTRAI)=0.
          NLATM(NSTRAI)=.FALSE.
          NLMOL(NSTRAI)=.FALSE.
          NLION(NSTRAI)=.FALSE.
          NLPLS(NSTRAI)=.FALSE.
          NSPEZ(NSTRAI)=0
          NSRFSI(NSTRAI)=0
C
          SORENI(NSTRAI)=0.
          SORENE(NSTRAI)=0.
          SORVDX(NSTRAI)=0.
          SORVDY(NSTRAI)=0.
          SORVDZ(NSTRAI)=0.
          SORCOS(NSTRAI)=0.
          SORMAX(NSTRAI)=0.
          SORCTX(NSTRAI)=0.
          SORCTY(NSTRAI)=0.
          SORCTZ(NSTRAI)=0.
C
C  READ INITIAL POPULATION FROM PREVIOUS RUN, OVERWRITE DEFAULTS
C

C  NEW TIMESTEP
          IF (DTIMVN.LE.0.D0) THEN
            DTIMVN=DTIMV
C         ELSE
C           DTIMVN=DTIMVN
          ENDIF
C
C  OLD TIMESTEP
          CALL RSNAP
          DTIMVO=DTIMV
C
          WRITE (6,*) 'INITIAL POPULATION FOR FIRST TIMESTEP'
          WRITE (6,*) 'READ FROM FILE FT 15 '
          WRITE (6,*) 'PARTICLES AND FLUX STORED FOR INITIAL '
          WRITE (6,*) 'DISTRIBUTION IN PREVIOUS RUN '
          CALL MASJ1('IPRNL   ',IPRNL)
          CALL MASR1('FLUX    ',FLUX(NSTRAI))
C
          IF (DTIMVN.NE.DTIMVO) THEN
            FLUX(NSTRAI)=FLUX(NSTRAI)*DTIMVO/DTIMVN
C
            WRITE (6,*) 'FLUX IS RESCALED BY DTIMV_OLD/DTIMV_NEW '
            CALL MASR1('FLUX    ',FLUX(NSTRAI))
            CALL LEER(1)
          ENDIF
C
          DTIMV=DTIMVN
C
          IF (NPTST.LE.0) THEN
            NPTS(NSTRAI)=IPRNL
          ELSEIF (NPTST.GT.0) THEN
            NPTS(NSTRAI)=NPTST
          ENDIF
C
          IF (NPTS(NSTRAI).GT.0.AND.FLUX(NSTRAI).GT.0) THEN
            NSRFSI(NSTRAI)=1
            SORWGT(1,NSTRAI)=1.D0
          ENDIF
C
          CALL LEER(2)
          DO I=1,IPRNL
            RPARTC(I,10)=TIME0
          ENDDO
          WRITE (6,*) 'PARTICLE CLOCK RESET TO TIME0'
          WRITE (6,*) 'FIRST TIMESTEP RUNS FROM TIM1 TO TIM2:  '
          CALL MASR2('TIM1, TIM2      ',TIME0,TIME0+DTIMV)
          CALL LEER(2)
        ENDIF
C
      ENDIF
1399  CONTINUE
C
1500  IF (IERROR.GT.0) THEN
        WRITE (6,*) IERROR,' INPUT OR PARAMETER ERRORS DETECTED '
        WRITE (6,*) ' SEE THE ERRORMESSAGES LISTED ABOVE AND CORRECT '
        WRITE (6,*) ' THE ERRORS BEFORE RE-EXECUTION '
        CALL EXIT
      ENDIF
C
      CALL PAGE
C
6662  FORMAT (L1,1X,A24,1X,I1,1X,4(2I3,1X))
6664  FORMAT (6E12.4)
6665  FORMAT (12(5L1,1X))
6666  FORMAT (12I6)
66661 FORMAT (I3,1X,A6,1X,A4,A9,A3,2I3,3E12.4)
66662 FORMAT (2E12.4,10I6)
66664 FORMAT (I6,6X,5E12.4)
66665 FORMAT (2I6,4E12.4)
66666 FORMAT (I2,1X,A8,1X,12(I2,1X))
C
C   MODIFICATION OF INPUT DUE TO EITHER INCONSISTENCIES OR DUE
C   TO COUPLED NEUTRAL-PLASMA (OR NEUTRAL-NEUTRAL) CALCULATIONS
C   SOME FURTHER CONSTANTS ARE SET.      STATEM. NO. 2000 --> 4000
C
C
C   GEOMETRY, GRIDS
C
      IF (NLSLB) LEVGEO=1
      IF (NLCRC) LEVGEO=2
      IF (NLELL) LEVGEO=2
      IF (NLTRI) LEVGEO=2
      IF (NLPLG) LEVGEO=3
      IF (NLFEM) LEVGEO=4
      IF (NLGEN) LEVGEO=5
      IF (NLFEM) THEN
        NLPOL=.FALSE.
        NLTOR=.FALSE.
        IF (INDPRO(1).NE.3.AND.INDPRO(1).LT.6) THEN
          WRITE (6,*) ' PROFILE OPTION ',INDPRO(1),' NOT FORESEEN FOR'
          WRITE (6,*) ' FINITE ELEMENT MESH '
          WRITE (6,*) ' INDPRO(1) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(1)=3
        ENDIF
        IF (INDPRO(2).NE.3.AND.INDPRO(2).LT.6) THEN
          WRITE (6,*) ' PROFILE OPTION ',INDPRO(2),' NOT FORESEEN FOR'
          WRITE (6,*) ' FINITE ELEMENT MESH '
          WRITE (6,*) ' INDPRO(2) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(2)=3
        ENDIF
        IF (INDPRO(3).NE.3.AND.INDPRO(3).LT.6) THEN
          WRITE (6,*) ' PROFILE OPTION ',INDPRO(3),' NOT FORESEEN FOR'
          WRITE (6,*) ' FINITE ELEMENT MESH '
          WRITE (6,*) ' INDPRO(3) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(3)=3
        ENDIF
        IF (INDPRO(4).NE.3.AND.INDPRO(4).LT.6) THEN
          WRITE (6,*) ' PROFILE OPTION ',INDPRO(4),' NOT FORESEEN FOR'
          WRITE (6,*) ' FINITE ELEMENT MESH '
          WRITE (6,*) ' INDPRO(4) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(4)=3
        ENDIF
      ENDIF
      IF (INDGRD(1).LE.4.AND.LEVGEO.LE.2) THEN
        IF (RGA.LE.RIA) RGA=RAA
        IF (RGA.GE.RAA) RGA=RAA
        IF (NRSEP.LE.1) RGA=RAA
        IF (NRSEP.GE.NR1ST) RGA=RAA
        IF (RGA.EQ.RAA) NRSEP=1
      ENDIF
      IF (INDGRD(2).LE.4) THEN
        IF (YGA.LE.YIA) YGA=YAA
        IF (YGA.GE.YAA) YGA=YAA
        IF (NPSEP.LE.1) YGA=YAA
        IF (NPSEP.GE.NP2ND) YGA=YAA
        IF (YGA.EQ.YAA) NPSEP=1
      ENDIF
      IF (INDGRD(3).LE.4) THEN
        IF (ZGA.LE.ZIA) ZGA=ZAA
        IF (ZGA.GE.ZAA) ZGA=ZAA
        IF (NTSEP.LE.1) ZGA=ZAA
        IF (NTSEP.GE.NT3RD) ZGA=ZAA
        IF (ZGA.EQ.ZAA) NTSEP=1
      ENDIF
C
      IF (.NOT.NLPOL) NP2ND=1
      NP2ND=MIN0(N2ND,NP2ND)
      IF (.NOT.NLTOR) NT3RD=1
      NT3RD=MIN0(N3RD,NT3RD)
      IF (NLTOR) NTTRA=NT3RD
      NR1P2=0
      IF (NLPOL.OR.NLTOR) NR1P2=NR1ST
      NP2T3=0
      IF (NLTOR) NP2T3=NP2ND
c slmod begin - not tr
c...  Needed to have scaling of recombination source using contributions
c     from each NBLOCK.  Not sure what effect turning NP2T3 on will have in the
c     rest of the code:
c      IF (NLMLT) NP2T3=NP2ND
c slmod end
      IF (.NOT.NLADD) NRADD=0
      IF (.NOT.NLMLT) NBMLT=1
C
C  SOURCE PARAMETERS AND (REFLECTING) BOUNDARY CONDITIONS,
C  ON ADDITIONAL AND NON DEFAULT STANDARD SURFACES
C
      DO 2000 J=0,NLIMPS
        IF (ILCOL(J).LT.0) IGFIL(J)=1
        ILCOL(J)=MAX0(1,IABS(ILCOL(J)))
        IF (ILIIN(J).LE.0.OR.ILIIN(J).GE.3) ILSPT(J)=0
        IF (ILIIN(J).LE.0) TRANSP(1,J)=0.D0
        IF (ILIIN(J).LE.0) TRANSP(2,J)=0.D0
        ISPUT(1,J)=IDEZ(ILSPT(J),1,2)
        ISPUT(2,J)=IDEZ(ILSPT(J),2,2)
        IF (ILIIN(J).EQ.2) RECYCF(1,J)=0.
        IF (ILIIN(J).EQ.2) RECYCT(1,J)=0.
C
        SAVE=ZNML(J)
        ZNML(J)=DBLE(IDINT(SAVE/100.D0))
        ZNCL(J)=SAVE-100.*ZNML(J)
        RINTEG(J)=RINTEG(1)
        EINTEG(J)=EINTEG(1)
        AINTEG(J)=AINTEG(1)
        DO 2001 ISPZ=1,NSPZ
          RECYCF(ISPZ,J)=RECYCF(1,J)
          RECYCT(ISPZ,J)=RECYCT(1,J)
          RECPRM(ISPZ,J)=RECPRM(1,J)
          EXPPL(ISPZ,J)=EXPPL(1,J)
          EXPEL(ISPZ,J)=EXPEL(1,J)
          EXPIL(ISPZ,J)=EXPIL(1,J)
          RECYCS(ISPZ,J)=RECYCS(1,J)
          RECYCC(ISPZ,J)=RECYCC(1,J)
          SPTPRM(ISPZ,J)=SPTPRM(1,J)
          ISRS(ISPZ,J)=ISRS(1,J)
          ISRC(ISPZ,J)=ISRC(1,J)
          ISRF(ISPZ,J)=ISRF(ISPZ,1)
          ISRT(ISPZ,J)=ISRT(ISPZ,1)
2001    CONTINUE
2000  CONTINUE
C
      DO 2011 I=0,N1ST
        DO 2011 J=0,N2ND
          DO 2011 K=0,N3RD
            INMP1I(I,J,K)=0
            INMP2I(I,J,K)=0
2011        INMP3I(I,J,K)=0
C
      DO 2019 ISTS=1,NSTSI
        NLJ=NLIM+ISTS
        ISWICH(1,NLJ)=IDEZ(ILSWCH(NLJ),1,6)
        IF (ISWICH(1,NLJ).EQ.1) ISWICH(1,NLJ)=-1
        IF (ISWICH(1,NLJ).EQ.2) ISWICH(1,NLJ)=1
        ISWICH(2,NLJ)=IDEZ(ILSWCH(NLJ),2,6)
        IF (ISWICH(2,NLJ).EQ.1) ISWICH(2,NLJ)=-1
        IF (ISWICH(2,NLJ).EQ.2) ISWICH(2,NLJ)=1
        ISWICH(3,NLJ)=IDEZ(ILSWCH(NLJ),3,6)
        IF (ISWICH(3,NLJ).EQ.1) ISWICH(3,NLJ)=-1
        IF (ISWICH(3,NLJ).EQ.2) ISWICH(3,NLJ)=1
        ISWICH(4,NLJ)=IDEZ(ILSWCH(NLJ),4,6)
        IF (ISWICH(4,NLJ).EQ.1) ISWICH(4,NLJ)=-1
        IF (ISWICH(4,NLJ).EQ.2) ISWICH(4,NLJ)=1
        ISWICH(5,NLJ)=IDEZ(ILSWCH(NLJ),5,6)
        IF (ISWICH(5,NLJ).EQ.1) ISWICH(5,NLJ)=-1
        IF (ISWICH(5,NLJ).EQ.2) ISWICH(5,NLJ)=1
c slmod begin - new
c...    Not sure what this is for, but it needs to be
c       extended for ISWICH(5,NLJ).EQ.3 if broken grids
c       are being used.
c slmod end
        ISWICH(6,NLJ)=IDEZ(ILSWCH(NLJ),6,6)
        IF (ISWICH(6,NLJ).EQ.1) ISWICH(6,NLJ)=-1
        IF (ISWICH(6,NLJ).EQ.2) ISWICH(6,NLJ)=1
C
        IF (ISWICH(4,NLJ).NE.0.OR.ISWICH(5,NLJ).NE.0.OR.
     .      ISWICH(6,NLJ).NE.0) THEN
          ILBLCK(NLJ)=IDEZ(ILCELL(NLJ),4,4)
          I1000=1000*ILBLCK(NLJ)
          ILACLL(NLJ)=ILCELL(NLJ)-I1000
        ENDIF
C
C  SET NON DEFAULT STANDARD SURFACE IDENTIFIERS INMP...
C
C  RADIAL SURFACE
        DO 2014 IR=1,NR1ST
          IF (IR.EQ.INUMP(ISTS,1)) THEN
            INMP1I(IR,0,0)=ISTS
            DO 2013 J=IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              INMP1I(IR,J,0)=ISTS
              DO 2013 K=IRPTA(ISTS,3),IRPTE(ISTS,3)-1
                INMP1I(IR,0,K)=ISTS
2013            INMP1I(IR,J,K)=ISTS
          ENDIF
2014    CONTINUE
C  POLOIDAL SURFACE
        DO 2016 JP=1,NP2ND
          IF (JP.EQ.INUMP(ISTS,2)) THEN
            INMP2I(0,JP,0)=ISTS
            DO 2015 I=IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              INMP2I(I,JP,0)=ISTS
              DO 2015 K=IRPTA(ISTS,3),IRPTE(ISTS,3)-1
                INMP2I(0,JP,K)=ISTS
2015            INMP2I(I,JP,K)=ISTS
          ENDIF
2016    CONTINUE
C  TOROIDAL SURFACE
        DO 2018 KT=1,NT3RD
          IF (KT.EQ.INUMP(ISTS,3)) THEN
            INMP3I(0,0,KT)=ISTS
            DO 2017 I=IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              INMP3I(I,0,KT)=ISTS
              DO 2017 J=IRPTA(ISTS,2),IRPTE(ISTS,2)-1
                INMP3I(0,J,KT)=ISTS
2017            INMP3I(I,J,KT)=ISTS
          ENDIF
2018    CONTINUE
C
2019  CONTINUE
C
      NLSYMT(0)=.TRUE.
      NLSYMP(0)=.TRUE.
      DO 2028 ISTRA=1,NSTRAI
        IF (INDSRC(ISTRA).EQ.6) GOTO 2028
        IF (.NOT.NLSRF(ISTRA))
     .  THMAX=MAX(0.D0,MIN(PIA,SORMAX(ISTRA)*DEGRAD))
        IF (NLSRF(ISTRA))
     .  THMAX=MAX(0.D0,MIN(PIHA,SORMAX(ISTRA)*DEGRAD))
        IF (NAMODS(ISTRA).EQ.1) THEN
          RP1=SORCOS(ISTRA)+1.
          SORCOS(ISTRA)=1./RP1
          IF (ABS(COS(THMAX)).LE.EPS10) THEN
            SORMAX(ISTRA)=1.
          ELSE
            SORMAX(ISTRA)=1.-COS(THMAX)**RP1
          ENDIF
        ELSEIF (NAMODS(ISTRA).EQ.2) THEN
          SORCOS(ISTRA)=SORCOS(ISTRA)*DEGRAD
          SORMAX(ISTRA)=THMAX
        ELSE
          WRITE (6,*) 'INPUT ERROR: ISTRA,NAMODS(ISTRA)='
          WRITE (6,*) '             ',ISTRA,NAMODS(ISTRA)
          CALL EXIT
        ENDIF
        NLSYMT(0)=NLSYMT(0).AND.NLSYMT(ISTRA)
        NLSYMP(0)=NLSYMP(0).AND.NLSYMP(ISTRA)
2028  CONTINUE
C
C
C  PLOTTING AND TEXT
C
      IF (NPLOTR.LE.0) NPLOTR=NR1ST
      IF (NPLOTP.LE.0) NPLOTP=NP2ND
      IF (NPLOTT.LE.0) NPLOTT=NT3RD
      NPLOTR=MIN0(NPLOTR,NR1ST)
      NPLINR=MAX0(NPLINR,1)
      NPLDLR=MAX0(NPLDLR,1)
      NPLOTP=MIN0(NPLOTP,NP2ND)
      NPLINP=MAX0(NPLINP,1)
      NPLDLP=MAX0(NPLDLP,1)
      NPLOTT=MIN0(NPLOTT,NT3RD)
      NPLINT=MAX0(NPLINT,1)
      NPLDLT=MAX0(NPLDLT,1)
      PL1ST=PL1ST.AND.NR1ST.GT.1
      PL2ND=PL2ND.AND.NP2ND.GT.1
      PL3RD=PL3RD.AND.NT3RD.GT.1
      PLADD=PLADD.AND.NLIMI.GT.0
      NLPL2D=PL1ST.OR.PL2ND.OR.PL3RD.OR.PLADD
      NLPL3D=PL3A(1).OR.PL3A(2).OR.PL3A(3).OR.PL3A(4).OR.PL3A(5).OR.
     .       PL3S(1).OR.PL3S(2).OR.PL3S(3)
      PLHST=PLHST.AND.(NLPL2D.OR.NLPL3D)
      PLCHOR=PLCHOR.AND.NVOLPL.EQ.0
      TRCSUR=TRCSUR.AND.(NLIMI.GT.0.OR.NSTSI.GT.0)
      LPRADR=.FALSE.
      LPPOLR=.FALSE.
      LPTORR=.FALSE.
C
C  SPECIES INDEX DISTRIBUTION OF PRIMARY SOURCE PARTICLES
C  OR FOR THERMAL PARTICLE REFLECTION MODEL
C
      NATMIM=NATMI-1
      NMOLIM=NMOLI-1
      NIONIM=NIONI-1
      NPLSIM=NPLSI-1
      SA=0.
      SI=0.
      SM=0.
      SP=0.
      DO 2210 J=1,NIONI
        SI=SI+DIOD(J)
2210    DION(J)=SI
      DO 2211 J=1,NMOLI
        SM=SM+DMLD(J)
2211    DMOL(J)=SM
      DO 2212 J=1,NATMI
        SA=SA+DATD(J)
2212    DATM(J)=SA
      DO 2213 J=1,NPLSI
        SP=SP+DPLD(J)
2213    DPLS(J)=SP
C
C  NORMALIZE DISTRIBUTION AND CUMULATIVE DISTRIBUTION
      DO 2215 IION=1,NIONI
        DIOD(IION)=DIOD(IION)/(SI+1.D-60)
2215    DION(IION)=DION(IION)/(SI+1.D-60)
      DO 2216 IMOL=1,NMOLI
        DMLD(IMOL)=DMLD(IMOL)/(SM+1.D-60)
2216    DMOL(IMOL)=DMOL(IMOL)/(SM+1.D-60)
      DO 2217 IATM=1,NATMI
        DATD(IATM)=DATD(IATM)/(SA+1.D-60)
2217    DATM(IATM)=DATM(IATM)/(SA+1.D-60)
      DO 2218 IPLS=1,NPLSI
        DPLD(IPLS)=DPLD(IPLS)/(SP+1.D-60)
2218    DPLS(IPLS)=DPLS(IPLS)/(SP+1.D-60)
C
C
C  ATOMIC WEIGHT OF TEST IONS  =RMASSI(IION)
      DO 2401 IION=1,NIONI
        RMASSI(IION)=NMASSI(IION)*PMASSA
        RSQDVI(IION)=1./SQRT(RMASSI(IION))*CVELAA
        CVRSSI(IION)=RMASSI(IION)*CVELI2
2401    ALMASI(IION)=LOG10(RMASSI(IION))
C  ATOMIC WEIGHT OF ATOMS  =RMASSA(IATM)
      DO 2402 IATM=1,NATMI
        RMASSA(IATM)=NMASSA(IATM)*PMASSA
        RSQDVA(IATM)=1./SQRT(RMASSA(IATM))*CVELAA
        CVRSSA(IATM)=RMASSA(IATM)*CVELI2
2402    ALMASA(IATM)=LOG10(RMASSA(IATM))
C  ATOMIC WEIGHT OF MOLECULES
      DO 2403 IMOL=1,NMOLI
        RMASSM(IMOL)=NMASSM(IMOL)*PMASSA
        RSQDVM(IMOL)=1./SQRT(RMASSM(IMOL))*CVELAA
        CVRSSM(IMOL)=RMASSM(IMOL)*CVELI2
2403    ALMASM(IMOL)=LOG10(RMASSM(IMOL))
C  ATOMIC WEIGHT OF BULK IONS
      DO 2404 IPLS=1,NPLSI
        RMASSP(IPLS)=NMASSP(IPLS)*PMASSA
        RSQDVP(IPLS)=1./SQRT(RMASSP(IPLS))*CVELAA
        CVRSSP(IPLS)=RMASSP(IPLS)*CVELI2
2404    ALMASP(IPLS)=LOG10(RMASSP(IPLS))
C
C
C  SET SOME ARRAYS TO SPEED UP COMPUTATIONS
C
C  1ST: SPECIES FLAGS:
        DO IA=0,NATMP
        DO IM=0,NMOLP
        DO II=0,NIONP
        DO IP=0,NPLSP
          ISPEZ(0,IA,IM,II,IP)=0
          ISPEZ(1,IA,IM,II,IP)=IA
          ISPEZ(2,IA,IM,II,IP)=NATMI+IM
          ISPEZ(3,IA,IM,II,IP)=NATMI+NMOLI+II
          ISPEZ(4,IA,IM,II,IP)=NATMI+NMOLI+NIONI+IP
        ENDDO
        ENDDO
        ENDDO
        ENDDO
        DO IZ=1,NATMI
          ISPEZI(IZ,0)=1
          ISPEZI(IZ,1)=IZ
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NATMI+1,NATMI+NMOLI
          ISPEZI(IZ,0)=2
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=IZ-NATMI
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NATMI+NMOLI+1,NATMI+NMOLI+NIONI
          ISPEZI(IZ,0)=3
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,3)=IZ-NATMI-NMOLI
          ISPEZI(IZ,3)=0
        ENDDO
        DO IZ=NATMI+NMOLI+NIONI+1,NATMI+NMOLI+NIONI+NPLSI
          ISPEZI(IZ,0)=4
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=IZ-NATMI-NMOLI-NIONI
        ENDDO
C
C
C  ADDITIONAL INPUT FOR THIS RUN COMES FROM EITHER
C  ANOTHER CODE (DATA FILE) OR FROM AN EARLIER RUN OF EIRENE
C
3000  CONTINUE
C
C  INPUT BLOCK 14 BEGIN
C
C  READ DATA IN INTERFACING SUBROUTINE INFCOP  1400 -- 1499
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL MASAGE ('*** 14. DATA FOR INTERFACING ROUTINE "INFCOP"   ')
c slmod begin - tr
1310  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1310
      BACKSPACE IUNIN
c slmod end
      IF (NMODE.EQ.0) THEN
        WRITE (6,*) '        SUBR. INFCOP NOT CALLED. '
        READ (IUNIN,6666) NAINI
        WRITE (6,*) '        NAINI = ',NAINI
        IF (NAINI.GT.NAIN) THEN
          CALL MASPRM('NAIN',4,NAIN,'NAINI',5,NAINI,IERROR)
          GOTO 1500
        ENDIF
        DO 3020 J=1,NAINI
3021      READ (IUNIN,'(A72)') ZEILE
          IF (ZEILE(1:1) .EQ. '*') GOTO 3021
          READ (IUNIN,6666) NAINS(J),NAINT(J)
          READ (IUNIN,'(A72)') TXTPLS(J,NTALN)
          READ (IUNIN,'(2A24)') TXTPSP(J,NTALN),TXTPUN(J,NTALN)
3020    CONTINUE
      ELSEIF (NMODE.NE.0) THEN
        NAINI=0
C  READ BLOCK 14 AND GEOMETRY FROM EXTERNAL DATABASE (FT30)
        CALL IF0COP
      ENDIF
C
C  INPUT BLOCK 14 DONE
C
C  NO MODIFICATION OF INPUT VARIABLES BEYOND THIS POINT
C  WITHOUT WARNING
C  EXCEPT IN SUBROUTINE MODUSR FOR THE NEXT ITERATION STEP
C         IN SUBROUTINE TMSUSR FOR THE NEXT TIME STEP
C
      CALL STTXT1
C
      CALL INIUSR
C
C  SET DERIVED INPUT PARAMETERS, GRIDS AND PROFILES
C
      NSURF=NR1ST*NP2ND*NT3RD*NBMLT
      NSTRD=NR1ST*NP2ND*NT3RD
      NBLCKS=NBMLT*NP2ND*NT3RD
      NSBOX=NSURF+NRADD
c slmod begin - tr
c GERMANY:
c...  Make sure that the toroidal resolution on the standard
c     grid does not cause arrays to be referenced out-of-
c     bounds:
      IF (NSURF.GT.N1ST*N2ND*N3RD) THEN
        WRITE(0,*) 'NSURF IS TOO LARGE',NSURF,N1ST*N2ND*N3RD
        WRITE(6,*) 'NSURF IS TOO LARGE',NSURF,N1ST*N2ND*N3RD
        CALL EXIT
      ENDIF
c slmod end
      IF (NSBOX.GT.NRAD) THEN
        CALL MASPRM('NRAD',4,NRAD,'NSBOX',5,NSBOX,IERROR)
        CALL EXIT
      ENDIF
      NSURFM=NSURF-1
      NR1STM=NR1ST-1
      NP2NDM=NP2ND-1
      NT3RDM=NT3RD-1
      NTTRAM=NTTRA-1
      NBMLTP=NBMLT+1
C
      NSIGI=NSIGVI+NSIGSI+NSIGCI
      NCPVI_STAT=0
      IF (NSIGI_COP > 0) NCPVI_STAT=NCPVI+NPLSI+2
      IF (NCPVI_STAT > NCPV_STAT) THEN
        CALL MASPRM('NCPVI_STAT',10,NCPVI_STAT,
     .              'NCPV_STAT',9,NCPV_STAT,IERROR)
        CALL EXIT
      END IF
C
      CALL PAGE
C
      IF (NFILEM.LE.1) THEN
C
C  SET GRIDS AND VOLUMES OF THE CELLS FOR THE STANDARD MESHES
C
        IF (output) WRITE(0,*) 'MARK: CALLING GRID'
C  SET RADIAL OR X GRID
        IF (NLRAD) CALL GRID (1)
C  SET POLOIDAL OR Y GRID
        IF (NLPOL) CALL GRID (2)
C  SET TOROIDAL OR Z GRID
        IF (NLTOR) CALL GRID (3)
C
        IF (output) WRITE(0,*) 'MARK: CALLING VOLUME'
C  INITIALIZE SUBROUTINE VOLUME FOR LATER CALLS
C       TO BE WRITTEN. AT PRESENT: MUST CALL VOLUME(1)
C  SET VOLUMES, 1ST DIMENSION (R/X-GRID)
        IF (NLRAD) CALL VOLUME(1)
C  SET VOLUMES, 2ND DIMENSION (THETA/Y-GRID)
        IF (NLPOL) CALL VOLUME(2)
C  SET VOLUMES, 3RD DIMENSION (PHI/Z-GRID)
        IF (NLTOR) CALL VOLUME(3)
C  SET VOLUMES, IN ADDITIONAL CELL REGION
        IF (NLADD) CALL VOLUME(4)
C
C  OVERWRITE VOLUMES, IF TRANSFERRED FROM EXTERNAL FILE
C
        IF (output) WRITE(0,*) 'MARK: RETURNED FROM VOLUME'
        IF (INDPRO(12).EQ.6) CALL PROFR (VOL,5+5*NPLS,1,1,NSURF)
C
C  MULTIPLY GEOMETRICAL DATA, IF NBMLT.GT.1
C
        IF (NBMLT.GT.1) CALL MULTIG
C
C   INCLUDE INFORMATION PROVIDED BY INPUT BLOCK 8: ADDITIONAL
C   DATA FOR SPECIFIC ZONES
C
        DO WHILE (ASSOCIATED(VOLLIST))
          VOL(VOLLIST%IN) = VOLLIST%VOL
          VOLCUR => VOLLIST
          VOLLIST => VOLLIST%NEXT
          DEALLOCATE(VOLCUR)
        ENDDO
C
C   MODIFY SOME GEOMETRICAL DATA, USER SUPPLIED ROUTINE
C
        IF (output) WRITE(0,*) 'MARK: CALLING GEOUSR'
        CALL GEOUSR
C
C  SET SOME DATA FOR ADDITIONAL SURFACES: INITIALIZE SUBR. TIMEA
C
        IF (output) WRITE(0,*) 'MARK: CALLING TIMEA0'
        CALL TIMEA0
C
C   MODIFY THE BOUNDARIES OF SOME SURFACES TO AVOID ROUND OFF
C   ERRORS
C
        IF (output) WRITE(0,*) 'MARK: CALLING SETFIT'
        CALL SETFIT (TRCSUR)
C
C   SET THE COEFFICIENTS OF SOME SURFACES IDENTICAL TO THOSE
C   OF SOME OTHER, TO AVOID ROUND OFF ERRORS
C
        IF (output) WRITE(0,*) 'MARK: CALLING SETEQ'
        CALL SETEQ
C
        IF (output) WRITE(0,*) 'MARK: CALLING WRMESH'
        IF (LEVGEO.EQ.3) CALL WRMESH
C
C
        CALL INTVOL (VOL,1,1,NSBOX,VOLTOT,
     .               NR1ST,NP2ND,NT3RD,NBMLT)
C
c slmod begin - tr
C  USER SUPPLIED ROUTINE FOR ASSIGNING IGJUMx ARRAYS
c        WRITE(0,*) 
c        WRITE(0,*) '*** NOT CALLING JUMUSR ***'
c        WRITE(0,*) 
        CALL JUMUSR

c      DO NCELL=1,NRAD
c        IGJUM4(NCELL,0)=1
c        DO J=1,8
c          IGJUM4(NCELL,J)=0
c        ENDDO
c      ENDDO

c        WRITE(0,*) 'MARK: NLIMPB=',nlimpb

c slmod end
C  SET 'VISIBLE ADDITIONAL SURFACES' RANGES
        DO 8002 J=1,NRAD
          NLIMII(J)=1
          NLIMIE(J)=NLIMI
8002    CONTINUE
        NSOPT=MIN(NOPTIM,NSBOX)
        DO 8004 J=1,NSOPT
c slmod begin - not tr (seems like they should be, but not sure)
c          DO I=1,NLIMPB
c            IGJUM3(J,I)=0
c          ENDDO


          IF (NLIMPB >= NLIMPS) THEN
            DO 8005 I=1,NLIMI
              LHELP(I) = IGJUM3(J,I)==0
8005        CONTINUE
            IIN=ILLZ(NLIMI,LHELP,1)+1
            IEN=NLIMI-ILLZ(NLIMI,LHELP,-1)
          ELSE
            IIN = -1
            IEN = -1
            DO I = 1, NLIMI
              IF (IIN.EQ.-1.AND.
     .            .NOT.BITGET(IGJUM3,0,NOPTIM,J,I,NBITS)) IIN=I
              IF (.NOT.BITGET(IGJUM3,0,NOPTIM,J,I,NBITS)) IEN=I
            ENDDO
        

c            NO=NOT(0)
c            IGO=NLIMI/NBITS
c            IAN=IGO+1
c            IAB=IGO+1
c            IBEND=MOD(NLIMI,NBITS)+1
c            Write(0,*) ']]',nlimi,nbits,ibend,no,igo
c            DO I=1,IGO
c              IF (IAND(IGJUM3(J,I),NO) /= NO) THEN
c                IF (IAN > I) THEN
c                  IAN = I
c                  IBEND = NBITS-1
c                END IF
c                IAB = I
c              END IF
c            END DO
c            ILA=IBEND
c            DO IB=0,IBEND
c              IF (.NOT.BTEST(IGJUM3(J,IAN),IB)) THEN
c                ILA=IB
c                EXIT
c              END IF
c            END DO
c            WRITE(0,*) '-> ',ian,nbits,ila,ibend
c            IIN = (IAN-1)*NBITS+ILA+1
c            IEN = 0
c            IF (IIN <= NLIMI) THEN
c              ILE=IBEND
c              DO IB=IBEND,0,-1
c                IF (.NOT.BTEST(IGJUM3(J,IAB),IB)) THEN
c                  ILE=IB
c                  EXIT
c                END IF
c              END DO
c              WRITE(0,*) '-> ',iab,ile
c              IEN = (IAB-1)*NBITS+ILE+1
c            END IF
          ENDIF
          NLIMII(J)=IIN
          NLIMIE(J)=IEN
c          NLIMII(J)=1
c          NLIMIE(J)=NLIMI
c          WRITE(6,*) 'NLIMI,E=',J,NLIMII(J),NLIMIE(J),NLIMI
c
c          DO 8005 I=1,NLIMI
c!PB         LHELP(I)=.NOT.LGJUM3(J,I)
c            LHELP(I) = IGJUM3(J,I)==0
c8005      CONTINUE
c          IIN=ILLZ(NLIMI,LHELP,1)+1
c          IEN=NLIMI-ILLZ(NLIMI,LHELP,-1)
c          NLIMII(J)=IIN
c          NLIMIE(J)=IEN
c slmod end
8004    CONTINUE
c slmod begin - debug - not tr
        IF (debugopt.NE.0) THEN
          WRITE(6,*)
     .      'SOMEWHERE: NRAD,NLIMI,NSOPT,NSURF,NOPTIM,NSBOX = '
          WRITE(6,*)
     .      '   ',NRAD,NLIMI,NSOPT,NSURF,NOPTIM,NSBOX
        ENDIF
c slmod end
C
C  ALL GEOMETRICAL DATA (GRIDS, VOLUMES, SWITCHES) ARE DEFINED NOW
C
C   SAVE GEOMETRICAL DATA ON FILE FT12
C
        DO 8006 IRAD=1,NSBOX
          VOLG(IRAD)=VOL(IRAD)
8006    CONTINUE
C
        DO ILIMPS=1,NLMPGS
          AREAG(ILIMPS)=SAREA(ILIMPS)
        ENDDO
C
        IF (NFILEM.EQ.1) CALL WRGEOM(TRCFLE)
C
      ELSEIF (NFILEM.EQ.2) THEN
C
C   RESTORE GEOMETRICAL DATA FROM FILE FT12
C
        CALL RGEOM(TRCFLE)
C
        DO 8010 IRAD=1,NSBOX
          VOL(IRAD)=VOLG(IRAD)
8010    CONTINUE
C
        DO ILIMPS=1,NLMPGS
          SAREA(ILIMPS)=AREAG(ILIMPS)
        ENDDO
C
C
      ENDIF
C
      DO 8011 IS=1,NLIMPS
        IF (ILACLL(IS).NE.0.AND..NOT.NLADD) THEN
          WRITE (6,*) 'ADDITIONAL CELL SWITCHES DEFINED, BUT NO '
          WRITE (6,*) 'ADDITIONAL CELLS DEFINED'
          ISS=IS
          IF (ISS.GT.NLIM) ISS=-(ISS-NLIM)
          WRITE (6,*) 'SURFACE NO. IS= ',ISS
          WRITE (6,*) 'CHECK INPUT BLOCK 2E'
          CALL EXIT
        ELSEIF (ILBLCK(IS).NE.0.AND..NOT.(NLMLT.OR.NLADD)) THEN
          WRITE (6,*) 'BLOCK SWITCHES DEFINED, BUT NEITHER BLOCKS'
          WRITE (6,*) 'NOR ADDITIONAL CELLS DEFINED'
          ISS=IS
          IF (ISS.GT.NLIM) ISS=-(ISS-NLIM)
          WRITE (6,*) 'SURFACE NO. IS= ',ISS
          WRITE (6,*) 'CHECK INPUT BLOCKS 2D AND 2E'
          CALL EXIT
        ENDIF
8011  CONTINUE
C
4000  CONTINUE
C
      IF (NMODE.NE.0.AND.IITER.LE.1) THEN
C  READ PLASMA BACKGROUND FROM EXTERNAL DATABASE (FT31) (NOT NLPLAS)
C  OR FROM COMMON BRAEIR (NLPLAS)
        CALL IF1COP
c slmod begin - not tr


c          WRITE(6,*) 'DIIN CHECK 1: ',1,1,DIIN(1,1)
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,*) 'CHECK1: ',IPLS,IN,
c     .                              DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .                              VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .                              VZIN(IPLS,IN)
c            ENDDO
c          ENDDO
c slmod end
C  COMPUTE SOURCE DATA (OVERRULE SOME OF INPUT BLOCK 7)
        DO ISTRA=1,NSTRAI
          IF (INDSRC(ISTRA).GE.0) CALL IF2COP(ISTRA)
        ENDDO
      ENDIF
C
      IF (output)
     .WRITE(0,*) 'MARK: NFILEL = ',NFILEL
      IF (NFILEL.LE.1) THEN
C
C  SET PLASMA PARAMETERS AND SOURCE PARAMETERS
C
c slmod begin - debug - not tr
        IF (debugopt.NE.0) WRITE(0,*) ' INPUT: Calling PLASMA'
c slmod end
        CALL PLASMA
c slmod begin - not tr



c          STOP 'ADDCEL PLA'

c          WRITE(6,*) 'DIIN CHECK 3: ',1,1,DIIN(1,1)
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,*) 'CHECK3: ',IPLS,IN,
c     .                              DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .                              VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .                              VZIN(IPLS,IN)
c            ENDDO
c          ENDDO
c slmod end
C
C  MULTIPLY PLASMA PARAMETERS, IF NBLCKS.GT.1
C
        IF (NBLCKS.GT.1) CALL MULTIP
C
C   INCLUDE INFORMATION PROVIDED BY INPUT BLOCK 8: ADDITIONAL
C   DATA FOR SPECIFIC ZONES
C
        IF (NZADD.GT.0) THEN
          DO WHILE (ASSOCIATED(TEMPLIST))
            TEIN(TEMPLIST%IN) = TEMPLIST%TE
            TIIN(TEMPLIST%IDION,TEMPLIST%IN) = TEMPLIST%TI
            TEMPCUR => TEMPLIST
            TEMPLIST => TEMPLIST%NEXT
            DEALLOCATE(TEMPCUR)
          ENDDO

          DO WHILE (ASSOCIATED(DENLIST))
            DIIN(DENLIST%IDION,DENLIST%IN) = DENLIST%DI
            DENCUR => DENLIST
            DENLIST => DENLIST%NEXT
            DEALLOCATE(DENCUR)
          ENDDO

          DO WHILE (ASSOCIATED(VELLIST))
            IPLS = VELLIST%IDION
            J = VELLIST%IN
            VXIN(IPLS,J) = VELLIST%VX
            VYIN(IPLS,J) = VELLIST%VY
            VZIN(IPLS,J) = VELLIST%VZ
            IF (VELLIST%IZ .EQ. 1) THEN
              VXIN(IPLS,J)=CVEL2A*VXIN(IPLS,J)*
     .                     SQRT((TEIN(J)+TIIN(IPLS,J))/RMASSP(IPLS))
              VYIN(IPLS,J)=CVEL2A*VYIN(IPLS,J)*
     .                     SQRT((TEIN(J)+TIIN(IPLS,J))/RMASSP(IPLS))
              VZIN(IPLS,J)=CVEL2A*VZIN(IPLS,J)*
     .                     SQRT((TEIN(J)+TIIN(IPLS,J))/RMASSP(IPLS))
            ENDIF
            VELCUR => VELLIST
            VELLIST => VELLIST%NEXT
            DEALLOCATE(VELCUR)
          ENDDO
        ENDIF
C
C   MODIFY SOME PLASMA DATA, USER SUPPLIED ROUTINE
C
        CALL PLAUSR
c slmod begin - not tr



c          WRITE(6,*) 'DIIN CHECK 4: ',1,1,DIIN(1,1)
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,*) 'CHECK4: ',IPLS,IN,
c     .                              DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .                              VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .                              VZIN(IPLS,IN)
c            ENDDO
c          ENDDO
c slmod end
C
C  COMPUTE SOME 'DERIVED' PLASMA DATA PROFILES FROM THE INPUT PROFILES
C
        CALL PLASMA_DERIV
c slmod begin - not tr
c          WRITE(6,*) 'ADDCEL DER: '
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .          IPLS,IN,
c     .          DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .          VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .          VZIN(IPLS,IN),
c     .          BXIN(IN),BYIN(IN),BZIN(IN)
c            ENDDO
c          ENDDO

c slmod end
C
C  SET ATOMIC DATA TABLES
C
        CALL SETAMD
c slmod begin - tr (modified)
c        WRITE(6,*) 'STDCEL STA: ',nsurf,nsbox
c        DO IPLS = 1, NPLSI
c          DO IN = 1, NSURF
c            WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .        IPLS,IN,
c     .        DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .        VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .        VZIN(IPLS,IN),
c     .        BXIN(IN),BYIN(IN),BZIN(IN)
c          ENDDO
c        ENDDO


        CALL BGKUSR

c          WRITE(6,*) 'ADDCEL AMD: '
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .          IPLS,IN,
c     .          DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .          VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .          VZIN(IPLS,IN),
c     .          BXIN(IN),BYIN(IN),BZIN(IN)
c            ENDDO
c          ENDDO

c          WRITE(6,*) 'TABEL3 AMD: '
c          DO IN = NSURF+1, NSURF+NRADD
c            WRITE(6,'(I6,1P,4E10.2,0P)') 
c     .        IN,(TABEL3(I1,IN,1),I1=1,4)
c          ENDDO

c        STOP 'AFTER CALL TO AMD'

c        WRITE(6,*) 'LGVAC (STANDARD GRID):'
c        DO IN = 1, NSURF
c          WRITE(6,*) IN,(LGVAC(IN,I1),I1=0,NPLS+1)
c        ENDDO


c        WRITE(6,*) 'LGVAC (ADDITIONAL SURFACE):'
c        DO IN = NSURF+1, NSURF+NRADD
c          WRITE(6,*) IN,(LGVAC(IN,I1),I1=0,NPLS+1)
c        ENDDO


c        WRITE(6,*) 'STDCEL BGK:',nsurf,nsbox
c        DO IPLS = 1, NPLSI
c          DO IN = 1, NSURF
c            WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .        IPLS,IN,
c     .        DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .        VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .        VZIN(IPLS,IN),
c     .        BXIN(IN),BYIN(IN),BZIN(IN)
c          ENDDO
c        ENDDO



c slmod end
C
        IF (NFILEL.EQ.1) CALL WRPLAM(TRCFLE)
C
      ELSEIF (NFILEL.EQ.2.OR.NFILEL.EQ.3) THEN
C
C  READ PLASMA DATA, ATOMIC DATA, SOURCE DATA FROM FT13
C
        CALL RPLAM(TRCFLE)
C
      ENDIF
C
      IF (TRCSUR) THEN
C
        CALL LEER(2)
        WRITE (6,*) 'COEFFICIENTS FOR ADDITIONAL SURFACES'
        WRITE (6,*) 'THIS IS AFTER ADDUSR, SETEQ AND SETFIT ARE CALLED '
        DO 7701 J=1,NLIMI
          CALL LEER(2)
          WRITE (6,*) TXTSFL(J)
          CALL LEER(1)
          IF (IGJUM0(J) == 1) THEN
            WRITE (6,*) 'THIS SURFACE IS NOT DEFINED'
          ELSE
            WRITE (6,*) 'A0       ',A0LM(J)
            WRITE (6,*) 'A1,A2,A3 ',A1LM(J),A2LM(J),A3LM(J)
            WRITE (6,*) 'A4,A5,A6 ',A4LM(J),A5LM(J),A6LM(J)
            WRITE (6,*) 'A7,A8,A9 ',A7LM(J),A8LM(J),A9LM(J)
            WRITE (6,*) 'JUMLIM ',JUMLIM(J)
            WRITE (6,*) 'ISWICH(1),ISWICH(2),ISWICH(3),ISWICH(4),',
     .                  'ISWICH(5),ISWICH(6)'
            WRITE (6,*)  ISWICH(1,J),ISWICH(2,J),ISWICH(3,J),
     .                   ISWICH(4,J),ISWICH(5,J),ISWICH(6,J)
          ENDIF
7701    CONTINUE
        CALL LEER(2)
        CALL MASIR2('IGJUM0 ',IGJUM0,1,1,1,1,NLIMPS)
        CALL LEER(1)
        IF (NLIMPB >= NLIMPS) THEN
          CALL MASIR2('IGJUM1 ',IGJUM1,0,NLIMPS,1,NLIMPS,NLIMPS)
        ELSE
          CALL MASBR2('IGJUM1 ',IGJUM1,0,NLIMPS,1,NLIMPS,NLIMPS,NBITS)
        END IF
        CALL LEER(1)
        IF (NLIMPB >= NLIMPS) THEN
          CALL MASIR2('IGJUM2 ',IGJUM2,0,NLIMPS,1,NLIMPS,NLIMPS)
        ELSE
          CALL MASBR2('IGJUM2 ',IGJUM2,0,NLIMPS,1,NLIMPS,NLIMPS,NBITS)
        END IF
        CALL LEER(1)
        NSOPT=MIN(NSBOX,NOPTIM)
c slmod begin - igjum3 - not tr (already there)
        IF (NLIMPB >= NLIMPS) THEN
          CALL MASIR2('IGJUM3 ',IGJUM3,0,NOPTIM,1,NSOPT,NLIMPS)
        ELSE
          CALL MASBR2('IGJUM3 ',IGJUM3,0,NOPTIM,1,NSOPT,NLIMPS,NBITS)
        END IF
c
c        CALL MASIR2('IGJUM3 ',IGJUM3,0,NOPTIM,1,NSOPT,NLIMPS)
c slmod end
        CALL LEER(1)
        DO 7702 J=1,NSBOX
          CALL MASJ3 ('J,NLIMII,NLIMIE          ',J,NLIMII(J),NLIMIE(J))
7702    CONTINUE
C
      ENDIF
C
C
c slmod begin - not tr
c          WRITE(6,*) 'DIIN CHECK 3: ',1,1,DIIN(1,1)
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,*) 'CHECK5: ',DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .                              VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .                              VZIN(IPLS,IN)
c            ENDDO
c          ENDDO


c          WRITE(6,*) 'ADDCEL RET: '
c          DO IPLS = 1, NPLSI
c            DO IN = NSURF+1, NSURF+NRADD
c              WRITE(6,'(2I6,1P,8E10.2,0P)') 
c     .          IPLS,IN,
c     .          DIIN(IPLS,IN),TIIN(IPLS,IN),
c     .          VXIN(IPLS,IN),VYIN(IPLS,IN),
c     .          VZIN(IPLS,IN),
c     .          BXIN(IN),BYIN(IN),BZIN(IN)
c            ENDDO
c          ENDDO

c      IF (NITER.EQ.1) THEN
c        WRITE(0,*) 'CALLING MODBG1'
c        CALL MODBG1
c      ENDIF

c slmod end
      RETURN
C
C  ERROR EXITS
C
990   CONTINUE
      WRITE (6,*) 'TALLY NUMBER FOR PRINTOUT OR PLOT OF VOLUME'
      WRITE (6,*) 'AVERAGED TALLIES OUT OF RANGE'
      CALL EXIT
991   CONTINUE
      WRITE (6,*) 'TALLY NUMBER FOR PRINTOUT OF SURFACE AVERAGED '
      WRITE (6,*) 'TALLIES OUT OF RANGE'
      CALL EXIT
992   CONTINUE
      WRITE (6,*) 'FINITE ELEMENT OPTION USED, BUT GRID INDICATOR '
      WRITE (6,*) 'LESS THAN 6. '
      CALL EXIT
994   CONTINUE
      WRITE (6,*) 'ERROR IN INPUT: NRPLG.NE.NP2ND, BUT NLPOL=TRUE'
      WRITE (6,*) 'NRPLG,NP2ND ',NRPLG,NP2ND
      CALL EXIT
998   CONTINUE
      WRITE (6,*) 'ERROR IN INPUT BLOCK FOR ADDITIONAL DATA FOR  '
      WRITE (6,*) 'SPECIFIC ZONES FOUND AT ZONE NO. ',I
      CALL EXIT
      END
C
