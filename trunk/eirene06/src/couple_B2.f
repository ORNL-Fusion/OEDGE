C EIRENE06 COMPILATION
C ===== SOURCE: eirsrt.f
C
C
      SUBROUTINE EIRSRT(LSTOP,LTIME,DELTAT,FLUXES,
     .                  B2BRM,B2RD,B2Q,B2VP)

      USE PRECISION
      USE PARMMOD
      USE BRASPOI
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CINIT
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CTRCEI
      USE CCOUPL
      USE CGEOM
      USE CSDVI
      USE CSDVI_BGK
      USE CSDVI_COP
      USE COMPRT
      USE COMNNL
      USE COMSOU
      USE COUTAU
      USE COMXS
      USE CSPEI
      USE BRASCL

      IMPLICIT NONE
C
      REAL(DP), INTENT(IN) :: FLUXES(NSTRA)
      REAL(DP), INTENT(IN) :: DELTAT, B2BRM, B2RD, B2Q, B2VP
      LOGICAL, INTENT(IN) :: LSTOP, LTIME

      REAL(DP) :: FLUXS(NSTRA)
      REAL(DP) :: FTABEI1, FEELEI1, FLXI, ESIG, RESET_SECOND, DUMMY,
     .          SECOND_OWN, DTIMVO
      INTEGER :: IN, IAEI, IRDS, IIDS, ICPV, IMDS, IFIRST, K, JC, NDXY,
     .           J, IRC, NREC10, NREC11, IPLSTI
      REAL(DP), ALLOCATABLE :: OUTAU(:)
      INTEGER, ALLOCATABLE :: IHELP(:)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
C
      SAVE
      DATA IFIRST/0/
C
      IF (LTIME) THEN
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        DUMMY=RESET_SECOND()
        IF(IFIRST.EQ.0) THEN
C
          CALL GRSTRT(35,8)
C
C  READ FORMATTED INPUT FILE IUNIN
C  AND RUN EIRENE FOR ONE TIME-CYCLE: ITIMV=1
C  WITH OR WITHOUT INITIAL DISTRIBUTION ON FILE FT15 (NFILE-J FLAG)
C  AS FINAL STRATUM
C  EXPECT PLASMA DATA ON FORT.31 (NLPLAS=.FALSE.)
C
          CALL EIRENE(DELTAT,.FALSE.,.FALSE.,1,.TRUE.)
C
C  EIRENE RUN DONE. CENSUS ARRAY WRITTEN
C  NOW ITIMV=ITIMV+1, NLPLAS=.TRUE.
C
          DO 3 ISTRA=1,NSTRAI
            FLUXS(ISTRA)=FLUX(ISTRA)
3         CONTINUE
          IFIRST=1
        ELSE
C
C  NOW: NLPLAS=.TRUE., I.E., PLASMA DATA EXPECTED ON BRAEIR
C  NOW: ITIMV=ITIMV+1
C  BUT: COMMON BRAEIR REDONE IN EXTERNAL CODE.
C  REACTIVATE INDEX MAPPING, EVEN WITHOUT READING INPUT BLOCK 14 AGAIN
          NCUTB_SAVE=NCUTB
C
          DTIMVO=DTIMV
          DTIMVN=DELTAT
C
C-----------------------------------------------------------------------
C
C  STRATA 1 TO NTARGI ARE SCALED IN PLASMA CODE  (RECYCLING STRATA)
C
C     RETURN TO PLASMA CODE THE PROFILES PER UNIT SOURCE STRENGTH
C     IE. THE PROFILES ARE SCALED BY 1./FLUX(ISTRA) BEFORE RETURN
C
C  STRATA NTARGI+1 TO NSTRAI-1  ARE SCALED BY EIRENE
C
C     (EG. GAS PUFF, VOLUME RECOMBINATION, ETC.)
C     THEY MAY BE RESCALED BY PLASMA CODE FACTORS: FLUXES(ISTRA)
C     RETURN TO PLASMA CODE THE PROFILES SCALED WITH
C     SOURCE STRENGTH: FLUX(ISTRA) (AMP)
C
C  STRATUM NSTRAI IS RESCALED WITH RATIO OF OLD TO NEW TIMESTEP
C
C     RETURN TO PLASMA CODE THE PROFILES WITH FLUX(ISTRA) (AMP)
C
          DO ISTRA=NTARGI+1,NSTRAI-1
            IF (FLUXES(ISTRA).NE.0.) THEN
              FLUX(ISTRA)=FLUXS(ISTRA)*FLUXES(ISTRA)*ELCHA
            ELSE
              FLUX(ISTRA)=FLUXS(ISTRA)
            ENDIF
          ENDDO
C
          IF (DTIMVN.NE.DTIMVO) THEN
            FLUX(NSTRAI)=FLUX(NSTRAI)*DTIMVO/DTIMVN
C
            WRITE (iunout,*) 'FLUX IS RESCALED BY DTIMV_OLD/DTIMV_NEW '
            CALL MASR1('FLUX    ',FLUX(NSTRAI))
            CALL LEER(1)
          ENDIF
C
C-----------------------------------------------------------------------
C
          DTIMV=DTIMVN
C
C  RUN EIRENE ON TIMESTEP DTIMV
C  THEN CALL INTERFACING ROUTINE AT ENTRY IF3COP (FROM EIRENE MAIN)
C
          IITER=1
          IPRNLI=0
          CALL EIRENE_COUPLE (LSTOP,1)
          IF (LSTOP) THEN
            CALL GREND
          ENDIF
        ENDIF
        CALL LEER(2)
        WRITE(*,*) 'EIRENE USED ',SECOND_OWN(),' CPU SECONDS'
        CALL LEER(2)
C
        RETURN
C
      ELSEIF (.NOT.LTIME) THEN
C
C  SHORT CYCLE, SEMI-IMPLICIT COUPLING
C
        IF (IFIRST.GE.1) GOTO 10000
C
        CALL ALLOC_COMUSR(1)
        CALL SETPRM
C
        NREC10=1500
        OPEN (UNIT=10,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC10)
        NREC11=NOUTAU
        OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
C
        IRC=3
        READ (11,REC=IRC) RCCPL
        ALLOCATE (IHELP(NOUTAU))
        JC=0
        IRC=IRC+1
        READ (11,REC=IRC) IHELP
        DO K=1,NPTRGT
          DO J=1,10*NSTEP
            JC=JC+1
            ICCPL1(J,K)=IHELP(JC)
            IF (JC == NOUTAU) THEN
              IRC=IRC+1
              READ (11,REC=IRC) IHELP
              JC=0
            END IF
          END DO
        END DO
        DEALLOCATE (IHELP)
        IRC=IRC+1
        READ (11,REC=IRC) ICCPL2
        IRC=IRC+1
        READ (11,REC=IRC) LCCPL
        IF (LTRCFL)
     .    WRITE (iunout,*) 'READ DATA FOR SHORT CYCLE, SAVED ON  FT11 ',
     .                      IRC
C
        NLPLG=LNLPLG
        NLDRFT=LNLDRF
        TRCFLE=LTRCFL
        NSTRAI=NSTRI
        DO 1 ISTRA=1,NSTRAI
          NLVOL(ISTRA)=LNLVOL(ISTRA)
1       CONTINUE
        NMODE=NMODEI
        NFILEN=NFILNN
C
C
        INDPRO(1)=6
        INDPRO(2)=6
        INDPRO(3)=6
        INDPRO(4)=6
        INDPRO(5)=6
C
        INDGRD(1)=6
        INDGRD(2)=1
        INDGRD(3)=1
C
        CALL SETCON
        CALL RGEOM(TRCFLE)
        CALL RPLAM(TRCFLE,0)
C
        IF (TRCFLE) 
     .    WRITE (iunout,*) 'READ DATA FOR EIRENE RECALL OPTION'
        IRC=1
        READ (11,REC=IRC) LOGATM,LOGION,LOGMOL,LOGPLS,LOGPHOT
        IF (TRCFLE)
     .    WRITE (iunout,*) 
     .    'DATA FOR RECALL OPTION READ FROM  FT11, IRC=1 '
        IRC=2
        ALLOCATE (OUTAU(NOUTAU))
        CALL WRITE_COUTAU (OUTAU, IUNOUT)
        READ (11,REC=IRC) OUTAU
        DEALLOCATE (OUTAU)
        IF (TRCFLE)
     .    WRITE (iunout,*) 
     .    'DATA FOR RECALL OPTION READ FROM  FT11, IRC=2 '
C
        CALL INTER0
C
        NDXY=(NDXA-1)*NR1ST+NDYA
C
!PB        IF (.NOT.ALLOCATED(SPLODA)) CALL ALLOC_BRASCL
        CALL ALLOC_BRASCL
        CALL INIT_BRASCL1
C
C  INITIAL: ATOMS, EI-PROCESSES
C
        DO 21 IATM=1,NATMI
        DO 21 IPLS=1,NPLSI
        DO 21 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 21
          DO 22 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
22        CONTINUE
21      CONTINUE
        DO 23 IPLS=1,NPLSI
          IPLSTI= MPLSTI(IPLS)
          DO 24 IN=1,NDXY
            SEIODA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLSTI,IN)+EDRIFT(IPLS,IN))
24        CONTINUE
23      CONTINUE
C
        DO 25 IATM=1,NATMI
        DO 25 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          DO 25 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
25      CONTINUE
C
C  INITIAL: TEST IONS, EI-PROCESSES
C
        DO 26 IION=1,NIONI
        DO 26 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          DO 26 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODI(IN,IION)=SEEODI(IN,IION)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODI(IN,IION)=SEEODI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
26      CONTINUE
C
        DO 27 IION=1,NIONI
        DO 27 IPLS=1,NPLSI
        DO 27 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 27
          DO 28 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ENDIF
28        CONTINUE
27      CONTINUE
C
        DO 29 IION=1,NIONI
        DO 29 IPLS=1,NPLSI
        DO 29 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 30 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODI(IN,IION)=SEIODI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODI(IN,IION)=SEIODI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
30        CONTINUE
29      CONTINUE
C
C
C  INITIAL: MOLECULES, EI-PROCESSES
C
        DO 35 IMOL=1,NMOLI
        DO 35 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 35 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            ENDIF
35      CONTINUE
C
        DO 47 IMOL=1,NMOLI
        DO 47 IPLS=1,NPLSI
        DO 47 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 47
          DO 48 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
48        CONTINUE
47      CONTINUE
C
        DO 49 IMOL=1,NMOLI
        DO 49 IPLS=1,NPLSI
        DO 49 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 50 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
50        CONTINUE
49      CONTINUE
C
C
C
        DO 60 ISTRA=1,NSTRAI
          IF (ISTRA.EQ.IESTR) THEN
C  NOTHING TO BE DONE
          ELSEIF ((NFILEN.EQ.1.OR.NFILEN.EQ.2).AND.ISTRA.NE.IESTR) THEN
            IESTR=ISTRA
            CALL RSTRT(ISTRA,NSTRAI,NESTM1,NESTM2,NADSPC,
     .                 ESTIMV,ESTIMS,ESTIML,
     .                 NSDVI1,SDVI1,NSDVI2,SDVI2,
     .                 NSDVC1,SIGMAC,NSDVC2,SGMCS,
     .                 NSBGK,SIGMA_BGK,NBGV_STAT,SGMS_BGK,
     .                 NSCOP,SIGMA_COP,NCPV_STAT,SGMS_COP,TRCFLE)
            IF (NLSYMP(ISTRA).OR.NLSYMT(ISTRA)) THEN
              CALL SYMET(ESTIMV,NTALV,NRTAL,NR1TAL,NP2TAL,NT3TAL,
     .                   NADDV,NFIRST,NLSYMP(ISTRA),NLSYMT(ISTRA))
            ENDIF
          ELSE
            WRITE (iunout,*) 'ERROR IN EIRSRT: STRATUM ISTRA= ',ISTRA
            WRITE (iunout,*) 'IS NOT AVAILABLE. EXIT CALLED'
            CALL EXIT_OWN(1)
          ENDIF
C
C  SAVE EIRENE TALLIES, SCALE PER UNIT FLUX (AMP), ON COMMON BRASCL
C  WTOTP IS NEGATIVE IN EIRENE (SINK FOR IONS)
C  ALL STRATA WHICH ARE NOT SPECIFIED BY INPUT BLOCK 14 (FROM
C  PLASMA CODE DATA) ARE NOT RESCALED HERE
C
          IF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).NE.0.) THEN
            FLXI=-1./WTOTP(0,ISTRA)
          ELSEIF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).EQ.0.) THEN
            GOTO 60
          ELSEIF (ISTRA.GT.NTARGI) THEN
            FLXI=1.
          ENDIF

          NULLIFY(PAPLS(ISTRA)%PMUL)
          NULLIFY(PMPLS(ISTRA)%PMUL)
          NULLIFY(PIPLS(ISTRA)%PMUL)

          NULLIFY(EAELS(ISTRA)%PSIM)
          NULLIFY(EMELS(ISTRA)%PSIM)
          NULLIFY(EIELS(ISTRA)%PSIM)
          NULLIFY(EAPLS(ISTRA)%PSIM)
          NULLIFY(EMPLS(ISTRA)%PSIM)
          NULLIFY(EIPLS(ISTRA)%PSIM)

          NULLIFY(PDENAS(ISTRA)%PMUL)
          NULLIFY(PDENMS(ISTRA)%PMUL)
          NULLIFY(PDENIS(ISTRA)%PMUL)
          NULLIFY(EDENAS(ISTRA)%PMUL)

          NULLIFY(COPVS(ISTRA)%PMUL)

          NULLIFY(MAPLS(ISTRA)%PMUL)
          NULLIFY(MMPLS(ISTRA)%PMUL)
          NULLIFY(MIPLS(ISTRA)%PMUL)
          NULLIFY(MPHPLS(ISTRA)%PMUL)

          DO IPLS=1,NPLSI
!pb         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PAPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PAPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PAPLS(ISTRA)%PMUL
                PAPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PMPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PMPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PMPLS(ISTRA)%PMUL
                PMPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PIPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PIPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PIPLS(ISTRA)%PMUL
                PIPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (MAPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = MAPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => MAPLS(ISTRA)%PMUL
                MAPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (MMPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = MMPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => MMPLS(ISTRA)%PMUL
                MMPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (MIPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = MIPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => MIPLS(ISTRA)%PMUL
                MIPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (MPHPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = MPHPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => MPHPLS(ISTRA)%PMUL
                MPHPLS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
!PB       DO IN=1,NDXY
          DO IN=1,NSBOX_TAL
            IF (EAEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAEL(IN)*FLXI
              CPSIM%NXTSIM => EAELS(ISTRA)%PSIM
              EAELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMEL(IN)*FLXI
              CPSIM%NXTSIM => EMELS(ISTRA)%PSIM
              EMELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIEL(IN)*FLXI
              CPSIM%NXTSIM => EIELS(ISTRA)%PSIM
              EIELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EAPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAPL(IN)*FLXI
              CPSIM%NXTSIM => EAPLS(ISTRA)%PSIM
              EAPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMPL(IN)*FLXI
              CPSIM%NXTSIM => EMPLS(ISTRA)%PSIM
              EMPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIPL(IN)*FLXI
              CPSIM%NXTSIM => EIPLS(ISTRA)%PSIM
              EIPLS(ISTRA)%PSIM => CPSIM
            ENDIF
          ENDDO
          DO IATM=1,NATMI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => PDENAS(ISTRA)%PMUL
                PDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (EDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = EDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => EDENAS(ISTRA)%PMUL
                EDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IMOL=1,NMOLI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENM(IMOL,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IMOL
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENM(IMOL,IN)*FLXI
                CPMUL%NXTMUL => PDENMS(ISTRA)%PMUL
                PDENMS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IION=1,NIONI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (PDENI(IION,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IION
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENI(IION,IN)*FLXI
                CPMUL%NXTMUL => PDENIS(ISTRA)%PMUL
                PDENIS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO ICPV=1,NCPVI
!PB         DO IN=1,NDXY
            DO IN=1,NSBOX_TAL
              IF (COPV(ICPV,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = ICPV
                CPMUL%ICM = IN
                CPMUL%VALUEM = COPV(ICPV,IN)*FLXI
                CPMUL%NXTMUL => COPVS(ISTRA)%PMUL
                COPVS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
C
C
60      CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI,0)
C
        IFIRST=IFIRST+1
        RETURN
C
10000   CONTINUE
C
        NCUTB_SAVE=NCUTB
        CALL INTER1
C
        CALL PLASMA
C
        CALL PLASMA_DERIV(0)
C
        CALL SETAMD
C
!pb        IF (.NOT.ALLOCATED(SPLNWA)) CALL ALLOC_BRASCL
        CALL ALLOC_BRASCL
        CALL INIT_BRASCL2
C
C  NEW: ATOMS, EI PROCESSES
C
        DO 101 IATM=1,NATMI
        DO 101 IPLS=1,NPLSI
          DO 102 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 101
            DO 102 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
              ELSE
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
              END IF
102       CONTINUE
101     CONTINUE
C
        DO 103 IPLS=1,NPLSI
          IPLSTI= MPLSTI(IPLS)
          DO 104 IN=1,NDXY
            SEINWA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLSTI,IN)+EDRIFT(IPLS,IN))
104       CONTINUE
103     CONTINUE
C
        DO 105 IATM=1,NATMI
          DO 105 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            DO 105 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
105     CONTINUE
C
C  NEW: TEST IONS, EI PROCESSES
C
        DO 106 IION=1,NIONI
          DO 106 IIDS=1,NIDSI(IION)
            IRDS=LGIEI(IION,IIDS)
            DO 106 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWI(IN,IION)=SEENWI(IN,IION)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWI(IN,IION)=SEENWI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
106     CONTINUE
C
        DO 107 IION=1,NIONI
        DO 107 IPLS=1,NPLSI
        DO 107 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 107
          DO 108 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
108       CONTINUE
107     CONTINUE
C
        DO 109 IION=1,NIONI
        DO 109 IPLS=1,NPLSI
        DO 109 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 110 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWI(IN,IION)=SEINWI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWI(IN,IION)=SEINWI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
110       CONTINUE
109     CONTINUE
C
C  NEW: MOLECULES, EI PROCESSES
C
        DO 115 IMOL=1,NMOLI
        DO 115 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 116 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
116       CONTINUE
115     CONTINUE
C
        DO 117 IMOL=1,NMOLI
        DO 117 IPLS=1,NPLSI
        DO 117 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 117
          DO 118 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
118       CONTINUE
117     CONTINUE
C
        DO 119 IMOL=1,NMOLI
        DO 119 IPLS=1,NPLSI
        DO 119 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 120 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
120       CONTINUE
119     CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI,0)
C
        IFIRST=IFIRST+1

        IF (LSTOP) THEN
          CALL DEALLOC_COMUSR
          CALL DEALLOC_CESTIM
          CALL DEALLOC_BRASCL
          CALL DEALLOC_BRASPOI
        END IF

        RETURN
C
      ENDIF

      END
C ===== SOURCE: if0prm.f


      SUBROUTINE IF0PRM(IUNIN)

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CINIT

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: IUNIN
      INTEGER :: NFLA, NCUTB, NCUTL, NDXA, NDYA, IPL, NTARGI, IT, IPRT,
     .           NAINB, IAIN, NAOTB, IAOT, NECKEN, NTRIAN, NRKNOT,
     .           NTRII, NCOPI
      INTEGER, ALLOCATABLE :: NTGPRT(:)
      CHARACTER(72) :: ZEILE

      READ (IUNIN,*)
      READ (IUNIN,'(3I6)') NFLA,NCUTB,NCUTL
      DO IPL=1,NPLS
        READ (IUNIN,*)
      END DO
      READ (IUNIN,'(2I6)') NDXA,NDYA
C  NUMBER OF TARGET SOURCES ON B2 SURFACES: NTARGI
      READ (IUNIN,'(I6)') NTARGI
C  NUMBER OF PARTS PER TARGET SOURCE
      IF (NTARGI.GT.0) THEN
        ALLOCATE (NTGPRT(NTARGI))
        READ (IUNIN,'(12I6)') (NTGPRT(IT),IT=1,NTARGI)
        NPTRGT=SUM(NTGPRT)
        DO IT=1,NTARGI
          DO IPRT=1,NTGPRT(IT)
 331        READ (IUNIN,'(A72)') ZEILE
            IF (ZEILE(1:1).EQ.'*') THEN
              GOTO 331
            ENDIF
          END DO
        END DO
        DEALLOCATE (NTGPRT)
      END IF
      READ (IUNIN,*)
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM B2 INTO EIRENE
C  HERE: B2 VOLUME TALLIES
      READ (IUNIN,'(I6)') NAINB
      NAIN = MAX(NAIN,NAINB)
      DO IAIN=1,NAINB
        READ (IUNIN,*)
        READ (IUNIN,*)
        READ (IUNIN,*)
      END DO
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM EIRENE INTO B2
C  HERE: EIRENE SURFACE TALLIES
      READ (IUNIN,'(I6)') NAOTB
      DO IAOT=1,NAOTB
        READ (IUNIN,*)
      END DO
C
C READING BLOCK 14 FROM FORMATTED INPUT FILE (IUNIN) FINISHED
C
C
C  DEFINE ADDITIONAL TALLIES FOR COUPLING (UPDATED IN SUBR. UPTCOP
C                                              AND IN SUBR. COLLIDE)
!pb      NCOPI=4
      NCOPI=1
      NCPVI=NCOPI*NPLS
      NCOP = NCOPI
      NCPV = NCPVI
C
C SAVE SOME MORE INPUT DATA FOR SHORT CYCLE ON COMMON CCOUPL
      NDX = NDXA
      NDY = NDYA
      NFL = NFLA
      NDXP = NDX+1
      NDYP = NDY+1

      RETURN
      END
C ===== SOURCE: indmap.f
C
C
      SUBROUTINE INDMAP(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG)
C
C     INDEX MAPPING FOR BRAAMS DATA FIELDS. DATA IN DUMMY ZONES
C     (CUTS OR BOUNDARY ZONES) MAY BE NEEDED AND THUS ARE KEPT
C     AND DUBLICATED IN CASE NCUTL GT NCUTB
C
C     NCUTB= NUMBER OF CELLS IN IX DIRECTION PER CUT IN BRAAMS
C     NCUTL= NUMBER OF CELLS IN IX DIRECTION PER CUT IN LINDA (AND
C            THUS ALSO IN EIRENE) GEOMETRY

      USE PRECISION
      USE COMPRT, ONLY: IUNOUT
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: NPOINT(2,*)
      INTEGER, INTENT(IN) :: NDX, NDY, NFL, NDXA, NDYA, NFLA, NCUTB,
     .                       NCUTL, NPPLG
      REAL(DP), INTENT(INOUT) :: FIELD(0:NDX+1,0:NDY+1,NFL),
     .                         DUMMY(0:NDX+1,0:NDY+1)
      INTEGER :: IX, IPART, IY, IF, IENDD, INB, IINID, IINIV, IENDV
C
C  LOOP FOR THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=FIELD(IX,IY,IF)
C
C
C      NDX DIRECTION: IX=0: NOT MODIFIED
C                     IX=I(CUT): USE CUT VALUE
C                     IX=I(LAST X ZONE): MOVE TO NDXA+1
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(IX,IY)=FIELD(INB,IY,IF)
213         CONTINUE
            DUMMY(IINID,IY) = FIELD(INB+1,IY,IF)
            IF (IENDD.NE.IINID) DUMMY(IENDD,IY) = FIELD(INB+NCUTB,IY,IF)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (iunout,*) 'ERROR IN SUBR. INDMAP: THIS SUBR. IS VALID ONLY'
      WRITE (iunout,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT_OWN(1)
991   WRITE (iunout,*) 
     ,  'ERROR IN SUBR. INDMAP: INCONSISTENCY IN NUMBER OF '
      WRITE (iunout,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED.  '
      WRITE (iunout,*) 'NCUTL = ',NCUTL, 
     .                 ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: indmpi.f
C
C
      SUBROUTINE INDMPI(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG,NSTR,ISTR)
C
C     INDEX MAPPING: INVERS TO SUBR. INDMAP
C
      USE PRECISION
      USE COMPRT, ONLY: IUNOUT
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: NPOINT(2,*)
      INTEGER, INTENT(IN) :: NDX, NDY, NFL, NDXA, NDYA, NFLA, NCUTB,
     .                       NCUTL, NPPLG, NSTR, ISTR
      REAL(DP), INTENT(INOUT) :: FIELD(0:NDX+1,0:NDY+1,NFL,NSTR),
     .                         DUMMY(0:NDX+1,0:NDY+1)
      INTEGER :: IX, IY, IF, IENDD, IPART, INB, IINID, IINIV, IENDV
C
C  LOOP OVER THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=0.
C
C
C      NDX DIRECTION
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(INB,IY)=FIELD(IX,IY,IF,ISTR)
213         CONTINUE
            DUMMY(INB+1,IY)=FIELD(IINID,IY,IF,ISTR)
            IF (IENDD.NE.IINID)
     .          DUMMY(INB+NCUTB,IY)=FIELD(IENDD,IY,IF,ISTR)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF,ISTR)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (iunout,*) 'ERROR IN SUBR. INDMPI: THIS SUBR. IS VALID ONLY'
      WRITE (iunout,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT_OWN(1)
991   WRITE (iunout,*) 
     .  'ERROR IN SUBR. INDMPI: INCONSISTENCY IN NUMBER OF'
      WRITE (iunout,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED. '
      WRITE (iunout,*) 'NCUTL = ',NCUTL, 
     .                 ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: infcop.f
C
C   EIRENE CODE SEGMENT COUPLE_$, $ MAY CURRENTLY STAND FOR B2,
C                                                           B2.5,
C                                                           DIVIMP,
C                                                           TRIA,
C                                                           TETRA,
C                                                           TRANSP,
C                                                           DUMMY
C
C   THIS VERSION: $=B2,  NOV. 2000
C
C   UPDATES:
C   OPTION TO EVALUATE B-FIELD VECTORS FROM GRIDADAP FILE FT29
C   FOR NON-ORTHOGONAL GRIDS
C
C   THIS CODE SEGMENT CONTAINES VARIOUS SUBROUTINES NEEDED FOR
C   INTERFACING THE EIRENE CODE TO PLASMA FLUID CODES.
C   IT READS GEOMETRICAL DATA (MESHES) FROM FILE FT30
C   AND PRODUCES THE EIRENE INPUT DATA (BLOCK 2).
C   IT READS PLASMA BACKGROUND DATA FROM FILE FT31 OR COMMON BLOCKS,
C   IT MAY (OPTIONAL) ALSO READ PLASMA DATA FROM FILE FT13
C   WRITTEN IN A PREVIOUS EIRENE RUN (E.G. IN ORDER TO ITERATE
C   IN SOME BACKGROUND SPECIES)
C   IT THEN PRODUCES INPUT DATA FOR EIRENE
C   INPUT BLOCK 5 (PLASMA DATA) AND BLOCK 7 (SURFACE RECYCLING SOURCES)
C
C
C   THIS PARTICULAR VERSION LINKS EIRENE TO THE B2   2D MULTIFLUID EDGE
C   PLASMA TRANSPORT CODE.
C
C   IT WAS WRITTEN BY D.REITER AND P.BOERNER, KFA-JUELICH
C   E-MAIL: D.REITER @ EIRENE.DE
C
C
C
C   MOST OF THE FORTRAN IN THIS CODE SEGMENT HAS BEEN DEVELOPED
C   UNDER KFA-NET CONTRACT NO. 428/90-8/FU-D
C
C   FINAL REPORT BY: D.REITER(1), P.BOERNER(1), B.KUEPPERS(1),
C                    M.BAELMANS(2) AND G.P.MADDISON(3)
C                    (1992)
C   1): KFA-JUELICH GMBH
C   2): UNIV. LEUVEN, ERM, KFA-JUELICH
C   3): AEA TECHNOLOGY, FUSION, CULHAM, UKAEA FUSION ASSOCIATION
C
*DK COUPLE
C
      SUBROUTINE INFCOP
C
C     THIS SUBROUTINE DEFINES THE PLASMA MODEL IN CASE OF A COUPLED
C     NEUTRAL-PLASMA CALCULATION
C
C     THE ENTRY "IF0COP" RECEIVES GEOMETRICAL INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF1COP" RECEIVES PLASMA INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF2COP" PREPARES THE SOURCE SAMPLING DISTRIBUTION
C     FROM THE EXTERNAL DATA, AND MAY OVERWRITE OTHER INPUT
C     DATA FROM BLOCKS 1 TO 13 AS WELL
C
C     THE ENTRIES "IF3COP, IF4COP" RETURN  RESULTS TO AN EXTERNAL CODE
C
!PB   17.11.05  NEMODS=-2  =>  NEMODS=8
!PB             NEMODS=-3  =>  NEMODS=9
      USE PRECISION
      USE PARMMOD
      USE BRASPOI
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CPLOT
      USE CINIT
      USE CPOLYG
      USE CGRID
      USE CZT1
      USE CTRCEI
      USE CCOUPL
      USE CGEOM
      USE CSDVI
      USE CSDVI_BGK
      USE CSDVI_COP
      USE COMPRT
      USE COMNNL
      USE COMSOU
      USE CSTEP
      USE CTEXT
      USE CLGIN
      USE COUTAU
      USE COMXS
      USE CSPEI
      USE CTRIG
      USE BRAEIR
      USE EIRBRA
      USE BRASCL

      IMPLICIT NONE
C
C  GEOMETRICAL DATA FROM GRIDADAP
      REAL(DP), ALLOCATABLE ::
     R  ALPHXB(:,:), ALPHYB(:,:), XAISO(:,:)

      REAL(DP), ALLOCATABLE, SAVE ::
     R  PUX(:),      PUY(:),      PVX(:),      PVY(:)

      INTEGER, ALLOCATABLE ::
     I  IAISO(:,:)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
      REAL(DP) :: SEES0(NSTRA), SEIS0(NSTRA)
      REAL(DP) :: CHPM(NPLS,NRAD), CHEEM(NRAD), CHEIM(NRAD),
     .            CHMOM(NPLS,NRAD)
      REAL(DP) :: DI(NPLS), VP(NPLS)


      REAL(DP) :: PPPL_COP(NPLS,NRAD), CPPV(NCPV,NRAD),
     .            EPPL_COP(NRAD), EPEL(NRAD)
C
      REAL(DP) :: PUXE(NRAD), PUYE(NRAD), PUXN(NRAD), PUYN(NRAD),
     R            TORL(NSTRA,NGITT), EFLX(NSTRA),
     R            DUMMY(0:NDXP,0:NDYP),
     R            ESHT(NSTEP,NGITT), ORI(NSTEP,NGITT),
     R            SFNIT(0:NSTEP), SFEIT(0:NSTEP),
     R            SFEET(0:NSTEP), SHEAE(0:NSTEP), SHEAI(0:NSTEP)

      REAL(DP), SAVE :: SCALM, SCALE, SCALI, CHEIS, SEES, SEIS, TEST,
     .          SFEISY, SFEESY, RECADD,
     .          EEADD, PIADD, SIGNUM, SMOCL, CHEES, EIADD, SNICL,
     .          SSE, BALANI, BALANE, SSEE, SSN, SSI, BALANN, RE, RI,
     .          RN, TOTI, TOTE, TOTN, SFEENY, SFNINY, SFEIWX,
     .          SFNIEX, SSNI, SSEI, SFNIWX, SFEIEX, SFEEEX, VVBC,
     .          UUBC, UPBC, RBC, UDBC, VL, V, T, BX, BY, BZ, BN,
     .          DELTE_PARA, DELTI_PARA, DELY, DELTI_PERP, TES, TIS,
     .          DELTE_PERP, ALX, ALE, ALW, ALS, ALN, AL, ETOT,
     .          RESSEE, FLX, ESUM, DR, VR, VTEST, EADD, SI,
     .          PARWI, PERWI, SUMM, SUMN, SUMEI, SUMEE, FLXI, CHP,
     .          CNDYNP, CHI, CHE, CS, THMAX, EESHT, EEMAX,
     .          RP1, DELX, PNORM, PVYS, PVXS, PUPV, RRBS, PUYS, PUXS,
     .          VPX, VPY, VT, PARW, PERW, PN1, OR, VPZ, GAMMA, CUR, TE,
     .          SFNISY, SFEEWX, SFEINY, PM1, RESSEI, DRR

      INTEGER :: NRWL(NSTRA)
      INTEGER, SAVE :: J, IRC, JC, INC, IADD, IP, ITARG, IO, IFL, NPES,
     .           IIPLS, IG, IGITT, IEPLS, NPEC, NPBC, NPBS, NTGPRI,
     .           IT, I, IPRT, IAOT, IAIN, IREAD, IPL, INN,
     .           IMODE, IERROR, LTARG, IN, IX, IY,
     .           NCOPI, NPLP, NDX2, NRED, IO29, NDXY, IFIRST,
     .           ISTRAI, IRRC, K, IR, IIRC, ICPV, IF, I34,
     .           NREC11, NEM, IPLSTI, IPLSV, IPLV, ISP
      INTEGER, INTENT(IN) :: ISTRAA, ISTRAE, NEW_ITER, IFRST, ITRG
      REAL(DP) :: STEP, FTABRC1, FEELRC1, SHEATH, EMAXW
      INTEGER, EXTERNAL :: IDEZ
C
      LOGICAL, INTENT(INOUT) :: LSTP
      LOGICAL :: LSHORT, LSTOP

      REAL(DP), ALLOCATABLE, SAVE ::
     . CHPS(:),    SNIS(:),    CHMOS(:),  SMOS(:),  SCALN(:),
     . SNIS0(:,:), SMOS0(:,:),
     . RESSNI(:),  RESSMO(:)

      INTEGER, ALLOCATABLE :: IHELP(:)
C
      CHARACTER(10) :: CHR
      CHARACTER(6)  :: CITARG
      CHARACTER(72) :: ZEILE
C
      DATA LTARG/0/
C
C
!      SAVE
C
      ENTRY IF0COP
C
      LSHORT=.FALSE.
C
      GOTO 99990
C
C  TO INITIALIZE THE SHORT CYCLING, THE GEOMETRY HAS TO BE
C  DEFINED ONCE (ENTRY: INTER0)
C
      ENTRY INTER0
      LSHORT=.TRUE.
99990 CONTINUE
C
      IERROR=0
C
      IMODE=IABS(NMODE)
C
      IF (.NOT.LSHORT.AND.ITIMV.LE.1) THEN
        WRITE (iunout,*) '        SUBROUTINE INFCOP IS CALLED  '
C  READ INPUT DATA OF BLOCK 14
C  SAVE INPUT DATA OF BLOCK 14 FOR SHORT CYCLE ON COMMON CCOUPL
        CALL LEER(1)
        CALL ALLOC_CCOUPL(1)
        READ (IUNIN,'(5L1)') LSYMET,LBALAN
        IF (TRCINT)
     .  WRITE (iunout,*) ' LSYMET,LBALAN = ',LSYMET,LBALAN
        READ (IUNIN,'(3I6)') NFLA,NCUTB,NCUTL
        NCUTB_SAVE=NCUTB
        IF (TRCINT) THEN
          WRITE (iunout,*) ' NFLA,NCUTB,NCUTL = ',NFLA,NCUTB,NCUTL
          WRITE (iunout,*) ' IPLS,IFLB(IPLS),FCTE(IPLS),BMASS(IPLS)'
        ENDIF
        DO 20 IPL=1,NPLSI
          READ (IUNIN,'(2I6,2E12.4)') I,IFLB(IPL),FCTE(IPL),BMASS(IPL)
          IF (TRCINT)
     .    WRITE (iunout,*) IPL,IFLB(IPL),FCTE(IPL),BMASS(IPL)
20      CONTINUE
        READ (IUNIN,'(2I6)') NDXA,NDYA
        IF (TRCINT) WRITE (iunout,*) 'NDXA,NDYA ',NDXA,NDYA
C  NUMBER OF TARGET SOURCES ON B2 SURFACES: NTARGI
        READ (IUNIN,'(I6)') NTARGI
        WRITE (iunout,*) '        NTARGI= ',NTARGI
        CALL LEER(1)
        IF (NTARGI.GT.NSTEP) THEN
          CALL MASPRM ('NSTEP',5,NSTEP,'NTARGI',6,NTARGI,IERROR)
          WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT_OWN(1)
        ENDIF
C  NUMBER OF PARTS PER TARGET SOURCE
        IF (NTARGI.GT.0) READ (IUNIN,'(12I6)') (NTGPRT(IT),IT=1,NTARGI)
        DO 22 IT=1,NTARGI
          IF (NTGPRT(IT).GT.NGITT) THEN
            NTGPRI=NTGPRT(IT)
            CALL MASPRM ('NGITT',5,NGITT,'NTGPRT',6,NTGPRI,IERROR)
            WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
            CALL EXIT_OWN(1)
          ENDIF
22      CONTINUE
C  ALL INDICES: AFTER INDEX MAPPING
C  NDT: INDEX OF X-CELL (EAST OR NORTH SURFACE OF BRAAMS CELL) OF TARGET
C  NINCT: DIRECTION OF OUTER TARGET NORMAL WITH RESPECT TO POSITIVE DIR.
C  NIXY: SOURCE ON Y SURFACE: NIXY=1; SOURCE ON X SURFACE: NIXY=2
C  NTIN,NTEN: SOURCE RANGE FROM GRIDPOINT NTIN TO GRIDPOINT NTEN
        IF (TRCINT)
     .  WRITE (iunout,*) '    IT,  NDT,NINCT, NIXY, NTIN, NTEN',
     .              ',NIFLG, NPTC,NSPZI,NSPZE,NEMOD'
        DO 30 IT=1,NTARGI
          DO 33 IPRT=1,NTGPRT(IT)
331         READ (IUNIN,'(A72)') ZEILE
            IREAD=1
            IF (ZEILE(1:1).EQ.'*') THEN
C             WRITE (iunout,......)
              GOTO 331
            ENDIF
            READ (ZEILE,'(12I6)') I,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                              NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                              NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                              NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                              NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IREAD=0
            NSPZI(IT,IPRT)=MAX0(1,NSPZI(IT,IPRT))
            NSPZE(IT,IPRT)=MIN0(NFLA,NSPZE(IT,IPRT))
            IF (NSPZE(IT,IPRT).LT.NSPZI(IT,IPRT)) THEN
              WRITE (iunout,*) 'WARNING FROM INFCOP: '
              WRITE (iunout,*) 'ITARG,IPRT : ',IT,IPRT
              WRITE (iunout,*) 'NSPZI,NSPZE MODIFIED TO 1,NFLA, RESP.'
              NSPZI(IT,IPRT)=1
              NSPZE(IT,IPRT)=NFLA
            ENDIF
            IF (TRCINT)
     .      WRITE (iunout,'(1X,12I6)') IT,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                               NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                               NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                               NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                               NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IF (NIXY(IT,IPRT).EQ.1) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NR1ST.OR.
     .            NTEN(IT,IPRT).GT.NR1ST) THEN
                WRITE (iunout,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT_OWN(1)
              ENDIF
            ELSEIF (NIXY(IT,IPRT).EQ.2) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NP2ND.OR.
     .            NTEN(IT,IPRT).GT.NP2ND) THEN
                WRITE (iunout,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT_OWN(1)
              ENDIF
            ENDIF
33        CONTINUE
          IF (TRCINT) CALL LEER(1)
30      CONTINUE
        READ (IUNIN,'(6E12.4)')  CHGP,CHGEE,CHGEI,CHGMOM
        IF (TRCINT) WRITE (iunout,*) 'CHGP,CHGEE,CHGEI,CHGMOM ',
     .                           CHGP,CHGEE,CHGEI,CHGMOM
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM B2 INTO EIRENE
C  HERE: B2 VOLUME TALLIES
        READ (IUNIN,'(I6)') NAINB
        NAIN = MAX(NAIN,NAINB)
        CALL ALLOC_CCOUPL(2)
        WRITE (iunout,*) '        NAINI = ',NAINB
        IF (TRCINT.AND.NAINB.GT.0)
     .      WRITE (iunout,*) 'I,NAINS(IAIN),NAINT(IAIN)'
        DO 40 IAIN=1,NAINB
          READ (IUNIN,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
          READ (IUNIN,'(A72)') TXTPLS(IAIN,12)
          READ (IUNIN,'(2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          IF (TRCINT) THEN
            WRITE (iunout,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
            WRITE (iunout,'(1X,A72)') TXTPLS(IAIN,12)
            WRITE (iunout,'(1X,2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          ENDIF
40      CONTINUE
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM EIRENE INTO B2
C  HERE: EIRENE SURFACE TALLIES
        READ (IUNIN,'(I6)') NAOTB
        WRITE (iunout,*) '        NAOTI = ',NAOTB
        IF (NAOTB.GT.NLIMPS) THEN
          CALL MASPRM ('NLIMPS',6,NLIMPS,'NAOTB',5,NAOTB,IERROR)
          WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT_OWN(1)
        ENDIF
        IF (TRCINT.AND.NAOTB.GT.0)
     .      WRITE (iunout,*) 'I,NAOTS(IAOT),NAOTT(IAOT)'
        DO 50 IAOT=1,NAOTB
          READ (IUNIN,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          IF (TRCINT) THEN
            WRITE (iunout,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          ENDIF
50      CONTINUE
      ENDIF
C
C READING BLOCK 14 FROM FORMATTED INPUT FILE (IUNIN) FINISHED
C
C
C  DEFINE ADDITIONAL TALLIES FOR COUPLING (UPDATED IN SUBR. UPTCOP
C                                              AND IN SUBR. COLLIDE)
      NCOPI=0
!pb      IF (NMODE.GT.0) NCOPI=4
      IF (NMODE.GT.0) NCOPI=1
      NCPVI=NCOPI*NPLSI
      NCOP = NCOPI
C
C SAVE SOME MORE INPUT DATA FOR SHORT CYCLE ON COMMON CCOUPL
      NDX = NDXA
      NDY = NDYA
      NFL = NFLA
      NDXP = NDX+1
      NDYP = NDY+1
      LNLPLG=NLPLG
      LNLDRF=NLDRFT
      LTRCFL=TRCFLE
      NSTRI=NSTRAI
      DO 60 ISTRA=1,NSTRAI
        LNLVOL(ISTRA)=NLVOL(ISTRA)
60    CONTINUE
      NMODEI=NMODE
      NFILNN=NFILEN
C
      IF (NCPVI.EQ.0) GOTO 70
      DO IPLS=1,NPLSI
        ICPVE(IPLS)=1
        ICPRC(IPLS)=1
        TXTTAL(IPLS,NTALM)=
     .  'ENERGY WEIGHTED CX RATE OF ATOMS WITH IPLS                  '
        TXTSPC(IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(IPLS,NTALM)='AMP                       '
C
!pb     ICPVE(NPLSI+IPLS)=3
!pb     ICPRC(NPLSI+IPLS)=1
!pb     TXTTAL(NPLSI+IPLS,NTALM)=
!pb  .  'PAR. MOM. SOURCE, FROM ATOMS, FOR IPLS             '
!pb     TXTSPC(NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
!pb     TXTUNT(NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
!pb     ICPVE(2*NPLSI+IPLS)=3
!pb     ICPRC(2*NPLSI+IPLS)=2
!pb     TXTTAL(2*NPLSI+IPLS,NTALM)=
!pb  .  'PAR. MOM. SOURCE, FROM MOLECULES, FOR IPLS         '
!pb     TXTSPC(2*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
!pb     TXTUNT(2*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
!pb     ICPVE(3*NPLSI+IPLS)=3
!pb     ICPRC(3*NPLSI+IPLS)=3
!pb     TXTTAL(3*NPLSI+IPLS,NTALM)=
!pb  .  'PAR. MOM. SOURCE, FROM TEST IONS, FOR IPLS         '
!pb     TXTSPC(3*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
!pb     TXTUNT(3*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
      ENDDO
C
70    CONTINUE
C
C
C  TRANSFER GEOMETRY
C
      IF (.NOT.(INDGRD(1).EQ.6.OR.INDGRD(2).EQ.6.OR.INDGRD(3).EQ.6))
     .RETURN
C
      OPEN (UNIT=29,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 29
C
      OPEN (UNIT=30,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 30
C
C  READ IN DATA TO SET UP GEOMETRY FOR NEUTRAL GAS TRANSPORT CODE
C  STATEMENT NUMBER 1000 ---> 1999
C
C  AT PRESENT THE DATA COME FROM THE FILE FT30
C  THIS PART WILL HAVE TO BE MODIFIED AS SOON AS BRAAMS PROVIDES
C  CELL VERTICES AND CUT DESCRIPTION
C
1000  CONTINUE
C
C  ACTUAL MESH SIZE USED IN THIS RUN: FIRST CARD OF GEOMETRY DATA FILE
C
C
      IF (NDYA.NE.NR1ST-1.OR.NDYA.GT.NDY) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (iunout,*) ' NDYA MUST BE = NR1ST-1 AND <= NDY'
        WRITE (iunout,*) ' NDYA,NR1ST-1,NDY = ',NDYA,NR1ST-1,NDY
        CALL EXIT_OWN(1)
      ELSEIF (NDXA.NE.NP2ND-1.OR.NDXA.GT.NDX) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (iunout,*) ' NDXA MUST BE = NP2ND-1 AND <= NDX'
        WRITE (iunout,*) ' NDXA,NP2ND-1,NDX = ',NDXA,NP2ND-1,NDX
        CALL EXIT_OWN(1)
      ENDIF
C
C  EACH FLUXSURFACE IS GIVEN BY A POLYGON OF LENGTH NDXA+1, I.E.
C  WITH NDXA SEGMENTS. THERE ARE NDYA+1 POLYGONS
C  READ IN POLYGONS CELL BY CELL. IX IS INDEX ALONG ONE POLYGON
C                                 IY IS INDEX PERP. TO THE POLYGONS
C
C
C         DIRECTION  OF INCREASING IY ("RADIAL")
C PERP.      ^                 ^ PERP.
C POLYG.NO.IX|      (VV,SY,    | POLYG.NO.IX+1
C            |       FNIY)     |
C            |       ^         |
C            |       |         |
C         X3,Y3      |        X4,Y4
C            ________X__________   -----> ALONG POLYGON NO. (IY+1)
C            |  CELL NO.(IX,IY)|
C            |                 |
C            |       X         X-----> (UU,UP,FNIX,SX)
C            |                 |
C            | (TE,TI,NI,PR,RR,|
C            |  VOL,GX,GY)     |
C            -------------------   -----> ALONG POLYGON NO. (IY)
C         X1,Y1               X2,Y2
C                                         DIRECTION OF INCREASING IX ("POLOIDAL"
C
C
      NPOINT = 0
      IF (.NOT.ALLOCATED(PUX)) THEN
        ALLOCATE (PUX(NRAD))
        ALLOCATE (PUY(NRAD))
        ALLOCATE (PVX(NRAD))
        ALLOCATE (PVY(NRAD))
      ENDIF
C
      CALL GEOMD (NDXA,NDYA,NPLP,NR1ST,
     .            PUX,PUY,PVX,PVY)
C
      IF (NDXA+1.NE.NRPLG) THEN
        WRITE (iunout,*) 'ERROR IN INFCOP: NRPLG.NE.NDXA+1'
        WRITE (iunout,*) 'NDXA+1,NRPLG ',NDXA+1,NRPLG
        CALL EXIT_OWN(1)
      ENDIF
      IF (NPLP.NE.NPPLG) THEN
        WRITE (iunout,*) 'ERROR IN INFCOP: NPPLG.NE.NPLP'
        WRITE (iunout,*) 'NPLP,NPPLG ',NPLP,NPPLG
        CALL EXIT_OWN(1)
      ENDIF
C
C  READ ADDITIONAL GEOMETRICAL DATA (MESH DISTORTION, DEAD CELLS)
C  SAME FORMAT AS FORT.31, I.E., INDEX MAPPING MAY BE NECESSARY
      READ (29,'(A)',IOSTAT=IO29) CHR
      IF (IO29.EQ.0) THEN
        REWIND 29
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED

        ALLOCATE (ALPHXB(0:NDXP,0:NDYP))
        ALLOCATE (ALPHYB(0:NDXP,0:NDYP))
        ALLOCATE (XAISO(0:NDXP,0:NDYP))
        ALLOCATE (IAISO(0:NDXP,0:NDYP))

        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHXB)
        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHYB)
        DO IY=NDYA+1,0,-1
          READ (29,'(500I1)') (IAISO(IX,IY),IX=0,NDX2+1)
        ENDDO
C
        IF (NCUTL.EQ.NCUTB) GOTO 1020
C
C CONVERT IAISO TO REAL, FOR INDMAP
        XAISO=IAISO
        CALL INDMAP (XAISO,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
C IAISO BACK TO INTEGER
        IAISO=XAISO
C
        CALL INDMAP (ALPHXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
        CALL INDMAP (ALPHYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
1020    CONTINUE
C
        DO IY=1,NDYA
          DO IX =1,NDXA
            IN=IY+(IX-1)*NR1ST
            ALE=ALPHXB(IX,IY)
            ALW=ALPHXB(IX-1,IY)
            IF (MAX(ALE,ALW)-MIN(ALE,ALW) > PIA) THEN
              AL=MIN(ALE,ALW)
              ALW=MAX(ALE,ALW)
              ALE=AL+PI2A
            END IF
            ALN=ALPHYB(IX,IY)
            ALS=ALPHYB(IX,IY-1)
            ALX=0.25D0*(ALE+ALW+ALN+ALS)
            PUXE(IN)=COS(ALE)
            PUYE(IN)=SIN(ALE)
            PUXN(IN)=COS(ALN)
            PUYN(IN)=SIN(ALN)
            PUX(IN)=COS(ALX)
            PUY(IN)=SIN(ALX)
            PVX(IN)=-PUY(IN)
            PVY(IN)=PUX(IN)
          END DO
        END DO
C
        DO IY=1,NDYA
          DO IX =1,NDXA
            IN=IY+(IX-1)*NR1ST
            NSTGRD(IN)=ABS(IAISO(IX,IY)-1)
          END DO
        END DO

        DEALLOCATE (ALPHXB)
        DEALLOCATE (ALPHYB)
        DEALLOCATE (XAISO)
        DEALLOCATE (IAISO)
C
      ELSE
        CALL LEER(1)
        WRITE (iunout,*) 
     .  ' NO FILE FORT.29 WITH MODIFIED GRID INFO. FOUND '
        WRITE (iunout,*) ' OLD VERSION CALCULATION MAGN. FIELD FROM ',
     .               'GRID IS USED '
        WRITE (iunout,*) ' GRID IS ASSUMED TO BE ORTHOGONAL '
      END IF
C
C  TRANSFER FLAGS
C
      NAINI=NAINB
C
      RETURN
C
C   GEOMETRY DEFINITION PART FINISHED
C
      ENTRY IF1COP
C
C   NOW READ THE PLASMA STATE GIVEN BY BRAAMS
C   AT PRESENT THE DATA COME FROM THE FILE FT31
C   FURTHERMORE: SCALING TO EIRENE UNITS AND INDEX MAPPING
C   STATEMENT NO. 2000 ---> 2999
C
C  IN CASE OF "SHORT CYCLE" THE PLASMA STATE IS TRANSFERRED VIA COMMON
C
      LSHORT=.FALSE.
      CALL LEER(1)
      WRITE (iunout,*) 'IF1COP CALLED '
C  SKIP READING PLASMA, IF NLPLAS
      IF (NLPLAS) GOTO 2100
C
      GOTO 99991
C
C  IN CASE OF "SHORT CYCLE" OR TIME DEP. MODE
C  THE PLASMA STATE IS TRANSFERRED VIA COMMON
C  ONLY SCALING TO EIRENE UNITS AND INDEX MAPPING NEEDS TO BE DONE HERE
C
      ENTRY INTER1
      LSHORT=.TRUE.
      GOTO 2100
C
99991 CONTINUE
C
C
C  TRANSFER PROFILES
C
      IF (.NOT.(INDPRO(1).EQ.6.OR.INDPRO(2).EQ.6.OR.INDPRO(3).EQ.6.OR.
     .          INDPRO(4).EQ.6)) RETURN
C
      IF (NLPLAS) WRITE (iunout,*) 'PLASMA DATA EXPECTED ON BRAEIR'
      IF (.NOT.NLPLAS) 
     .  WRITE (iunout,*) 'PLASMA DATA EXPECTED ON FORT.31'
C
      OPEN (UNIT=31,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 31
C
      IF (NFLA.GT.NFL) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INFCOP '
        WRITE (iunout,*) ' NFLA MUST BE <= NFL'
        WRITE (iunout,*) ' NFLA,NFL = ',NFLA,NFL
        CALL EXIT_OWN(1)
      ENDIF

      CALL ALLOC_BRAEIR(NDX,NDY,NFL)
C
C  B2-BRAAMS CODE SPECIFIC BEGIN
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,DNIB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UUB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,VVB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TEB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TIB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,PRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UPB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,RRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIXB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEYB)


C
C  OPTIONAL ARRAYS: VOLB, BFELDB,FNIX_YB, FNIY_XB
      VOLB = 0.D0
      BFELDB = 0.D0
      FNIX_YB = 0.D0
      FNIY_XB = 0.D0
C  CELL VOLUMES AS USED IN B2
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,VOLB)
C  MAGNETIC FIELD STRENGTH (TESLA)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,BFELDB)
C  X-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A Y-FLUX TOO
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIX_YB)
C  Y-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A X-FLUX TOO
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIY_XB)
C
2100  CONTINUE
C
C  NO INDEX MAPPING REQUIRED, IF NEW TIMESTEP ON SAME PLASMA
C  BRAEIR NOT MODIFIED SINCE LAST CALL TO IF1COP
      IF (NCUTB_SAVE.EQ.NCUTL) THEN
        WRITE (iunout,*) 'NO INDEX MAPPING DONE'
      ELSE
        WRITE (iunout,*) 'INDEX MAPPING DONE ', NCUTB_SAVE,NCUTB,NCUTL
      ENDIF
      CALL LEER(1)
C
C  INDEX MAPPING : NDY DIRECTION
C
C  INDEX MAPPING : NDX DIRECTION
C  SET THE NUMBER OF COLUMNS PER CUT FROM NCUTB (BRAAMS IMPLEMENTATION)
C  TO WHAT IS FOUND FROM THE EIRENE GEOMETRY FILE (NCUTL)
C
      IF (NCUTL.EQ.NCUTB_SAVE) GOTO 2101
C  FIRST THE ZONE CENTERED DATA
      CALL INDMAP (DNIB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (TEB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (TIB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (RRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (PRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
C  NOW THE SURFACE CENTERED DATA
      CALL INDMAP (FNIXB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIYB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UUB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (VVB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UPB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)




      CALL INDMAP (VOLB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (BFELDB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIX_YB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIY_XB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
C
2101  CONTINUE
C
C  INDICATE, THAT NOW BRAEIR CONTAINS DATA AFTER INDEX-MAPPING
      NCUTB_SAVE=NCUTL
C
C  RESET 2D ARRAYS ONTO 1D EIRENE ARRAYS, RESCALE TO EIRENE UNITS
C  AND CONVERT BRAAMS VECTORS INTO CARTHESIAN EIRENE VECTORS
C
C  UNITS CONVERSION FACTORS
      T=1./ELCHA
      V=1.E2
      VL=1.E6
      DO 2105 IPLS=1,NPLSI
        D(IPLS)=1.E-6*FCTE(IPLS)
        FL(IPLS)=ELCHA*FCTE(IPLS)
2105  CONTINUE
C
      BZINTF = 1._DP
      DO 2110 IY=1,NDYA
        DO 2120 IX =1,NDXA
          IN=IY+(IX-1)*NR1ST
          TEINTF(IN)=TEB(IX,IY)*T
C
C  ONLY ONE ION TEMPERATURE AVAILABLE FROM PLASMA FLUID CODE,
C  SEE LOOP 2150 BELOW
          TIINTF(1,IN)=TIB(IX,IY)*T
C
          BX=PUX(IN)*RRB(IX,IY)+PVX(IN)*0.
          BY=PUY(IN)*RRB(IX,IY)+PVY(IN)*0.
          BZ=SQRT(1.-RRB(IX,IY)**2)
          BN=SQRT(BX*BX+BY*BY+BZ*BZ)
          BXINTF(IN)=BX/BN
          BYINTF(IN)=BY/BN
          BZINTF(IN)=BZ/BN
          VLINTF(IN)=VOLB(IX,IY)*VL
2120    CONTINUE
2110  CONTINUE
C
C  SET SAME ION TEMPERATURE FOR ALL EIRENE BACKGROUND SPECIES
C
      DO 2150 IPLS=1,NPLSTI
      DO 2150 IY=1,NDYA
        DO 2150 IX =1,NDXA
          IN=IY+(IX-1)*NR1ST
          TIINTF(IPLS,IN)=TIINTF(1,IN)
2150  CONTINUE
C
      IREAD=0
      DO 2200 IPLS=1,NPLSI
        IF (IFLB(IPLS).GT.0) THEN
          IPLSV=MPLSV(IPLS)
          DO 2201 IFL=1,NFLA
            IF (IFLB(IPLS).NE.IFL) GOTO 2201
            DO 2210 IY=1,NDYA
              DO 2220 IX = 1,NDXA
                IN=IY+(IX-1)*NR1ST
                DIINTF(IPLS,IN)=DNIB(IX,IY,IFL)*D(IPLS)
                UUBC=0.5*(UUB(IX-1,IY,IFL)+UUB(IX,IY,IFL))
                UPBC=0.5*(UPB(IX-1,IY,IFL)+UPB(IX,IY,IFL))
                VVBC=0.5*(VVB(IX,IY-1,IFL)+VVB(IX,IY,IFL))
C  UDBC: DIAMAGNETIC VELOCITY, SHOULD BE ZERO IN B2, AND NONZERO IN EB2
C        NOTE: IN LINEAR DEVICES: RRB=1
                IF (RRB(IX,IY).LT.1.D0) THEN
                  RBC=SQRT(1.-RRB(IX,IY)**2)
                  UDBC=1./RBC*(UUBC-RRB(IX,IY)*UPBC)
                ELSE
                  RBC=0.
                  UDBC=0.
                ENDIF
                VXINTF(IPLSV,IN)=(PUX(IN)*UUBC+PVX(IN)*VVBC)*V
                VYINTF(IPLSV,IN)=(PUY(IN)*UUBC+PVY(IN)*VVBC)*V
                VZINTF(IPLSV,IN)=(RBC*UPBC-RRB(IX,IY)*UDBC)*V
2220          CONTINUE
2210        CONTINUE
C  EIRENE BACKGROUND SPECIES "IPLS" FILLED WITH B2 DATA "IFL"
2201      CONTINUE
C  NO DATA FOR "IPLS" IN B2 FILES
        ELSEIF (IFLB(IPLS).EQ.-13) THEN
C  READ DATA FOR "IPLS" FROM EIRENE DUMP FILE FT13
          IF (IREAD.EQ.0) THEN
            OPEN (UNIT=13,ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
            REWIND 13
            READ (13,IOSTAT=IO) TEIN,TIIN,DEIN,DIIN,VXIN,VYIN,VZIN
            IREAD=1
            IF (TRCFLE) WRITE (iunout,*) 'READ 13: RCMUSR, IO= ',IO
            CLOSE (UNIT=13)
          ENDIF
          IF (IO.EQ.0) THEN
            IPLSTI= MPLSTI(IPLS)
            IPLSV= MPLSV(IPLS)
            DIINTF(IPLS,:)=DIIN(IPLS,:)
            VXINTF(IPLSV,:)=VXIN(IPLSV,:)
            VYINTF(IPLSV,:)=VYIN(IPLSV,:)
            VZINTF(IPLSV,:)=VZIN(IPLSV,:)
            TIINTF(IPLSTI,:)=TIIN(IPLSTI,:)
          ENDIF
        ELSE
C  SET PARAMETERS FOR SPECIES IPLS TO ZERO
C  NOTHING TO BE DONE HERE
        ENDIF
2200  CONTINUE
C  B2-BRAAMS CODE SPECIFIC END
C
C
C  READ OTHER B2 ARRAYS INTO EIRENE, FOR PRINTOUT AND PLOTTING
C
      DO 2300 IAIN=1,NAINB
        IF (NAINT(IAIN).EQ.1.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2321 IY=1,NDYA
          DO 2321 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=DNIB(IX,IY,NAINS(IAIN))
2321      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.2.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2322 IY=1,NDYA
          DO 2322 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=UUB(IX,IY,NAINS(IAIN))
2322      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.3.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2323 IY=1,NDYA
          DO 2323 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=VVB(IX,IY,NAINS(IAIN))
2323      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.6) THEN
          DO 2326 IY=1,NDYA
          DO 2326 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=PRB(IX,IY)
2326      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.7.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2327 IY=1,NDYA
          DO 2327 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=UPB(IX,IY,NAINS(IAIN))
2327      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.8) THEN
          DO 2328 IY=1,NDYA
          DO 2328 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=RRB(IX,IY)
2328      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.9.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2329 IY=1,NDYA
          DO 2329 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FNIXB(IX,IY,NAINS(IAIN))+
     .                      FNIX_YB(IX,IY,NAINS(IAIN))
2329      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.10.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2330 IY=1,NDYA
          DO 2330 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FNIYB(IX,IY,NAINS(IAIN))+
     .                      FNIY_XB(IX,IY,NAINS(IAIN))
2330      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.11) THEN
          DO 2331 IY=1,NDYA
          DO 2331 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEIXB(IX,IY)
2331      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.12) THEN
          DO 2332 IY=1,NDYA
          DO 2332 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEIYB(IX,IY)
2332      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.13) THEN
          DO 2333 IY=1,NDYA
          DO 2333 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEEXB(IX,IY)
2333      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.14) THEN
          DO 2334 IY=1,NDYA
          DO 2334 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=FEEYB(IX,IY)
2334      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.15) THEN
          DO 2335 IY=1,NDYA
          DO 2335 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=VOLB(IX,IY)
2335      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.16) THEN
          DO 2336 IY=1,NDYA
          DO 2336 IX=1,NDXA
            IN=IY+(IX-1)*NR1ST
            ADINTF(IAIN,IN)=BFELDB(IX,IY)
2336      CONTINUE
        ENDIF
2300  CONTINUE
C
      RETURN
C
2999  CONTINUE
C
C  PLASMA PROFILES ARE NOW READ IN
C
      ENTRY IF2COP(ITRG)
      ITARG=ITRG
      IF (ITARG.GT.NTARGI) THEN
        CALL LEER(1)
        WRITE (iunout,*) 'SOURCE DATA FOR STRATUM ISTRA= ',ITARG
        WRITE (iunout,*) 
     .    'CANNOT BE DEFINED IN IF2COP. CHANGE INDSRC(ISTRA)'
        CALL LEER(1)
        RETURN
      ENDIF
C
C  NEXT DEFINE FLUXES, TEMPERATURES AND VELOCITIES AT THE TARGETS
C  (FLUXES IN AMP/(CM ALONG TARGET), TEMPERATURES IN EV, VELOCITIES IN CM/SEC)
C   FNIXB*FL (FNIYB*FL) ARE GIVEN IN AMP
C  STATEMENT NO 3000 ---> 3999
C
3000  CONTINUE
C
      IF (TRCINT.AND.LTARG.EQ.0) THEN
        LTARG=1
        WRITE (iunout,*) 'ITARG: TARGET NUMBER '
        WRITE (iunout,*) 'IPRT : SUBSECTION OF TARGET '
        WRITE (iunout,*) 
     .     'NPBS : BRAAMS (SURFACE) X-CELL INDEX OF TARGET '
        WRITE (iunout,*) 'NPBC : BRAAMS (ZONE) P-CELL INDEX OF TARGET '
        WRITE (iunout,*) 'NPES : POLOIDAL SURFACE INDEX OF TARGET'
        WRITE (iunout,*) '       IN EIRENE MESH'
        WRITE (iunout,*) 'NPEC : 1ST POLOIDAL CELL INDEX OF EIRENE MESH'
        WRITE (iunout,*) '       SEEN BY MONTE CARLO HISTORIES'
      ENDIF
C
      DO 3005 IPLS=1,NPLSI
      DO 3005 IGITT=1,NGITT
        FLSTEP(IPLS,ITARG,IGITT)=0.
3005  CONTINUE
C
C??   ALLOCATE (TORL(NSTRA,NGITT))
C??   ALLOCATE (ESHT(NSTEP,NGITT))
C??   ALLOCATE (ORI(NSTEP,NGITT))

      RRSTEP(ITARG,1)=0.
      IG=0
      IIPLS=NPLSI
      IEPLS=1
      DO 3040 IPRT=1,NTGPRT(ITARG)
C  NINCT= 1: PLASMA FLUX IN SAME   DIRECTION AS B2 CO-ORDINATE
C  NINCT=-1: PLASMA FLUX IN OPPOS. DIRECTION AS B2 CO-ORDINATE
C  BRAAMS X-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (SURFACE CENTERED, EAST OR NORTH) (AFTER INDEX MAPPING)
C  (E.G. SURFACE NO.0 AND SURFACE NO. NX) AT TARGETS.
        NPBS=NDT(ITARG,IPRT)
C  BRAAMS P-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (ZONE CENTERED) (AFTER INDEX MAPPING)
C
C  THIS LINE, IF B2-BOUNDARY CONDITIONS ARE COMPUTED FROM GUARD CELLS
C  (E.G. CELL NO.0 AND CELL NO. NX+1) AT TARGETS.
        NPBC=NPBS+MAX0(0,NINCT(ITARG,IPRT))
C
C  1ST EIRENE CELL ALONG TARGET
        NPEC=NPBS-MIN0(0,NINCT(ITARG,IPRT))
C  EIRENE SURFACE NUMBER AT TARGET
        NPES=NPBS+1
        IF (TRCINT) THEN
          WRITE (iunout,*) 'ITARG,IPRT,NPBS,NPBC,NPES,NPEC ',
     .                 ITARG,IPRT,NPBS,NPBC,NPES,NPEC
        ENDIF
C
C  FIRST: SOURCES AT POLOIDAL (Y) SURFACES (EAST OR WEST CELL FACES)
        IF (NIXY(ITARG,IPRT).EQ.2) GOTO 3020
C
        DO IY=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(NPBC,IY)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  RRSTEP IS THE ARC LENGTH ALONG THE TARGET (CM)
          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .                       SQRT((XPOL(IY+1,NPES)-XPOL(IY,NPES))**2+
     .                            (YPOL(IY+1,NPES)-YPOL(IY,NPES))**2)
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
          IRSTEP(ITARG,IG)=IY
          IPSTEP(ITARG,IG)=NPEC
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=200000+NPES
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
          TORL(ITARG,IG)=2.*PIA*0.5*(XPOL(IY+1,NPES)+
     .                               XPOL(IY,NPES))
          DO 3013 IPLS=1,NPLSI
            IPLSTI=MPLSTI(IPLS)
            IPLSV=MPLSV(IPLS)
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLSTI,ITARG,IG) = TIB(NPBC,IY)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3013
            DISTEP(IPLS,ITARG,IG)=DNIB(NPBC,IY,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELY=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELY.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                                FNIXB(NPBS,IY,IFL))*FL(IPLS)/DELY
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
C  USE SIGN FROM "MAIN" CONTRIBUTION TO DECIDE ORIENTATION OF SEC. CONTR.
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIX_YB(NPBS,IY,IFL))*
     .                   FL(IPLS)/DELY
                ENDIF
C  SET ION ENERGY FLUXES FROM B2-BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLSTI,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG)+
     .                                  FL(IPLS)/DELY*
     .            (TIS*delti_perp*ABS(Fnix_yb(npbs,iy,ifl))+
     .             TIS*delti_para*ABS(fnixb  (npbs,iy,ifl))+
     .             TES*delte_para*ABS(fnixb  (npbs,iy,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PV VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        DATA FOR POLOIDAL POLYGON NPES
            IN=IY+(NPEC-1)*NR1ST
            PVXS=XPOL(IY+1,NPES)-XPOL(IY,NPES)
            PVYS=YPOL(IY+1,NPES)-YPOL(IY,NPES)
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
C  ORTHONORMALIZE PU VECTOR WITH RESPECT TO PV
            PUPV=PUX(IN)*PVXS+PUY(IN)*PVYS
            PUXS=PUX(IN)-PUPV*PVXS
            PUYS=PUY(IN)-PUPV*PVYS
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
            VXSTEP(IPLSV,ITARG,IG)=
     .            (PUXS*UUB(NPBS,IY,IFL)+PVXS*VVB(NPBS,IY,IFL))*V
            VYSTEP(IPLSV,ITARG,IG)=
     .            (PUYS*UUB(NPBS,IY,IFL)+PVYS*VVB(NPBS,IY,IFL))*V
            RRBS=UUB(NPBS,IY,IFL)/(UPB(NPBS,IY,IFL)+EPS60)
            VZSTEP(IPLSV,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(NPBS,IY,IFL))*V
3013      CONTINUE
        ENDDO
C
        GOTO 3030
C
3020    CONTINUE
C
C  SECOND: SOURCES AT RADIAL (X) SURFACES
C
        DO IX=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(IX,NPBC)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .                     SQRT((XPOL(NPES,IX+1)-XPOL(NPES,IX))**2+
     .                          (YPOL(NPES,IX+1)-YPOL(NPES,IX))**2)
          IRSTEP(ITARG,IG)=NPEC
          IPSTEP(ITARG,IG)=IX
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=100000+NPES
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
          TORL(ITARG,IG)=2.*PIA*0.5*(XPOL(NPES,IX+1)+
     .                               XPOL(NPES,IX))
          DO 3023 IPLS=1,NPLSI
            IPLSTI=MPLSTI(IPLS)
            IPLSV=MPLSV(IPLS)
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLSTI,ITARG,IG) = TIB(IX,NPBC)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE (EV)
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3023
            DISTEP(IPLS,ITARG,IG)=DNIB(IX,NPBC,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELX=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELX.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                                FNIYB(IX,NPBS,IFL))*FL(IPLS)/DELX
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIY_XB(IX,NPBS,IFL))*
     .                   FL(IPLS)/DELX
                ENDIF
C  SET ION ENERGY FLUXES FROM B2 BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLSTI,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG) +
     .                                  FL(IPLS)/DELX*
     .            (TIS*delti_perp*ABS(Fniyb  (ix,npbs,ifl))+
     .             TIS*delti_para*ABS(fniy_xb(ix,npbs,ifl))+
     .             TES*delte_para*ABS(fniy_xb(ix,npbs,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PU VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        RADIAL POLYGON NPES DATA
            IN=NPEC+(IX-1)*NR1ST
            PUXS=XPOL(NPES,IX+1)-XPOL(NPES,IX)
            PUYS=YPOL(NPES,IX+1)-YPOL(NPES,IX)
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
C  ORTHONORMALIZE PV VECTOR WITH RESPECT TO PU
            PUPV=PUXS*PVX(IN)+PUYS*PVY(IN)
            PVXS=PVX(IN)-PUPV*PUXS
            PVYS=PVY(IN)-PUPV*PUYS
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
            VXSTEP(IPLSV,ITARG,IG)=
     .            (PUXS*UUB(IX,NPBS,IFL)+PVXS*VVB(IX,NPBS,IFL))*V
            VYSTEP(IPLSV,ITARG,IG)=
     .            (PUYS*UUB(IX,NPBS,IFL)+PVYS*VVB(IX,NPBS,IFL))*V
            RRBS=UUB(IX,NPBS,IFL)/(UPB(IX,NPBS,IFL)+EPS60)
            VZSTEP(IPLSV,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(IX,NPBS,IFL))*V
3023      CONTINUE
        ENDDO
3030    CONTINUE
C
3040  CONTINUE
      NRWL(ITARG)=IG+1

C
      IF (TRCSOU) CALL LEER(2)
C
C  INITIALIZE FUNCTION STEP (FOR RANDOM SAMPLING ALONG TARGET)
C  SET SOME SOURCE PARAMETERS EXPLICITLY TO ENFORCE INPUT CONSISTENCY
C
      FLUX(ITARG)=STEP(IIPLS,IEPLS,NRWL(ITARG),ITARG)
C
      NLPLS(ITARG)=.TRUE.
      NLATM(ITARG)=.FALSE.
      NLMOL(ITARG)=.FALSE.
      NLION(ITARG)=.FALSE.
C
      NLSRF(ITARG)=.TRUE.
      NLPNT(ITARG)=.FALSE.
      NLLNE(ITARG)=.FALSE.
      NLVOL(ITARG)=.FALSE.
      NLCNS(ITARG)=.FALSE.
C
      NSRFSI(ITARG)=1
      INDIM(1,ITARG)=4
      IF (INDSRC(ITARG).NE.6) THEN
        I34=IDEZ(INT(SORLIM(1,ITARG)),3,3)
        SORLIM(1,ITARG)=I34*100+04
      ELSEIF (INDSRC(ITARG).EQ.6) THEN
C  SORLIM DEFAULT WAS 0.D0
        SORLIM(1,ITARG)=0204
      ENDIF
      SORIND(1,ITARG)=ITARG
C  IN CASE INDIM=4: INSOR,INDGRD,... ARE REDUNDANT
      NRSOR(1,ITARG)=-1
      NPSOR(1,ITARG)=-1
      IF (INDSRC(ITARG).LT.6) THEN
        WRITE (iunout,*) 'MESSAGE FROM IF2COP: '
        WRITE (iunout,*) 'SOURCE STRENGTH AND SPATIAL DISTRIBUTION FOR '
        WRITE (iunout,*) 'STRATUM ',ISTRA,' MODIFIED.'
        CALL MASR1('FLUX=   ',FLUX(ISTRA))
        WRITE (iunout,*) 'USE STEP FUNCTION ISTEP= ',ITARG,
     .                   ' FROM BLOCK 14'
        CALL LEER(1)
      ENDIF
C
      IF (INDSRC(ITARG).EQ.6) THEN
C  DEFINE SOURCE FOR TARGET RECYCLING STRATUM ITARG
C  ASSUME NOW: ITARG=ISTRA
C  DEFAULTS ARE ALREADY SET IN SUBR. INPUT.
C
        CALL FTCRI(ITARG,CITARG)
        TXTSOU(ITARG)= 'SURFACE RECYCLING SOURCE NO.'//CITARG
        NPTS(ITARG)=NPTC(ITARG,1)
        NINITL(ITARG)=ITARG*1001
        NSPEZ(ITARG)=-1
        SORIFL(1,ITARG)=NIFLG(ITARG,1)
        SORWGT(1,ITARG)=1.
C  USE ENERGY FLUXES SPECIFIED HERE, IE., SORENE, SORENI ARE REDUNDANT
        NEMODS(ITARG)=9
        NAMODS(ITARG)=1
C
C  USE POLYGON MESH, IE., SORAD1,...,SORAD4 ARE REDUNDANT.
        SORAD5(1,ITARG)=ZIA
        SORAD6(1,ITARG)=ZAA
C
C  VELOCITY SPACE DISTRIBUTION
        SORCOS(ITARG)=1.
        SORMAX(ITARG)=0.
C
C
C  DO 2028 LOOP FROM SUBR. INPUT
        THMAX=MAX(0._DP,MIN(PIHA,SORMAX(ITARG)*DEGRAD))
        IF (NAMODS(ITARG).EQ.1) THEN
          RP1=SORCOS(ITARG)+1.
          SORCOS(ITARG)=1./RP1
          IF (ABS(COS(THMAX)).LE.EPS10) THEN
            SORMAX(ITARG)=1.
          ELSE
            SORMAX(ITARG)=1.-COS(THMAX)**RP1
          ENDIF
        ELSEIF (NAMODS(ITARG).EQ.2) THEN
          SORCOS(ITARG)=SORCOS(ITARG)*DEGRAD
          SORMAX(ITARG)=THMAX
        ENDIF
        NLSYMT(0)=NLSYMT(0).AND.NLSYMT(ITARG)
        NLSYMP(0)=NLSYMP(0).AND.NLSYMP(ITARG)
C
      ENDIF
C
C  SOURCE DEFINITION FOR TARGET RECYCLING STRATUM ITARG COMPLETED
C
3999  CONTINUE
C
C  TARGET DATA ARE DEFINED NOW
C
C
C  COMPUTE EXACT SURFACE ENERGY FLUXES FOR COMPARISON WITH SAMPLED
C  E-FLUX "ETOTP". THIS IS ONLY FOR DIAGNOSTICS PURPOSES
C  E.G. TO CHECK CONSISTENCY OF BOUNDARY CONDITIONS
C  STATEMENT NO. 6000 ---> 6500
C
      IF (.NOT.TRCSOU) GOTO 6500
C
      EEMAX=0.
      EESHT=0.
C
      DO 6011 IG=1,NRWL(ITARG)-1
        OR=ORI(ITARG,IG)
C
C  COMPUTE SHEATH POTENTIAL ESHT(ITARG,IG)
C  USE ALL NPLSI SPECIES, NOT JUST IFL=NSPZI,NSPZE
C
        ESHT(ITARG,IG)=0.D0
        NEM=IABS(NEMODS(ITARG))
        IF (NEM.EQ.3.OR.NEM.EQ.5.OR.NEM.EQ.7.OR.NEM.EQ.9) THEN
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
            IY=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            DO 6005 IPL=1,NPLSI
              IPLV=MPLSV(IPL)
              PM1=(PPLNX(IY,NPES)*VXSTEP(IPLV,ITARG,IG)+
     .             PPLNY(IY,NPES)*VYSTEP(IPLV,ITARG,IG))*OR
              VPZ=VZSTEP(IPLV,ITARG,IG)
              VP(IPL)=SQRT(PM1**2+VPZ**2)
              DI(IPL)=DISTEP(IPL,ITARG,IG)
6005        CONTINUE
            TE=TESTEP(ITARG,IG)
            CUR=0.
            GAMMA=0.
            ESHT(ITARG,IG)=SHEATH(TE,DI,VP,NCHRGP,GAMMA,CUR,NPLSI,
     .                           -ITARG)
          ELSEIF (IGSTEP(ITARG,IG).LT.200000) THEN
            IX=IPSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-100000
            DO 6006 IPL=1,NPLSI
              IPLV=MPLSV(IPL)
              PM1=(PPLNX(NPES,IX)*VXSTEP(IPLV,ITARG,IG)+
     .             PPLNY(NPES,IX)*VYSTEP(IPLV,ITARG,IG))*OR
              VPZ=VZSTEP(IPLV,ITARG,IG)
              VP(IPL)=SQRT(PM1**2+VPZ**2)
              DI(IPL)=DISTEP(IPL,ITARG,IG)
6006        CONTINUE
            TE=TESTEP(ITARG,IG)
            CUR=0.
            GAMMA=0.
            ESHT(ITARG,IG)=SHEATH(TE,DI,VP,NCHRGP,GAMMA,CUR,NPLSI,
     .                           -ITARG)
          ENDIF
        ENDIF
C
        DO 6009 IPLS=1,NPLSI
          IF (FLSTEP(IPLS,ITARG,IG).EQ.0.D0) GOTO 6009
C
          IPLSTI=MPLSTI(IPLS)
          IPLSV=MPLSV(IPLS)
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
C  CHECK BOHM CRITERION AT "POLOIDAL" TARGET SURFACE COMPONENTS
            IY=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            VT=SQRT(2.*TISTEP(IPLSTI,ITARG,IG)/BMASS(IPLS))*CVEL2A
C  VELOCITY COMPONENT NORMAL TO POLOIDAL TARGET SURFACE
C  I.E., POLOIDAL COMPONENT V-POL
C  ASSUMING ORTHOGONAL TARGET
            PM1=(PPLNX(IY,NPES)*VXSTEP(IPLSV,ITARG,IG)+
     .           PPLNY(IY,NPES)*VYSTEP(IPLSV,ITARG,IG))*OR
C  VELOCITY COMPONENT PARALLEL TO POLOIDAL TARGET SURFACE
C  I.E., RADIAL PLUS TOROIDAL COMPONENT, V-RAD + V-TOR
C  AGAIN: ASSUMING ORTHOGONAL TARGET
            VPX=VXSTEP(IPLSV,ITARG,IG)-PM1*PPLNX(IY,NPES)*OR
            VPY=VYSTEP(IPLSV,ITARG,IG)-PM1*PPLNY(IY,NPES)*OR
            VPZ=VZSTEP(IPLSV,ITARG,IG)-0.
            PN1=SQRT(VPX**2+VPY**2+VPZ**2)
            PERW=0.
            PARW=0.
            IF (VT.GT.0.) THEN
              PERW=PM1/VT
              PARW=PN1/VT
            ENDIF
C
            CS=SQRT((1.*TISTEP(IPLSTI,ITARG,IG)+
     .                  TESTEP(ITARG,IG))/BMASS(IPLS))*CVEL2A
C THE MACH NUMBER BOUNDARY CONDITION ONLY AFFECTS THE PARALLEL TO B
C MOMENTUM, I.E., NOT THE RADIAL VELOCITY
            VTEST=SQRT(PM1**2+VPZ**2)
            VTEST=VTEST/(CS+EPS60)
            VR=SQRT(VPX**2+VPY**2)
            WRITE (iunout,*) 'IPLS,ITARG,IG,MACH ',IPLS,ITARG,IG,VTEST
C           WRITE (iunout,*) 'POL., TOR., RAD. ',PM1,VPZ,VR
            CALL LEER(1)
          ENDIF
C
C  BOHM CRITERION CHECK DONE
C
C  NEXT: TARGET ENERGY FLUXES
          DRR=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
C  ENERGY FLUX DEFINED IN INPUT BLOCK 7
          IF (NEMODS(ITARG).EQ.1) THEN
            EADD=SORENI(ITARG)
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).EQ.2.OR.NEMODS(ITARG).EQ.3) THEN
            EADD=SORENI(ITARG)*TISTEP(IPLSTI,ITARG,IG)+SORENE(ITARG)*
     .           TESTEP(ITARG,IG)
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).GE.4 .AND. NEMODS(ITARG).LE.7) THEN
            IF (IGSTEP(ITARG,IG).LT.200000) THEN
              EADD=0.
              WRITE (iunout,*) 'INVALID OPTION FOUND IN IF2COP '
              WRITE (iunout,*) 'POSSIBLE ERROR IN TARGET ENERGY FLUX '
              WRITE (iunout,*) 'ITARG,IG ',ITARG,IG
            ELSE
              PERWI=PERW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
              PARWI=PARW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
              EADD=EMAXW(TISTEP(IPLSTI,ITARG,IG),PERWI,PARWI)
            ENDIF
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).EQ.8 .OR. NEMODS(ITARG).EQ.9) THEN
C  ENERGY FLUX DEFINED BY B2-BOUNDARY CONDITIONS
            EEMAX=EEMAX+ELSTEP(IPLS,ITARG,IG)*DRR
          ENDIF
C  SUM SHEATH ACCELERATION
          EADD=NCHRGP(IPLS)*ESHT(ITARG,IG)
          ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
          EESHT=EESHT+ESUM*DRR
6009    CONTINUE
        GOTO 6011
6010    CONTINUE
C  TO BE WRITTEN
6011  CONTINUE
C
      CALL LEER(1)
      WRITE (iunout,*) 'TARGET DATA: TARGET NO. ITARG=ISTRA= ',ITARG
      WRITE (iunout,*)
     .' IG,  ARC,     P-FLUX,   E-FLUX,     TE,       TI,    SHEATH/TE'
      DO 6100 IG=1,NRWL(ITARG)-1
        WRITE (iunout,'(1X,I3,1P,6E11.3)')
     .             IG,RRSTEP(ITARG,IG),FLSTEP(0,ITARG,IG),
     .             ELSTEP(0,ITARG,IG),
     .             TESTEP(ITARG,IG),TISTEP(1,ITARG,IG),
     .             ESHT(ITARG,IG)/(TESTEP(ITARG,IG)+EPS60)
6100  CONTINUE
      WRITE (iunout,'(1X,I3,1P,1E11.3)') NRWL(ITARG),
     .                                 RRSTEP(ITARG,NRWL(ITARG))
      CALL MASR1 ('EEMAX    ',EEMAX)
      CALL MASR1 ('EESHT    ',EESHT)
C
      ETOT=EEMAX+EESHT
      EFLX(ITARG)=EEMAX+EESHT
      WRITE (iunout,*) 'PARTICLE FLUX(IPLS), IPLS=1,NPLSI '
      WRITE (iunout,'(1X,1P,6E12.4)') (FLTOT(ISP,ITARG),ISP=1,NPLSI)
      CALL LEER(1)
      WRITE (iunout,*) 'ENERGY FLUX '
      WRITE (iunout,'(1X,1P,1E12.4)') EFLX(ITARG)
      CALL LEER(2)
C
6300  CONTINUE
C
C  SET SOME OTHER DATA SPECIFIC FOR EIRENE CODE REQUIREMENTS
C  STATEMENT NO. 6500 ---> 6999
C
6500  CONTINUE
C
C
      RETURN
999   CONTINUE
      WRITE (iunout,*) 'ERROR IN IF2COP: NGITT TOO SMALL '
      CALL EXIT_OWN(1)
      RETURN
C
C
      ENTRY IF3COP(ISTRAA,ISTRAE,NEW_ITER)
C
C
      WRITE (iunout,*) ' IF3COP IS CALLED, ISTRAA,ISTRAE '
      WRITE (iunout,*) ISTRAA,ISTRAE
      LSHORT=.FALSE.
      LSTOP=.TRUE.
      IFIRST=0
      NDXY=(NDXA-1)*NR1ST+NDYA
      GOTO 99992
C
      ENTRY INTER3(LSTP,IFRST,ISTRAA,ISTRAE,NEW_ITER)
C
C  ENTRY FOR SHORT CYCLE FROM SUBR. EIRSRT
C
C  IFIRST=0: RESTORE DATA FROM A PREVIOUS EIRENE RUN, SET REFERENCE
C            DATA FOR "STOP-CRITERION" SNIS,SEES,SEIS
C  IFIRST>0: MODIFY SOURCE TERMS ACCORDING TO NEW PLASMA CONDITIONS,
C            COMPARE INTEGRALS WITH SNIS,...., AND DECIDE TO STOP OR
C            CONTINUE SHORT CYCLE (LSTOP)
C
      LSHORT=.TRUE.
      LSTOP=LSTP
      IFIRST=IFRST
      NDXY=(NDXA-1)*NR1ST+NDYA
C
99992 CONTINUE

      IF (.NOT.ALLOCATED(CHPS)) THEN
        ALLOCATE (CHPS(NFL))
        ALLOCATE (SNIS(0:NFL))
        ALLOCATE (CHMOS(NFL))
        ALLOCATE (SMOS(0:NFL))
        ALLOCATE (SCALN(0:NFL))
        ALLOCATE (SNIS0(NSTRA,0:NFL))
        ALLOCATE (SMOS0(NSTRA,0:NFL))
        ALLOCATE (RESSNI(NFL))
        ALLOCATE (RESSMO(NFL))
        CALL ALLOC_BRASPOI
        CALL ALLOC_EIRBRA(NDXP,NDYP,NFL,NSTRA)
      ENDIF
C
!      IF ((ISTRAA.NE.ISTRAE).OR.(ISTRAA.EQ.1).OR.(ISETRES == 0)) THEN
!        ISETRES = 1
      IF (NEW_ITER == 0) THEN
        RESSNI = 0.D0
        RESSMO = 0.D0
        RESSEE = 0.D0
        RESSEI = 0.D0
      ENDIF

      DO 10000 ISTRAI=ISTRAA,ISTRAE
C
        IF (XMCP(ISTRAI).LE.1.) GOTO 10000
C
        IF (LSHORT) GOTO 7000
C
C  READ DATA FROM STRATUM NO. ISTRAI BACK INTO WORKING SPACE
C  IF REQUIRED
C
        IF (ISTRAI.EQ.IESTR) THEN
C  NOTHING TO BE DONE
        ELSEIF (NFILEN.EQ.1.OR.NFILEN.EQ.2) THEN
          IESTR=ISTRAI
          CALL RSTRT(ISTRAI,NSTRAI,NESTM1,NESTM2,NADSPC,
     .               ESTIMV,ESTIMS,ESTIML,
     .               NSDVI1,SDVI1,NSDVI2,SDVI2,
     .               NSDVC1,SIGMAC,NSDVC2,SGMCS,
     .               NSBGK,SIGMA_BGK,NBGV_STAT,SGMS_BGK,
     .               NSCOP,SIGMA_COP,NCPV_STAT,SGMS_COP,
     .               NSIGI_SPC,TRCFLE)
        ELSE
          WRITE (iunout,*) 'ERROR IN INFCOP: STRATUM ISTRAI= ',ISTRAI
          WRITE (iunout,*) 'IS NOT AVAILABLE. EXIT CALLED'
          CALL EXIT_OWN(1)
        ENDIF
C
C  DATA TRANSFER BACK FROM EIRENE TO EXTERNAL CODE
C  STATEMENT NO 7000 ---> 7999
C
7000    CONTINUE
C
C  SCALE SURFACE SOURCES PER UNIT FLUX, FOR OTHER SOURCES USE
C  EIRENE SCALINGS
        IF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).NE.0.) THEN
C  FLUX FROM EIRENE TO PLASMA CODE: NEGATIVE
          FLX=-WTOTP(0,ISTRAI)
          FLXI=1./FLX
        ELSEIF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).EQ.0.) THEN
          WRITE (iunout,*) 'NO PLASMA FLUX FROM STRATUM NO. ISTRAI= ',
     .                     ISTRAI
          WRITE (iunout,*) 
     .      'NO DATA RETURNED TO PLASMA CODE FOR THIS STRATUM'
          GOTO 7999
        ELSEIF (ISTRAI.GT.NTARGI) THEN
          FLXI=1.
        ENDIF
C
C  FIRSTLY INITIALIZE SOURCE TERM ARRAYS
C
        DO 7100 IX=0,NDXA+1
          DO 7150 IY=0,NDYA+1
            SEE(IX,IY,ISTRAI)=0.
            SEI(IX,IY,ISTRAI)=0.
7150      CONTINUE
7100    CONTINUE
        DO 7210 IF=1,NFLA
          DO 7220 IX=0,NDXA+1
            DO 7230 IY=0,NDYA+1
              SNI(IX,IY,IF,ISTRAI)=0.
              SMO(IX,IY,IF,ISTRAI)=0.
7230        CONTINUE
7220      CONTINUE
7210    CONTINUE
C
        DO 7300 IPLS=1,NPLSI
        DO 7300 IN=1,NDXY
          CHPM(IPLS,IN)=0.
          CHMOM(IPLS,IN)=0.
7300    CONTINUE
        DO 7301 IN=1,NDXY
          CHEEM(IN)=0.
          CHEIM(IN)=0.
7301    CONTINUE
C
        IF (.NOT.LSHORT) GOTO 7400

        COPV=0.D0
        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IN=CPMUL%ICM
          COPV(ICPV,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MAPL=0.D0
        CPMUL => MAPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MAPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MMPL=0.D0
        CPMUL => MMPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MMPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MIPL=0.D0
        CPMUL => MIPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MIPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT IONISATION OF ATOMS
C                        AND BULK ION CHARGE EXCHANGE WITH ATOMS
C

        PAPL=0.D0
        CPMUL => PAPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PAPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EAEL=0.D0
        CPSIM => EAELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EAPL=0.D0
        CPSIM => EAPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7310

        CPMUL => PDENAS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IATM=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWA(IN,IATM,IPLS)-SPLODA(IN,IATM,IPLS))*ELCHA
            PAPL(IPLS,IN)=PAPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          ENDDO
          CHE=CPMUL%VALUEM*
     .        (SEENWA(IN,IATM)-SEEODA(IN,IATM))*ELCHA
          EAEL(IN)=EAEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IF (ICPV.LE.NPLSI) THEN
            IPLS=ICPV
            IN=CPMUL%ICM
            CHI=CPMUL%VALUEM*
     .          (SEINWA(IN,IPLS)-SEIODA(IN,IPLS))*ELCHA
            EAPL(IN)=EAPL(IN)+CHI
            CHEIM(IN)=CHEIM(IN)+CHI
          ENDIF
          CPMUL => CPMUL%NXTMUL
        ENDDO

7310    CONTINUE

C
C  CORRECTION FOR ELECTRON IMPACT IONISATION AND CX OF ATOMS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS
C

        PIPL=0.D0
        CPMUL => PIPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PIPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EIEL=0.D0
        CPSIM => EIELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EIPL=0.D0
        CPSIM => EIPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7330

        CPMUL => PDENIS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IION=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM *
     .          (SPLNWI(IN,IION,IPLS)-SPLODI(IN,IION,IPLS))*ELCHA
            PIPL(IPLS,IN)=PIPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM *
     .        (SEENWI(IN,IION)-SEEODI(IN,IION))*ELCHA
          EIEL(IN)=EIEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CHI=CPMUL%VALUEM *
     .        (SEINWI(IN,IION)-SEIODI(IN,IION))*ELCHA
          EIPL(IN)=EIPL(IN)+CHI
          CHEIM(IN)=CHEIM(IN)+CHI
          CPMUL => CPMUL%NXTMUL
        ENDDO

7330    CONTINUE
C
C
C  CORRECTION FOR TEST IONS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT COLLISIONS
C             OF MOLECULES
C

        PMPL=0.D0
        CPMUL => PMPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PMPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EMEL=0.D0
        CPSIM => EMELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EMPL=0.D0
        CPSIM => EMPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7350

        CPMUL => PDENMS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IMOL=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWM(IN,IMOL,IPLS)-SPLODM(IN,IMOL,IPLS))*ELCHA
            PMPL(IPLS,IN)=PMPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM*
     .        (SEENWM(IN,IMOL)-SEEODM(IN,IMOL))*ELCHA
          EMEL(IN)=EMEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

7350    CONTINUE
C
C  CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS FINISHED
C
C  SHORT LOOP CORRECTION FINISHED
C
7400    CONTINUE
C
C
C  ADD CONTRIBUTIONS FROM VOLUME RECOMBINATION SOURCE
C
        PPPL_COP =0.D0
        CPPV = 0.D0
        EPPL_COP = 0.D0
        EPEL = 0.D0

        IF (NLVOL(ISTRAI)) THEN
C
          DO 7473 IPLS=1,NPLSI
            CNDYNP=AMUA*RMASSP(IPLS)
            IPLSTI= MPLSTI(IPLS)
            DO 7472 IIRC=1,NPRCI(IPLS)
              IRRC=LGPRC(IPLS,IIRC)
              SUMN=0.0
              SUMM=0.0
              SUMEI=0.0
              SUMEE=0.0
              DO 7471 IR=1,NR1ST-1
              DO 7471 K=1,NPPLG
              DO 7471 IP=NPOINT(1,K),NPOINT(2,K)-1
                IN=(IP-1)*NR1ST+IR
                INC=NCLTAL(IN)
                IF (NSTORDR >= NRAD) THEN
                  RECADD=-TABRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                  EEADD=  EELRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                ELSE
                  RECADD=-FTABRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                  EEADD=  FEELRC1(IRRC,IN)*DIIN(IPLS,IN)*ELCHA
                END IF
                PPPL_COP(IPLS,INC)=PPPL_COP(IPLS,INC)+RECADD
                SUMN=SUMN+RECADD*VOL(IN)
                PIADD=PARMOM(IPLS,IN)*RECADD
                CPPV(IPLS,INC)=CPPV(IPLS,INC)+PIADD
                SUMM=SUMM+PIADD*VOL(IN)
                EIADD=(1.5*TIIN(IPLSTI,IN)+EDRIFT(IPLS,IN))*RECADD
                EPPL_COP(INC)=EPPL_COP(INC)+EIADD
                SUMEI=SUMEI+EIADD*VOL(IN)
                EPEL(INC)=EPEL(INC)+EEADD
                SUMEE=SUMEE+EEADD*VOL(IN)
7471          CONTINUE
              WRITE (iunout,*) 'IPLS,IRRC ',IPLS,IRRC
              CALL MASR4('SUMN, SUMM, SUMEI, SUMEE        ',
     .                     SUMN,SUMM,SUMEI,SUMEE)
7472        CONTINUE
7473      CONTINUE
        ENDIF
C
        IF (.NOT.LSYMET) GOTO 7500
C
C  SECONDLY SYMMETRISE EIRENE ARRAYS ACCORDING TO SYMMETRY IN MODEL
C
C
C   THIRDLY WRITE EIRENE ARRAYS (1D) ONTO BRAAMS ARRAYS (2D)
C   AND RESCALE TO PROPER UNITS: #/CELL/STRATUM FLUX
C   # STANDS FOR PARTICLES (SNI), MOMENTUM (SMO)
C   AND ENERGY (SEE,SEI)
C
7500    CONTINUE
        DO 7510 IFL=1,NFLA
          CHPS(IFL)=0.
          SNIS(IFL)=0.
          CHMOS(IFL)=0.
          SMOS(IFL)=0.
          DO 7510 IPLS=1,NPLSI
            IF (IFLB(IPLS).NE.IFL) GOTO 7510
            IPLSV=MPLSV(IPLS)
            DO 7520 IX=1,NDXA
              DO 7530 IY=1,NDYA
                INN=IY+(IX-1)*NR1ST
                IN=NCLTAL(INN)
                SNICL=(PAPL(IPLS,IN)+PMPL(IPLS,IN)+PIPL(IPLS,IN)+
     .                 PPPL_COP(IPLS,IN))*VOLTAL(IN)
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)+SNICL
                SNIS(IFL)=SNIS(IFL)+SNICL
                CHPS(IFL)=CHPS(IFL)+CHPM(IPLS,IN)*VOLTAL(IN)
                RESSNI(IFL)=RESSNI(IFL)+ABS(SIGMA_COP(NPLSI+IPLS,IN)*
     .                      SNICL/100.D0)
7530          CONTINUE
7520        CONTINUE
!pb            DO 7539 IADD=NPLSI,3*NPLSI,NPLSI
!pb            IF (NCPVI.LT.IADD+NPLSI) GOTO 7539
            DO 7536 IX=1,NDXA
              DO 7533 IY=1,NDYA
                IN=IY+(IX-1)*NR1ST
                INC=NCLTAL(IN)
                SIGNUM=SIGN(1._DP,BVIN(IPLSV,IN))
!pb                SMOCL=(COPV(IADD+IPLS,INC)+CPPV(IADD+IPLS,INC))*
 !pb    .                VOLTAL(INC)*1.D-5*SIGNUM
                SMOCL=(MAPL(IPLS,IN)+MMPL(IPLS,IN)+MIPL(IPLS,IN)+
     .                 CPPV(IPLS,INC))*VOLTAL(INC)*1.D-5*SIGNUM
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)+SMOCL
                SMOS(IFL)=SMOS(IFL)+SMOCL
                CHMOS(IFL)=CHMOS(IFL)+CHMOM(IPLS,INC)*VOLTAL(INC)
                RESSMO(IFL)=RESSMO(IFL)+ABS(SIGMA_COP(IPLS,INC)*
     .                      SMOCL/100.D0*1.D5)
7533          CONTINUE
7536        CONTINUE
!pb 7539        CONTINUE
7510    CONTINUE

C
        CHEES=0.
        CHEIS=0.
        SEES=0.
        SEIS=0.
        DO 7540 IX=1,NDXA
          DO 7545 IY=1,NDYA
            INN=IY+(IX-1)*NR1ST
            IN=NCLTAL(INN)
            SEE(IX,IY,ISTRAI)=(EAEL(IN)+EMEL(IN)+EIEL(IN)+EPEL(IN))*
     .                        VOLTAL(IN)
            CHEES=CHEES+CHEEM(IN)*VOLTAL(IN)
            SEES=SEES+SEE(IX,IY,ISTRAI)
            RESSEE=RESSEE+ABS(SIGMA_COP(2*NPLSI+1,IN)*
     .             SEE(IX,IY,ISTRAI)/100.D0)
            SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*ELCHA
            SEI(IX,IY,ISTRAI)=(EAPL(IN)+EMPL(IN)+EIPL(IN)+EPPL_COP(IN))*
     .                        VOLTAL(IN)
            CHEIS=CHEIS+CHEIM(IN)*VOLTAL(IN)
            SEIS=SEIS+SEI(IX,IY,ISTRAI)
            RESSEI=RESSEI+ABS(SIGMA_COP(2*NPLSI+2,IN)*
     .             SEI(IX,IY,ISTRAI)/100.D0)
            SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*ELCHA
7545      CONTINUE
7540    CONTINUE
C
C   NEXT:
C   IF LSHORT: CRITERION TO STOP SHORT CYCLE,
C   IF NOT LSHORT: RESCALE SURFACE SOURCE STRATA
C                  UNITS: # PER UNIT TARGET PLATE FLUX
C
        IF (LSHORT.AND.IFIRST.EQ.0) THEN
C
          SNIS0(ISTRAI,0)=0.
          SMOS0(ISTRAI,0)=0.
          DO 7550 IFL=1,NFLA
            SNIS0(ISTRAI,0)=SNIS0(ISTRAI,0)+SNIS(IFL)
            SNIS0(ISTRAI,IFL)=SNIS(IFL)
            SMOS0(ISTRAI,0)=SMOS0(ISTRAI,0)+SMOS(IFL)
            SMOS0(ISTRAI,IFL)=SMOS(IFL)
7550      CONTINUE
          SEES0(ISTRAI)=SEES
          SEIS0(ISTRAI)=SEIS
C
        ELSEIF (LSHORT.AND.IFIRST.GT.0) THEN
C
          SNIS(0)=0.
          DO 7551 IFL=1,NFLA
            SNIS(0)=SNIS(0)+SNIS(IFL)
            SCALN(IFL)=SNIS0(ISTRAI,IFL)/(SNIS(IFL)+EPS60)
7551      CONTINUE

          SCALN(0)=SNIS0(ISTRAI,0)/(SNIS(0)+EPS60)
C
C         SCALM=SMOS0(ISTRAI,0)/(SMOS(0)+EPS60)  ???
C         SCALE=SEES0(ISTRAI)/(SEES+EPS60)       ???
C         SCALI=SEIS0(ISTRAI)/(SEIS+EPS60)       ???
C
          SCALM=1.
          SCALE=1.
          SCALI=1.
          DO 7555 IX=0,NDXA+1
            DO 7552 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*SCALN(0)
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*SCALN(0)
7552        CONTINUE
7555      CONTINUE
          DO 7556 IFL=1,NFLA
            DO 7553 IX=0,NDXA+1
              DO 7554 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*SCALN(IFL)
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*SCALN(IFL)
7554          CONTINUE
7553        CONTINUE
7556      CONTINUE
C
          IF (LSTOP) THEN
            WRITE (iunout,*) 'STOP SHORT CYCLE: ALL B2 TIMESTEPS DONE '
          ELSE
            DO 7558 IFL=1,NFLA
              TEST=CHPS(IFL)/(SNIS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGP) THEN
                LSTP=.TRUE.
                WRITE (iunout,*) 'STOP SHORT CYCLE: PART. SOURCES: ',
     .                            SNIS(IFL),CHPS(IFL),TEST
                WRITE (iunout,*) 'STRATUM ISTRAI, SPECIES IFL ',
     .                            ISTRAI,IFL
              ENDIF
              TEST=CHMOS(IFL)/(SMOS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGMOM) THEN
                LSTP=.TRUE.
                WRITE (iunout,*) 'STOP SHORT CYCLE: MOMENTUM SOURCE: ',
     .                            SMOS(IFL),CHMOS(IFL),TEST
                WRITE (iunout,*) 'STRATUM ISTRAI, SPECIES IFL ',
     .                            ISTRAI,IFL
              ENDIF
7558        CONTINUE
            TEST=CHEES/(SEES+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEE) THEN
              LSTP=.TRUE.
              WRITE (iunout,*) 'STOP SHORT CYCLE: EL EN. SOURCE: ',SEES,
     .                     CHEES,TEST
              WRITE (iunout,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
            TEST=CHEIS/(SEIS+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEI) THEN
              LSTP=.TRUE.
              WRITE (iunout,*) 'STOP SHORT CYCLE: ION EN. SOURCE: ',
     .                          SEIS,CHEIS,TEST
              WRITE (iunout,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
          ENDIF
C
        ELSEIF (.NOT.LSHORT) THEN
C
          DO 7560 IX=0,NDXA+1
            DO 7565 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*FLXI
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*FLXI
7565        CONTINUE
7560      CONTINUE
          DO 7570 IFL=1,NFLA
            DO 7580 IX=0,NDXA+1
              DO 7590 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*FLXI
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*FLXI
7590          CONTINUE
7580        CONTINUE
7570      CONTINUE
C
        ENDIF
C
C   THIRDLY:
C   INDEX MAPPING BACK TO BRAAMS IMPLEMENTATION OF LINDA GEOMETRY
C
        IF (NCUTL.EQ.NCUTB) GOTO 7600
C
        CALL INDMPI (SNI,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SMO,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEE,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEI,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
C
7600    CONTINUE
C
7700    CONTINUE
C
7999  CONTINUE
C
C  DATA TRANSFER BACK TO PLASMA CODE FINISHED FOR STRATUM NO. ISTRAI
C
10000 CONTINUE
C
      RETURN
C
      ENTRY IF4COP
C
      NREC11=NOUTAU
      OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
      IRC=3
      WRITE (11,REC=IRC) RCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
      IRC=3
      ALLOCATE (IHELP(NOUTAU))
      JC=0
      DO K=1,NPTRGT
        DO J=1,10*NSTEP
          JC=JC+1
          IHELP(JC)=ICCPL1(J,K)
          IF (JC == NOUTAU) THEN
            IRC=IRC+1
            WRITE (11,REC=IRC) IHELP
            IF (TRCINT.OR.TRCFLE)   
     .        WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
            JC=0
          END IF
        END DO
      END DO
      IF (JC > 0) THEN
        IHELP(JC+1:NOUTAU) = 0
        IRC=IRC+1
        WRITE (11,REC=IRC) IHELP
        IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
      END IF
      DEALLOCATE (IHELP)
      IRC=IRC+1
      WRITE (11,REC=IRC) ICCPL2
      IRC=IRC+1
      WRITE (11,REC=IRC) LCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
C
      IF (LSHORT) LSTOP=LSTP
C
      IF (.NOT.LSTOP) RETURN
C
      IF (.NOT.(LBALAN)) GOTO 11000
C
C  BALANCES, SHOULD BE DONE ONLY AT THE END OF B2 RUN
C  AT THE END OF AN EIRENE RUN THE BALANCES MAY BE OFF AT LEAST AT
C  THE BEGINNING OF THE CYCLING PROCEDURE, BECAUSE THE PLASMA STILL
C  HAS TO ADJUST TO THE NEW SOURCES
C
C...............................................................................
C
C  CHECK FLUXES AT THE GRID BOUNDARY, SIGN, RECYCLING OR NON-RECYCLING BOUNDARY
C  COUNT FLUXES FROM OUTSIDE INTO GRID AS POSITIVE
C
C...............................................................................
C
C  FIRST: SOUTH EDGE: IY=0
C
C NON RECYCLING FLUXES AT SOUTH EDGE: SFEISY,SFEESY,SFNISY
      SFEISY=0.
      SFEESY=0.
      SFNISY=0.
C
      DO 10113 IX=1,NDXA
C
C IS (IX,0) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.0) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10113
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C SURFACE NORMAL IS INWARD. HENCE: TAKE ALL FLUXES F...YB POSITIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEISY=SFEISY+FEIYB(IX,0)
        SFEESY=SFEESY+FEEYB(IX,0)
        DO 10111 IF=1,NFLA
          SI=SIGN(1._DP,FNIYB(IX,0,IF))
          SFNISY=SFNISY+FNIYB(IX,0,IF)+SI*ABS(FNIY_XB(IX,0,IF))
10111   CONTINUE
10113 CONTINUE
C
      SFNISY=SFNISY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM SOUTH EDGE '
      WRITE (37,8888) SFNISY,SFEISY,SFEESY
8888  FORMAT (3E14.6)
C
C
C  SECOND: NORTH EDGE: IY=NDYA
C
C NON RECYCLING FLUXES AT NORTH EDGE: SFEINY,SFEENY,SFNINY
      SFEINY=0.
      SFEENY=0.
      SFNINY=0.
      DO 10118 IX=1,NDXA
C
C IS (IX,NDYA) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.NDYA) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10118
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C SURFACE NORMAL IS OUTWARD. HENCE: TAKE ALL FLUXES F...YB NEGATIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEINY=SFEINY-FEIYB(IX,NDYA)
        SFEENY=SFEENY-FEEYB(IX,NDYA)
        DO 10116 IF=1,NFLA
          SI=SIGN(1._DP,FNIYB(IX,NDYA,IF))
          SFNINY=SFNINY-FNIYB(IX,NDYA,IF)-SI*ABS(FNIY_XB(IX,NDYA,IF))
10116   CONTINUE
10118 CONTINUE
C
      SFNINY=SFNINY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO NORTH EDGE '
      WRITE (37,8888) SFNINY,SFEINY,SFEENY
C
C
C  THIRD: WEST EDGE: IX=0
C
C NON RECYCLING FLUXES AT WEST EDGE: SFEIWX,SFEEWX,SFNIWX
      SFEIWX=0.
      SFEEWX=0.
      SFNIWX=0.
      DO 10123 IY=1,NDYA
C
C IS (0,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
             IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.0) THEN
               IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .             IY.LT.NTEN(ITARG,IPRT)) GOTO 10123
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        SFEIWX=SFEIWX+FEIXB(0,IY)
        SFEEWX=SFEEWX+FEEXB(0,IY)
        DO 10121 IF=1,NFLA
          SI=SIGN(1._DP,FNIXB(0,IY,IF))
          SFNIWX=SFNIWX+FNIXB(0,IY,IF)+SI*ABS(FNIX_YB(0,IY,IF))
10121   CONTINUE
10123 CONTINUE
C
      SFNIWX=SFNIWX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM WEST EDGE '
      WRITE (37,8888) SFNIWX,SFEIWX,SFEEWX
C
C
C  FOURTH: EAST EDGE: IX=NDXA
C
C NON RECYCLING FLUXES AT EAST EDGE: SFEIEX,SFEEEX,SFNIEX
      SFEIEX=0.
      SFEEEX=0.
      SFNIEX=0.
      DO 10128 IY=1,NDYA
C
C IS (NDXA,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.NDXA) THEN
              IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .            IY.LT.NTEN(ITARG,IPRT)) GOTO 10128
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        SFEIEX=SFEIEX-FEIXB(NDXA,IY)
        SFEEEX=SFEEEX-FEEXB(NDXA,IY)
        DO 10126 IF=1,NFLA
          SI=SIGN(1._DP,FNIXB(NDXA,IY,IF))
          SFNIEX=SFNIEX-FNIXB(NDXA,IY,IF)-SI*ABS(FNIX_YB(NDXA,IY,IF))
10126   CONTINUE
10128 CONTINUE
C
      SFNIEX=SFNIEX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO EAST EDGE '
      WRITE (37,8888) SFNIEX,SFEIEX,SFEEEX
C
C  NEXT: FLUXES TO THOSE SURFACES, AT WHICH RECYCLING BOUNDARY
C        CONDITIONS ARE SPECIFIED
C
10130 CONTINUE
C
      SFEIT(0)=0.
      SFEET(0)=0.
      SFNIT(0)=0.
      SHEAE(0)=0.
      SHEAI(0)=0.
      DO 10139 I=1,NTARGI
        SFEIT(I)=0.
        SFEET(I)=0.
        SFNIT(I)=0.
        SHEAE(I)=0.
        SHEAI(I)=0.
        DO IPRT=1,NTGPRT(I)
          IF (NIXY(I,IPRT).EQ.1) THEN
C  BALANCE CONTRIB. X-GRID REC. SOURCE
            DO 10132 IY=NTIN(I,IPRT),NTEN(I,IPRT)-1
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIXB(NDT(I,IPRT),IY)
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEXB(NDT(I,IPRT),IY)
              DO 10131 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF).GT.0) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)-
     .                   ABS(FNIX_YB(NDT(I,IPRT),IY,IF))
                SHEAE(I)=SHEAE(I)+TEB(NDT(I,IPRT),IY)*
     .           (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)+
     .            ABS(FNIX_YB(NDT(I,IPRT),IY,IF)))*
     .           (-2.8)
                SHEAI(I)=SHEAI(I)+TEB(NDT(I,IPRT),IY)*
     .           (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)+
     .            ABS(FNIX_YB(NDT(I,IPRT),IY,IF)))*
     .           2.8
                ELSE
                  WRITE (iunout,*)
     .              'WRONG ORIENTATION OF W/E-TARGET RECYCLING FLUX '
                  WRITE (iunout,*) 'ITARG, IPRT, IPLS, NDT, IY ',
     .                         I    , IPRT, IF,   NDT(I,IPRT), IY
                  WRITE (iunout,*) 'FNIX(NDT,IY) ',
     .                              FNIXB(NDT(I,IPRT),IY,IF)
                ENDIF
10131         CONTINUE
10132       CONTINUE
C  BALANCE CONTRIB. FROM Y-GRID REC. SOURCE
          ELSEIF (NIXY(I,IPRT).EQ.2) THEN
            DO 10135 IX=NTIN(I,IPRT),NTEN(I,IPRT)-1
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIYB(IX,NDT(I,IPRT))
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEYB(IX,NDT(I,IPRT))
              DO 10136 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF).GT.0.) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)-
     .                   ABS(FNIY_XB(IX,NDT(I,IPRT),IF))
                SHEAE(I)=SHEAE(I)+TEB(IX,NDT(I,IPRT))*
     .           (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)+
     .            ABS(FNIY_XB(IX,NDT(I,IPRT),IF)))*
     .           (-2.8)
                SHEAI(I)=SHEAI(I)+TEB(IX,NDT(I,IPRT))*
     .           (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)+
     .            ABS(FNIY_XB(IX,NDT(I,IPRT),IF)))*
     .           2.8
                ELSE
                  WRITE (iunout,*)
     .              'WRONG ORIENTATION OF S/N-TARGET RECYCLING FLUX '
                  WRITE (iunout,*) 'ITARG, IPRT, IPLS, IX, NDT ',
     .                         I    , IPRT, IF,   IX, NDT(I,IPRT)
                  WRITE (iunout,*) 'FNIY(IX,NDT) ',
     .                              FNIYB(IX,NDT(I,IPRT),IF)
                ENDIF
10136         CONTINUE
10135       CONTINUE
          ENDIF
        ENDDO
C
        SFNIT(I)=SFNIT(I)*ELCHA
C
C
        WRITE (37,*) 'FLUXES TO TARGET NO. ',I
        WRITE (37,8888) SFNIT(I),SFEIT(I),SFEET(I)
C
        SFEIT(0)=SFEIT(0)+SFEIT(I)
        SFEET(0)=SFEET(0)+SFEET(I)
        SFNIT(0)=SFNIT(0)+SFNIT(I)
        SHEAE(0)=SHEAE(0)+SHEAE(I)
        SHEAI(0)=SHEAI(0)+SHEAI(I)
10139 CONTINUE
C
      SSNI=0.
      SSEI=0.
      SSEE=0.
      DO 10150 ISTRA=1,NSTRAI
        IF (XMCP(ISTRA).LE.1) GOTO 10150
        FLX=0.
        IF (ISTRA.LE.NTARGI) THEN
          FLX=ABS(SFNIT(ISTRA))
        ELSE
          FLX=1.
        ENDIF
        SSN=0.
        SSI=0.
        SSE=0.
        DO 10140 IX=1,NDXA
           DO 10140 IY=1,NDYA
             DO 10141 IF=1,NFLA
               SSN=SSN+SNI(IX,IY,IF,ISTRA)
10141        CONTINUE
             SSI=SSI+SEI(IX,IY,ISTRA)
             SSE=SSE+SEE(IX,IY,ISTRA)
10140   CONTINUE
C
      WRITE (37,*) 'RECYCLING SOURCE RATES, POTENTIAL+RAD. EN. ',ISTRA
      WRITE (37,8888) SSN*FLX,SSI*FLX/ELCHA,SSE*FLX/ELCHA
C
C  TRENNEN VON RAD. UND POTENTIELLER ENERGY IM ELECTRONENKANAL.
C  DAZU ABER TEILCHENQUELLE SPEZIESAUFGELOEST NOETIG.
C
C
C
C     WRITE (37,*) 'RADIATION LOSSES VIA NEUTRAL CHANNEL ',ISTRA
C     WRITE (37,8888) 0.,0.,0.
C
        SSNI=SSNI+SSN*FLX
        SSEI=SSEI+SSI*FLX/ELCHA
        SSEE=SSEE+SSE*FLX/ELCHA
10150 CONTINUE
C
      WRITE (37,*) 'EQUILIBRATION '
      WRITE (37,8888) 0.,B2QIE,-B2QIE
C
C
      WRITE (37,*) 'BREMSSTRAHLUNG '
      WRITE (37,8888) 0.,0.,B2BREM
C
      WRITE (37,*) 'CHARGED IMPURITY RAD.,IONIZ. AND RECOMB. '
      WRITE (37,8888) 0.,0.,B2RAD
C
      WRITE (37,*) 'ELECTRIC FIELD TERMS (PRESSURE GRADIENTS)'
      WRITE (37,8888) 0.,B2VDP,-B2VDP
C
      BALANI=SFEISY+SFEINY+SFEIT(0)+SHEAI(0)+SSEI+B2QIE+B2VDP+
     .       SFEIWX+SFEIEX
      BALANE=SFEESY+SFEENY+SFEET(0)+SHEAE(0)+SSEE+B2BREM+B2RAD-B2QIE+
     .       SFEEWX+SFEEEX-B2VDP
      BALANN=SFNISY+SFNINY+SFNIWX+SFNIEX+SFNIT(0)+SSNI
C
      TOTI=ABS(SFEISY+SFEINY)+ABS(SFEIT(0))+
     .     ABS(SHEAI(0))+ABS(SSEI)
      TOTE=ABS(SFEESY+SFEENY)+ABS(SFEET(0))+
     .     ABS(SHEAE(0))+ABS(SSEE)
      TOTN=ABS(SFNISY+SFNINY)+ABS(SFNIT(0))+
     .     ABS(SSNI)
      RE=BALANE/(TOTE+EPS60)*100.
      RI=BALANI/(TOTI+EPS60)*100.
      RN=BALANN/(TOTN+EPS60)*100.
C
      CALL LEER (1)
      IF (LBALAN) THEN
        WRITE (iunout,*) 'B2-EIRENE GLOBAL BALANCES '
        WRITE (iunout,*) 'PARTICLE FLUXES (SFNI..) IN AMP'
        WRITE (iunout,*) 'ENERGY FLUXES (SFEI..,SFEE..,) IN WATT'
        CALL LEER(1)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT SOUTH EDGE '
        CALL MASR3(' SFEISY,SFEESY,SFNISY   ',SFEISY,SFEESY,SFNISY)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT NORTH EDGE'
        CALL MASR3(' SFEINY,SFEENY,SFNINY   ',SFEINY,SFEENY,SFNINY)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT WEST EDGE '
        CALL MASR3(' SFEIWX,SFEEWX,SFNIWX   ',SFEIWX,SFEEWX,SFNIWX)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT EAST EDGE '
        CALL MASR3(' SFEIEX,SFEEEX,SFNIEX   ',SFEIEX,SFEEEX,SFNIEX)
        CALL MASRR1 (' TARGETS,EI',SFEIT(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,EE',SFEET(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,NI',SFNIT(1),NTARGI,5)
        CALL MASR3(' TOTALS, EI,EE,NI       ',SFEIT(0),
     .                                     SFEET(0),SFNIT(0))
        WRITE (iunout,*) ' NEUTRAL PLASMA INTERACTION: '
        CALL MASR3(' SSEI,SSEE,SSNI         ',SSEI,SSEE,SSNI)
        WRITE (iunout,*) 
     .    ' VOLUMETRIC ENERGY SINKS FOR ELECTRONS, FROM B2 '
        CALL MASR4(' B2BREM,B2RAD,-B2QIE,-B2VDP     ',
     .               B2BREM,B2RAD,-B2QIE,-B2VDP)
        WRITE (iunout,*) 
     .    ' TARGET SHEATH CONTRIBUTIONS,ELECTRONS AND IONS '
        CALL MASRR1 (' TARGETS,EI',SHEAI(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,EE',SHEAE(1),NTARGI,5)
        CALL MASR2(' TOTALS,EI,EE    ',SHEAI(0),SHEAE(0))
        CALL LEER(1)
        CALL MASR3(' BALANI,BALANE,BALANN   ',BALANI,BALANE,BALANN)
        CALL MASR3(' REL. ERR.(%) RI,RE,RN  ',RI,RE,RN)
        CALL LEER(1)
        WRITE (iunout,*) ' NOISE FROM SOURCE TERMS '
        RESSNI(1:NFLA) = RESSNI(1:NFLA)/ELCHA
        CALL MASR4(' RESSEE,RESSEI,RESSNI,RESSMO    ',
     .        RESSEE,RESSEI,SUM(RESSNI(1:NFLA)),SUM(RESSMO(1:NFLA)))
        CALL LEER(1)
        WRITE (iunout,*) ' RESSNI-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSNI    ',RESSNI(1),NFLA,5)
        WRITE (iunout,*) ' RESSMO-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSMO    ',RESSMO(1),NFLA,5)
      ENDIF
C
      CALL LEER (1)
C
11000 CONTINUE
C
      RETURN
C
      END
C ===== SOURCE: mshproj.f
C
C
      SUBROUTINE MSHPROJ(X1,Y1,X2,Y2,X3,Y3,X4,Y4,PUX,PUY,PVX,PVY,
     .                   NDXA,NR1ST,IY)

      USE PRECISION
      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: X1(*), Y1(*), X2(*), Y2(*),
     .                      X3(*), Y3(*), X4(*), Y4(*)
      REAL(DP), INTENT(OUT) :: PUX(*), PUY(*), PVX(*), PVY(*)
      INTEGER, INTENT(IN) :: NDXA, NR1ST, IY
      REAL(DP) :: D12, D34, D13, D24, EPS60, PUPV, PVPV, DVX, DVY,
     .          DUX, DUY
      INTEGER :: IX, IN

      EPS60 = 1.E-60_DP
C
C
      DO 1 IX=1,NDXA
C
C  CALCULATE THE NORM OF THE VECTORS (POINT2-POINT1),....
C
        D12 = SQRT((X2(IX)-X1(IX))*(X2(IX)-X1(IX))+(Y2(IX)-Y1(IX))*
     .        (Y2(IX)-Y1(IX)))+EPS60
        D34 = SQRT((X4(IX)-X3(IX))*(X4(IX)-X3(IX))+(Y4(IX)-Y3(IX))*
     .        (Y4(IX)-Y3(IX)))+EPS60
        D13 = SQRT((X3(IX)-X1(IX))*(X3(IX)-X1(IX))+(Y3(IX)-Y1(IX))*
     .        (Y3(IX)-Y1(IX)))+EPS60
        D24 = SQRT((X4(IX)-X2(IX))*(X4(IX)-X2(IX))+(Y4(IX)-Y2(IX))*
     .        (Y4(IX)-Y2(IX)))+EPS60
C
C  CALCULATE THE BISSECTING VECTORS, BUT NOT NORMALISED YET
C
        DUX = (X2(IX)-X1(IX))/D12 + (X4(IX)-X3(IX))/D34
        DUY = (Y2(IX)-Y1(IX))/D12 + (Y4(IX)-Y3(IX))/D34
        DVX = (X3(IX)-X1(IX))/D13 + (X4(IX)-X2(IX))/D24
        DVY = (Y3(IX)-Y1(IX))/D13 + (Y4(IX)-Y2(IX))/D24
C
C  CALCULATE THE COMPONENTS OF THE TWO UNIT VECTOR (= PROJECTION RATE)
C
        IN=IY+(IX-1)*NR1ST
        PUX(IN) = DUX/(SQRT(DUX*DUX+DUY*DUY)+EPS60)
        PUY(IN) = DUY/(SQRT(DUX*DUX+DUY*DUY)+EPS60)
        PVX(IN) = DVX/(SQRT(DVX*DVX+DVY*DVY)+EPS60)
        PVY(IN) = DVY/(SQRT(DVX*DVX+DVY*DVY)+EPS60)
C
C  ORTHOGONORMALIZE, CONSERVE ORIENTATION (E.SCHMIDT)
C
        PUPV=PUX(IN)*PVX(IN)+PUY(IN)*PVY(IN)
        PVX(IN)=PVX(IN)-PUPV*PUX(IN)
        PVY(IN)=PVY(IN)-PUPV*PUY(IN)
        PVPV=SQRT(PVX(IN)*PVX(IN)+PVY(IN)*PVY(IN))+EPS60
        PVX(IN)=PVX(IN)/PVPV
        PVY(IN)=PVY(IN)/PVPV
C
1     CONTINUE
      RETURN
      END
C ===== SOURCE: neutr.f
C
C
*//NEUTR//
C=======================================================================
C          S U B R O U T I N E   N E U T R
C=======================================================================
      SUBROUTINE NEUTR(KARD,NDIMX,NDIMY,NDIMF,DUMMY,LDMX,LDMY,LDMF,
     .                 LDNS,IS)

      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: KARD, NDIMX, NDIMY, NDIMF, LDMX, LDMY,
     .                       LDMF, LDNS, IS
      REAL(DP), INTENT(IN) :: DUMMY(0:LDMX+1,0:LDMY+1,LDMF,LDNS)
      INTEGER :: ND1, LIM, IX, IY, III, IF
C
      ND1 = NDIMX
      LIM = (ND1/5)*5 - 4
      DO  500  IF = 1,NDIMF
        DO  110  IY = 1,NDIMY
          DO  100  IX = 1,LIM,5
  100     WRITE(KARD,910) (DUMMY(IX-1+III,IY,IF,IS),III = 1,5)
          IF( (LIM+4).EQ.ND1 )   GOTO 110
          WRITE(KARD,910) (DUMMY(IX,IY,IF,IS),IX = LIM+5,ND1)
  110   CONTINUE
  500 CONTINUE
      RETURN
  910 FORMAT(5(E16.8))
*//END NEUTR//
      END
C ===== SOURCE: plasm.f
C
*//PLASM//
C=======================================================================
C          S U B R O U T I N E   P L A S M
C=======================================================================
      SUBROUTINE PLASM(KARD,NDIMX,NDIMY,NDIMF,N,M,NF,DUMMY)

      USE PRECISION
      IMPLICIT NONE

      INTEGER, INTENT(IN) :: KARD, NDIMX, NDIMY, NDIMF, N, M, NF
      REAL(DP), INTENT(OUT) :: DUMMY(0:N+1,0:M+1,NF)
      INTEGER :: ND1, LIM, IF, III, IX, IY

      DUMMY(0:N+1,0:M+1,NF)=0._DP

      ND1 = NDIMX + 2
      LIM = (ND1/5)*5 - 4
      DO    110  IF = 1,NDIMF
      DO    110  IY = 0,NDIMY+1
      DO    100  IX = 1,LIM,5
100     READ(KARD,910,END=500) (DUMMY(-1+IX-1+III,IY,IF),III = 1,5)
        IF( (LIM+4).EQ.ND1 )     GOTO 110
        READ(KARD,910,END=500) (DUMMY(-1+IX,IY,IF),IX = LIM+5,ND1)
110   CONTINUE
500   RETURN
910   FORMAT(5(E16.8))
*//END PLASM//
      END
C ===== SOURCE: statis_cop.f
!PB  17.11.05  USAGE OF SIGMA_COP CHANGED
!PB            SIGMA_COP(      1:  NPLSI) : STATISTICS FOR MOMENTUM SOURCES
!PB            SIGMA_COP(NPLSI+1:2*NPLSI) : STATISTICS FOR PARTICLE SOURCES
!PB            SIGMA_COP(2*NPLSI+1)       : STATISTICS FOR ELECTRON ENERGY SOURCES  
!PB            SIGMA_COP(2*NPLSI+2)       : STATISTICS FOR ION ENERGY SOURCES  
C
C
      SUBROUTINE STATIS_COP

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CGRID
      USE CSDVI
      USE CSDVI_COP
      USE COUTAU

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: XN, FSIG, ZFLUX
      INTEGER, INTENT(IN) :: NBIN, NRIN, NPIN, NTIN, NSIN
      LOGICAL, INTENT(IN) :: LP, LT

      REAL(DP) :: XNM, SD2, DS, ZFLUXQ, SD2S, SDS, SDI, SDE, D2S, SG,
     .          DSA, DD, D, SG2, DA, SD1, SD1S
      INTEGER :: IPLS, NSB, IR, ICO, IPL, NP2, NR1, ICPV, NT3
C
      SAVE
C
      ENTRY STATS0_COP
C
      RETURN

C
      ENTRY STATS1_COP(NBIN,NRIN,NPIN,NTIN,NSIN,LP,LT)
      NSB=NBIN
      NR1=NRIN
      NP2=NPIN
      NT3=NTIN
C
C
      IF (NCPVI.EQ.0) RETURN
C
C
C
C  STATISTICS FOR MOMENTUM SOURCES
      ICPV=0
      DO IPL = 1,NPLSI
        IF (LMETSP(NSPAN(97)+IPL-1) .OR.
     .      LMETSP(NSPAN(98)+IPL-1) .OR.
     .      LMETSP(NSPAN(99)+IPL-1) ) THEN
          ICPV = NCPVI + IPL
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SDS=MAPL(IPL,IR)+MIPL(IPL,IR)+MMPL(IPL,IR)
            SD1=SDS-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR)=SDS
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
      END DO
C
C  STATISTICS FOR PARTICLE SOURCES
      ICPV=NPLSI
      DO IPL = 1,NPLSI
        IF (LMETSP(NSPAN(14)+IPL-1) .OR.
     .      LMETSP(NSPAN(20)+IPL-1) .OR.
     .      LMETSP(NSPAN(26)+IPL-1) ) THEN
          ICPV = NCPVI + IPL
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SDS=PAPL(IPL,IR)+PIPL(IPL,IR)+PMPL(IPL,IR)
            SD1=SDS-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR)=SDS
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
      END DO
C
C  STATISTICS FOR ELECTRON AND ION ENERGY SOURCES
      ICPV=2*NPLSI
      SD1S=0.
      SD2S=0.
      DO ICO = 1,NCLMT
        IR = ICLMT(ICO)
        SDE=EAEL(IR)+EIEL(IR)+EMEL(IR)
        SDI=EAPL(IR)+EIPL(IR)+EMPL(IR)
        SD1=SDE-SDVIA_COP(ICPV+1,IR)
        SD2=SDI-SDVIA_COP(ICPV+2,IR)
        SD1S=SD1S+SD1
        SD2S=SD2S+SD2
        SDVIA_COP(ICPV+1,IR) = SDE
        SDVIA_COP(ICPV+2,IR) = SDI
        SIGMA_COP(ICPV+1,IR)=SIGMA_COP(ICPV+1,IR)+SD1*SD1
        SIGMA_COP(ICPV+2,IR)=SIGMA_COP(ICPV+2,IR)+SD2*SD2
      END DO
      SGMS_COP(ICPV+1)=SGMS_COP(ICPV+1)+SD1S*SD1S

C
C
1020  CONTINUE
      RETURN
C
      ENTRY STATS2_COP(XN,FSIG,ZFLUX)
C
C  1. FALL  ALLE BEITRAEGE GLEICHES VORZEICHEN: SIG ZWISCHEN 0 UND 1
C           (=1, FALLS NUR EIN BEITRAG UNGLEICH 0, ODER (KUENSTLICH
C            ERZWUNGEN) FALLS GAR KEIN BEITRAG UNGLEICH NULL)
C  2. FALL  NEGATIVE UND POSITIVE BEITRAGE KOMMEN VOR:
C           LT. FORMEL SIND AUCH WERTE GROESSER 1  MOEGLICH.
C
      XNM=XN-1.
      IF (XNM.LE.0.) RETURN
      ZFLUXQ=ZFLUX*ZFLUX
C
      IF (NCPVI.EQ.0) GOTO 2200
C
C  STATISTICS FOR MOMENTUM SOURCES
      ICPV = 0
      DO IPLS=1,NPLSI
C
        ICPV = ICPV + 1
        DS=SUM(MAPL(IPLS,1:NSB))+SUM(MIPL(IPLS,1:NSB))+
     .     SUM(MMPL(IPLS,1:NSB))
        DO IR=1,NSB
          D=MAPL(IPLS,IR)+MMPL(IPLS,IR)+MIPL(IPLS,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
      END DO
C
C  STATISTICS FOR PARTICLE SOURCES
      ICPV = NPLSI
      DO IPLS=1,NPLSI
C
        ICPV = ICPV + 1
        DS=SUM(PAPL(IPLS,1:NSB))+SUM(PIPL(IPLS,1:NSB))+
     .     SUM(PMPL(IPLS,1:NSB))
        DO IR=1,NSB
          D=PAPL(IPLS,IR)+PMPL(IPLS,IR)+PIPL(IPLS,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
      END DO
C
C  STATISTICS FOR ELECTRON ENERGY SOURCES
        DS=SUM(EAEL(1:NSB))+SUM(EIEL(1:NSB))+SUM(EMEL(1:NSB))
        DO IR=1,NSB
          D=EAEL(IR)+EMEL(IR)+EIEL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV+1,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+1,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+1,IR)=STV_COP(ICPV+1,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+1,IR)=EE_COP(ICPV+1,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV+1)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+1)=SG*FSIG
C
        STVS_COP(ICPV+1)=STVS_COP(ICPV+1)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+1)=EES_COP(ICPV+1)+DS*ZFLUX/XN
C
C  STATISTICS FOR ION ENERGY SOURCES
        DS=SUM(EAPL(1:NSB))+SUM(EIPL(1:NSB))+SUM(EMPL(1:NSB))
        DO IR=1,NSB
          D=EAPL(IR)+EMPL(IR)+EIPL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0._DP,SIGMA_COP(ICPV+2,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+2,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+2,IR)=STV_COP(ICPV+2,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+2,IR)=EE_COP(ICPV+2,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0._DP,SGMS_COP(ICPV+2)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+2)=SG*FSIG
C
        STVS_COP(ICPV+2)=STVS_COP(ICPV+2)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+2)=EES_COP(ICPV+2)+DS*ZFLUX/XN
C
2200  CONTINUE
      RETURN
      END
C ===== SOURCE: upscop.f
C
C
      SUBROUTINE UPSCOP
      RETURN
      END
C ===== SOURCE: uptcop.f
C
C
      SUBROUTINE UPTCOP(XSTOR2,XSTORV2,WV,IFLAG)
C
C  USER SUPPLIED TRACKLENGTH ESTIMATOR, VOLUME AVERAGED
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CGEOM
      USE COMPRT
      USE CSDVI
      USE COMXS

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: XSTOR2(MSTOR1,MSTOR2,N2ND+N3RD),
     .                      XSTORV2(NSTORV,N2ND+N3RD), WV
      INTEGER, INTENT(IN) :: IFLAG
      REAL(DP) :: P, WTRSIG, EION, V0_PARB, PARMOM_0, DIST, WTR
      INTEGER :: IAEL, IREL, IPL2, IAEI, IRDS, IBGK, IICX, IIEI, IIEL,
     .           IMEL, IPL1, I, IPL, IIO, IRD, IP, IR, IML, IAT, IFIRST,
     .           IRCX, IADD, ICOU, IACX, IRDD, IMCX, IMEI, IPLSTI,
     .           IPLSV, IPLV
      INTEGER, SAVE :: NMTSP
      REAL(DP), ALLOCATABLE, SAVE ::
     . CNDYNA(:), CNDYNM(:), CNDYNI(:)
CDR
      REAL(DP), ALLOCATABLE, SAVE ::
     . VPX(:),    VPY(:),    VRX(:),    VRY(:)
CDR
      DATA IFIRST/0/
      SAVE
      IF (IFIRST.EQ.0) THEN
        IFIRST=1
        ALLOCATE (CNDYNA(NATM))
        ALLOCATE (CNDYNM(NMOL))
        ALLOCATE (CNDYNI(NION))
        ALLOCATE (VPX(NRAD))
        ALLOCATE (VPY(NRAD))
        ALLOCATE (VRX(NRAD))
        ALLOCATE (VRY(NRAD))
        DO 11 IAT=1,NATMI
11        CNDYNA(IAT)=AMUA*RMASSA(IAT)
        DO 12 IML=1,NMOLI
12        CNDYNM(IML)=AMUA*RMASSM(IML)
        DO 13 IIO=1,NIONI
13        CNDYNI(IIO)=AMUA*RMASSI(IIO)
C
CDR
CDR  PROVIDE A RADIAL UNIT VECTOR PER CELL
CDR  VPX,VPY,  NEEDED FOR PROJECTING PARTICLE VELOCITIES
C
CDR  SAME FOR POLOIDAL UNIT VECTOR VRX,VRY
C
        DO 1 I=1,NRAD
          VPX(I)=0.
          VPY(I)=0.
          VRX(I)=0.
          VRY(I)=0.
1       CONTINUE
        DO 2 IR=1,NR1STM
          DO 2 IP=1,NP2NDM
            IRD=IR+(IP-1)*NR1P2
            VPX(IRD)=PLNX(IR,IP)
            VPY(IRD)=PLNY(IR,IP)
            VRX(IRD)=PPLNX(IR,IP)
            VRY(IRD)=PPLNY(IR,IP)
2       CONTINUE
C
        NMTSP=NPHOTI+NATMI+NMOLI+NIONI+NPLSI+NADVI+NALVI
C
      ENDIF
C
C  WV=WEIGHT/VEL
C
C  ATOMS
      IF (ITYP.EQ.1) THEN
        DO 20 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
          IRDD=NCLTAL(IRD)
C
          IF (LGVAC(IRD,0)) GOTO 20
C
          XSTOR(:,:) = XSTOR2(:,:,ICOU)
          XSTORV(:) = XSTORV2(:,ICOU)
C
C  1,NPLSI:
C              PARTICLE CHARGE EXCHANGE RATE DUE TO IPLS: #/S
C              WITH ATOM SPECIES IATM=1,NATMI, PER ION
C  EACH RATE IS WEIGHTED WITH THE FACTOR (E0/EI-1), E0 BEING
C  THE NEUTRAL PARTICLE ENERGY, EI THE MEAN PLASMA ION ENERGY
C  THESE RATES ARE SCALED IN THE SHORT CYCLE WITH EI*NI
C
C
          IF (LGACX(IATM,0,0).EQ.0) GOTO 51
          IF (NCPVI >= NPLSI) THEN
            DO 52 IACX=1,NACXI(IATM)
              IRCX=LGACX(IATM,IACX,0)
              IPLS=LGACX(IATM,IACX,1)
              IF (LGVAC(IRD,IPLS)) GOTO 52
              IPLSTI= MPLSTI(IPLS)
              EION=1.5*TIIN(IPLSTI,IRD)+EDRIFT(IPLS,IRD)
              WTRSIG=WTR*SIGVCX(IRCX)/DIIN(IPLS,IRD)
              COPV(IPLS,IRDD)=COPV(IPLS,IRDD)+WTRSIG*(E0/EION-1.)
              LMETSP(NMTSP+IPLS)=.TRUE.
52          CONTINUE
          END IF
51        CONTINUE
C
20      CONTINUE
C
C  MOLECULES
      ELSEIF (ITYP.EQ.2) THEN
C
C
C  TEST IONS
C
      ELSEIF (ITYP.EQ.3) THEN
C
C
C
      ENDIF
C
      RETURN
      END
