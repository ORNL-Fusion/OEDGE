**==GMTRY
C
C=======================================================================
      SUBROUTINE GMTRY(NIMP,NINOWA,KINDP,ISHOT,
     &                 FEQUIL,IHCORR,LXTARG,SHFACT)
      IMPLICIT REAL*8(A-H,O-Z)
      LOGICAL LXTARG,LTPC1
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
      INCLUDE 'p09'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
      DIMENSION Y(MY),R(MY),IT(MY)
C
      DIMENSION IROW(MY),YOLD(MY),HOLD(MY),HNEW(MY),ITAGY(MY)
C
      CHARACTER FEQUIL*(*)
C

      LOGICAL LEXIST
C
CPOLY(START)------------------------------------------------------------
C
C../CPOLYG/
      INCLUDE 'c09'
C
CPOLY(END)--------------------------------------------------------------
C                           GEOMETRY
      CALL RESETR(HCORR(1) ,MP,1.0D0)
      CALL RESETI(ITAGDV(1),MP,0    )
C
   20 INGEOM = 4
C
C......................... OPEN EQUILIBRIUM FILE .......................
C
      INQUIRE( FILE=FEQUIL , EXIST=LEXIST )
C
      IF( LEXIST ) THEN
          OPEN( UNIT=INGEOM , FILE=FEQUIL )
      ELSE
          WRITE(MSG1,90380) FEQUIL
          CLOSE (INGEOM)
          CALL ERRMSS(LOUT,'GMTRY',1,MSG1,' ',' ')
      END IF
C
C.......................................................................
C
C                  GEOMETRY FROM EQUILIBRIUM CALCULATION
      CALL GENGEO(INGEOM,
     &            MP,NP,ISYMG,ITAG(1,1),RMESH(1),ZMESH(1),RHO(1),
     &            THETA(1),HRO(1),HTETA(1),BFI(1),SH(1),R0,Z0,NXPNT,
     &            JPLFT,JPRGT,RPX,ZPX,JDO,JUP,IOX,NXW,IREF,JREF,NYREFG,
     &            THETAG(1),IRL,ISHOT,ITAGDV(1),IREFCT,IPWALL,IBSIGN,
     &            FEQUIL)
      IF( NP.GT.MPG ) THEN
          WRITE(LOUT,90400) NP , MPG , NP
          CALL EXITX(LOUT)
      END IF
C
C--------------------------- ANY VIRTUAL RINGS -------------------------
C
      CALL SKORXY(MP,NP,ITAG(1,1),MR,NR,MX,KORX(1,1),NI(1),MC,NC,MY,
     &            KORY(1,1),NJ(1),IO,IW,NI2D,NJ2D,KORXY(1,1),
     &            ILC,JFP,JLP,IFMP,IFPR)
C
C... IVIRT(1) = 1 ---- IF RING # 1     IS VIRTUAL ELSE IVIRT(1) = 0
C... IVIRT(2) = 1 ---- IF RING # NXW   IS VIRTUAL ELSE IVIRT(2) = 0
C... IVIRT(3) = 1 ---- IF RING # NXW+1 IS VIRTUAL ELSE IVIRT(3) = 0
C
      DO 30 L          = 1 , 3
         IF( L.EQ.1 ) THEN
             I         = 1
         ELSE IF( L.EQ.2 ) THEN
             I         = NXW
         ELSE
             I         = NXW + 1
         END IF
         ICOUNT        = 0
         DO 35 J       = 1 , NJ(I)
            K          = KORY(I,J)
            IF( ITAG(K,4).LT.0 ) ICOUNT = ICOUNT + 1
   35    CONTINUE
         IF( ICOUNT.EQ.NJ(I) ) THEN
             IVIRT(L)  = 1
         ELSE
             IVIRT(L)  = 0
         END IF
   30 CONTINUE
C
C     PATCH TO CORRECT HTETA FOR INNER VIRTUAL RING AT J=1 AND J=NY
C
      IF( IVIRT(1).EQ.1 )THEN
          NY  = NJ(1)
          JM1 = NY-1
          KM1 = KORY(1,JM1)
          KK  = KORY(1,NY)
          HTETA(1)  = ( PYTHGS(RMESH(KM1),ZMESH(KM1),RMESH(1),ZMESH(1))
     &                 +PYTHGS(RMESH(1),ZMESH(1),RMESH(2),ZMESH(2))) /
     &                (THETA(2)-THETA(1)+THETA(KK)-THETA(KM1))
          HTETA(KK) = HTETA(1)
      ENDIF
C
CPOLY(START)------------------------------------------------------------
C
      CALL READPG(INGEOM,IFAIL)
      IF( IFAIL.NE.0 )THEN
          CLOSE (INGEOM)
          CALL ERRMSS(LOUT,'GMTRY',1, 'UNABLE TO READ POLYGONS',' ',' ')
      ENDIF
C
CPOLY(END)--------------------------------------------------------------
C
C
C......................... CLOSE EQUILIBRIUM FILE ......................
C
      CLOSE (INGEOM)
C
C.......................................................................
C
C                  ADDITIONAL GEOMETRIC QUANTITIES
C
   40 CONTINUE
C
      IF( SHFACT.NE.1.0D0 ) THEN
          DO 37 K  = 1 , NP
             SH(K) = SH(K) * SHFACT
   37     CONTINUE
      END IF
C
      IF(LXTARG) THEN
CW      WRITE(LOUT,'(1H1,'' OR. TAG  '')')
CW      DO 42 K = 1,NP
CW        WRITE(LOUT,41)K,(ITAG(K,M),M=1,5)
CW 41     FORMAT(I5,')',5(1X,I3))
CW 42   CONTINUE
C       ALLOW X-SWEEP CLOSE TO TARGETS
        DO 44 I = IOX,NC
          NY =NJ(I)
          IF(NY.LE.0) GOTO 44
          DO 43 J=1,NY
            K=KORY(I,J)
            IF(ITAG(K,4).EQ.4) THEN
              ITAG(K,1) = ITAG(K+1,1)
              ITAG(K,2) = ITAG(K+1,2)-1
              ITAG(K,3) = ITAG(K+1,3)
              IF(I.EQ.NXW-1) THEN
                K3=K+NY
                ITAG(K3,1)=ITAG(K,1)+1
                ITAG(K3,2)=ITAG(K,2)
                ITAG(K3,3)=3
              ENDIF
              IF(I.EQ.NXW+2) THEN
                K7=K-NY
                ITAG(K7,1)=ITAG(K,1)-1
                ITAG(K7,2)=ITAG(K,2)
                ITAG(K7,3)=7
              ENDIF
            ENDIF
            IF(ITAG(K,4).EQ.5) THEN
              ITAG(K,1) = ITAG(K-1,1)
              ITAG(K,2) = ITAG(K-1,2)+1
              ITAG(K,3) = ITAG(K-1,3)
              IF(I.EQ.NXW-1) THEN
                K3=K+NY
                ITAG(K3,1)=ITAG(K,1)+1
                ITAG(K3,2)=ITAG(K,2)
                ITAG(K3,3)=3
              ENDIF
              IF(I.EQ.NXW+2) THEN
                K7=K-NY
                ITAG(K7,1)=ITAG(K,1)-1
                ITAG(K7,2)=ITAG(K,2)
                ITAG(K7,3)=7
              ENDIF
            ENDIF
   43     CONTINUE
   44   CONTINUE
        CALL SKORXY(MP,NP,ITAG(1,1),MR,NR,MX,KORX(1,1),NI(1),MC,NC,MY,
     &              KORY(1,1),NJ(1),IO,IW,NI2D,NJ2D,KORXY(1,1),
     &              ILC,JFP,JLP,IFMP,IFPR)
      ENDIF
C
      IF( .FALSE. .AND. NXPNT.EQ.1 )THEN
C                  FORCE NORMAL ON TARGETS (XPOINT)
        CALL SKORXY(MP,NP,ITAG(1,1),MR,NR,MX,KORX(1,1),NI(1),MC,NC,MY,
     &              KORY(1,1),NJ(1),IO,IW,NI2D,NJ2D,KORXY(1,1),
     &              ILC,JFP,JLP,IFMP,IFPR)
        IERR = 0
        DO 50 I = IOX,NC
          NY = NJ(I)
          K = KORY(I,2)
          IF( ITAG(K,4).NE.4 )THEN
            IERR = 1
            WRITE(LOUT,'('' POINT 2 ON COL.'',I3,'' IS NO TARGET'')')I
          ENDIF
          ITAG(K,2) = ITAG(K+1,2)-1
          ITAG(K,3) = ITAG(K+1,3)
          K = KORY(I,NJ(I)-1)
          IF( ITAG(K,4).NE.5 )THEN
            IERR = 1
            WRITE(LOUT,'('' POINT'',I3,'' ON COL.'',
     &            I3,'' IS NO TARGET'')')
     &            NJ(I)-1,I
          ENDIF
          ITAG(K,2) = ITAG(K-1,2)+1
          ITAG(K,3) = ITAG(K-1,3)
          DO 45 J = 3,NJ(I)-2
            K = KORY(I,J)
            IF( ITAG(K,4).EQ.0 )GOTO 45
            WRITE(LOUT,'('' ERROR FOR 1D, COL. = '',
     &            I3,'' ROW='',I3)')I,J
            IERR = 1
   45     CONTINUE
   50   CONTINUE
        IF( IERR.NE.0 )CALL EXITX(LOUT)
      ENDIF
C
      IOPEN = 0
      DO 54 I = 2,NXW
         DO 53 J = 1,NJ(I)
            K = KORY(I,J)
            ITA = ITAG(K,4)
            IF( ITA.EQ.0 ) GOTO 53
            IOPEN = I
            GOTO 55
   53    CONTINUE
   54 CONTINUE
   55 CONTINUE
      NPDISC = 0
      NIMP   = MIN(NIMP,IOPEN-1)
      NINOMP=IOPEN-NIMP-1
CW    WRITE(LOUT,*) ' IOPEN',IOPEN,' NIMP=',NIMP,' NINOMP=',NINOMP
      IF( NINOMP.LE.0 )GOTO 80
C                  DISCARD FIELD LINES TOWARDS BULK PLASMA
      ICOLMP = NINOMP+1
      IF( IVIRT(1).EQ.1 ) ICOLMP = ICOLMP - 1
      IOX = IOX-ICOLMP+1
      NXW = NXW-ICOLMP+1
      IREF = IREF-ICOLMP+1
      KNEW = 0
      DO 60 K = 1,NP
        ICOL = ITAG(K,1)
        IF( ICOL.LT.ICOLMP )GOTO 60
        KNEW = KNEW+1
        ICOLN = ICOL-ICOLMP+1
        ITAG(KNEW,1) = ICOLN
        ITAG(KNEW,2) = ITAG(K,2)
        ITAG(KNEW,3) = ITAG(K,3)
        ITAG(KNEW,4) = ITAG(K,4)
        ITAG(KNEW,5) = ITAG(K,5)
        IF( ICOLN.EQ.1 )THEN
          ITAG(KNEW,3) = 1
          ITAG(KNEW,5) = 1
          IF( IVIRT(1).EQ.1 ) ITAG(KNEW,4) = -1
        ENDIF
        ITAGDV(KNEW) = ITAGDV(K)
        RMESH(KNEW) = RMESH(K)
        ZMESH(KNEW) = ZMESH(K)
        RHO(KNEW) = RHO(K)
        THETA(KNEW) = THETA(K)
        HRO(KNEW) = HRO(K)
        HTETA(KNEW) = HTETA(K)
        BFI(KNEW) = BFI(K)
        SH(KNEW) = SH(K)
   60 CONTINUE
      NPDISC = NP-KNEW
      NP = KNEW
   80 CONTINUE
C
      CALL SKORXY(MP,NP,ITAG(1,1),MR,NR,MX,KORX(1,1),NI(1),MC,NC,MY,
     &            KORY(1,1),NJ(1),IO,IW,NI2D,NJ2D,KORXY(1,1),
     &            ILC,JFP,JLP,IFMP,IFPR)
C     MESH FOR M.C.
      NPMC = NP
      NCMC = NC
C
C
   90 CONTINUE
C     NINOWA GE 0
      ICOLWA = NXW-NINOWA
      IF( ICOLWA.EQ.NXW )GOTO 120
C                  DISCARD FIELD LINES TOWARDS WALL
      IF( ICOLWA.GT.NXW )THEN
        WRITE(LOUT,'('' ERROR: ICOLWA='',I3,'' > NXW='',I3)')
        CALL EXITX(LOUT)
      ENDIF
      IF( IREF.GT.ICOLWA )IREF = IREF-(ICOLWA-NXW)
      KNEW = 0
      DO 100 K = 1,NP
        ICOL = ITAG(K,1)
        IF( ICOL.LT.ICOLWA )THEN
          KNEW = KNEW+1
          GOTO 100
        ENDIF
        IF( ICOL.EQ.ICOLWA )THEN
          KNEW = KNEW+1
          IF( ITAG(KNEW,2).NE.0 )ITAG(KNEW,3) = 3
          IF( ITAG(KNEW,4).EQ.0 )ITAG(KNEW,5) = 3
          IF( ITAG(KNEW,4).EQ.5 )ITAG(KNEW,5) = 53
          IF( ITAG(KNEW,4).EQ.4 )ITAG(KNEW,5) = 43
          GOTO 100
        ENDIF
        IF( ICOL.GT.ICOLWA.AND.ICOL.LE.NXW )GOTO 100
        ICOLN = ICOL-(NXW-ICOLWA)
        KNEW = KNEW+1
        ITAG(KNEW,1) = ICOLN
        ITAG(KNEW,2) = ITAG(K,2)
        ITAG(KNEW,3) = ITAG(K,3)
        ITAG(KNEW,4) = ITAG(K,4)
        ITAG(KNEW,5) = ITAG(K,5)
        ITAGDV(KNEW) = ITAGDV(K)
        RMESH(KNEW) = RMESH(K)
        ZMESH(KNEW) = ZMESH(K)
        RHO(KNEW) = RHO(K)
        THETA(KNEW) = THETA(K)
        HRO(KNEW) = HRO(K)
        HTETA(KNEW) = HTETA(K)
        BFI(KNEW) = BFI(K)
        SH(KNEW) = SH(K)
  100 CONTINUE
      NXW = ICOLWA
      NP = KNEW
  120 CONTINUE
C
      CALL SKORXY(MP,NP,ITAG(1,1),MR,NR,MX,KORX(1,1),NI(1),MC,NC,MY,
     &            KORY(1,1),NJ(1),IO,IW,NI2D,NJ2D,KORXY(1,1),
     &            ILC,JFP,JLP,IFMP,IFPR)
C
C
CPOLY(START)------------------------------------------------------------
C
      NOMP = MAX0( NINOMP-IVIRT(1) , 0 )
      NOWA = MAX0( NINOWA-IVIRT(2) , 0 )
C
      CALL ASSMPG(NOMP,NOWA,NP,RMESH(1),ZMESH(1))
C
CPOLY(END)--------------------------------------------------------------
C
      WRITE(LOUT,90020)NP,NC,NR
C
      IF( ISYMG.EQ.1 )THEN
C                          SYMMETRISE GEOMETRY
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,RMESH(1),ITAG(1,1),
     &              1.0D0)
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,ZMESH(1),ITAG(1,1),
     &              -1.0D0)
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,RHO(1),ITAG(1,1),1.0D0)
        DO 160 I = 1,NC
          N = NJ(I)
          K1 = KORY(I,1)
          KN = KORY(I,N)
          DO 140 J = 2,N/2
            JL = J
            KL = KORY(I,JL)
            JR = N-J+1
            KR = KORY(I,JR)
            TRAN = ((THETA(KL)-THETA(K1))+(THETA(KN)-THETA(KR)))*0.5
            THETA(KL) = THETA(K1)+TRAN
            THETA(KR) = THETA(KN)-TRAN
  140     CONTINUE
          IF( 2*(N/2).NE.N )THEN
            KM = KORY(I,N/2+1)
            KMM1 = KORY(I,N/2)
            KMP1 = KORY(I,N/2+2)
            THETA(KM) = (THETA(KMM1)+THETA(KMP1))*0.5
          ENDIF
  160   CONTINUE
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,HRO(1),ITAG(1,1),1.0D0)
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,HTETA(1),ITAG(1,1),
     &              1.0D0)
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,BFI(1),ITAG(1,1),1.0D0)
        CALL POLSYM(MC,NC,NJ(1),MY,KORY(1,1),MP,SH(1),ITAG(1,1),1.0D0)
        IF( KINDP.GT.0 ) WRITE(LOUT,90040)
      ENDIF
C
      DO 200 J = 1,NR
        IF( KINDP.GT.1 )WRITE(LOUT,90060)J,NI(J),(KORX(J,I),I=1,NI(J))
        IF( NI(J).EQ.0 )GOTO 200
        DO 180 I = 1,NI(J)
          K = KORX(J,I)
          IT(I) = ITAG(K,3)
  180   CONTINUE
        IF( KINDP.GT.1 )WRITE(LOUT,90080)(IT(I),I=1,NI(J))
  200 CONTINUE
C
      IF( NXPNT.EQ.0 )THEN
        NXW = NC
        IOX = 0
        JDO = 1
        JUP = NR-1
      ENDIF
C
      CALL RESETI(IBUF2D(1,1),MX*MY,199999999)
      MAXJ = 0
      IOPEN = 0
      DO 260 I = 1,NC
        MAXJ = MAX0(MAXJ,NJ(I))
        IF( KINDP.GT.1 )WRITE(LOUT,90100)I,NJ(I),(KORY(I,J),J=1,NJ(I))
        IF( I.GT.1 .OR. (I.EQ.1 .AND. IVIRT(1).EQ.0) ) THEN
          DO 220 J = 1,NJ(I)
            K = KORY(I,J)
            IT(J) = ITAG(K,4)
            IF( IOPEN.EQ.0.AND.IT(J).NE.0 )IOPEN = I
  220     CONTINUE
        END IF
        IF( KINDP.GT.1 )WRITE(LOUT,90120)(IT(J),J=1,NJ(I))
        DO 240 J = 1,NJ(I)
          K = KORY(I,J)
          IT(J) = ITAG(K,5)
          IBUF2D(I,J) = IT(J)
  240   CONTINUE
        IF( KINDP.GT.1 )WRITE(LOUT,90140)(IT(J),J=1,NJ(I))
  260 CONTINUE
      IF( KINDP.GT.0 ) WRITE(LOUT,'(/'' FIRST OPEN FIELD LINE'',I3)')
     &        IOPEN
C
      K=KORY(IOPEN,NR/2)
      IOF=ITAG(K,1)
      IF(IOF.NE.IOPEN) THEN
        WRITE(MSG1,*) 'IOPEN=',IOPEN,' IOF=',IOF
        CALL ERRMSS(LOUT,'GMTRY',1,MSG1,' ',' ')
      ENDIF
      DO 263 J=1,NR
        NX=NI(J)
        IOPENX(J)=0
        IF(NX.LE.0) GOTO 263
C       GET THE INDEX OF THE SEPARATRIX FOR THIS NORMAL
        DO 262 I=1,NX
          K=KORX(J,I)
          IF(ITAG(K,1).EQ.IOPEN) IOPENX(J)=I
  262   CONTINUE
        IF( KINDP.GT.0 )
     >      WRITE(LOUT,*) ' JROW =',J,' FIRST POINT IN SOL =',IOPENX(J)
        IF(IOPENX(J).EQ.0) THEN
          CALL ERRMSS(LOUT,'GMTRY',1,
     >               'UNACCEPTABLE FIRST SOL POINT',' ',' ')
        ENDIF
  263 CONTINUE
C
      IF( KINDP.GT.0 )CALL PRI2D(IBUF2D(1,1),MX,NC,MAXJ,'2D-TAG MAP',+1)
C     IF( KINDP.GT.1 )CALL PRI2D(IBUF2D(1,1),MX,NC,MAXJ,'2D-TAG MAP',+1)
C
C     CALL RESETI(IBUF2D(1,1),MX*MY,199999999)
C     MAXJ = 0
C     DO 270 I = 1 , NC
C        MAXJ = MAX0(MAXJ,NJ(I))
C        DO 269 J = 1 , NJ(I)
C           IBUF2D(I,J) = KORY(I,J)
C 269    CONTINUE
C 270 CONTINUE
C     CALL PRI2D(IBUF2D(1,1),MX,NC,MAXJ,'K-MESH CROSS-REFERENCE',+1)
C
C           CHECK L'ESISTENZA DI UN CUSCINETTO PER STAGGERING
      DO 300 I = 1,NC
        DO 280 J = 2,NJ(I)-1
          K = KORY(I,J)
          IT0 = ITAG(K,4)
          ITP = ITAG(K+1,4)
          ITM = ITAG(K-1,4)
          IF( IT0.EQ.4.AND.ITM.GE.0.OR.IT0.EQ.5.AND.ITP.GE.0 )THEN
            WRITE(LOUT,90160)K,I,J
            CALL EXITX(LOUT)
          ENDIF
  280   CONTINUE
  300 CONTINUE
C
C
      FBOH = 1348925.D+46
      CALL RESETR(RHOI(1),MC,FBOH)
      CALL RESETR(THETAJ(1),MR,FBOH)
      DO 320 K = 1,NP
        IC = ITAG(K,1)
        IR = IABS(ITAG(K,2))
C----   IF( IC.GT.NXW )GOTO 320
        IF( IC*IR.NE.0 )THEN
          IF( RHOI(IC).EQ.FBOH )THEN
            RHOI(IC) = RHO(K)
          ELSE
C           CALL EXITX(LOUT)
            IF( IC.LE.NXW .AND. RHOI(IC).NE.RHO(K) .AND. KINDP.GT.0 )
     *          WRITE(LOUT,90180)IC,RHOI(IC),K,RHO(K)
          ENDIF
        ENDIF
        IF( IC.GT.NXW ) GOTO 320
C            IF(IABS(IR).EQ.1) THEN
C                 WRITE(LOUT,115) K,IC,IR,(ITAG(K,M),M=1,4),THETA(K)
C 115             FORMAT(' K=',I3,' IC=',I3,' IR=',I4,' ITAG=',4I5,
C    *                   ' THETA=',1P,E12.3)
C                 ENDIF
        IF( IR.GT.0 )THEN
          IF( THETAJ(IR).EQ.FBOH )THEN
            THETAJ(IR) = THETA(K)
          ELSE
C           CALL EXITX(LOUT)
            IF( THETAJ(IR).NE.THETA(K) .AND. KINDP.GT.0 )
     >          WRITE(LOUT,90200)ITAG(K,2),K
          ENDIF
        ENDIF
  320 CONTINUE
      IF( KINDP.GT.1 )CALL PRRVEC(LOUT,RHOI(1),NC,'RHO VS. COLUMN')
      DO 340 I = NXW+1,MC
C     RHOI(I)=UCRAY
  340 CONTINUE
      IF( KINDP.GT.1 )CALL PRRVEC(LOUT,THETAJ(1),NR,'THETA VS. ROW')
      DO 360 J = NR+1,MR
C     THETAJ(J)=UCRAY
  360 CONTINUE
      IF( NXPNT.EQ.1 )THEN
        DO 380 J = 1,NYREFG
          IF( THETAJ(J).EQ.FBOH )THETAJ(J) = THETAG(J)
          IF( THETAJ(J).NE.THETAG(J) .AND. KINDP.GT.0 )
     >       WRITE(LOUT,90220)J
  380   CONTINUE
        IF( KINDP.GT.1 )CALL PRRVEC(LOUT,THETAJ(1),NYREFG,
     &                              'THETA VS. ROW   (FROM FILE)')
      ENDIF
C
C
      IF( IRL.EQ.1 )GOTO 620
C     CALL PRNT2D(DTHETA(1),'DTHETA MESH PRIMA DELLA REGOL.')
C                     REGOLARIZZA THETA,HTHETA VICINO ALLE TARGHETTE
C                     (PER COMPATIBILITA' CON VECCHI EQUILIBRI)
      IF( KINDP.GT.0 ) WRITE(LOUT,90240)
      DO 600 I = 1,NC
        NY = NJ(I)
        DO 400 J = 1,NY
          K = KORY(I,J)
          ITAGY(J) = ITAG(K,4)
          IROW(J) = ITAG(K,2)
          YOLD(J) = THETA(K)
          Y(J) = YOLD(J)
          HOLD(J) = HTETA(K)
          HNEW(J) = HOLD(J)
  400   CONTINUE
        J = 0
  420   J = J+1
        IF( J.GT.NY )GOTO 560
        IF( ITAGY(J).EQ.5.AND.IROW(J-1).EQ.0 )THEN
          L = J
  440     L = L-1
          IF( IROW(L).EQ.0 )GOTO 440
C       DYP=(YOLD(L+1)-YOLD(L))*0.5
C       DYM=(YOLD(L)-YOLD(L-1))*0.5
C       DYOLD=DYP+DYM
C       DYNEW=DYM*2.0
C       DYMOR=(DYNEW-DYOLD)*2.0
          DYMOR = THETAJ(IROW(L)+1)-YOLD(L+1)
C       WRITE(LOUT,1155) I,L,IROW(L),ITAGY(L),
C    *         YOLD(L-1),YOLD(L),YOLD(L+1)
C1155   FORMAT(' I=',I2,' J=',I2,' IROW=',I2,' ITAG=',I2,
C    *         ' YOLD=',1P,3E12.3)
          DO 460 M = L+1,J+1
            Y(M) = YOLD(M)+DYMOR
C       WRITE(LOUT,1156)   M,IROW(M),ITAGY(M),YOLD(M),Y(M)
C1156   FORMAT( 5X,     ' J=',I2,' IROW=',I2,' ITAG=',I2,
C    *         ' YOLD=',1P,E12.3,' YNEW=',E12.3)
  460     CONTINUE
          DO 480 M = L,J-1
            HNEW(M) = HOLD(M)*((YOLD(M+1)-YOLD(M-1))/(Y(M+1)-Y(M-1)))
  480     CONTINUE
        ENDIF
        IF( ITAGY(J).EQ.4.AND.IROW(J+1).EQ.0 )THEN
          L = J
  500     L = L+1
          IF( IROW(L).EQ.0 )GOTO 500
C       DYP=(YOLD(L+1)-YOLD(L))*0.5
C       DYM=(YOLD(L)-YOLD(L-1))*0.5
C       DYOLD=DYP+DYM
C       DYNEW=DYP*2.0
C       DYMOR=(DYNEW-DYOLD)*2.0
          DYMOR = YOLD(L-1)-THETAJ(IROW(L)-1)
C       WRITE(LOUT,1155) I,L,IROW(L),ITAGY(L),YOLD(L-1),YOLD(L),YOLD(L+1)
          DO 520 M = L-1,J-1,-1
            Y(M) = YOLD(M)-DYMOR
C       WRITE(LOUT,1156)   M,IROW(M),ITAGY(M),YOLD(M),Y(M)
  520     CONTINUE
          DO 540 M = L,J+1,-1
            HNEW(M) = HOLD(M)*((YOLD(M+1)-YOLD(M-1))/(Y(M+1)-Y(M-1)))
  540     CONTINUE
        ENDIF
        GOTO 420
  560   DO 580 J = 1,NY
          K = KORY(I,J)
          THETA(K) = Y(J)
          HTETA(K) = HNEW(J)
  580   CONTINUE
  600 CONTINUE
  620 CONTINUE
C
      CALL RESETR(DRHO(1),MP,UCRAY)
      CALL RESETR(DTHETA(1),MP,UCRAY)
      DO 700 I = 1,NC
        NY = NJ(I)

        DO 640 J = 1,NY
          K = KORY(I,J)
          Y(J) = THETA(K)
  640   CONTINUE
        DO 680 J = 1,NY
          K = KORY(I,J)
          IT(J) = ITAG(K,4)
          IF(J.EQ.1  .OR. J.EQ.NY) DY=((Y(2)-Y(1))+(Y(NY)-Y(NY-1)))*0.5
          IF(J.GT.1 .AND. J.LT.NY) DY = (Y(J+1)-Y(J-1))*0.5
          DTHETA(K) = DY
          IF(I.EQ.1 .OR. I.EQ.NXW .OR. I.EQ.NXW+1) GOTO 680
          IF(ITAG(K,4).LT.0) GOTO 680
          RO = RHO(K)
          ROL = -1.0E+30
          ROR = +1.0E+30
          DO 660 L = 1,NC
            IF(RHOI(L).LT.RO .AND. RHOI(L).GT.ROL) ROL = RHOI(L)
            IF(RHOI(L).GT.RO .AND. RHOI(L).LT.ROR) ROR = RHOI(L)
  660     CONTINUE
          DX = (ROR-ROL)*0.5
          IF(ROL.EQ.-1.0E+30) DX = (ROR-RO)*2.0
          IF(ROR.EQ.+1.0E+30) DX = (RO-ROL)*2.0
          DRHO(K) = DX
          N = KORPG(K)
          IF( N.LE.0 ) THEN
            WRITE(LOUT,90360) I,J,K
            CALL EXITX(LOUT)
          ENDIF
          AREAK = AREAP(N)
C          FORCE EQUALITY OF AREAS
          IF(IHCORR.EQ.3) HRO(K)   = AREAK/(HTETA(K)*DY*DX)
          IF(IHCORR.EQ.2) HTETA(K) = AREAK/(HRO(K)*DY*DX)
          IF(IHCORR.EQ.1) HCORR(K) = AREAK/(HRO(K)*DX*HTETA(K)*DY)
C         IF(IHCORR.EQ.0) CORRECT SOURCES
CW        WRITE(LOUT,747) K,I,J,ROL,RO,ROR,HRO(K)*DX,
CW   *               THETA(K-1),THETA(K),THETA(K+1),HTETA(K)*DY
CW747    FORMAT(' K=',I3,' I=',I2,' J=',I2,' X=',1P,4E12.3,' Y=',4E12.3)
  680   CONTINUE
C               PATCH FOR ITAGX=2
        DO 690 J = 1,NY
          K = KORY(I,J)
          ITAG3 = ITAG(K,3)
          IF( ITAG3.EQ.0 )DRHOCO = DRHO(K)
          IF( ITAG3.EQ.2 )DRHO(K) = DRHOCO
  690   CONTINUE
  700 CONTINUE
C                NO PARALLEL TRANSPORT ON RINGS  1, NXW, NXW+1
C                                         ITAGX  1    3      7
      DO 704 I=1,NC
        IF( I.EQ.1 .OR. I.EQ.NXW .OR. I.EQ.NXW+1) THEN
          NY=NJ(I)
          IF(NY.LE.0) GOTO 704
          DO 703 J=1,NY
            K=KORY(I,J)
            ITAG(K,4)=-1
            ITAG(K,5)=-1
  703     CONTINUE
        ENDIF
  704 CONTINUE
C
      CALL RESETR( BUFFER(1) , MP , 0.00D+00 )
      IF( KINDP.GT.0 ) WRITE(LOUT,705)
      DO 710   I     = 1 , NC
        SPAR         = 0.00D+00
        SPOL         = 0.00D+00
        DO 712 J     = 1 , NJ(I)
           K         = KORY(I,J)
           IF( J.GT.1 ) THEN
               SPAR  = SPAR + HTETA(K)*DTHETA(K)
               SPOL  = SPOL + HTETA(K)*DTHETA(K)/SH(K)
           END IF
           IF( KINDP.GT.0 ) THEN
               IF(MOD(K,61).EQ.0 ) WRITE(LOUT,705)
               WRITE(LOUT,706) K,(ITAG(K,M),M=1,5),
     *                      RMESH(K),ZMESH(K),RHO(K),THETA(K),
     *                      HRO(K),HTETA(K),BFI(K),SH(K),SPAR,SPOL
           END IF
  712    CONTINUE
  710 CONTINUE
  705   FORMAT('1   K','       TAG',7X,'     R      ','    Z      '
     *  ,'   RHO     ','  THETA    ','  HRHO     ','  HTHETA   ',
     *   '   BPHI    ',' BTHETA/B'  , '   POL.DIST' , '   PAR.DIST' )
  706   FORMAT(I5,')',5(I3),1P,10E11.3)
C
CW    CALL PRNT2D(DRHO(1),'DRHO MESH')
CW    CALL PRNT2D(DTHETA(1),'DTHETA MESH')
C
C     COMPUTE WIDTH DELX OF COLUMNS (CONSTANT IN THE TUBE)
      DO 714 I = 1,NC
        DELXI(I) = 0.0D0
        NY = NJ(I)
        IF( NY.LE.0 )GOTO 714
        L = 0
  713   L = L+1
        IF(L.GT.NY) GOTO 714
        K = KORY(I,L)
        IF( ITAG(K,3).LT.0 .OR. ITAG(K,3).GT.7 ) GOTO 713
CW      WRITE(LOUT,*) ' ICOL=',I, ' L=',L,' ITAG3=',ITAG(K,3)
        DELXI(I) = DRHO(K)
  714 CONTINUE
      IF( KINDP.GT.0 ) CALL PRRVEC(LOUT,DELXI(1),NC,'DRHO VS. COLUMN')
C     COMPUTE WIDTH DELY OF ROWS    (CONSTANT IN THE TUBE)
      DO 717 J = 1,NR
        DELYJ(J) = 0.0D0
        NX = NI(J)
        IF( NX.LE.0 )GOTO 717
        L = 0
  716   L = L+1
        IF(L.GT.NX) GOTO 717
        K = KORX(J,L)
        IF( ITAG(K,4).LT.0 .OR. ITAG(K,4).GT.5 ) GOTO 716
        DELYJ(J) = DTHETA(K)
  717 CONTINUE
      IF( KINDP.GT.0 ) CALL PRRVEC(LOUT,DELYJ(1),NR,'DTHETA VS. ROW')
C
      IF( .TRUE. )GOTO 840
      DO 760 J = 1,NR
        NX = NI(J)
        IF( NX.LE.0 )GOTO 760
        DO 720 I = 1,NX
          K = KORX(J,I)
          BUFFER(I) = DRHO(K)
          IT(I) = ITAG(K,3)
          Y(I) = RHO(K)
  720   CONTINUE
        DO 740 I = 1,NX
          IP1 = MIN0(I+1,NX)
          IM1 = MAX0(I-1,1)
          IF( IT(I).EQ.1.OR.IT(I).EQ.7 )IM1 = I
          IF( IT(1).EQ.3.OR.IT(I).EQ.2 )IP1 = I
          BUFFER(NX+I) = (Y(IP1)-Y(IM1))*0.5
  740   CONTINUE
        IF( KINDP.GT.0 )
     >      WRITE(LOUT,90260)J,(I,BUFFER(I),BUFFER(NX+I),I=1,NX)
  760 CONTINUE
      DO 820 I = 1,NC
        NY = NJ(I)
        DO 780 J = 1,NY
          K = KORY(I,J)
          BUFFER(J) = DTHETA(K)
          IT(J) = ITAG(K,4)
          Y(J) = THETA(K)
  780   CONTINUE
        DO 800 J = 1,NY
          JP1 = MIN0(J+1,NY)
          JM1 = MAX0(J-1,1)
          IF( IT(J).EQ.4 )JM1 = J
          IF( IT(J).EQ.5 )JP1 = J
          BUFFER(NY+J) = (Y(JP1)-Y(JM1))*0.5
          IF( J.EQ.1.AND.IT(J).EQ.0 )BUFFER(NY+J) = ((Y(2)-Y(1))+(Y(NY)-
     &                                              Y(NY-1)))*0.5
          IF( J.EQ.NY.AND.IT(J).EQ.0 )BUFFER(NY+J) = ((Y(2)-Y(1))+(Y(NY)
     &                                               -Y(NY-1)))*0.5
  800   CONTINUE
        IF( KINDP.GT.0 )
     >      WRITE(LOUT,90280)I,(J,BUFFER(J),BUFFER(NY+J),J=1,NY)
  820 CONTINUE
  840 CONTINUE
C
      DO 900 J = 1,NR
        IF( NI(J).EQ.0 )GOTO 900
        DO 860 I = 1,NI(J)
          K = KORX(J,I)
          BUFFER(I) = DTHETA(K)
  860   CONTINUE
        TRAN = BUFFER(1)
        ISENT = 0
        DO 880 I = 2,NI(J)
          IF( BUFFER(I).NE.TRAN )ISENT = 1
  880   CONTINUE
        IF( ISENT.NE.0.AND.KINDP.GT.0 )
     >      WRITE(LOUT,90300)J,(BUFFER(I),I=1,NI(J))
  900 CONTINUE
      DO 960 I = 1,NC
        TRAN = 1.0D+30
        DO 920 J = 1,NJ(I)
          K = KORY(I,J)
          BUFFER(J) = DRHO(K)
          IF( ITAG(K,4).GE.0) TRAN = BUFFER(J)
  920   CONTINUE
        ISENT = 0
        DO 940 J = 1,NJ(I)
          IF( BUFFER(J).NE.TRAN .AND. ITAG(KORY(I,J),4).GE.0 ) ISENT = 1
  940   CONTINUE
        IF( ISENT.NE.0.AND.KINDP.GT.0 )
     >      WRITE(LOUT,90320)I,(BUFFER(J),J=1,NJ(I))
  960 CONTINUE
C
 1040 CONTINUE
C
      CALL RESETI(KY(1),MP,0)
      DO 1080 I = 1,NC
        NY = NJ(I)
        DO 1060 J = 1,NY
          K = KORY(I,J)
          KY(K) = J
 1060   CONTINUE
 1080 CONTINUE
      CALL RESETI(KX(1),MP,0)
      DO 1120 J = 1,NR
        NX = NI(J)
        IF( NX.LE.0 )GOTO 1120
        DO 1100 I = 1,NX
          K = KORX(J,I)
          KX(K) = I
 1100   CONTINUE
 1120 CONTINUE
C
      DO 1140 K = 1,NP
        H(K) = HRO(K)*HTETA(K)*RMESH(K)*HCORR(K)
        DRDTET(K) = UCRAY
 1140 CONTINUE
      DO 1200 I = 1,NC
        NY = NJ(I)
        DO 1160 J = 1,NY
          K = KORY(I,J)
          Y(J) = THETA(K)
          R(J) = RMESH(K)
          IT(J) = ITAG(K,4)
 1160   CONTINUE
        DO 1180 J = 1,NY
          K = KORY(I,J)
          JP1 = MIN0(NY,J+1)
          JP1 = ICVMGT(J,JP1,IT(JP1).LT.0.OR.IT(J).EQ.5)
          JM1 = MAX0(1,J-1)
          JM1 = ICVMGT(J,JM1,IT(JM1).LT.0.OR.IT(J).EQ.4)
          DY = Y(JP1)-Y(JM1)
          DY = CVMGT(DY,1.0D0,JP1.NE.JM1)
          DRDTET(K) = (R(JP1)-R(JM1))/DY
 1180   CONTINUE
 1200 CONTINUE
C
      CALL NEIGHB(MP,NP,RMESH(1),ZMESH(1),ITAG(1,1),MR,NR,MX,NI(1),
     &            KORX(1,1),MC,NC,MY,NJ(1),KORY(1,1),KNORTH(1),KEAST(1),
     &            KSOUTH(1),KWEST(1),WNORTH(1),WEAST(1),WSOUTH(1),
     &            WWEST(1))
C
C.................... CONSTRUCT ACTUAL SEPARATRIX ......................
C
      I           = LCFSPG + 1
C
      L           = 1
      DO 1300 J   = NJPOLY(I) , 1 , -1
         L        = L + 1
         RSEPX(L) = RPOLY(I,J)
         ZSEPX(L) = ZPOLY(I,J)
 1300 CONTINUE
C
      L           = 1
      K1          = KORY(IOPEN,1        )
      K2          = KORY(NC   ,1        )
      RSEPX(L)    = ( RMESH(K1) + RMESH(K2) ) * 5.00D-01
      ZSEPX(L)    = ( ZMESH(K1) + ZMESH(K2) ) * 5.00D-01
      RSEPX(L)    = RSEPX(L+1) + (RSEPX(L)-RSEPX(L+1))*1.00D+01
      ZSEPX(L)    = ZSEPX(L+1) + (ZSEPX(L)-ZSEPX(L+1))*1.00D+01
C
      L           = NJPOLY(I)+2
      K1          = KORY(IOPEN,NJ(IOPEN))
      K2          = KORY(NC   ,NJ(NC)   )
      RSEPX(L)    = ( RMESH(K1) + RMESH(K2) ) * 5.00D-01
      ZSEPX(L)    = ( ZMESH(K1) + ZMESH(K2) ) * 5.00D-01
      RSEPX(L)    = RSEPX(L-1) + (RSEPX(L)-RSEPX(L-1))*1.00D+01
      ZSEPX(L)    = ZSEPX(L-1) + (ZSEPX(L)-ZSEPX(L-1))*1.00D+01
C
      NSEPX       = NJPOLY(I)+2
C
C.............. MAX VERTEX POINTS ON OUTER/INNER TARGETS ...............
C
      IF( NXPNT.EQ.1 ) CALL MARKPG
C
C.......................................................................
C
      RETURN
C
90020 FORMAT(/' NUMBER OF    POINTS ',I4/'    "   "  PARALLELS ',
     &       I4/'    "   "    NORMALS ',I4)
90040 FORMAT(/' THE GEOMETRY HAS BEEN UP/DOWN SYMMETRISED'/)
90060 FORMAT(' J=',I3,' NI(J)=',I3,'   KORX:',20I5/(24X,20I5))
90080 FORMAT(16X,'  ITAGX:',20I5/(24X,20I5))
90100 FORMAT(' I=',I3,' NJ(I)=',I3,'   KORY:',20I5/(24X,20I5))
90120 FORMAT(16X,'  ITAGY:',20I5/(24X,20I5))
90140 FORMAT(16X,' ITAGMC:',20I5/(24X,20I5))
90160 FORMAT(/' ERROR IN ITAG AT K=',I4,' I=',I3,' J=',I3)
90180 FORMAT(' INCONSISTENT RHO MESH, ',' RHOI(',I2,')=',1P,E12.4,
     &       '  RHO(',I4,')=',E12.3)
90200 FORMAT(' INCONSISTENT THETA MESH,  IR=',I3,' K=',I4)
90220 FORMAT(' WARNING: INCONSISTENCY AT THETA(',I2,')')
90240 FORMAT(/' HTHETA BEING REGULARISED NEAR TARGETS')
90260 FORMAT(' J=',I3,' DRHO'/(5X,I5,1P,2E12.3))
90280 FORMAT(' I=',I3,' DTHETA'/(5X,I5,1P,2E12.3))
90300 FORMAT(' INCONSISTENT DTHETA ALONG ROW',I3/(1P,10E12.3))
90320 FORMAT(' INCONSISTENT DRHO ALONG COLUMN',I3/(1P,10E12.3))
90340 FORMAT(/' NO PERPENDICULAR TRANSPORT IN THE PRIVATE REGION')
90360 FORMAT(/' ***ERROR***  UNDEFINED PLASMA POLYGON FOR',
     *        ' I=',I3,' J=',I3,' K=',I5)
90380 FORMAT( 'UNABLE TO OPEN EQUILIBRIUM FILE :-'
     *         , A )
90400 FORMAT( // ' **** ERROR **** NO. OF MESH POINTS (', I6
     *         , ') .GT. MAX. NO. OF POLYGONS (' , I6 , ')'
     *   / 17X , 'INCREASE MPG IN /CPOLY/ TO, AT LEAST, ' , I6 , ' AND'
     *   / 17X , 'INCREASE MRG IN NIMBUS  TO, AT LEAST, MPG+2' // )
      END
**++EOF
**==NEIGHB
C
C=======================================================================
      SUBROUTINE NEIGHB(MP,NP,R,Z,ITAG,MR,NR,MX,NI,KORX,MC,NC,MY,NJ,
     &                  KORY,KNORTH,KEAST,KSOUTH,KWEST,WN,WE,WS,WW)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION R(NP),Z(NP),ITAG(MP,5),NI(NR),KORX(MR,MX),NJ(NC),
     &          KORY(MC,MY),KNORTH(NP),KEAST(NP),KSOUTH(NP),KWEST(NP),
     &          WN(NP),WE(NP),WS(NP),WW(NP)
C
      DATA JUNK/-999999999/
C
      DO 20 K = 1,NP
        KNORTH(K) = JUNK
        KEAST(K) = JUNK
        KSOUTH(K) = JUNK
        KWEST(K) = JUNK
   20 CONTINUE
C
      DO 60 J = 1,NR
        NX = NI(J)
        IF( NX.LE.0 )GOTO 60
        K = KORX(J,1)
        KEAST(K) = KORX(J,2)
        KWEST(K) = 0
        DO 40 I = 2,NX-1
          K = KORX(J,I)
          KEAST(K) = KORX(J,I+1)
          KWEST(K) = KORX(J,I-1)
   40   CONTINUE
        K = KORX(J,NX)
        KEAST(K) = 0
        KWEST(K) = KORX(J,NX-1)
   60 CONTINUE
C
      DO 120 I = 1,NC
        NY = NJ(I)
        IF( NY.LE.0 )GOTO 120
        K = KORY(I,1)
        IF( ITAG(K,4).LT.0 )THEN
          KNORTH(K) = 0
          KSOUTH(K) = 0
          GOTO 80
        ENDIF
        KNORTH(K) = KORY(I,2)
        KSOUTH(K) = 0
        IF( ITAG(K,4).EQ.0 )KSOUTH(K) = KORY(I,NY-1)
   80   DO 100 J = 2,NY-1
          K = KORY(I,J)
          KNORTH(K) = ICVMGT(0,KORY(I,J+1),ITAG(K,4).EQ.5.OR.ITAG(K,4)
     &                .EQ.-1)
          KSOUTH(K) = ICVMGT(0,KORY(I,J-1),ITAG(K,4).EQ.4.OR.ITAG(K,4)
     &                .EQ.-1)
  100   CONTINUE
        K = KORY(I,NY)
        IF( ITAG(K,4).LT.0 )THEN
          KNORTH(K) = 0
          KSOUTH(K) = 0
          GOTO 120
        ENDIF
        IF( ITAG(KORY(I,1),4).EQ.0 )KNORTH(K) = KORY(I,2)
        KSOUTH(K) = KORY(I,NY-1)
  120 CONTINUE
C
      DO 180 K = 1,NP
C     EXTERNAL POINT
        IF( ITAG(K,4).LT.0 )GOTO 180
C     PERIODIC POINT (SEE LATER)
        IF( ITAG(K,2).LT.0 )GOTO 180
        IF( ITAG(K,2).GT.0 )GOTO 180
        KWEST(K) = 0
        DW = 1.0E+30
        KEAST(K) = 0
        DE = 1.0E+30
        DO 160 L = 1,NP
          IF( ITAG(L,1).EQ.ITAG(K,1) )GOTO 160
          IF( ITAG(L,4).LT.0 )GOTO 160
          D = (R(L)-R(K))**2+(Z(L)-Z(K))**2
          IF( ITAG(K,3).EQ.1.OR.ITAG(K,3).EQ.7.OR.ITAG(L,1).GT.ITAG(K,1)
     &         )GOTO 140
          IF( D.LT.DW )THEN
            DW = D
            KWEST(K) = L
          ENDIF
  140     CONTINUE
          IF( ITAG(K,3).EQ.2.OR.ITAG(K,3).EQ.3.OR.ITAG(L,1).LT.ITAG(K,1)
     &         )GOTO 160
          IF( D.LT.DE )THEN
            DE = D
            KEAST(K) = L
          ENDIF
  160   CONTINUE
  180 CONTINUE
C
      DO 240 K = 1,NP
        IF( ITAG(K,2).GE.0 )GOTO 240
C     PERIODIC POINT
        K1 = K
  200   K1 = K1-1
        IF( K1.EQ.0 )GOTO 220
        IF( ITAG(K1,1).NE.ITAG(K,1) )GOTO 220
        GOTO 200
  220   K1 = K1+1
        KNORTH(K) = KNORTH(K1)
        KEAST(K) = KEAST(K1)
        KSOUTH(K) = KSOUTH(K1)
        KWEST(K) = KWEST(K1)
  240 CONTINUE
C
C     WEIGHTS FOR INTERPOLATION ARE INVERSELY PROPORTIONAL TO DISTANCE
      DO 260 K = 1,NP
        WN(K) = 0.0
        WE(K) = 0.0
        WS(K) = 0.0
        WW(K) = 0.0
        L = KNORTH(K)
        IF( L.GT.0 )WN(K) = 1.0/DSQRT((R(K)-R(L))**2+(Z(K)-Z(L))**2)
        L = KEAST(K)
        IF( L.GT.0 )WE(K) = 1.0/DSQRT((R(K)-R(L))**2+(Z(K)-Z(L))**2)
        L = KSOUTH(K)
        IF( L.GT.0 )WS(K) = 1.0/DSQRT((R(K)-R(L))**2+(Z(K)-Z(L))**2)
        L = KWEST(K)
        IF( L.GT.0 )WW(K) = 1.0/DSQRT((R(K)-R(L))**2+(Z(K)-Z(L))**2)
        SUM = WN(K)+WE(K)+WS(K)+WW(K)
        IF( SUM.LE.0.0 )GOTO 260
        WN(K) = WN(K)/SUM
        WE(K) = WE(K)/SUM
        WS(K) = WS(K)/SUM
        WW(K) = WW(K)/SUM
  260 CONTINUE
C
      RETURN
      END
**++EOF
**==GENGEO
C
C=======================================================================
      SUBROUTINE GENGEO(INGEOM,
     &                  MPL,NP,ISYMG,ITAG,RMESH,ZMESH,RHO,THETA,HRO,
     &                  HTETA,BFI,SH,R0,Z0,NXPNT,JPLFT,JPRGT,RPX,ZPX,
     &                  JDO,JUP,IOX,NXW,IREF,JREF,NYREFG,THETAG,IRL,
     &                  ISHOT,ITAGDV,IREFCT,IPWALL,IBSIGN,FEQUIL)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION ITAG(MPL,5),RMESH(MPL),ZMESH(MPL)
     &          ,RHO(MPL),THETA(MPL),HRO(MPL)
     &          ,HTETA(MPL),BFI(MPL),SH(MPL),THETAG(1),ITAGDV(MPL)
C
      CHARACTER FEQUIL*(*) , STRING*72
C
      INCLUDE 'p01'
      INCLUDE 'p02'
C../SHOTD/
      INCLUDE 'c10'
C../PSIDAT/
      INCLUDE 'c11'
C
C                         GEOMETRY DATA FROM EQUILIBRIUM
      REWIND INGEOM
      READ(INGEOM,90060)NP,ISYMG,NSHOT,TSHOT,R0,Z0,B0,NXPNT,IRL
CX    IF( ISHOT.GT.0 .AND. NSHOT.NE.ISHOT ) THEN
CX      WRITE(LOUT,90130) NSHOT,ISHOT
CX      CALL EXITX(LOUT)
CX    ELSE
CX      ISHOT = NSHOT
CX    ENDIF
C
      IF( ISHOT.GT.0 .AND. ISHOT.NE.NSHOT ) THEN
          TSHOT = 0.00D+00
      ELSE
          ISHOT = NSHOT
      END IF
C
      WRITE(LOUT,90080)ISHOT,TSHOT,FEQUIL
      IF( NP.GT.MPL )THEN
        WRITE(LOUT,
     &'('' GEOMETRY DIMENSIONS EXCEEDED:'',          '' MP='',I5,'' NP='
     &',I5)')MPL,NP
        CLOSE (INGEOM)
        CALL EXITX(LOUT)
      ENDIF
      IF( NXPNT.NE.0 )THEN
        READ(INGEOM,90100)JPLFT,JPRGT,RPX,ZPX,JDO,JUP,IOX,NXW,IREF,JREF
        READ(INGEOM,90110)NYREFG,IREFCT,SCALE,IPWALL,IBSIGN
        READ(INGEOM,90040)(THETAG(J),J=1,NYREFG)
        WRITE(LOUT,90120) JPRGT,JPLFT
      ENDIF
      READ(INGEOM,90020)((ITAG(K,L),L=1,5),K=1,NP)
      READ(INGEOM,90040)(RMESH(K),K=1,NP)
      READ(INGEOM,90040)(ZMESH(K),K=1,NP)
      READ(INGEOM,90040)(RHO(K),K=1,NP)
      READ(INGEOM,90040)(THETA(K),K=1,NP)
      READ(INGEOM,90040)(HRO(K),K=1,NP)
      READ(INGEOM,90040)(HTETA(K),K=1,NP)
      READ(INGEOM,90040)(BFI(K),K=1,NP)
      READ(INGEOM,90040)(SH(K),K=1,NP)
C
      DO 20 ISEACH = 1 , 2
    5    READ(INGEOM,90140,END=15) STRING
         IF( ISEACH.EQ.1 .AND. STRING(1:3).EQ.'PSI' ) THEN
             READ(INGEOM,90160) (FLXPSI(K),K=1,NP)
             GOTO 20
         ELSE IF( ISEACH.EQ.2 .AND. STRING(1:6).EQ.'ITAGDV' ) THEN
             READ(INGEOM,90150) (ITAGDV(K),K=1,NP)
             GOTO 20
         ELSE
             GOTO 5
         END IF
   15    REWIND INGEOM
   20 CONTINUE
C
      REWIND INGEOM
C             CGS
      DO 40 K = 1,NP
        RMESH(K) = RMESH(K)*1.0E+2
        ZMESH(K) = ZMESH(K)*1.0E+2
        RHO(K) = RHO(K)*1.0E+2
        THETA(K) = THETA(K)*1.0E+2
        BFI(K) = BFI(K)*1.0E+4
   40 CONTINUE
      IF( NXPNT.NE.0 )THEN
        DO 60 J = 1,NYREFG
          THETAG(J) = THETAG(J)*1.0E+2
   60   CONTINUE
      ENDIF
      R0 = R0*1.0E+02
      Z0 = Z0*1.0E+02
      B0 = B0*1.0E+04
      IF( NXPNT.NE.0 )THEN
        RPX = RPX*1.0E+02
        ZPX = ZPX*1.0E+02
      ENDIF
C
      RETURN
C
C
90020 FORMAT(/(12I6))
90040 FORMAT(/(1P,6E12.4))
90060 FORMAT(/2I6,I8,E10.0,3E11.0,I6,I3)
90080 FORMAT(/' SHOT NO.',I6,' AT ',F5.1,' S',
     *        ' FROM FILE : ' , A )
90100 FORMAT(/2I6,2E12.0,6I6)
90110 FORMAT(/2I6, E12.0,6I6)
90120 FORMAT(/' SINGLE- NULL'/
     *        ' FIRST NORMALS UNCONNECTED TO PRIVATE REGION',2I3)
90130 FORMAT(' *** ERROR ***  MISMATCH OF SHOT NUMBERS',2I7)
90140 FORMAT( A )
90150 FORMAT( (12I6) )
90160 FORMAT( (1P,6E12.4) )
      END
**++EOF
**==SKORXY
C
C=======================================================================
      SUBROUTINE SKORXY(MP,NP,ITAG,MR,NR,MX,KORX,NI,MC,NC,MY,KORY,NJ,
     *        IO,IW,NI2D,NJ2D,KORXY,ILC,JFP,JLP,IFMP,IFPR)
C
      IMPLICIT REAL*8(A-H,O-Z)
      INCLUDE 'plun'
C
      DIMENSION ITAG(MP,5),KORX(MR,MX),NI(MR),KORY(MC,MY),NJ(MC),
     *          KORXY(MC,MR)
C
C I            NP = NUMBER OF POINTS
C I     ITAG(K,1) = INDEX OF FLUX LINE  ( <= NC )
C              2  =   "    " NORMAL TO FLUX LINES  ( <= NR )
C                   (=0 IF NO SWEEP IN RHO-DIRECTION)
C                   (-INDEX OF NORMAL  IF PERIODIC POINT AT THE TOP)
C              3  = TAG FOR X SWEEP
C              4  =  "   "  Y   "
C              5  =  "   "  M.C.
C I            MR = MAXIMUM NUMBER OF ROWS (= NORMAL TO FLUX LINES)
C O            NR = NUMBER OF ROWS
C I            MX = MAXIMUM NUMBER OF POINTS ALONG RHO
C O     KORX(J,I) = LOCATION IN VECTORS SUCH AS ITAG OF THE I-TH
C                   ELEMENT FOR SWEEPING ALONG X OF THE J-TH ROW
C O         NI(J) = NUMBER OF ELEMENTS IN ROW J
C I            MC = MAXIMUM NUMBER OF COLUMNS (= FLUX LINES)
C O            NC = NUMBER OF COLUMNS
C I            MY = MAXIMUM NUMBER OF POINTS ALONG THETA
C O     KORY(I,J) = LOCATION IN VECTORS SUCH AS ITAG OF THE J-TH
C                   ELEMENT FOR SWEEPING ALONG Y OF THE I-TH COLUMN
C O         NJ(I) = NUMBER OF ELEMENTS IN ROW I
C O            IO = FIRST OPEN FLUX LINE
C O            IW = WALL
C O          NI2D = NUMBER OF POINTS ALONG X FOR THE 2D MAP
C O          NJ2D = NUMBER OF POINTS ALONG Y FOR THE 2D MAP
C O    KORXY(I,J) = LOCATION IN VECTORS FOR THE (I,J)-TH 2D POINT
C O           ILC = LAST CLOSED I-LINE (2D)
C O           JFP = FIRST PERIODIC J-LINE (2D)
C O           JLP = LAST  PERIODIC J-LINE (2D)
C O           IFMP= FIRST MAIN PLASMA I LINE (2D)
C O           IFPR= FIRST PRIVATE LINE (2D)
C
C     COMPUTE NR,NC AND CHECK THAT THE WORM IS GIVEN BY COLUMNS
C     COMPUTE ALSO IO,IW
C
      NC = 0
      NR = 0
      IO = 0
      IW = 0
      I0 = ITAG(1,1)
      J0 = ITAG(1,2)
      DO 80 K = 2,NP
        I = ITAG(K,1)
        NC = MAX0(NC,I)
        J = ITAG(K,2)
        NR = MAX0(NR,IABS(J))
        IF( I.GT.MC.OR.J.GT.MR )GOTO 100
        IF( I-I0 )100,20,40
   20   IF( J.LE.0 )GOTO 60
        IF( J.LE.J0 )GOTO 100
   40   J0 = J
   60   I0 = I
        IF ( IO.EQ.0 .AND. (ITAG(K,4).EQ.4 .OR. ITAG(K,4).EQ.5) ) IO = I
        IF ( IW.EQ.0 .AND. ITAG(K,3).EQ.3 ) IW = I
   80 CONTINUE
      GOTO 120
  100 WRITE(LOUT,90020)K
      GOTO 400
  120 CONTINUE
C
C               ACCESS VECTORS FOR SWEEPING ALONG X
      DO 240 J = 1,NR
        I = 0
        DO 140 K = 1,NP
          J1 = ITAG(K,2)
          IF( J1.NE.J )GOTO 140
          I = I+1
          IF( I.GT.MX )THEN
            WRITE(LOUT,90040)J
            CALL EXITX(LOUT)
          ENDIF
          KORX(J,I) = K
  140   CONTINUE
        NI(J) = I
C
        IF( NI(J).LE.0 )GOTO 240
        DO 160 I = 2,NI(J)
          K = KORX(J,I)
          KM1 = KORX(J,I-1)
          IF( ITAG(K,1).EQ.(ITAG(KM1,1)+1) )GOTO 160
          WRITE(LOUT,90060)J,ITAG(KM1,1),ITAG(K,1)
          GOTO 400
  160   CONTINUE
C               RE-ORDER THE PRIVATE REGION (X-POINT ONLY)
        I7 = 0
        DO 180 I = 1,NI(J)
          K = KORX(J,I)
          IF( ITAG(K,3).EQ.7 )I7 = I
  180   CONTINUE
        IF( I7.EQ.0 )GOTO 240
  200   KORX1 = KORX(J,1)
        DO 220 I = 2,NI(J)
          KORX(J,I-1) = KORX(J,I)
  220   CONTINUE
        KORX(J,NI(J)) = KORX1
        I7 = I7-1
        IF( I7.GT.1 )GOTO 200
  240 CONTINUE
C
C               ACCESS VECTORS FOR SWEEPING ALONG Y
      DO 280 I = 1,NC
        J = 0
        DO 260 K = 1,NP
          I1 = ITAG(K,1)
          IF( I1.NE.I )GOTO 260
          J = J+1
          IF( J.GT.MY )THEN
            WRITE(LOUT,90080)J
            CALL EXITX(LOUT)
          ENDIF
          KORY(I,J) = K
  260   CONTINUE
        NJ(I) = J
  280 CONTINUE
C
C               ACCESS VECTORS FOR 2D
      IM = - MIN0(0,IO-NC+IW-1)
      NI2D = IM+IW
      NJ2D = NR+1
      ILC = IM+IO-1
      JFP = 0
      JLP = 0
      DO 340 I = 1,NI2D
        DO 320 J=1,NJ2D
          KORXY(I,J) = 0
  320   CONTINUE
  340 CONTINUE
      DO 360 K = 1,NP
        I = ITAG(K,1)
        J = ITAG(K,2)
        IF( I.GT.IW ) I = IO-NC+I-1
        I2D = IM + I
        J2D = MAX0(0,J)
        IF( J.LT.0 ) THEN
          IF(JFP.EQ.0) THEN
            JFP = -J-NJ(I)+1
            JLP = -J-1
          ELSE
            IF(JFP.NE.-J-NJ(I)+1 .OR. JLP.NE.-J-1) THEN
              WRITE(LOUT,90120) I
              CALL EXITX(LOUT)
            ENDIF
          ENDIF
        ENDIF
        IF(J2D.GT.0) KORXY(I2D,J2D) = K
CW      WRITE(LOUT,*) ' IO=',IO,' IW=',IW,' I=',I2D,' J=',J2D,' K=',K
  360 CONTINUE
      DO 390 I=1,NI2D
        DO 380 J=1,NJ2D
          K=KORXY(I,J)
          IF(ITAG(K,4).EQ.4 .AND. J.GT.1   ) KORXY(I,J-1)=K-1
          IF(ITAG(K,4).EQ.5 .AND. J.LT.NJ2D) KORXY(I,J+1)=K+1
  380   CONTINUE
  390 CONTINUE
      IFPR = ILC - NC + IW + 1
      IFMP = ILC - IO + 2
CW      WRITE(LOUT,*) ' ILC=',ILC,' JFP=',JFP,' JLP=',JLP
C
C
      RETURN
C
  400 CONTINUE
      WRITE(LOUT,'(1H1,''     TAG  '')')
      DO 420 K = 1,NP
        WRITE(LOUT,90100)K,(ITAG(K,M),M=1,5)
  420 CONTINUE
      CALL EXITX(LOUT)
90020 FORMAT(' ERROR AT K=',I3)
90040 FORMAT(' TOO MANY POINT AT ROW',I3)
90060 FORMAT(' GAP ALONG ROW',I3,', ITAG(I-1,1)=',I2,' ITAG(I,1)=',I2)
90080 FORMAT(' TOO MANY POINT AT COLUMN',I3)
90100 FORMAT(I5,')',5(1X,I3))
90120 FORMAT(' PERIODICITY ERROR AT COLUMN',I3)
C
      END
**++EOF
**==PRI2D
C
C=======================================================================
      SUBROUTINE PRI2D(IMAT,MX,NX,NY,TEXT,IVER)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION IMAT(MX,*)
      CHARACTER TEXT*(*)
      INCLUDE 'plun'
      DATA INUM/25/
C INUM = NUMBER OF COLUMNS ON PAGE
C
      N           = 0
      N1          = 1
      IN          = ( NX - 1 ) / INUM + 1
      NR          = NX
C
      WRITE(LOUT,90010) TEXT
      DO 100 II   = 1 , IN
         N        = N + INUM
         IF( NR.LT.INUM ) N = N - INUM + NR
         NR       = NR - INUM
         WRITE(LOUT,90020) ( I       , I=N1,N )
         WRITE(LOUT,90040) ( '-----' , I=N1,N )
         IF( IVER.GE.0 )THEN
             J1   = 1
             J2   = NY
             J3   = 1
         ELSE
             J1   = NY
             J2   = 1
             J3   = -1
          ENDIF
          DO 20 J = J1,J2,J3
             WRITE(LOUT,90060)J,(IMAT(I,J),I=N1,N)
   20     CONTINUE
          N1   = N1 + INUM
  100 CONTINUE
C
      RETURN
90010 FORMAT(/40X,A)
90020 FORMAT(/'  J/I',25I5)
90040 FORMAT(5X,25A)
90060 FORMAT(I4,')',25I5)
      END
**++EOF
**==VARIE
C
C=======================================================================
      SUBROUTINE VARIE
      RETURN
      END
**++EOF
**==PRNT2D
C
C=======================================================================
      SUBROUTINE PRNT2D(VECT,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
C
      CHARACTER TEXT*(*)
      DIMENSION VECT(NP+NPXTRA)
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
C
C../CINPUT/
      INCLUDE 'c02'
C../CPHYS/
      INCLUDE 'c03'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
      DIMENSION REV(MY,MX)
      LOGICAL LTAG
C
      CALL RESETR(REV(1,1),MX*MY,UCRAY)
      MAXL = 0
C
      IF( LAVERX )THEN
        IMAX = NC+1
      ELSE
        IMAX = NC
      ENDIF
C
      DO 40 I = 1,IMAX
        L = 0
        DO 20 J = 1,NJ(I)
          K = KORY(I,J)
          LTAG = ITAG(K,4).LT.0
C         VECTK = CVMGT(UCRAY,VECT(K),LTAG)
                          VECTK=VECT(K)
C     IF(LTAG) GOTO 110
          L = L+1
          MAXL = MAX0(MAXL,L)
          REV(L,I) = VECTK
   20   CONTINUE
   40 CONTINUE
C
C     CALL PRRMAT(REV(1,1),MY,MAXL,IMAX,LOUT,TEXT)
      CALL PRUMAT(REV(1,1),MY,MAXL,IMAX,LOUT,TEXT,UCRAY)
C
      RETURN
      END
**++EOF
**==PLOT2D
C
C=======================================================================
      SUBROUTINE PLOT2D(VECT,TEXT,IXMIN,IXMAX)
      IMPLICIT REAL*8(A-H,O-Z)
C
      CHARACTER TEXT*(*)
      DIMENSION VECT(NP)
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
C
C../CINPUT/
      INCLUDE 'c02'
C../CPHYS/
      INCLUDE 'c03'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
      DIMENSION VER(MC,MR)
C NO! EQUIVALENCE (VER(1,1),BUF2D(1,1))
CT       DIMENSION REV(MY,MX)
C
      IMIN = MAX0(IXMIN,1)
      IMAX = MIN0(IXMAX,NC,NXW)
C
      BOH = 4.913683996D+53
      CALL RESETR(VER(1,1),MC*MR,BOH)
CT       CALL RESETR(REV(1,1),MY*MX,UCRAY)
      DO 20 K = 1,NP
        I = ITAG(K,1)
        IF( I.LT.IMIN.OR.I.GT.IMAX )GOTO 20
        J = ITAG(K,2)
C     FOLLOWING FOR PERIODICITY
        J = IABS(J)
        IF( J.LT.1.OR.J.GT.NR )GOTO 20
C     EXCLUDE EXTERNAL POINTS
        IF( ITAG(K,5).LT.0 )GOTO 20
        VECTK = VECT(K)
        VER(I-IMIN+1,J) = VECTK
CT       REV(J,I)=VECTK
   20 CONTINUE
C
CT       CALL PRRMAT(REV(1,1),MY,NR,NC,6,TEXT)
      FMIN = 0.0
      FMAX = 0.0
      CALL CONTUB(1,RHOI(IMIN),THETAJ(1),VER(1,1),MC,IMAX-IMIN+1,NR,120,
     &            60,FMIN,FMAX,BOH,TEXT,'<EDGE2D>',LOUT)
C
      RETURN
      END
**++EOF
**==PRNT2X
C
C=======================================================================
C     DEBUG SUBCHK
C     END DEBUG
      SUBROUTINE PRNT2X(VECT,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
C
      CHARACTER TEXT*(*)
      DIMENSION VECT(NP)
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
C
C../CINPUT/
      INCLUDE 'c02'
C../CPHYS/
      INCLUDE 'c03'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
      DIMENSION REV(MY,MX)
      LOGICAL LTAG
C
      CALL RESETR(REV(1,1),MX*MY,UCRAY)
CC    MAXL=0
      DO 40 J = 1,NR
        IF( NI(J).LE.0 )GOTO 40
CC    L=0
        DO 20 I = 1,NI(J)
          K = KORX(J,I)
          LTAG = ITAG(K,3).LT.0
          VECTK = CVMGT(UCRAY,VECT(K),LTAG)
C     IF(LTAG) GOTO 110
CC    L=L+1
CC    MAXL=MAX0(MAXL,L)
          L = ITAG(K,1)
          IF( L.LE.0.OR.L.GT.NC )THEN
            WRITE(LOUT,90020)J,I,L
            GOTO 20
C       CALL EXITX(LOUT)
          ENDIF
C WRONG?  IF( L.GT.NXW )L = IOX-(NC-L)-1
          REV(J,L) = VECTK
CCC   FILL PERIODIC NORMAL, IF ANY
CCC   IF(J.EQ.1 .AND. ITAG(K,4).EQ.0) REV(NR,L)=VECTK
   20   CONTINUE
   40 CONTINUE
C
C     CALL PRRMAT(REV(1,1),MY,NR,NC ,LOUT,TEXT)
      CALL PRUMAT(REV(1,1),MY,NR,NC ,LOUT,TEXT,UCRAY)
C WRONG?                         NXW
C
      RETURN
90020 FORMAT(' ERROR FROM PRNT2X, ROW=',I2,' I=',I2,' ICOL=',I3)
      END
**++EOF
**==HSOURC
      SUBROUTINE HSOURC(IMC,LPRINT)
      IMPLICIT REAL*8(A-H,O-Z)
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
C
C../CINPUT/
      INCLUDE 'c02'
C../CPHYS/
      INCLUDE 'c03'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
C../UNK/
      INCLUDE 'c06'
C====================================
C
      LOGICAL LPRINT
C
      IMC = 0
C NO! IF( TIME.GT.TIMNE1 ) THEN                            ....08/12/93
      IF( NTINE.GT.0 .OR. TIME.GT.TIMNEU(1) )THEN
C
C                       NEUTRALS SOURCE FROM M.C.
        CALL HMC(IMC,LPRINT)
        RETURN
      ENDIF
C
C                       NEUTRALS SOURCE FROM ANALYTIC MODEL
      CALL RESETR(SOUN(1),NP,0.0D0)
      CALL RESETR(SOUZ(1,1),MP*MZS,0.0D0)
      CALL RESETR(SOUMP(1),NP,0.0D0)
      CALL RESETR(SOUQ(1,1),MP*2,0.0D0)
      CALL RESETR(SOUQE(1,1),MP*2,0.0D0)
      CALL RESETR(SOQE2Z(1,1),MP*MZS,0.0D0)
      CALL RESETR(DA(1),NP,0.0D0)
      CALL RESETR(DM(1),NP,0.0D0)
C                       AND DENSITY OF SPUTTERED NEUTRAL IMPURITY
      CALL RESETR(DZ(1,1),MP*MZS,0.0D0)
C
      CALL RESETR(RADEFF(1,1),MP*MZ,0.0D0)
      CALL RESETR(RADEF0(1,1),MP*MZS,0.0D0)
      CALL RESETR(SVIA(1),NP,0.0D0)
      CALL RESETR(DSVIA(1),NP,0.0D0)
      CALL RESETR(SVRC(1),NP,0.0D0)
      CALL RESETR(DSVRC(1),NP,0.0D0)
      CALL RESETR(SVIM(1),NP,0.0D0)
      CALL RESETR(DSVIM(1),NP,0.0D0)
      CALL RESETR(SVCX(1),NP,0.0D0)
      CALL RESETR(DSVCX(1),NP,0.0D0)
      CALL RESETR(SVDM(1),NP,0.0D0)
      CALL RESETR(DSVDM(1),NP,0.0D0)
      CALL RESETR(ENEUTA(1),NP,0.0D0)
      CALL RESETR(VNUTAP(1),NP,0.0D0)
      CALL RESETR(ENEUTM(1),NP,0.0D0)
      CALL RESETR(VNUTMP(1),NP,0.0D0)
      CALL RESETR(ENEUTZ(1,1),MP*MZS,0.0D0)
      CALL RESETR(SVIZ(1,1),MP*MZ,0.0D0)
      CALL RESETR(SVIZ0(1,1),MP*MZS,0.0D0)
      CALL RESETR(SVRZ(1,1),MP*MZ,0.0D0)
      RETURN
C
      END
**++EOF
**==ZSOURC
C
C=======================================================================
      SUBROUTINE ZSOURC
      IMPLICIT REAL*8(A-H,O-Z)
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      INCLUDE 'p02'
C
C../CINPUT/
      INCLUDE 'c02'
C../CPHYS/
      INCLUDE 'c03'
C
C../PARAM/
      INCLUDE 'c04'
C../PARAME/
      INCLUDE 'c05'
C
      DIMENSION IBUF2D(MX,MY),BUFFER(MP),IBUFER(MP)
      EQUIVALENCE(BUF2D(1,1),IBUF2D(1,1),BUFFER(1),IBUFER(1))
C
C../UNK/
      INCLUDE 'c06'
C
      DIMENSION DE(MP),ZEF(MP),TEVL(MP)
C
      DIMENSION QERAD(MZS)
C
      DATA IZSENT/1/
      SAVE IZSENT
C
C
C INITIALISATIONS
C ---------------
C
      DO 20 K = 1,NP
        SOUQ(K,2)  = 0.0
        SOUQE(K,2) = 0.0
        SOQE2G(K)  = 0.0
        TEVL(K) = PREEL(K)/(DENEL(K)*EV)
        TEVL(K) = TEVL(K)*TZSHFT
   20 CONTINUE
C
      DO IZS=1,NZS
        DO K=1,NP
C                 M.C.         GIVEN
          DZ(K,IZS) = CVMGT(DZ(K,IZS),DEN(K)*ZFRAC,ZFRAC.LE.0.0)
          SOQE2Z(K,IZS) = 0.0D0
        ENDDO
      ENDDO
C
      TACHZ = 1.0
      IF( TIME.LT.ZTIM )TACHZ = 0.001+TIME/ZTIM
C
C RADIATION ACCORDING TO GARCHING MODEL (A.T. 07/12/93)
C -----------------------------------------------------
C
      IF ( IGARCH.GT.0 )THEN
C
        DO 30 K = 1,NP
          TN         = DMAX1(1.D-6,TEVL(K)/TALIMP)
          XLZ        = 2.D-18/(TN**EX1IMP+TN**EX2IMP)
          SOQE2G(K)  = -ALFIMP*DENEL(K)**2*XLZ
          SOQE2G(K)  = CVMGT(0.0D0,SOQE2G(K),TEVL(K).LE.TCUTSR)
  30    CONTINUE
C
C   NORMALISE ALFIMP IF PRAD GIVEN
C
        IF( PRAD.GT.0.D0 )THEN
          ALFIMN = ALFIMP
          TOTR   = 0.0D0
          DO 35 K = 1,NP
            TOTR = TOTR+SOQE2G(K)*DVOL(K,4)
  35      CONTINUE
          TOTR = TOTR*TWOPI
          TRAN = 1.0
          IF( TOTR.NE.0.0 )TRAN = -DABS(PRAD)*1.0D+13/TOTR*TACHZ
          DO 40 K = 1,NP
            SOQE2G(K) = SOQE2G(K)*TRAN
  40      CONTINUE
          ALFIMN = ALFIMP*TRAN
        ENDIF
C
      ENDIF
C
C CORONA MODEL
C ------------
C
      IF( NZ.EQ.1 )THEN
C
        IF( IZSENT.EQ.0 )GOTO 60
        CALL STARIMJ(1,ZMASS(1))
        IZSENT = 0
   60   CONTINUE
        CALL IMPJ(
     &    NP,NP,DEN(1),TEVL(1),1,DENZ(1,1),DE(1),ZI(1,1),ZI2(1,1)
     &          ,ZEF(1),PZ(1),SOUQE(1,2))
        DO 100 K = 1,NP
          IF(ITAG(K,4).GE.0 .AND. ZI(K,1).GT.MZ) THEN
            WRITE(LOUT,*)' **** ERROR: ZI .GT. MZ',K,ZI(K,1),DENZ(K,1)
            CALL EXITX(LOUT)
C           ZI(K,1)=DMIN1(ZI(K,1),DFLOAT(MZ))
C           ZI2(K,1)=DMIN1(ZI2(K,1),DFLOAT(MZ*MZ))
          ENDIF
          FR = CVMGT(1.0D0,0.0D0,TEV(K)/TZSHFT.GT.TRCUT)
          DENEL(K)=DEN(K)+ZI(K,1)*DENZ(K,1)
          SOUQE(K,2) = -CVMGT(SOUQE(K,2),FR*DENEL(K)*DENZ(K,1)*ZLRAD
     &                        *TACHZ,ZLRAD.EQ.0.0D0)*ENHRAD
          SOUQE(K,2) = CVMGT(0.0D0,SOUQE(K,2),TEVL(K).LE.TCUTSR)
  100   CONTINUE
C
C             FORCE ELECTRON RADIATION POWER LEVEL IF PRAD GIVEN
C          .GT.0    "      "      "   RADIATION PROFILE ONLY
C          .LT.0  CONSTANT RADIATION EFFICIENCY
C             PROVIDED NO GARCHING RADIATION
C
        IF( IGARCH.GT.0 .OR. PRAD.EQ.0.0D0 )GOTO 340
        IF( PRAD.LT.0.0D0 )THEN
          CALL RESETR(SOUQE(1,2),NP,0.0D0)
          DO 280 K = 1,NP
            DZZ = 0.0D0
            DO 260 IZ = 1,NZ
              DZZ = DZZ+DENZ(K,IZ)
  260       CONTINUE
            SOUQE(K,2) = DENEL(K)*DZZ
            SOUQE(K,2) = CVMGT(0.0D0,SOUQE(K,2),TEVL(K).LE.TCUTSR)
  280     CONTINUE
        ENDIF
        TOTR = 0.0D0
        DO 300 K = 1,NP
          TOTR = TOTR+SOUQE(K,2)*DVOL(K,4)
  300   CONTINUE
        TOTR = TOTR*TWOPI
        TRAN = 1.0
        IF( TOTR.NE.0.0 )TRAN = -DABS(PRAD)*1.0D+13/TOTR*TACHZ
        DO 320 K = 1,NP
          SOUQE(K,2) = SOUQE(K,2)*TRAN
  320   CONTINUE
  340   CONTINUE
C
C NON-CORONA MODEL
C ----------------
C
      ELSE IF(NZ.GT.1)THEN
C
        DO 441 IZS=1,NZS
          DO 440 IZC=1,NZC(IZS)
             IZ = IZSC(IZS,IZC)
             DO 420 K=1,NP
               ZI(K,IZ)=IZC
               ZI2(K,IZ)=IZC*IZC
  420        CONTINUE
  440     CONTINUE
  441   CONTINUE
        DO 460 K=1,NP
          ZEF(K)=1.0
          SOUQE(K,2)=0.0D0
          DO IZS=1,NZS
            SOQE2Z(K,IZS) = 0.D0
          ENDDO
  460   CONTINUE
C
        DO 500 K=1,NP
          DENEL(K)=DEN(K)
          DO 481 IZS =1,NZS
            RADEF0(K,IZS) = CVMGT(0.0D0,RADEF0(K,IZS),TEVL(K).LE.TCUTSR)
            QERAD(IZS)    = RADEF0(K,IZS)*DZ(K,IZS)
            DO 480 IZC=1,NZC(IZS)
              IZ = IZSC(IZS,IZC)
              RADEFF(K,IZ) = CVMGT(0.0D0,RADEFF(K,IZ),TEVL(K).LE.TCUTSR)
              DENEL(K)=DENEL(K)+ZI(K,IZ)*DENZ(K,IZ)
              QERAD(IZS)=QERAD(IZS)+RADEFF(K,IZ)*DENZ(K,IZ)
  480       CONTINUE
  481     CONTINUE
          DO 485 IZS=1,NZS
            QERAD(IZS)    =  QERAD(IZS)*DENEL(K)
            SOQE2Z(K,IZS) = -QERAD(IZS)*TACHZ
            SOUQE(K,2)    = SOUQE(K,2) + SOQE2Z(K,IZS)
  485     CONTINUE
  500   CONTINUE
      ENDIF
C
C ADD CONTRIBUTIONS TO TOAL RADIATION
C -----------------------------------
C
      DO 600 K=1,NP
        SOUQE(K,2) = SOUQE(K,2) + SOQE2G(K)
 600  CONTINUE
C
      RETURN
      END
**++EOF
**==TRAPEZ
C
C=======================================================================
      SUBROUTINE TRAPEZ(N,X,F,FINT)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(N),F(N)
C
      FINT = 0.0
      DO 20 I = 1,N-1
        DX = (X(I+1)-X(I))*0.5
        FINT = FINT+(F(I)+F(I+1))*DX
   20 CONTINUE
      RETURN
      END
**++EOF
**==FLUXAV
C
C=======================================================================
      SUBROUTINE FLUXAV(MP,NP,DRHO,DTHETA,ITAG,H,MR,NI,NR,KORX,MC,NJ,NC,
     &                  KORY,ICOL,VECT,SUM)
C
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER(MX=100,MY=100)
      DIMENSION VECT(MP),DRHO(MP),DTHETA(MP),ITAG(MP,5),H(MP),NI(MR),
     &          KORX(MR,MX),NJ(MC),KORY(MC,MY)
C
      LOGICAL LTAG
C
      SUM = 0.0
      NY = NJ(ICOL)
      DO 20 J = 1,NY-1
        K = KORY(ICOL,J)
        IT = ITAG(K,4)
        LTAG = IT.EQ.0 .OR. IT.EQ.4 .OR. IT.EQ.5
        IF( .NOT.LTAG )GOTO 20
        SUM = SUM+H(K)*VECT(K)*DRHO(K)*DTHETA(K)
   20 CONTINUE
      SUM = SUM*6.283185D0
C
      RETURN
      END
**++EOF
**==FLXAVG
C
C=======================================================================
      SUBROUTINE FLXAVG(MP,NP,DRHO,DTHETA,ITAG,H,MR,NI,NR,KORX,MC,NJ,NC,
     &                  KORY,ILC,ICOL,VECT,SUM)
C
C    CALCULATE FLUX SURFACE AVERAGE
C
      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER(MX=100,MY=100)
      DIMENSION VECT(MP),DRHO(MP),DTHETA(MP),ITAG(MP,5),H(MP),NI(MR),
     &          KORX(MR,MX),NJ(MC),KORY(MC,MY)
C
      SUM  = 0.0
      SUM1 = 0.0
      NY = NJ(ICOL)
      DO 20 J = 1,NY-1
        K = KORY(ICOL,J)
        IF( ITAG(K,2).LE.0 ) GOTO 20
        DV = H(K)*DTHETA(K)*DRHO(K)
        SUM = SUM+VECT(K)*DV
        SUM1 = SUM1+DV
   20 CONTINUE
      SUM = SUM/SUM1
C
      RETURN
      END
**++EOF
**==INT2D
C
C======================================================================
      SUBROUTINE INT2D(MC,I1,NC,NJ,KORY,MP,DRHO,DTHETA,H,ITAG,ICOLEX,
     &                 NXW,VECT,TOT)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION NJ(MC),KORY(MC,1),DRHO(MP),DTHETA(MP),H(MP),ITAG(MP,5),
     &          VECT(MP),ICOLEX(MC)
C
      LOGICAL LTAG
C
      TOT = 0.0
      DO 40 I = I1,NC
CRS BEGIN
        IF(I.EQ.1 .OR. I.EQ.NXW .OR. I.EQ.NXW+1) GOTO 40
CRS END
        IF( ICOLEX(I).EQ.0 )GOTO 40
        DO 20 J = 1,NJ(I)
          K = KORY(I,J)
          IF( ITAG(K,2).LT.0 )GOTO 20
          IT = ITAG(K,4)
          LTAG = IT.EQ.0 .OR. IT.EQ.4 .OR. IT.EQ.5
          IF( .NOT.LTAG )GOTO 20
          TOT = TOT+VECT(K)*H(K)*DRHO(K)*DTHETA(K)
   20   CONTINUE
   40 CONTINUE
C
      RETURN
      END
**++EOF
**==POLSYM
C
C======================================================================
      SUBROUTINE POLSYM(MC,NC,NJ,MY,KORY,MP,PROF,ITAG,SYM)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION NJ(MC),KORY(MC,MY),PROF(MP),ITAG(MP,5)
C                 POLOIDAL SYMMETRISATION
      DO 40 I = 1,NC
        NY = NJ(I)
        JYM = NY/2
        DO 20 J = 1,JYM
          J1 = J
          K1 = KORY(I,J1)
          J2 = NY-J+1
          K2 = KORY(I,J2)
          IF( ITAG(K1,5).LT.0.OR.ITAG(K2,5).LT.0 )GOTO 20
          PROF(K1) = (PROF(K1)+PROF(K2)*SYM)*0.5
          PROF(K2) = SYM*PROF(K1)
   20   CONTINUE
   40 CONTINUE
      RETURN
      END
**++EOF
**==UNSCOL
C
C=======================================================================
      SUBROUTINE UNSCOL(NY,ITAGY,VSY,V,R)
      IMPLICIT REAL*8(A-H,O-Z)
C     IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION ITAGY(NY),VSY(NY+1),V(NY),R(NY)
C
      PARAMETER(MY=200)
      DIMENSION JMINL(17),JMAXL(17),VS(MY+1),ITAGS(MY+1),HR(MY)
C
C               DETERMINE JMIN,JMAX BETWEEN EACH LIMITER/TARGET
C               AND ASSOCIATE TO EACH POINT THE INDEX NL
      NLY = 0
      CALL RESETI(JMINL(1),17,0)
      CALL RESETI(JMAXL(1),17,0)
      J5L = 0
      J = 0
   20 J = J+1
      IF( J.GT.NY )GOTO 60
      IF( ITAGY(J).EQ.5.AND.NLY.EQ.0 )J5L = J
      IF( ITAGY(J).NE.4 )GOTO 20
      NLY = NLY+1
      JMINL(NLY) = J
   40 J = J+1
      IF( J.GT.NY )GOTO 60
      IF( ITAGY(J).NE.5 )GOTO 40
      JMAXL(NLY) = J
      GOTO 20
   60 CONTINUE
      IF( J5L.NE.0 )JMAXL(NLY) = J5L
C
CW      IF(NLY.NE.0) WRITE(LOUT,112) NLY,(JMINL(L),JMAXL(L),L=1,NLY)
CW112   FORMAT(' UNSCOL AT 112  NLY=',I3/(' JMINL=',I3,'  JMAXL=',I3))
C
      IF( NLY-1 )240,140,80
   80 DO 120 L = 1,NLY-1
        JMIN = JMINL(L)
        JMAX = JMAXL(L)
        K = 0
        DO 100 J = JMIN,JMAX+1
          K = K+1
          VS(K) = VSY(J)
CW      WRITE(LOUT,132) J,VSY(J),K,VS(K)
CW132   FORMAT(' UNSCOL J=',I3,' VSY=',1P,E12.3,' K=',I3,' VS=',E12.3)
          ITAGS(K) = 0
  100   CONTINUE
        NS = K
        ITAGS(1) = 4
        ITAGS(NS) = 5
        V1 = V(JMIN)
        VN = V(JMAX)
CW      WRITE(LOUT,150) L,VS(1),V1,(VS(J),J=2,NS-1),VN,VS(NS)
CW150   FORMAT(' UNSCOL L=',I3,' VS+V1+VN'/(1P,10E12.3))
        CALL UNSTAG(NS-1,VS(1),V1,VN,ITAGS(1),R(JMIN))
  120 CONTINUE
C
  140 CONTINUE
      JMIN = JMINL(NLY)
      JMAX = JMAXL(NLY)
      K = 0
      DO 160 J = JMIN,NY-1
        K = K+1
        VS(K) = VSY(J)
CW      WRITE(LOUT,132) J,VSY(J),K,VS(K)
        ITAGS(K) = 0
  160 CONTINUE
      KNY = K+1
      DO 180 J = 1,JMAX+1
        K = K+1
        VS(K) = VSY(J)
CW      WRITE(LOUT,132) J,VSY(J),K,VS(K)
        ITAGS(K) = 0
  180 CONTINUE
      NS = K
      ITAGS(1) = 4
      ITAGS(NS) = 5
      V1 = V(JMIN)
      VN = V(JMAX)
CW      WRITE(LOUT,150) L,VS(1),V1,(VS(J),J=2,NS-1),VN,VS(NS)
      CALL UNSTAG(NS-1,VS(1),V1,VN,ITAGS(1),HR(1))
      J = JMIN-1
      DO 200 K = 1,KNY
        J = J+1
        R(J) = HR(K)
  200 CONTINUE
      J = 1
      R(J) = R(NY)
      DO 220 K = KNY+1,NS-1
        J = J+1
        R(J) = HR(K)
  220 CONTINUE
      GOTO 260
C
  240 CONTINUE
      CALL UNSTAG(NY,VSY(1),0.0D+00,0.0D+00,ITAGY(1),R(1))
C
  260 RETURN
      END
**++EOF
**==UNSTAG
C
C=======================================================================
      SUBROUTINE UNSTAG(N,VS,V1,VN,ITAG,V)
      IMPLICIT REAL*8(A-H,O-Z)
C
      INCLUDE 'plun'
      DIMENSION VS(0:N),ITAG(0:N),V(N)
C
      LOGICAL LTAG
C
      PARAMETER(M=200)
      DIMENSION A(M),B(M),C(M),D(M),X(M)
C
CW    WRITE(LOUT,5) N,(ITAG(J),J=0,N)
CW  5 FORMAT(/' ITAG IN UNSTAG FOR N=',I3/(20I5))
CW    WRITE(LOUT,6) (VS(J),J=0,N)
CW  6 FORMAT(' VS'/(1P,5E12.3))
      LTAG = ITAG(0).EQ.4 .AND. ITAG(N).EQ.5
      DO 20 I = 1,N-1
        LTAG = LTAG .AND. ITAG(I).EQ.0
   20 CONTINUE
      IF( .NOT.LTAG )GOTO 60
C
C                    WITH BOUNDARY CONDITIONS
      B(1) = 2.
      C(1) = 1.
      D(1) = 2.*VS(1)+V1
      DO 40 I = 2,N-1
        A(I) = 1.
        B(I) = 2.
        C(I) = 1.
        D(I) = 2.*(VS(I-1)+VS(I))
   40 CONTINUE
      A(N) = 1.
      B(N) = 2.
      D(N) = 2.*VS(N-1)+VN
      CALL TRIDX(1,N,A(1),B(1),C(1),D(1),V(1))
      RETURN
C
   60 CONTINUE
      LTAG = ITAG(0).EQ.0
      DO 80 I = 1,N-1
        LTAG = LTAG .AND. ITAG(I).EQ.0
   80 CONTINUE
      IF( .NOT.LTAG )THEN
        WRITE(LOUT,90020)
        CALL EXITX(LOUT)
      ENDIF
C                    PERIODIC
      EPS = 0.0
      IF( (N/2)*2.NE.N )THEN
        WRITE(LOUT,90040)
        IF( .TRUE. )CALL EXITX(LOUT)
        EPS = 1.0E-04
      ENDIF
      DO 100 I = 1,N-1
        A(I) = 1.0
        B(I) = 1.0+2.0*EPS
        C(I) = 0.0+EPS
        D(I) = 2.*VS(I-1)
  100 CONTINUE
      CALL TRIDX(2,N,A(1),B(1),C(1),D(1),V(1))
      RETURN
90020 FORMAT(/' UNKNOWN OPTION IN UNSTAG')
90040 FORMAT(/' ERROR: ODD NUMBER OF POINTS IN PERIODIC UNSTAG')
C
      END
**++EOF
**==TRIDX
C
C=======================================================================
      SUBROUTINE TRIDX(MODE,N,A,B,C,D,Y)
      IMPLICIT REAL*8(A-H,O-Z)
      INCLUDE 'plun'
      DIMENSION A(N),B(N),C(N),D(N),Y(N)
C
C     SOLVES EITHER THE TRI-DIAGONAL SYSTEM  (MODE=1)
C
C                           B(1)*Y(1) + C(1)*Y(2)   = D(1)
C             ............................................
C             A(I)*Y(I-1) + B(I)*Y(I) + C(I)*Y(I+1) = D(I)     I=2,N-1
C             ............................................
C             A(N)*Y(N-1) + B(N)*Y(N)               = D(N)
C
C
C     OR THE (CYCLIC) TRI-DIAGONAL SYSTEM  (MODE=2)
C
C             A(1)*Y(N-1) + B(1)*Y(1) + C(1)*Y(2)   = D(1)
C             ............................................
C             A(I)*Y(I-1) + B(I)*Y(I) + C(I)*Y(I+1) = D(I)     I=2,N-1
C             ............................................
C                                Y(N)               = Y(1)
C
C
      PARAMETER(M=200)
      DIMENSION A1(M),B1(M),C1(M),D1(M),U(M),V(M)
C
      IF( N.GT.M )THEN
        WRITE(LOUT,90020)
        CALL EXITX(LOUT)
      ENDIF
C
      IF( MODE.LT.1.OR.MODE.GT.2 )THEN
        WRITE(LOUT,90040)
        CALL EXITX(LOUT)
      ENDIF
C
      GOTO(140,20),MODE
C
C                    CYCLIC
   20 CONTINUE
      A1(1) = 0.0
      B1(1) = 1.0
      C1(1) = 0.0
      D1(1) = 0.0
      DO 40 I = 2,N-1
        A1(I) = A(I)
        B1(I) = B(I)
        C1(I) = C(I)
        D1(I) = D(I)
   40 CONTINUE
      A1(N) = 0.0
      B1(N) = 1.0
      C1(N) = 0.0
      D1(N) = 0.0
      CALL TRIDIA(N,A1(1),B1(1),C1(1),D1(1))
      DO 60 I = 1,N
        U(I) = D1(I)
   60 CONTINUE
C
      A1(1) = 1.0
      B1(1) = 1.0
      C1(1) = 0.0
      D1(1) = 1.0
      DO 80 I = 2,N-1
        A1(I) = A(I)
        B1(I) = B(I)
        C1(I) = C(I)
        D1(I) = 0.0
   80 CONTINUE
      A1(N) = 0.0
      B1(N) = 1.0
      C1(N) = 0.0
      D1(N) = 1.0
      CALL TRIDIA(N,A1(1),B1(1),C1(1),D1(1))
      DO 100 I = 1,N
        V(I) = D1(I)
  100 CONTINUE
CW    WRITE(LOUT,222) (A(I),B(I),C(I),D(I),U(I),V(I),I=1,N)
CW222 FORMAT(/1P,6E12.3)
C
      Y(1) = (D(1)-A(1)*U(N-1)-C(1)*U(2))/(A(1)*V(N-1)+B(1)+C(1)*V(2))
      DO 120 I = 2,N
        Y(I) = U(I)+Y(1)*V(I)
  120 CONTINUE
      RETURN
C
  140 CONTINUE
      DO 160 I = 1,N
        A1(I) = A(I)
        B1(I) = B(I)
        C1(I) = C(I)
        D1(I) = D(I)
  160 CONTINUE
      CALL TRIDIA(N,A1(1),B1(1),C1(1),D1(1))
      DO 180 I = 1,N
        Y(I) = D1(I)
  180 CONTINUE
      RETURN
90020 FORMAT(' DIMENSION EXCEEDED IN TRID')
90040 FORMAT(' UNKNOWN MODE IN TRID')
C
      END
**++EOF
**==TRIDIA
C
C=======================================================================
      SUBROUTINE TRIDIA(N,A,B,C,D)
      IMPLICIT REAL*8(A-H,O-Z)
C     IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(N),B(N),C(N),D(N)
C
C     SOLVES THE TRI-DIAGONAL SYSTEM
C
C                           B(1)*U(1) + C(1)*U(2)   = D(1)
C             ............................................
C             A(I)*U(I-1) + B(I)*U(I) + C(I)*U(I+1) = D(I)     I=2,N-1
C             ............................................
C             A(N)*U(N-1) + B(N)*U(N)               = D(N)
C
C     A(I),B(I),C(I),D(I) ARE MODIFIED BY THE SUBROUTINE.
C     ON EXIT, D(I) CONTAINS THE SOLUTION.
C
      A(1) = 0.0
      C(N) = 0.0
C
      C(1) = C(1)/B(1)
      D(1) = D(1)/B(1)
      DO 20 I = 2,N
        E = 1./(B(I)-A(I)*C(I-1))
        C(I) = C(I)*E
        D(I) = (D(I)-A(I)*D(I-1))*E
   20 CONTINUE
      DO 40 I = N-1,1,-1
        D(I) = D(I)-C(I)*D(I+1)
   40 CONTINUE
C
      RETURN
      END
**++EOF
**==AVERX
C
C======================================================================
      SUBROUTINE AVERX(MR,NI,KORX,MP,HRHO,HTHETA,H,ITAG,DRHO,I1,I2,J,NF,
     &                 VOL,VECT,AVER)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION NI(MR),KORX(MR,1),HRHO(MP),HTHETA(MP),H(MP),ITAG(MP,5),
     &          DRHO(MP),VECT(MP)
C
C     RHO-AVERAGES FROM ICOL=I1 TO ICOL=I2 (USUALLY SEPARATRIX TO WALL)
C
      LOGICAL LTAG
C
      NF=0
      AVER=0.0
      NX=NI(J)
      IF( NX.LE.0 )RETURN
      TOT=0.0
      VOL=0.0
      DO 20 I=1,NX
      K=KORX(J,I)
      ICOL=ITAG(K,1)
      IF( ICOL.LT.I1.OR.ICOL.GT.I2 )GOTO 20
      IT=ITAG(K,3)
      LTAG=IT.EQ.0 .OR. IT.EQ.1 .OR. IT.EQ.7 .OR. IT.EQ.3
      IF( .NOT.LTAG )GOTO 20
      NF=NF+1
      TOT=TOT+VECT(K)*H(K)*DRHO(K)
      VOL=VOL+H(K)*DRHO(K)
   20 CONTINUE
      AVER=TOT/VOL
C
      RETURN
      END
**++EOF
**==SUMRO
C
C======================================================================
      SUBROUTINE SUMRO(MR,NI,KORX,MP,HRHO,ITAG,DRHO,RMESH,I1,I2,J,NF,TOT
     *                )
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION NI(MR),KORX(MR,1),HRHO(MP),ITAG(MP,5),RMESH(MP),DRHO(MP)
C
C     RHO-INTEGRAT FROM ICOL=I1 TO ICOL=I2 (USUALLY SEPARATRIX TO WALL)
C
      LOGICAL LTAG
C
      NF=0
      NX=NI(J)
      IF( NX.LE.0 )RETURN
      TOT=0.0
      DO 20 I=1,NX
      K=KORX(J,I)
      ICOL=ITAG(K,1)
      IF( ICOL.LT.I1.OR.ICOL.GT.I2 )GOTO 20
      IT=ITAG(K,3)
      LTAG=IT.EQ.0 .OR. IT.EQ.1 .OR. IT.EQ.7 .OR. IT.EQ.3
      IF( .NOT.LTAG )GOTO 20
      NF=NF+1
      TOT=TOT+RMESH(K)*HRHO(K)*DRHO(K)
   20 CONTINUE
C
      RETURN
      END
**++EOF
**==ROOT
C
C=======================================================================
      SUBROUTINE ROOT(N1,X1,Y1,N2,X2,Y2,MR,X,Y,LI,LJ,NR)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     GIVEN THE TWO CURVES
C               (X1(K),Y1(K),K=1,N1)
C               (X2(K),Y2(K),K=1,N2)
C     RETURNS THEIR INTERSECTION POINTS (X(K),Y(K),K=1,NR), IF ANY
C             AND LI,LJ
C
      REAL*8 X1(N1),Y1(N1),X2(N2),Y2(N2),X(MR),Y(MR)
      INTEGER*4 LI(MR),LJ(MR),NR
C
      REAL*8 KX,KY
C
      DATA EPS/1.0D-12/
C
      NR=0
C
      N1M1=N1-1
      N2M1=N2-1
      DO 40 I=1,N1M1
      DO 20 J=1,N2M1
      L1=I
      L2=J
      X11=X1(I)
      Y11=Y1(I)
      X12=X1(I+1)
      Y12=Y1(I+1)
      X21=X2(J)
      Y21=Y2(J)
      X22=X2(J+1)
      Y22=Y2(J+1)
      H1X=X12-X11
      H1Y=Y12-Y11
      H2X=X22-X21
      H2Y=Y22-Y21
      KX=X21-X11
      KY=Y21-Y11
      D=-H1X*H2Y+H2X*H1Y
CW    WRITE(LOUT,123) X11,X12,Y11,Y12,
CW   *             X21,X22,Y21,Y22,
CW   *             H1X,H1Y,H2X,H2Y,
CW   *             KX,KY,D
CW123 FORMAT(' X11=',1PE10.3,' X12=',E10.3,' Y11=',E10.3,' Y12=',E10.3/
CW   *       ' X21=',  E10.3,' X22=',E10.3,' Y21=',E10.3,' Y22=',E10.3/
CW   *       ' H1X=',  E10.3,' H1Y=',E10.3,' H2X=',E10.3,' H2Y=',E10.3/
CW   *       ' KX =',  E10.3,' KY =',E10.3,' D  =',E10.3)
      IF( D.EQ.0.0D0 )THEN
CW    WRITE(LOUT,'('' D=0 IN ROOT'')')
      GOTO 20
      ENDIF
      S=(-KX*H2Y+H2X*KY)/D
      T=(H1X*KY-KX*H1Y)/D
CW    WRITE(LOUT,124) S,T
CW124 FORMAT('  S =',1P,G28.20,'  T =',E28.20)
CW    WRITE(LOUT,125) X11+S*H1X,Y11+S*H1Y,X21+T*H2X,Y21+T*H2Y
CW125 FORMAT(' X0 =',1PE10.3,' Y0 =',E10.3,' Y0 =',E10.3,' Y0 =',E10.3)
      IF( S.LT.-EPS.OR.S.GT.(1.0D0+EPS) )GOTO 20
      IF( T.LT.-EPS.OR.T.GT.(1.0D0+EPS) )GOTO 20
C     IF( S.LT.0.0D0.OR.S.GT.1.0D0 )GOTO 20
C     IF( T.LT.0.0D0.OR.T.GT.1.0D0 )GOTO 20
C
      NR=NR+1
      LI(NR)=L1
      LJ(NR)=L2
      IF( H1X*H1Y.NE.0.0 )THEN
          X(NR)=X11+S*H1X
          Y(NR)=Y11+S*H1Y
      ELSE
          X(NR)=X21+T*H2X
          Y(NR)=Y21+T*H2Y
      ENDIF
C...
      LMAX      = NR - 1
      DO 15 L  = 1 , LMAX
         XDIFF2 = ( X(NR) - X(L) ) * ( X(NR) - X(L) )
         YDIFF2 = ( Y(NR) - Y(L) ) * ( Y(NR) - Y(L) )
         DIST   = SQRT( XDIFF2 + YDIFF2 )
         IF( DIST.LE.EPS ) THEN
             NR = NR - 1
             GOTO 25
         END IF
   15 CONTINUE
C...
   25 IF( NR.GE.MR )GOTO 60
C
   20 CONTINUE
   40 CONTINUE
C
   60 CONTINUE
CW    WRITE(LOUT,150) (I,X1(I),Y1(I),I=1,N1)
CW150 FORMAT('  FIRST POLYGONAL'/(I5,1P,2E12.4))
CW    WRITE(LOUT,160) (I,X2(I),Y2(I),I=1,N2)
CW160 FORMAT(' SECOND POLYGONAL'/(I5,1P,2E12.4))
CW    IF( NR.EQ.0 )WRITE(LOUT,90020)
      RETURN
90020 FORMAT(' NO ROOT FOUND')
      END
**++EOF
**==SPLSRC
C
C=======================================================================
C
      INCLUDE 'header'
C
      SUBROUTINE SPLSRC(N,DENSI0,RATION,RATREC,EXTSRC,IMORE,F,
     *                  TAU,DENSI,IFAIL)
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : SOLVE THE SYSTEM OF RATE EQUATIONS
C
C      D/DT U(I;T)  =       S(I-1)*U(I-1;T)
C                     -(S(I)+R(I))*U(I;T)
C                     +     R(I+1)*U(I+1,T)
C                     +         B(I)
C                     +     F(I,J)*U(J;T)      IF IMORE>0
C
C METHOD  : (1) CONSTRUCT A TRI-DIAGONAL MATRIX AS DEFINED IN TRIDAG(,).
C           (2) FIND THE EIGENVECTORS AND EIGENVALUES OF THAT MATRIX.
C           (3) FIND C0(K) (K = 1,...,N) BY SOLVING :-
C               DENSI0(I)=VECTOR(I,K)*C0(K) + VECTOR(I,K+1)*C0(K+1) + ..
C           (4) FIND XU(K) (K = 1,...,N) BY SOLVING :-
C               EXTSRC(I)=VECTOR(I,K)*XU(K) + VECTOR(I,K+1)*XU(K+1) + ..
C           (5) COMPUTE :-
C               C(K) = ( C0(K)
C                        + ( XU(K)/VALUES(K) )
C                          * ( 1-EXP(-VALUES(K)*TAU) )
C                      ) * EXP(VALUES(K)*TAU)
C           (6) COMPUTE :-
C               DENSI(I) = C(1)*VECTOR(I,1) + C(2)*VECTOR(I,2) + ...
C REFERENCES:
C    T.AMANO, M.OKAMOTO, "A METHOD OF SOLVING THE RATE EQUATIONS",
C    REPORT JAERI-M 6401 (1976)
C
C INPUT   : N         - NUMBER OF CHARGED STATES
C           DENSI0()  - DENSITY OF CHARGED STATES              (CM-3)
C           RATION()  - IONISATION    RATE                     (SEC-1)
C           RATRAD()  - RECOMBINATION RATE                     (SEC-1)
C           EXTSRC()  - EXTERNAL SOURCE OF ALL CHARGED STATES
C           TAU       - TIME STEP                              (SEC)
C
C OUTPUT  : FOR THE LOCAL TRI-DIAGONAL MATRIX OF ORDER N DEFINED AS
C                       TRIDAG(I,K) = 0.0  FOR K .NE. I,I-1,I+1
C                       TRIDAG(I,I) = - RATION(I) - RATREC(I)
C                       TRIDAG(I,I-1) = + RATION(I-1)
C                       TRIDAG(I,I+1) =          + RATREC(I+1)
C                       FOR I = 1 TO N (ROW)
C                       FOR K = 1 TO N (COLUMN)
C           WITH
C           VECTOR(,) - EIGENVECTORS MATRIX OF ORDER N.
C           VALUES()  - EIGENVALUES  MATRIX OF ORDER N (COMPLEX).
C RETURN  :
C           DENSI()   - UPDATED DENSITY OF CHARGED STATES      (CM-3)
C           IFAIL     - =  0 IF ROUTINE IS   SUCCESSFUL.
C                       = -1 IF N IS NOT POSITIVE.
C                       =  I IF QR METHOD DID NOT CONVERGE FOR THE ITH
C                            EIGENVALUE.
C                       = -88888 IF TAU IS TOO LARGE FOR EXP. ARG. RANGE
C                       = -99999 IF RATREC(1) <> 0.0 OR RATION(N) <> 0.0
C
C PROGRAM : WORK()    - WORK SPACE ARRAY WITH DIMENSION OF AT LEAST 2*N.
C           AWORK(,)  - STORAGE FOR TRIDAG(,).
C           EPS       - ACCURACY
C           IERROR    - ERROR OUTPUT CHANNEL
C
C NOTES   : (1) THE ITH EIGENVALUE IN VALUES(I) CORRESPONDS TO THE KTH
C               COLUMN OF THE EIGENVECTOR MATRIX VECTOR(I,K).
C           (2) EIGENVECTORS ARE NORMALISED.
C
C AUTHOR  : JAMES SPENCE (K1/0/80) EXT.4866
C           JET
C
C DATE    : 22/01/90
C
C-----------------------------------------------------------------------
C
C--------------------------------
      INCLUDE 'p01'
C--------------------------------
      PARAMETER(EPS=1.0D-09,IERROR=LOUT)
C
      DIMENSION DENSI0(N),DENSI(N)
      DIMENSION RATION(N),RATREC(N),EXTSRC(N),F(N,N)
C
      DIMENSION VECTOR(MZ,MZ),TRIDAG(MZ,MZ),IEQ(MZ)
      COMPLEX*16 VALUES(MZ)
C
      DIMENSION C0(MZ),XU(MZ),C(MZ)
      DIMENSION WORK(MZ*2),AWORK(MZ,MZ)
      LOGICAL LEQ(MZ)
C
C     MAXIMUM ARGUMENT FOR EXPONENTIALS
      DATA EXPMAX/174.0D0/
C
C.....INITIALISE TO ZERO................................................
C
      CALL RESETR( TRIDAG(1,1) , MZ*MZ , 0.0D0 )
      CALL RESETR( VECTOR(1,1) , MZ*MZ , 0.0D0 )
      CALL RESETR( DENSI(1)    , N     , 0.0D0 )
      CALL ZDSCAL(MZ  ,0.00D+00,VALUES,1)
C
C.....CHECK.............................................................
C
      IF(IFAIL.EQ.-1)THEN
        IDEB = 1
      ELSE
        IDEB = 0
      ENDIF
      IFAIL=-99999
      IF( RATION(N).NE.0.00D+00 )THEN
      WRITE(IERROR,90080)N
      WRITE(IERROR,90120)RATION(1)
      GOTO 180
      ENDIF
      IF( RATREC(1).NE.0.00D+00 )THEN
      WRITE(IERROR,90100)1
      WRITE(IERROR,90120)RATREC(1)
      GOTO 180
      ENDIF
C
      IFAIL=0
C
C.....(1) ASSEMBLE THE TRI-DIAGONAL MATRIX..............................
C
      DO 20 I=1,N
      TRIDAG(I,I)=-RATION(I)-RATREC(I)
      IF( I.GT.1 )TRIDAG(I,I-1)=RATION(I-1)
      IF( I.LT.N )TRIDAG(I,I+1)=RATREC(I+1)
      IF(IMORE.LE.0) GOTO 20
        DO 15 J=1,N
          TRIDAG(I,J) = TRIDAG(I,J) + F(I,J)
   15   CONTINUE
   20 CONTINUE
      IF(IDEB.EQ.1)THEN
         WRITE(LOUT,*) 'SPLSRC..ASSEMBLE MATRIX'
         DO 123  I=1,N
           WRITE(LOUT,'(A,8E11.4)') '    TRIDAG :',(TRIDAG(I,J),J=1,N)
 123     CONTINUE
      ENDIF
C
C.....(1A) REMOVE SPECIES WHICH ARE NOT COUPLED.........................
C
      NEQ = 0
      DO 25 I=1,N
        TMAX   = 0.0D0
        LEQ(I) = .FALSE.
        DO 22 J=1,N
          TMAX  = DMAX1( TMAX,DABS(TRIDAG(I,J)) )
 22     CONTINUE
        IF(TMAX.GT.0.0D0)THEN
           NEQ      = NEQ + 1
           IEQ(NEQ) = I
           LEQ(I)   = .TRUE.
        ENDIF
   25 CONTINUE
      IF(NEQ.EQ.0)GOTO 225
      DO 27 I=1,NEQ
         DO 26 J=1,NEQ
           TRIDAG(I,J) = TRIDAG(IEQ(I),IEQ(J))
 26      CONTINUE
 27   CONTINUE
      IF(IDEB.EQ.1)THEN
         WRITE(LOUT,*) '    REMOVE UNCOUPLED ->'
         WRITE(LOUT,*) '        NEQ:',NEQ
         WRITE(LOUT,*) '        IEQ:',(IEQ(I),I=1,NEQ)
         WRITE(LOUT,*) '        LEQ:',(LEQ(I),I=1,N)
         WRITE(LOUT,*) '    TRIDAG :'
         DO 1234 I=1,N
           WRITE(LOUT,'(A,8E11.4)') '    TRIDAG :',(TRIDAG(I,J),J=1,N)
 1234    CONTINUE
      ENDIF
C
C.....(2) CALCULATE EIGENVALUES & EIGENVECTORS OF TRIDAG(,).............
C
C         SAVE TRIDAG (NECESSARY ONLY TO CHECK SOLUTION)
      CALL DCOPY(MZ*MZ,TRIDAG(1,1),1,AWORK(1,1),1)
C
      CALL EB06AD(TRIDAG,MZ,VECTOR,MZ,VALUES,NEQ,WORK,IFAIL)
      IF( IFAIL.NE.0 )THEN
      IF( IFAIL.EQ.-1 )WRITE(IERROR,90040)NEQ
      IF( IFAIL.GT.0 )WRITE(IERROR,90060)IFAIL
      GOTO 180
      ENDIF
C
C         RESTORE TRIDAG (DITTO)
      CALL DCOPY(MZ*MZ,AWORK(1,1),1,TRIDAG(1,1),1)
C
      IF( IFAIL.NE.0 )GOTO 180
C
C.....(3) & (4) FIRST FIND INVERSE MATRIX OF VECTOR(,)..................
C         SAVE VECTOR
      CALL DCOPY(MZ*MZ,VECTOR(1,1),1,AWORK(1,1),1)
C
      CALL MINV(VECTOR,NEQ,MZ,WORK,DET,0.0D0,0,1)
C
C     (3) FIND C0(K)....................................................
C
      DO 60 I=1,NEQ
      C0(I)=0.0D+00
      DO 40 K=1,NEQ
      KEQ = IEQ(K)
      C0(I)=C0(I)+VECTOR(I,K)*DENSI0(KEQ)
   40 CONTINUE
   60 CONTINUE
C
C     (4) FIND XU(K)....................................................
C
      DO 100 I=1,NEQ
      XU(I)=0.0D+00
      DO 80 K=1,NEQ
      KEQ = IEQ(K)
      XU(I)=XU(I)+VECTOR(I,K)*EXTSRC(KEQ)
   80 CONTINUE
  100 CONTINUE
C
C.....(5) COMPUTE C(K)..................................................
C         RESTORE VECTOR
      CALL DCOPY(MZ*MZ,AWORK(1,1),1,VECTOR(1,1),1)
C
      DO 120 I=1,NEQ
      EXPN=DREAL(VALUES(I))*TAU
      IF( DABS(EXPN).GT.EPS )THEN
      IF( EXPN.GT.EXPMAX )THEN
      WRITE(IERROR,90020)EXPMAX/DREAL(VALUES(I))
      IFAIL=-88888
      GOTO 180
      ENDIF
      IF( EXPN.LT.-EXPMAX )EXPN=-EXPMAX
      DEXPN=DEXP(EXPN)
      TRAN=C0(I)
      IF( XU(I).NE.0.0D0 )TRAN=TRAN+XU(I)*(1.0D0-1.0D0/DEXPN)
     &                         /DREAL(VALUES(I))
      C(I)=TRAN*DEXPN
      ELSE
      C(I)=C0(I)+XU(I)*TAU
      ENDIF
  120 CONTINUE
C
C.....(6) COMPUTE DENSI(I)..............................................
C
      DO 160 I=1,NEQ
      ID = IEQ(I)
      DENSI(ID)=0.0D+00
      DO 140 K=1,NEQ
      DENSI(ID)=DENSI(ID)+C(K)*VECTOR(I,K)
  140 CONTINUE
  160 CONTINUE
      IF(IDEB.EQ.1)THEN
         WRITE(LOUT,*) '    OUTPUT - SETTING COUPLED EQUATIONS'
         WRITE(LOUT,*) '      DENSI:',(DENSI(I),I=1,N)
      ENDIF
C
C.....(7) COMPUTE DENSI(I) FOR UNCOUPLED EQUATIONS......................
C
  225 CONTINUE
C
      IF(NEQ.LT.N)THEN
        DO 240 I=1,N
          IF(.NOT.LEQ(I))THEN
            DENSI(I)=DENSI0(I)+EXTSRC(I)*TAU
          ENDIF
  240   CONTINUE
      ENDIF
      IF(IDEB.EQ.1)THEN
         WRITE(LOUT,*) '    OUTPUT - ADDING UNCOUPLED EQUATIONS'
         WRITE(LOUT,*) '      DENSI:',(DENSI(I),I=1,N)
      ENDIF
C
C.......................................................................
C
  180 RETURN
C
C.......................................................................
C
90020 FORMAT(
     &     ' *** ERROR *** EXPONENTIAL OVERFLOW. REDUCE TAU TO AT MOST '
     &     ,1PE10.4,' SEC')
90040 FORMAT(' *** ERROR *** ORDER OF THE MATRIX IS NOT POSTIIVE : N = '
     &       ,I2)
90060 FORMAT(
     &' *** ERROR *** THE QR METHOD FAILED TO CONVERGE FOR EIGENVALUE =
     &',I2)
90080 FORMAT(
     &  ' *** ERROR *** IONISATION RATE MUST BE ZERO FOR CHARGED STATE '
     &  ,I2)
90100 FORMAT(
     &' *** ERROR *** RECOMBINATION RATE MUST BE ZERO FOR CHARGED STATE
     &',I2)
90120 FORMAT('               CURRENT VALUE = ',1PE12.4,' SEC-1')
      END
**++EOF
**==NEUPRO
C
C=======================================================================
      SUBROUTINE NEUPRO
     I                (AMASS,GAMMAI,EA,N,F,V,DENE,SVI,
     O                 S,DENA,GAMMAO)
C
C     RETURNS THE IONISATION SOURCE AND THE ATOMIC DENSITY OF A
C     MONOENERGETIC BEAM OF ATOMS INJECTED INTO A STRING OF
C     PLASMA CELLS
C
C    I   AMASS       MASS                     ( AMU )
C    I   GAMMAI      INFLUX OF ATOMS          ( S**(-1) )
C    I   EA          ENERGY OF ATOMS          ( EV )
C    I   N           NUMBER OF CELLS
C    I   F(I)        <SURFACE> OF I-TH CELL   ( CM**2 )
C    I   V(I)        VOLUME OF I-TH CELL      ( CM**3 )
C    I   DENE(I)     ELECTRON DENSITY         ( CM**(-3) )
C    I   SVI(I)      IONISATION RATE          ( CM**3/S )
C    O   S(I)        IONISATION SOURCE        ( CM**(-3) S**(-1) )
C    O   DENA(I)     ATOMIC DENSITY           ( CM**(-3) )
C    O   GAMMAO      OUTFLUX OF ATOMS         ( S**(-1) )
C
      IMPLICIT REAL*8(A-H,O-Z)
C
      PARAMETER (EV=1.6022D-12, AMU=1.6726D-24)
C
      DIMENSION F(N),V(N),DENE(N),SVI(N),S(N),DENA(N)
C
      VA = DSQRT(2.0D0*EA*EV/(AMASS*AMU))
C
      GAMMAO = GAMMAI
      DO 100 I=1,N
CW      WRITE(LOUT,*) ' NEUPRO IN  I=',I,' F=',F(I),' V=',V(I),
CW   &             ' NE=',DENE(I),' SVI=',SVI(I)
        S(I) = 0.0D0
        DENA(I) = GAMMAO/(VA*F(I))
        IF(GAMMAO.LE.0.0D0) GOTO 100
        RATE = DENE(I)*SVI(I)
        IF(RATE.LE.0.0D0) GOTO 100
C         IONISATION SOURCE IN THE VOLUME:
        S(I) = DMIN1( GAMMAO/V(I) , DENA(I)*RATE )
C         ATOMIC DENSITY IN THE VOLUME:
        DENA(I) = S(I)/RATE
C         OUTFLUX TO NEIGHBOUR CELL;
        GAMMAO = DMAX1( GAMMAO - S(I)*V(I) , 0.0D0 )
        IF(GAMMAO/GAMMAI.LE.1.0D-06) GAMMAO=0.0D0
CW      WRITE(LOUT,*) ' NEUPRO OUT I=',I,' S=',S(I),' NA=',DENA(I),
CW   &             ' FO =',GAMMAO
  100 CONTINUE
C
  120 RETURN
      END
**++EOF
