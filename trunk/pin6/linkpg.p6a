C
C=======================================================================
      SUBROUTINE VLINK( REQ , ACT , IER )
      IMPLICIT REAL*8(A-H,O-Z)
C
      CHARACTER*9 VERSON
      PARAMETER( VERSON = '02-MAR-99' )
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO OBTAIN THE VERSION OF THE 'LINKPG' MODULE.
C
C INPUT   : (C*9) REQ    = REQUIRED VERSION.
C
C OUTPUT  : (C*9) ACT    = ACTUAL VERSION.
C           (I*4) IER    = 0 IF REQ =  ACT
C                        = 1 IF REQ <> ACT
C
C PROGRAM : (C*9) VERSON = VERSION
C
C AUTHOR  : JAMES SPENCE (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 09-DEC-91
C
C-----------------------------------------------------------------------
C
      CHARACTER*9   REQ , ACT
      INTEGER*4     IER
C
C.......................................................................
C
      ACT = VERSON
C
C.......................................................................
C
      IF( REQ.EQ.ACT ) THEN
          IER = 0
      ELSE
          IER = 1
      END IF
C
C.......................................................................
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE LINKPG( IFILE  , IOUT   , IPUNCH , ISHOT  , BCD
     C                 , LTEST  , LMC
     C                 , MP     , MC     , MR     , NXW
     C                 , MACRO1 , MACRO2 , MACRO3 , MACRO
     C                 , MDEBWR , MDEBPT
     C                 , NP     , NC     , NR     , IOPEN
     C                 , MVESM  , MVESC
     C                 , MFLX   , MFLXH  , MFLXPB , MWREG
     C                 , MLK    , MMPG   , INIZ   , MTOREG
     C                 , ITAG   , NJ     , KORY   , ITAGDV
     C                 , RMESH  , ZMESH
     C                 , DENSE  , DENSI  , TEMPE  , TEMPI
     C                 , VPAR   , BSIGN  , SH     , FIPAR  , FIPER
     C                 , NZE2D  , IZE2D  , MIMP
     C                 , MIONH  , NIONH  , IOPTRC , RECMAT , RMATW
     C                 , PERC   , FIPARZ , FIPERZ , ZZ     , IREFCT
     D                 , JPRGT  , JPLFT  , JXRM   , JXLM
     D                 , RPX    , ZPX    , NYREFG , MODEZR , ZGAMMA
     E                 , NHIST  , ISTEPA , ILSTMC , IFPRIM , KINDPR
     E                 , IFCHAN , IMPURE , IWRITE , IREAD
     E                 , ICORE  , ICHARG , IAEMIS , IZWALL
     E                 , IALB   , IFWALD , IRECO  , ISP93
     E                 , MIXS   , IXS    , MCX    , NTSPUT , ISPOFF
     E                 , YNOSP  , MCOLP  , NOZPMP , IMOMSO
     E                 , TDIVW  , TPRIV  , TSUBD  , TEVGAP
     F                 , HMASS  ,          TWALL  , TTARG  , RGAMMA
     F                 , ISPLIT , WSPLIT , ICODE  , ICHKP
     F                 , IHYEAR , IZYEAR , IDYEAR , USERID
     F                 , LWALL  , LBUFLE , LPWALL , LPSEG
     G                 , ZESCUT , IALBPG , ALBPG  , ALBEPG , ALBATO
     G                 , EATMD  , FRAPUF , IHOR   , DECIMA , ISEHHE
     G                 , RNLITE , EWLITE , INUTPG , EATMR  , TPUFF
     G                 , LPUMP  , INPUMP , FPUMP  , ALBPMP , ALBLK
     G                 , PSEMPO , PSEMPT , PSEMPI , PSEMPX , FRAPUZ
     G                 , IPSEMP , PSEMP  , PSEMG  , PSEMPB
     G                 , IVIEW  , VIEW   , IPVOID , PWMAT
     G                 , FTRIM  , IFTRIM , LFULL
     G                 , ITIMIO , ITAIO1 , ITAIO2 , TSLICE
     G                 , AYIZ   , BYIZ   , ICORRN
     G                 , DCUTCX , TCUTCX , ITAU   , IYCHEM , EYCHEM
     G                 , AYCHEM , ALFCH7
     G                 , IDBHST , XGAUGE , YGAUGE , RGAUGE , LGAUGE
     G                 , MCLRS  , XLRS   , YLRS   , LLRS
     G                 , MCGAP  , XGAP   , YGAP   , PGAP   , LGAP
     G                 , ANGNOR , MPWALL , NPWALL , FPWALL
     O                 , SUMPAR , SUMPER
     O                 , TOTION , SOLION , TOTHES , TOTHEA
     O                 , TOTZSP , TOTZES , TOTZEA , TOTHLK , TOTZLK
     O                 , PROFSN , PROFQ  , PROFQE , PROFA  , DAHF
     O                 , PROFM  , PROFZ  , PROFSZ , PROFMP
     O                 , PROFMN , PROFHA
     O                 , ENEUTA , ENEUTM , ENEUTZ
     O                 , VOLP   , PDIST
     O                 , VNUTAP , VNUTMP
     O                 , VA     , VM     , HORTON
     O                 , SRECYC , SRECOM , ENEUCX , ERELHI
     O                 , TOTZSN , SMACRO , PMACRO , VMACRO
     O                 , NVESM  , NVESP  , RVESM  , ZVESM  , IVESM
     O                 , GVESM
     O                 , NVESC  , XVESC
     O                 , NPLASM , RPLASM , ZPLASM , IPLASM , GPLASM
     O                 , IDEBWR , KDEBWR , NDBHST , XDEBWR
     O                 , PRQELA , PRPELA , PRQELM , PRPELM
     O                 , NFLXHW , FLUXHW , FLUXPB , FLUXZW , FLXHSW
     O                 , STMOUT , HTMOUT , YTMOUT , ZTMOUT
     O                 , GWREG  , AWREG  , FWREG  , MAPFLX , BUFHSW
     &           )
      IMPLICIT REAL*8(A-H,O-Z)
C
      SAVE
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO WRITE A MONTE CARLO FILE WHICH WILL BE READ BY NIMBUS
C           THEN CALL SUBROUTINE NIMBUS.
C
C INPUT   : IFILE       = WRITE FILE      ON STREAM 'IFILE'
C           IOUT        = WRITE PRINT-OUT ON STREAM 'IOUT'
C           IPUNCH      = NIMBUS OUTPUT   ON STREAM 'IPUNCH'
C           ISHOT       = SHOT NUMBER
C
C           BCD         = TEXT
C
C           LTEST       = TESTING GEOMETRY (SEE. S.R. DATA)
C           LMC         = PRODUCE NIMBUS FILE BUT EXIT BEFORE CALLING
C                         NIMBUS.  CHECKING OF LRS AND GAUGES IS
C                         DISABLED
C
C MESH    : MP          = MAXIMUM NUMBER OF K-POINTS ALLOWED
C           MC          = MAXIMUM NUMBER OF RINGS    ALLOWED
C           MR          = MAXIMUM NUMBER OF ROWS     ALLOWED
C           MDEBWR      = MAX. NO. OF NEUTRAL TRAJECTORIES
C           MDEBPT      = MAX. NO. OF NEUTRAL TRAJECTORY TRACKS
C           NP          = NUMBER OF MESH POINTS
C           NC          = NUMBER OF RINGS IN K-MESH
C           NR          = NUMBER OF ROWS  IN K-MESH
C           ITAG(K,1)   = RING POINT K LIES ON
C               (K,2)   = ROW  POINT K LIES ON, IF ANY.
C               (K,3)   = Y-SWEEP INFORMATION FOR POINT K
C               (K,4)   = X-SWEEP INFORMATION FOR POINT K
C               (K,5)   = M.C     INFORMATION FOR POINT K
C           KORPG(K)    = PLASMA POLYGON # N WITH CENTRE AT POINT K
C           KORKG(N)    = FIRST K POINT TO LIE IN PLASMA POLYGON # N
C           NJ(I)       = NUMBER OF K POINT IN RING I
C           KORY(I,J)   = K VALUE OG THE J-TH POINT IN RING I
C           RMESH(K)    = R - COORD OF POINT K
C           ZMESH(K)    = Z - COORD OF POINT K
C           DENSE(K)    = ELECTRON DENSITY     AT MESH POINT K (CM-3)
C           DENSI(K)    = ION      DENSITY     AT MESH POINT K (CM-3)
C           TEMPE(K)    = ELECTRON TEMPERATURE AT MESH POINT K (EV)
C           TEMPI(K)    = ION      TEMPERATURE AT MESH POINT K (EV)
C           VPAR(K)     = PARALLEL VELOCITY    AT MESH POINT K (CM/S)
C           BSIGN       = DIRECTION OF TOROIDAL FIELD (+1/-1)
C           SH(K)       = MAGNETIC ANGLE
C           FIPAR(K)    = FLUX*CM POLOIDAL       AT POINT K
C           FIPER(K)    = FLUX*CM PERPENDICULAR  AT POINT K
C           NZE2D       = NO. OF IMPURITY SPECIES IN EDGE2D
C                         (AT LEAST ONE, EVEN THOUGH IT IS NOT
C                          SIMULATED BY NIMBUS WHEN IFPRIM=0)
C           IZE2D(K),   >0 ATOMIC NUMBER OF INTRINSIC IMP. (=IZWALL)
C            K=1,NZE2D  =0 NO ION IMPURITY SPUTTERING
C                       <0  - ATOMIC NUMBER OF RECYCLABLE IMPURITY
C           MIMP        = 0 --- ONE IMPURITY SPECIES IN NIMBUS
C                       > 0 --- MULTI-IMPURITY SPECIES IN NIMBUS
C           FIPARZ(K,*) = Z-FLUX*CM POLOIDAL       AT POINT K
C           FIPERZ(K,*) = Z-FLUX*CM PERPENDICULAR  AT POINT K
C           ZZ(K)       = CHARGE OF STAGE IZ       AT POINT K
C           ITAGDV(K)   = 0 --- UNCHANGED BY DIVERTOR PLATES
C                       = 1 ---   CHANGED BY RHS DIVERTOR PLATE
C                       = 2 ---   CHANGED BY LHS DIVERTOR PLATE
C           IREFCT      = -1 -- GEOMETRY HAS NOT BEEN REFLECTED
C                       =  0 -- GEOMETRY REFLECTION IS UNKNOWN
C                       = +1 -- GEOMETRY HAS BEEN REFLECTED
C
C X-POINT : JPRGT       = LAST  ROW WHICH JOINS THE MAIN PLASMA (RIGHT)
C           JPLFT       = FIRST ROW WHICH JOINS THE MAIN PLASMA (LEFT)
C           JXRM        = JPRGT ADJUSTMENT
C           JXLM        = JPLFT ADJUSTMENT
C           RPX         = R COORDINATE OF THE X-POINT
C           ZPX         = Z COORDINATE OF THE X-POINT
C           NYREFG      = NUMBER OF ROWS AT RING NXW
C
C           MODEZR      = MODEL FOR IMPURITY ION RECYCLING
C
C NIMBUS  : NHIST       = NUMBER OF HISTORIES
C           ISTEPA      = STEP AT WHICH CALLED
C           ILSTMC      = STEP AT WHICH PREVIOUS M.C WAS CALLED
C           IFPRIM      = 1 --- IF IMPURITY SPUTTERED ARE TO BE
C                               PROCESSED UP TO IONISATION POINT
C           KINDPR      = PRINT-OUT OPTIONS
C           IWRITE      = 1 --- WRITE RESULTS
C           IREAD       = 1 --- READ  RESULTS
C           IFCHAN      = 0 --- NO CHANNELS
C                         1 ---    CHANNELS
C           IMPURE      =<>0--- IF PLASMA IS IMPURE
C           ICORE       = 1 --- IF THE CORE IS TO BE CONSIDERED
C           IAEMIS      = 1 --- ATOMIC RE-EMISSION
C                         0 --- MOLECULAR RE-EMISSION
C                        -1 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + ATOMIC RE-EMISSION OUTSIDE INUTPG()
C                        -2 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + MOLECULAR RE-EMISSION OUTSIDE INUTPG()
C           IZWALL      = ATOMIC NUMBER OF WALL
C           ICHARG      = CHARGE OF IONIZED HEAVY IMPURITY GOING BACK
C                         TO WALLS
C           IALB        = 0 --- ALBEDO REGION IS A WALL
C                         1 --- ALBEDO REGION IS A TRUE ALBEDO
C                         2 --- ALBEDO REGION IS A VOID
C           IFWALD      = 1 --- IF DISTRIBUTIONS OF SPUTTERING AND
C                               THERMAL LOAD ALONG WALLS ARE REQUIRED
C           IRECO       = 1,2 - IF NEUTRALS ARE BORN BY RECOMBINATION
C           ISP93       = 1 --- IF SPUTTERING DATA 1993 ARE TO BE USED
C           MIXS        = MAXIMUM DIMENSION OF IXS()
C           IXS(1)      = X-SECTION MODEL
C              (2)      = USE JANEV FOR CH.EX RATE COEF. (IXS(1)>2)
C              (3)      = USE JANEV FOR MOLEC RATE COEF. (IXS(1)>2)
C              (4)      = USE ADAS FOR IMP. ION. RATE COEF.
C              (5)      = SWITCH ON HYRDOGEN RECOMBINATION (1)
C           MCX         = MODEL FOR ENERGY AFTER C.X.
C           NTSPUT      = 0 --- TURN OFF NEUTRAL SPUTT. OF IMPURITIES
C           ISPOFF()    = SWITCH OFF SPUTTER IN THESE MACRO-ZONES
C           YNOSP       = SWITCH OFF SPUTTER BELOW YNOSP
C           MCOLP       = MAX. NO. OF COLLIS. BEFORE R.R. OR ANALOG GAME
C           NOZPMP      = 0 --- PUMPING OF IMPURITIES IN PUMP
C                       = 1 --- NO PUMPING OF IMPURITIES IN PUMP
C
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIVATE REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C           ALBPG()     = ALBEDO REFLECTIVITY FRACTION
C           ALBEPG()    = ENERGY = E*ALBEPG()
C           ALBATO      = PROBABILITY THAT FUEL ATOMS AND ENERGETIC
C                         HELIUM ARE ALBEDOED AS ATOMS WITH
C                         ENERGY=E*ALBENE(IR)
C           DECIMA      = DECIMATION PROBABILITY
C           ISEHHE      = ELASTIC SCATTERING MODEL
C
C           RNLITE      = RECYCLED LIGHT IMPURITY FRACTION
C           EWLITE      = ENERGY OF LIGHT IMPURITY
C
C           INUTPG()    >  0 --- NIMBUS WALL REGION SET AS NEUTRAL
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -1 --- NIMBUS WALL REG. IN PRIV. REGION COVER
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -3 --- NIMBUS WALL REG. IN INNER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -4 --- NIMBUS WALL REG. IN OUTER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -5 --- NIMBUS WALL REG. IN INNER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -6 --- NIMBUS WALL REG. IN OUTER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -7 --- NIMBUS WALL REG. IN INNER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -8 --- BUFFLE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -9 --- ENTIRE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                                (INCL. BUFFLE)
C                       (ORDER OF INUTPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C           EATMR       = ENERGY OF FORCED REFLECTED NEUTRALS (EV)
C                         (IF <=0 ,USE DISSOCIATION ENERGY)
C           TPUFF       = TEMPERATURE OF PUFFED NEUTRALS (EV)
C
C           LPUMP       = .T. --- SWITCH ON PUMP IN PUMP STRUCTURE
C           INPUMP      >  0  --- INPUT CHANNEL TO READ PUMP FILE
C           FPUMP       = FULLY QUALIFIED NAME OF PUMP FILE (NO QUOTES)
C           ALBPMP      = ALBEDO FOR PUMP (=1.0-PUMP EFF)
C           PSEMPO      = PROBABILITY OF SEMI-PERMEABILITY OF OUTER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPT      = PROBABILITY OF SEMI-PERMEABILITY OF TARGET
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPI      = PROBABILITY OF SEMI-PERMEABILITY OF INNER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           IPSEMP()    = NIMBUS REGION IN WHICH THE SEMI-PERMEABILITY
C                         FRACTION IS SPECIFIED OVERRIDING ABOVE
C           PSEMP()     = ABOVE FRACTIONS FOR EACH SPECIFIED REGION
C           PSEMG()     = STORAGE FOR PUMP SIDE TRANSPARANCY OF GAPS
C
C           PSEMPB(I)   = PROBABILITY OF SEMI-PERMEABILITY OF BAFFLE
C                         I = 0 --- ORIGINAL BAFFLE
C                         I > 0 --- EXTRA BAFFLE INDEX
C                         (1.0D+30 --- USE BAFFLE WITHOUT THIS)
C
C           IVIEW       = 0 --- NIMBUS GEOMETRY MAP PICTURE (GEOM())
C                       < 0 --- ABOVE +
C                                NIMBUS GEOMETRY MAP PICTURE (VIEW())
C           VIEW(1)     = RMIN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C           VIEW(2)     = ZMIN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C           VIEW(3)     = RLEN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C           VIEW(4)     = ZLEN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C
C           IPVOID      = HOW TO TREAT THE PUMP VOID (M.R. 15)
C                         <>0 IT WILL PLAY NO PART IN DETERMINING
C                         WALL LOADING FLUX.
C                         IF <0, SWITCH OFF
C                         SPUTTERING FROM PUMP REGION WALLS
C           PWMAT       = MATERIAL OF PUMP WALL
C           FTRIM       = PREFIX FOR TRIM FILES ALSO SETS ITRIM IS
C                         NON-BLANK
C           IFTRIM      = TRIM STREAM UNIT
C           LFULL       = FULL/PARTIAL NIMBUS SETUP
C
C           ITIMIO      = FLAG FOR TIME-DEPENDENT SIMULATION
C                         (0-START, +1/-1 R/W ORDERING FOR BUFFERS)
C           ITAIO1      = 1ST BUFFER UNIT
C           ITAIO2      = 2ND BUFFER UNIT
C           TSLICE      = TIME SLICE (SECONDS)
C
C           AYIZ,BYIZ   = YIELD ENHANCING TERMS
C           ICORRN      = RANDOM NUM. CORRELATION FLAG (0-N0 <>0 YES)
C           IYCHEM      = CHEMICAL SPUTTERING FLAG
C           EYCHEM      = ENERGY OF CHEMICALLY-SPUTTERED C NEUTRALS
C           AYCHEM      = FUDGE FACTOR FOR CHEM. SPUTT.
C           ALFCH7      = PARAMETER FOR CHEM. SPUTT. 7
C
C           IDBHST()    = HISTORIES FROM WHICH TO RETURN NEUTRAL
C                         TRAJECTORIES
C
C           XGAUGE()    = R-COORD TO OVERRIDE GAUGE LABELLED LGAUGE()
C           YGAUGE()    = Z-COORD TO OVERRIDE GAUGE LABELLED LGAUGE()
C           RGAUGE()    = RADIUS  TO OVERRIDE GAUGE LABELLED LGAUGE()
C           LGAUGE()    = LABEL FOR GAUGE REGION TO OVERRIDE
C
C           MCLRS       = MAX. ALLOWED NO. OF LEAK RECYCLING SEGMENTS
C                         WHICH CAN BE CHANGED FROM THOSE IN THE PUMP
C                         FILE
C           LLRS(I)     = IDENTIFIES WHICH LRS IS TO BE CHANGED
C           XLRS(I,)    = R-COORD PAIRS TO BE CHANGED FOR THE LRS
C                         WITH ID SAME AS LLRS(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C           YLRS(I,)    = Z-COORD PAIRS TO BE CHANGED FOR THE LRS
C                         WITH ID SAME AS LLRS(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C
C           MCGAP       = MAX. ALLOWED NO. OF GAPS WHICH CAN BE
C                         CHANGED FROM THOSE IN THE PUMP FILE
C           LGAP(I)     = IDENTIFIES WHICH GAP IS TO BE CHANGED
C           XGAP(I,)    = R-COORD PAIRS TO BE CHANGED FOR THE GAP
C                         WITH ID SAME AS LGAP(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C           YGAP(I,)    = Z-COORD PAIRS TO BE CHANGED FOR THE GAP
C                         WITH ID SAME AS LGAP(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C           PGAP(I,1)   = TRANSPARACNY FRACTION (PLASMA SIDE) TO BE
C                         CHANGED FOR THE GAP WITH ID SAME AS LGAP(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C               (I,2)   = TRANSPARACNY FRACTION (PUMP SIDE) TO BE
C                         CHANGED FOR THE GAP WITH ID SAME AS LGAP(I)
C                         (1.0D+30 = USE PUMP FILE VALUE)
C
C           DCUTCX      = MAX. DENSITY FOR C.X.
C           TCUTCX      = MIN. TEMPERATURE FOR C.X.
C           ITAU        = MODEL FOR FLUX ESTIMATOR
C
C           ANGNOR      = ANGLE WITH WALL NORMAL FOR H-FLUXES SCORES
C
C           MPWALL      = MAXIMUM NUMBER OF EXTRA POINTS TO INSERT
C                         IN THE LINE JOINING THE EXTRAPOLATIONS OF
C                         THE PROVATE REGION VESSEL WALL END-POINTS
C           NPWALL      = ACTUAL NUMBER OF THE ABOVE
C           FPWALL()    = FRACTIONAL POSITIONS ALONG THE ABOVE LINE
C                         (MONOTONIC AND IN THE EXCLSUIVE RANGE (0,1)
C
C LINK    : HMASS       = MASS OF ION (A.U)
C           TWALL       = VESSEL WALL TEMPERATURE (CELSIUS)
C           TTARG       = DIVERTOR TARGET TEMPERATURE (CELSIUS)
C           TDIVW       = DIVERTOR  WALL TEMPERATURE (CELSIUS) ++++
C           TPRIV       = PRIV. REG WALL TEMPERATURE (CELSIUS) ++++
C           TSUBD       = SUBD. REG WALL TEMPERATURE (CELSIUS) ++++
C           TEVGAP      = TEMPERATURE OF VOIDS (EV)
C           RGAMMA      = RECYCLING SOURCE INTENSITY (#/SEC)
C           ISPLIT      = 1 --- IF SPLITTING IS USED
C           WSPLIT()    = SPLITTING FACTORS (CONSTANT ALONG CHANNELS)
C           ICODE       = 0   PIN
C                       = 1   EDGE1D
C                       = 2   EDGE2D
C           ICHKP       = 0 --- STOP IF POLYGON AREA PROBLEMS
C                       = 1 --- WARN IF POLYGON AREA PROBLEMS
C           LWALL       = USE INNER VESSEL WALL IF TRUE (& NVES>0)
C           LBUFLE      = USE BAFFLE IF TRUE (& NBUFLE>0 & IALB=2)
C           LPWALL      = .T. --- USE ACTUAL PRIVATE REGION VESSEL
C                                 WALL IN THE "ALBEDO" COVER
C           LPSEG       = .T. --- EXPLICIT SOURCE SEGMENTS AROUND
C                                 PRIVATE VOID/ALBEDO/WALL REGION
C           NVES        = NUMBER OF COORDINATES FORMING INNER VESSEL
C           RVES()      = R-COORDINATES OF INNER VESSEL
C           ZVES()      = Z-COORDINATES OF INNER VESSEL
C           NBUFLE      = NUMBER OF COORDINATES FORMING BAFFLE
C           RBUFLE()    = R-COORDINATES OF BAFFLE (ANTI-CLOCKWISE)
C           ZBUFLE()    = Z-COORDINATES OF BAFFLE (ANTI-CLOCKWISE)
C           NBUFMX      = NO. OF EXTRA BAFFLES
C           NBUFX(I)    = NUMBER OF COORDS FORMING EXTRA BAFFLE # I
C           RBUFX(I,)   = R-COORDS OF EXTRA BAFFLE # I (ANTI-CLOCKWISE)
C           ZBUFX(I,)   = Z-COORDS OF EXTRA BAFFLE # I (ANTI-CLOCKWISE)
C           EATMD       = ENERGY OF NEUTRALS RE-EMITTED AS ATOMS
C                         (IF <=0 ,USE DISSOCIATION ENERGY)
C           FRAPUF(K,1/2= FRACTION OF PUFFED NEUTRALS
C                         (1-NORMAL, 2-POLOIDAL)
C                         (AT T=TPUFF) OVER TOTAL (PUFF+RECYCL.)
C           FRAPUZ(K,1/2,IZ) DITTO FOR IMPUR.
C           IHOR        = 1 --- SWITCH ON HORTON SECTION
C
C           MACRO       = NUMBER OF MACRO-REGIONS (CFR ITAGRM)
C           MVESM       = MAX. NUMBER OF NIMBUS VESSEL SEGMENT PAIRS
C           MVESC       = MAX. NUMBER OF VESSEL 'CIR' STRUCTURES
C           MFLX        = 2ND DIMENSION OF FLUXHW(,)
C           MFLXH       = 2ND DIMENSION OF FLXHSW(,)
C           MFLXPB      = 2ND DIMENSION OF FLUXPB(,)
C           MWREG       = NUMBER OF WALL (SEGMENT) REGIONS
C           MMPG        = MAX. NO. OF POLYGONS (INPUT FROM INTFAC)
C
C           MLK         = MAX. NO. OF LEAK SEGMENTS
C           INIZ        = RANDOM NUMBER SEED FOR NIMBUS
C
C           MTOREG(M)   = WALL SEGMENT REGION ASSOCIATED WITH NIMBUS #M
C
C
C PROGRAM : IT5(L,1)    = NIMBUS POLYGON INDEX = M (GOING INWARDS)
C           IT5(L,2)    = UPPER VERTEX NEAREST LIMITER FOR ITAGM(M,2)=5
C           IT5(L,3)    = LOWER VERTEX NEAREST LIMITER FOR ITAGM(M,2)=5
C           NT5         = TOTAL NUMBER OF L'S
C           IT4(L,1)    = NIMBUS POLYGON INDEX = M (GOING INWARDS)
C           IT4(L,2)    = UPPER VERTEX NEAREST LIMITER FOR ITAGM(M,2)=4
C           IT4(L,3)    = LOWER VERTEX NEAREST LIMITER FOR ITAGM(M,2)=4
C           NT4         = TOTAL NUMBER OF L'S
C
C           NLIM(1)     = REGION OF 1ST LIMITER
C           NLIM(2)     = REGION OF 2ND LIMITER
C
C           NCHAN       = NUMBER OF CHANNELS
C           MCHAN(IC)   = NUMBER OF NIMBUS POLYGONS IN CHANNEL IC
C           JCHAN(IC,K) = THE KTH NIMBUS POLYGON IN CHANNEL IC
C
C           NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C
C           NSEGX       = NUMBER OF EXTRA (DIVERTOR WALL) SOURCE SEGMENT
C           ITAGSX(IX,1)= NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH EXTRA SOURCE SEGMENT 'IX'
C                 (IX,2)= VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                 (IX,3)= VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                 (IX,4)= 0 --- 'IX' HAS BEEN     INSERTED INTO ITAGS(,)
C                       = 1 --- 'IX' HAS NOT BEEN INSERTED INTO ITAGS(,)
C
C           NWSEG       = NUMBER OF VESSEL WALL SEGMENTS
C           NWSPG()     = WALL POLYGON ASSOCIATED WITH EACH SEGMENT
C           WSDIST()    = LENGTH OF VESSEL WALL SEGMENT
C           RWSEG(,)    = R-COORDINATES OF VESSEL WALL SEGMENT
C           ZWSEG(,)    = Z-COORDINATES OF VESSEL WALL SEGMENT
C           IWSEGK(1)   = 1ST  WALL SEGMENT OF INNER DIVERTOR TARGET
C                 (2)   = LAST WALL SEGMENT OF INNER DIVERTOR TARGET
C                 (3)   = 1ST  WALL SEGMENT OF OUTER DIVERTOR TARGET
C                 (4)   = LAST WALL SEGMENT OF OUTER DIVERTOR TARGET
C                 (5)   = 1ST  CORNER WALL SEGMENT
C                 (6)   = LAST CORNER WALL SEGMENT
C                 (5)   = 1ST  PRIVATE WALL SEGMENT
C                 (6)   = LAST PRIVATE WALL SEGMENT
C
C           NWALL       = NUMBER OF WALL POLYGONS
C           IWALL()     = ARRAY CONTAINING WALL POLYGON INDICIES + 2
C           NGAP        = NUMBER OF GAP POLYGONS
C           IGAP()      = ARRAY CONTAINING GAP POLYGONS INDICIES + 2
C           NALBDO      = NUMBER OF ALBEDO POLYGONS
C           IALBDO()    = ARRAY CONTAINING ALBEDO POLYGONS INDICIES+2
C
C           L1()        = GENERAL ARRAY
C           L2()        = GENERAL ARRAY
C           L3()        = GENERAL ARRAY
C           RGEN1()     = GENERAL ARRAY
C           ZGEN1()     = GENERAL ARRAY
C           RGEN2()     = GENERAL ARRAY
C           ZGEN2()     = GENERAL ARRAY
C
C     O     PUNCH(M, 1) = PROFSN = IONISED NEUTRALS SOURCE
C                (M, 2) = PROFQ  = ENERGY TRANSFERED TO PLASMA
C     B          (M, 3) = PROFMX = X-MOMENTUM
C                (M, 4) = PROFMY = Y-MOMENTUM
C     S          (M, 5) = PROFMZ = Z-MOMENTUM
C                (M, 6) = PROFQE = EN. SUBTRACTED TO PLASMA BY ELECTR.
C     O          (M, 7) = PROFA  = ATOM NEUTRALS DENSITY
C                (M, 8) = PROFM  = MOLECULE NEUTRALS DENSITY
C     L          (M, 9) = PROFZ  = HEAVY IMPURITY DENSITY
C                (M,10) = PROFHA = H-ALPHA RADIATION
C     E          (M,11) = PROFSZ = HEAVY IMPURITY SOURCE
C                (M,12) = ENEUTH = H-NEUTRALS ENERGY
C     T          (M,13) = ENEUTM = H2-NEUTRALS ENERGY
C                (M,14) = ENEUTZ = Z-NEUTRALS ENERGY
C     E          (M,15) = VA(1)  = H-NEUTRALS X-VELOCITY
C                (M,16) = VA(2)  = H-NEUTRALS Y-VELOCITY
C                (M,17) = VA(3)  = H-NEUTRALS Z-VELOCITY
C                (M,18) = VM(1) = H2-NEUTRALS X-VELOCITY
C                (M,19) = VM(2) = H2-NEUTRALS Y-VELOCITY
C                (M,20) = VM(3) = H2-NEUTRALS Z-VELOCITY
C                (M,21) =
C                (M,22) =
C                (M,23) = PRQELA = Q-EL,A SOURCE
C                (M,24) = PRPELA = P-EL,A
C                (M,25) = PRQELM = Q-EL,M
C                (M,26) = PRPELA = P-EL,M
C
C           NZCHAN      = NUMBER OF CHANNELS
C           JZCHAN(I)   = NUMBER OF ZONES IN CHANNEL # I
C           IZCHAN(I,J) = ZONES IN CHANNEL I
C
C           MZONE(M,1)  = NIMBUS CHANNEL THAT NIMBUS POLYGON M LIES IN
C                (M,2)  = NIMBUS CELL    THAT NIMBUS POLYGON M LIES IN
C
C           VOLM(M)     = NIMBUS CALCULATED AREA OF NIMBUS POLYGON # M.
C                         ( CF. AREAM(M) )
C
C           MFTRIM      = NO. OF TRIM FILES
C           PROTRM()    = TRIM PROJECTILE ATOMIC SYMBOL
C           TARTRM()    = TRIM TARGET     ATOMIC SYMBOL
C           TRMFIL()    = FULL NAME OF TRIM FILE
C
C           ITRIM       = FLAG FOR TRIM REFLECTION MODEL (<>0)
C
C           LHORIZ      = .T. --- HORIZONTALIZE TARGET ESCAPE FIGURE
C
C           FLHCHM()    = CHEMICAL SPUTTER FLUX TERM
C
C /CPUMP/ : (SEE 'cpump')
C
C /CLINK/ : (SEE 'clink')
C
C OUTPUT  : SUMPAR      = TOTAL POLOIDAL SOURCE (/1CM IN TOROIDAL DIR.)
C           SUMPER      = TOTAL PERPEND. SOURCE (/1CM IN TOROIDAL DIR.)
C           TOTION      = NEUTRALS IONISED (H+Z)
C           SOLION      = H-NEUTRALS IONISED IN SOL
C           TOTHES      = H-NEUTRALS ESCAPED
C           TOTHEA      = H-NEUTRALS ESCAPED THROUGH ALBEDO REGION
C           TOTZSP      = Z-NEUTRALS SPUTTERED (FROM H-IONS & NEUTRALS)
C                         - REDEPOSITION (FOR EFFECTIVE YIELD)
C           TOTZSN      = Z-NEUTRALS SPUTTERED (FROM NEUTRALS ONLY)
C           TOTZES      = Z-NEUTRALS ESCAPED
C           TOTZEA      = Z-NEUTRALS ESCAPED THROUGH ALBEDO REGION
C           TOTHLK      = H-NEUTRALS ESCAPED THROUGH LEAK REGION
C           TOTZLK      = Z-NEUTRALS ESCAPED THROUGH LEAK REGION
C           PROFSN(K)   = PROFILE OF IONISED NEUTRALS SOURCE
C           PROFQ(K)    = PROFILE OF ENERGY TRANSFERED TO PLASMA
C           PROFQE(K)   = PROFILE OF ENERGY SUBTRACTED TO PLASMA BY
C                         ELECTRONS.
C           PROFA(K)    = PROFILE OF NEUTRAL ATOM     DENSITY
C           PROFM(K)    = PROFILE OF NEUTRAL MOLECULE DENSITY
C           PROFZ(K)    = PROFILE OF HEAVY NEUTRAL IMPURITIES
C           PROFSZ(K)   = PROFILE OF HEAVY IMPURITIES SOURCE
C           PROFMP(K)   = PROFILE OF MOMENTUM PAR. TRANSFERED TO PLASMA
C           PROFMN(K)   = PROFILE OF MOMENTUM PER. TRANSFERED TO PLASMA
C           PROFHA(K)   = PROFILE OF H-ALPHA RADIATION
C           ENEUCX(K)   = EFFECTIVE C.X. NEUTRAL ENERGY
C           ERELHI(K)   = 1/2 M <(V-VI)**2> ATOMIC    (EV)
C           ENEUTM(K)   = H2-NEUTRALS ENERGY (EV)
C           ENEUTZ(K)   = Z-NEUTRALS ENERGY  (EV)
C           VOLP(N)     = NIMBUS CALCULATED AREA OF PLASMA POLYGON # N.
C                         THIS IS THE SUM OF THE AREA OF THE INDIVIDUAL
C                         NIMBUS POLYGONS (I.E VOLM(M)) MAKING UP
C                         PLASMA POLYGON # N.
C                         ( CF. AREAP(N) )
C           PDIST(K)    = LENGTH OF SOURCE SEGMENT
C           VNUTAP(K)   = PARALLEL VELOCITY OF H-NEUTRALS
C           VNUTMP(K)   = PARALLEL VELOCITY OF H2-NEUTRALS
C           VA(1-3,K)   = ATOM FLUID VELOCITY
C           VM(1-3,K)   = MOLECULE FLUID VELOCITY
C           ENEUTA(K)   = H-NEUTRALS ENERGY  (EV)
C           PRQELA(K)   = Q-EL,A SOURCE
C           PRPELA(K)   = P-EL,A SOURCE
C           PRQELM(K)   = Q-EL,M SOURCE
C           PRPELM(K)   = P-EL,M SOURCE
C           NFLXHW      = SIZE OF FLUXHW(,) (I.E NVESM + COMPOUND
C                         BUFFLE BUT EXCLUDING ACTUAL BUFFLE SEGMENTS)
C           FLUXHW(L,1) = R
C                    2  = Z
C                    3  = H + H2 FLUX ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    4  = H + H+ FLUX ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    5  = Z-SPUTTERING FLUX ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    6  = Z-REDEPOSITION FLUX ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    7  = ENERGY OF H ATOM ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    8  = H ATOM FLUX ONTO WALL L
C                                (EXCLUDING PUMP MACRO-REGION)
C                    9  = H-NEUTRALS IMPLANTATION FLUX TO WALLS
C
C           FLUXPB(L,1) = H + H2 FLUX ONTO PLASMA REGION L
C                                (EXCLUDING MAIN VOID MACRO-REGION)
C
C           FLXHSW(L,1,I) = H-NEUTRAL IMPLANTATION FLUX TO WALLS
C                           FOR HYDROGEN SPECIES #I
C
C           HORTON(1-3,1,K)  = <NH>      COLD/HOT/REFL.   ( /CM(3) )
C                      2       <H IONIS>                  ( /CM(3)S )
C                      3       <H CX>
C                      4       <VX>                       ( CM/S)
C                      5       <VY>
C                      6       <VZ>
C                      7       <VX VX>                    ( (CM/S)**2 )
C                      8       <VY VY>
C                      9       <VZ VZ>
C                     10       <VX VY>
C                     11       <VX VZ>
C                     12       <VY VZ>
C                   1,13       <H2 IONIS>                 ( /CM(3)S )
C                   2,13        NOT USED
C                 1-2,14       <H2 DISSOC> (SLOW/FAST)
C           SRECYC      = RECYCLING NEUTRAL SOURCE  ( S(-1) CM(-1) )
C           SRECOM      = RECOMB. NEUTRAL SOURCE  ( S(-1) CM(-1) )
C
C           FOR THE FOLLOWING --- Z=1 IS HYDROGEN
C                                 Z>1 IS IMPURITY SPECIES
C           SMACRO(M,1,Z)   = PRODUCTION, OF NEUTRAL, IN MACRO-REGION M
C           SMACRO(M,2,Z)   = IONISATION, OF NEUTTAL,  IN MACRO-REGION M
C           SMACRO(M,2+N,Z) = FLUX, OF NEUTRAL, FROM MR M INTO MR N
C           PMACRO(M,1,Z)   = PARTICLE CONTENT OF NEUTRAL (1 CM TOROIDAL)
C           PMACRO(M,2,Z)   = ENERGY   CONTENT OF NEUTRAL (1 CM TOROIDAL)
C           VMACRO(M)       = VOLUME OF MACRO-REGION M
C
C           NVESM       = NUMBER OF COORDINATES FORMING ACTUAL NIMBUS
C                         VESSEL SEGMENT PAIRS
C           NVESP       = NUMBER OF COORDINATES FORMING ACTUAL PUMP
C                         STRUCTURE PAIRS (DATA IS PIGGY-BACKED ON
C                         THE TOP OF RVESM(,) & ZVESM(,) AND RANGES
C                         FROM NVESM+1 TO NVESM+NVESP)
C     (R*4) RVESM(,)    = R-COORDINATE SEGMENT PAIR OF NIMBUS VESSEL
C     (R*4) ZVESM(,)    = Z-COORDINATE SEGMENT PAIR OF NIMBUS VESSEL
C     (I*4) IVESM(,1)   = WALL/ALBEDO POLYGON FORMING SEGMENT
C                (,2)   = VOID/PLASMA POLYGON FORMING SEGMENT
C                (,3)   = LINE DRAWING TYPE FOR SEGMENT
C                         (0=FULL 1=DOTTED 2=DASHED 3=LT.FULL 4=NO-PLOT)
C     (C*2) GVESM()     = GROUPING FOR EACH INDIVIDUAL SEGMENT
C                       = SEE GWREG()
C
C     (I*4) NVESC       = NUMBER OF VESSEL 'CIR' STRUCTURES
C     (R*4) XVESC(,1)   = R-COORDINATE OF 'CIR' CENTRE
C                (,2)   = Z-COORDINATE OF 'CIR' CENTRE
C                (,3)   = RADIUS OF 'CIR' STRUCTURE
C
C           NPLASM      = NUMBER OF COORDINATES FORMING PLASMA
C                         BOUNDARY SEGMENT PAIRS
C     (R*4) RPLASM(,)   = R-COORDINATE SEGMENT PAIR OF PLASMA BOUNDARY
C     (R*4) ZPLASM(,)   = Z-COORDINATE SEGMENT PAIR OF PLASMA BOUNDARY
C           IPLASM(,1)  = PLASMA POLYGON FORMING SEGMENT
C           IPLASM(,2)  = WALL/ALBEDO/DIVPMP/VOID POLYGON FORMING
C                         PLASMA BOUNDARY  SEGMENT
C     (C*2) GPLASM()    = GROUPING FOR EACH INDIVIDUAL SEGMENT
C                       = OT --- OUTER TARGET
C                       = OD --- OUTER DIVERTOR
C                       = IT --- INNER TARGET
C                       = ID --- INNER DIVERTOR
C                       = MS --- MAIN SOL (OUTSIDE DIVERTOR REGION)
C
C           IDEBWR      = NO. OF NEUTRAL TRAJECTORIES
C           KDEBWR()    = NO. OF TRACKS IN NEUTRAL TRAJECTORY
C           NDBHST()    = HISTORY NO. ASSOCIATED WITH NEUT. TRAJ.
C           XDEBWR(,,1) = X (R) COORDINATE OF NEUTRAL TRAJECTORY TRACK
C           XDEBWR(,,2) = Y (Z) COORDINATE OF NEUTRAL TRAJECTORY TRACK
C           XDEBWR(,,3) = Z     COORDINATE OF NEUTRAL TRAJECTORY TRACK
C
C           GWREG()     = VESSEL SEGMENT REGION LABELS
C                (1)    = OUTER TARGET
C                (2)    = OUTER CORNER
C                (3)    = OUTER DIVERTOR
C                (4)    = MAIN SOL (OUTSIDE DIVERTOR REGION)
C                (5)    = INNER DIVERTOR
C                (6)    = INNER CORNER
C                (7)    = INNER TARGET
C                (8)    = PRIVATE VOID
C                (9)    = COMPOUND BUFFLES
C                (10)   = BAFFLES (NON-COMPOUND)
C
C           AWREG()     = AREAS OF WALL (SEGMENT) REGIONS
C           FWREG(,1,)  = IMPLANTATION FLUX OF WALL (SEGMENT) REGIONS
C
C /CPOLYG/: (SEE 'c09')
C
C NOTES   : (1) INNER ESCAPE FIGURE MUST BE IN THE MAIN PLASMA.
C           (2) ONLY TWO POINTS PER SOURCE SEGMENT.
C           (3) THERE MAY BE PROBLEMS FOR FIVE OR MORE SIDED NIMBUS
C               POLYGONS AT THE ENDS OF THE TARGET PLATES.
C           (4) DIVERTOR WALLS WILL BE WELL SEPARATED FROM ANY LIMITERS.
C           (5) SOURCE SEGMENTS : (A) INITIALLY WILL NOT INCL.
C                                     SEGMENTS AT A DIVERTOR WALL.
C                                 (B) SEGMENTS AT DIVERTOR WALLS ARE
C                                     TEMPORARY STORED IN ITAGSX(,) BUT
C                                     WILL THEN BE INSERTED INTO
C                                     ITAGS(,). ISEGK() & NSEG WILL BE
C                                     CORRESPONDINGLY AJUSTED.
C                                 (C) DIVERTOR WALL SOUCE SEGMENTS WILL
C                                     BE CONSIDERED TO BE PERPENDICULAR
C                                     SOURCES.
C           (6) PDIST() CONTAINS PARALLEL SEGMENTS ACROSS TARGETS AND
C               PERPENDICULAR SEGMENT ALONG RINGS.  CORNER POINTS ARE
C               PARALLEL SEGMENTS EVEN ALTHOUGH THEY HAVE A
C               PERPENDICULAR COMPONENT.
C           (7) REGIONS INSIDE THE PUMP STRUCTURE ARE NOT ALLOWED TO
C               BE ALBEDO'S.  THE ACTUAL PUMP 'P' IS AUTOMATICALLY
C               AN ALBEDO.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 07/06/90
C
C UPDATES :
C           19/09/90 --- CORRECT PERPENDICULAR SOURCE SEGMENTS
C                        AND PROPERLY CALCULATE SOURCES AROUND LIMITERS
C           01/11/90 --- ALLOW DIVERTOR WALLS (PLATES)
C           14/11/90 --- CALC. SOURCE SEGMENTS AT DIVERTOR WALLS.
C (V2.0.0 ) 22/11/90 --- INTRO. L2PIR SWITCH (SOURCES * (2*PI*R OR 1.0))
C (V2.0.1 ) 10/12/90 --- ADD L2PIR TO LINKPG VERSION PRINT-OUT LINE
C (V2.0.2 ) 13/12/90 --- ADD SUM OF PROFILES TO PROFILE PRINT-OUT
C (V2.0.3 ) 13/12/90 --- MULTIPLY ABOVE SUMS BY VOLP(N)
C (V2.0.4 ) 17/01/91 --- PRINTOUT NIMBUS POLYGON RELATED TO SOURCE SEG.
C                        AND MULTIPLY DIV. SOURCE SEGMENTS BY THE SIGN
C                        OF PARALLEL VELOCITY.
C (V2.1.0 ) 22/01/91 --- PASS L2PIR AS AN ARGUMENT.
C (V3.0.0 ) 22/04/91 --- ADD IN REAL PLASMA WALLS IF LWALL=.TRUE.
C                    --- EXTRA COMMENTS INTO NIMBUS FILE.
C                    --- USE MESH CENTRE RATHER THAN GEOM. CENTRE.
C                    --- REMOVE IALBX AND MODIFY IALB.
C                    --- VOID (I.E GAP) TEMPERATURE.
C (V3.1.0 ) 01/05/91 --- CHANGE DECPRO = 0.8 FROM 0.1
C                    --- CHANGE IONTOW = 0   FROM 1
C (V3.2.0 ) 02/05/91 --- IF A POINT IS BETWEEN THE X-POINT AND THE
C                        PLASMA CENTRE MAKE THE ESCAPE FIGURE PROJECTION
C                        BE HORIZONTAL.
C (V3.2.1 ) 09/01/92 --- USE 'INCL.' STATEMENT FOR COMMON /CPOLYG/.
C (V3.3.0 ) 06/05/92 --- ADD IN BAFFLE REGION & LBUFLE
C (V3.4.0 ) 24/06/92 --- ITAGDP(,)
C (V3.5.0 ) 26/06/92 --- CORRECT FAULT IN WALL ESCAPE FIGURES WHEN THERE
C                        ARE TWO OR MORE NIMBUS POLYGONS IN A PLASMA
C                        POLYGON.  ALSO CORRECT FAULT TO ALBEDO POLYGON
C                        WHEN THERE ARE TWO OR MORE NIMBUS POLYGONS
C                        IN A PLASMA POLYGON.
C (V3.6.0 ) 02/07/92 --- FOR LWALL=T FORCE 1ST AND LAST PRIVATE REGION
C                        POLYGONS TO HAVE 5 VERTICES WITH THE EXTRA
C                        VERTEX BEING EQUAL TO THE INTERSECTION POINT
C                        OF THE WALL WITH THE 1ST AND LAST ESCAPE
C                        POLYGONS FROM WALL RING.  THIS IS BECAUSE THE
C                        LACK OF GOOD ACCURACY IN THE NIMBUS FILE
C                        (3 DEC. PLS) MAY PRODUCE GEOMETRY ACCIDENTS
C                        WITH THE TWO ADJACENT POLYGONS NOT EXACTLY
C                        TOUCHING EACH OTHER.
C (V3.7.0 ) 21/07/92 --- CORRECT PRIVATE REGION SOURCES FOR NON-
C                        ORTHOGONAL MESH (ASSUME 4-SIDED PLASMA
C                        POLYGONS AT THE ENDS OF THE PRIVATE
C                        REGIONS)
C (V3.7.1 ) 21/07/92 --- PRINT-OUT OF SOURCE SEGMENTS WITH CORRECTED
C                        FOR NON-ORTHOGONALITY.
C (V3.7.1 ) 30/07/92 --- ADD ESCAPE FIGURES CUT SUCH THAT ESCAPE
C                        FIGURES (FROM WALL RING) WILL BECOME WALL
C                        RATHER THAN VOID.
C (V3.8.0 ) 29/07/92 --- ABANDON V3.7 AND RETURN TO V3.6.0 WITH CHANGES
C                        (1) RENAME (IN COMMENTS) PARALLEL AS POLOIDAL
C                        (2) BUFFER(ISEG) = FIPAR OR FIPER
C                            WITHOUT DIST(ISEG) * TWOPIR
C                        (KEEP V3.7.1 CHANGE OF 30/07/92 - ESCAPE FIGURE
C                         CUT)
C....... (V3.9.0 TO V4.1.0 ARE DECENDENTS OF V3.7.1 NOT V3.8.0) ........
C (V3.9.0 ) 08/09/92 --- PASS OUT COSTHE(K) THROUGH ARGUMENT LIST
C (V3.9.1 ) 09/09/92 --- IFILE<0 : COMPUTE AS NORMAL BUT DON'T WRITE
C                                  FILE THEN ABORT ROUTINE BEFORE CALL
C                                  TO NIMBUS
C                        IOUT <0 : DON'T WRITE MESSAGES
C (V4.0.0 ) 09/09/92 --- SET GAP AREAS TO 0
C (V4.1.0 ) 11/09/92 --- PASS OUT PDIST(K) THROUGH ARGUMENT LIST
C....... (V3.9.0 TO V4.1.0 ARE DECENDENTS OF V3.7.1 NOT V3.8.0) ........
C (V4.2.0 ) 02/10/92 --- (1) PASS ITAGDV(K) THROUGH ARGUMENT LIST.
C                        (2) PASS PDIST(K) THROUGH ARGUMENT LIST.
C                        (3) SET GAP AREAS TO 0.
C                        (4) IFILE<0 : COMPUTE AS NORMAL BUT DON'T
C                                      WRITE FILE THEN ABORT ROUTINE
C                                      BEFORE CALL TO NIMBUS
C                            IOUT <0 : DON'T WRITE MESSAGES
C                        (I.E AS V3.9.1 TO V4.1.0 BUT WITHOUT COSTHE())
C (V5.0.0 ) 04/11/92 --- FORMAT CHANGES FOR 04-NOV-92 VERSION OF NIMBUS
C                        AND ALLOWENCE FOR FINE MESHES.
C (V5.1.0 ) 22/02/93 --- CHANGES TO PROFMN & PROFMP
C (V5.2.0 ) 24/02/93 --- L2PIR ---> ICODE
C (V5.3.0 ) 03/02/93 --- REDUCE STORAGE BY REDUCING NIMBUS VERTEX ARRAYS
C                        (1) ALL NIMBUS POLYGONS HAVE EITHER 3, 4  OR 5
C                            VERTICES EXCEPT FOR 1ST LIMITER,
C                            2ND LIMITER, CORE & PRV. REGION WHICH HAVE
C                            MORE THAN 5.  SO IT IS WASTEFUL TO DEFINE
C                            MRG AS THE MAXIMUM VERTEX VALUE FOR ALL
C                            NIMBUS POLYGONS.
C                        (2) CHANGE :-
C                            (RVERTM(MPG,MRG),ZVERTM(MPG,MRG)) TO
C                            (RVERTM(MPG,5)  ,ZVERTM(MPG,5)  )
C                        (3) HAVE SEPARATE ARRAYS FOR MULTI-VERTEX
C                            NIMBUS POLYGONS (SEE (1))
C                            (RVERTG(ITYPG,MRG),ZVERTG(ITYPG,MRG))
C                            & NVERTG(ITYPG)=NUMBER OF VERTICES
C                        (4) IDENTIFY THESE ARRAYS WITH NVERTM()
C                            NVERTM(NPOLY)=-1 : 1ST LIMITER  (ITYPG=1)
C                            NVERTM(NPOLY)=-2 : 2ND LIMITER  (ITYPG=2)
C                            NVERTM(NPOLY)=-3 : CORE         (ITYPG=3)
C                            NVERTM(NPOLY)=-4 : PRV. REGION  (ITYPG=4)
C                        (5) HENCE, IF NVERTM().LT.0 USE RVERTG,ZVERTG,
C                            NVERTG ELSE USE RVETM,ZVERTM,NVERTM
C                    --- BRING /CPOLYG/ INTO ROUTINE AND ELIMINATE IT'S
C                        VARIABLES,ETC FROM THE ARGUMENT LIST
C                    --- CHECKS IN 'READPG' FOR DIMENSION SIZE
C                    --- CHECK THAT NUMBER OF POLYGONS BEING CREATED
C                        DOES NOT EXCEED THE MAXIMUM
C (V5.4.0 ) 16/03/93 --- FORMAT CHANGES FOR 16-MAR-93 VERSION OF NIMBUS
C (V5.5.0 ) 06/04/93 --- SEE JETRSI
C (V5.6.0 ) 08/06/93 --- FOR X-POINT CASES : ESCAPE FIGURES BETWEEN
C                        Z=ZPX & Z=ZCENT0 ARE EXTRAPOLATED AS STRAIGHT
C                        LINES BUT CAN BREAKDOWN IF THE R OF THE EDGE
C                        POLYGON VERTEX WHICH IS BEING USED FOR THE
C                        EXTRAPOLATION IS ON THE WRONG SIDE OF R=RCENT0.
C                        PREVIOUSILY THIS PROBLEM WAS FIXED BY MOVING
C                        JPRGT (OR JPLFT) WITH JXRM (OR JXLM) FROM
C                        /NIMBIN/ NAMELIST TO USE R=RPX AS THE GUIDING
C                        CENTRE.  THIS WAS INCONVIENIENT!  SO THE
C                        GUIDING CENTRE IS NOW R=RCENT1=MID-POINT OF
C                        THE MAXIMUM R OF LHS & THE MINIMUM R OF THE RHS
C                        OF ALL EDGE POLYGON VERTICIES ABOVE Z=ZCENT0
C                        (THE EFFECT OF THIS IMPROVEMENT IS TO MOVE THE
C                         R OF THE FINAL WALL ESCAPE FIGURE POLYGON
C                         VERTEX.  THIS WILL NOT CHANGE THE NIMBUS
C                         RESULTS.)
C                    --- THE FLICK OVER CONDITION OF CHANGING THE
C                        GUIDING CENTRE (SEE ABOVE) FROM (RPX,ZPX) TO
C                        (RCENT0,ZCENT0) BASED ON JRIGHT & JLEFT COULD
C                        CAUSE PROBLEMS. I.E SAY, POINTS ABOVE JRIGHT
C                        USE (RPX,ZPX), POINTS BELOW JRIGHT BUT ABOVE
C                        Z=ZPX USE (RCENT0,ZCENT), AND POINTS BETWEEN
C                        Z=ZPX & Z=ZCENT0 USE STRAIGHT LINE EXTRA-
C                        POLATIONS THEN CONFLICTS OF ESCAPE FIGURE POLY-
C                        GONS CROSSINGS COULD ARISE. SO FOR CONSISTANCY
C                        USE Z AS THE CONDITION SUCH THAT
C                        Z.GT.ZPX                   : USE ZPX
C                        Z.GE.ZCENT0 .AND. Z.LE.ZPX : USE STRAIGHT LINES
C                        Z.LT.ZCENT0                : USE ZCENT0
C                        (THIS MAY AFFECT NIMBUS RESULTS.)
C (V5.7.0 ) 10/06/93 --- IALBPG() INTO AGRUEMENT.  THIS WILL SET WHICH
C                        WALL POLYGONS PASSED ONTO NIMBUS ARE TO BE
C                        CONSIDERED AS ALBEDO REGIONS.  ALBPG ALSO INTO
C                        ARGUMENT LIST.
C (V5.8.0 ) 21/06/93 --- PROBLEM WITH ALBEDO COVER IF EDGE PLASMA
C                        POLYGONS ARE DECOMPOSED INTO NIMBUS TRIANGLE
C                        IN WHICH NO ASSUMPTIONS SUCH BE MADE ABOUT
C                        THEIR ORDER.
C (V5.9.0 )  5/07/93 --- NEW SPUTTERING (ISP93)
C                        REMOVE 'NXPG' FROM ARGUMENT LIST AS IT IS
C                        ALREADY IN /CPOLYG/
C (V6.0.0 ) 23/07/93 --- CHANGE ALBPG TO ALBPG() AND INTRODUCE ALBEPG()
C                        (C09) REPLACES 'JET???.LINKPG.COMMONS(LINKPG)'
C (V6.1.0 ) 30/09/93 --- EXTEND STRAIGHT LINE ESCAPE FIGURES ABOVE ZPX
C                        (SEE V5.6.0 - 23/07/93) FRO ALL WALL POINTS
C                    --- REMOVE PATCH (V3.6.0 - 02/0792) WHICH FORCED
C                        THE CORNER PRIVATE REGION POLYGONS TO HAVE
C                        A FIFTH VERTEX WHICH MATCHED THE POSITION OF
C                        THE WALL.  BUT DUE TO THE EXTENTION OF THE
C                        STRAIGHT LINE ESCAPE FIGURES THIS NEEDS TO
C                        BE REMOVED AND AN EXPLICIT CORNER POLYGON
C                        (4 OR 5 VERTEX) INTRODUCED.
C                    --- VESSPG (30/09/93) : DISALLOW MULTI-ROOTS
C (V6.2.0 ) 07/10/93 --- VESSEL MUST ALWAYS BE ORDERED CLOCKWISE
C                    --- VESS62 REPLACES VESSPG
C                    --- VESS62 (07/10/93) : USE 'STRIP' TO ACCOUNT FOR
C                                            ACTUAL VESSEL
C                    --- MULTI-POLYGONS CREATED IN VESS62
C                    --- INTRODUCE SWITCH LNWESC
C (V6.2.1 ) 20/10/93 --- ITAGES(M,1) = 2 (WALL) DEFAULT IN ITAGES(M,1)
C                        CONDITION TESTING I.E IF ... THEN ... ELSE.
C                        PROBLEMS WERE CAUSED FOR LWALL=F WITHOUT THIS
C                        FIX (SEE (20/10/93))
C (V6.3.0 ) 26/10/93 --- EATMD, T0NEUT
C (V6.3.1 ) 05/11/93 --- LPOUT
C (V6.4.0 ) 17/12/93 --- CORRECTION IN THE PLASMA DIRECTION COSINES,
C                        IPUNCH<>0, VA, VM IN CALLING SEQUENCE,
C                        IXS, MCX.
C                        CORRECTION IN NEUTRAL ENERGIES (AVERAGED NOW
C                        OVER N*V)
C (V6.5.0 ) 20/12/93 --- PARAMETERS FOR HYDR. RAD. CALCUL. (L.HORTON)
C (V6.6.0 ) 31/12/93 --- NTSPUT INTO ARGUMENT LIST (L.HORTON)
C (V6.6.1 ) 31/12/93 --- MOVE EATMD & T0NEUT TO INPUT SECTION
C                    --- VOLP(MRG)
C (V6.6.2 ) 31/12/93 --- IHOR INTO ARGUMENT LIST
C (V6.7.0 ) 13/01/94 --- USE PRIVATE REGION VESSEL AS THE WALL & SWITCH
C                        OFF ANY BAFFLE IF LPWALL IS .TRUE.
C                    --- SOURCE SEGMENTS AROUND ALBEDO (I.E PRIVATE
C                        VOID/WALL/ALBEDO) REGION IF LPSEG=.T.
C (V6.7.1 ) 18/01/94 --- NWSEG , NWSPG , WSDIST , RWSEG & ZWSEG
C (V6.8.0 ) 25/01/94 --- RECYCLING + RECOMBINATION
C (V6.8.1 ) 04/02/94 --- ROBUST LPWALL & LBUFLE HANDLING
C (V6.8.2 ) 08/02/94 --- CORRELATED RANDOM NUMBERS
C (V6.9.0 ) 10/03/94 --- DECIMATION PROBABILITY, C.X. EFFECTIVE ENERGY,
C                        V0 DOT VI
C                    --- IXS(2) = USE JANEV FOR CH.EX RATE COEF.
C                        IXS(3) = USE JANEV FOR MOLEC. RATE COEF.
C                    --- MCOLP, TOTZSN
C (V6.9.1 ) 18/03/94 --- SPUTTERING FROM IMPURITY IONS
C (V7.0.0 ) 08/04/94 --- IHYEAR,IZYEAR,IDYEAR,USERID INTO ARGUMENT LIST
C                    --- IXS(4)
C (V7.0.1 ) 20/04/94 --- LIGHT RECYCLING IMPURITY
C (V7.1.0 ) 04/05/94 --- NXW & IOPEN INTO ARGUMENT LIST.
C                        ITAGRM() INTRODUCED.
C (V7.2.0 ) 10/05/94 --- MIXS INTO ARGUEMENT LIST AND REARRAGNGE IXS()
C                        PASSED INTO NIMBUS FILE.
C (V7.3.0 ) 13/05/94 --- UPGRADE PUNHO() & HORTON() TO INCL.  REFL.
C                        (AS PRESCRIBED BY L.HORTON IN D3A04WK6.FORT)
C                    --- MOVE DECIMA & MACRO TO INPUT ARGUMENT LIST
C                        BLOCK
C                    --- ALLOW BOTH LPWALL=T AND LBUFLE=T (I.E REMOVE
C                        LIMITATION OF V6.7.0
C (V7.3.1 ) 24/05/94 --- ALLOW PRIVATE REGION VOID COVER TO BE
C                        SPECIFIED AS AN ALBEDO WITH IALBPG().
C                        DISALLOW IALBPG() TO SPECIFY AN ALBEDO IN
C                        PRIVATE REGION VOID OR BUFFLE.
C (V7.4.0 ) 26/05/94 --- SET ALL WALL POLYGONS IN THE REGION DETERMINED
C                        BY IREGON() TO ALBEDO.
C                        IF ITAGES > 3 THEN I = ITAGES - 3 TO FIND
C                                           ALBPG(I) & ALBEPG(I)
C                        IF ITAGES = 3 THEN PRIVATE VOID IS ALBEDO AS
C                                           GIVEN BY IALB=1
C (V7.5.0 ) 15/06/94 --- COORDINATES OF ACTUAL NIMBUS VESSEL
C                        (RVESM(,),ZVESM(,))
C (V7.6.0 ) 11/07/94 --- GEOMETRY CAN BE STORED, MORE MACRO PROFILES
C (V7.7.0 ) 15/07/94 --- NEUTRAL TRAJECTORY TRACKS
C (V7.8.0 ) 21/11/94 --- BUG FIX TO TARGET SEGMENT WHEN LPSEG = .TRUE.
C                        CUT HORTON STORAGE
C (V7.8.5 ) 10/11/94 --- DIRECTION COSINES FOR TOROIDAL FIELD
C                    --- DIAGNOSTICS FOR 'STRIP' ERRORS
C (V7.8.6 ) 11/11/94 --- RVESM,ZVESM CHANGED FROM R*8 TO R*4.
C                    --- SETORD = SET-UP DATA FOR ORDERING ROUTINE
C                        VESORD = ORDERING ROUTINE
C                        SEGORD = ORDER ORIGINAL SEGMENT PAIRS
C                                 IN SAME ORDER AS 'VESORD'
C                    --- IVESM
C (V7.9.0 ) 02/12/94 --- ELASTIC SCATTERING
C (V7.9.1 ) 06/12/94 --- (V7.9.0) + (V7.8.6)
C (V7.9.2 ) 07/12/94 --- WALL LOADING (SWITCHED OFF), IAEMIS=-1/0/1
C (V7.9.3 ) 21/12/94 --- WALL LOADING (SWITCHED ON), MZONEW REMOVED
C                        AS MVESM SHOULD HAVE BEEN USED
C                    --- RESTORE 'NIMBUS VESSEL SEGMENT PAIRS' OUTPUT
C                        TO NIMBUS FILE (FOR USE BY PLOTPG)
C                    --- COUNT ONLY THOSE PRIV. REGION VOID NIMBUS
C                        POLYGONS WHICH HAVE CONTACT WITH BUFFLE RATHER
C                        THAN ALL PRIV. REGION POLYGONS
C (V7.9.4 ) 23/12/94 --- ALLOW FOR 'HELIUM' IN SYMBOL() AND INDEX()
C                    --- INCREASE IWORK FROM 10 TO 100
C (V7.9.5 ) 24/01/95 --- ASSIGN (RVESM,ZVESM) FOR COMPOUND BUFFLE
C                    --- NFLXHW INTO ARGUEMENT LIST
C                    --- ALLOW FOR 'NITROGEN' IN SYMBOL() AND INDEX()
C (V8.0.0 ) 26/01/95 --- MFLX INTO ARGUEMENT LIST
C                    --- DIMENSION FLUXHW(MVESM,MFLX) AND NOT JUST
C                        FLXHW(MVESM,3)
C (V8.1.0 ) 27/01/95 --- MORE FREEDOM FOR LIGHT IMP. (UNIV. FORMUL.)
C                        (I.E RNLITE AND EWLITE)
C (V8.2.0 ) 02/02/95 --- OPTION TO SPECIFY EXACT REGIONS & ENERGIES FOR
C                        RECYCLED NEYTRALS (I.E INUTPG() AND EATMR)
C                    --- TTARG INTO ARGUEMENT LIST
C (V8.3.0 ) 08/02/95 --- EXTENT ITAGRM()
C                    --- UPGRADE CHKNUT
C (V8.4.0 ) 21/03/95 --- LPUMP, INPUMP, FPUMP, IVIEW, VIEW(), ALBATO,
C                        IREFCT,MACRO1,MACRO2 & MACRO3 INTO ARGUEMENT
C                        LIST
C                    --- CHECK FOR STRUCTURE LYING OUTSIDE GEOM()
C                        WINDOW IF SO THEN ALTER RECTANGLE (S.R MOVREC)
C                    --- NIMBUS FILE HEADER TO SHOW IF PUMP (LPUMP=T)
C                        IS ACTIVE
C                    --- VIEW() WINDOW AT END OF POLYGON VERTICES IN
C                        NIMBUS FILE (IF IVIEW<0 ONLY)
C                    --- PUMP DATA (SEE S.R RDPUMP)
C                    --- DIRECT LINK BETWEEN THE NIMBUS POLYGONS (RVERTM
C                        , ETC) AND NIMBUS REGIONS (COMM()) HAS BEEN
C                        IS BROKEN DUE TO ADDITION OF PUMP STRUCTURE
C                        REGIONS.
C                    --- EXTENDED NPOLYC()
C                    --- DIMENSION ITAGRM WITH MPG NOT NDIM2
C                    --- COMM() = '-' FOR 'CIR'
C                               = '*' FOR 'REC'
C                               = 'D' --- DIVERTOR WALL SECTION OF PUMP
C                    --- WORKING SPACE COMMON BLOCK /WSPACE/
C                    --- PUMP COMMON BLOCK /CPUMP/
C                    --- REPLACE ERROR BY WARNING IF PUNCH FILE HAS MORE
C                        WALL SEGMENTS THAN LINKPG
C                    --- PIGGY-BACK PUMP STRUCTURE SEGMENT ON THE TOP OF
C                        RVESM(,) & ZVESM(,) SUCH THAT NVESM+1 TO
C                        NVESM+NVESP ARE THE PUMP STRUCTURES
C                    --- SET ALL WALL LOADING FLUXES TO ZERO IF LPUMP
C                        IS TRUE (I.E FLUXHW(,,K)=0.0)
C                    --- ITAGRM() > 14 ARE RENUMBERED
C (V8.5.0 ) 27/03/95 --- CHANGE PUNCH FILE FOR INTEGER/DECIMAL TO
C                        INTEGER/HEXADECIMAL FORMAT (MACRO-ZONES ONLY)
C                    --- NVPUMP() < 0 OPTION TO FORCE PUMP STRUCTURE
C                        POLYGON INTO IVDWB() ARRAY
C                    --- IPSEMP() & PSEMP() INTO ARGUEMENT LIST
C                    --- S.R 'CHKPSP'
C (V8.6.0 ) 04/04/95 --- REMOVE NVPUMP() < 0 OPTION
C                    --- RENAME NPUMPX TO NDWB & IPUMPX() TO IVDWB()
C                    --- MOVE PRODUCTION OF ORDERED NIMBUS VESSEL
C                        SEGMENT PAIRS INTO SUBROUTINE 'SETSEG'
C                    --- NPLASM , RPLASM(,) , ZPLASM(,) , IPLASM(,)
C                        & FLUXPB(,) INTO ARGUEMENT LIST
C                    --- PRODUCE ORDERED PLASMA BOUNDARY SEGMENT PAIRS
C                        USING 'SETSEG'
C                    --- MAP FLUX 'TO PLASMA BOUNDARY FROM GAP VOID'
C                        READ FROM PUNCH FILE TO ORDERED PLASMA
C                        BOUNDARY SEGMENTS
C                    --- ACTIVATE FLUXHW(,) WHEN LPUMP = .T. AS NIMBUS
C                        HAS BEEN CORRECTED TO AVOID DOUBLE COUNTING
C                    --- INTRODUCE ROUTINE 'LOCDWB' - DETERMINES NIMBUS
C                        WALL POLYGONS WHICH BELONG TO DIVERTOR WALL
C                        (I.E. THOSE TO BE LABELLED AS 'DIVPMP').  THIS
C                        REPLACES HARD CODING OF V8.4.0 & V8.5.0.
C                    --- SEGMENT GROUPING LABEL GVESM() & GPLASM() INTO
C                        ARGUMENT LIST
C                    --- ALLOW PUMP REGIONS (LRPUMP()) TO BE SPECIFIED
C                        WITH THE '*' CONTINUATION CHARACTER OVER ONE
C                        OR MORE LINES.
C (V8.7.0 ) 24/04/95 --- PSEMPB INTO ARGUMENT LIST
C                    --- CORRECTION TO ALBEDO COVER :-
C                            KORM(N0,NM(N)) ---> KORM(N0,NM(N0))
C                            KORM(N1,NM(N)) ---> KORM(N1,NM(N1))
C                        FOR TRIANGLE ACTION.
C (V8.8.0 ) 17/05/95 --- MEANING OF LPUMP CHANGED
C                    --- LPMPST = .T. IF FPUMP.NE.' ' (== OLD LPUMP)
C                                     (I.E PUMP STRUCTURE IS PRESENT)
C                    --- 'FIXPMP' CHANGED TO FILL ITPUMP(,,3)
C                    --- 'LOCDWB' CHANGED TO USE  ITPUMP(,,3)
C                    --- PMACRO DECLARED AS PMACRO(MACRO1,MACRO3) NOT
C                        PMACRO(MACRO1,1) !!
C                    --- TRIM REFLECTION DATA (FTRIM & IFTRIM)
C                    --- NEUTRAL PRESSURE (MACRO3=2)
C                    --- NOFLXW CHANGED TO IPVOID
C                    --- PROTRM() & TARTRM() PREFIXED WITH FTRIM
C (V8.8.1 ) 06/06/95 --- USE PLUN PARAMETERS REPLACE HARD CODED
C                        WRITES TO CHANNEL 6
C (V8.9.0 ) 16/06/95 --- ITARHZ() INTO ARGUEMENT LIST
C                    --- HORIZONTALIZE TARGET ESCAPE FIGURES
C                    --- SETUP OPTIONS IN NIMBUS (ISETUP)
C (V8.9.1 ) 17/06/95 --- CORRECTIONS TO VESSEL BOUNDARY 'PUNCH' SECTION
C (V9.0.0 ) 22/08/95 --- INTRODUCE 'RNGCUT' TO LIMIT ITARHZ()
C                    --- ICHKP & ILSTMC INTO ARGUEMENT LIST
C                    --- ITIMIO , ITAIO1 , ITAIO2 , TSLICE ,
C                        STMOUT , HTMOUT , ZT.., YT.. INTO ARGUMENT LIST
C                    --- AYIZ, BYIZ, R.N. CORRELATION OPTION
C (V9.1.0 ) 17/10/95 --- ADDITIONAL PUMPING FROM PUMP REGION WALLS
C                    --- PSEMPX, ALBLK() INTO ARGUEMENT LIST
C                    --- AUTOMATIC CALCULATION OF NRPUMP IN S.R 'RDPUMP'
C (V9.2.0 ) 30/10/95 --- IPTPSB() INTO /CPUMP/
C                    --- IVESM(,2) INCREASED TO IVESM(,3)
C (V9.3.0 ) 16/11/95 --- IMPROVE TERMINATION CONDITION WHILE CALCULATING
C                        NRPUMP
C                    --- IMPROVE ITARHZ() AUTO-CALCULATION
C                    --- DCUTCX, TCUTCX & ITAU INTO ARGUEMENT LIST
C (V9.4.0 ) 09/01/96 --- CHEMICAL SPUTTERING FLUX TERM CALCULATIONS
C (V9.5.0 ) 06/02/96 --- LEAK RECYCLING SEGMENTS READ FROM 'RDPUMP'
C                    --- CHKLRS() CHECKS LRS WITH WALL VOID REGION
C                    --- IDBHST() INTO ARGUEMENT LIST
C                    --- REPLACE NDIM2 BY MPG
C                    --- BUFFER(NDIM2,...) CHANGED TO BUFFER(MDIM,...)
C                    --- CORRECT MAPS() AS IT SHOULD ONLY BE CHANGED
C                        IF IPSEMP() IS CUT BY THE PUMP (I.E ITAGES<0)
C                    --- PICK PUMP DEFAULT PARAMETERS FROM PUMP FILE
C                        IF NOT GIVEN BY INPUT
C (V9.6.0 ) 12/03/96 --- PUMP 'CIR' STRUCTURES
C                    --- MVESC , NVESC , XVESC(,) INTO ARGUEMENT LIST
C                    --- PRESSURE GAUGE MACRO-ZONE(S)
C                    --- T0NEUT --> FRAPUF, ENERGY ACCORDING TO
C                        PUFF/(RECYC+PUFF)
C                    --- GAUGE (CIR) OVERRIDE PARAM'S
C                    --- GET TOTZEA, TOTZLK & TOTHLK FROM PUNCH FILE
C                    --- FLUXHW(,5) & FLUXHW(,6)
C (V9.7.0 ) 27/03/96 --- FLUXHW(,7)
C                    --- PRESSURE GAUGE 'K' (I.E SOL GAUGE)
C                    --- IGAUGE() ARRAY TO MAP GAUGE TO PUMP POLYGON
C (V9.7.1 ) 18/04/96 --- IMPROVE PRESSURE GAUGES DESCRIPTION WITH
C                        NIMBUS VOID POLYGONS.
C (V9.7.2 ) 22/04/96 --- VESSPG() & VESS62 CORRECTIONS
C (V9.8.0 ) 22/05/96 --- USERID*6 TO USERID*(*)
C                    --- MOVE 'USERID' TO A SEPARATE LINE IN M.C FILE
C (V9.8.1 ) 11/06/96 --- ISPOFF() INTO ARGUEMENT LIST
C (V9.9.0 ) 03/07/96 --- LLRS(), XLRS(,) & YLRS(,) AND LGAP(), XGAP(,),
C                        YGAP(,) & PGAP() INTO ARGUEMENT LIST
C                        (DESIGNED TO OVERRIDE PUMP FILE SETTINGS)
C (V9.10.0) 10/07/96 --- FLUXHW(,8)
C (V9.11.0) 23/07/96 --- NZE2D & MIMP INTO ARGUMENT LIST
C                    --- NZ REPLACED BY IZE2D()
C                    --- MZE2D PARAMETER FOR /WSPACE/
C                    --- FLUXZW(*,2,NZE2D)
C (V9.12.0) 01/08/96 --- INTRODUCE 'IHORIZ()=1' TO IDENTIFY WHICH ESCAPE
C                        FIGURES HAVE BEEN HORIZONTALISED BY ITAGHZ()
C                    --- IF IHORIZ(M)=1 THEN SET ITAGES(M) TO -1 OR -3
C                        RATHER THAN -2
C (V9.12.5) 09/08/96 --- LMC OPTION
C                    --- NEW VERSION OF PNEIGH
C (V9.13.0) 03/10/96 --- TRAP FOR H-ION FLUX <=0
C (V9.14.0) 15/11/96 --- AYIZ,BYIZ MULTI-SPECIES
C                    --- CHANGE LTEST TO LMC
C                    --- PASS OVER LTEST FROM S.R. DATA
C                    --- 'INIZ' ARGUMENT
C                    --- 'NOZPMP' ARGUMENT
C (V9.15.0) 21/11/96 --- NOZPMP REPOSITIONED IN THE M.C. FILE
C                    --- "ILLEGAL IMPUR. COMB." CHECK REMOVED
C (V9.16.0) 08/01/97 --- YNOSP ARGUMENT
C (V9.16.1) 13/01/97 --- WALL FLUXES AT DIVERTOR/TARGET CORNERS
C                        CORRECTED AS THE CORNER POLYGON CONTAINS TWO
C                        WALL SEGMENTS (SEE IMATCH()).
C (V9.17.0) 06/03/97 --- PUMP REGION MATERIAL (PWMAT),
C                        FUDGE FACTOR FOR CHEM. SPUTT. (AYCHEM),
C                        PRIV. REG. AND PUMP REG. WALL TEMPERATURES.
C (V9.17.1) 10/03/97 --- FULL IMPLEMENTATIONS OF VARIOUS WALL TEMPS.
C (V9.18.0) 10/04/97 --- TRAP NEGATIVE SOURCE SEGMENT CHARGE !!
C (V9.19.0) 24/04/97 --- MOVE WALL CORNER TO BE ASSIGNED DIVERTOR
C                        WALL TEMPS RATHER THAN TARGET.
C (V9.20.0) 14/05/97 --- PARAMETER TGAP REPLACED BY TEVGAP ARGUMENT.
C                        RENAME TGAP TO TEVGAP.
C (V9.21.0) 16/06/97 --- ROUTINE 'MARKPG' ADDED.
C                    --- AUTO-CALCULATION OF WALL/PUMP GAPS.
C                    --- ADJUSTMENT FOR GAPS POINTS IN CORNER.
C                    --- TOTZRD() DIMENSIONED WITH MZE2D NOT NZE2D
C                    --- CHECK MZE2D IS NOT LESS THAN NZE2D
C (V9.21.1) 18/06/97 --- NION>=1, ECX->ENEUCX, PUNCH OBSOLETE
C (V9.22.0) 20/06/97 --- ADJUSTMENT OF GAPS POINTS IN CORNERS - REMOVED.
C (V9.23.0) 21/06/97 --- ADJUSTMENT OF GAPS POINTS IN CORNERS TO BE
C                        SELECTED VIA THE PUMP FILE (I.E IGOPT=1).
C (V9.24.0) 27/06/97 --- EXTRA BAFFLES
C                    --- PSEMPB CHANGED TO VECTOR PSEMPB()
C                    --- ALL PRIVATE VOID REGIONS ASSIGNED BAFFLES
C                        (REMOVE TESTING FOR THOSE WHICH ACTUALLY CUT)
C (V9.25.0) 08/07/97 --- FRAPUZ INTO ARGUMENT LIST
C                    --- IMPURITY PUFF BY NIMBUS
C                    --- RECMAT IN ARGUMENT LIST
C (V9.26.0) 18/07/97 --- CHECK NIMBUS WALL POLYGONS DO NOT CUT OTHERS
C                        (WARNING ONLY IF LMC=.T.)
C (V9.27.0) 22/08/97 --- TOTZSN=-1E+30 (TRAP FOR WRONG USE)
C                    --- NIONH>1
C                    --- NFLUID OBSOLETE
C                    --- BUFFER(...) CHANGED TO BUFFER(2*MDIM)
C (V9.28.0) 09/09/97 --- S.R "STRIP" DON'T PRINT KR+1,KL+1 IF >NR OR NL
C                    --- EXTRA ERROR MESSAGES IF SZE2D=SYMBOL OR
C                        IZINDW=0
C                    --- TYPO : ZZ(K,IZ) -> ZZ(K,KZ)
C                    --- REMOVE REDUNDENT SAVE STATEMENT IN LINKPG
C                    --- S.R "POLCHK" USE IOUT NOT LOUT
C (V9.29.0) 12/09/97 --- FUNCTION "LBREC" FOR ESCAPE FIGURES
C                    --- GAP POLYGONS EXTENSION
C(V10.01.0) 28/10/97 --- IMPROVE GAP POLYGON EXTENSION TO USE
C                        RECTANGLES, RATHER THAN TRIANGLES, FOR
C                        NON-CORNER POINTS
C                    --- CALCULATE LENGTH OF GAP ENTRANCE
C                    --- OUTBOARD TRANSPARANCY FOR POLYGONS ALLOWED
C                    --- PSEMG() INTO ARGUMENT LIST
C                    --- BUG FIXES (TRITIUM -- SEE RS)
C                    --- WRITE PUMP GAP POLYGONS IN M.C FILE COMMENTS
C                        SECTION
C(V10.02.0) 07/11/97 --- OUTPUT MAXIMUM VESSEL VERTICES ON
C                        INNER/OUTER SIDES
C                    --- ANGNOR INTO ARGUMENT LIST
C(V10.03.0) 10/11/97 --- OUTPUT THE PLASMA SIDE COORDINATES OF THE
C                        PUMP GAP CHANNEL
C                    --- RPGAP(,) & ZPGAP(,) INTO /CPUMP/
C                    --- REMOVE PSEMG() = PSEMP(), THIS SHOULD BE DONE
C                        OUTSIDE LINKPG
C                    --- WRITE PUMP POLYGON IN M.C FILE COMMENTS
C                        SECTION
C(V10.04.0) 25/11/97 --- MPWALL, NPWALL, FPWALL INTO ARGUMENT LIST
C                    --- ALLOW EXTREME PRIVATE REGION VESSEL WALL
C                        CONFIGURATIONS VIA THE INSERTION OF EXTRA
C                        POINTS ALONG LINE JOINING THE EXTRAPOLATIONS
C                        OF THE PRIVATE REGION END-POINT
C(V10.05.0) 11/02/98 --- IMPLANTATION FLUX OF H-NEUTRALS IN WALLS
C                    --- FRACTION OF HOT NEUTRALS
C                    --- BUG FIXES FOR PARALLEL MOMENTUM
C                        (SIGNK1 FOR TOROIDAL COMP., BSIGN FOR PROFMP)
C                    --- INFORMATION ON IMPLANTATION OF MOLECULES
C(V10.06.0) 03/03/98 --- H DIFFUSION IN WALLS
C                    --- MWREG, CWREG(), AWREG() & FWREG(,,)
C                        INTO ARGUMENT LIST
C                    --- MAP NIMBUS POLYGON TO WALL SEGMENT TO REGION
C(V10.07.0) 09/03/98 --- RE-ENGINEER GWREG()
C                    --- MMPG, MTOREG() INTO ARGUMENT LIST
C(V10.07.1) 10/03/98 --- DEFINE GWREG() AND USE THIS FOR GVESM(), ETC
C                    --- CHANGE 'SETSEG' FOR GAP SEGMENTS
C                    --- IVESM(,3) = 4 FOR DON'T PLOT
C                    --- CHANGE CONDITION FOR SETTING COMM() OF GAPS
C                        ('/') TO WALLS ('W')
C(V10.07.2) 25/03/98 --- TRITIUM BUG FIX
C                    --- EQUIVALENCE BUFFER() IN S.R."SETSEG"
C(V10.07.3) 21/04/98 --- CHANGES FOR NEW (F95/G77) COMPILERS
C                    --- RENAME EXIT() TO EXITX()
C(V10.08.0) 19/06/98 --- TRAP ZERO IMPURITY ION CHARGE.
C                        MOMENTUM SOURCE OPTION IMOMSO.
C(V10.08.1) 23/07/98 --- RENAME S.R. 'INTLIN' TO 'INTLINJ' TO AVOID NAME
C                        CLASS WITH JETTO
C(V10.09.0) 07/09/98 --- ALLOW LMC IN VOID/WALL INTERFACE CALLS TO
C                        S.R. 'FXPOLY'
C                    --- MAPFLX() & BUFHSW() INTO ARGUEMENT LIST
C(V11.01.0) 09/12/98 --- RE-WRITE 'POLYGON VERTICES' SECTION
C                    --- RE-WRITE 'NIMBUS REGIONS' SECTION
C                    --- REMOVE LIMITOR'S FROM ESCAPE FIGURES
C                        (LAST EDGE2D VERSION = 01-OCT-98)
C                    --- /CPUMP/  NOW IN AN INCLUDE FILE
C                    --- /CLINK/  NOW IN AN INCLUDE FILE
C                    --- /WSPACE/ NOW IN AN INCLUDE FILE
C                    --- FLHCHM() USE M NOT M+2 !!!
C                    --- FLHCHM() NOT AVAILABLE FOR PUMP REGIONS
C                    --- REMOVE LNWESC & ITARHZ() FROM ARGUMENT LIST
C(V11.01.1) 15/12/98 --- NEW VERSION OF S.R. 'SETORD' SECTION
C(V11.02.0) 02/03/99 --- FIX BUG WITH IWGAP(,)
C
C-----------------------------------------------------------------------
C
      CHARACTER BCD*(*) , FPUMP*60
C
      CHARACTER*2 PWMAT
C
C..LOGICAL UNIT NUMBERS
      INCLUDE  'plun'
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C-----------------------------------------------------------------------
C
      PARAMETER( NDIM1  = 500 , NDIM3 = 18 )
      PARAMETER( NDIM5  = 100 , NSTRIP = NDIM1/4 )
      PARAMETER( IPRINT = LOUT )
      PARAMETER( PI     = 3.141592654D+00 )
      PARAMETER( NDIHO  = 14 )
      PARAMETER( EPS    = 3.0D-05 )
      PARAMETER( PROJ   = 2.0D+01 )
C
      REAL*4    RVESM(MVESM,2)   , ZVESM(MVESM,2)
     &        , RPLASM(MVESM,2)  , ZPLASM(MVESM,2)
     &        , XVESC(MVESC,3)
      REAL*8    FLHCHM(MPG)      , PSEMPB(0:MBUFX)
     &        , XGAUGE(MVESC)    , YGAUGE(MVESC) , RGAUGE(MVESC)
     &        , XLRS(MCLRS,2)    , YLRS(MCLRS,2)
     &        , XGAP(MCGAP,2)    , YGAP(MCGAP,2) , PGAP(MCGAP,2)
      INTEGER*4 IVESM(MVESM,3)   , IPLASM(MVESM,2)
      CHARACTER GVESM(MVESM)*(*) , GPLASM(MVESM)*(*) , LGAUGE(MVESC)*(*)
     &        , LLRS(MCLRS)*(*)  , LGAP(MCGAP)*(*)
C
      PARAMETER (MMATCH=10)
      DIMENSION NLIM(2) , IMATCH(MMATCH) , AMATCH(MMATCH)
C
      DIMENSION IZE2D(NZE2D),ZGAMMA(NZE2D)
     &         ,TOTZSP(NZE2D),TOTZES(NZE2D)
     &         ,TOTZSN(NZE2D),TOTZEA(NZE2D),TOTZLK(NZE2D)
     &        , FIPARZ(MP,NZE2D),FIPERZ(MP,NZE2D),ZZ(MP,NZE2D)
     &        , AYIZ(NZE2D),BYIZ(NZE2D)
C
      DIMENSION RMESH(MP)    , ZMESH(MP)
     &        , ITAG(MP,5)   , NJ(MC)        , KORY(MC,MR), ITAGDV(MP)
     &        , DENSE(MP)    , TEMPE(MP)
     &        , DENSI(MP,NIONH)              , TEMPI(MP)
     &        , VPAR(MP,NIONH) ,   SH(MP)
     &        , FIPAR(MP,NIONH)  , FIPER(MP,NIONH)
     &        , IALBPG(MR)   , ALBPG(MR)     , ALBEPG(MR) , IXS(MIXS)
     &        , INUTPG(MR)   , IPSEMP(MR)    , PSEMP(MR)  , PSEMG(MR)
     &        , VIEW(4)      , ALBLK(MLK)
     &        , FPWALL(MPWALL)
C
      DIMENSION WSPLIT(NC)
C
      PARAMETER (IU=1)
      DIMENSION HMASS(NIONH) , RECMAT(MIONH,NIONH), PERC(NIONH),
     &          RMATW(MIONH,NIONH,MWREG)
      DIMENSION PROFSN(MP,NIONH) , PROFQ(MP)
     &         ,PROFQE(MP)       , PROFA(MP,NIONH)
     &         ,PROFM(MP,NIONH)  , PROFMP(MP)
     &         ,PROFMN(MP)   , PROFHA(MP)
     &         ,ENEUTA(MP,NIONH) , ENEUTM(MP,NIONH)
     &         ,VA(3,MP,NIONH)   , VM(3,MP,NIONH)
     &         ,VNUTAP(MP,NIONH) , VNUTMP(MP,NIONH)
     &         ,ERELHI(MP,NIONH) , ENEUCX(MP,NIONH)
     &         ,DAHF(MP,NIONH)
      DIMENSION PDIST(MP)
      DIMENSION FRAPUF(MP,2,NIONH)
      DIMENSION PRQELA(MP)   , PRPELA(MP)    , PRQELM(MP),  PRPELM(MP)
      DIMENSION FLUXHW(MVESM,MFLX)           , FLUXPB(MVESM,MFLXPB)
     &        , FLXHSW(MVESM,MFLXH,MIONH)    , BUFHSW(MVESM,MIONH)
     &        , FWREG(MWREG,MFLXH,MIONH)     , AWREG(MWREG)
      CHARACTER*2 GWREG(MWREG)
      DIMENSION PROFZ(MP,NZE2D) , PROFSZ(MP,NZE2D) , ENEUTZ(MP,NZE2D)
      DIMENSION FLUXZW(MVESM,2,NZE2D)
      DIMENSION TOTHES(NIONH),TOTHEA(NIONH),TOTHLK(NIONH)
C
      INTEGER*4 ISPOFF(MACRO)
C
      DIMENSION SMACRO(MACRO1,MACRO2,1+NZE2D)
      DIMENSION PMACRO(MACRO1,MACRO3,1+NZE2D),VMACRO(MACRO1)
C
      DIMENSION KDEBWR(MDEBWR) , NDBHST(MDEBWR)
     &        , XDEBWR(MDEBWR,MDEBPT,3)
     &        , IDBHST(MDEBWR)
C
C-----------------------------------------------------------------------
C
      DIMENSION DIST(MPG)
      DIMENSION L1(NDIM1)      , L2(NDIM1)  , L3(NDIM1)
      DIMENSION RGEN1(NSTRIP)  , ZGEN1(NSTRIP)
     &        , RGEN2(NSTRIP)  , ZGEN2(NSTRIP)
C
      DIMENSION ITAGS(NDIM1,4) , ITAGSX(NDIM1,4)
      DIMENSION IWALL(NDIM1)   , IGAP(NDIM1)           , IALBDO(NDIM1)
C
      DIMENSION MAPS(MPG)
C
      DIMENSION MCHAN(NDIM1) , JCHAN(NDIM1,NDIM1)
      DIMENSION SYMION(4)
      DIMENSION STYPE(3)
C
      DIMENSION IT5(NDIM1,3) , IT4(NDIM1,3)
C
      DIMENSION IELEM(MPG)
C
C-----------------------------------------------------------------------
C
      DIMENSION VOLP(MMPG)   , MTOREG(MMPG) , VOLM(MPG)
      PARAMETER (MIO=3, MIZ=3)
      DIMENSION PUNION(MPG,MIO),PUNENI(MPG),PUNXMO(MPG),PUNYMO(MPG)
     &         ,PUNZMO(MPG),PUNENE(MPG)
     &         ,PUNADN(MPG,MIO),PUNMDN(MPG,MIO),PUNALF(MPG)
     &         ,PUNAEN(MPG,MIO),PUNMEN(MPG,MIO)
     &         ,PUNZDN(MPG,MIZ),PUNZIO(MPG,MIZ),PUNZEN(MPG,MIZ)
     &         ,PUNACS(MPG,3,MIO),PUNMCS(MPG,3,MIO)
     &         ,ECX(MPG),PUNAE0(MPG,MIO)
     &         ,PUNSOU(MPG,2,2),DAHFR(MPG,MIO)
      DIMENSION SUMSN(MIO),SUMEA0(MIO),SUMDHF(MIO)
     &     ,SUMA(MIO),SUMEA(MIO),SUMAVX(MIO),SUMAVY(MIO),SUMAVZ(MIO)
     &     ,SUMM(MIO),SUMEM(MIO),SUMMVX(MIO),SUMMVY(MIO),SUMMVZ(MIO)
C
      DIMENSION DI(MIO)
C
      REAL*4    XR4(2)       , YR4(2)
C
      INTEGER*4   MAPFLX(MVESM)
C
C------------- COMMENT OUT NON-APPROPRIATE BLOCK ---
C
C     PARAMETER ( NHORT=1 )
C
      PARAMETER ( NHORT=MPG )
C
C---------------------------------------------------
      DIMENSION PUNHO(NHORT,3,NDIHO),HOR(3,NDIHO)
      DIMENSION JZCHAN(NDIM5), IZCHAN(NDIM5,NDIM5)
      DIMENSION PROFMF(MPG)  , HORTON(3,NDIHO,MP)
      DIMENSION NWSPG(NDIM1)   , WSDIST(0:NDIM1)
     &        , RWSEG(NDIM1,2) , ZWSEG(NDIM1,2)
     &        , IWSEGK(8)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../CLINK/
      INCLUDE  'clink'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C.......................................................................
C
C..<BEGIN> TO BE REMOVED
      REAL*8  RLESC(5) , ZLESC(5) ,  RRESC(5) , ZRESC(5)
C..<END  > TO BE REMOVED
C
      CHARACTER*4  SZE2D(MZE2D)
      DIMENSION    SUMZ(MZE2D)    , SUMSZ(MZE2D)       , SUMEZ(MZE2D)
     &         ,   FLUX3(MZE2D)   , FLUX4(MZE2D)
     &         ,   TOTZRD(MZE2D)  , FRAPUZ(MP,2,MZE2D) , PUFRZ(MZE2D)
      DIMENSION FHMC(MIO),PUFR(MIO),FZMC(MZE2D),ZZMC(MZE2D)
C
      CHARACTER    USERID*(*) , FTRIM*(*)
C
      CHARACTER*22 VERSON
      CHARACTER*1  BLANK  , DOT    , WALL   , ALBEDO , PLATE
     &          ,  CIR    , REC    , DIVPMP
      CHARACTER*1  EMIS   , EMISW , EMISX   , MAPS
      CHARACTER*3  SYMION
      CHARACTER*4  SYM , SYMW , STYPE
      CHARACTER    STRING*80
C
      PARAMETER (MCP=6)
      CHARACTER*4 SYMIMP
      DIMENSION AUXIMP(6,MCP)
      INTEGER INDIMP(MCP)
C
      PARAMETER   ( MFTRIM = 3 )
      CHARACTER*4  PROTRM(MFTRIM) , TARTRM(MFTRIM)
      CHARACTER*60 TRMFIL(MFTRIM)
      CHARACTER*2  CPW
C
      LOGICAL LCHECK , LWALL  , LPWALL , LPSEG  , LBUFLE , LTRAN
     &      , LTRAN0 , LPOUT  , LVESM  , LPLASM , LHORIZ
     &      , LPUMP  , LRDPMP(5) , LMOVRE , LPMPST , LFULL
     &      , LTEST  , LMC       , LBREC  , LFIRST
C
C------------------------------- VERSION -------------------------------
C
      DATA VERSON / 'V11.02.0 --- 02-MAR-99' /
C
      DATA LRDPMP/ .FALSE. , .FALSE. , .FALSE. , .FALSE. , .FALSE. /
C
C-----------------------------------------------------------------------
C
      DATA BLANK  / ' ' /
      DATA DOT    / '.' /
      DATA WALL   / 'W' /
      DATA ALBEDO / 'A' /
      DATA PLATE  / 'P' /
      DATA CIR    / '-' /
      DATA REC    / '*' /
      DATA DIVPMP / 'D' /
C
      DATA SYMION / 'H+ '  , 'D+ '  , 'DT+' , 'T+ '  /
C
      DATA PROTRM / 'D   ' , 'D   ' , 'D   ' /
      DATA TARTRM / 'C   ' , 'FE  ' , 'BE  ' /
C
      DATA STYPE  / 'PERP' , 'PARA' , 'DIV.'  /
C
      DATA LCHECK / .TRUE.   /
      DATA LPOUT  / .FALSE.  /
      DATA LVESM  / .FALSE.  /
      DATA LPLASM / .FALSE.  /
      DATA LFIRST / .TRUE.   /
C
      DATA ISETUP / 0 /
C
C------------------------------ INITIALISE -----------------------------
C
      CALL RESETR( VOLM(1)      , MPG           , 0.00D+00 )
      CALL RESETR( PUNION(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNENI(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNXMO(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNYMO(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNZMO(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNENE(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNION(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNADN(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNMDN(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNALF(1)    , MPG           , 0.00D+00 )
      CALL RESETR( PUNAEN(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNMEN(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNZDN(1,1)  , MPG*MIZ       , 0.00D+00 )
      CALL RESETR( PUNZIO(1,1)  , MPG*MIZ       , 0.00D+00 )
      CALL RESETR( PUNZEN(1,1)  , MPG*MIZ       , 0.00D+00 )
      CALL RESETR( PUNACS(1,1,1), MPG*3*MIO     , 0.00D+00 )
      CALL RESETR( PUNMCS(1,1,1), MPG*3*MIO     , 0.00D+00 )
      CALL RESETR( ECX(1)       , MPG           , 0.00D+00 )
      CALL RESETR( PUNAE0(1,1)  , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNSOU(1,1,1), MPG*2*2       , 0.00D+00 )
      CALL RESETR( DAHFR(1,1)   , MPG*MIO       , 0.00D+00 )
      CALL RESETR( PUNHO(1,1,1) , NHORT*3*NDIHO , 0.00D+00 )
C
      CALL RESETR( FLHCHM(1)    , MPG           , 0.00D+00 )
      CALL RESETI( IWGAP(1,1)   , MWGAP*2       , 0        )
      CALL RESETI( IMWGAP(1,1)  , MWGAP*2       , 0        )
C
      CALL RESETI( MAPFLX(1)    , MVESM         , 0        )
      CALL RESETR( BUFHSW(1,1)  , MVESM*MIONH   , 0.00D+00 )
C
C.... SKIP GEOMETRY SECTION OF MC FILE (ISETUP = 1 )
      IF( ISETUP.EQ.1 ) THEN
         REWIND IFILE
         WRITE(IFILE,'(/'' NIMBUS CALLED AT STEP '',I6)') ISTEPA
         GOTO 1990
      ENDIF
C
C.... FILL SYMBOL() & INDEX()
      CALL SETLNK( )
C
C---------------------- WALL SEGMENT REGION LABELS ---------------------
C
C.. OUTER TARGET   WALL SEGMENT REGION
      GWREG( 1) = 'OT'
C.. OUTER CORNER   WALL SEGMENT REGION
      GWREG( 2) = 'OC'
C.. OUTER DIVERTOR WALL SEGMENT REGION
      GWREG( 3) = 'OD'
C.. MAIN SOL WALL SEGMENT REGION
      GWREG( 4) = 'MS'
C.. INNER DIVERTOR WALL SEGMENT REGION
      GWREG( 5) = 'ID'
C.. INNER CORNER   WALL SEGMENT REGION
      GWREG( 6) = 'IC'
C.. INNER TARGET   WALL SEGMENT REGION
      GWREG( 7) = 'IT'
C.. PRIVATE VOID   WALL SEGMENT REGION
      GWREG( 8) = 'PV'
C.. COMPOUND BAFFLES WALL SEGMENT REGION
      GWREG( 9) = 'CB'
C.. NON-COMPOUND BAFFLES WALL SEGMENT REGION
      GWREG(10) = 'BA'
C
C--------------------------------- CHECK -------------------------------
C
      IF( NZE2D.GT.MZE2D ) THEN
          WRITE(LOUT,*) ' *** LINKPG ERROR *** NZE2D > MZE2D'
          WRITE(LOUT,*) ' NZE2D=',NZE2D , '    MZE2D=',MZE2D
          CALL EXITX(LOUT)
      END IF
C
      IF( IHOR.NE.0 .AND. NHORT.NE.MPG ) THEN
          WRITE(LOUT,*) ' *** LINKPG ERROR *** HORTON DIMENSION SIZE'
          CALL EXITX(LOUT)
      END IF
C
      IF( FTRIM.NE.' ' ) THEN
          ITRIM = 1
      ELSE
          ITRIM = 0
      END IF
C
C.. CHECK VALUES ARE MONTONIC AND IN THE EXCLUSIVE RANGE (0,1)
      IF( LPWALL .AND. NPWALL.GT.0 ) THEN
          CALL MONTON( NPWALL , FPWALL(1) , 0.0D0 , 1.0D0 , IER )
          IF( IER.NE.0 ) THEN
              IF( IER.EQ.1 ) THEN
                  WRITE(LOUT,9210) 'MONOTONIC'
              ELSE IF( IER.EQ.2 ) THEN
                  WRITE(LOUT,9210) 'IN THE EXCLUSIVE RANGE 0.0 -> 1.0'
              END IF
              CALL EXITX(LOUT)
          END IF
      END IF
C
C--------------------------- GET PUMP DATA -----------------------------
C
      IF( FPUMP.NE.' ' ) THEN
          LPMPST = .TRUE.
      ELSE
          LPMPST = .FALSE.
      END IF
C
      IF( .NOT.LPMPST ) THEN
          NPUMP  = 0
          NRPUMP = 0
          NLRS   = 0
          NWGAP  = 0
      END IF
C
      IF( LPMPST .AND. .NOT.LRDPMP(1) ) THEN
C
          CALL RDPUMP( INPUMP , FPUMP  , LPUMP , MLK
     &               , STRING , IER   )
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR(RDPUMP) : ' , STRING
              CALL EXITX(LOUT)
          ELSE
              LRDPMP(1) = .TRUE.
          END IF
C
          CALL DEFCIR( MVESC
     &               , XGAUGE(1) , YGAUGE(1) , RGAUGE(1) , LGAUGE(1) )
C
CW        DO 1 I = 1 , NPUMP
CW           WRITE(LOUT,'(/A,I5)')   ' IPUMP  = ' , I
CW           WRITE(LOUT,'(A,A)'  )   ' LAPUMP = ' , LAPUMP(I)
CW           WRITE(LOUT,'(A,I5)' )   ' NVPUMP = ' , NVPUMP(I)
CW           DO 2 J = 1 , NVPUMP(I)
CW              WRITE(LOUT,'(A,1PE12.4,A,E12.4,A,I1)')
CW   &                   ' RPUMP  = ' , RPUMP(I,J)
CW   &                 , ' ZPUMP  = ' , ZPUMP(I,J)
CW   &                 , ' ITPUMP1 = ' , ITPUMP(I,J,1)
CW  2        CONTINUE
CW  1     CONTINUE
C
      END IF
C
      IF( LPMPST ) THEN
C
          IF( .NOT.LRDPMP(4) ) THEN
              I = LOUT
          ELSE
              I = 0
          END IF
C
C.. PUMP DEFAULTS
          CALL DEFPMP( I      , MLK
     &               , PSEMPO , PSEMPI   , PSEMPT , PSEMPX
     &               , ALBPMP , ALBLK(1) )
          LRDPMP(4) = .TRUE.
C
C.. PUMP CIR STRUCTURES
         CALL PMPCIR( MVESC , NVESC     , XVESC(1,1) )
C
C.. OVERRIDE PUMP LRS VALUES
         CALL SETLRS( I , MCLRS , LLRS(1) , XLRS(1,1) , YLRS(1,1) )
C
C.. OVERRIDE PUMP GAP VALUES
         CALL SETGAP( I         , MCGAP
     &              , LGAP(1)   , XGAP(1,1) , YGAP(1,1) , PGAP(1,1)
     &              , RMARKG(1) , ZMARKG(1) )
C
      END IF
C
C------------------------- PRINT LINKPG VERSION ------------------------
C
      IF( IFILE.GT.0 ) THEN
        IF( NVES.GT.0 ) THEN
          IF( NBUFLE.GT.0 .OR. NBUFMX.GT.0 ) THEN
            WRITE(IPRINT,1470) VERSON , ICODE , LWALL , LPWALL , LBUFLE
     &                       , LPSEG  , LPMPST
          ELSE
            WRITE(IPRINT,1470) VERSON , ICODE , LWALL , LPWALL , .FALSE.
     &                       , LPSEG  , LPMPST
          END IF
        ELSE
          IF( NBUFLE.GT.0 .OR. NBUFMX.GT.0 ) THEN
            WRITE(IPRINT,1470) VERSON , ICODE ,.FALSE. , LPWALL , LBUFLE
     &                       , LPSEG  , LPMPST
          ELSE
            WRITE(IPRINT,1470) VERSON , ICODE ,.FALSE. , LPWALL ,.FALSE.
     &                       , LPSEG  , LPMPST
          END IF
       END IF
      END IF
C
C-----------------------------------------------------------------------
C
      IF( IFILE.GT.0 ) REWIND IFILE
C
C-----------------------------------------------------------------------
C
      NHORIZ = 0
C
      CALL RESETI( NPOLYK(1)   , 10          , 0        )
      CALL RESETI( ISEGK(1)    , 7           , 0        )
      CALL RESETI( ITAGSX(1,1) , NDIM1*4     , 0        )
      CALL RESETI( ITAGES(1)   , MPG         , 0        )
      CALL RESETI( IHORIZ(1)   , MPG         , 0        )
      CALL RESETI( NLIM(1)     , 2           , 0        )
      CALL RESETI( NPOLYC(1)   , 10          , 0        )
      CALL RESETI( NIMREG(1)   , 10          , 0        )
      CALL RESETI( IWSEGK(1)   , 8           , 0        )
C
      CALL RESETI( MHZWA(1)    , 2           , 0        )
      CALL RESETI( MHZVO(1)    , 2           , 0        )
      CALL RESETI( IVHZWA(1,1) , 2*2         , 0        )
C
      CALL RESETI( MCORN(1,1)  , 2*2         , 0        )
      CALL RESETR( RVINT(1)    , 2           , UDEF     )
      CALL RESETR( ZVINT(1)    , 2           , UDEF     )
      CALL RESETR( RCORN(1,1)  , 2*2         , UDEF     )
      CALL RESETR( ZCORN(1,1)  , 2*2         , UDEF     )
C
      DO I          = 1 , MR
         IF( IALBPG(I).NE.0 ) THEN
             ALBPG(I) = DMIN1( DABS(ALBPG(I) ) , 1.00D+00 )
             ALBEPG(I)= DMIN1( DABS(ALBEPG(I)) , 1.00D+00 )
         END IF
      ENDDO
C
C-----------------------------------------------------------------------
C
      IF(NZE2D.GT.1 .AND. MIMP.LE.0) THEN
        WRITE(LOUT,*) ' ***** LINKPG: MIMP<=0 AND NZE2D>1'
        CALL EXITX(LOUT)
      ENDIF
CW    WRITE(LOUT,*) 'NZE2D',NZE2D,(IZE2D(I),I=1,NZE2D)
      LIGHTW=0
      IF(NZE2D.LE.0) THEN
        WRITE(LOUT,'(''*** LINKPG. NZE2D.LE.0'')')
        CALL EXITX(LOUT)
      ELSE IF(NZE2D.EQ.1) THEN
        IF(IZE2D(1).LT.0) LIGHTW=1
      ELSE IF(NZE2D.EQ.2) THEN
        IF(IZE2D(1).LT.0 .AND.IZE2D(2).EQ.IZWALL) THEN
          LIGHTW=1
        ELSEIF(IZE2D(2).LT.0 .AND.IZE2D(1).EQ.IZWALL) THEN
          LIGHTW=2
        ENDIF
      ELSE
        WRITE(LOUT,'(''*** LINKPG. TOO MANY IMPURITIES'')')
        CALL EXITX(LOUT)
      ENDIF
C
      TEVWL     = ( TWALL + 2.7314D+02 ) / 1.16D+04
      TIVWL     = TEVWL
C
      TEVTA     = ( TTARG + 2.7314D+02 ) / 1.16D+04
      TIVTA     = TEVTA
C
      TEVDV     = ( TDIVW + 2.7314D+02 ) / 1.16D+04
      TIVDV     = TEVDV
C
      TEVPR     = ( TPRIV + 2.7314D+02 ) / 1.16D+04
      TIVPR     = TEVPR
C
      TEVSD     = ( TSUBD + 2.7314D+02 ) / 1.16D+04
      TIVSD     = TEVSD
C
      IF(IFPRIM.NE.0 .AND. ICODE.EQ.2) THEN
        DO KZ=1,NZE2D
          SZE2D(KZ)=SYMBOL(0)
          DO J=1,NDIM3
CW          WRITE(LOUT,*) ' KZ,IZE2D,J,INDEX=',KZ,IZE2D(KZ),J,INDEX(J)
            IF(IABS(IZE2D(KZ)).EQ.INDEX(J)) SZE2D(KZ)=SYMBOL(J)
          ENDDO
CW        WRITE(LOUT,'('' KZ,SZE2D='',I3,2X,A)') KZ,SZE2D(KZ)
          IF(SZE2D(KZ).EQ.SYMBOL(0)) THEN
            WRITE(LOUT,*) ' *** ERROR (LINKPG) : SZE2D = SYMBOL = '
     &                  , SZE2D(KZ)
            CALL EXITX(LOUT)
          ENDIF
        ENDDO
      ELSE
        IF(NZE2D.GT.1) THEN
          WRITE(LOUT,*) ' *** ERROR (LINKPG) : NZE2D>1 AND IFPRIM=0'
          CALL EXITX(LOUT)
        ELSE
          SZE2D(1)=SYMBOL(0)
          LIGHTW=0
        ENDIF
      ENDIF
C
      IZINDW    = 0
      DO 10 IZ  = 1 , NDIM3
         IF( IZWALL.EQ.INDEX(IZ) ) IZINDW = IZ
   10 CONTINUE
      IF(IZINDW.EQ.0) THEN
         WRITE(LOUT,*) ' *** ERROR (LINKPG) : IZINDW = 0'
         CALL EXITX(LOUT)
      END IF
C
C-----------------------------------------------------------------------
C
      IF( IFWALD.NE.0 .AND. LPOUT ) THEN
          WRITE(LOUT,*)' *** ERROR *** IFWALD > 0 NOT YET IMPLEMENTED'
          WRITE(LOUT,*)'               THEREFORE, SETTING IFWALD = 0   '
          IFWALD = 0
      END IF
C
C-----------------------------------------------------------------------
C
      IF( IFPRIM.EQ.0 ) THEN
          DECPRO = 1.0E-30
      ELSE
          DECPRO = DECIMA
      END IF
C
      IDEBIN   = 1
C
C#######################################################################
C###### CHECK GEOMETRY RECTANGLE IS BIG ENOUGH FOR ALL STRUCTURES ######
C#######################################################################
C
      IF( .NOT.LMOVRE ) THEN
C.. ASSEMBLE ALL STRUCTURAL POINTS
          K                     = 0
C (VESSEL)
          DO 50 I               = 1 , NVES
             K                  = K + 1
             BUFFER(K)          = RVES(I)
             BUFFER(MDIM+K)     = ZVES(I)
   50     CONTINUE
C (PUMP RECTANGLE)
          IF( LPMPST ) THEN
              BUFFER(K+1)       = GPUMP(1)
              BUFFER(K+2)       = GPUMP(1) + GPUMP(3)
              BUFFER(MDIM+K+1)  = GPUMP(2)
              BUFFER(MDIM+K+2)  = GPUMP(2) + GPUMP(4)
              K                 = K + 2
          END IF
C
C (MOVE GEOMETRY RECTANGLE ?)
          CALL MOVREC( LOUT
     I               , K       , BUFFER(1), BUFFER(MDIM+1) , 5.0D-02
     I               , GEOM(1) , GEOM(2)  , GEOM(3)         , GEOM(4)
     O               , IRES    )
C
C (LIMIT PUMP COORDS TO GEOMETRY RECTANGLE)
          IF( LPMPST ) THEN
              WRITE(LOUT,*) ' '
              DO 60 I = 1 , NPUMP
                 DO 65 J = 1 , NVPUMP(I)
                    IF( RPUMP(I,J).LT.GEOM(1) ) THEN
                        WRITE(LOUT,9100) LAPUMP(I) , J , 'R' ,RPUMP(I,J)
     &                              , GEOM(1)
                        RPUMP(I,J) = GEOM(1)
                    END IF
                    IF( ZPUMP(I,J).LT.GEOM(2) ) THEN
                        WRITE(LOUT,9100) LAPUMP(I) , J , 'Z' ,ZPUMP(I,J)
     &                              , GEOM(2)
                        ZPUMP(I,J) = GEOM(2)
                    END IF
                    IF( RPUMP(I,J).GT.GEOM(1)+GEOM(3) ) THEN
                        WRITE(LOUT,9100) LAPUMP(I) , J , 'R' ,RPUMP(I,J)
     &                              , GEOM(1)+GEOM(3)
                        RPUMP(I,J) = GEOM(1) + GEOM(3)
                    END IF
                    IF( ZPUMP(I,J).GT.GEOM(2)+GEOM(4) ) THEN
                        WRITE(LOUT,9100) LAPUMP(I) , J , 'Z' ,ZPUMP(I,J)
     &                              , GEOM(2)+GEOM(4)
                        ZPUMP(I,J) = GEOM(2) + GEOM(4)
                    END IF
   65            CONTINUE
   60         CONTINUE
              WRITE(LOUT,*) ' '
          END IF
C
         LMOVRE = .TRUE.
C
      END IF
C
C#######################################################################
C######################### NIMBUS POLYGON REGIONS ######################
C#######################################################################
C
      DO M = 1 , NPOLYM
         N = ITAGM(M,1)
         K = KORKG(N)
         CALL IREGON( MP , ITAG(1,1) , JPRGT , JPLFT , NXW , IOPEN
     &              , K  , ITAGRM(M) )
         MPOLYT(M) =  1     ! PLASMA POLYGON
      ENDDO
C
C#######################################################################
C########################## NIMBUS FILE HEADER #########################
C#######################################################################
C
      IF( IFILE.GT.0 ) THEN
        IF(ICODE.EQ.0 .OR. ICORRN.EQ.0) THEN
          ICORR = 0
        ELSE
          ICORR = NHIST
        ENDIF
C
        IF( IREFCT.LE.0 ) THEN
            LREFCT = 0
        ELSE
            LREFCT = 1
        END IF
C
        IF(LPMPST) THEN
          I1 = ISIGN(15,IPVOID)
          CPW= PWMAT
        ELSE
          I1 = 0
          CPW= '  '
        ENDIF
C
        WRITE(IFILE,1000) ISTEPA , ISHOT  , BCD(1:60)
     &                  , NHIST  , KINDPR , INIZ   , ISEHHE , ISP93
     &                  , ITAU   , MCX    , IHOR   , ISPLIT
     &                  , NTSPUT , NOZPMP , IMOMSO , ICORR  , MCOLP
     &                  , IREAD  , IWRITE , DECPRO
     &                  , IHYEAR , IZYEAR , IDYEAR
     &                  , (MAX0(IXS(I),0),I=1,MIXS), ITRIM
     &                  , IYCHEM , EYCHEM , AYCHEM , ALFCH7
     &                  , USERID
        WRITE(IFILE,'(I6)') NZE2D
        DO KZ=1,NZE2D
          WRITE(IFILE,'(A4,8X,1P,3E12.5)')SZE2D(KZ),AYIZ(KZ),BYIZ(KZ),0.
        ENDDO
        WRITE(IFILE,1001) DCUTCX , TCUTCX , TPUFF , 0.025
     &                  , I1     , CPW    , TEVSD , MIMP , IGOPT
     &                  , IDEBIN
     &                  , 0      , MDEBWR , MDEBPT , MACRO
        WRITE(IFILE,1062) ( ISPOFF(I) , I=1,MACRO )
        WRITE(IFILE,1001) YNOSP
        WRITE(IFILE,1060) ( IDBHST(I) , I=1,MDEBWR )
        WRITE(IFILE,1005) ICHKP  , IVIEW  , LREFCT
      ENDIF
C
C#######################################################################
C############### CREATE ESCAPE FIGURE POLYGONS #########################
C#######################################################################
C
C.. NUMBER OF VESSEL SEGMENTS
      NSEG   = 0
C
C.. TOTAL NUMBER OF NIMBUS POLYGONS (CURRENTLY CREATED)
      NPOLY = NPOLYM
C
C.. CREATE ESCAPE FIGURE POLYGONS
      CALL MKESCG( LOUT   , LMC       , LPWALL    , LPSEG  , LBUFLE
     I           , RPX    , ZPX       , PROJ      , EPS    , ZESCUT
     I           , MP     , 5         , ITAG(1,1)
     I           , MR     , IALBPG(1)
     I           , NDIM1  , 4
     I           , IOPEN  , NXW       , JPRGT     , JPLFT
     I           , MPWALL , NPWALL    , FPWALL(1) , IALB
     O           , NSEG   , ITAGS(1,1)
     O           , NPOLY  )
C
C.. PROCESS PUMP
       IF( LPMPST ) CALL MKPUMP( LOUT , LPMPST , NPOLY , RPX , ZPX )
C
C.. NUMBER OF POLYGONS FORMING PRIVATE VOID INCLUDING VOID COVER
      IF( NXPG.EQ.1 ) THEN
          IABEDO = NPOLYK(8) + NPOLYK(10) + 6
      ELSE
          IABEDO = 0
      ENDIF
C
C#######################################################################
C###################### WRITE NIMBUS POLYGONS ##########################
C#######################################################################
C
C.... RANGES OF POLYGON REGIONS
      CALL POLRNG( LOUT , NPOLY )
C
C.... FOR HISTORICAL REASONS
      NPOLYC(3)  = MPOLYS(9)                    ! START OF BAFFLE
C
      IF( MPOLYS(9).NE.0 )
     &    MEXTRA = MPOLYE(9) - MPOLYS(9) + 1    ! NO. OF BAFFLES
C
C.... WRITE POLYGONS TO FILE ?
      IF( IFILE.GT.0 ) THEN
          CALL WRPOLY( IFILE , LPMPST , IVIEW , VIEW(1) , NPOLY )
      ENDIF
C
C#######################################################################
C########################## NIMBUS REGIONS #############################
C#######################################################################
C
C.... ASSIGN CHARACTER (MAPS) TO REGIONS
      CALL MAPREG( LOUT    , NPOLY  , LPMPST , IALB
     I           , CIR     , REC    , DOT    , BLANK  , WALL
     I           , ALBEDO  , PLATE  , DIVPMP )
C
C.... WRITE NIMBUS REGIONS
      IF( IFILE.GT.0 ) THEN
          CALL WRREG( IFILE , LOUT , NPOLY , LPMPST , LBUFLE
     &              , IALB  , EPS )
      ENDIF
C
C#######################################################################
C####################### SET WALL GAP POLYGONS #########################
C#######################################################################
C
      IF( LPMPST .AND. NWGAP.GT.0 ) THEN
C
          IF( .NOT.LRDPMP(5) ) THEN
              I = LOUT
          ELSE
              I = 0
          END IF
C
          CALL WALGAP( I
     I               , MPG       , MRG         , MR          , NPOLY
     I               , NVERTM    , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     I               , RPX       , ZPX         , RMARKG(1)   , ZMARKG(1)
     O               , IPSEMP(1) , PSEMP(1)    , PSEMG(1)    )
          LRDPMP(5) = .TRUE.
C
      END IF
C
C#######################################################################
C############################# REGION MAP ##############################
C#######################################################################
C
C     DO NOT TAMPER WITH COMM!
      DO 786 M = 1,MPG
         MAPS(M) = COMM(M)
  786 CONTINUE
      DO 787 I = 1 , MR
         M     = IPSEMP(I)
         IF( M.GT.0 ) THEN
           IF( ITAGES(M-2).LT.0 ) THEN
               RGEN1(1) = MIN( PSEMP(I) , PSEMG(I) )
               RGEN1(2) = MAX( PSEMP(I) , PSEMG(I) )
               IF( RGEN1(1).GT.0.9999D0 ) THEN
C.. BOTH TRANSP. ALMOST VOID
                   MAPS(M) = ' '
               ELSE IF ( RGEN1(2).GT.0.0001D0 .AND.
     &                   RGEN1(1).LT.0.9999D0       ) THEN
C.. NEITHER TRANSP. ALMOST VOID OR WALL
                   MAPS(M) = '/'
               ELSE
C.. BOTH TRANS. ALMOST WALL
                   MAPS(M) = '%'
               ENDIF
           ENDIF
         ENDIF
  787 CONTINUE
C
      IF(IFILE.GT.0) WRITE(IFILE,1040) ( MAPS(M) , M=1,NIMREG(1) )
C
C#######################################################################
C############################ NIMBUS VESSEL ############################
C#######################################################################
C
      IF( .NOT.LVESM ) THEN
C
C(1) PRODUCTION OF ORDERED NIMBUS VESSEL SEGMENT PAIRS
C
          CALL SETSEG( 1          , MVESM      , NIMREG(1)
     &               , COMM(1)    , ITAGRM(1)
     &               , DOT        , BLANK      , WALL
     &               , ALBEDO     , DIVPMP
     &               , MHZWA(1)   , MHZVO(1)   , IVHZWA(1,1)
     &               , MWGAP      , NWGAP
     &               , IWGAP(1,1) , IMWGAP(1,1)
     &               , MWREG      , GWREG(1)
     &               , NVESM      , RVESM(1,1) , ZVESM(1,1)
     &               , IVESM(1,1) , GVESM(1)
     &               , STRING     , IER        )
C
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR(SETSEG) : ' , STRING
              CALL EXITX(LOUT)
          END IF
C
C(2) PUMP SPECIAL VERTICIES MUST NOT LIE ON A VESSEL SEGMENT
C    (NB. DISTANCE FROM 1ST SEGMENT TO PUMP VERTEX TO 2ND SEGMENT
C       = DISTANCE FROM 1ST SEGMENT TO 2ND SEGMENT
C       = PUMP VERTEX LIES ON VESSEL SEGMENT )
C
          IF( LPMPST ) THEN
              DO 790 I = 1 , NPUMP
                 DO 792 J = 1 , NVPUMP(I)
                    IF( ITPUMP(I,J,1).NE.0 ) THEN
                        DO 794 K = 1 , NVESM
                           BUFFER(1) = RVESM(K,1)
                           BUFFER(2) = ZVESM(K,1)
                           BUFFER(3) = RVESM(K,2)
                           BUFFER(4) = ZVESM(K,2)
                           BUFFER(5) = PYTHGS( BUFFER(1)  , BUFFER(2)
     &                                       , BUFFER(3)  , BUFFER(4)  )
                           BUFFER(6) = PYTHGS( BUFFER(1)  , BUFFER(2)
     &                                       , RPUMP(I,J) , ZPUMP(I,J) )
                           BUFFER(7) = PYTHGS( BUFFER(3)  , BUFFER(4)
     &                                       , RPUMP(I,J) , ZPUMP(I,J) )
                           BUFFER(8) = (BUFFER(6)+BUFFER(7)) - BUFFER(5)
                           IF( BUFFER(8).LT.EPS ) THEN
                               WRITE(LOUT,9110) LAPUMP(I) , J , K
     &                                     , RPUMP(I,J) , ZPUMP(I,J)
     &                                     , RVESM(K,1) , ZVESM(K,1)
     &                                     , RVESM(K,2) , ZVESM(K,2)
                               CALL EXITX(LOUT)
                           END IF
  794                   CONTINUE
                    END IF
  792            CONTINUE
  790         CONTINUE
          END IF
C
C(3) BAFFLE SEGMENTS
C
          IF( LBUFLE .AND. IALB.EQ.2 .AND. NBUFLE.GT.0 ) THEN
              IF( NVESM+NBUFLE+1.LE.MVESM ) THEN
C... INITIALIZE
                  RGEN1(3)          = 0.00D+00
                  ZGEN1(3)          = 0.00D+00
                  RGEN1(4)          = 0.00D+00
C... ASSEMBLE SEGMENTS, SUM AND BUFFLE LENGTH
                  DO 770 I          = 1 , NBUFLE
                     IF( I+1.LE.NBUFLE ) THEN
                         IP1        = I + 1
                     ELSE
                         IP1        = 1
                     END IF
                     NVESM          = NVESM + 1
                     RVESM(NVESM,1) = RBUFLE(I)
                     ZVESM(NVESM,1) = ZBUFLE(I)
                     RVESM(NVESM,2) = RBUFLE(IP1)
                     ZVESM(NVESM,2) = ZBUFLE(IP1)
                     IVESM(NVESM,1) = -(NPOLYK(2)+1)
                     IVESM(NVESM,2) = -(NPOLYK(2)+1)
                     IVESM(NVESM,3) = 0
                     GVESM(NVESM)   = GWREG(10)
                     RGEN1(3)       = RGEN1(3) + RBUFLE(I)
                     ZGEN1(3)       = ZGEN1(3) + ZBUFLE(I)
                     RGEN1(4)       = RGEN1(4) +
     &                                PYTHGS(RBUFLE(I  ),ZBUFLE(I  )
     &                                      ,RBUFLE(IP1),ZBUFLE(IP1))
  770             CONTINUE
C... AVERAGED CENTRE OF BUFFLE
                  RGEN1(3)          = RGEN1(3) / DFLOAT(NBUFLE)
                  ZGEN1(3)          = ZGEN1(3) / DFLOAT(NBUFLE)
C... COMPOUND BUFFLE WALL SEGMENT DATA
                  NVESM             = NVESM + 1
                  RVESM(NVESM,1)    = RGEN1(3) - RGEN1(4)*5.0D-01
                  RVESM(NVESM,2)    = RGEN1(3) + RGEN1(4)*5.0D-01
                  ZVESM(NVESM,1)    = ZGEN1(3)
                  ZVESM(NVESM,2)    = ZGEN1(3)
                  IVESM(NVESM,1)    = NPOLYK(2) + 1
                  IVESM(NVESM,2)    = -IVESM(NVESM,1)
                  IVESM(NVESM,3)    = 4
                  GVESM(NVESM)      = GWREG(9)
              ELSE
                  WRITE(LOUT,9070) NVESM+NBUFLE , MVESM
                  CALL EXITX(LOUT)
             END IF
          END IF
C
C(4) EXTRA BAFFLE SEGMENTS
C
          IF( LBUFLE .AND. IALB.EQ.2 .AND. NBUFMX.GT.0 ) THEN
C
              M     = 0
              DO IB = 1 , NBUFMX
                 IF( NBUFX(IB).LE.0 ) GOTO 779
                 IF( NVESM+NBUFX(IB)+1.LE.MVESM ) THEN
C... INITIALIZE
                     M                 = M + 1
                     RGEN1(3)          = 0.00D+00
                     ZGEN1(3)          = 0.00D+00
                     RGEN1(4)          = 0.00D+00
C... ASSEMBLE SEGMENTS, SUM AND BUFFLE LENGTH
                     DO 775 I          = 1 , NBUFX(IB)
                        IF( I+1.LE.NBUFX(IB) ) THEN
                            IP1        = I + 1
                        ELSE
                            IP1        = 1
                        END IF
                        NVESM          = NVESM + 1
                        RVESM(NVESM,1) = RBUFX(IB,I)
                        ZVESM(NVESM,1) = ZBUFX(IB,I)
                        RVESM(NVESM,2) = RBUFX(IB,IP1)
                        ZVESM(NVESM,2) = ZBUFX(IB,IP1)
                        IVESM(NVESM,1) = -(NPOLYK(2)+1+M)
                        IVESM(NVESM,2) = -(NPOLYK(2)+1+M)
                        IVESM(NVESM,3) = 0
                        GVESM(NVESM)   = GWREG(10)
                        RGEN1(3)       = RGEN1(3) + RBUFX(IB,I)
                        ZGEN1(3)       = ZGEN1(3) + ZBUFX(IB,I)
                        RGEN1(4)       = RGEN1(4) +
     &                               PYTHGS(RBUFX(IB,I  ),ZBUFX(IB,I  )
     &                                     ,RBUFX(IB,IP1),ZBUFX(IB,IP1))
  775                CONTINUE
C... AVERAGED CENTRE OF BUFFLE
                     RGEN1(3)          = RGEN1(3) / DFLOAT(NBUFX(IB))
                     ZGEN1(3)          = ZGEN1(3) / DFLOAT(NBUFX(IB))
C... COMPOUND BUFFLE WALL SEGMENT DATA
                     NVESM             = NVESM + 1
                     RVESM(NVESM,1)    = RGEN1(3) - RGEN1(4)*5.0D-01
                     RVESM(NVESM,2)    = RGEN1(3) + RGEN1(4)*5.0D-01
                     ZVESM(NVESM,1)    = ZGEN1(3)
                     ZVESM(NVESM,2)    = ZGEN1(3)
                     IVESM(NVESM,1)    = NPOLYK(2) + 1 + M
                     IVESM(NVESM,2)    = -IVESM(NVESM,1)
                     IVESM(NVESM,3)    = 4
                     GVESM(NVESM)      = GWREG(9)
                 ELSE
                     WRITE(LOUT,9070) NVESM+NBUFX(IB) , MVESM
                     CALL EXITX(LOUT)
                 END IF
  779            CONTINUE
             ENDDO
          END IF
C
C(4)  PUMP STRUCTURE SEGMENTS
C
          NVESP                              = 0
          IF( LPMPST ) THEN
              NV                             = 0
              DO 810 I                       = 1 , NPSB
                 K                           = I4CHRV(LAPSB(I))
                 IF( NDPSB(I).GT.1 ) THEN
                     DO 820 J                    = 1 , NDPSB(I) - 1
                        IV1                      = IDPSB(I,J)
                        IV2                      = IDPSB(I,J+1)
                        IF( IV1.LE.0 .OR. IV1.GT.NVPUMP(K) ) THEN
                            WRITE(LOUT,9120) I , K , J , IV1
                            CALL EXITX(LOUT)
                        END IF
                        IF( IV2.LE.0 .OR. IV2.GT.NVPUMP(K) ) THEN
                            WRITE(LOUT,9120) I , K , J , IV2
                            CALL EXITX(LOUT)
                        END IF
                        NVESP                    = NVESP + 1
                        IF( NVESM+NVESP.LE.MVESM ) THEN
                            RVESM(NVESM+NVESP,1) = RPUMP(K,IV1)
                            RVESM(NVESM+NVESP,2) = RPUMP(K,IV2)
                            ZVESM(NVESM+NVESP,1) = ZPUMP(K,IV1)
                            ZVESM(NVESM+NVESP,2) = ZPUMP(K,IV2)
                            IVESM(NVESM+NVESP,3) = IPTPSB(I)
                        ELSE
                            WRITE(LOUT,9075) NVESM+NVESP , MVESM
                            CALL EXITX(LOUT)
                        END IF
  820                CONTINUE
                 ELSE
                     IV                          = IDPSB(I,1)
                     IF( IV.LE.0 .OR. IV.GT.NVPUMP(K) ) THEN
                         WRITE(LOUT,9120) I , K , J , IV
                         CALL EXITX(LOUT)
                     END IF
                     NV                          = NV + 1
                     IF( NV.EQ.1 ) THEN
                         NVESP                   = NVESP + 1
                         IF( NVESM+NVESP.GT.MVESM ) THEN
                             WRITE(LOUT,9075) NVESM+NVESP , MVESM
                             CALL EXITX(LOUT)
                         ELSE
                             IVESM(NVESM+NVESP,3)    = IPTPSB(I)
                         END IF
                     END IF
                     RVESM(NVESM+NVESP,NV)       = RPUMP(K,IV)
                     ZVESM(NVESM+NVESP,NV)       = ZPUMP(K,IV)
                     IF( NV.EQ.2 ) NV            = 0
                 END IF
  810         CONTINUE
C
              DO 830 I                = 1 , NLRS
                 DO 835 J             = I-1 , 1 , -1
                    IF( LALRS(I).EQ.LALRS(J) ) GOTO 830
  835            CONTINUE
                 NVESP                = NVESP + 1
                 RVESM(NVESM+NVESP,1) = RLRS(I,1)
                 RVESM(NVESM+NVESP,2) = RLRS(I,2)
                 ZVESM(NVESM+NVESP,1) = ZLRS(I,1)
                 ZVESM(NVESM+NVESP,2) = ZLRS(I,2)
                 IVESM(NVESM+NVESP,3) = 0
  830         CONTINUE
          END IF
C
          LVESM = .TRUE.
      END IF
C
C.. LENGTHS OF WALL SEGMENT REGIONS
      CALL LENREG( LOUT
     I           , MVESM    , MWREG
     I           , NVESM    , RVESM(1,1) , ZVESM(1,1) , GVESM(1)
     I           , GWREG(1)
     O           , AWREG(1) )
C
C#######################################################################
C############################ PLASMA BOUNDARY ##########################
C#######################################################################
C
      IF( .NOT.LPLASM ) THEN
C
          CALL SETSEG( 2           , MVESM       , NIMREG(1)
     &               , COMM(1)     , ITAGRM(1)
     &               , DOT         , BLANK       , WALL
     &               , ALBEDO      , DIVPMP
     &               , MHZWA(1)    , MHZVO(1)    , IVHZWA(1,1)
     &               , MWGAP       , NWGAP
     &               , IWGAP(1,1)  , IMWGAP(1,1)
     &               , MWREG       , GWREG(1)
     &               , NPLASM      , RPLASM(1,1) , ZPLASM(1,1)
     &               , IPLASM(1,1) , GPLASM(1)
     &               , STRING      , IER         )
C
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR(SETSEG) : ' , STRING
              CALL EXITX(LOUT)
          END IF
C
          LPLASM = .TRUE.
      END IF
C
C#######################################################################
C################################ AREAS ################################
C#######################################################################
C
      IMAX = ( NIMREG(1) ) / 12
      IF( MOD( NIMREG(1) , 12 ).NE.0 ) IMAX = IMAX + 1
C
      DO 800 I      = 1 , IMAX
         DO 850 K   = 1 , 12
            L1(K) = 1
            IR      = ( I - 1 ) * 12 + K
            IF( IR.GE.3 .AND. IR.LE.NIMREG(2) ) THEN
                IF( ITAGES(IR-2).EQ.1 ) L1(K) = 0
            ELSE IF( IR.GT.NIMREG(2) .AND. IR.LT.NIMREG(1) ) THEN
                IF( COMM(IR).EQ.BLANK ) THEN
                    L1(K) = 0
                ELSE IF( COMM(IR).EQ.'G' ) THEN
                    L1(K) = 0
                ELSE IF( COMM(IR).EQ.'K' ) THEN
                    L1(K) = 0
                END IF
            END IF
            IF( IR.GT.NIMREG(1) ) GOTO 850
            IF( COMM(IR).EQ.DOT ) L1(K) = 0
  850    CONTINUE
         IF( IFILE.GT.0 ) WRITE(IFILE,1050) ( DFLOAT(L1(K)) , K=1,12 )
  800 CONTINUE
C
      IF( IFILE.GT.0 ) WRITE(IFILE,1060) 0
C
C#######################################################################
C##################### CHECK LEAK RECYCLING SEGMENTS ###################
C#######################################################################
C
      IF( NLRS.GT.0 .AND. LPMPST ) THEN
C
          CALL CHKLRS( MVESM , NPLASM , RPLASM(1,1) , ZPLASM(1,1)
     &               , MVESM , NVESM  , RVESM(1,1)  , ZVESM(1,1)
     &               , LOUT  , NSTRIP , RGEN1(1)    , ZGEN1(1)
     &               , IER   , STRING )
C
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR(CHKLRS) : ' , STRING
              IF( .NOT.LMC ) CALL EXITX(LOUT)
          END IF
C
      END IF
C
C#######################################################################
C########################## REGIONS & CHANNELS #########################
C#######################################################################
C
      NCHAN  = 0
C
      DO 900 I        = 1 , NCPG
         IF( I.EQ.NXWPG ) GOTO 900
         NCHAN        = NCHAN + 1
         MCHAN(NCHAN) = 0
C
         DO 920 J     = NJP(I) , 1 , -1
            N         = KORP(I,J)
C
            DO 940 K  = 1 , NM(N)
               MCHAN(NCHAN) = MCHAN(NCHAN) + 1
               JCHAN(NCHAN,MCHAN(NCHAN)) = KORM(N,K)
  940       CONTINUE
C
  920    CONTINUE
C
  900 CONTINUE
C
      IF( IFILE.GT.0 ) THEN
        IF( IFCHAN.EQ.0 ) THEN
            WRITE(IFILE,1060) 0
        ELSE
            WRITE(IFILE,1060) NCHAN , ( MCHAN(IC) , IC=1,NCHAN )
            WRITE(IFILE,1060) ((JCHAN(IC,J)+2,J=1,MCHAN(IC)),IC=1,NCHAN)
            WRITE(IFILE,1060) ( 0 , IC=1,NCHAN )
        END IF
      END IF
C
C#######################################################################
C############################# MACRO-ZONES #############################
C#######################################################################
C
      IF( IFILE.GT.0 ) THEN
C........................ PATCH FOR MACRO-ZONES .......................
C            (FORCE ALL OUTER  VOID REGIONS INTO ONE REGION)
C            (FORCE ALL OUTER  WALL REGIONS INTO ONE REGION)
C            (FORCE ALL CORNER WALL REGIONS INTO ONE REGION)
C            (FORCE PUMP VOID REGION AS MACRO-ZONE '15' REST AS '0')
          DO 466 M      = 1 , (NIMREG(1)-1) - 2
             IF( M.LE.NIMREG(2)-2 ) THEN
                 MZONE(M,1) = ITAGRM(M)
                 IF(ITAGRM(M).EQ.17.OR.ITAGRM(M).EQ.18) MZONE(M,1) = 8
                 IF(ITAGRM(M).EQ.19.OR.ITAGRM(M).EQ.20) MZONE(M,1) = 9
                 IF(ITAGRM(M).EQ.21                   ) MZONE(M,1) = 10
                 IF(ITAGRM(M).EQ.22                   ) MZONE(M,1) = 12
             ELSE
                 IF( COMM(M+2).EQ.BLANK ) THEN
                     MZONE(M,1) = 15
                 ELSE IF( COMM(M+2).EQ.'L') THEN
                     MZONE(M,1) = 16
                 ELSE IF( COMM(M+2).EQ.'R') THEN
                     MZONE(M,1) = 16
                 ELSE IF( COMM(M+2).EQ.'C') THEN
                     MZONE(M,1) = 16
                 ELSE IF( COMM(M+2).EQ.'B') THEN
                     MZONE(M,1) = 16
                 ELSE IF( COMM(M+2).EQ.'P'.OR.COMM(M+2).EQ.'O' ) THEN
                     MZONE(M,1) = 17
                 ELSE IF( COMM(M+2).EQ.'1') THEN
                     MZONE(M,1) = 18
                 ELSE IF( COMM(M+2).EQ.'2') THEN
                     MZONE(M,1) = 19
                 ELSE IF( COMM(M+2).EQ.'3') THEN
                     MZONE(M,1) = 20
                 ELSE IF( COMM(M+2).EQ.'4') THEN
                     MZONE(M,1) = 21
                 ELSE IF( COMM(M+2).EQ.'X') THEN
                     MZONE(M,1) = 16
                 ELSE IF( COMM(M+2).EQ.'G') THEN
                     MZONE(M,1) = 22
                 ELSE IF( COMM(M+2).EQ.'K') THEN
                     MZONE(M,1) = 23
                 ELSE
                     MZONE(M,1) = 0
                 END IF
             END IF
  466     CONTINUE
C......................................................................
          WRITE(IFILE,1060) 1
          WRITE(IFILE,1060) 0 , 0
     &                    , ( MZONE(M,1) , M = 1 , (NIMREG(1)-1) - 2 )
      END IF
C
CW    DO 464 M = 1 , NPOLYK(2)+MEXTRA
CW       WRITE(LOUT,*) ' M+2,ITAGRM=' , M+2 , ITAGRM(M)
CW464 CONTINUE
C
C#######################################################################
C############################# TIME-DEPENDENT ##########################
C#######################################################################
C
 1990 CONTINUE
      IF( IFILE.GT.0 ) THEN
         WRITE(IFILE,1064) ISTEPA , ILSTMC
         IF(TSLICE.EQ.0.0) THEN
            WRITE(IFILE,1065)  TSLICE, 0, 1
         ELSE
            WRITE(IFILE,1065)  TSLICE, ITIMIO, 1
            IF(ITIMIO.GE.0) THEN
              ITIMIO = -1
            ELSE
              ITIMIO = +1
            ENDIF
         ENDIF
      ENDIF
C
C#######################################################################
C############################# COMPOSITION #############################
C#######################################################################
C
      SHP = 0.00D+00
      IF( IFILE.GT.0 ) THEN
        IF(NION.GT.1 .AND. IMPURE.NE.2) THEN
          WRITE(LOUT,*) ' NION > 1 AND IMPURE <> 2'
          CALL EXITX(LOUT)
        ENDIF
        WRITE(IFILE,1070) IMPURE,NIONH , 0.0 , 0.0 , 0.0 , SHP
     &                                 , 0.0 , 0.0 , 0.0 , 0   , EATMD
     &                                 , EATMR
      ENDIF
C
C#######################################################################
C############################# COSINES #################################
C#######################################################################
C
      DO 2000 I        = 1 , NCPG
         IF( NJP(I).LE.0 ) GOTO 2000
         NFIRST        = KORP(I,1     )
         NLAST         = KORP(I,NJP(I))
C
         DO 2010 J     = NJP(I) , 1 , -1
            N          = KORP(I,J)
            K          = KORKG(N)
C
            IF( ITAG(K,4).NE.4 ) THEN
                IF( J-1.GE.1      ) THEN
                    N0 = KORP(I,J-1)
                ELSE
                    N0 = NLAST
                END IF
                K0     = KORKG(N0)
                N1     = N
                K1     = K
            ELSE
                N0     = N
                K0     = K
                IF( J+1.LE.NJP(I) ) THEN
                    N1 = KORP(I,J+1)
                ELSE
                    N1 = NFIRST
                END IF
                K1     = KORKG(N1)
            END IF
C
            RDIFF      = RMESH(K0) - RMESH(K1)
            ZDIFF      = ZMESH(K0) - ZMESH(K1)
            RZLEN      = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
            SINA       = RDIFF/RZLEN
            COSA       = ZDIFF/RZLEN
C           AVERAGE HYDROGEN PARALLEL VELOCITY
            VPARA=0.0
            DENSA=0.0
            DO IH=1,NIONH
              VPARA=VPARA+VPAR(K1,IH)*DENSI(K1,IH)
              DENSA=DENSA+DENSI(K1,IH)
            ENDDO
            IF(DENSA.GT.0.0) VPARA=VPARA/DENSA
            SIGNK1     = DSIGN( 1.00D+00 , VPARA )
            COSU       = SIGNK1 * SH(K1) * (-SINA )
            COSV       = SIGNK1 * SH(K1) * (-COSA )
            COSW       = SIGNK1 * BSIGN * DSQRT( 1.0D0 - SH(K1)*SH(K1) )
            TRAN       = DSQRT( COSU*COSU + COSV*COSV + COSW*COSW )
            COSU       = COSU / TRAN
            COSV       = COSV / TRAN
            COSW       = COSW / TRAN
CT          BUFFER(MDIM*0+K) = COSU
CT          BUFFER(MDIM*1+K) = COSV
CT          BUFFER(MDIM*2+K) = COSW
            COSUP      = SH(K1) * (-SINA )
            COSVP      = SH(K1) * (-COSA )
            COSWP      = BSIGN * DSQRT( 1.0D0 - SH(K1)*SH(K1) )
            TRAN       = DSQRT( COSUP*COSUP+COSVP*COSVP+COSWP*COSWP )
            COSUP      = COSUP / TRAN
            COSVP      = COSVP / TRAN
            COSWP      = COSWP / TRAN
C
            DO 2020 M0 = 1 , NM(N)
               M       = KORM(N,M0)
               IF( ICORE.EQ.1 .AND. M.EQ.1 ) THEN
                  COSU3  = COSU
                  COSV3  = COSV
                  COSW3  = COSW
                  COSU3P = COSUP
                  COSV3P = COSVP
                  COSW3P = COSWP
               END IF
               IF( IFILE.GT.0 )
     >         WRITE(IFILE,1080) M + 2 , COSU , COSV , COSW
     >                                 , COSUP, COSVP, COSWP
 2020       CONTINUE
C
 2010   CONTINUE
C
 2000 CONTINUE
CT    IF(.TRUE.) THEN
CT      CALL PRNTXY(BUFFER(MDIM*0+1),'COSU')
CT      CALL PRNTXY(BUFFER(MDIM*1+1),'COSV')
CT      CALL PRNTXY(BUFFER(MDIM*2+1),'COSW')
CT      STOP
CT    ENDIF
C
      IF( ICORE.EQ.1 .AND. IFILE.GT.0 )
     >    WRITE(IFILE,1080) NPOLYM+1 , COSU3 , COSV3 , COSW3
     >                               , COSU3P, COSV3P, COSW3P
C
      IF( IFILE.GT.0 ) WRITE(IFILE,1060) -1
C
C#######################################################################
C############################# ION TYPE ################################
C#######################################################################
C
      IF( IFILE.GT.0 ) WRITE(IFILE,1085) IOPTRC
      DO IH=1,NIONH
C..GC   IF(                            HMASS(IH).LT.1.1D+00    ) ION = 1
C..GC   IF( HMASS(IH).GT.1.9D+00 .AND. HMASS(IH).LT.2.0001D+00 ) ION = 2
C..GC   IF( HMASS(IH).GT.2.4D+00 .AND. HMASS(IH).LT.2.6D+00    ) ION = 3
C..GC   IF( HMASS(IH).GT.2.0001D+00 .AND. HMASS(IH).LT.2.1D+00 ) ION = 4
        IF(                            HMASS(IH).LT.1.1D+00    ) ION = 1
        IF( HMASS(IH).GT.1.9D+00 .AND. HMASS(IH).LT.2.1D+00    ) ION = 2
        IF( HMASS(IH).GT.2.4D+00 .AND. HMASS(IH).LT.2.6D+00    ) ION = 3
        IF( HMASS(IH).GT.2.6D+00                               ) ION = 4
C
        IF( IFILE.GT.0 ) WRITE(IFILE,1090) SYMION(ION) ,PERC(IH),
     &                   (RECMAT(J,IH),J=1,NIONH)
      ENDDO
C
C#######################################################################
C#################### PHYSICAL DESCRIPTION OF REGIONS ##################
C#######################################################################
C
      DO L         = 1 , NVESM
         M         = IVESM(L,1)
         FLHCHM(M) = FLUXHW(L,4)
CW       WRITE(LOUT,*) ' L,M+2,FLHCHM=',L,M+2,FLHCHM(M)
      ENDDO
C
      CALL WRPHYR( IFILE     , LOUT       , NPOLY        , LPMPST
     &           , IALB      , IAEMIS     , ICORE        , ICHARG
     &           , IOPTRC
     &           , MP        , MPG        , MR           , MLK
     &           , MBUFX
     &           , MIONH     , NIONH      , MWREG        , MMPG
     &           , DENSE(1)  , DENSI(1,1) , TEMPE(1)     , TEMPI(1)
     &           , VPAR(1,1) , HMASS(1)   , TEVGAP
     &           , FLHCHM(1) , MTOREG(1)  , RMATW(1,1,1) , INUTPG(1)
     &           , IPSEMP(1) , PSEMP(1)   , PSEMG(1)
     &           , PSEMPO    , PSEMPI     , PSEMPT       , PSEMPX
     &           , PSEMPB(0)
     &           , ALBPG(1)  , ALBEPG(1)  , ALBATO
     &           , ALBPMP    , ALBLK(1)   )
C
C#######################################################################
C############# SKIP LEAK & TRIM SECTION OF MC FILE ? ###################
C#######################################################################
C
      IF( ISETUP.EQ.1 ) GOTO 2119
C
C#######################################################################
C###################### LEAK RECYCLING SEGMENTS ########################
C#######################################################################
C
      IF(IFILE.GT.0) THEN
        WRITE(IFILE,'(I6,''  NLEAK'')') NLRS
        IF( NLRS.GT.0 ) WRITE(IFILE,'(1P,4E12.4)')
     &                  ((RLRS(I,J),ZLRS(I,J),J=1,2),I=1,NLRS)
      ENDIF
C
C#######################################################################
C############################ TRIM FILES ###############################
C#######################################################################
C
      IF( ITRIM.NE.0 ) THEN
C
          CALL TRMCAT( INPUMP , MFTRIM
     &                        , FTRIM     , PROTRM(1) , TARTRM(1)
     &                        , TRMFIL(1) , STRING    , IER        )
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR(TRMCAT) : ' , STRING
              CALL EXITX(LOUT)
          END IF
C
          IF( IFILE.GT.0 ) THEN
              WRITE(IFILE,1132) MFTRIM
              DO 2115 I = 1 , MFTRIM
                 WRITE(IFILE,1134) PROTRM(I) , TARTRM(I) , TRMFIL(I)
 2115         CONTINUE
          END IF
C
      ELSE
C
          IF( IFILE.GT.0 ) WRITE(IFILE,1132) 0
C
      END IF
C
 2119 CONTINUE
C
C#######################################################################
C########################### ION DENSITY ###############################
C#######################################################################
C
      IF( IMPURE.NE.0 ) THEN
          IF( IFILE.GT.0 ) WRITE(IFILE,1110) 2 , 0.00D+00
          DO 2120 M = 1 , NPOLYK(1)-1
             IF( IDTAGM(M,1).EQ.0 ) THEN
                 N  = ITAGM(M,1)
                 K  = KORKG(N)
                 DO IH=1,NIONH
                   DI(IH) = DENSI(K,IH) * 1.00D-13
                 ENDDO
             ELSE
                 DO IH=1,NIONH
                   DI(IH) = 0.00D+00
                 ENDDO
             END IF
             IF( IFILE.GT.0 ) WRITE(IFILE,1110) M+2 ,(DI(IH),IH=1,NIONH)
 2120     CONTINUE
          IF( IFILE.GT.0 ) WRITE(IFILE,1110) -1
      END IF
C
C#######################################################################
C####################### RECYCLABLE IMPURITY ###########################
C#######################################################################
C
      IF(LIGHTW.LE.0) THEN
        IF( IFILE.GT.0 ) WRITE(IFILE,1135) 0,' NO ', 0.0, 0.0
      ELSE
        IZINDL    = 0
        DO 2130 IZ  = 1 , NDIM3
           IF( -IZE2D(LIGHTW).EQ.INDEX(IZ) ) IZINDL = IZ
 2130   CONTINUE
        IF( IFILE.GT.0 ) THEN
          IF(IZINDL.GT.0 ) THEN
             WRITE(IFILE,1135) 1,SYMBOL(IZINDL),RNLITE,EWLITE
          ELSE
             WRITE(IFILE,1135) 0,'   ?',RNLITE,EWLITE
          ENDIF
        ENDIF
      ENDIF
C
      IF( ISETUP.EQ.1 ) GOTO 2135
C
C#######################################################################
C####################### EROSION & THERMAL LOAD ########################
C#######################################################################
C
      IF( IFILE.GT.0 ) WRITE(IFILE,1140) 0
C
      IONTOW = 0
C
      IF( IFILE.GT.0 ) THEN
          IF( IFWALD.EQ.0 ) THEN
              WRITE(IFILE,1150) 0      , 0.0 , IONTOW
          ELSE
              WRITE(IFILE,1150) LIMSEG , 0.0 , IONTOW
          END IF
      END IF
C
 2135 CONTINUE
C
C#######################################################################
C################# SOURCE SEGMENTS AT DIVERTOR WALLS ###################
C#######################################################################
C
C.....................COLLECT ALL SOURCE SEGMENTS.......................
C (1) EXAMINE ALL PLASMA POLYGONS FOR THOESE LYING ON A DIVERTOR WALL.
C     (I.E IDTAGP(N) = 2)
C (2) FROM (1) SELECT THE NIMBUS POLYGON WHICH LIES OUTSIDE BUT TOUCHING
C     THE DIVERTOR WALL - SET NSEGX & ITAGSX(NSEGX,1) = M.
C     (I.E IDTAGM(M,1) = 0 - THERE MUST ONLY BE ONE OF THESE NIMBUS
C     POLYGONS IN A "BORDER" PLASMA POLYGON)
C (3) GET THE FIRST & LAST VERTICES OF THE NIMBUS POLYGON, IN (2), WHICH
C     TOUCH THE DIVERTOR WALL - SET ITAGSX(NSEGX,2) & ITAGSX(NSEGX,3).
C     (I.E IDTAGM(M,IVERT+1) = 2 - SHOULD BE ONLY TWO OF THESE IN A
C     "BORDER NIMBUS POLYGON)
C N.B AT THIS STAGE, THE EXACT ORDERING OF TWO VERTEX POINTS IS
C     UNIMPORTANT.
C.......................................................................
C
      NSEGX                  = 0
C(1)
      DO 4000 N              = 1 , NPOLYP
         IF( IDTAGP(N).NE.2 ) GOTO 4000
C(2)
         LTRAN               = .FALSE.
         DO 4010 J           = 1 , NM(N)
            M                = KORM(N,J)
            IF( IDTAGM(M,1).EQ.0 ) THEN
                LTRAN        = .TRUE.
                GOTO 4015
            END IF
 4010    CONTINUE
C(3)
 4015    IF( LTRAN ) THEN
             NSEGX           = NSEGX + 1
             ITAGSX(NSEGX,1) = M
             DO 4020 IVERT   = 1 , NVERTM(M)
                IF( IDTAGM(M,IVERT+1).EQ.2 ) THEN
                    IF( ITAGSX(NSEGX,2).EQ.0 ) THEN
                        ITAGSX(NSEGX,2) = IVERT
                    ELSE
                        ITAGSX(NSEGX,3) = IVERT
                    END IF
                END IF
 4020       CONTINUE
         END IF
C
 4000 CONTINUE
C
      DO 4022 I = 1 , NSEGX
         M      = ITAGSX(I,1)
         IV1    = ITAGSX(I,2)
         IV2    = ITAGSX(I,3)
 4022 CONTINUE
C
C.........................ASSEMBLE SOURCE SEGMENTS......................
C (1) IF THEIR ARE NO DIVERTOR WALL SOURCE SEGMENTS THEN THERE IS NO
C     NEED TO DO FURTHER WORK AND SO SKIP TO THE NEXT SECTION.
C (2) L = 1 ---- L.H.S OF THE PLAMSA (INNER DIVERTOR PLATE)
C           ---- EXTRA SEGMENTS WILL BE INSERTED BEFORE ISEG = 1
C     L = 2 ---- R.H.S OF THE PLAMSA (OUTER DIVERTOR PLATE)
C           ---- EXTRA SEGMENTS WILL BE INSERTED AFTER THE LAST SEGMENT
C                BEFORE THE 1ST PART OF THE PRIVATE REGION I.E ISEGK(3)
C (3) (A) THE SEGMENT UPON WHICH AN EXTRA SOURCE SEGMENTS WILL BE
C         ATTACHED IS DECLARED.
C                FOR L = 1 THIS IS POINT ISEG = IBASE = 1
C                FOR L = 2 THIS IS POINT ISEG = IBASE = ITAGK(3)
C     (B) AN ALLOWENCE IS MADE (IVC0.NE.0) FOR HAVING TO REVERSE
C         THE TWO POINTS OF THIS DECLARED SEGMENT TO GET A JOIN.  THIS
C         IS ONLY ALLOWED FOR THIS INITIALIZER ( LTRAN = .TRUE. ).
C (4) ALL EXTRA SOURCE SEGMENTS ARE INTEROGATED TO SEE IF ANY OF THEIR
C     TWO VERTICIES MATCH A 'IVA0' OF THE PREVIOUS SEGMENT STARTING
C     FROM THE INITIALLY DECLARED SEGMENT IN (3).  THE INITAL SEGMENT
C     IS THEN REPLACED WITH THIS ONE AND THIS SECTION IS REPEATED
C     AD INFINITUM UNTIL NO MORE SEGMENTS ARE FOUND WHICH CAN BE JOINED
C     ONTO THE CHAIN (SEE NOTE (C) BELOW)
C     (I.E (TAIL TO HEAD) TO (TAIL TO HEAD) TO ...)
C (5) WHEN A SEGMENT IN (4) IS FOUND THEN THE FOLLOWING IS SET :-
C           ITAGSX(ISEG,4) = 1 --- THIS SEGMENT HAS BEEN USED
C           L1(ISEG)       = NIMBUS POLYGON
C           L2(ISEG)       = "TAIL" VERTEX
C           L3(ISEG)       = "HEAD" VERTEX
C           ISEGX          = TOTAL NUMBER TO BE INSERTED.
C (6) THE GROUP OF EXTRA SEGMENTS (IF ANY) ARE INSERTED INTO ITAGS(,)
C     WHILE NSEG & ITAGK() ARE ADJUSTED ACCORDINGLY.  THE INSERTION IS
C     AS FOLLOWS :-
C     (A) MOVE EXISTING ITAGS(,) BY ISEGX FROM :-
C         IBASE + L -1 = 1                --- FOR L = 1
C                      = ITAGK(3) + 1     --- FOR L = 2
C     (B) NSEG     = NSEG + ISEGX
C         ISEGK(1) = ISEGK(1) + ISEGX     --- FOR L = 1 & ISEGK(1) <> 0
C         ISEGK(2) = ISEGK(2) + ISEGX     --- FOR L = 1 & ISEGK(2) <> 0
C         ISEGK(3) = ISEGK(3) + ISEGX     --- FOR L = 1 & ISEGK(3) <> 0
C         ISEGK(3) = ISEGK(3) + 1         --- FOR L = 2 & ISEGK(3) <> 0
C         ISEGK(4) = ISEGK(4) + ISEGX     --- FOR L = 1 & ISEGK(4) <> 0
C         ISEGK(4) = ISEGK(4) + ISEGX     --- FOR L = 2 & ISEGK(4) <> 0
C         ( JBASE  = STARTING INDEX  = 1  --- FOR L = 1
C                                    = 3  --- FOR L = 2 )
C     (C) INSERT THE EXTRA POINTS INTO ITAGS(,) FOR THE RANGE :-
C         ISEGX     , ... , 1             --- FOR L = 1
C         IBASE + 1 , ... , IBASE + ISEGX --- FOR L = 2
C         (I.E FOR L = 1 THE EXTRA SEGMENTS ARE IN REVERSE ORDER)
C
C
C N.B (A) THE BASIC PRINCIPAL FOR ASSEMBLING SOURCE SEGMENTS IS THAT
C         THEY ARE JOINED "TAIL TO HEAD TO TAIL TO ....".
C     (B) THE DIVERTOR WALL CAN OCCUR AT THE L.H.S AND/OR THE R.H.S OF
C         THE REGION.
C     (C) ILOOP = 1 :-      IVB0-------------IVA0
C                                                \ (IVA OR IVB)
C                  (IVA0 IS THE CONTROLLER)       \
C                                                  \
C                                                   \
C                                                    \
C                                                     \ (IVB OR IVA)
C         (1) DOES IVA0 TOUCH ANY VERTEX OF ANY OF THE EXTRA SEGMENTS
C             IF NOT THEN REVERSE IVA0 & IVB0
C         (2) IVA OF ONE OF THE EXTRA SEGMENTS TOUCH IVA0
C             THEN SET IVA0 = IVB & IVB0 = IVA AND GO ONTO ANOTHER
C             OF THE EXTRA SEGMENTS (ILOOP>1).
C         (3) IVB OF ONE OF THE EXTRA SEGMENTS TOUCH IVA0
C             THEN SET IVA0 = IVA & IVB0 = IVB AND GO ONTO ANOTHER
C             OF THE EXTRA SEGMENTS (ILOOP>1).
C.......................................................................
C
C(1)
      IF( NSEGX.EQ.0 ) GOTO 2200
C(2)
      DO 4030 L                  = 1 , 2
         IF( L.EQ.1 ) THEN
             IBASE               = 1
             JBASE               = 1
         ELSE
             IBASE               = ISEGK(3)
             JBASE               = 3
         END IF
C(3.A)
         M0                      = ITAGS(IBASE,1)
         IVA0                    = ITAGS(IBASE,2)
         IVB0                    = ITAGS(IBASE,3)
         IVC0                    = 0
C
         LTRAN                   = .TRUE.
         ISEGX                   = 0
         DO 4040 ILOOP           = 1 , NSEGX
C
 4050       IF( NVERTM(M0).LT.0 ) THEN
                ITYPG            = IABS( NVERTM(M0) )
                RVA0             = RVERTG(ITYPG,IVA0)
                ZVA0             = ZVERTG(ITYPG,IVA0)
            ELSE
                RVA0             = RVERTM(M0,IVA0)
                ZVA0             = ZVERTM(M0,IVA0)
            END IF
C(4)
            DO 4060 I            = 1 , NSEGX
               IF( ITAGSX(I,4).NE.0 ) GOTO 4060
C
               M                 = ITAGSX(I,1)
               IVA               = ITAGSX(I,2)
               IVB               = ITAGSX(I,3)
               IF( NVERTM(M).LT.0 ) THEN
                   ITYPG         = IABS( NVERTM(M) )
                   RVA           = RVERTG(ITYPG,IVA)
                   ZVA           = ZVERTG(ITYPG,IVA)
                   RVB           = RVERTG(ITYPG,IVB)
                   ZVB           = ZVERTG(ITYPG,IVB)
               ELSE
                   RVA           = RVERTM(M,IVA)
                   ZVA           = ZVERTM(M,IVA)
                   RVB           = RVERTM(M,IVB)
                   ZVB           = ZVERTM(M,IVB)
               END IF
C(5)&NOTE (C)
               IF( RVA.EQ.RVA0 .AND. ZVA.EQ.ZVA0 ) THEN
                   ISEGX         = ISEGX + 1
                   L1(ISEGX)     = M
                   IF( IVC0.EQ.0 ) THEN
                       L2(ISEGX) = IVB
                       L3(ISEGX) = IVA
                   ELSE
                       L2(ISEGX) = IVB
                       L3(ISEGX) = IVA
                   END IF
                   ITAGSX(I,4)   = 1
                   M0            = M
                   IVA0          = IVB
                   IVB0          = IVA
                   LTRAN         = .FALSE.
                   GOTO 4040
               END IF
               IF( RVB.EQ.RVA0 .AND. ZVB.EQ.ZVA0 ) THEN
                   ISEGX         = ISEGX + 1
                   L1(ISEGX)     = M
                   IF( IVC0.EQ.0 ) THEN
                       L2(ISEGX) = IVA
                       L3(ISEGX) = IVB
                   ELSE
                       L2(ISEGX) = IVB
                       L3(ISEGX) = IVA
                   END IF
                   ITAGSX(I,4)   = 1
                   M0            = M
                   IVA0          = IVA
                   IVB0          = IVB
                   LTRAN         = .FALSE.
                   GOTO 4040
               END IF
C
 4060       CONTINUE
C(3.B)
            IF( LTRAN ) THEN
                IVC0             = IVA0
                IVA0             = IVB0
                IVB0             = IVC0
                LTRAN            = .FALSE.
                GOTO 4050
            ELSE
                IVC0             = 0
            END IF
C
 4040    CONTINUE
C(3.B)
         IF( IVC0.NE.0 ) THEN
             IVC0                = ITAGS(IBASE,2)
             ITAGS(IBASE,2)      = ITAGS(IBASE,3)
             ITAGS(IBASE,3)      = IVC0
         END IF
C(6)
         IF( ISEGX.GT.0 ) THEN
C(6.A)
             DO 4070 ISEG        = NSEG , IBASE + L - 1 , -1
                I1               = ISEG + ISEGX
                DO 4075 I        = 1    , 4
                   ITAGS(I1,I)   = ITAGS(ISEG,I)
 4075           CONTINUE
 4070        CONTINUE
C(6.B)
             NSEG                = NSEG     + ISEGX
             ISEGK(7)            = ISEGK(7) + ISEGX
             DO 4080 I           = JBASE , 4
                IF( ISEGK(I).GT.0 ) ISEGK(I) = ISEGK(I) + ISEGX
 4080        CONTINUE
C(6.C)
             IF( L.EQ.1 ) THEN
                 ISEG0           = ISEGX
                 ISEG1           = 1
                 ISEGK(5)        = ISEGX
             ELSE
                 ISEG0           = 1
                 ISEG1           = ISEGX
                 ISEGK(6)        = ISEGK(3) - ISEGX + 1
                 IF( ISEGK(6).LT.0 ) ISEGK(6) = 0
             END IF
             IF( ISEG0.LE.ISEG1 ) THEN
                 ISEG2           = 1
             ELSE
                 ISEG2           = -1
             END IF
C
             ISEG                = IBASE + L - 2
             DO 4090 I           = ISEG0 , ISEG1 , ISEG2
                ISEG             = ISEG + 1
                ITAGS(ISEG,1)    = L1(I)
                ITAGS(ISEG,2)    = L2(I)
                ITAGS(ISEG,3)    = L3(I)
                ITAGS(ISEG,4)    = 2
 4090        CONTINUE
C
         END IF
C
 4030 CONTINUE
C
C#######################################################################
C######################### SOURCE OF NEUTRALS ##########################
C#######################################################################
C
 2200 IF( IRECO.EQ.1 ) THEN
          IF(IFILE.GT.0) WRITE(IFILE,1160) 0.00D+00 , 0.00D+00 , 0 , 1
     &                                   , ANGNOR
          GOTO 2300
      END IF
C
      WTOT           = RGAMMA
      IF( WTOT.EQ.0.00D+00 ) WTOT = 1.00D+00
C
      IF( IFILE.GT.0 ) THEN
          WRITE(IFILE,1160) WTOT , 1.00D+00 , 0  , IRECO , ANGNOR
          IF(IFPRIM.EQ.0 .OR. ICODE.NE.2) THEN
            WRITE(IFILE,1161) 1, 0 , SYMBOL(0) , 0.0D0
            IF(NIONH.GT.1) THEN
              WRITE(IFILE,1176) (PERC(IH),IH=1,NIONH)
            ENDIF
          ELSE
            IF(MODEZR.NE.1) THEN
              WRITE(LOUT,*) ' *** LINKPG ERROR *** MODEZR <>1'
              CALL EXITX(LOUT)
            ENDIF
            WRITE(IFILE,1161) 1, NZE2D, SZE2D(1) , ZGAMMA(1)
            IF(NIONH.GT.1) THEN
              WRITE(IFILE,1176) (PERC(IH),IH=1,NIONH)
            ENDIF
            IF(NZE2D.GT.1) THEN
              WRITE(IFILE,'(12X,2X,A4,1P,E12.4)')
     &       (SZE2D(KZ),ZGAMMA(KZ),KZ=2,NZE2D)
            ENDIF
          ENDIF
          WRITE(IFILE,1060) NSEG
      END IF
C
C---------------------WEIGHTING FACTOR FOR SEGMENTS---------------------
C
C.......................................................................
C
C PERPENDICULAR SOURCES : USE SIMPLE DISTANCE BETWEEN THE TWO VERTICES
C                         AS BOTH LIE ON THE SAME RING
C
C POLOIDAL      SOURCES :
C
C      (A) AT A LIMITER : USE POLOIDAL DISTANCE BETWEEN THE TWO RINGS
C          =============  THAT THE VERTICES LIES ON :-
C                         (1) IVERT1 LIES ON RING I1
C                             IVERT2 LIES ON RING I2
C                         (2) A THIRD VERTEX OF NIMBUS POLYGON # M IS
C                             CHOSEN SUCH THAT IT LIES ON THE RING
C                             OF ONE OF THE SEGMENT VERTICES ( THE
C                             UPPER VERTEX IF POSSIBLE).
C                         (3) CALCULATE THE INTERSECTION POINT OF THE
C                             LINES (A) JOINING THE TWO POINTS ON THE
C                                       SAME RING
C                             AND   (B) THE NORMAL OF (A) WHICH PASSES
C                                       THROUGH THE VERTEX WHICH LIES
C                                       ON THE OTHER RING
C                         (4) THE DISTANCE OF THIS INTERSECTION POINT
C                             TO THE POINT ON LINE (B) IS ASSUMED TO BE
C                             THE POLOIDAL DISTANCE OF THE TWO RINGS.
C
C      (B) AT PRIV. REG.: USE SIMPLE DISTANCE BETWEEN THE TWO
C          =============  SEGMENTS VERTICES.
C
C      (C) DIV. WALLS   : AVG THE DISTANCE BETWEEN VERTICES (1) & (2)
C          =============  AND THE DISTANCE BETWEEN VERTICES (3) & (4)
C                         OF THE PLASMA POLYGON CONTAINING THE SOURCE
C                         SEGMENT.  THE MULTIPLY BY (RHOIN()-RHOOUT())
C.......................................................................
C
      IF( ISEGK(3).EQ.0 ) ISEGK(3) = NSEG + 1
C
      CALL RESETR( PDIST(1) , MP , -1.00D+00 )
C
      SUMPAR         = 0.00D+00
      SUMPER         = 0.00D+00
      LTRAN          = .TRUE.
C
C
      DO 2210 ISEG   = 1 , NSEG
C
         M           = ITAGS(ISEG,1)
         IVERT1      = ITAGS(ISEG,2)
         IVERT2      = ITAGS(ISEG,3)
C
C........NOTE. THE PRIVATE REGION SOURCE SEGMENTS ARE HANDLED
C........====  DIFFERENTLY FROM OTHER SOURCE SEGMENT.  THIS IS DUE
C........      TO THE PRIVATE REGION ITAGS(ISEG,1) = NIMBUS POLYGON
C........      WHICH CREATED THAT SEGMENT, NOT THE NIMBUS POLYGON OF
C........      THE SOURCE SEGMENT (I.E THE PRIVATE REGION) ITSELF.
C........                                                     (13/01/94)
C
         IF( NVERTM(M).LT.0 ) THEN
             ITYPG   = IABS( NVERTM(M) )
             IVERTM  = NVERTG(ITYPG)
         ELSE
             ITYPG   = 0
             IVERTM  = NVERTM(M)
         END IF
C
         N           = ITAGM(M,1)
         K           = KORKG(N)
         R           = RMESH(K)
C
         IF( ICODE.EQ.1 ) THEN
C.. EDGE1D
             TWOPIR  = 2.0D0 * PI * R
         ELSE
C.. PIN
             TWOPIR  = 1.0D0
         END IF
C.. EDGE2D NEVER USES TWOPIR
C
         IF( ITAGS(ISEG,4).GE.1 .OR.
     &     ( ISEG.GT.ISEGK(3) .AND. ISEG.LE.ISEGK(7) ) ) THEN
C.........................POLOIDAL SEGMENT..............................
             IF( ISEG.LE.ISEGK(3) ) THEN
C A(1)
                 I1             = ITAGM (M,IVERT1+2)
                 I2             = ITAGM (M,IVERT2+2)
C A(2)
                 IA1            = 0
                 DO 2015 IVERT  = 1 , IVERTM
                    IF( IVERT.NE.IVERT1 .AND. IVERT.NE.IVERT2 ) THEN
                        IF( ITAGM(M,IVERT+2).EQ.I1 ) THEN
                            IF( IA1.EQ.0 .OR. I1.GT.I2 ) THEN
                                IA1 = IVERT1
                                IA2 = IVERT
                                IB  = IVERT2
                            END IF
                        ELSE
                            IF( IA1.EQ.0 .OR. I1.LT.I2 ) THEN
                                IA1 = IVERT2
                                IA2 = IVERT
                                IB  = IVERT1
                            END IF
                        END IF
                    END IF
 2015           CONTINUE
C A(3) & A(4)
                IF( ITYPG.EQ.0 ) THEN
                  A          = ZVERTM(M,IA2) - ZVERTM(M,IA1)
                  B          = RVERTM(M,IA1) - RVERTM(M,IA2)
                  C1         = RVERTM(M,IA2) * ZVERTM(M,IA1)
                  C2         = RVERTM(M,IA1) * ZVERTM(M,IA2)
                  DIST(ISEG) = DABS( A*RVERTM(M,IB)
     &                             + B*ZVERTM(M,IB) + C1 - C2 )
     &                         / DSQRT( A*A + B*B )
                ELSE
                  A          = ZVERTG(ITYPG,IA2) - ZVERTG(ITYPG,IA1)
                  B          = RVERTG(ITYPG,IA1) - RVERTG(ITYPG,IA2)
                  C1         = RVERTG(ITYPG,IA2) * ZVERTG(ITYPG,IA1)
                  C2         = RVERTG(ITYPG,IA1) * ZVERTG(ITYPG,IA2)
                  DIST(ISEG) = DABS( A*RVERTG(ITYPG,IB)
     &                             + B*ZVERTG(ITYPG,IB) + C1 - C2 )
     &                         / DSQRT( A*A + B*B )
                END IF
             ELSE
C B
                IF( ITYPG.EQ.0 ) THEN
                  RDIFF      = RVERTM(M,IVERT1) - RVERTM(M,IVERT2)
                  ZDIFF      = ZVERTM(M,IVERT1) - ZVERTM(M,IVERT2)
                  DIST(ISEG) = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
                ELSE
                  RDIFF  = RVERTG(ITYPG,IVERT1)-RVERTG(ITYPG,IVERT2)
                  ZDIFF  = ZVERTG(ITYPG,IVERT1)-ZVERTG(ITYPG,IVERT2)
                  DIST(ISEG) = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
                END IF
             END IF
             IF( ITAGS(ISEG,4).NE.1 ) ITAGS(ISEG,1) = 1
C.......................................................................
             PDIST(K)         = DIST(ISEG)
             IF( ICODE.EQ.2 ) THEN
                 DO IH=1,NIONH
                   FHMC(IH) = FIPAR(K,IH)
                 ENDDO
                 IF(IFPRIM.NE.0) THEN
                   DO KZ=1,NZE2D
                     IF(FIPARZ(K,KZ).GT.0.0D0) THEN
                       FZMC(KZ) = FIPARZ(K,KZ)
                       IF( ZZ(K,KZ).GT.0.0D+00 ) THEN
                           ZZMC(KZ) = ZZ(K,KZ)
                       ELSE
                           FZMC(KZ) = 0.0D0
                           ZZMC(KZ) = 0.0D0
                           WRITE(LOUT,9160) K , KZ , ZZ(K,KZ)
                       END IF
                     ELSE
                       FZMC(KZ) = 0.0D0
                       ZZMC(KZ) = 0.0D0
                     ENDIF
                   ENDDO
CW                 WRITE(LOUT,*) ' PARALL ISEG=',ISEG,
CW                                 FIPAR(K,1),FIPARZ(K,1),ZZ(K,1)
                 ELSE
                   FZMC(1) = 0.0
                   ZZMC(1) = 0.0
                 ENDIF
             ELSE
                 DO IH=1,NIONH
                   FHMC(IH) = FIPAR(K,IH) * DIST(ISEG) * TWOPIR
                 ENDDO
                 FZMC(1) = 0.0
                 ZZMC(1) = 0.0
             END IF
             DO IH=1,NIONH
               PUFR(IH) = FRAPUF(K,2,IH)
               SUMPAR   = SUMPAR   + FHMC(IH)
             ENDDO
             DO KZ  = 1 , NZE2D
               PUFRZ(KZ) = FRAPUZ(K,2,KZ)
             ENDDO
CW           WRITE(LOUT,*) ' LINKPG PUFF2',ISEG,PUFR(1),PUFRZ(1)
         ELSE
C.........................PERPENDICULAR SEGMENT.........................
             IF( ITYPG.EQ.0 .OR. ITYPG.EQ.4 ) THEN
               RDIFF      = RVERTM(M,IVERT1) - RVERTM(M,IVERT2)
               ZDIFF      = ZVERTM(M,IVERT1) - ZVERTM(M,IVERT2)
               DIST(ISEG) = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
             ELSE
               RDIFF      = RVERTG(ITYPG,IVERT1) - RVERTG(ITYPG,IVERT2)
               ZDIFF      = ZVERTG(ITYPG,IVERT1) - ZVERTG(ITYPG,IVERT2)
               DIST(ISEG) = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
             END IF
C.......................................................................
             IF( PDIST(K).LT.0.00D+00 ) PDIST(K) = DIST(ISEG)
             IF( ICODE.EQ.2 ) THEN
                 DO IH=1,NIONH
                   FHMC(IH) = FIPER(K,IH)
                 ENDDO
                 IF(IFPRIM.NE.0) THEN
                   DO KZ=1,NZE2D
                     IF(FIPERZ(K,KZ).GT.0.0D0) THEN
                       FZMC(KZ) = FIPERZ(K,KZ)
                       IF( ZZ(K,KZ).GT.0.0D+00 ) THEN
                           ZZMC(KZ) = ZZ(K,KZ)
                       ELSE
                           FZMC(KZ) = 0.0D0
                           ZZMC(KZ) = 0.0D0
                           WRITE(LOUT,9160) K , KZ , ZZ(K,KZ)
                       END IF
                     ELSE
                       FZMC(KZ) = 0.0D0
                       ZZMC(KZ) = 0.0D0
                     ENDIF
                   ENDDO
CW                 WRITE(LOUT,*) ' PERPEN ISEG=',ISEG,
CW                                 FIPER(K,1),FIPERZ(K,1),ZZ(K,1)
                 ELSE
                   FZMC(1) = 0.0
                   ZZMC(1) = 0.0
                 ENDIF
             ELSE
                 DO IH=1,NIONH
                   FHMC(IH) = FIPER(K,IH) * DIST(ISEG) * TWOPIR
                 ENDDO
                 FZMC(1) = 0.0
                 ZZMC(1) = 0.0
             END IF
             DO IH=1,NIONH
               PUFR(IH) = FRAPUF(K,1,IH)
               SUMPER   = SUMPER + FHMC(IH)
             ENDDO
             DO KZ = 1 , NZE2D
               PUFRZ(KZ) = FRAPUZ(K,1,KZ)
             ENDDO
CW           WRITE(LOUT,*) ' LINKPG PUFF1',ISEG,PUFR(1),PUFRZ(1)
         END IF
C
C----------------------COMMON TO PERPENDICULAR AND POLOIDAL SEGMENTS --
         IF( ITAGS(ISEG,4).NE.0 .AND. ITAGS(ISEG,4).NE.1 ) THEN
          WRITE(LOUT,*) ' *** LINKPG ERROR *** ITAGS(4) <> 0,1',ISEG
          CALL EXITX(LOUT)
         ENDIF
C
         TE   = TEMPE(K)
         TSOU = TE
C
         BUFFER(ISEG) = FHMC(1)
         BUFFER(MDIM+ISEG) = FHMC(1)
C
         IF( IFILE.GT.0 ) THEN
C
             IF( ITYPG.EQ.0 .OR. ITYPG.EQ.4 ) THEN
              WRITE(IFILE,1170)RVERTM(M,IVERT1),ZVERTM(M,IVERT1)
     &                        ,RVERTM(M,IVERT2),ZVERTM(M,IVERT2)
             ELSE
              WRITE(IFILE,1170)RVERTG(ITYPG,IVERT1),ZVERTG(ITYPG,IVERT1)
     &                        ,RVERTG(ITYPG,IVERT2),ZVERTG(ITYPG,IVERT2)
             END IF
             WRITE(IFILE,1175) FHMC(1) , TSOU , PUFR(1) , 0.0
     &                       , FZMC(1) , ZZMC(1) , PUFRZ(1)
             IF(NIONH.GT.1) THEN
               WRITE(IFILE,1176) (FHMC(IH),PUFR(IH), IH=2,NIONH)
             ENDIF
             IF(NZE2D.GT.1) THEN
               WRITE(IFILE,1176)
     &              (FZMC(KZ) , ZZMC(KZ) , PUFRZ(KZ) , KZ=2,NZE2D)
             ENDIF
         END IF
C
 2210 CONTINUE
C
      LTRAN = .TRUE.
      IF( IFILE.GT.0 ) THEN
         IF( SUMPAR+SUMPER.LE.0.00D+00 ) THEN
             IF( LTRAN )
     &           WRITE(LOUT,*) ' *** LINKPG ERROR *** H-ION FLUX <=0'
             LTRAN = .FALSE.
             IF( .NOT.LTEST ) CALL EXITX(LOUT)
         END IF
      END IF
C
C-----------------------OUTPUT SEGMENT INFORMATION----------------------
C
C
      IF( LCHECK .AND. IFILE.GT.0 .AND. LPOUT ) WRITE(IPRINT,1430)
C
      DO 2220 ISEG   = 1 , NSEG
         M           = ITAGS(ISEG,1)
         IVERT1      = ITAGS(ISEG,2)
         IVERT2      = ITAGS(ISEG,3)
         N           = ITAGM(M,1)
         K           = KORKG(N)
C
         FLUX=BUFFER(MDIM+ISEG)
         IF( LCHECK .AND. IFILE.GT.0 .AND. LPOUT )
     >       WRITE(IPRINT,1440)
     &                      ISEG             , STYPE(ITAGS(ISEG,4)+1)
     &                    , FLUX             , DIST(ISEG)
     &                    , BUFFER(ISEG)     , WEIGHT
     &                    , RMESH(K)         , VPAR(K,IU)
     &                    , DENSI(K,IU)      , DENSE(K)
     &                    , TEMPI(K)         , TEMPE(K)
 2220 CONTINUE
C
      IF( IPRINT.GT.0 .AND. IFILE.GT.0 )
     >    WRITE(IPRINT,1210)SUMPAR , SUMPER , SUMPAR+SUMPER
C
      IF( RGAMMA.LT.0.00D+00 .AND. IFILE.GT.0 )
     >    WRITE(IFILE,1160) SUMPAR + SUMPER
C
      IF( ISETUP.EQ.1 ) GOTO 2395
C
C#######################################################################
C######################### SPLITTING FACTORS ###########################
C#######################################################################
C
 2300 CALL RESETR( BUFFER(1) , MDIM , 0.00D+00 )
C
      IF( ISPLIT.NE.0 .AND. IFCHAN.NE.0 ) THEN
          DO 2310 I          = 1 , NCHAN
             DO 2320 J       = 1 , MCHAN(I)
                IREG         = JCHAN(I,J) + 2
                BUFFER(IREG) = WSPLIT(I)
 2320        CONTINUE
 2310     CONTINUE
          IF( IFILE.GT.0 )
     &        WRITE(IFILE,1180) ( BUFFER(K) , K=1,NIMREG(1))
      END IF
C
C#######################################################################
C######################### WALL & GAP REGIONS ##########################
C#######################################################################
C
      IF( NXPG.EQ.0 ) THEN
          NMAX = NPOLYK(2)
      ELSE
          IF( IALB.NE.1 ) THEN
              NMAX = NPOLYK(2) - MEXTRA
          ELSE
              NMAX = NPOLYK(2)
          END IF
      END IF
C
      NWALL                 = 0
      NGAP                  = 0
      NALBDO                = 0
      DO 2330 I             = NPOLYK(1) + 1 , NMAX
         IF( ITAGES(I).EQ.1 ) THEN
             NGAP           = NGAP + 1
             IGAP(NGAP)     = I + 2
         ELSE IF( ITAGES(I).GE.3 ) THEN
             NALBDO         = NALBDO + 1
             IALBDO(NALBDO) = I + 2
         ELSE
             NWALL          = NWALL + 1
             IWALL(NWALL)   = I + 2
         END IF
 2330 CONTINUE
C
      IF( LPMPST ) THEN
          DO 2340 M             = NIMREG(2)+1 , NIMREG(1)
             IF( COMM(M).EQ.'P' .OR.
     &         ( COMM(M).GE.'1' .AND. COMM(M).LE.'9' ) ) THEN
                 NALBDO         = NALBDO + 1
                 IALBDO(NALBDO) = M
             END IF
 2340     CONTINUE
      END IF
C
C#######################################################################
C###################### VESSEL WALL SEGMENT LENGTHS ####################
C#######################################################################
C
      NWSEG             = 0
      WSDIST(0)         = 0.00D+00
C
C.(01).....1ST LOOP OVER ALL ESCAPE FIGURES EXCEPT CORE & BAFFLE........
      DO 2350 M         = NPOLYK(1) + 1 , NPOLYK(2)
C
C.(02)..........PROCESS ONLY WALL OR ALBEDO NIMBUS POLYGONS ............
         IF( ITAGES(M).LT.0 .OR. ITAGES(M).GE.2 ) THEN
C
C.(03)..........IS POLYGON A MULTI-VERTEX SPECIAL REGION ?..............
C         (PRIVATE REGION IS TREATED LIKE ANYOTHER SPECIAL POLYGON)
             IF( NVERTM(M).GT.0 ) THEN
                 ITYPG1 = 0
                 MV1    = NVERTM(M)
             ELSE
                 ITYPG1 = IABS( NVERTM(M) )
                 MV1    = NVERTG(ITYPG1)
             END IF
C
C
C.(04)...................TEST WITH OTHER POLYGONS.......................
             DO 2360 M0                 = 1 , NPOLYK(2)
                NGEN2                   = 0
C
C.(05)............TEST POLYGONS MUST BE VOID OR PLASMA .................
                IF( M0.EQ.M .OR.
     >            ( ITAGES(M0).NE.0 .AND. ITAGES(M0).NE.1 ) ) GOTO 2360
C
C.(06)............IS THE TEST POLYGON A SPECIAL REGION ?................
C         (PRIVATE REGION IS TREATED LIKE ANYOTHER SPECIAL POLYGON)
                IF( NVERTM(M0).GT.0 ) THEN
                    ITYPG2              = 0
                    MV2                 = NVERTM(M0)
                ELSE
                    ITYPG2              = IABS( NVERTM(M0) )
                    MV2                 = NVERTG(ITYPG2)
                END IF
C
C.(07)............LOOP OVER EACH VERTEX OF TEST POLYGON.................
                DO 2370 IV2             = 1 , MV2
C
C.(08).........DOES THE VERTEX BELONG TO A SPECIAL REGION ?.............
                   IF( ITYPG2.EQ.0 ) THEN
                       RGEN1(2)         = RVERTM(M0,IV2)
                       ZGEN1(2)         = ZVERTM(M0,IV2)
                   ELSE
                       RGEN1(2)         = RVERTG(ITYPG2,IV2)
                       ZGEN1(2)         = ZVERTG(ITYPG2,IV2)
                   END IF
C
C.(09).......COMPARE TEST VERTEX WITH VERTICES OF POLYGON M.............
                   DO 2380 IV1          = 1 , MV1
C
C.(10).........DOES THE VERTEX BELONG TO A SPECIAL REGION ?.............
                      IF( ITYPG1.EQ.0 ) THEN
                          RGEN1(1)      = RVERTM(M,IV1)
                          ZGEN1(1)      = ZVERTM(M,IV1)
                      ELSE
                          RGEN1(1)      = RVERTG(ITYPG1,IV1)
                          ZGEN1(1)      = ZVERTG(ITYPG1,IV1)
                      END IF
C
C.(11)..........IF VERTICES MATCH THEN WALL SEGMENT POINT...............
                      IF( RGEN1(1).EQ.RGEN1(2) .AND.
     >                    ZGEN1(1).EQ.ZGEN1(2)       ) THEN
                          NGEN2         = NGEN2 + 1
                          RGEN2(NGEN2)  = RGEN1(1)
                          ZGEN2(NGEN2)  = ZGEN1(1)
                          GOTO 2370
                      END IF
C
 2380              CONTINUE
C
 2370           CONTINUE
C
C..(12)...IF ONLY ONE SEGMENT POINT FOUND TRY ANOTHER TEST POLYGON......
                IF( NGEN2.GT.1 ) GOTO 2385
C
 2360        CONTINUE
C
C..(13).....................ASSEMBLE WALL SEGMENT ......................
 2385        IF( NGEN2.EQ.2 ) THEN
                 NWSEG             = NWSEG + 1
                 NWSPG(NWSEG)      = M
                 WSDIST(NWSEG)     = PYTHGS( RGEN2(1) , ZGEN2(1)
     &                                     , RGEN2(2) , ZGEN2(2) )
                 WSDIST(0)         = WSDIST(0) + WSDIST(NWSEG)
C
C..(14).............REVERSE COORD. ORDER OF CERTAIN SEGMENTS............
C           (MAINTAIN CONSISTANT DIRECTION AS WITH SOURCE SEGMENTS)
                 IF( ( M.GE.NPOLYK(5) .AND. M.LT.NPOLYK(6) ) .OR.
     &                 M.EQ.NPOLYC(2) .OR.  M.EQ.NPOLYK(7)        ) THEN
                      RWSEG(NWSEG,1)    = RGEN2(2)
                      ZWSEG(NWSEG,1)    = ZGEN2(2)
                      RWSEG(NWSEG,2)    = RGEN2(1)
                      ZWSEG(NWSEG,2)    = ZGEN2(1)
                 ELSE
                      RWSEG(NWSEG,1)    = RGEN2(1)
                      ZWSEG(NWSEG,1)    = ZGEN2(1)
                      RWSEG(NWSEG,2)    = RGEN2(2)
                      ZWSEG(NWSEG,2)    = ZGEN2(2)
                 END IF
                 IF( M.GE.NPOLYK(5).AND.M.LT.NPOLYK(6)      ) THEN
                     IF( IWSEGK(1).EQ.0 ) IWSEGK(1) = NWSEG
                     IWSEGK(2)          = NWSEG
                 ELSE IF( M.GE.NPOLYK(6).AND.M.LT.NPOLYC(1) ) THEN
                     IF( IWSEGK(3).EQ.0 ) IWSEGK(3) = NWSEG
                     IWSEGK(4)          = NWSEG
                 ELSE IF( M.GE.NPOLYC(1).AND.M.LE.NPOLYC(2) ) THEN
                     IF( IWSEGK(5).EQ.0 ) IWSEGK(5) = NWSEG
                     IWSEGK(6)          = NWSEG
                 ELSE IF( M.GE.NPOLYK(7).AND.M.LT.NPOLYK(7)+NPOLYK(8) )
     &                                                        THEN
                     IF( IWSEGK(7).EQ.0 ) IWSEGK(7) = NWSEG
                     IWSEGK(8)          = NWSEG
                 END IF
             ELSE IF( NGEN2.GT.2 ) THEN
                 WRITE(LOUT,9050) M , NSEG2
                 CALL EXITX(LOUT)
             END IF
C
         END IF
C
 2350 CONTINUE
C
C..(15)......LPWALL=T : REVERSE ORDER OF PRIVATE REGION SEGMENTS........
C          (TO MAINTAIN CONSISTANCY WITH ORDER OF OTHER SEGMENTS)
      IF( NPOLYK(8).GT.1 ) THEN
C
          L               = IWSEGK(8) - IWSEGK(7) + 1
          DO 2390 I       = 1 , L/2
C
             IV1          = IWSEGK(7) + I - 1
             IV2          = IWSEGK(8) - I + 1
C
             M            = NWSPG(IV1)
             RGEN1(1)     = RWSEG(IV1,1)
             RGEN1(2)     = RWSEG(IV1,2)
             ZGEN1(1)     = ZWSEG(IV1,1)
             ZGEN1(2)     = ZWSEG(IV1,2)
             RGEN2(1)     = WSDIST(IV1)
C
             NWSPG(IV1)   = NWSPG(IV2)
             NWSPG(IV2)   = M
C
             RWSEG(IV1,1) = RWSEG(IV2,1)
             RWSEG(IV2,1) = RGEN1(1)
C
             RWSEG(IV1,2) = RWSEG(IV2,2)
             RWSEG(IV2,2) = RGEN1(2)
C
             ZWSEG(IV1,1) = ZWSEG(IV2,1)
             ZWSEG(IV2,1) = ZGEN1(1)
C
             ZWSEG(IV1,2) = ZWSEG(IV2,2)
             ZWSEG(IV2,2) = ZGEN1(2)
C
             WSDIST(IV1)  = WSDIST(IV2)
             WSDIST(IV2)  = RGEN2(1)
C
 2390     CONTINUE
C
      END IF
C
 2395 CONTINUE
C
C#######################################################################
C############################## COMMENTS ###############################
C#######################################################################
C
      IF( IFILE.GT.0 ) THEN
C
C.......................................................................
C
      IF( NXPG.EQ.0) THEN
          WRITE(IFILE,1200) ' LIMITER PROBLEM'
      ELSE
          WRITE(IFILE,1200) ' X-POINT PROBLEM'
      END IF
C
      WRITE(IFILE,1210) SUMPAR , SUMPER , SUMPAR + SUMPER
C
      IF( ICORE.EQ.1 ) THEN
          WRITE(IFILE,1200) ' CORE PLASMA IS (PLASMA) REGION ' ,
     &                       NPOLYK(1) + 2
      ELSE
          WRITE(IFILE,1200) ' CORE PLASMA IS (ESCAPE) REGION ' ,
     &                       NPOLYK(1) + 2
      END IF
C
      WRITE(IFILE,1200) ' PLASMA REGIONS FROM ' , 3 , ' TO ' , NPOLYM+2
C
      IF( IFCHAN.NE.0 ) THEN
C
      WRITE(IFILE,1200) ' THERE ARE ' , NCHAN , ' CHANNELS'
      WRITE(IFILE,1200) ' NIMBUS CLOSED CHANNELS FROM ' , 1 ,
     &                  ' TO ' , LCFSPG
      IF( NXPG.NE.0 ) WRITE(IFILE,1200) ' LAST NIMBUS "CLOSED" CHANNEL
     & INCL. THE LOWER SEPARATRIX'
C
          DO 2400 I = 1 , NCHAN
             IF( NXPG.NE.0 ) THEN
                 IF( I.EQ.LCFSPG+1 )
     &               WRITE(IFILE,1200) ' OPEN LONG CHANNELS FROM '
     &                               , I , ' TO ' , NXWPG - 1
                 IF( I.EQ.NXWPG )
     &               WRITE(IFILE,1200) ' OPEN SHORT CHANNELS FROM '
     &                               , I , ' TO ' , NCPG - 1
             END IF
             WRITE(IFILE,1200) ' CHANNEL ' , I , ' FROM REGION ' ,
     &                         JCHAN(I,1)+2,' TO ' ,JCHAN(I,MCHAN(I))+2
 2400     CONTINUE
C
      END IF
C
      WRITE(IFILE,1220) ' WALL REGIONS :-'
      WRITE(IFILE,1245) ( IWALL(I) , I = 1 , NWALL )
C
      IF( NGAP.GT.0 ) THEN
          WRITE(IFILE,1220) ' GAP REGIONS :-'
          WRITE(IFILE,1245) ( IGAP(I) , I = 1 , NGAP )
      END IF
C
      IF( NALBDO.GT.0 ) THEN
          IF( LPMPST ) THEN
              WRITE(IFILE,1220) ' ALBEDO/PUMP REGIONS :-'
          ELSE
              WRITE(IFILE,1220) ' ALBEDO REGIONS :-'
          END IF
          WRITE(IFILE,1245) ( IALBDO(I) , I = 1 , NALBDO )
      END IF
C
      IF( NPOLYC(3).GT.0 ) THEN
          WRITE(IFILE,1200)' BAFFLE REGIONS ARE :-'
          WRITE(IFILE,1245) ( NPOLYC(3) + (I-1) + 2 , I = 1 , MEXTRA )
      END IF
C
      IF( LPMPST ) THEN
          WRITE(IFILE,1220)' PUMP STRUCTURE REGIONS :-'
          WRITE(IFILE,1245) ( I , I = NIMREG(2)+1 , NIMREG(1)-1 )
          WRITE(IFILE,1220)' PUMP STRUCTURE POLYGONS :-'
          WRITE(IFILE,1245) ( I + 2 , I = NPOLYC(5) , NPOLYC(6) )
C
          DO I = 1 , NWGAP
             IF( RWGAP(I,1).GT.RPX ) THEN
                 WRITE(IFILE,1220) ' OUTER PUMP GAP CHANNEL POLYGONS :-'
             ELSE
                 WRITE(IFILE,1220) ' INNER PUMP GAP CHANNEL POLYGONS :-'
             END IF
             WRITE(IFILE,1245) ( MGAP(I,J) + 2 , J=1,NMGAP(I) )
          ENDDO
C
          WRITE(IFILE,1200) ' PUMP POLYGON IS ' , MPMPG
      END IF
C
      IF( NLIM(1).NE.NLIM(2) ) THEN
          IF( NLIM(2).GT.0 ) THEN
              WRITE(IFILE,1200) ' THERE ARE 2 LIMITERS: REGION ' ,
     &                          NLIM(1)+2 , ' AND REGION ' , NLIM(2)+2
          ELSE
              WRITE(IFILE,1200) ' THERE IS 1 LIMITERS: REGION ' ,
     &                          NLIM(1)+2
          END IF
      END IF
C
      WRITE(IFILE,1200) ' SOURCE SEGMENTS FROM ' , 1 , ' TO ' , NSEG
C
      IF( NXPG.NE.0 ) THEN
          IF( ISEGK(5).NE.0 ) WRITE(IFILE,1200)' INNER DIV SRC. SEGMENTS
     & FROM ' , 1        , ' TO ' , ISEGK(5) , ' ANTICLOCK'
          IF( ISEGK(6).NE.0 ) WRITE(IFILE,1200)' OUTER DIV SRC. SEGMENTS
     & FROM ' , ISEGK(6) , ' TO ' , ISEGK(3) , ' ANTICLOCK'
          WRITE(IFILE,1200) ' INNER DIVERTOR SEGMENTS FROM ' ,
     &                      ISEGK(3)+1 , ' TO ' , ISEGK(4) ,' ANTICLOCK'
          WRITE(IFILE,1200) ' OUTER DIVERTOR SEGMENTS FROM ' ,
     &                      ISEGK(4)+1 , ' TO ' , ISEGK(7) ,' ANTICLOCK'
          WRITE(IFILE,1200) ' PRIVATE VOID/WALL/ALBEDO SEGMENTS FROM ' ,
     &                      ISEGK(7)+1 , ' TO ' , NSEG     ,' ANTICLOCK'
      END IF
C
      IF( NWSEG.GT.0 .AND. .FALSE. ) THEN
C
          WRITE(IFILE,1205) ' VESSEL WALL SEGMENTS FROM '
     &                    , 1 , ' TO ' , NWSEG
     &                    , ' ANTICLOCK : LENGTH =' , WSDIST(0)
C
          IF( NXPG.NE.0 ) THEN
              IF( IWSEGK(1).GT.0 ) WRITE(IFILE,1200)
     &          ' INNER  DIV WALL SEGMENTS FROM ',IWSEGK(1),
     &          ' TO '                           ,IWSEGK(2),' ANTICLOCK'
              IF( IWSEGK(3).GT.0 ) WRITE(IFILE,1200)
     &          ' OUTER  DIV WALL SEGMENTS FROM ',IWSEGK(3),
     &          ' TO '                           ,IWSEGK(4),' ANTICLOCK'
              IF( IWSEGK(5).GT.0 ) WRITE(IFILE,1200)
     &          ' CORNER DIV WALL SEGMENTS FROM ',IWSEGK(5),
     &          ' TO '                           ,IWSEGK(6),' ANTICLOCK'
              IF( IWSEGK(7).GT.0 ) WRITE(IFILE,1200)
     &          ' PRIV. VOID WALL SEGMENTS FROM ',IWSEGK(7),
     &          ' TO '                           ,IWSEGK(8),' ANTICLOCK'
          END IF
C
          WRITE(IFILE,1220) ' VESSEL WALL SEGMENT POLYGONS :-'
          WRITE(IFILE,1245) ( NWSPG(I) + 2 , I=1,NWSEG )
C
          WRITE(IFILE,1220) ' WALL POLYGONS, COORDS & LENGTHS:-'
          WRITE(IFILE,1125) ( NWSPG(I)+2
     &                      , RWSEG(I,1) , ZWSEG(I,1)
     &                      , RWSEG(I,2) , ZWSEG(I,2)
     &                      , WSDIST(I)  , I=1,NWSEG )
C
      END IF
C
      WRITE(IFILE,'(''*END'')')
C
C..................... EXTRA-COMMENT INFORMATION .......................
C
      WRITE(IFILE,1220)
     &     ' NIMBUS VESSEL SEGMENT PAIRS (+ POLYGONS FORMING SEGMENT)'
      WRITE(IFILE,1126) NVESM
      WRITE(IFILE,1126) ( I
     &                  , RVESM(I,1)    , ZVESM(I,1)
     &                  , RVESM(I,2)    , ZVESM(I,2)
     &                  , IVESM(I,1)+2*ISIGN(1,IVESM(I,1))
     &                  , COMM(IABS(IVESM(I,1))+2)
     &                  , IVESM(I,2)+2*ISIGN(1,IVESM(I,2))
     &                  , COMM(IABS(IVESM(I,2))+2)
     &                  , GVESM(I),IVESM(I,3)
     &                  , I = 1 , NVESM )
C
      WRITE(IFILE,1220)
     &     ' PLASMA BOUNDARY SEGMENT PAIRS (+ POLYGONS FORMING SEGMENT)'
      WRITE(IFILE,1126) NPLASM
      WRITE(IFILE,1126) ( I
     &                  , RPLASM(I,1)    , ZPLASM(I,1)
     &                  , RPLASM(I,2)    , ZPLASM(I,2)
     &                  , IPLASM(I,1)+2*ISIGN(1,IPLASM(I,1))
     &                  , COMM(IABS(IPLASM(I,1))+2)
     &                  , IPLASM(I,2)+2*ISIGN(1,IPLASM(I,2))
     &                  , COMM(IABS(IPLASM(I,2))+2)
     &                  , GPLASM(I)      , 0
     &                  , I = 1 , NPLASM )
C
      IF( NVESP.GT.0 ) THEN
          WRITE(IFILE,1220) ' PUMP STRUCTURE SEGMENT PAIRS'
          WRITE(IFILE,1127) NVESP
          WRITE(IFILE,1127) ( I
     &                      , RVESM(NVESM+I,1) , ZVESM(NVESM+I,1)
     &                      , RVESM(NVESM+I,2) , ZVESM(NVESM+I,2)
     &                      , IVESM(NVESM+I,3)
     &                      , I = 1 , NVESP )
      END IF
C
      IF( NLRS.GT.0 ) THEN
          WRITE(IFILE,1220) ' PUMP LEAK RECYCLING SEGMENT PAIRS'
          WRITE(IFILE,1128) NLRS
          WRITE(IFILE,1128) ( I , RLRS(I,1) , ZLRS(I,1)
     &                          , RLRS(I,2) , ZLRS(I,2)
     &                          , LALRS(I)  , LRS(I)    , I=1,NLRS )
      END IF
C
      IF( NVESC.GT.0 ) THEN
          WRITE(IFILE,1220) ' PUMP CIR STRUCTURES (R,Z,RADIUS)'
          WRITE(IFILE,1128) NVESC
          WRITE(IFILE,1129) ( I , XVESC(I,1) , XVESC(I,2) , XVESC(I,3)
     &                          , I=1,NVESC )
      END IF
C
C.......................................................................
C
      END IF
C
C#######################################################################
C######################### END OF NIMBUS FILE ##########################
C#######################################################################
C
      IF( IFILE.LE.0 ) GOTO 9999
C
      IF( LMC ) THEN
          WRITE(LOUT,9150)
          CALL EXITX(LOUT)
      END IF
C
C#######################################################################
C############################# CALL NIMBUS #############################
C#######################################################################
C
      IF( IPUNCH.GT.0 ) THEN
        REWIND IFILE
        REWIND IPUNCH
C
        IARK = 0
        IF( IREAD.NE.0 .OR. IWRITE.NE.0 ) IARK = LARKF
C
        CALL NIMBUS
     &    ( IFILE , IOUT , LOUT, IARK , IPUNCH , 0 , IFTRIM , ISETUP ,
     &      ITAIO1,ITAIO2)
C
        IF(.NOT.LFULL) ISETUP = 1
C
C#######################################################################
C#################### COPY IFILE COMMENTS TO IOUT ######################
C#######################################################################
C
 3000   READ(IFILE,1220,END=3010) STRING
        IF( IOUT.GT.0 ) WRITE(IOUT,1220) STRING
        GOTO 3000
 3010   CONTINUE
C
C#######################################################################
C############################# READ IPUNCH #############################
C#######################################################################
C
        REWIND IPUNCH
      ELSE IF(IPUNCH.LT.0) THEN
        REWIND -IPUNCH
      ENDIF
C
      IPUN = IABS(IPUNCH)
      READ(IPUN,'(//)')
      IF(MIMP.GT.0) THEN
        READ(IPUN,1230) NION
        IF(NION.NE.NIONH) THEN
          WRITE(LOUT,*) ' LINKPG NION<>NIONH'
CWARN     CALL EXITX(LOUT)
        ENDIF
        IF(NION.GT.MIO) THEN
          WRITE(LOUT,*) ' LINKPG NION>',MIO
          CALL EXITX(LOUT)
        ENDIF
        DO K=1,NION
          READ(IPUN,3015) ITRAN,TRAN,TRAN1,TRAN2
 3015     FORMAT(I4,4X,A4,1P,2E12.5)
 3016     FORMAT(I4,4X,A4,1X,2F6.1)
          WRITE(LOUT,3016)ITRAN,TRAN,TRAN1,TRAN2
        ENDDO
        READ(IPUN,1230) NMOL
        IF(NMOL.GT.0) THEN
          DO K=1,NMOL
            READ(IPUN,3015) ITRAN,TRAN,TRAN1,TRAN2
            WRITE(LOUT,3016)ITRAN,TRAN,TRAN1,TRAN2
          ENDDO
        ENDIF
        READ(IPUN,1230) NIMP
        DO K=1,NIMP
          READ(IPUN,3015) ITRAN,SYMIMP,TRAN1,TRAN2
          WRITE(LOUT,3016)ITRAN,SYMIMP,TRAN1,TRAN2
C         INDIMP(IZ_NIMBUS)=IZ_EDGE2D
          INDIMP(K)=0
          DO KZ=1,NZE2D
            IF(SZE2D(KZ).EQ.SYMIMP) THEN
              INDIMP(K)=KZ
              WRITE(LOUT,'( '' RECEIVE PROFILES OF IMPUR. NEUTRAL'',I2,
     &                   '':'',I2,'' ('',A2,'')'')') KZ,K,SYMIMP
            ENDIF
          ENDDO
        ENDDO
      ELSE
        NIMP=1
        IF(NIONH.EQ.1) THEN
          NION=1
        ELSE
          WRITE(LOUT,*) ' **** ERROR IN LINKPG: MIMP<1> AND NIONH>1'
          CALL EXITX(LOUT)
        ENDIF
      ENDIF
C
 3020 CONTINUE
      READ(IPUN,1230) I , VOLZ
C
      IF( I.GE.3 ) THEN
          M       = I - 2
          VOLM(M) = VOLZ
          READ(IPUN,1240)
     &          (PUNION(M,L),L=1,NION)
     &         , PUNENI(M)
     &         , PUNXMO(M)
     &         , PUNYMO(M)
     &         , PUNZMO(M)
     &         , PUNENE(M)
     &         ,(PUNADN(M,L),L=1,NION)
     &         ,(PUNMDN(M,L),L=1,NION)
     &         ,(AUXIMP(1,L)   , L=1,NIMP)                  ! PUNZDN(Z)
     &         , PUNALF(M)
     &         ,(AUXIMP(2,L)   , L=1,NIMP)                  ! PUNZIO(Z)
     &         ,(PUNAEN(M,L),L=1,NION)
     &         ,(PUNMEN(M,L),L=1,NION)
     &         ,(AUXIMP(3,L)   , L=1,NIMP)                  ! PUNZEN(Z)
     &         ,(PUNACS(M,1,L),PUNACS(M,2,L),PUNACS(M,3,L),L=1,NION)
     &         ,(PUNMCS(M,1,L),PUNMCS(M,2,L),PUNMCS(M,3,L),L=1,NION)
     &         , ECX(M)
     &         ,(PUNAE0(M,L),L=1,NION)
     &         , PUNSOU(M,1,1),PUNSOU(M,2,1)
     &         , PUNSOU(M,1,2),PUNSOU(M,2,2)
     &         ,(DAHFR(M,L),L=1,NION)
          IF(MIMP.GT.0) THEN
            DO L=1,NIMP
              IF(INDIMP(L).GT.0) THEN
                PUNZDN(M,INDIMP(L))=AUXIMP(1,L)
                PUNZIO(M,INDIMP(L))=AUXIMP(2,L)
                PUNZEN(M,INDIMP(L))=AUXIMP(3,L)
              ENDIF
            ENDDO
          ELSE
            PUNZDN(M,1)=AUXIMP(1,1)
            PUNZIO(M,1)=AUXIMP(2,1)
            PUNZEN(M,1)=AUXIMP(3,1)
          ENDIF
          IF(IHOR.EQ.1) THEN
            READ(IPUN,1240) ( ( PUNHO(M,L,JTYP),L=1,3 ) , JTYP=1,NDIHO)
          ENDIF
          GOTO 3020
      END IF
C
C                    MACRO-REGIONS
      CALL RESETR( SMACRO(1,1,1) , MACRO1*MACRO2*(1+NZE2D) , 0.00D+00 )
      CALL RESETR( PMACRO(1,1,1) , MACRO1*MACRO3*(1+NZE2D) , 0.00D+00 )
      CALL RESETR( VMACRO(1)     , MACRO1                  , 0.00D+00 )
C
      READ(IPUN,1230) NMACRO
      IF(NMACRO.GT.MACRO1) THEN
         WRITE(LOUT,*)
     &   ' **** ERROR **** LINKPG : MACRO-REGION DIMENSIONS'
         WRITE(LOUT,*)
     &   '                 NMACRO,MACRO1=',NMACRO,MACRO1
         CALL EXITX(LOUT)
      ENDIF
C                     H MACRO
      READ(IPUN,1242) ( SMACRO(M,1,1),SMACRO(M,2,1),
     &                  (SMACRO(M,2+K,1),K=1,NMACRO),
     &                 M=1,NMACRO)
      READ(IPUN,1242) ( VMACRO(M),TRAN,TRAN,
     &                  PMACRO(M,1,1),PMACRO(M,2,1),
     &                 M=1,NMACRO)
C                     Z MACRO (TOTAL OR ZERO)
        READ(IPUN,1242) ( SMACRO(M,1,1+1),SMACRO(M,2,1+1),
     &                    (SMACRO(M,2+K,1+1),K=1,NMACRO),
     &                   M=1,NMACRO)
        READ(IPUN,1242) (           TRAN,TRAN,
     &                    PMACRO(M,1,1+1),PMACRO(M,2,1+1),
     &                   M=1,NMACRO)
      IF(MIMP.GT.0) THEN
        DO L=1,NIMP
          KZ=INDIMP(L)
          IF(KZ.GT.0) THEN
            READ(IPUN,1242) ( SMACRO(M,1,1+KZ),SMACRO(M,2,1+KZ),
     &                        (SMACRO(M,2+K,1+KZ),K=1,NMACRO),
     &                       M=1,NMACRO)
            READ(IPUN,1242) (           TRAN,TRAN,
     &                        PMACRO(M,1,1+KZ),PMACRO(M,2,1+KZ),
     &                       M=1,NMACRO)
          ELSE
            READ(IPUN,1242) ( TRAN            ,TRAN            ,
     &                        (TRAN              ,K=1,NMACRO),
     &                       M=1,NMACRO)
            READ(IPUN,1242) (           TRAN,TRAN,
     &                        TRAN            ,TRAN            ,
     &                       M=1,NMACRO)
          ENDIF
        ENDDO
      ENDIF
C
      DO KZ=1,NZE2D
        TOTZSP(KZ)=0.0
        TOTZES(KZ)=0.0
        TOTZRD(KZ)=0.0
        TOTZSN(KZ)=0.0
        TOTZEA(KZ)=0.0
        TOTZLK(KZ)=0.0
      ENDDO
C
      READ(IPUN,1240) TOTION
     &              , (TOTHES(K), TOTHEA(K), K=1,NION)
     &              , TOTZSP(1)
     &              , TOTZES(1) , TOTZRD(1) , SRECYC , SRECOM
     &              , TOTZSN(1)
     &              , HTMOUT , STMOUT , TRAN1  , TRAN2
     &              , ZTMOUT , YTMOUT , TOTZEA(1)
     &              , (TOTHLK(K), K=1,NION), TOTZLK(1)
C
      IF(MIMP.GT.0) THEN
        READ(IPUN,1240) ( (AUXIMP(J,L),J=1,6), L=1,NIMP )
        DO L=1,NIMP
          IF(INDIMP(L).GT.0) THEN
            TOTZSP(INDIMP(L))=AUXIMP(1,L)
            TOTZES(INDIMP(L))=AUXIMP(2,L)
            TOTZRD(INDIMP(L))=AUXIMP(3,L)
            TOTZSN(INDIMP(L))=AUXIMP(4,L)
            TOTZEA(INDIMP(L))=AUXIMP(5,L)
            TOTZLK(INDIMP(L))=AUXIMP(6,L)
          ENDIF
        ENDDO
      ENDIF
C
      DO KZ=1,NZE2D
        TOTZSP(KZ) = TOTZSP(KZ)-TOTZRD(KZ)
C OLD   TOTZSN(KZ) = TOTZSN(KZ)-TOTZRD(KZ)
C OLD  IN THIS WAY, IF THE PRIMARY ION SPUTTERING IS RECOMPUTED (EDGE2D)
C OLD  SPUTTERING FROM IONS + TOTZSN = NET TOTAL IMPURITY PRODUCTION
C      NO! WRONG IF THERE IS INJECTION OF IMPURITY. SO, TO TRAP ITS USE:
        TOTZSN(KZ) = -1.0D+30
      ENDDO
C
      READ(IPUN,1245) NZCHAN
      READ(IPUN,1245) ( JZCHAN(I) , I=1,NZCHAN )
      READ(IPUN,1245) ( (IZCHAN(I,J) , J=1,JZCHAN(I)) , I=1,NZCHAN )
C
C     NEUTRAL TRAJECTORY TRACKS
C
      READ(IPUN,1245) IDEBWR
      IF( IDEBWR.GT.MDEBWR ) THEN
          WRITE(LOUT,9080) 'IDEBWR' , IDEBWR , MDEBWR
          CALL EXITX(LOUT)
      END IF
C
      IF( IDEBWR.GT.0 ) THEN
          DO 3022 I=1,IDEBWR
             READ(IPUN,1246) IDEBPT , NDBHST(I)
             IF( IDEBPT.GT.MDEBPT ) THEN
                 WRITE(LOUT,9080) 'IDEBPT' , IDEBPT , MDEBPT
                 CALL EXITX(LOUT)
             ELSE
                 KDEBWR(I) = IDEBPT
             END IF
             READ(IPUN,1240)
     *                (XDEBWR(I,K,1),XDEBWR(I,K,2),XDEBWR(I,K,3),
     *                 K=1,KDEBWR(I))
 3022     CONTINUE
      ENDIF
C
C----------------------------- WALL LOADING ----------------------------
C
      NFLXHW=0
      CALL RESETI( MAPFLX(1) , MVESM , 0 )
C
      DO 3023 I=1,NVESM
        IF( IVESM(I,1).GT.0 ) THEN
            NFLXHW           = NFLXHW + 1
            MAPFLX(I)        = NFLXHW
            FLUXHW(NFLXHW,1) = (RVESM(I,1)+RVESM(I,2))*0.5D0
            FLUXHW(NFLXHW,2) = (ZVESM(I,1)+ZVESM(I,2))*0.5D0
            FLUXHW(NFLXHW,3) = 0.0D0
            FLUXHW(NFLXHW,4) = 0.0D0
            FLUXHW(NFLXHW,5) = 0.0D0
            FLUXHW(NFLXHW,6) = 0.0D0
            FLUXHW(NFLXHW,7) = 0.0D0
            FLUXHW(NFLXHW,8) = 0.0D0
            FLUXHW(NFLXHW,9) = 0.0D0
            DO KZ=1,NZE2D
              FLUXZW(NFLXHW,1,KZ) = 0.0D0
              FLUXZW(NFLXHW,2,KZ) = 0.0D0
            ENDDO
            DO KH=1,NIONH
              FLXHSW(NFLXHW,1,KH) = 0.0D0
              BUFHSW(NFLXHW,KH)   = 0.0D0
            ENDDO
        END IF
 3023 CONTINUE
C
      SUMFH=0.0D0
      SUMIH=0.0D0
      SUMZS=0.0D0
      SUMZR=0.0D0
      SUMAH=0.0D0
      READ(IPUN,1220) STRING
CW    WRITE(LOUT,1220) STRING
C
 3025 CONTINUE
      DO KZ=1,NZE2D
        FLUX3(KZ)=0.0
        FLUX4(KZ)=0.0
      ENDDO
      READ(IPUN,1230) IZO , FLUX1, FLUX2 , FLUX3(1) , FLUX4(1), EAHWL
      IF(IZO.LE.0) GOTO 3029
      READ(IPUN,1233) FLUX5, (BUFFER(KH),KH=1,NIONH)
C
      IF(MIMP.GT.0) THEN
        READ(IPUN,1240) ( (AUXIMP(J,L),J=1,2), L=1,NIMP )
        DO L=1,NIMP
          IF(INDIMP(L).GT.0) THEN
            FLUX3(INDIMP(L))=AUXIMP(1,L)
            FLUX4(INDIMP(L))=AUXIMP(2,L)
          ENDIF
        ENDDO
      ENDIF
C
      NMATCH = 0
      DO 3027 L=1,NVESM
        IF( IABS(IVESM(L,1))+2.EQ.IZO .AND. IVESM(L,1).GT.0 ) THEN
            IF( NMATCH.LT.MMATCH ) THEN
                NMATCH         = NMATCH + 1
                IMATCH(NMATCH) = L
            ELSE
                WRITE(LOUT,*)' '
                WRITE(LOUT,*)'***************************************'
                WRITE(LOUT,*)'*** ERROR(LINKPG): IMATCH DIM. EXCEEDED'
                WRITE(LOUT,*)'***************************************'
                WRITE(LOUT,*)' '
                CALL EXITX(LOUT)
            END IF
        END IF
 3027 CONTINUE
      IF( NMATCH.EQ.0 ) THEN
          WRITE(LOUT,*)' '
          WRITE(LOUT,*)'**********************************************'
          WRITE(LOUT,*)'*** WARNING(LINKPG): NO INFO. FOR WALL',IZO
          WRITE(LOUT,*)'**********************************************'
          WRITE(LOUT,*)' '
          GOTO 3025
      END IF
C
      SUMFH=SUMFH+FLUX1
      SUMIH=SUMIH+FLUX2
      DO KZ=1,NZE2D
        SUMZS=SUMZS+FLUX3(KZ)
        SUMZR=SUMZR+FLUX4(KZ)
      ENDDO
      SUMAH=SUMAH+FLUX5
C
      AREAW        = 0.0D+00
      DO N         = 1 , NMATCH
         I         = IMATCH(N)
         AMATCH(I) =  SQRT( (RVESM(I,2)-RVESM(I,1))**2
     &                    + (ZVESM(I,2)-ZVESM(I,1))**2 )
         AREAW     = AREAW + AMATCH(I)
      ENDDO
C
      DO N     = 1 , NMATCH
         I     = IMATCH(N)
C
C.. RATIO OF MATCHED AREAS
         RATIO = AMATCH(I) / AREAW
C
C.. SEGMENT TO FLUX INDEX MAPPING
         L = MAPFLX(I)
C
         IF(FLUXHW(L,3).NE.0.0D0) THEN
          WRITE(LOUT,*)' **** ERROR(LINKPG): WALL',IZO,'ALREADY DEFINED'
          CALL EXITX(LOUT)
         ENDIF
C
         FLUXHW(L,3) = (FLUX1/AREAW) * RATIO
         FLUXHW(L,4) = (FLUX2/AREAW) * RATIO
         IF(MIMP.LE.0) THEN
           FLUXHW(L,5) = (FLUX3(1)/AREAW) * RATIO
           FLUXHW(L,6) = (FLUX4(1)/AREAW) * RATIO
         ELSE
           DO KZ=1,NZE2D
C            TOTAL IMPURITY FLUX ON WALLS
             FLUXHW(L,5) = FLUXHW(L,5) + ((FLUX3(KZ)/AREAW) * RATIO )
             FLUXHW(L,6) = FLUXHW(L,6) + ((FLUX4(KZ)/AREAW) * RATIO )
C            IMPURITY FLUX BREAKDOWN
             FLUXZW(L,1,KZ) = (FLUX3(KZ)/AREAW) * RATIO
             FLUXZW(L,2,KZ) = (FLUX4(KZ)/AREAW) * RATIO
           ENDDO
         ENDIF
         FLUXHW(L,7) = EAHWL * RATIO
         FLUXHW(L,8) = (FLUX5/AREAW) * RATIO
C
         FLUXHW(L,9) = 0.0D+00
         DO KH = 1 , NIONH
            BUFHSW(L,KH)   = BUFFER(KH) * RATIO
            FLXHSW(L,1,KH) = BUFHSW(L,KH) / AREAW
            FLUXHW(L,9)    = FLUXHW(L,9) + FLXHSW(L,1,KH)
         ENDDO
C
CW       WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
CW   &            ' IZO='     , IZO
CW   &           ,' IVES='    , L
CW   &           ,' FLUX1='   , FLUX1
CW   &           ,' AREAW='   , AREAW
CW   &           ,' FLUXHW3=' , FLUXHW(L,3)
CW       WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
CW   &            ' IZO='     , IZO
CW   &           ,' IVES='    , L
CW   &           ,' FLUX2='   , FLUX2
CW   &           ,' AREAW='   , AREAW
CW   &           ,' FLUXHW4=' , FLUXHW(L,4)
CW       WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
CW   &            ' IZO='     , IZO
CW   &           ,' IVES='    , L
CW   &           ,' FLUX3='   , FLUX3
CW   &           ,' AREAW='   , AREAW
CW   &           ,' FLUXHW5=' , FLUXHW(L,5)
CW       WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
CW   &            ' IZO='     , IZO
CW   &           ,' IVES='    , L
CW   &           ,' FLUX4='   , FLUX4
CW   &           ,' AREAW='   , AREAW
CW   &           ,' FLUXHW6=' , FLUXHW(L,6)
CW       WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
CW   &            ' IZO='     , IZO
CW   &           ,' IVES='    , L
CW   &           ,' FLUX5='   , FLUX5
CW   &           ,' AREAW='   , AREAW
CW   &           ,' FLUXHW8=' , FLUXHW(L,8)
      ENDDO
C
      GOTO 3025
 3029 CONTINUE
C
C.. SUMS OF H(IHS)-NEUTRAL IMPLANTATION, FOR EACH REGION
      CALL FLXREG( LOUT
     I           , MVESM , MWREG       , MFLXH      , MIONH
     I           , NVESM , GVESM(1)
     I           , NIONH , BUFHSW(1,1) , MAPFLX(1)  , GWREG(1)
     O           , FWREG(1,1,1) )
C
C.. PRINT INFORMATIONS ABOUT WALL FLUXES, ETC
      WRITE(LOUT,*) 'LINKPG:  H + H2 FLUX ONTO WALLS'    , SUMFH
      WRITE(LOUT,*) 'LINKPG:  H + H+ FLUX ONTO WALLS'    , SUMIH
      WRITE(LOUT,*) 'LINKPG:  H      FLUX ONTO WALLS'    , SUMAH
      WRITE(LOUT,*) 'LINKPG:  Z-SPUTT   FLUX ONTO WALLS' , SUMZS
      WRITE(LOUT,*) 'LINKPG:  Z-REDEPOS FLUX ONTO WALLS' , SUMZR
C
C.. PRINT SUM INFORMATIONS
      DO I = 1 , MWREG
       DO IHS = 1 , NIONH
         IF( AWREG(I).GT.0.0D+00 )
     >       WRITE(LOUT,8010) IHS , GWREG(I) , FWREG(I,1,IHS) / AWREG(I)
       ENDDO
      ENDDO
C
C----------------- FLUX TO PLASMA BOUNDARY FROM VOID -------------------
C
      CALL RESETR( FLUXPB(1,1) , MVESM*MFLXPB , 0.0D+00 )
C
      SUMFB=0.0D0
      READ(IPUN,1220) STRING
CW    WRITE(LOUT,1220) STRING
 3095 READ(IPUN,1230) IZO , FLUX1
      IF(IZO.LE.0) GOTO 3099
C
      LTRAN     = .FALSE.
      DO 3092 L = 1 , NPLASM
         I      = L
         IF( IABS(IPLASM(I,1))+2.EQ.IZO ) THEN
             IF( COMM(IABS(IPLASM(I,2))+2).EQ.BLANK ) THEN
                 GOTO 3098
             ELSE
                 LTRAN = .TRUE.
             END IF
         END IF
 3092 CONTINUE
C
C.. LTRAN USED ONLY IF PLASMA BOUNDARY CANNOT BE FOUND OR OF WRONG TYPE
      WRITE(LOUT,*)' '
      WRITE(LOUT,*)'***************************************************'
      IF( LTRAN ) THEN
          WRITE(LOUT,*)
     >       '*** WARNING(LINKPG): NON-VOID USED IN PLASMA BOUNDARY '
          WRITE(LOUT,'(1X,A,6X,A,I5,A,1PE12.5,A)')
     >      '***' , '(IZO =' , IZO , ' WITH FLUX1 =' , FLUX1 , ')'
      ELSE
          WRITE(LOUT,*)
     >      '*** WARNING(LINKPG): NO INFO FOR PLASMA BOUNDARY'
          WRITE(LOUT,'(1X,A,6X,A,I5,A,1PE12.5,A)')
     >      '***' , '(IZO =' , IZO , ' WITH FLUX1 =' , FLUX1 , ')'
      END IF
      WRITE(LOUT,*)'***************************************************'
      WRITE(LOUT,*)' '
      GOTO 3095
C
 3098 CONTINUE
C
      IF(FLUXPB(I,1).NE.0.0D0) THEN
       WRITE(LOUT,*)' '
       WRITE(LOUT,*)
     > '***************************************************'
       WRITE(LOUT,*)' ***** ERROR IN LINKPG: WALL',IZO,'ALREADY DEFINED'
       WRITE(LOUT,*)
     > '***************************************************'
       WRITE(LOUT,*)' '
       CALL EXITX(LOUT)
      ENDIF
C
      SUMFB  = SUMFB + FLUX1
      AREAB  = SQRT(  (RPLASM(I,2)-RPLASM(I,1))**2
     &              + (ZPLASM(I,2)-ZPLASM(I,1))**2 )
      FLUXPB(I,1) = FLUX1/AREAB
C     WRITE(LOUT,'(A,I6,A,I6,A,1PE12.4,A,E12.4,A,E12.4)')
C    &         ' IZO='     , IZO
C    &        ,' IPLASM='  , I
C    &        ,' FLUX1='   , FLUX1
C    &        ,' AREAB='   , AREAB
C    &        ,' FLUXPB1=' , FLUXPB(L,1)
      GOTO 3095
C
 3099 CONTINUE
      WRITE(LOUT,*) 'LINKPG:  H+H2 FLUX ONTO PLASMA BOUNDARY', SUMFB
C
C#######################################################################
C################ WHICH CELL DOES A NIMBUS POLYGON LIE #################
C#######################################################################
C
      DO 3030 M               = 1 , NPOLYM
         DO 3040 I            = 1 , NZCHAN
            DO 3045 J         = 1 , JZCHAN(I)
               IF( IZCHAN(I,J).EQ.M+2 ) THEN
                   MZONE(M,1) = I
                   MZONE(M,2) = J
                   GOTO 3030
               END IF
 3045       CONTINUE
 3040    CONTINUE
         MZONE(M,1)           = 0
         MZONE(M,2)           = 0
 3030 CONTINUE
C
C#######################################################################
C############### CALCULATE H-NEUTRALS IONISED IN THE SOL ###############
C#######################################################################
C
      SOLION        = 0.00D+00
      DO 3050 I     = LCFSPG + 1 , NCHAN
         DO 3060 J  = 1          , MCHAN(I)
            M       = JCHAN(I,J)
            DO L    =1           , NION
               SOLION  = SOLION + PUNION(M,L)
            ENDDO
 3060    CONTINUE
 3050 CONTINUE
C
      IF( IPRINT.GT.0 .AND. IFILE.GT.0 )
     >    WRITE(IPRINT,1250) RGAMMA , TOTION , SOLION ,
     &                       TOTHES(1) , TOTZSP(1) , TOTZES(1)
C
C#######################################################################
C############################## PROFILES ###############################
C#######################################################################
C
CT    TESTA=0.0D0
      DO 3100 I           = 1 , NC
         DO 3110 J        = 1 , NJ(I)
            K             = KORY(I,J)
            IF( ITAG(K,4).LT.0 ) GOTO 3110
C
            VSUM          = 0.00D+00
            DO L=1,NION
              SUMSN(L)    = 0.00D+00
              SUMA(L)     = 0.00D+00
              SUMAVX(L)     = 0.00D+00
              SUMAVY(L)     = 0.00D+00
              SUMAVZ(L)     = 0.00D+00
              SUMM(L)       = 0.00D+00
              SUMMVX(L)     = 0.00D+00
              SUMMVY(L)     = 0.00D+00
              SUMMVZ(L)     = 0.00D+00
              SUMEA(L)      = 0.00D+00
              SUMEA0(L)     = 0.00D+00
              SUMEM(L)      = 0.00D+00
              SUMDHF(L)     = 0.00D+00
            ENDDO
            SUMAT         = 0.00D+00
            SUMQ          = 0.00D+00
            SUMQE         = 0.00D+00
C
            SUMMX         = 0.00D+00
            SUMMY         = 0.00D+00
            SUMMZ         = 0.00D+00
            SUMHA         = 0.00D+00
            SUMEAX        = 0.00D+00
            DO KZ=1,NZE2D
              SUMZ(KZ)    = 0.00D+00
              SUMSZ(KZ)   = 0.00D+00
              SUMEZ(KZ)   = 0.00D+00
            ENDDO
C
            SMQELA        = 0.00D+00
            SMPELA        = 0.00D+00
            SMQELM        = 0.00D+00
            SMPELM        = 0.00D+00
C
            CALL RESETR( HOR(1,1) , 3*NDIHO, 0.00D+00 )
C
            N             = KORPG(K)
            DO 3120 LL    = 1 , NM(N)
               M          = KORM(N,LL)
C
               VL = VOLM(M)
               IF( VL.GT.0.00D+00 ) THEN
                   VSUM   = VSUM  + VL
C
                   DO L=1,NION
                     SUMSN(L)  = SUMSN(L)  + PUNION(M,L)
                     SUMA(L)= SUMA(L)+ PUNADN(M,L)                 * VL
                     SUMAT  = SUMAT  + PUNADN(M,L)                 * VL
                     SUMM(L)= SUMM(L)+ PUNMDN(M,L)                 * VL
                     SUMEA(L)  = SUMEA(L)
     &                         + PUNAEN(M,L)  * PUNADN(M,L)  * VL
                     SUMDHF(L) = SUMDHF(L)
     &                         + DAHFR(M,L)   * PUNADN(M,L)  * VL
                     SUMEAX    = SUMEAX
     &                         + ECX(M) * PUNADN(M,L)  * VL
                     SUMEA0(L) = SUMEA0(L)
     &                         + PUNAE0(M,L)  * PUNADN(M,L)  * VL
                     SUMEM(L)  = SUMEM(L)
     &                         + PUNMEN(M,L)  * PUNMDN(M,L)  * VL
                     SUMAVX(L) = SUMAVX(L)
     &                         + PUNACS(M,1,L) * PUNADN(M,L) * VL
                     SUMAVY(L) = SUMAVY(L)
     &                         + PUNACS(M,2,L) * PUNADN(M,L) * VL
                     SUMAVZ(L) = SUMAVZ(L)
     &                         + PUNACS(M,3,L) * PUNADN(M,L) * VL
                     SUMMVX(L) = SUMMVX(L)
     &                         + PUNMCS(M,1,L) * PUNMDN(M,L) * VL
                     SUMMVY(L) = SUMMVY(L)
     &                         + PUNMCS(M,2,L) * PUNMDN(M,L) * VL
                     SUMMVZ(L) = SUMMVZ(L)
     &                         + PUNMCS(M,3,L) * PUNMDN(M,L) * VL
                   ENDDO
                   SUMQ   = SUMQ  + PUNENI(M)
                   SUMMX  = SUMMX + PUNXMO(M)
                   SUMMY  = SUMMY + PUNYMO(M)
                   SUMMZ  = SUMMZ + PUNZMO(M)
                   SUMQE  = SUMQE - PUNENE(M)
                   SUMHA  = SUMHA + PUNALF(M)
C
                   IF(MIMP.LE.0) THEN
                     KZ=1
                       SUMZ(KZ)  = SUMZ(KZ)  + PUNZDN(M,KZ) * VL
                       SUMSZ(KZ) = SUMSZ(KZ) + PUNZIO(M,KZ)
                       SUMEZ(KZ) = SUMEZ(KZ) + PUNZEN(M,KZ) *
     &                                         PUNZDN(M,KZ) * VL
                   ELSE
                     DO KZ=1,NZE2D
                       SUMZ(KZ)  = SUMZ(KZ)  + PUNZDN(M,KZ) * VL
                       SUMSZ(KZ) = SUMSZ(KZ) + PUNZIO(M,KZ)
                       SUMEZ(KZ) = SUMEZ(KZ) + PUNZEN(M,KZ) *
     &                                         PUNZDN(M,KZ) * VL
                     ENDDO
                   ENDIF
C
                   SMQELA = SMQELA + PUNSOU(M,1,1)
CT                 TESTA=TESTA+PUNSOU(M,1,1)
                   SMPELA = SMPELA + PUNSOU(M,2,1)
                   SMQELM = SMQELM + PUNSOU(M,1,2)
                   SMPELM = SMPELM + PUNSOU(M,2,2)
C
                   IF( IHOR.EQ.1 ) THEN
                     DO 3114 IBIN=1,3
C                      <NH>
                       HOR(IBIN,1) = HOR(IBIN,1)+PUNHO(M,IBIN,1)*VL
C                      <H-IONIS>
                       HOR(IBIN,2) = HOR(IBIN,2)+PUNHO(M,IBIN,2)*VL
C                      <H-CX>
                       HOR(IBIN,3) = HOR(IBIN,3)+PUNHO(M,IBIN,3)*VL
C                      <H2-IONIS>
                       HOR(IBIN,13) = HOR(IBIN,13)+PUNHO(M,IBIN,13)*VL
C                      <H2-DISSOC>
                       HOR(IBIN,14) = HOR(IBIN,14)+PUNHO(M,IBIN,14)*VL
 3114                CONTINUE
                     DO 3115 IH=4,12
                       HOR(1,IH)=HOR(1,IH)+PUNHO(M,1,1)*PUNHO(M,1,IH)*VL
                       HOR(2,IH)=HOR(2,IH)+PUNHO(M,2,1)*PUNHO(M,2,IH)*VL
                       HOR(3,IH)=HOR(3,IH)+PUNHO(M,3,1)*PUNHO(M,3,IH)*VL
 3115                CONTINUE
                   ENDIF
C
               ELSE
C
                  VSUM = VSUM + AREAM(M)
C
               END IF
C
 3120       CONTINUE
C
            IF( VSUM.GT.0.00D+00 ) THEN
                PROFQ(K)     = SUMQ  / VSUM
                PROFQE(K)    = SUMQE / VSUM
                DO L=1,NION
                  PROFSN(K,L) = SUMSN(L) / VSUM
                  PROFA(K,L)  = SUMA(L)  / VSUM
                  PROFM(K,L)  = SUMM(L)  / VSUM
                  IF(SUMA(L).NE.0.0D0) THEN
                    ENEUTA(K,L) = SUMEA(L) / SUMA(L)
                    DAHF(K,L)   = SUMDHF(L) / SUMA(L)
                    ERELHI(K,L) = SUMEA0(L) / SUMA(L)
                    VA(1,K,L)   = SUMAVX(L) / SUMA(L)
                    VA(2,K,L)   = SUMAVY(L) / SUMA(L)
                    VA(3,K,L)   = SUMAVZ(L) / SUMA(L)
                  ELSE
                    ENEUTA(K,L) = 0.00D+00
                    DAHF(K,L)   = 0.00D+00
                    ERELHI(K,L) = 0.00D+00
                    VA(1,K,L)   = 0.00D+00
                    VA(2,K,L)   = 0.00D+00
                    VA(3,K,L)   = 0.00D+00
                  ENDIF
                  IF(SUMM(L).NE.0.0D0) THEN
                    ENEUTM(K,L) = SUMEM(L) / SUMM(L)
                    VM(1,K,L)   = SUMMVX(L) / SUMM(L)
                    VM(2,K,L)   = SUMMVY(L) / SUMM(L)
                    VM(3,K,L)   = SUMMVZ(L) / SUMM(L)
                  ELSE
                    ENEUTM(K,L) = 0.00D+00
                    VM(1,K,L)   = 0.00D+00
                    VM(2,K,L)   = 0.00D+00
                    VM(3,K,L)   = 0.00D+00
                  ENDIF
                ENDDO
                DO KZ=1,NZE2D
                  PROFZ(K,KZ) = SUMZ(KZ) / VSUM
                  PROFSZ(K,KZ) = SUMSZ(KZ) / VSUM
                ENDDO
                PROFMN(K) = SUMMX / VSUM
                PROFMP(K) = SUMMY / VSUM
                PROFMF(K) = SUMMZ / VSUM
                PROFHA(K) = SUMHA / VSUM
                PRQELA(K) = SMQELA / VSUM
                PRPELA(K) = SMPELA / VSUM
                PRQELM(K) = SMQELM / VSUM
                PRPELM(K) = SMPELM / VSUM
                IF(NION.EQ.1) THEN
                  IF(SUMAT.NE.0.0D0) THEN
                    ENEUCX(K,1)  = SUMEAX / SUMAT
                  ELSE
                    ENEUCX(K,1)  = 0.00D+00
                  ENDIF
                ELSE
                  DO IH=1,NIONH
                    ENEUCX(K,IH) = ENEUTA(K,IH)
                  ENDDO
                ENDIF
                DO KZ=1,NZE2D
                  IF(SUMZ(KZ).NE.0.0D0) THEN
                    ENEUTZ(K,KZ) = SUMEZ(KZ) / SUMZ(KZ)
                  ELSE
                    ENEUTZ(K,KZ) = 0.00D+00
                  ENDIF
                ENDDO
                IF(IHOR.NE.0) THEN
                  DO 3105 IBIN=1,3
                    HORTON(IBIN,1,K) = HOR(IBIN,1)/VSUM
                    HORTON(IBIN,2,K) = HOR(IBIN,2)/VSUM
                    HORTON(IBIN,3,K) = HOR(IBIN,3)/VSUM
                    HORTON(IBIN,13,K) = HOR(IBIN,13)/VSUM
                    HORTON(IBIN,14,K) = HOR(IBIN,14)/VSUM
 3105             CONTINUE
                   DO 3106 IH=4,12
                     IF(HOR(1,1).GT.0.0D0)
     &               HORTON(1,IH,K)=HOR(1,IH)/HOR(1,1)
                     IF(HOR(2,1).GT.0.0D0)
     &               HORTON(2,IH,K)=HOR(2,IH)/HOR(2,1)
                     IF(HOR(3,1).GT.0.0D0)
     &               HORTON(3,IH,K)=HOR(3,IH)/HOR(3,1)
 3106              CONTINUE
                ENDIF
            ELSE
                PROFQ(K)     = 0.00D+00
                PROFQE(K)    = 0.00D+00
                PROFMP(K) = 0.00D+00
                PROFMF(K) = 0.00D+00
                PROFMN(K) = 0.00D+00
                PROFHA(K) = 0.00D+00
                DO L=1,NION
                  PROFSN(K,L) = 0.00D+00
                  PROFA(K,L)  = 0.00D+00
                  PROFM(K,L)  = 0.00D+00
                  ENEUTA(K,L) = 0.00D+00
                  DAHF(K,L)   = 0.00D+00
                  ENEUTM(K,L) = 0.00D+00
                  VA(1,K,L)   = 0.00D+00
                  VA(2,K,L)   = 0.00D+00
                  VA(3,K,L)   = 0.00D+00
                  VM(1,K,L)   = 0.00D+00
                  VM(2,K,L)   = 0.00D+00
                  VM(3,K,L)   = 0.00D+00
                ENDDO
                DO KZ=1,NZE2D
                  PROFZ(K,KZ)  = 0.00D+00
                  PROFSZ(K,KZ) = 0.00D+00
                  ENEUTZ(K,KZ) = 0.00D+00
                ENDDO
                VSUM      = 1.00D-30
                PRQELA(K) = 0.00D+00
                PRPELA(K) = 0.00D+00
                PRQELM(K) = 0.00D+00
                PRPELM(K) = 0.00D+00
                IF(IHOR.NE.0) CALL RESETR(HORTON(1,1,K),3*NDIHO,0.0D0)
            END IF
C
            IF( N.LE.MPG ) THEN
                VOLP(N)   = VSUM
            ELSE
                WRITE(LOUT,*) ' **** ERROR **** LINKPG : VOLP DIMENSION'
                CALL EXITX(LOUT)
            END IF
C
 3110    CONTINUE
 3100 CONTINUE
CT    WRITE(LOUT,*) ' LINKPG - TESTA=',TESTA*1.6022E-19
C
C#######################################################################
C############### CALC. PARALLEL & PERPENDICULAR MOMENTA ################
C#######################################################################
C
      DO 3200 I       = 1 , NC
C
         DO 3210 J    = 1 , NJ(I)
C
            JM1       = J - 1
            JP1       = J + 1
            IF( JM1.LT.1     ) JM1 = NJ(I) - 1
            IF( JP1.GT.NJ(I) ) JP1 = 2
C
            K         = KORY(I,J)
            KM1       = KORY(I,JM1)
            KP1       = KORY(I,JP1)
C
            IF( ITAG(K,4).LT.0 ) GOTO 3210
C
            PFMOMX    = PROFMN(K)
            PFMOMY    = PROFMP(K)
C
            IF( ITAG(K,4).NE.4 ) THEN
                RDIFF = RMESH(KM1) - RMESH(K)
                ZDIFF = ZMESH(KM1) - ZMESH(K)
CW              IF( ITAG(K,4).EQ.5 ) THEN
CW              WRITE(LOUT,*) ' LINK I=',I,' J=',J,' TAG=',ITAG(K,4)
CW              WRITE(LOUT,*) '     R(J)=',RMESH(K),  '   Z(J)=',ZMESH(K)
CW              WRITE(LOUT,*) '   R(J-1)=',RMESH(KM1),' Z(J-1)=',ZMESH(KM1)
CW              WRITE(LOUT,*) '       MR=',PFMOMX    ,'     MZ=',PFMOMY
CW              END IF
            ELSE
                RDIFF = RMESH(K)   - RMESH(KP1)
                ZDIFF = ZMESH(K)   - ZMESH(KP1)
CW              WRITE(LOUT,*) ' LINK I=',I,' J=',J,' TAG=',ITAG(K,4)
CW              WRITE(LOUT,*) '     R(J)=',RMESH(K),  '   Z(J)=',ZMESH(K)
CW              WRITE(LOUT,*) '   R(J+1)=',RMESH(KP1),' Z(J+1)=',ZMESH(KP1)
CW              WRITE(LOUT,*) '       MR=',PFMOMX    ,'     MZ=',PFMOMY
            END IF
C
            RZLEN     = DSQRT( RDIFF*RDIFF + ZDIFF*ZDIFF )
            COSA      = ZDIFF / RZLEN
            SINA      = RDIFF / RZLEN
C
C         RADIAL:
            PROFMN(K) = + PFMOMX*COSA - PFMOMY*SINA
C         POLOIDAL:
            PROFMP(K) = - PFMOMY*COSA - PFMOMX*SINA
            DO L=1,NION
              VNUTAP(K,L) = - VA(2,K,L)*COSA - VA(1,K,L)*SINA
              VNUTMP(K,L) = - VM(2,K,L)*COSA - VM(1,K,L)*SINA
            ENDDO
CW          IF(ITAG(K,4).EQ.4 .OR. ITAG(K,4).EQ.5) THEN
CW            WRITE(LOUT,*) '     COSA=',COSA,      '   SINA=',SINA
CW            WRITE(LOUT,*) '   PROFMN=',PROFMN(K),
CW   &                   ' =',+PFMOMX*COSA,-PFMOMY*SINA
CW            WRITE(LOUT,*) '   PROFMP=',PROFMP(K),
CW   &                   ' =',-PFMOMY*COSA,-PFMOMX*SINA
CW          ENDIF
C         PARALLEL:
            PROFMP(K) = PROFMP(K)*SH(K)
     &                + PROFMF(K)*DSQRT(1.0D0-SH(K)**2)*BSIGN
            DO L=1,NION
              VNUTAP(K,L) = VNUTAP(K,L)*SH(K)
     &                    + VA(3,K,L)*DSQRT(1.0D0-SH(K)**2)*BSIGN
              VNUTMP(K,L) = VNUTMP(K,L)*SH(K)
     &                    + VM(3,K,L)*DSQRT(1.0D0-SH(K)**2)*BSIGN
            ENDDO
C=================
CW          IF(ENEUTA(K).NE.0.0D0) THEN
CW            EKINP = 0.5D0*HMASS*VNUTAP(K)**2
CW   &              * 1.6726D-24 / 1.6022D-12
CW            CALL XS(TEMPE(K),TEMPI(K),ENEUTA(K),SVI,TRAN,SVCX,TRAN,
CW   &                TRAN,TRAN,TRAN,TRAN,TRAN,TRAN)
CW            DI = DENSE(K)
CW            IF(IMPURE.NE.0) DI = DENSI(K)
CW            SMOMP = HMASS*1.6726D-24*PROFA(K)*( DENSE(K)*SVI*VNUTAP(K)
CW   &                                   +DI*SVCX*(VNUTAP(K)-VPAR(K)))
CW            WRITE(LOUT,3207) K,ITAG(K,4),
CW   &                      ENEUTA(K),EKINP,PROFMP(K)*SH(K),SMOMP
C3207         FORMAT(' LINK K=',I3,' TAG=',I2,
CW   &               ' E=',1P,E9.2,' EKP=',E9.2,
CW   &               ' FMC=',E9.2,' FF=',E9.2)
CW          ENDIF
C=================
C
 3210    CONTINUE
C
 3200 CONTINUE
C
C#######################################################################
C############################# CHECKS ##################################
C#######################################################################
C
C...............PRINT-OUT K,N,M & NIMBUS CELL INFORMATION...............
C
      IF( IFILE.GT.0 ) THEN
C
          IF( LPOUT ) WRITE(IPRINT,1400)
C
          DO 3950 K    = 1 , NP
             N         = KORPG(K)
             IF( N.GT.0 ) THEN
                 DO 3960 J = 1 , NM(N)
                    M      = KORM(N,J)
                    IF( J.EQ.1 ) THEN
                        IF( LPOUT )
     >                    WRITE(IPRINT,1410) K,N,M,(MZONE(M,J1),J1=1,2)
                    ELSE
                        IF( LPOUT )
     >                    WRITE(IPRINT,1420)     M,(MZONE(M,J1),J1=1,2)
                    END IF
 3960            CONTINUE
             END IF
 3950     CONTINUE
C
      END IF
C
      IF( LCHECK .AND. IPRINT.GT.0 .AND. IFILE.GT.0 ) THEN
C
C.........COMPARE POLYGON AREA CALCULATION OF GRID2D WITH NIMBUS........
C
          IF( LPOUT ) THEN
              WRITE(IPRINT,1300)
              WRITE(IPRINT,1310)
          END IF
C
          AGRID        = 0.00D+00
          ANIM         = 0.00D+00
C
          DO 3900 N    = 1 , NPOLYP
C
             AGRID     = AGRID + AREAP(N)
             ANIM      = ANIM  + VOLP(N)
             PDIFF     = 1.00D+02 - VOLP(N) * 1.00D+02 / AREAP(N)
             IF( LPOUT )
     >           WRITE(IPRINT,1320) N , AREAP(N) , VOLP(N) , PDIFF
C
             DO 3910 J = 1 , NM(N)
                M      = KORM(N,J)
                PDIFF  = 1.00D+02 - VOLM(M) * 1.00D+02 / AREAM(M)
                IF( LPOUT )
     >              WRITE(IPRINT,1330) M , AREAM(M) , VOLM(M) , PDIFF
 3910        CONTINUE
C
 3900     CONTINUE
C
          PDIFF        = 1.00D+02 - ANIM * 1.00D+02 / AGRID
          IF( LPOUT ) THEN
              WRITE(IPRINT,1350)
              WRITE(IPRINT,1340) AGRID , ANIM , PDIFF
          END IF
C
C........................PRINT-OUT PROFILES.............................
C
          CALL RESETR( BUFFER(1) , 13 , 0.00D+00 )
C
          IF( LPOUT ) WRITE(IPRINT,1360)
          DO 3920 I    = 1 , NC
             DO 3925 J = 1 , NJ(I)
                K      = KORY(I,J)
                N      = KORPG(K)
                IF( ITAG(K,4).LT.0 ) GOTO 3925
                IF( LPOUT )
     >            WRITE(IPRINT,1370) K , KORPG(K)
     &               , PROFA(K,IU)  , PROFM(K,IU)  , PROFZ(K,IU)
     &               , ENEUTA(K,IU) , ENEUTM(K,IU) , ENEUTZ(K,IU)
                BUFFER(01) = BUFFER(01) + PROFA(K,IU) * VOLP(N)
                BUFFER(02) = BUFFER(02) + PROFM(K,IU) * VOLP(N)
                BUFFER(03) = BUFFER(03) + PROFZ(K,IU) * VOLP(N)
 3925        CONTINUE
 3920     CONTINUE
CX        WRITE(IPRINT,1365)
CX        WRITE(IPRINT,1375) ( BUFFER(K) , K = 1 , 3 )
C
          IF( LPOUT ) WRITE(IPRINT,1380)
          DO 3930 I    = 1 , NC
             DO 3935 J = 1 , NJ(I)
                K      = KORY(I,J)
                N      = KORPG(K)
                IF( ITAG(K,4).LT.0 ) GOTO 3935
                IF( LPOUT )
     >            WRITE(IPRINT,1370) K , KORPG(K)
     &            , PROFSN(K,IU)   , PROFQ(K) , PROFQE(K)
     &            , PROFSZ(K,IU) , PROFMP(K) , PROFMN(K)
     &            , PROFHA(K)
                BUFFER(07) = BUFFER(07) + PROFSN(K,IU) * VOLP(N)
                BUFFER(08) = BUFFER(08) + PROFQ(K)     * VOLP(N)
                BUFFER(09) = BUFFER(09) + PROFQE(K)    * VOLP(N)
                BUFFER(10) = BUFFER(10) + PROFSZ(K,IU) * VOLP(N)
                BUFFER(11) = BUFFER(11) + PROFMP(K) * VOLP(N)
                BUFFER(12) = BUFFER(12) + PROFMN(K) * VOLP(N)
                BUFFER(13) = BUFFER(13) + PROFHA(K) * VOLP(N)
 3935        CONTINUE
 3930     CONTINUE
          IF( LPOUT ) THEN
              WRITE(IPRINT,1385)
              WRITE(IPRINT,1375) ( BUFFER(K) , K = 7 , 13 )
          END IF
C
C.......................................................................
C
      END IF
C
C#######################################################################
C#######################################################################
C#######################################################################
C
 1000 FORMAT( 5X  , '2'  ,5X,'0'
     &      / ' EDGE2D/NIMBUS INTERFACE CALLED AT STEP ', I6
     &      / ' SHOT NO.',I6,3X,A,
     &      / I6 , I1 , T25 , I6 , I1, I1 , I1, I1, I1
     &      , T37 , I1 , I1 , I1 , I1, T42 , '1' , I6, 6X, I4
     &      , T65 , I1 , I1
     &      , T67 , 1P , E6.0
     &      / 3I3 , 1X , 6X , 10I3 , I3
     &      / I3  , 3E12.4
     &      / A80 )
 1001 FORMAT( 1P, 4E12.4
     &      / I6  , 2X,A2,2X,1P,E12.4 , I6 , I6 , '  MIMP,IGOPT'
     &      / I6 , '     0  0000' , 4I6 )
 1005 FORMAT( '    0    0    0   -1' , I5 ,'    0' , 3I5 )
 1040 FORMAT( 72A1 )
 1050 FORMAT( 12F6.2 )
 1060 FORMAT( 12I6 )
 1062 FORMAT( 24I3 )
 1064 FORMAT( 2I8 , '   (CURRENT & PREVIOUS M.C TANK IDENTIFIER)' )
 1065 FORMAT( 1P,E12.3,2I6,'  TSLICE')
 1070 FORMAT( 1X , I1 , I4 , 7F6.2 , I6 , F6.2 , F6.2 , T72 , '!' )
 1080 FORMAT( I6 , 6F6.3 )
 1085 FORMAT( I6 , ' IOPTRC' )
 1090 FORMAT( 1X , A3 , 2X , F6.3 , T68,'RECMAT',T13,1P,3E12.4)
 1110 FORMAT( ' 1' , I4 , 1P , 4E12.4 , 2I3 , A1 , 1X , A4 , A1 )
 1125 FORMAT(        I6 , 1P , 5E12.4 )
 1126 FORMAT(        I6 , 1P , 4E12.4 , I8 , A1 , I8 , A1
     &       ,       3X ,'(' , A      , ')', I1 )
 1127 FORMAT(        I6 , 1P , 4E12.4 , 25X , I1 )
 1128 FORMAT(        I6 , 1P , 4E12.4 , A8 , 1X , A8 )
 1129 FORMAT(        I6 , 1P , 3E12.4 )
 1132 FORMAT( I6 , 2X , 'TRIM' )
 1134 FORMAT( 2X , A4 , 2X , A4 , A )
 1135 FORMAT( I6,A4,F6.2,F6.2,14X , 'LIGHT RECYCLING IMPURITY')
 1140 FORMAT( I6  , 30X , 'OUTPUT ENERGY MESH' )
 1150 FORMAT( I6,F6.1,I6 ,10X, 'LOADS & SPUTTERING ALONG WALL SEGMENTS')
 1160 FORMAT( 1P , E12.4 , 0P , F6.1 , 2I6 , F6.1, T60, 'H SOURCE')
 1161 FORMAT( I6, I6, 2X, A4, 1P, E12.4, T60, 'Z SOURCE')
 1170 FORMAT( 1P , 4E12.4 )
 1175 FORMAT( 1P , 3E12.4 ,'     0'/E12.4,3E12.4)
 1176 FORMAT( 1P , 6E12.4 )
 1180 FORMAT( 12F6.0 )
 1200 FORMAT( A , I4 , A , I4 ,A , I4 )
 1205 FORMAT( A , I4 , A , I4 ,A , 1P , E12.4 )
 1210 FORMAT( ' POLOIDAL SOURCE = ' , 1P , E12.3 , ' PERP.' , E12.3 ,
     &        ' TOTAL' , E12.3 )
 1220 FORMAT( 80A )
 1230 FORMAT( I12 , 5E12.0 )
 1231 FORMAT( 12X , 2E12.0 )
 1232 FORMAT( I12 , 1Z16 )
 1233 FORMAT( 12X , 5E12.0 , 5(/12X , 5E12.0) )
 1240 FORMAT( 6E12.0 )
 1242 FORMAT( 5Z16 )
 1245 FORMAT( 12I5 )
 1246 FORMAT( I5 , 3X , I6 )
 1250 FORMAT( ' RGAMMA = ' , 1P , E12.3 , ' TOTION = ' , E12.3 ,
     &        ' SOLION = ' ,      E12.3 , ' TOTHES = ' , E12.3 ,
     &        ' TOTZSP = ' ,      E12.3 , ' TOTZES = ' , E12.3   )
 1300 FORMAT(1H1
     &       / ' GRID2D & NIMBUS POLYGON AREA COMPARISON ( CM**2 ) :-')
 1310 FORMAT( '    N    M   A(GRID2D)   A(NIMBUS)    %DIFF'
     &      / ' ---- ---- ----------- ----------- --------' )
 1320 FORMAT( I5 , 5X , 1P , 2E12.4 , 0P , F8.2 ,'%')
 1330 FORMAT( 5X , I5 , 1P , 2E12.4 , 0P , F8.2 ,'%')
 1340 FORMAT( 5X , 5X , 1P , 2E12.4 , 0P , F8.2 ,'%')
 1350 FORMAT( '           =========== =========== =======')
 1360 FORMAT( 1H1
     &        / '    K    N       PROFA       PROFM       PROFZ      ENE
     &UTA      ENEUTM      ENEUTZ'
     &        / ' ---- ---- ----------- ----------- ----------- --------
     &--- ---------- -----------' )
 1365 FORMAT( 10X , 6(' ===========' ) )
 1370 FORMAT( 2I5 , 1P , 7E12.4 )
 1375 FORMAT( 10X , 1P , 7E12.4 )
 1380 FORMAT( 1H1
     &        / '    K    N      PROFSN       PROFQ      PROFQE      PRO
     &FSZ    PROFMP      PROFMN      PROFHA'
     &        / ' ---- ---- ----------- ----------- ----------- --------
     &--- ---------- ----------- -----------' )
 1385 FORMAT( 10X , 7(' ===========' ) )
 1400 FORMAT( 1H1
     &        / ' PLASMA & NIMBUS GEOMETRICAL CROSS-REFERENCE :-'
     &        / '     K      N      M  CHANNEL  CELL'
     &        / ' -----  -----  -----  -------  ----' )
 1410 FORMAT( 1X , 3( I5 , 2X ) , I7 , 2X , I4 )
 1420 FORMAT( 15X,    I5 , 2X   , I7 , 2X , I4 )
 1430 FORMAT(
     &/'1ISEG TYPE        FLUX    ADJ.DIST      SOURCE      WEIGHT
     &     R        VPAR          NI          NE          TI          TE
     &'
     &/' ---- ---- ----------- ----------- ----------- ----------- -----
     &------ ----------- ----------- ----------- ----------- -----------
     &' )
 1440 FORMAT( 1X , I4 , 1X , A , 1P , 10E12.4 )
 1450 FORMAT(
     &/'1ISEG     M        R1        Z1         R2       Z2    LENGTH(IN
     &)    LENGTH(OUT)         RHOIN        RHOOUT'
     &/' ---- ----- --------- --------- ---------- -------- ------------
     &- -------------- ------------- -------------')
 1460 FORMAT( I5 , I6 , 4F10.3 , 1P , 4E14.4 )
 1470 FORMAT( / ' ( LINKPG VERSION = ' , A
     &        , ' : ICODE = '  , I1
     &        , ' ; LWALL = '  , L1
     &        , ' ; LPWALL = ' , L1
     &        , ' ; LBUFLE = ' , L1
     &        , ' ; LPSEG = ' , L1
     &        , ' ; LPMPST = ' , L1 , ' ) ' / )
C
 8010 FORMAT( ' LINKPG: H(' , I1 , ')-IMPLANTATION FLUX TO '
     &      , A , 1P , E12.5 )
C
 9050 FORMAT( / ' *** ERROR *** LINKPG : TOO MANY WALL SEGMENT COORD.'
     &        , ' M = ' , I6 , ' NCOORDS = ' , I6 )
 9070 FORMAT( / ' *** ERROR *** LINKPG : ACTUAL NIMBUS VESSEL COORINATES
     & (' , I6 ,') EXCEEDS MAXIMUM ALLOWED ' , I6 , ')' / )
 9075 FORMAT( / ' *** ERROR *** LINKPG : ACTUAL NIMBUS VESSEL COORINATES
     & + PUMP STRUCTURE (' , I6 ,') EXCEEDS MAXIMUM ALLOWED '
     &        , I6 , ')' / )
 9080 FORMAT( / ' *** ERROR *** LINKPG : ' , A , ' (' , I6
     &      ,   '), READ FROM PUNCH FILE, EXCEEDS MAX. DIMENSION (' , I6
     &      ,   ') IN EDGE2D' / )
 9100 FORMAT( ' *** WARNING(LINKPG) PUMP ' , A , ' VERTEX #' , I2 , 1X
     &      , A , ' COORD HAS BEEN MOVED FROM ' , 1PE12.4 , ' TO '
     &      , E12.4 , ' (GEOMETRY RECTANGLE)' )
 9110 FORMAT(/' *** ERROR(LINKPG) PUMP ' , A , ' VERTEX #' , I2
     &      , ' LIES ON VESSEL : VESSEL SEGMENT #' , I5 , 1P
     &      / 19X , 'PUMP (R,Z) = (' , E12.5 , ',' , E12.5 , ')'
     &      / 19X , 'SEG1 (R,Z) = (' , E12.5 , ',' , E12.5 , ')'
     &      / 19X , 'SEG2 (R,Z) = (' , E12.5 , ',' , E12.5 , ')' /)
 9120 FORMAT(/' *** ERROR(LINKPG) PUMP SEGMENT BLOCK (' , I2
     &       , ') MATCHING PUMP STRUCTURE POLYGON # ' , I2
     &       / '                   HAS DATA POINT (' , I2
     &       , ') POINTING TO POLYGON VERTEX ' , I2
     &       / '                   WHICH DOES NOT EXIST.' /)
 9150 FORMAT(/ ' *** LINKPG HAS BEEN STOPPED BEFORE CALL TO NIMBUS'
     &       / '     BECAUSE LMC HAS BEEN SET TO TRUE IN /NIMBIN/.'
     &      // ' *** TO PLOT THE "MC" FILE, YOU WILL NEED TO USE THE'
     &       / '     "PLOTPG" PROGRAM ON THE MAINFRAME.')
 9160 FORMAT(/' *** ERROR(LINKPG) NEGATIVE CHARGE FOR A SOURCE SEGMENT'
     &       /'                   K=',I5,'  KZ=',I5, '  ZZ=',1PE12.4 )
 9210 FORMAT(/ ' *** ERROR(LINKPG) : FPWALL() IS NOT ' , A , / )
C
C-----------------------------------------------------------------------
C
 9999 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE RESETG(IV,N0,N1,IA)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION IV(N1)
C
      DO 10 I=N0,N1
         IV(I)=IA
   10 CONTINUE
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE REVERS( N , A )
      IMPLICIT REAL*8(A-H,O-Z)
C
C.......................................................................
C
C ROUTINE : REVERS
C
C VERSION : V1.R1.M0
C
C PURPOSE : TO REVERSE THE ORDER OF ARRAY A(N)
C
C INPUT   : (I*4) N      = ORDER OF ARRAY
C
C I/O     : (R*8) A()    = ARRAY BEING REORDERED
C
C PROGRAM : (R*8) TRAN   = TEMPORARY REAL*8 VARIABLE
C
C AUTHOR  : J.SPENCE  (K1/0/80)  EXT. 4865
C
C HISTORY : 26/08/93 --- V1.R1.M0 --- CREATION
C
C.......................................................................
C
      DIMENSION A(N)
C
      DO I        = 1 , N/2
         TRAN     = A(I)
         A(I)     = A(N-I+1)
         A(N-I+1) = TRAN
      ENDDO
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE REVERI( N , IA )
      IMPLICIT REAL*8(A-H,O-Z)
C
C.......................................................................
C
C ROUTINE : REVERS
C
C VERSION : V1.R1.M0
C
C PURPOSE : TO REVERSE THE ORDER OF ARRAY A(N)
C
C INPUT   : (I*4) N      = ORDER OF ARRAY
C
C I/O     : (I*4) IA()   = ARRAY BEING REORDERED
C
C PROGRAM : (I*4) ITRAN  = TEMPORARY INTEGER*4 VARIABLE
C
C AUTHOR  : J.SPENCE  (K1/0/80)  EXT. 4865
C
C HISTORY : 04/12/98 --- V1.R1.M0 --- CREATION
C
C.......................................................................
C
      DIMENSION IA(N)
C
      DO I         = 1 , N/2
         ITRAN     = IA(I)
         IA(I)     = IA(N-I+1)
         IA(N-I+1) = ITRAN
      ENDDO
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE GETVTX( NVERTM , ITAGM  , MP
     &                 , M      , I      , IP1
     &                 , NIP1   , IVERT1 , IVERT2
     &                 , NI     , IVERT3 , IVERT4        )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO ASSIGN VERTICES
C
C INPUT   : M           = NIMBUS POLYGON UNDER INVESTIGATION
C           NVERTM(M)   = NUMBER OF VERTICES IN NIMBUS POLYGON # M
C           ITAGM(M,1)  = PLASMA POLYGON IN WHICH NIMBUS POLYGON#M LIES
C                (M,3)  = 0 --- PLASMA ABOVE & BELOW PLASMA POLYGON # N
C                         5 --- PLASMA ABOVE         PLASMA POLYGON # N
C                         4 --- PLASMA         BELOW PLASMA POLYGON # N
C                (M,K)  = THE RING VERTEX K-2 (K=3,...,10) LIES ON
C
C OUTPUT  : NIP1        = NUMBER OF VERTICIES ON UPPER RING
C           IVERT1      = 1ST VERTEX ON UPPER RING (ANIT-CLOCKWISE ORDER
C           IVERT2      = 2ND VERTEX ON UPPER RING (ANTI-CLOCKWISE ORDER
C           NI          = NUMBER OF VERTICIES ON LOWER RING
C           IVERT3      = 1ST VERTEX ON LOWER RING (ANIT-CLOCKWISE ORDER
C           IVERT4      = 2ND VERTEX ON LOWER RING (ANTI-CLOCKWISE ORDER
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 18/06/90
C
C HISTORY : V1.R1.M0 --- 18/06/90 --- CREATION
C           V2.R1.M0 --- 09/11/98 --- REMOVE NDIM FROM ARGUMENT LIST
C                                     AS NEVER USED
C                                 --- REMOVE WRITE AS COMMENTED OUT
C
C-----------------------------------------------------------------------
C
      DIMENSION NVERTM(MP)  , ITAGM(MP,10)
C
C-----------------------------------------------------------------------
C
      IVERT1 = 0
      IVERT2 = 0
      IVERT3 = 0
      IVERT4 = 0
      NIP1   = 0
      NI     = 0
C
C-----------------------------------------------------------------------
C
      DO 100 IVERT      = 1 , NVERTM(M)
C
         IF( ITAGM(M,IVERT+2).EQ.IP1 ) THEN
             NIP1       = NIP1 + 1
             IF( IVERT1.EQ.0 ) THEN
                 IVERT1 = IVERT
             ELSE
                 IVERT2 = IVERT
             END IF
         END IF
C
         IF( ITAGM(M,IVERT+2).EQ.I ) THEN
             NI         = NI   + 1
             IF( IVERT3.EQ.0 ) THEN
                 IVERT3 = IVERT
             ELSE
                 IVERT4 = IVERT
             END IF
         END IF
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      IF( IVERT2.EQ.0 ) IVERT2 = IVERT1
      IF( IVERT4.EQ.0 ) IVERT4 = IVERT3
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE READPG( IREAD  , IFAIL )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO READ PLASMA/NIMBUS POLYGONS CREATED BY GRID2D
C
C INPUT   : IREAD       = READ FILE ON STREAM 'IREAD'
C
C OUTPUT  : IFAIL       = 0 --- ROUTINE SUCCESSFUL
C                         1 --- ROUTINE FAILED
C
C /CPOLYG/: (SEE 'c09')
C
C NOTE    : (1) CONVERTION FROM MKS UNITS TO CGS UNITS OCCURS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 05/06/90
C
C UPDATE  : 29/06/90 --- COMMON BLOCK /CPOLYG/
C           01/11/90 --- MITP , MITM , NPG , IDTAGP() & IDTAGM()
C           07/11/90 --- RHOIN() & RHOOUT()
C           16/04/91 --- NVES, RVES() & ZVES()
C           06/05/92 --- NBUFLE, RBUFLE() & ZBUFLE()
C           24/06/92 --- ITAGDP(,)
C           03/02/93 --- CHECKS FOR DIMENSION SIZE
C           08/10/93 --- REMOVE IDENTICAL ADJACIENT VESSEL POINTS
C                        AND FORCE VESSEL TO BE ORDERED CLOCKWISE
C           17/01/94 --- COPY RBUFLE(1),ZBUFLE(1) TO NBUFLE+1 ELEMENTS
C           27/06/97 --- NBUFX(), RBUFX(,) & ZBUFX(,)
C           06/11/98 --- DELETE RCENT0 & ZCENT0 AS NEVER USED
C           22/11/98 --- IESCF INTO EQUILIBRIUM FILE
C
C-----------------------------------------------------------------------
C
C..LOGICAL UNIT NUMBERS
      INCLUDE  'plun'
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C-----------------------------------------------------------------------
C
      DIMENSION SEARCH(2) , RGEN1(3) , ZGEN1(3)
      CHARACTER STRING*80 , SEARCH*7
C
      DATA SEARCH/' NPOLYP' , 'NVES   ' /
C
C--------------------------- INITIALISATION ----------------------------
C
      CALL RESETI( IDTAGP(1)   , MPG    , 0 )
      CALL RESETI( IDTAGM(1,1) , MPG*10 , 0 )
C
      CALL RESETI( ITAGDP(1,1) , MPG*5  , 0 )
C
      NBUFMX = 0
      CALL RESETI( NBUFX(1)    , MBUFX  , 0 )
C
      IESCF = 0
C
C-----------------------------------------------------------------------
C
      REWIND IREAD
C
C-----------------------------------------------------------------------
C
      IFAIL = 1
C
   10 READ(IREAD,1000,END=9999) STRING
      IF( STRING(1:7).NE.SEARCH(1).AND.STRING(1:7).NE.SEARCH(2) )GOTO 10
C
      IFAIL = 0
C
C-----------------------------------------------------------------------
C
      IF( STRING(1:4).EQ.'NVES' ) THEN
          READ(IREAD,1025)   NVES
          IF( NVES.GT.MVES ) THEN
              WRITE(LOUT,9020) NVES , MVES
              CALL EXITX(LOUT)
          END IF
          READ(IREAD,1030) ( RVES(K) , K = 1 , NVES )
          READ(IREAD,1030) ( ZVES(K) , K = 1 , NVES )
C
          READ(IREAD,1000) STRING
          IF( STRING(1:6).EQ.'NBUFLE' ) THEN
              READ(IREAD,1025) NBUFLE
              IF( NBUFLE.GT.MBUFLE ) THEN
                  WRITE(LOUT,9030) NBUFLE , MBUFLE
                  CALL EXITX(LOUT)
              END IF
              READ(IREAD,1030) ( RBUFLE(K) , K = 1 , NBUFLE )
              READ(IREAD,1030) ( ZBUFLE(K) , K = 1 , NBUFLE )
C
              READ(IREAD,1000) STRING
              IF( STRING(1:6).EQ.'NBUFMX' ) THEN
                  READ(IREAD,1025) NBUFMX
                  IF( NBUFMX.GT.MBUFX ) THEN
                      WRITE(LOUT,9033) NBUFMX , MBUFX
                      CALL EXITX(LOUT)
                  END IF
                  DO I = 1 , NBUFMX
                     READ(IREAD,1020) NBUFX(I)
                     IF( NBUFX(I).GT.MBUFLE ) THEN
                         WRITE(LOUT,9035) I , NBUFX(I) , MBUFLE
                         CALL EXITX(LOUT)
                     END IF
                     READ(IREAD,1030) ( RBUFX(I,K) , K = 1 , NBUFX(I) )
                     READ(IREAD,1030) ( ZBUFX(I,K) , K = 1 , NBUFX(I) )
                  ENDDO
                  READ(IREAD,1030) ( GEOM(K)   , K = 5 , 6  )
              ELSE
                  READ(IREAD,1040) ( GEOM(K)   , K = 5 , 6  )
              END IF
C
          ELSE
              READ(IREAD,1040) ( GEOM(K)   , K = 5 , 6      )
          END IF
          READ(IREAD,1000) STRING
      ELSE
          NVES   = 0
          NBUFLE = 0
      END IF
C
      READ(IREAD,1010) NPOLYP , NPOLYM , MITP , MITM , NPG , IESCF
C
      IF( NPOLYP.GT.MPG .OR. NPOLYM.GT.MPG ) THEN
          WRITE(LOUT,9000) NPOLYP , NPOLYM , MPG
          CALL EXITX(LOUT)
      END IF
C
      IF( IESCF.LT.0 .OR. IESCF.GT.1 ) THEN
          WRITE(LOUT,9060) IESCF
          CALL EXITX(LOUT)
      END IF
C
      IF( MITP.LE.0 ) MITP = 3
      IF( MITM.LE.0 ) MITM = 6
      IF( NPG .LE.0 ) NPG  = MPG
C
      READ(IREAD,1015) NCPG , NXWPG , LCFSPG , (GEOM(K),K=1,4)
      NXPG = 0
      IF( NCPG.NE.NXWPG ) NXPG = 1
C
      IF( NCPG.GT.MCG ) THEN
          WRITE(LOUT,9010) NCPG , MCG
          CALL EXITX(LOUT)
      END IF
C
      READ(IREAD,1020)( NJPOLY(I) , I=1,NCPG)
C
      READ(IREAD,1020)( NJP(I) , I=1,NCPG)
C
      READ(IREAD,1020) ( ( KORP(I,J) , J=1,NJP(I) ) , I=1,NCPG )
C
      READ(IREAD,1020) ( NM(N) , N=1,NPOLYP)
C
      READ(IREAD,1020) ( ( KORM(N,K) , K=1,NM(N) ) , N=1,NPOLYP )
C
      READ(IREAD,1020) ( ( ITAGP(N,K) , K=1,MITP ) , N=1,NPOLYP )
C
      READ(IREAD,1020) ( ( ITAGM(M,K) , K=1,MITM ) , M=1,NPOLYM )
C
      READ(IREAD,1020) ( NVERTP(N) , N=1,NPOLYP )
C
      READ(IREAD,1020) ( NVERTM(M) , M=1,NPOLYM )
C
      READ(IREAD,1030) ( ( RVERTP(N,K) , K=1,5 ) , N=1,NPOLYP )
C
      READ(IREAD,1030) ( ( ZVERTP(N,K) , K=1,5 ) , N=1,NPOLYP )
C
      READ(IREAD,1030) ( AREAP(N) , N=1,NPOLYP )
C
      READ(IREAD,1030) ( ( RVERTM(M,K) , K=1,NVERTM(M) ) , M=1,NPOLYM )
C
      READ(IREAD,1030) ( ( ZVERTM(M,K) , K=1,NVERTM(M) ) , M=1,NPOLYM )
C
      READ(IREAD,1030) ( AREAM(M) , M=1,NPOLYM )
C
      READ(IREAD,1030) ( ( RPOLY(I,J) , J=NJPOLY(I),1,-1 ) , I=1,NCPG )
C
      READ(IREAD,1030) ( ( ZPOLY(I,J) , J=NJPOLY(I),1,-1 ) , I=1,NCPG )
C
      READ(IREAD,1020) ( KORKG(N) , N=1,NPOLYP )
C
      READ(IREAD,1020,END=15) ( KORPG(K) , K=1,NPG )
C
      READ(IREAD,1020,END=15) ( IDTAGP(N) , N=1,NPOLYP )
C
      READ(IREAD,1020,END=15) ((IDTAGM(M,K),K=1,NVERTM(M)+1),M=1,NPOLYM)
C
      READ(IREAD,1030,END=15) ( RHOIN(N)  , N=1,NPOLYP )
C
      READ(IREAD,1030,END=15) ( RHOOUT(N) , N=1,NPOLYP )
C
      READ(IREAD,1020,END=15) ( ( ITAGDP(N,K) , K=1,5 ) , N=1,NPOLYP )
C
C-----------------------------------------------------------------------
C
   15 REWIND IREAD
C
C--------------REMOVE DUPLICATE POINTS EXCEPT FIRST & LAST--------------
C
      DO 100    I = 1 , NCPG
C
   20    DO 150 J = 1 , NJPOLY(I) - 1
            IF( RPOLY(I,J).EQ.RPOLY(I,J+1) .AND.
     &          ZPOLY(I,J).EQ.ZPOLY(I,J+1)       ) GOTO 199
  150    CONTINUE
         GOTO 100
C
  199    DO 200 J0 =  1 , NJPOLY(I) - 1
            IF( J0.GT.J ) THEN
                RPOLY(I,J0)  = RPOLY(I,J0+1)
                ZPOLY(I,J0)  = ZPOLY(I,J0+1)
            END IF
  200    CONTINUE
         NJPOLY(I) = NJPOLY(I) - 1
         GOTO 20
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      IF( NVES.LE.0 ) THEN
          GEOM(5)  = GEOM(1) + GEOM(3)*5.0D-01
          GEOM(6)  = GEOM(2) + GEOM(4)*5.0D-01
      ENDIF
C
C-----------------------MKS TO CGS UNIT CONVERSION----------------------
C
      DO 300 K              = 1 , 6
         GEOM(K)            = GEOM(K) * 1.0D+02
  300 CONTINUE
C
      DO 400 N              = 1 , NPOLYP
         AREAP(N)           = AREAP(N) * 1.0D+04
         DO 450 IVERT           = 1 , NVERTP(N) + 1
            RVERTP(N,IVERT) = RVERTP(N,IVERT) * 1.0D+02
            ZVERTP(N,IVERT) = ZVERTP(N,IVERT) * 1.0D+02
  450    CONTINUE
  400 CONTINUE
C
      DO 500 M              = 1 , NPOLYM
         AREAM(M)           = AREAM(M) * 1.0D+04
         DO 550 IVERT           = 1 , NVERTM(M) + 1
            RVERTM(M,IVERT) = RVERTM(M,IVERT) * 1.0D+02
            ZVERTM(M,IVERT) = ZVERTM(M,IVERT) * 1.0D+02
  550    CONTINUE
  500 CONTINUE
C
      DO 600 I              = 1 , NCPG
         DO 650 J           = 1 , NJPOLY(I)
            RPOLY(I,J)      = RPOLY(I,J)      * 1.00D+02
            ZPOLY(I,J)      = ZPOLY(I,J)      * 1.00D+02
  650    CONTINUE
  600 CONTINUE
C
C.............................. VESSEL .................................
C
      IF( NVES.GT.0 ) THEN
C
C.. REMOVE IDENTICAL ADJACIENT COORDS
          I                 = 1
          RVES(I)           = RVES(1)
          ZVES(I)           = ZVES(1)
          DO 700 K          = 2 , NVES
             IF( RVES(K).NE.RVES(I) .OR. ZVES(K).NE.ZVES(I) ) THEN
                 I          = I + 1
                 RVES(I)    = RVES(K)
                 ZVES(I)    = ZVES(K)
             END IF
  700     CONTINUE
C
          NVES              = I + 1
          RVES(NVES)        = RVES(1)
          ZVES(NVES)        = ZVES(1)
C
C.. CONVERT MKS TO CGS UNITS
          DO 710 I          = 1 , NVES
             RVES(I)        = RVES(I)         * 1.00D+02
             ZVES(I)        = ZVES(I)         * 1.00D+02
  710     CONTINUE
C
C.. VESSEL ORDER
          IVWISE            = 0
C
          RGEN1(3)          = GEOM(5)
          ZGEN1(3)          = GEOM(6)
C
          DO 720 IV         = 1 , NVES - 1
C
             RGEN1(1)       = RVES(IV)
             ZGEN1(1)       = ZVES(IV)
C
             RGEN1(2)       = RVES(IV+1)
             ZGEN1(2)       = ZVES(IV+1)
C
             CALL POLCHK( 0 , 3 , RGEN1(1) , ZGEN1(1) , 0 , IER )
C
             IF( IER.EQ.0 ) THEN
                 IVWISE     = -1
                 GOTO 725
             ELSE IF( IER.EQ.2 ) THEN
                 IVWISE     = + 1
                 GOTO 725
             END IF
C
  720     CONTINUE
C
  725     IF( IVWISE.EQ.0 ) THEN
              WRITE(LOUT,9040)
              CALL EXITX(LOUT)
          ELSE IF( IVWISE.LT.0 ) THEN
              WRITE(LOUT,9050)
              CALL REVERS( NVES , RVES(1) )
              CALL REVERS( NVES , ZVES(1) )
          END IF
C
      END IF
C
C.......................................................................
C
      IF( NBUFLE.GT.0 ) THEN
          DO 730 K          = 1 , NBUFLE
             RBUFLE(K)      = RBUFLE(K)       * 1.00D+02
             ZBUFLE(K)      = ZBUFLE(K)       * 1.00D+02
  730     CONTINUE
      END IF
C
      RBUFLE(NBUFLE+1)      = RBUFLE(1)
      ZBUFLE(NBUFLE+1)      = ZBUFLE(1)
C
      DO I = 1 , NBUFMX
         DO 735 K           = 1 , NBUFX(I)
             RBUFX(I,K)     = RBUFX(I,K)       * 1.00D+02
             ZBUFX(I,K)     = ZBUFX(I,K)       * 1.00D+02
  735     CONTINUE
          RBUFX(I,NBUFX(I)+1) = RBUFX(I,1)
          ZBUFX(I,NBUFX(I)+1) = ZBUFX(I,1)
      ENDDO
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( A80 )
 1010 FORMAT( 6I7 )
 1015 FORMAT( / (3I5 , 1P , 4E12.4) )
 1020 FORMAT( / (12I6) )
 1025 FORMAT(   (12I6) )
 1030 FORMAT( / (1P , 6E12.4) )
 1040 FORMAT(   (1P , 6E12.4) )
C
 9000 FORMAT(/' *** ERROR *** READPG : NO. OF POLYGONS EXCEEDS MAX.'
     &       /'               NPOLYP,NPOLYM,MPG=' , 3I6 )
 9010 FORMAT(/' *** ERROR *** READPG : NO. OF POLYGON COL. EXCEEDS MAX.'
     &       /'               NCPG,MCG='      , 2I6 )
 9020 FORMAT(/' *** ERROR *** READPG : NO. OF VESSEL PTS. EXCEEDS MAX.'
     &       /'               NVES,MVES='     , 2I6 )
 9030 FORMAT(/' *** ERROR *** READPG : NO. OF BAFFLE PTS. EXCEEDS MAX.'
     &       /'               NBUFLE,MBUFLE=' , 2I6 )
 9033 FORMAT(/' *** ERROR *** READPG : MAX. NO. OF BAFFLES EXCEEDS MAX.'
     &       /'               NBUFMX,MBUFX=' , 2I6 )
 9035 FORMAT(/' *** ERROR *** READPG : NO. OF BAFFLE PTS. EXCEEDS MAX.'
     &       /'               IBUFX,NBUFX,MBUFLE=' , 3I2 )
 9040 FORMAT(/' *** ERROR *** READPG : UNABLE TO DETERMINE ORDER OF VE
     &SSEL.' )
 9050 FORMAT(/' *** WARNING *** READPG : FORCED VESSEL ORDER TO BE CLOCK
     &WISE.' /)
 9060 FORMAT(/' *** ERROR *** READPG : ILLEGAL VALUE OF IESCF =',I6 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE WRITPG( IWRITE )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO WRITE PLASMA/NIMBUS POLYGONS CREATED BY GRID2D
C
C INPUT   : IWRITE      = WRITE FILE ON STREAM 'IWRITE'
C
C /CPOLYG/: (SEE 'c09')
C
C NOTE    : (1) ALL UNITS IN CGS.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 15/06/90
C
C UPDATE  : 29/06/90 --- COMMON BLOCK /CPOLYG/
C           24/06/92 --- ITAGDP(,)
C
C-----------------------------------------------------------------------
C
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C-----------------------------------------------------------------------
C
      IF( IWRITE.GT.0 ) THEN
C
          I = IWRITE
C
          WRITE(I,1000)
          WRITE(I,2000) NPOLYP , NPOLYM , ( GEOM(K) , K=1,6 )
C
          WRITE(I,1010)
          DO 4000 IRING = 1 , NCPG
             WRITE(I,2010) IRING , NJP(IRING)
     &                   , ( KORP(IRING,J) , J=1,NJP(IRING) )
 4000     CONTINUE
C
          WRITE(I,1020)
          DO 4010 N = 1 , NPOLYP
             NV     = NVERTP(N)
             WRITE(I,2020) ' POL' , N , DFLOAT(NV) , AREAP(N)
     &                     , ( ITAGP(N,M)                , M=1,3     )
             WRITE(I,2030)   ( RVERTP(N,M) , ZVERTP(N,M) , M=1,NV    )
             WRITE(I,2030)     RVERTP(N,5) , ZVERTP(N,5)
             WRITE(I,2040)     NM(N) , ( KORM(N,M) , M=1,NM(N) )
 4010     CONTINUE
C
          WRITE(I,1030)
          DO 4020 N = 1 , NPOLYM
             NV    = NVERTM(N)
             WRITE(I,2020) ' POL' , N , DFLOAT(NV) , AREAM(N)
     &                   , ( ITAGM(N,M)                , M=1,NV+2)
             WRITE(I,2025) ( JPOLY(N,IVERT) - ITAGM(N,IVERT+2) * 1000
     &                     , IVERT=1,NV )
             WRITE(I,2030) ( RVERTM(N,M) , ZVERTM(N,M) , M=1,3   )
             IF(NV.GT.3) WRITE(I,2030)(RVERTM(N,M),ZVERTM(N,M),M=4,NV)
 4020     CONTINUE
C
          WRITE(I,1040)
          DO 4030 IRING = 1 , NCPG
             WRITE(I,2050) IRING , 1 , RPOLY(IRING,1) , ZPOLY(IRING,1)
             DO 4040 J = 2 , NJPOLY(IRING)
                WRITE(I,2060)  J , RPOLY(IRING,J) , ZPOLY(IRING,J)
 4040        CONTINUE
 4030     CONTINUE
C
      END IF
C
C-----------------------------------------------------------------------
C
 1000 FORMAT('1NPOLYP NPOLYM      RMIN/M      ZMIN/M      RLEN/M      ZL
     &EN/M     RCENT/M1    ZCENT/M')
 1010 FORMAT(' IRING    NUM   PLASMA POLYGONS IN THIS RING')
 1020 FORMAT('1PLASMA CODE POLYGONS (M) ASSIGNED CLOCKWISE & POLYGON CEN
     &TRE:-')
 1030 FORMAT('1MONTE CARLO POLYGONS (M) ASSIGNED ANTI-CLOCKWISE
     &    :-')
 1040 FORMAT('1RING    J    RPOLY0/M     ZPOLY/M')
C
 2000 FORMAT( 2I7 , 1P , 6E12.4 )
 2010 FORMAT( 1X , I5 , 2X , I5 , 2X , 10I5 / (15X , 10I5) )
 2020 FORMAT( 1X , A4 , I5 , 1PE10.3 , E14.6 , ' ITAG = ' , 6I5 )
 2025 FORMAT( 34X                            , ' JPOL = ' , 10X,4I5 )
 2030 FORMAT( 10X     , 1P,6E10.3 )
 2040 FORMAT( 10X     , ' MN = ' , I2 , ' KORM = ' , 10I5 )
 2050 FORMAT( 2I5 , 1P , 3E12.4 )
 2060 FORMAT( 5X  , I5 , 1P , 3E12.4 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE ASSMPG( NINOMP , NINOWA , NP , RMESH , ZMESH )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO ASSEMBLE PLASMA/NIMBUS POLYGONS CREATED BY GRID2D IN
C           LIGHT OF NINOMP & NINOWA.
C
C INPUT   : NINOMP      = KNOCK OUT THE FIRST NINOMP RINGS
C           NINOWA      = KNOCK OUT THE LAST  NINOWA RINGS AT THE WALL
C
C           NP          = NUMBER OF K-MESH POINTS
C           RMESH(K)    = R-COORDINATE OF POINT K
C           ZMESH(K)    = Z-COORDINATE OF POINT K
C
C /CPOLYG/: (SEE 'c09')
C
C ROUTINE : RESETG
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 06/06/90
C
C UPDATE  : 29/06/90 --- COMMON BLOCK /CPOLYG/
C           24/06/92 --- ITAGDP(,)
C
C-----------------------------------------------------------------------
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
      DIMENSION RMESH(NP) , ZMESH(NP)
C
C-----------------------------------------------------------------------
C
      IF( NINOMP.LE.0 .AND. NINOWA.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C
      IF( NINOMP.EQ.0 ) THEN
          CALL RESETG( NJP(1) , NXWPG - NINOWA , NCPG , 0 )
      ELSE
          CALL RESETG( NJP(1) , 1              , NCPG , 0 )
      END IF
C
C---------------------------PLASMA POLYGONS-----------------------------
C
      IPOLYP                = 0
C
      DO 100 N              = 1 , NPOLYP
C
         I                  = ITAGP(N,1)
         IP1                = ITAGP(N,2)
         IF( I.LE.NINOMP .OR.
     &     ( IP1.GT.NXWPG-NINOWA .AND. IP1.LE.NXWPG ) ) GOTO 100
         IF(NINOMP.EQ.0 .AND. I.LT.NXWPG-NINOWA ) THEN
            IPOLYP          = IPOLYP + 1
            GOTO 100
         END IF
C
         IPOLYP             = IPOLYP + 1
         NVERTP(IPOLYP)     = NVERTP(N)
         AREAP(IPOLYP)      = AREAP(N)
         DO 120 IVERT       = 1 , NVERTP(N) + 1
            RVERTP(IPOLYP,IVERT) = RVERTP(N,IVERT)
            ZVERTP(IPOLYP,IVERT) = ZVERTP(N,IVERT)
            ITAGDP(IPOLYP,IVERT) = ITAGDP(N,IVERT)
  120    CONTINUE
         ITAGP(IPOLYP,3)     = ITAGP(N,3)
         IF( I.LE.NXWPG-NINOWA ) THEN
             ITAGP(IPOLYP,1) = ITAGP(N,1) - NINOMP
         ELSE
             ITAGP(IPOLYP,1) = ITAGP(N,1) - (NINOMP + NINOWA)
         END IF
         IF( IP1.LE.NXWPG-NINOWA ) THEN
             ITAGP(IPOLYP,2) = ITAGP(N,2) - NINOMP
         ELSE
             ITAGP(IPOLYP,2) = ITAGP(N,2) - (NINOMP + NINOWA)
         END IF
C
         NM(IPOLYP)          = NM(N)
         DO 140 K            = 1 , NM(N)
            KORM(IPOLYP,K)   = KORM(N,K)
  140    CONTINUE
C
         IRING               = ITAGP(IPOLYP,1)
         NJP(IRING)          = NJP(IRING) + 1
         J                   = NJP(IRING)
         KORP(IRING,J)       = IPOLYP
C
         IDTAGP(IPOLYP)      = IDTAGP(N)
C
         RHOIN(IPOLYP)       = RHOIN(N)
         RHOOUT(IPOLYP)      = RHOOUT(N)
C
  100 CONTINUE
C
      NPOLYP                 = IPOLYP
C
C---------------------------NIMBUS POLYGONS-----------------------------
C
      IPOLYM                 = 0
C
      DO 200 I               = 1 , NCPG - (NINOMP + NINOWA)
C
         DO 220 J            = NJP(I) , 1 , -1
C
         N                   = KORP(I,J)
C
         DO 240 K            = 1 , NM(N)
            M                = KORM(N,K)
            IPOLYM           = IPOLYM + 1
            NVERTM(IPOLYM)   = NVERTM(M)
            AREAM(IPOLYM)    = AREAM(M)
            ITAGM(IPOLYM,1)  = N
            ITAGM(IPOLYM,2)  = ITAGM(M,2)
C
            DO 250 L         = 3 , NVERTM(M) + 2
               IF( ITAGM(M,L).EQ.0 ) THEN
                   ITAGM(IPOLYM,L)  = ITAGM(M,L)
                   GOTO 250
               END IF
               IF( ITAGM(M,L).GT.NXWPG-NINOWA ) THEN
                   ITAGM(IPOLYM,L)  = ITAGM(M,L) - (NINOMP + NINOWA)
               ELSE
                   ITAGM(IPOLYM,L)  = ITAGM(M,L) - NINOMP
               END IF
  250       CONTINUE
C
            DO 260 IVERT              = 1 , NVERTM(M)
               RVERTM(IPOLYM,IVERT)   = RVERTM(M,IVERT)
               ZVERTM(IPOLYM,IVERT)   = ZVERTM(M,IVERT)
               IDTAGM(IPOLYM,IVERT+1) = IDTAGM(M,IVERT+1)
  260       CONTINUE
            KORM(N,K)                 = IPOLYM
            IDTAGM(IPOLYM,1)          = IDTAGM(M,1)
  240    CONTINUE
C
  220    CONTINUE
  200 CONTINUE
C
      NPOLYM                 = IPOLYM
C
C------------------------------RPOLY,ZPOLY------------------------------
C
      ICOUNT                 = 0
      DO 300 I               = NINOMP + 1 , NCPG
         IF( I.GT.NXWPG-NINOWA .AND. I.LE.NXWPG ) GOTO 300
         ICOUNT              = ICOUNT + 1
         NJPOLY(ICOUNT)      = NJPOLY(I)
         DO 350 J            = 1 , NJPOLY(I)
            RPOLY(ICOUNT,J)  = RPOLY(I,J)
            ZPOLY(ICOUNT,J)  = ZPOLY(I,J)
  350    CONTINUE
  300 CONTINUE
C
C-----------------------------------------------------------------------
C
      NCPG                   = NCPG   - ( NINOMP + NINOWA )
      NXWPG                  = NXWPG  - ( NINOMP + NINOWA )
      LCFSPG                 = LCFSPG - NINOMP
C
C-----------------------------KORPG & KORKG-----------------------------
C
      CALL RESETI( KORPG(1)  , MPG , 0 )
      CALL RESETI( KORKG(1)  , MPG , 0 )
C
      DO 390 K               = 1 , NP
         DO 395 N            = 1 , NPOLYP
            IF(RMESH(K).EQ.RVERTP(N,5).AND.ZMESH(K).EQ.ZVERTP(N,5))THEN
               KORPG(K)      = N
               IF( KORKG(N).EQ.0 ) KORKG(N) = K
               GOTO 390
            END IF
  395    CONTINUE
  390 CONTINUE
C
C----------------------------------JPOLY--------------------------------
C
 9999 DO 400 M               = 1 , NPOLYM
C
         N                   = ITAGM(M,1)
         IN                  = ITAGP(N,1)
         NFIRST              = KORP(IN,1)
         NLAST               = KORP(IN,NJP(IN))
         MLAST               = KORM(NFIRST,NM(NFIRST))
         MFIRST              = KORM(NLAST,1)
C
         DO 420 IVERT        = 1 , NVERTM(M)
            I                = ITAGM(M,IVERT+2)
C
            IF( M.EQ.MLAST ) THEN
                IF( RVERTM(M,IVERT).EQ. RPOLY(I,NJPOLY(I))
     &                             .AND.
     &              ZVERTM(M,IVERT).EQ. ZPOLY(I,NJPOLY(I)) ) THEN
                    JPOLY(M,IVERT) = NJPOLY(I) + I * 1000
                    GOTO 420
               END IF
            END IF
C
            DO 440 J         = 1 , NJPOLY(I)
               IF( RVERTM(M,IVERT).EQ. RPOLY(I,J)
     &                            .AND.
     &             ZVERTM(M,IVERT).EQ. ZPOLY(I,J) ) THEN
                   JPOLY(M,IVERT) = J + I * 1000
                   GOTO 420
               END IF
  440       CONTINUE
CW          WRITE(LOUT,9000) M
C
  420    CONTINUE
C
  400 CONTINUE
C
C-----------------------------------------------------------------------
C
 9000 FORMAT(' *** WARNING *** UNABLE TO ASSIGN VERTEX TO (RPOLY,ZPOLY)
     &FOR M = ' , I4 )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE VESSPG( MVES   , MPG    , MRG    , NDIM2
     *                 , NVES   , NPOLY  , NVERTM
     *                 , RVES   , ZVES   , ZESCUT
     *                 , RVERTM , ZVERTM
     *                 , ITAGES , NEWPG
     *                 , RROOT1 , ZROOT1
     *                 , RROOT3 , ZROOT3 )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : (1) CUT AN ESCAPE FIGURE POLYGON (NPOLY) BY THE INNER
C               VESSEL WALL.
C           (2) FORM TWO POLYGONS FROM THIS ONE POLYGON SUCH THAT ONE
C               IS INSIDE THE VESSEL (NPOLY) AND ONE OUTSIDE (NPOLY+1).
C           (3) TO ASSIGN ITAGES() TO THESE POLYGONS.
C
C INPUT   : MVES        = MAXIMUM NUMBER OF INNER VESSEL COORDINATES
C           MPG         = MAXIMUM NUMBER OF POLYGONS ALLOWED
C           NDIM2       = MAXIMUM NUMBER OF POLYGONS ALLOWED
C
C           NVES        = NUMBER OF INNER VESSEL COORDINATES
C           NPOLY       = POLYGON UNDER INVESTIGATION = MAX. NO. SO FAR
C           NVERTM()    = NUMBER OF VERTICIES FOR ALL POLYGONS
C
C           RVES()      = R-COORDINATES OF INNER VESSEL
C           ZVES()      = Z-COORDINATES OF INNER VESSEL
C           ZESCUT      = IF ALL VERTICES OF POLYGON ARE ABOVE OR ON
C                         ZESCUT THEN FORCE ITAGES(M)=2
C
C           RVERTM(,K)  = R-COORDINATES OF VERTIX K OF ALL POLYGONS
C           ZVERTM(,K)  = Z-COORDINATES OF VERTIX K OF ALL POLYGONS
C           NXWPG       = RING AT WALL
C
C OUTPUT  : NPOLY       = SEE ABOVE
C           NVERTM()    = SEE ABOVE
C           RVERTM(,K)  = SEE ABOVE
C           ZVERTM(,K)  = SEE ABOVE
C           ITAGES(M)   = 0 --- NOT AN OUTER ESCAPE FIGURE
C                       = 1 --- ESCAPE FIGURE IS VOID
C                       = 2 --- ESCAPE FIGURE IS WALL
C                       > 2 --- ESCAPE FIGURE IS ALBEDO
C           NEWPG       = NUMBER OF NEW POLYGONS CREATED ( 0 OR 1 )
C           RROOT1      = R-COORDINATE OF INTERSECTION POINT ON SIDE 1
C           ZROOT1      = Z-COORDINATE OF INTERSECTION POINT ON SIDE 1
C           RROOT3      = R-COORDINATE OF INTERSECTION POINT ON SIDE 3
C           ZROOT3      = Z-COORDINATE OF INTERSECTION POINT ON SIDE 3
C
C PROGRAM : M           = NPOLY
C           MVERT       = NUMBER OF VERTICIES OF M
C           R1(K)       = R-COORDINATES OF VERTIX K FOR POLYGON NPOLY
C           Z1(K)       = Z-COORDINATES OF VERTIX K FOR POLYGON NPOLY
C           R2(J)       = R-COORDINATES OF VESSEL/POLYGON INTERSECTION
C           Z2(J)       = Z-COORDINATES OF VESSEL/POLYGON INTERSECTION
C           R3(K1)      = R-COORDINATES OF VERTIX K1 (INCL.INTERSECT.)
C           Z3(K1)      = Z-COORDINATES OF VERTIX K1 (INCL.INTERSECT.)
C           L1(K)       = 0 --- IF VERTIX K IS WITHIN A DISTANCE EPS
C                               OF INNER VESSEL
C                       = 1 --- IF VERTIX K IS INSIDE  INNER VESSEL
C                       = 2 --- IF VERTIX K IS OUTSIDE INNER VESSEL
C           L2()        = FACE WHERE INTERSECTION OCCURS
C           L3()        = N/A
C           L4()        = GENERAL ARRAY
C           EPS         = TOLERENCE
C
C NOTES   : (1) NPOLY WILL EITHER BE UNCHANGED OR WILL INCREASE BY ONE.
C           (2) THERE ORIGINAL POLYGON WILL BE OVERWRITEN BY THE NEW
C               ONE ON EXIT.
C           (3) AN ESCAPE FIGURE CAN NEVER BE ENTIRELY INSIDE THE INNER
C               VESSEL.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 16/04/91
C
C HISTORY : 30/07/92 --- INTRODUCE ZESCUT
C           30/09/93 --- CHECK FOR MULTI-ROOTS
C                        & OUTPUT RROOT1,3 & ZROOT1,3
C           22/04/96 --- REMOVE 'LSETUP' AND CALL GA15AD EVERYTIME THE
C                        ROUTINE IS ENTERED.
C
C-----------------------------------------------------------------------
C
      PARAMETER ( NDIM = 10 )
      PARAMETER ( EPS  = 5.0D-03 )
C
      DIMENSION RVES(MVES)    , ZVES(MVES)
C
      DIMENSION NVERTM(MPG)   , RVERTM(MPG,MRG) , ZVERTM(MPG,MRG)
C
      DIMENSION ITAGES(NDIM2)
C
      DIMENSION R1(NDIM) , Z1(NDIM) , R2(NDIM) , Z2(NDIM)
     &        , R3(NDIM) , Z3(NDIM)
     &        , L1(NDIM) , L2(NDIM) , L3(NDIM) , L4(NDIM)
     &        , XMIN(2)  , LMIN(2)
C
      PARAMETER ( IWORK = 600     , LND = IWORK )
      COMMON/SWORK/ WORKSP(IWORK)
     &            , TDUM(IWORK)   , XDUM(IWORK) , YDUM(IWORK)
     &            , LNDSP(2,LND)
C
C---------------------------- DATA BLOCKS ------------------------------
C
      NEWPG = 0
C
      RROOT1 = 1.00D+30
      ZROOT1 = 1.00D+30
      RROOT3 = 1.00D+30
      ZROOT3 = 1.00D+30
C
C-------------------- SET UP VESSEL BOUNDARY TESTING--------------------
C
      IF( NVES.LE.0 ) GOTO 9999
C
      CALL GA15AD( NVES      , 1
     &           , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &           , RVES(1)   , ZVES(1)
     &           , TDUM(1)   , XDUM(1) , YDUM(1)    , 6   )
C
C--------------------- GET COORDS OF NPOLY & CHECK ---------------------
C
      M         = NPOLY
      MVERT     = NVERTM(M)
C
      NOUT      = 0
      DO 100 I  = 1 , NVERTM(M)
C
         R1(I)  = RVERTM(M,I)
         Z1(I)  = ZVERTM(M,I)
C........................... CHECK BOUNDARY ............................
         CALL GA15BD( R1(I)     , Z1(I)   , RESULT
     &              , NVES      , 1
     &              , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &              , RVES(1)   , ZVES(1)
     &              , TDUM(1)   , XDUM(1) , YDUM(1)    , 6   )
C
        IF( RESULT.GT.EPS ) THEN
                 L1(I) = 1
        ELSE IF( RESULT.LT.-EPS ) THEN
                 L1(I) = 2
                 NOUT  = NOUT + 1
        ELSE
                 L1(I) = 0
                 NOUT  = NOUT + 1
        END IF
C.......................................................................
C
  100 CONTINUE
C
      MVERT     = MVERT + 1
      R1(MVERT) = R1(1)
      Z1(MVERT) = Z1(1)
C
C----------------------- ESCAPE FIGURE OUTSIDE WALL --------------------
C
      IF( NOUT.EQ.NVERTM(M) ) THEN
          ITAGES(M) = 2
          NEWPG     = 0
          GOTO 9999
      ELSE
          NEWPG     = 1
      END IF
C
C----------------------- FIND INTERSECTION POINTS ----------------------
C
      CALL ROOT( MVERT , R1(1)   , Z1(1)
     &         , NVES  , RVES(1) , ZVES(1)
     &         , NDIM  , R2(1)   , Z2(1)
     &         , L2(1) , L3(1)   , NROOT   )
C
C------------------- ERROR IF MULTI-ROOTS ON A SIDE --------------------
C------ (SHOULD ONLY BE INTERSECTIONS ON SIDE 1 AND NVERTM(M)-1) -------
C
      IFIRST           = 0
      ILAST            = 0
C
      DO 150 IROOT     = 1 , NROOT
         IF( L2(IROOT).EQ.1 ) THEN
             IFIRST    = IFIRST + 1
         ELSE IF( L2(IROOT).EQ.NVERTM(M)-1 ) THEN
             ILAST     = ILAST  + 1
         ELSE
             WRITE(LOUT,9010) 9 , L2(IROOT) , M
             CALL EXITX(LOUT)
         END IF
  150 CONTINUE
C
      IF( IFIRST.GT.1 .OR. ILAST.GT.1 ) THEN
          IF( IFIRST.GT.1 ) WRITE(LOUT,9020) 9 , 1           , M
          IF( ILAST .GT.1 ) WRITE(LOUT,9020) 9 , NVERTM(M)-1 , M
          CALL EXITX(LOUT)
      END IF
C
C------------------ INTERSECTION POINT NEAR A VERTIX? ------------------
C
      DO 200    I     = 1 , NVERTM(M)
         DO 220 IROOT = 1 , NROOT
            DIST      = PYTHGS( R1(I) , Z1(I) , R2(IROOT) , Z2(IROOT) )
            IF( DIST.LE.EPS ) THEN
                L1(I) = 0
                L4(IROOT) = I
            ELSE
                L4(IROOT) = 0
            END IF
  220    CONTINUE
  200 CONTINUE
C
C------------------ IF SO, REMOVE INTERSECTION POINT  ------------------
C
      L               = 0
      DO 240 IROOT    = 1 , NROOT
         IF( L4(IROOT).EQ.0 ) THEN
             L        = L + 1
             R2(L)    = R2(IROOT)
             Z2(L)    = Z2(IROOT)
             L2(L)    = L2(IROOT)
             IF( L2(IROOT).EQ.1 ) THEN
                 RROOT1 = R2(IROOT)
                 ZROOT1 = Z2(IROOT)
             ELSE IF( L2(IROOT).EQ.3 ) THEN
                 RROOT3 = R2(IROOT)
                 ZROOT3 = Z2(IROOT)
             ELSE
                 WRITE(LOUT,9010) L2(IROOT) , M
                 CALL EXITX(LOUT)
             END IF
         END IF
  240 CONTINUE
      NROOT           = L
C
C--------------- PLUG INTERSECTION POINTS INTO POLYGON -----------------
C--------------------------- OVERWRITE L3 ------------------------------
C
      L               = 0
      DO 300 I        = 1 , NVERTM(M)
C
         L            = L + 1
         R3(L)        = R1(I)
         Z3(L)        = Z1(I)
         L3(L)        = L1(I)
C
         DO 350 IROOT = 1 , NROOT
            IF( L2(IROOT).EQ.I ) THEN
                L     = L + 1
                R3(L) = R2(IROOT)
                Z3(L) = Z2(IROOT)
                L3(L) = 0
            END IF
  350    CONTINUE
C
  300 CONTINUE
      MVERT           = L
C
C----------------- CREATE TWO POLYGONS OUT OF ORIGINAL -----------------
C--------------------- OVERWRITE R1, Z1 , R2 , Z2-----------------------
C
      LIN             = 0
      LOUT            = 0
C
      DO 400 I        = 1 , MVERT
C.......................... INSIDE VESSEL ..............................
         IF( L3(I).EQ.0 .OR. L3(I).EQ.1 ) THEN
             LIN      = LIN + 1
             R1(LIN)  = R3(I)
             Z1(LIN)  = Z3(I)
         END IF
C.......................... OUTSIDE VESSEL .............................
         IF( L3(I).EQ.0 .OR. L3(I).EQ.2 ) THEN
             LOUT     = LOUT + 1
             R2(LOUT) = R3(I)
             Z2(LOUT) = Z3(I)
         END IF
C
  400 CONTINUE
C
C-------------------------- ASSEMBLE POLYGONS --------------------------
C
C.......................... INSIDE VESSEL ..............................
        NVERTM(NPOLY) = LIN
        ICUT          = 0
        DO 500 I      = 1 , LIN
           RVERTM(NPOLY,I) = R1(I)
           ZVERTM(NPOLY,I) = Z1(I)
           IF( ZVERTM(NPOLY,I).GE.ZESCUT ) ICUT = ICUT + 1
  500   CONTINUE
C
        IF( ICUT.LT.LIN ) THEN
            ITAGES(NPOLY) = 1
        ELSE
            ITAGES(NPOLY) = 2
        END IF
C.......................... OUTSIDE VESSEL .............................
        NPOLY         = NPOLY + 1
        IF( NPOLY.GT.MPG ) THEN
            WRITE(LOUT,9000) 9 , MPG
            CALL EXITX(LOUT)
        END IF
C
        NVERTM(NPOLY) = LOUT
        DO 550 I      = 1 , LOUT
           RVERTM(NPOLY,I) = R2(I)
           ZVERTM(NPOLY,I) = Z2(I)
CW         WRITE(LOUT,*) NPOLY , I , R2(I) , Z2(I)
  550   CONTINUE
        ITAGES(NPOLY) = 2
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( 2I5 , 2( I4 , 1P , 2E12.4 ) , 5I4 )
C
 9000 FORMAT( / ' *** ERROR *** LINKPG (' , I1
     &        ,                     ') : NO. OF POLYGONS EXCEEDS MAX.'
     &        / '               INCREASE MPG WHICH IS CURRENTLY', I7
     &        / '               (NOTE. MRG(NIMBUS).GE.MPG(CPOLYG)+2) ')
C
 9010 FORMAT( / ' *** ERROR *** LINKPG (' , I1
     &        , ') : ROOT FOUND ON ILLEGAL SIDE ' , I2
     &        , ' OF ESCAPE FIGURE ' , I5 )
C
 9020 FORMAT( / ' *** ERROR *** LINKPG (' , I1
     &        , ') : MULTI-ROOTS ON SIDE ' , I2
     &        , ' OF ESCAPE FIGURE ' , I5 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE VESS62( IOUT   , LMC
     *                 , MVES   , MPG    , MRG    , NDIM2
     *                 , NVES   , NPOLY  , NVERTM
     *                 , RVES   , ZVES   , ZESCUT
     *                 , RVERTM , ZVERTM
     *                 , ITAGES , NEWPG
     *                 , RROOT1 , ZROOT1
     *                 , RROOT3 , ZROOT3 )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : (1) CUT AN ESCAPE FIGURE POLYGON (NPOLY) BY THE INNER
C               VESSEL WALL.
C           (2) FORM TWO POLYGONS FROM THIS ONE POLYGON SUCH THAT ONE
C               IS INSIDE THE VESSEL (NPOLY) AND ONE OUTSIDE (NPOLY+1).
C           (3) TO ASSIGN ITAGES() TO THESE POLYGONS.
C
C INPUT   : IOUT        > 0 --- OUTPUT MESSAGES
C           LMC         = PRODUCE NIMBUS FILE BUT EXIT BEFORE CALLING
C                         NIMBUS.  CHECKING OF LRS AND GAUGES IS
C                         DISABLED
C           MVES        = MAXIMUM NUMBER OF INNER VESSEL COORDINATES
C           MPG         = MAXIMUM NUMBER OF POLYGONS ALLOWED
C           NDIM2       = MAXIMUM NUMBER OF POLYGONS ALLOWED
C
C           NVES        = NUMBER OF INNER VESSEL COORDINATES
C           NPOLY       = POLYGON UNDER INVESTIGATION = MAX. NO. SO FAR
C           NVERTM()    = NUMBER OF VERTICIES FOR ALL POLYGONS
C
C           RVES()      = R-COORDINATES OF INNER VESSEL
C           ZVES()      = Z-COORDINATES OF INNER VESSEL
C           ZESCUT      = IF BOTH PLASMA VERTICES OF AN ESCAPE FIGURE
C                         ARE ABOVE OR ON ZESCUT THEN FORCE ITAGES()=2
C
C           RVERTM(,K)  = R-COORDINATES OF VERTEX K OF ALL POLYGONS
C           ZVERTM(,K)  = Z-COORDINATES OF VERTEX K OF ALL POLYGONS
C
C OUTPUT  : NPOLY       = SEE ABOVE
C           NVERTM()    = SEE ABOVE
C           RVERTM(,K)  = SEE ABOVE
C           ZVERTM(,K)  = SEE ABOVE
C           ITAGES(M)   = 0 --- NOT AN OUTER ESCAPE FIGURE
C                       = 1 --- ESCAPE FIGURE IS VOID
C                       = 2 --- ESCAPE FIGURE IS WALL
C                       > 2 --- ESCAPE FIGURE IS ALBEDO
C           NEWPG       = NUMBER OF EXTRA POLYGONS CREATED
C           RROOT1      = R-COORDINATE OF INTERSECTION POINT ON SIDE 1
C           ZROOT1      = Z-COORDINATE OF INTERSECTION POINT ON SIDE 1
C           RROOT3      = R-COORDINATE OF INTERSECTION POINT ON SIDE 3
C           ZROOT3      = Z-COORDINATE OF INTERSECTION POINT ON SIDE 3
C
C PROGRAM : M           = NPOLY
C           MVERT       = NUMBER OF VERTICIES OF M
C           R1(K)       = R-COORDINATES OF VERTEX K FOR POLYGON NPOLY
C           Z1(K)       = Z-COORDINATES OF VERTEX K FOR POLYGON NPOLY
C           R2(J)       = R-COORDINATES OF VESSEL/POLYGON INTERSECTION
C           Z2(J)       = Z-COORDINATES OF VESSEL/POLYGON INTERSECTION
C           L1(K)       = 0 --- IF VERTEX K IS WITHIN A DISTANCE EPS
C                               OF INNER VESSEL
C                       = 1 --- IF VERTEX K IS INSIDE  INNER VESSEL
C                       = 2 --- IF VERTEX K IS OUTSIDE INNER VESSEL
C           L2()        = FACE WHERE INTERSECTION OCCURS
C           L3()        = INTERSECTION IN VESSEL ARRAY
C           L4()        = 0 --- L3() IS ON      ESCAPE FIGURE BOUNDARY
C                       = 1 --- L3() IS INSIDE  ESCAPE FIGURE BOUNDARY
C                       = 2 --- L3() IS OUTSIDE ESCAPE FIGURE BOUNDARY
C           EPS         = TOLERENCE
C
C NOTES   : (1) NPOLY WILL EITHER BE UNCHANGED OR WILL INCREASED
C           (2) THE ORIGINAL POLYGON WILL BE OVERWRITEN BY A NEW ONE
C           (3) AN ESCAPE FIGURE CAN NEVER BE ENTIRELY INSIDE THE INNER
C               VESSEL.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 16/04/91
C
C HISTORY : 30/07/92 --- INTRODUCE ZESCUT
C           30/09/93 --- CHECK FOR MULTI-ROOTS
C                        & OUTPUT RROOT1,3 & ZROOT1,3
C           07/10/93 --- RENAME 'VESSPG' AS 'VESS62' FOR V6.2 OF LINKPG
C                    --- USE STRIP VIA FXPOLY TO CONSTRUCT A SERIES OF
C                        POLYGONS TOUCHING THE VESSEL
C                    --- ERROR IF VESSEL IS WITHIN 'EPS' OF A VERTEX
C                        (TAKE NO AUTO-CORRECTIVE ACTION)
C                    --- THE VERTICES OF THE POLYGONS HAVE NO
C                        PRE-DETERMINED ORDER.
C           15/06/94 --- IOUT INTO ARGUEMENT LIST
C           22/04/96 --- REMOVE 'LSETUP' AND CALL GA15AD EVERYTIME THE
C                        ROUTINE IS ENTERED.
C           03/07/97 --- MAKE SURE NEW POLYGONS DO NOT CUT VESSEL MORE
C                        THAN ONCE.
C           11/05/98 --- NROOT MUST BE GREATER THAN 1, FROM POLCUT
C
C-----------------------------------------------------------------------
C
      PARAMETER ( NSTRIP= 50    )
      PARAMETER ( EPS  = 5.0D-03 )
C
      DIMENSION RVES(MVES)    , ZVES(MVES)
C
      DIMENSION NVERTM(MPG)   , RVERTM(MPG,MRG) , ZVERTM(MPG,MRG)
C
      DIMENSION ITAGES(NDIM2)
C
      DIMENSION RVOID(NSTRIP)  , ZVOID(NSTRIP)
     &        , RDIOV(NSTRIP)  , ZDIOV(NSTRIP)
     &        , RINTER(NSTRIP) , ZINTER(NSTRIP)
     &        , RRETNI(NSTRIP) , ZRETNI(NSTRIP)
     &        , RWALL(NSTRIP)  , ZWALL(NSTRIP)
     &        , RLLAW(NSTRIP)  , ZLLAW(NSTRIP)
     &        , LTOP(4*NSTRIP)
C
      LOGICAL LMC
C
C/SWORK/
      PARAMETER ( IWORK = 600     , LND = IWORK )
      COMMON/SWORK/ WORKSP(IWORK)
     &            , TDUM(IWORK)   , XDUM(IWORK) , YDUM(IWORK)
     &            , LNDSP(2,LND)
C
C../SWORK1/
      INTEGER*4  NDIM
      PARAMETER( NDIM = 10 )
C
      COMMON/SWORK1/ R1 , Z1 , R2 , Z2 , R3 , Z3 , L1 , L2 , L3
C
      INTEGER*4 L1(NDIM) , L2(NDIM) , L3(NDIM)
      REAL*8    R1(NDIM) , Z1(NDIM) , R2(NDIM) , Z2(NDIM)
     &        , R3(NDIM) , Z3(NDIM)
C
C---------------------------- DATA BLOCKS ------------------------------
C
      NEWPG = 0
C
      RROOT1 = 1.00D+30
      ZROOT1 = 1.00D+30
      RROOT3 = 1.00D+30
      ZROOT3 = 1.00D+30
C
      IF( NVES.LE.0 ) GOTO 9999
C
C-------------------- SET UP VESSEL BOUNDARY TESTING--------------------
C
      CALL GA15AD( NVES      , 1
     &           , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &           , RVES(1)   , ZVES(1)
     &           , TDUM(1)   , XDUM(1) , YDUM(1)    , 6   )
C
C--------------------- GET COORDS OF NPOLY & CHECK ---------------------
C
      M         = NPOLY
      MVERT     = NVERTM(M)
C
      NOUT      = 0
      DO 100 I  = 1 , NVERTM(M)
C
         R1(I)  = RVERTM(M,I)
         Z1(I)  = ZVERTM(M,I)
C........................... CHECK BOUNDARY ............................
         CALL GA15BD( R1(I)     , Z1(I)   , RESULT
     &              , NVES      , 1
     &              , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &              , RVES(1)   , ZVES(1)
     &              , TDUM(1)   , XDUM(1) , YDUM(1)    , 6   )
C
        IF( RESULT.GT.EPS ) THEN
                 L1(I) = 1
        ELSE IF( RESULT.LT.-EPS ) THEN
                 L1(I) = 2
                 NOUT  = NOUT + 1
        ELSE
                 L1(I) = 0
                 NOUT  = NOUT + 1
        END IF
C.......................................................................
C
  100 CONTINUE
C
      MVERT     = MVERT + 1
      R1(MVERT) = R1(1)
      Z1(MVERT) = Z1(1)
C
C----------------------- ESCAPE FIGURE OUTSIDE WALL --------------------
C
      IF( NOUT.EQ.NVERTM(M) ) THEN
          ITAGES(M) = 2
          NEWPG     = 0
          GOTO 9999
      ELSE
          NPOLY0    = NPOLY
      END IF
C
C----------------------- FIND INTERSECTION POINTS ----------------------
C
      CALL ROOT( MVERT , R1(1)   , Z1(1)
     &         , NVES  , RVES(1) , ZVES(1)
     &         , NDIM  , R2(1)   , Z2(1)
     &         , L2(1) , L3(1)   , NROOT   )
C
C------------------- ERROR IF MULTI-ROOTS ON A SIDE --------------------
C------ (SHOULD ONLY BE INTERSECTIONS ON SIDE 1 AND NVERTM(M)-1) -------
C
      IFIRST        = 0
      ILAST         = 0
C
      DO 120 I      = 1 , NROOT
         IF( L2(I).EQ.1 ) THEN
             IFIRST = IFIRST + 1
             RROOT1 = R2(I)
             ZROOT1 = Z2(I)
         ELSE IF( L2(I).EQ.NVERTM(M)-1 ) THEN
             ILAST  = ILAST  + 1
             RROOT3 = R2(I)
             ZROOT3 = Z2(I)
         ELSE
             WRITE(IOUT,9010) L2(I) , M
             WRITE(IOUT,9012) (R1(J),Z1(J),J=1,MVERT)
             CALL EXITX(IOUT)
         END IF
  120 CONTINUE
C
      IF( IFIRST.GT.1 .OR. ILAST.GT.1 ) THEN
          IF( IFIRST.GT.1 ) WRITE(IOUT,9020) 1           , M
          IF( ILAST .GT.1 ) WRITE(IOUT,9020) NVERTM(M)-1 , M
          CALL EXITX(IOUT)
      END IF
C
C------------------ INTERSECTION POINT NEAR A VERTEX? ------------------
C
      DO 200    I     = 1 , NVERTM(M)
         DO 220 IROOT = 1 , NROOT
            DIST      = PYTHGS( R1(I) , Z1(I) , R2(IROOT) , Z2(IROOT) )
            IF( DIST.LE.EPS ) THEN
                WRITE(IOUT,9040) EPS , M , R1(I) , Z1(I)
                CALL EXITX(IOUT)
            END IF
  220    CONTINUE
  200 CONTINUE
C
C--------------- ASSEMBLE LINES FOR USE IN ROUTINE STRIP ---------------
C
C.. VOID LINE
C
      NVOID           = 2
      RVOID(1)        = RVERTM(M,1)
      ZVOID(1)        = ZVERTM(M,1)
      RVOID(2)        = RVERTM(M,NVERTM(M))
      ZVOID(2)        = ZVERTM(M,NVERTM(M))
C
      IF( ZVOID(1).GE.ZESCUT .AND. ZVOID(2).GE.ZESCUT ) THEN
          ITVOID      = 2
      ELSE
          ITVOID      = 1
      END IF
C
C.. WALL LINE
C
      NWALL            = 0
      DO 240 I         = 2 , NVERTM(M) - 1
         NWALL         = NWALL + 1
         RWALL(NWALL)  = RVERTM(M,I)
         ZWALL(NWALL)  = ZVERTM(M,I)
  240 CONTINUE
C
C.. VOID/VESSEL/WALL INTERFACE LINE
C
      NINTER          = 1
      RINTER(1)       = R2(1)
      ZINTER(1)       = Z2(1)
C
      IF( L3(1).NE.L3(2) ) THEN
C
          LSTART  = L3(1)
          LSTOP   = L3(2)
          IF( LSTART.EQ.1 ) LSTART = NVES
          IF( LSTOP .EQ.1 ) LSTOP  = NVES
C
          L           = LSTART
  250     NINTER      = NINTER + 1
          IF( NINTER.GT.NSTRIP ) THEN
            WRITE(IOUT,9030) M , ( R1(II) , Z1(II) , II = 1 , MVERT-1 )
            CALL EXITX(IOUT)
          END IF
C
          DIST1       = PYTHGS( RVES(L) , ZVES(L) , R2(1) , Z2(1) )
          DIST2       = PYTHGS( RVES(L) , ZVES(L) , R2(2) , Z2(2) )
C
          IF( DIST1.LE.EPS .OR. DIST2.LE.EPS ) THEN
              NINTER  = NINTER - 1
          ELSE
              RINTER(NINTER) = RVES(L)
              ZINTER(NINTER) = ZVES(L)
          END IF
C
          L           = L - 1
          IF( L.EQ.1 .AND. LSTOP.NE.1 ) L = NVES
C
          IF( L.NE. LSTOP ) GOTO 250
C
      END IF
C
      NINTER          = NINTER + 1
      RINTER(NINTER)  = R2(2)
      ZINTER(NINTER)  = Z2(2)
C
      ITWALL          = 2
C
C.. SWAP THE ORDER OF THE ABOVE THREE LINES (FOR 2ND ATTEMPT METHOD)
C
      DO 260 I     = 1 , NVOID
         RDIOV(I)  = RVOID(NVOID-I+1)
         ZDIOV(I)  = ZVOID(NVOID-I+1)
  260 CONTINUE
C
      DO 262 I     = 1 , NWALL
         RLLAW(I)  = RWALL(NWALL-I+1)
         ZLLAW(I)  = ZWALL(NWALL-I+1)
  262 CONTINUE
C
      DO 264 I     = 1 , NINTER
         RRETNI(I) = RINTER(NINTER-I+1)
         ZRETNI(I) = ZINTER(NINTER-I+1)
  264 CONTINUE
C
C--------------------- GENERATE VOID POLYGONS --------------------------
C
      CALL FXPOLY( IOUT        , ITVOID      , .FALSE.
     I           , MPG         , MRG         , NSTRIP
     I           , NINTER      , RRETNI(1)   , ZRETNI(1)
     I           , NVOID       , RDIOV(1)    , ZDIOV(1)
     O           , NPOLY       , NVERTM(1)
     O           , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O           , LTOP(1)
     O           , IER         )
C
      IF( IER.NE.0 ) THEN
          IF( IOUT.GT.0 ) WRITE(IOUT,9050) 'VOID'
          CALL FXPOLY( IOUT        , ITVOID      , .FALSE.
     I               , MPG         , MRG         , NSTRIP
     I               , NVOID       , RVOID(1)    , ZVOID(1)
     I               , NINTER      , RINTER(1)   , ZINTER(1)
     O               , NPOLY       , NVERTM(1)
     O               , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O               , LTOP(1)
     O               , IER         )
          IF( IER.NE.0 ) THEN
              WRITE(IOUT,9060) 'VOID'
C
              WRITE(IOUT,*) ' VOID COORDINATES :-'
              WRITE(IOUT,'(I6,1P,2E12.5)')
     >          (II,RVOID(II) ,ZVOID(II),II=1,NVOID)
C
              WRITE(IOUT,*) ' INTERFACE COORDINATES :-'
              WRITE(IOUT,'(I6,1P,2E12.5)')
     >          (II,RINTER(II),ZINTER(II),II=1,NINTER)
C
              CALL EXITX(IOUT)
          END IF
      END IF
C
C---------- CHECK NEW POLYGONS DO NOT CUT INTER() POLYGONS -------------
      DO M = NPOLY0 , NPOLY
         CALL POLCUT(M , NINTER , RINTER(1) , ZINTER(1) , NROOT)
         IF( NROOT.GT.1 ) THEN
             WRITE(IOUT,9070) 'VOID'
             WRITE(IOUT,*) ' VOID COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,RVOID(II) ,ZVOID(II),II=1,NVOID)
             WRITE(IOUT,*) ' INTERFACE COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,RINTER(II),ZINTER(II),II=1,NINTER)
             WRITE(IOUT,*) ' INTERSECTION COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,R3(II),Z3(II),II=1,NROOT)
             IF( .NOT.LMC ) CALL EXITX(IOUT)
         END IF
      ENDDO
C
C--------------------- GENERATE WALL POLYGONS --------------------------
C
      NPOLY = NPOLY + 1
C
      CALL FXPOLY( IOUT        , ITWALL      , .FALSE.
     I           , MPG         , MRG         , NSTRIP
     I           , NINTER      , RINTER(1)   , ZINTER(1)
     I           , NWALL       , RWALL(1)    , ZWALL(1)
     O           , NPOLY       , NVERTM(1)
     O           , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O           , LTOP(1)
     O           , IER         )
C
      IF( IER.NE.0 ) THEN
          IF( IOUT.GT.0 ) WRITE(IOUT,9050) 'WALL'
          CALL FXPOLY( IOUT        , ITWALL      , .FALSE.
     I               , MPG         , MRG         , NSTRIP
     I               , NWALL       , RLLAW(1)    , ZLLAW(1)
     I               , NINTER      , RRETNI(1)   , ZRETNI(1)
     O               , NPOLY       , NVERTM(1)
     O               , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O               , LTOP(1)
     O               , IER         )
          IF( IER.NE.0 ) THEN
              WRITE(IOUT,9060) 'WALL'
C
              WRITE(IOUT,*) ' WALL COORDINATES :-'
              WRITE(IOUT,'(I6,1P,2E12.5)')
     >          (II,RLLAW(II) ,ZLLAW(II),II=1,NWALL)
C
              WRITE(IOUT,*) ' INTERFACE COORDINATES :-'
              WRITE(IOUT,'(I6,1P,2E12.5)')
     >          (II,RRETNI(II),ZRETNI(II),II=1,NINTER)
C
              CALL EXITX(IOUT)
          END IF
      END IF
C
C---------- CHECK NEW POLYGONS DO NOT CUT INTER() POLYGONS -------------
      DO M = NPOLY0 , NPOLY
         CALL POLCUT(M , NINTER , RINTER(1) , ZINTER(1) , NROOT)
         IF( NROOT.GT.1 ) THEN
             WRITE(IOUT,9070) 'WALL'
             WRITE(IOUT,*) ' WALL COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,RWALL(II) ,ZWALL(II),II=1,NVOID)
             WRITE(IOUT,*) ' INTERFACE COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,RINTER(II),ZINTER(II),II=1,NINTER)
             WRITE(IOUT,*) ' INTERSECTION COORDINATES :-'
             WRITE(IOUT,'(I6,1P,2E12.5)')
     >         (II,R3(II),Z3(II),II=1,NROOT)
             IF( .NOT.LMC ) CALL EXITX(IOUT)
         END IF
      ENDDO
C
C---------------------- NUMBER OF POLYGONS CREATED ---------------------
C
      NEWPG = NPOLY - NPOLY0
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( 2I5 , 2( I4 , 1P , 2E12.4 ) , 5I4 )
C
 9000 FORMAT( / ' *** ERROR *** VESS62 : NO. OF POLYGONS EXCEEDS MAX.'
     &        / '               INCREASE MPG WHICH IS CURRENTLY', I7
     &        / '               (NOTE. MRG(NIMBUS).GE.MPG(CPOLYG)+2) ')
 9010 FORMAT( / ' *** ERROR *** VESS62 : ROOT ON ILLEGAL SIDE ' , I2
     &        , ' OF ESCAPE FIGURE ' , I5 )
 9012 FORMAT(   2(' ( ' , 1P , E12.5 , ',' , E12.5 , ')' ) )
 9020 FORMAT( / ' *** ERROR *** VESS62 : MULTI-ROOTS ON SIDE ' , I2
     &        , ' OF ESCAPE FIGURE ' , I5 )
 9030 FORMAT( / ' *** ERROR *** VESS62 : TOO MANY VESSEL POINTS INSIDE E
     &SCAPE FIGURE ' , I5 /
     &        ( 14X , ' (RESC,ZESC) = (' , 1PE12.4 , ',' , E12.4 , ')'))
 9040 FORMAT( / ' *** ERROR *** VESS62 : VESSEL IS WITHIN '
     &        , 1P , E12.4 , 'M OF A VERTEX'
     &        , ' IN ESCAPE FIGURE ' , I5
     &        / '               VERTEX : (' , E12.4 ,',', E12.4 , ')' )
 9050 FORMAT( / ' *** WARNING *** VESS62 : ATTEMPTING TO RECALL STRIP WI
     &TH ' , A  , ' LINES SWAPPED AND THEIR ORDER REVERSED.' /)
 9060 FORMAT( / ' *** ERROR *** VESS62 : 2ND CALL TO S.R. STRIP FOR '
     &        , A , ' POLYGON FAILED.  SOLUTION - CHANGE VESSEL.' )
 9070 FORMAT( / ' *** ERROR *** VESS62 : ' , A , ' POLYGONS ARE'
     &        , ' CUTTING OTHERS.  SOLUTION - CHANGE VESSEL.' )
 9075 FORMAT( / ' *** WARNING *** VESS62 : ' , A , ' POLYGONS ARE'
     &        , ' CUTTING OTHERS.  REVERSING S.R. STRIP ORDERING.' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      FUNCTION INDLRS( DESC , LOUT )
      IMPLICIT NONE
      INTEGER*4 INDLRS
C
C+ .....................................................................
C
C ROUTINE : INDEX OF LEAK RECYCLING SEGMENT
C           ---      -    -         -
C VERSION : V1.R1.M0
C
C PURPOSE : TO FIND WHICH LEAK RECYCLING SEGMENT LRS() MATCHES THE
C           PUMP LEAK DESCRIPTION LABEL.
C
C INPUT   : (C*1) DESC         = PUMP LEAK DESCRIPTION LABEL
C
C OUTPUT  : (I*4) INDLRS       = ELEMENT OF LRS() WHICH MATCHES STRING
C
C /CPUMP/ : (SEE 'cpump')
C
C PROGRAM : (I*4) I            = GENEREAL LOOP INTEGER
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 06/02/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      CHARACTER  DESC*(*)
      INTEGER*4  LOUT
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..PROGRAM
      INTEGER*4 I
C
C------------------------------ INITIALISE -----------------------------
C
      INDLRS = 0
C
C-----------------------------------------------------------------------
C
      DO 100 I = 1 , NLRS
         IF( LRS(I).EQ.DESC ) THEN
             IF( INDLRS.NE.0 ) THEN
                 WRITE(LOUT,1000) I , INDLRS , DESC
                 CALL EXITX(LOUT)
             ELSE
                 INDLRS = I
             END IF
         END IF
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(/ ' *** ERROR *** INDLRS : LRS(' , I2
     &      ,  ') MATCHES LRS(' , I2 , ') DESCRIPTOR ' , A )
C
      RETURN
      END
C
C=======================================================================
      FUNCTION I4CHRV(STRING)
      IMPLICIT NONE
      INTEGER*4 I4CHRV
      REAL*8   XREAD
      CHARACTER*(*) STRING
      IF( STRING.NE.' ' ) THEN
          READ(STRING,*) XREAD
      ELSE
          XREAD = 0.0D+00
      END IF
      I4CHRV = XREAD
      RETURN
      END
C
C=======================================================================
      FUNCTION SMIN(X,N)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SMIN
      DIMENSION X(N)
      SMIN=X(1)
      DO 10 K=2,N
      SMIN=DMIN1(SMIN,X(K))
   10 CONTINUE
      RETURN
      END
C
C=======================================================================
      FUNCTION SMAX(X,N)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SMAX
      DIMENSION X(N)
      SMAX=X(1)
      DO 10 K=2,N
      SMAX=DMAX1(SMAX,X(K))
   10 CONTINUE
      RETURN
      END
C
C=======================================================================
      FUNCTION SMIN1(X,N,L)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SMIN1
      DIMENSION X(N)
      L            = 1
      SMIN1        = X(L)
      DO 10 K      = 2 , N
         IF( X(K).LT.SMIN1 ) THEN
             L     = K
             SMIN1 = X(L)
         END IF
   10 CONTINUE
      RETURN
      END
C
C=======================================================================
      FUNCTION SMAX1(X,N,L)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 SMAX1
      DIMENSION X(N)
      L            = 1
      SMAX1        = X(L)
      DO 10 K      = 2 , N
         IF( X(K).GT.SMAX1 ) THEN
             L     = K
             SMAX1 = X(L)
         END IF
   10 CONTINUE
      RETURN
      END
C
C=======================================================================
       FUNCTION PYTHGS( X1 , Y1 , X2 , Y2 )
       IMPLICIT REAL*8(A-H,O-Z)
       REAL*8 PYTHGS
C
C-----------------------------------------------------------------------
C
C PURPOSE : CALCULATE THE LENGTH BETWEEN POINTS WITH COORDINATES
C           (X1,Y1) AND (X2,Y2).
C
C INPUT   : X1     = X-AXIS COORDINATE OF 1ST POINT
C           Y1     = Y-AXIS COORDINATE OF 1ST POINT
C           X2     = X-AXIS COORDINATE OF 2ND POINT
C           Y2     = Y-AXIS COORDINATE OF 2ND POINT
C
C OUTPUT  : PYTHGS = LENGTH BETWEEN THE TWO POINTS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 02/03/90
C
C-----------------------------------------------------------------------
C
       XDIFF  = X1 - X2
       YDIFF  = Y1 - Y2
C
       XDIFF2 = XDIFF * XDIFF
       YDIFF2 = YDIFF * YDIFF
C
       PYTHGS = DSQRT( XDIFF2 + YDIFF2 )
C
       RETURN
       END
C
C=======================================================================
       FUNCTION XPROD( X1 , Y1 , X2 , Y2 , X3 , Y3 )
       IMPLICIT NONE
       REAL*8 XPROD
C
C-----------------------------------------------------------------------
C
C PURPOSE : CALCULATE THE CROSS PRODUCT OF A TRIANGLE WITH VERTICES
C           (X1,Y1), (X2,Y2) & (X3,Y3)
C
C INPUT   : X1     = X-AXIS COORDINATE OF 1ST POINT
C           Y1     = Y-AXIS COORDINATE OF 1ST POINT
C           X2     = X-AXIS COORDINATE OF 2ND POINT
C           Y2     = Y-AXIS COORDINATE OF 2ND POINT
C           X4     = X-AXIS COORDINATE OF 3RD POINT
C           Y4     = Y-AXIS COORDINATE OF 3RD POINT
C
C OUTPUT  : XPROD  = CROSS-PRODUCT OF TRIANGLE
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C AUTHOR  : J.SPENCE & G.CORRIGAN
C           (K1/0/80)  EXT. 4866
C
C DATE    : 17/03/98
C
C-----------------------------------------------------------------------
C
C.. INPUT
       REAL*8 X1 , Y1 , X2 , Y2 , X3 , Y3
C
C.. LOCAL
       REAL*8 X12 , Y12 , X32 , Y32
C
C-----------------------------------------------------------------------
C
       X12  = X1 - X2
       Y12  = Y1 - Y2
       X32  = X3 - X2
       Y32  = Y3 - Y2
C
       XPROD = ( X12 * Y32 ) - ( Y12 * X32 )
C
       RETURN
       END
C
C=======================================================================
       SUBROUTINE CHKALB( MALBPG , IALBPG , IR , M , ITAGES )
       IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : DETERMINE IF WALL POLYGON M+2 IS TO BE SET AS AN ALBEDO
C           REGION OR NOT.
C
C INPUT   : MALBPG   = MAXIMUM ARRAY SIZE OF IALBPG()
C           IALBPG() >  0 --- M+2 POLYGON WHICH WILL BE AN ALBEDO REGION
C                    = IR --- SET POLYGON TO ALBEDO
C           IR       = REGION WHERE M LIES
C                    >= 0 --- DON'T CHECK REGION JUST POLYGON NUMBER
C                    = -1 --- PRIVATE REGION COVER
C                    = -2 --- OUTER (RHS) DIVERTOR WALL
C                    = -3 --- INNER (LHS) DIVERTOR WALL
C                    = -4 --- OUTER (RHS) CORNER WALL
C                    = -5 --- INNER (LHS) CORNER WALL
C                    = -6 --- OUTER (RHS) DIVERTOR TARGET WALL
C                    = -7 --- INNER (LHS) DIVERTOR TARGET WALL
C           M        = POLYGON INDEX UNDER INVESTIGATION
C
C I/O     : ITAGES   = 2 --- WALL   ESCAPE FIGURE POLYGON
C                    > 3 --- ALBEDO ESCAPE FIGURE POLYGON
C                            (IALBPG(I) : WHERE, I = ITAGES - 3)
C
C NOTE    : THE FIRST ALBEDO MATCH IN IALBPG() IS USED ANY OTHERS ARE
C           IGNORED.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 10/06/93
C
C HISTORY : 26/05/94 --- IR INTO ARGUEMENT LIST
C
C-----------------------------------------------------------------------
C
       DIMENSION IALBPG(MALBPG)
       LOGICAL LTRAN
C
       DO 100 I      = 1 , MALBPG
C
          IF( IALBPG(I).NE.0 ) THEN
C
              IF( IALBPG(I).LT.0 ) THEN
                  LTRAN  = IALBPG(I).EQ.IR
              ELSE
                  LTRAN  = IALBPG(I)-2.EQ.M
              END IF
C
              IF( LTRAN .AND. ITAGES.GE.2 ) THEN
                  ITAGES = I + 3
                  GOTO 9999
              END IF
C
          END IF
C
  100  CONTINUE
C
 9999  RETURN
       END
C
C=======================================================================
       SUBROUTINE CHKNUT( MNUTPG , INUTPG , IR , M , IRES )
       IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : DETERMINE IF WALL POLYGON M+2 IS TO BE SET AS AN NEUTRAL
C           RECYCLED REGION OR NOT.
C
C INPUT   : MNUTPG   = MAXIMUM ARRAY SIZE OF INUTPG()
C           INUTPG() >  0 --- M+2 POLYGON WILL BE A RECYCLED REGION
C                    = -9 --- M+2 POLYGON WILL BE A RECYCLED REGION
C           IR       = REGION WHERE M LIES
C                    >= 0 --- DON'T CHECK REGION JUST POLYGON NUMBER
C                    = 11 --- PRIVATE REGION COVER
C                    = 17 --- OUTER (RHS) DIVERTOR WALL
C                    = 18 --- INNER (LHS) DIVERTOR WALL
C                    = 19 --- OUTER (RHS) CORNER WALL
C                    = 20 --- INNER (LHS) CORNER WALL
C                    = 10 --- OUTER (RHS) DIVERTOR TARGET WALL
C                    = 12 --- INNER (LHS) DIVERTOR TARGET WALL
C                    = 13 --- BUFFLE
C           M        = POLYGON INDEX UNDER INVESTIGATION
C
C OUTPUT  : IRES     = 0 --- M+2 IS NOT A NEUTRAL RECYCLED REGION
C                    = I --- M+2 IS     A NEUTRAL RECYCLED REGION
C                            (I = INDEX OF INUTPG(I))
C
C NOTE    : THE FIRST REGION MATCH IN INUTPG() IS USED ANY OTHERS ARE
C           IGNORED.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 02/02/95
C
C HISTORY : V1.R2.M0 --- 08/02/95 --- EXTEND INUTPG() SPECIAL REGIONS
C                                 --- IR INTO ARGUEMENT LIST
C
C-----------------------------------------------------------------------
C
       DIMENSION INUTPG(MNUTPG)
       LOGICAL LTRAN
C
       IRES          = 0
C
       IF( (IR.GE.9.AND.IR.LE.13) .OR. (IR.GE.17.AND.IR.LE.20) ) THEN
           DO 100 I      = 1 , MNUTPG
              IF( ( INUTPG(I)-2.EQ.M               ) .OR.
     &            ( INUTPG(I).EQ.-1 .AND. IR.EQ.11 ) .OR.
     &            ( INUTPG(I).EQ.-2 .AND. IR.EQ.17 ) .OR.
     &            ( INUTPG(I).EQ.-3 .AND. IR.EQ.18 ) .OR.
     &            ( INUTPG(I).EQ.-4 .AND. IR.EQ.19 ) .OR.
     &            ( INUTPG(I).EQ.-5 .AND. IR.EQ.20 ) .OR.
     &            ( INUTPG(I).EQ.-6 .AND. IR.EQ.10 ) .OR.
     &            ( INUTPG(I).EQ.-7 .AND. IR.EQ.12 ) .OR.
     &            ( INUTPG(I).EQ.-8 .AND. IR.EQ.13 ) .OR.
     &            ( INUTPG(I).EQ.-9                )      ) THEN
                    IRES   = I
                    GOTO 9999
              END IF
  100      CONTINUE
       END IF
C
 9999  RETURN
       END
C
C=======================================================================
       SUBROUTINE CHKPSP( MPSEMP , IPSEMP , M , IRES )
       IMPLICIT NONE
C
C+ .....................................................................
C
C PURPOSE : DETERMINE IF WALL POLYGON M+2 IS TO BE SET AS AN INDIVIDUAL
C           SEMI-PERMEANABILITY POLYGON OR NOT.
C
C INPUT   : (I*4) MPSEMP   = MAXIMUM ARRAY SIZE OF IPSEMP()
C           (I*4) IPSEMP() > 0 --- M+2 POLYGON WILL BE AN INDIVIDUAL
C                                  POLYGON
C           (I*4) M        = POLYGON INDEX UNDER INVESTIGATION
C
C OUTPUT  : (I*4) IRES     = 0 --- M+2 IS NOT AN INDIVIDUAL POLYGON
C                          = I --- M+2 IS     AN INDIVIDUAL POLYGON
C                                  (I = INDEX OF IPSEMP(I))
C
C PROGRAM : (I*4) I        = GENERAL INTEGER
C
C NOTE    : THE FIRST POLYGON MATCH IN IPSEMP() IS USED ANY OTHERS ARE
C           IGNORED.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 02/02/95
C
C HISTORY :
C
C- .....................................................................
C
C..INPUT
       INTEGER*4 MPSEMP , IPSEMP(MPSEMP) , M
C
C..OUTPUT
       INTEGER*4 IRES
C
C..PROGRAM
       INTEGER*4 I
C
C-----------------------------------------------------------------------
C
       IRES          = 0
C
       DO 100 I      = 1 , MPSEMP
          IF( IPSEMP(I)-2.EQ.M ) THEN
              IRES   = I
              GOTO 9999
          END IF
  100  CONTINUE
C
 9999  RETURN
       END
C
C=======================================================================
      SUBROUTINE STRIP(IOUT,LREVS,MN,NL,NR,XL,YL,XR,YR,LV,NE,LTOP,IER)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     AUTOMATIC MESHING OF A (POSSIBLY CLOSED) CURVILINEAR STRIP
C
C     THE ADOPTED CRITERION IS PURELY LOCAL: ONE CONSIDERS THE FIRST
C     FOUR POINTS AND INSERTS A QUADRANGLE WHENEVER THE FOLLOWING
C     CONDITIONS ARE MET:
C         A) THE RATIO BETWEEN THE SQUARE OF THE DIAGONALS IS LESS THAN
C            THE GIVEN RHOMBUS PARAMETER (SKEW=0.25);
C         B) THE QUADRANGLE IS CONVEX;
C         C) ITS VERTICES ARE GIVEN CONTERCLOCKWISE WITH RESPECT TO
C            THE ADOPTED TOPOLOGY
C     OTHERWISE THE ROUTINE INSERTS A TRIANGLE, WITH JUST ONE VERTEX
C     ON THE RIGHT OR ON THE LEFT, SO AS TO MINIMISE THE AREA.
C     IF THE VERTICES OF THE TRIANGLE OF MINIMAL AREA TURN OUT NOT
C     TO BE COUNTERCLOCKWISE, THE ROUTINE STOPS AND SIGNALS THE ERROR.
C
C ... IF LREVS=.TRUE. THEN REVERSE POLYGON ORDER IF POLCHK DETECTS
C     POLYGON IS IN CLOCKWISE ORDER AND TRY AGAIN.
C
C======================================================================
C    INPUT VALUES:
C          IOUT    > 0 --- OUTPUT MESSAGES
C          LREVS   .TRUE. --- REVERSE POLYGON ORDER IF POLCHK DETECTS
C                             ORDER IS CLOCKWISE THEN TRY AGAIN.
C          NL      NUMBER OF POINTS ALONG THE SIDE 1 (>1) CALLED "LEFT"
C          NR         "     "           "      "   2 (>1) CALLED "RIGHT"
C                  POINTS FROM "BOTTOM" TO "TOP"
C          XL,YL   COORDINATES OF THE NODAL POINTS ALONG THE SIDE 1
C          XR,YR      "             "           "             "   2
C    OUTPUT VALUES:
C          LV      LENGTH OF VECTOR LTOP
C          NE      NUMBER OF ELEMENTS INTRODUCED IN THE STRIP
C          LTOP    VECTOR CONTAINING THE INDICES OF NODES DEFINING THE
C                  REGIONS,COUNTED FROM "BOTTOM" TO "TOP",STARTING FROM
C                  SIDE 1 AND CONTINUING ON SIDE 2. THE SENSE IS
C                  COUNTERCLOCKWISE WITH RESPECT TO THE TOPOLOGY OF
C                  "LEFT" AND "RIGHT","TOP" AND "BOTTOM" ADOPTED.
C                  THE FIRST VERTEX IS NEGATIVE FOR TRIANGLES.
C                  FIRST VERTEX IN EACH FIGURE BELONGS TO THE LINE 2.
C
C=======================================================================
C
      DIMENSION XL(MN),YL(MN),XR(MN),YR(MN),LTOP(4*MN)
      DIMENSION XV(4),YV(4)
C
      LOGICAL LREVS
C
      DATA SKEW/0.25/
C
C              PRESET COUNTERS (KL COUNTS ON THE LEFT, KR ON THE RIGHT)
      IER=0
      LV=0
      NE=0
      KL=1
      KR=1
C              EXHAUSTED THE POINTS ON ONE OF THE TWO SIDES?
  100 IF(KL.EQ.NL) GO TO 330
      IF(KR.EQ.NR) GO TO 350
C              NO. TRY A QUADRANGLE
C                  ----------------
      XV(1)=XR(KR)
      YV(1)=YR(KR)
      XV(2)=XR(KR+1)
      YV(2)=YR(KR+1)
      XV(3)=XL(KL+1)
      YV(3)=YL(KL+1)
      XV(4)=XL(KL)
      YV(4)=YL(KL)
C              CHECK RATIO OF DIAGONALS (DEGREE OF SKEW)
      D13=(XV(1)-XV(3))**2+(YV(1)-YV(3))**2
      D24=(XV(2)-XV(4))**2+(YV(2)-YV(4))**2
      IF(D13/D24.LT.SKEW .OR. D24/D13.LT.SKEW) GO TO 300
C              CHECK WHETHER CONVEX AND COUNTERCLOCKWISE
      CALL POLCHK(0,4,XV,YV,0,IERR)
      IF( LREVS .AND. IERR.EQ.2 ) THEN
          CALL REVERS(4,XV)
          CALL REVERS(4,YV)
          CALL POLCHK(0,4,XV,YV,0,IERR)
      END IF
      IF(IERR.GT.0) GO TO 300
C              ACCEPT THE QUADRANGLE
      LTOP(LV+1)=NL+KR
      LTOP(LV+2)=NL+KR+1
      LTOP(LV+3)=KL+1
      LTOP(LV+4)=KL
C===================================================================----
C     WRITE(IOUT,10)NL+KR,NL+KR+1,KL+1,KL
C  10 FORMAT(4I5)
C===================================================================----
      LV=LV+4
      NE=NE+1
      KL=KL+1
      KR=KR+1
      GO TO 500
C              TRY A TRIANGLE
C              --------------
C              SINGLE VERTEX ON THE LEFT OR SINGLE VERTEX ON THE RIGHT?
  300 IF((XL(KL)-XR(KR+1))**2+(YL(KL)-YR(KR+1))**2 .GT.
     *   (XR(KR)-XL(KL+1))**2+(YR(KR)-YL(KL+1))**2) GO TO 350
C              INSERT TRIANGLE WITH SINGLE VERTEX ON THE LEFT
  330 LTOP(LV+1)=-(NL+KR)
      LTOP(LV+2)=NL+KR+1
      LTOP(LV+3)=KL
C===================================================================----
C     WRITE(IOUT,10)NL+KR,NL+KR+1,KL
C===================================================================----
C              CHECK WHETHER COUNTERCLOCKWISE
      XV(1)=XR(KR)
      YV(1)=YR(KR)
      XV(2)=XR(KR+1)
      YV(2)=YR(KR+1)
      XV(3)=XL(KL)
      YV(3)=YL(KL)
      CALL POLCHK(0,3,XV,YV,0,IERR)
      IF( LREVS .AND. IERR.EQ.2 ) THEN
          CALL REVERS(3,XV)
          CALL REVERS(3,YV)
          CALL POLCHK(0,3,XV,YV,0,IERR)
      END IF
      IF(IERR.GT.0) GO TO 390
C              ACCEPT TRIANGLE WITH SINGLE VERTEX ON THE LEFT
      KR=KR+1
      LV=LV+3
      NE=NE+1
      GO TO 500
C              INSERT TRIANGLE WITH SINGLE VERTEX ON THE RIGHT
  350 LTOP(LV+1)=-(NL+KR)
      LTOP(LV+2)=KL+1
      LTOP(LV+3)=KL
C===================================================================----
C     WRITE(LOUT,10)NL+KR,KL+1,KL
C===================================================================----
C              CHECK WHETHER COUNTERCLOCKWISE
      XV(1)=XR(KR)
      YV(1)=YR(KR)
      XV(2)=XL(KL+1)
      YV(2)=YL(KL+1)
      XV(3)=XL(KL)
      YV(3)=YL(KL)
      CALL POLCHK(0,3,XV,YV,0,IERR)
      IF( LREVS .AND. IERR.EQ.2 ) THEN
          CALL REVERS(3,XV)
          CALL REVERS(3,YV)
          CALL POLCHK(0,3,XV,YV,0,IERR)
      END IF
      IF(IERR.GT.0) GO TO 390
C              ACCEPT TRIANGLE WITH SINGLE VERTEX ON THE RIGHT
      KL=KL+1
      LV=LV+3
      NE=NE+1
      GO TO 500
C              ERROR
  390 IF( IOUT.GT.0 ) THEN
          WRITE(IOUT,399) IERR,KL,KR-NL
          WRITE(IOUT,'(A,1P,2E12.4)') ' KR   : ' , XR(KR)   , YR(KR)
          IF( KR+1.LE.NR )
     >      WRITE(IOUT,'(A,1P,2E12.4)') ' KR+1 : ' , XR(KR+1) , YR(KR+1)
          WRITE(IOUT,'(A,1P,2E12.4)') ' KL   : ' , XL(KL)   , YL(KL)
          IF( KL+1.LE.NL )
     >      WRITE(IOUT,'(A,1P,2E12.4)') ' KL+1 : ' , XL(KL+1) , YL(KL+1)
      END IF
  399 FORMAT(//' ERROR MESSAGE: UNABLE TO INSERT A PROPER TRIANGLE IN TH
     *E STRIP.  (IERR=' , I2 ,')'
     */' ERROR OCCURRED ABOVE',I4,'-TH POINT ON SIDE 1 AND',I4,
     *'-TH POINT ON SIDE 2')
C     STOP
      IER = IERR
      GOTO 9999
C              STRIP FINISHED?
  500 IF(KL.LT.NL .OR. KR.LT.NR) GO TO 100
C              YES
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE POLCHK(IREG,N,VX,VY,IOUT,IERR)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     VERIFY CONVEXITY (WITH A CERTAIN TOLERANCE) AND
C     THE COUNTERCLOCKWISE ORDERING OF VERTICES
C
C-----------------------------------------------------------------------
C     IOUT=K  FILE TO RECEIVE DIAGNOSTICS (E.G. 6)
C         =0  NO PRINTOUT OF DIAGNOSTICS
C
C     IERR=0 POLYGON IS CONVEX AND VERTICES COUNTERCLOCKWISE: O.K.
C     IERR=1 POLYGON CONCAVE                                : ERROR
C     IERR=2 VERTICES IN WRONG (CLOCKWISE) ORDER            : ERROR
C-----------------------------------------------------------------------
C
      DIMENSION  VX(N),VY(N)
C
      DATA ISTOP/1/
C                               VERIFY CONVEXITY
C         GIVEN THE THREE VECTORS P1-O,P2-O,P3-O (FROM THE ORIGIN),
C         THE VECTOR PRODUCT OF P2-P1 AND P3-P1 IS GIVEN BY
C         FISK=(PY(3)-PY(1))*(PX(2)-PX(1))-(PX(3)-PX(1))*(PY(2)-PY(1))
      IERR=0
      DO 60 I=1,N
      J=I+1
      IF(J.GT.N) J=1
      KPOS=0
      KNEG=0
      NM2=N-2
C                               VERIFY THE SIGN OF THE OTHER VERTICES
C                               WITH RESPECT TO THE FIRST PAIR
      DO 20 K=1,NM2
      L=MOD(J-1+K,N)+1
      FISK=(VY(L)-VY(I))*(VX(J)-VX(I))-(VX(L)-VX(I))*(VY(J)-VY(I))
C                               TOLERANCE CHECK BEGINS
       DIJ=DSQRT((VX(I)-VX(J))**2+(VY(I)-VY(J))**2)
       DJL=DSQRT((VX(J)-VX(L))**2+(VY(J)-VY(L))**2)
       TRAN=DABS(FISK/(DIJ*DJL*0.5))
       IF( TRAN.LT.1.0E-02) THEN
       KPOS=KPOS+1
       GOTO 20
       END IF
C                               TOLERANCE CHECK ENDS
      IF(FISK.GT.0.0) KPOS=KPOS+1
      IF(FISK.LT.0.0) KNEG=KNEG+1
   20 CONTINUE
      IF(KPOS*KNEG.EQ.0) GOTO 40
      IERR=1
      IF(IOUT.GT.0) WRITE(IOUT, 30 )
   30 FORMAT(/' NON-CONVEX POLYGON')
      GO TO 55
   40 IF(KNEG.EQ.0) GOTO 60
      IERR=2
      IF(IOUT.GT.0) WRITE(IOUT, 50 )
   50 FORMAT(/' POLYGON VERTICES MUST BE ASSIGNED COUNTERCLOCKWISE')
   55 IF(IOUT.GT.0) WRITE(IOUT,56) IREG
   56 FORMAT(' POLYGON IS',I6,' AND ITS VERTICES ARE:')
      IF(IOUT.GT.0) WRITE(IOUT,57) (VX(IJK),VY(IJK),IJK=1,N)
   57 FORMAT(1P,2E16.6)
      IF(IOUT.LE.0) GO TO 60
      IF(ISTOP.EQ.0) THEN
         WRITE(IOUT,*)' *** POLCHK. STOP AND EXIT.'
         CALL EXITX(IOUT)
      END IF
   60 CONTINUE
      RETURN
C
      ENTRY SPLCHK(ISTO)
      ISTOP=ISTO
      RETURN
      END
C
C=======================================================================
      SUBROUTINE FXPOLY( IOUT   , ITYPE  , LREVS
     I                 , MPOLY  , MVERT  , NSTRIP
     I                 , NLINE1 , RLINE1 , ZLINE1
     I                 , NLINE2 , RLINE2 , ZLINE2
     O                 , NPOLY  , NVERT
     O                 , RVERT  , ZVERT  , ITAGES
     O                 , LTOP
     O                 , IER    )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : FIX POLYGONS
C           - - ----
C VERSION : V1.R2.M1
C
C PURPOSE : TO CONSTRUCT POLYGONS BETWEEN TWO LINES
C
C INPUT   : (I*4) IOUT        > 0 --- OUTPUT CHANNEL
C           (I*4) ITYPE       = 0 --- PLASMA STRIP
C                             = 1 --- VOID   STRIP
C                             = 2 --- WALL   STRIP
C                             = 3 --- ALBEDO STRIP
C           (LOG) LREVS       = .T. --- IF POLCHK ROUTINE DETECTS
C                                       CLOCKWISE ORDER THEN REVERSE
C                                       POLYGON ORDER AND TRY AGAIN.
C
C           (I*4) MPOLY       = MAXIMUM NUMBER OF POLYGONS
C           (I*4) MVERT       = MAXIMUM NUMBER OF VERTICES
C           (I*4) NSTRIP      = MAXIMUM SIZE OF LINE 1 & 2
C
C           (I*4) NLINE1      = NUMBER OF POINTS FORMING LINE 1
C           (R*8) RLINE1()    = R-COORDINATES OF LINE 1
C           (R*8) ZLINE1()    = Z-COORDINATES OF LINE 1
C
C           (I*4) NLINE2      = NUMBER OF POINTS FORMING LINE 2
C           (R*8) RLINE2()    = R-COORDINATES OF LINE 2
C           (R*8) ZLINE2()    = Z-COORDINATES OF LINE 2
C
C I/O     : (I*4) NPOLY       = POLYGON NUMBER OF ESCAPE FIGURE
C           (I*4) NVERT()     = NUMBER OF VERTICES FORMING ESCAPE FIGURE
C           (R*4) RVERT(,IV)  = R-COORDINATE OF VERTEX IV
C           (R*4) ZVERT(,IV)  = Z-COORDINATE OF VERTEX IV
C           (I*4) ITAGES()    = 1 --- VOID POLYGON
C                             = 2 --- WALL POLYGON
C
C OUTPUT  : (I*4) LTOP()      = ORDER OF VERTICES OF POLYGON STARTING ON
C                               LINE 1, WHERE
C                               1ST VERTEX .GT. 0 --- 4-SIDED POLYGON
C                               1ST VERTEX .LT. 0 --- 3-SIDED POLYGON
C
C           (I*4) IER         = 0 --- ROUTINE SUCCESSFUL
C                             = 1 --- STRIP ERROR
C                             = 2 --- STRIP ERROR
C                             = 3 --- NLINE1 .GT. NSTRIP
C                             = 4 --- NLINE2 .GT. NSTRIP
C
C PROGRAM : (I*4) L           = GENERAL INTEGER
C           (I*4) IVERT       = VERTEX  INTEGER
C           (I*4) LV          = LENGTH OF VECTOR LTOP
C           (I*4) NE          = NUMBER OF ELEMENTS INTRODUCED INTO STRIP
C                               BETWEEN LINE 1 & LINE 2
C           (I*4) LTOPA       = IABS( LTOP() )
C
C METHOD  : A SERIES OF POLYGONS ARE CONSTRUCTED FROM TWO LINES AFTER
C           PROCESSING VIA 'STRIP' WHICH ASSIGNS POINTS FORMING THE
C           TWO LINES INTO VERTICES OF A POLYGON (SEE LTOP).
C
C ROUTINE : STRIP
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C HISTORY : V1.R1.M0 --- 06/10/93 --- CREATION
C           V1.R2.M0 --- 07/07/97 --- LREVS OPTION
C           V1.R2.M1 --- 27/03/98 --- BUG FIX IN '9000 FORMAT'
C
C.......................................................................
C
C..INPUT
      INTEGER*4 IOUT      , ITYPE
     &        , NLINE1    , NLINE2    , NSTRIP
      REAL*8    RLINE1(*) , ZLINE1(*)
     &        , RLINE2(*) , ZLINE2(*)
      LOGICAL   LREVS
C
C..I/O
      INTEGER*4 MPOLY              , MVERT              , NPOLY
     &        , ITAGES(*)          , NVERT(*)
      REAL*8    RVERT(MPOLY,MVERT) , ZVERT(MPOLY,MVERT)
C
C..OUTPUT
      INTEGER*4 LTOP(*) , IER
C
C..PROGRAM
      INTEGER*4 L       , IVERT
     &        , LV      , NE       , LTOPA
C
C........................... CALL STRIP ................................
C
      CALL STRIP( IOUT      , LREVS , NSTRIP    , NLINE1    , NLINE2
     &          , RLINE1(1) , ZLINE1(1)
     &          , RLINE2(1) , ZLINE2(1)
     &          , LV        , NE        , LTOP(1)
     &          , IER       )
C
      IF( IER.NE.0 ) GOTO 9999
C
C.......................... CONSTRUCT POLYGONS .........................
C
      IVERT                     = 0
C
      DO 100 L                  = 1 , LV
C
         IF( IVERT.EQ.0 ) THEN
             IF( L.GT.1 ) NPOLY = NPOLY + 1
             IF( NPOLY.GT.MPOLY ) THEN
                 WRITE(IOUT,9000) MPOLY
                 CALL EXITX(IOUT)
            END IF
             IF( LTOP(L).GT.0 ) THEN
                 NVERT(NPOLY)   = 4
             ELSE
                 NVERT(NPOLY)   = 3
             END IF
             ITAGES(NPOLY)      = ITYPE
         END IF
C
         IVERT                  = IVERT + 1
C
         LTOPA                  = IABS( LTOP(L) )
C
         IF( LTOPA.LE.NLINE1 ) THEN
             RVERT(NPOLY,IVERT) = RLINE1(LTOPA)
             ZVERT(NPOLY,IVERT) = ZLINE1(LTOPA)
         ELSE
             RVERT(NPOLY,IVERT) = RLINE2(LTOPA-NLINE1)
             ZVERT(NPOLY,IVERT) = ZLINE2(LTOPA-NLINE1)
         END IF
C
         IF( IVERT.EQ.NVERT(NPOLY) ) IVERT = 0
C
  100 CONTINUE
C
C.......................................................................
C
 9000 FORMAT(/' *** ERROR *** FXPOLY : NUMBER OF POLYGONS EXCEEDS MAXIMU
     &M (' , I6 , ')' /)
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE IREGON( MP , ITAG , JPRGT , JPLFT , NXW , IOPEN , K
     &                 , IR )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C ROUTINE : IREGON
C
C VERSION : V2.R1.M0
C
C PURPOSE : TO DETERMINE IN WHICH REGION MESH POINT K LIES
C
C INPUT   :  (I*4)   MP      = MAXIMUM NUMBER OF POINTS
C            (I*4)   ITAG(,) = TAG OF K-MESH POINTS
C            (I*4)   JPRGT   = BORDER RHS DIVERTOR REGION ROW
C            (I*4)   JPLFT   = BORDER LHS DIVERTOR REGION ROW
C            (I*4)   NXW     = WALL RING
C            (I*4)   IOPEN   = FIREST OPEN RING
C            (I*4)   K       = MESH POINT INDEX
C
C OUTPUT  :  (I*4)   IR      = 0 --- DISALLOWED POINT (I.E VIRTUAL)
C                            = 1 --- INSIDE CORE
C                            = 2 --- MAIN.SOL
C                            = 3 --- OUTER DIVERTOR SOL
C                            = 4 --- INNER DIVERTOR SOL
C                            = 5 --- OUTER DIVERTOR PRIVATE
C                            = 6 --- INNER DIVERTOR PRIVATE
C
C ASSUME  : K-MESH POINT LIES ON A ROW
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 -- 10/11/93 -- CREATION
C           V2.R1.M0 -- 03/05/94 -- REMOVE COMMON BLOCKS AND MOVE
C                                   APPROPRIATE QUANTITIES INTO
C                                   ARUGEMENT LIST.  UPGRADE FUNCTION TO
C                                   A FULL SUBROUTINE.
C
C.......................................................................
C
      DIMENSION ITAG(MP,5)
C
C-----------------------------------------------------------------------
C
      IR       = 0
C
      I        = ITAG(K,1)
      J        = ITAG(K,2)
C
C..(VIRTUAL POINTS)
      IF( J.LE.0 ) THEN
          IF( ITAG(K,4).LT.0 .OR. J.LT.0 ) GOTO 9999
          IF( ITAG(K,4).EQ.4 ) J = ITAG(K+1,2) - 1
          IF( ITAG(K,4).EQ.5 ) J = ITAG(K-1,2) + 1
      END IF
C
C..(OUTER DIV)
      IF( J.LT.JPRGT .AND. JPRGT.GT.0 ) THEN
          IF( I.LE.NXW ) THEN
              IR     = 3
          ELSE
              IR     = 5
          END IF
C..(INNER DIV)
      ELSE IF( J.GT.JPLFT .AND. JPLFT.GT.0 ) THEN
          IF( I.LE.NXW ) THEN
              IR     = 4
          ELSE
              IR     = 6
          END IF
C..(MAIN BODY)
      ELSE
          IF( I.LT.IOPEN ) THEN
              IR     = 1
          ELSE
              IR     = 2
          END IF
      END IF
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SETORD( MVESM
     I                 , NVESM  , RVESM  , ZVESM
     I                 , RI     , ZI     , RJ    , ZJ
     O                 , ISTART , JSTART , IER        )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : SET-UP INITIALISATION FOR VESSEL SEQUENTIAL ORDERING ROUTINE
C           ---                                         ---
C PURPOSE : TO GET ISTART AND JSTART (NECESSARY TO ROUTINE 'VESORD')
C           FROM COORDINATES (RI,ZI) & (RJ,ZJ).
C
C INPUT   :  (I*4)   MVESM     = MAXIMUM NUMBER OF VESSEL SEGMENT PAIRS
C            (I*4)   NVESM     = NO. OF VESSEL SEGMENT PAIRS
C            (R*4)   RVESM(,1) = R-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = R-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C            (R*4)   ZVESM(,1) = Z-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = Z-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C            (R*4)   RI        = R-COORD WHICH IDENTIFIES ISTART
C            (R*4)   ZI        = Z-COORD WHICH IDENTIFIES ISTART
C            (R*4)   RJ        = R-COORD WHICH IDENTIFIES JSTART
C            (R*4)   ZJ        = Z-COORD WHICH IDENTIFIES JSTART
C
C OUTPUT  :  (I*4)   ISTART    = STARTING SEGMENT
C            (I*4)   JSTART    = STARTING VERTEX OF ISTART
C            (I*4)   IER       = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- UNABLE TO MATCH (R1,Z1) & (R2,Z2)
C                                      TO SEGMENT PAIR
C
C PROGRAM :  (I*4)   I         = SEGMENT
C            (I*4)   JHEAD     = HEAD VERTEX OF SEGMENT I
C            (I*4)   JTAIL     = TAIL VERTEX OF SEGMENT I
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 29/11/93 --- CREATION
C           V1.R2.M0 --- 15/12/98 --- POSSIBLE THAT (RI,ZI) & (RJ,ZJ)
C                                     DO NOT LIE IN THE SAME SEGMENT.
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MVESM          , NVESM
      REAL*4     RVESM(MVESM,2) , ZVESM(MVESM,2)
     *        ,  RI             , ZI
     *        ,  RJ             , ZJ
C
C..OUTPUT
      INTEGER*4  ISTART         , JSTART         , IER
C
C..PROGRAM
      INTEGER*4  I , IP1 , IM1  , JHEAD          , JTAIL
C
C---------------------------- INITIALIZE -------------------------------
C
      IER              = 0
C
      ISTART           = 0
      JSTART           = 0
C
C------------------- STARTING POSITION FOR ORDERING --------------------
C
      DO 100 I = 1 , NVESM
C
C....... SEGMENTS ADJACENT TO I
         IP1   = I + 1
         IM1   = I - 1
C
         IF( IP1.GT.NVESM ) IP1 = 1
         IF( IP1.LT.1     ) IM1 = NVESM
C
C....... CHECK EACH VERTEX FOR MATCHING AS NO ORDERING IS ASSUMED
         DO 150 JHEAD  = 1 , 2
C
C.......... ADJACIENT VERTEX TO JHEAD
            IF( JHEAD.EQ.1 ) THEN
                JTAIL  = 2
            ELSE
                JTAIL  = 1
            END IF
C
C.......... DOES JHEAD VERTEX MATCH (RI,ZI) ?
            IF( RI.EQ.RVESM(I,JHEAD) .AND. ZI.EQ.ZVESM(I,JHEAD) ) THEN
C
C.............. DOES JTAIL VERTEX MATCH (RJ,ZJ) ?
                IF( RJ.EQ.RVESM(I,JTAIL).AND.ZJ.EQ.ZVESM(I,JTAIL) ) THEN
                    ISTART = I
                    JSTART = JTAIL
                    GOTO 9999
C
C.............. DOES VERTEX OF AN ADJACENT SEGMENT MATCH (RJ,ZJ) ?
                ELSE IF( ( RJ.EQ.RVESM(IP1,1) .AND. ZJ.EQ.ZVESM(IP1,1) )
     &                                        .OR.
     &                   ( RJ.EQ.RVESM(IP1,2) .AND. ZJ.EQ.ZVESM(IP1,2) )
     &                                        .OR.
     &                   ( RJ.EQ.RVESM(IM1,1) .AND. ZJ.EQ.ZVESM(IM1,1) )
     &                                        .OR.
     &                   ( RJ.EQ.RVESM(IM1,2) .AND. ZJ.EQ.ZVESM(IM1,2) )
     &                 ) THEN
                    ISTART = I
                    JSTART = JTAIL
                    GOTO 9999
                END IF
            END IF
C
  150    CONTINUE
C
  100 CONTINUE
C
      IER              = 1
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE VESORD( MVESM , ISTART , JSTART , LSTART
     I                 , NVESM , RVESM  , ZVESM
     I                 , MSEGO , ISEGO
     O                 , NVESO , IER )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : VESSEL SEGMENT ORDERING
C           ---            ---
C VERSION : V1.R2.M0
C
C PURPOSE : TO FORM VESSEL SEGMENT PAIRS INTO A SEQUENTIAL ORDER,
C           WHERE ISEGO() WILL MATCH THE VESSEL SEGMENT PAIRS,
C           STARTING AT THE VERTEX # JSTART OF THE SEGMENT # ISTART.
C
C INPUT   :  (I*4)   MVESM     = MAXIMUM NUMBER OF VESSEL SEGMENT PAIRS
C            (I*4)   ISTART    = STARTING SEGMENT
C            (I*4)   JSTART    = STARTING VERTEX OF ISTART
C            (L  )   LSTART    = T --- PLACE NON-JSTART VERTEX OF
C                                      SEGMENT ISTART INTO FIRST ELEMENT
C                                      OF THE SEQUENTIAL ORDERING VECTOR
C            (I*4)   NVESM     = NO. OF VESSEL SEGMENT PAIRS
C            (R*4)   RVESM(,1) = R-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = R-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C            (R*4)   ZVESM(,1) = Z-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = Z-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C                                (NB. PAIRS WILL BE ORDERED SEQUENTIALLY
C                                     ON EXIT (VIA RVESM(,0),ZVESM(,0))
C            (I*4)   MSEGO     = SIZE OF ISEGO() (.GE.MVESM)
C
C
C OUTPUT  :  (I*4)   NVESO     = NO. OF SEQUENTIAL ORDERED VESSEL POINTS
C            (I*4)   ISEGO()   > 0 --- SEGMENT PAIR INDEX WHICH MATCHES
C                                      SEQUENTIAL ORDERED SEGMENT
C                                      (DO NOT REVERSE PAIRS)
C                              = 0 --- NOT APPLICABLE
C                              < 0 --- SEGMENT PAIR INDEX WHICH MATCHES
C                                      SEQUENTIAL ORDERED SEGMENT
C                                      (REVERSE PAIRS)
C            (I*4)   IER       = 0 --- ROUTINE SUCCESSFUL
C                              =-1 --- ISTART OUTSIDE RANGE
C                              =-2 --- JSTART OUTSIDE RANGE
C                              =-3 --- ISTART & JSTART OUTSIDE RANGE
C                              =-4 --- MSEGO < MVESM
C                              =-5 --- NSEGO .NE. NVESM + 1
C                              > 0 --- UNABLE TO JOIN SEGMENTS INTO A
C                                      SEQUENTIAL ORDER.
C
C PROGRAM :  (I*4)   INOSE     = NOSE SEGMENT
C            (I*4)   ITAIL     = TAIL SEGMENT WHICH JOINS ONTO NOSE
C            (R*4)   RNOSE     = R-COORD VERTEX OF NOSE WHICH JOINS TAIL
C            (R*4)   ZNOSE     = Z-COORD VERTEX OF NOSE WHICH JOINS TAIL
C            (R*4)   RTAIL()   = R-COORD VERTICIES OF TAIL ONE OF WHICH
C                                MAY JOIN NOSE (NO ORDERING IS ASSUMED)
C            (R*4)   ZTAIL()   = Z-COORD VERTICIES OF TAIL ONE OF WHICH
C                                MAY JOIN NOSE (NO ORDERING IS ASSUMED)
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 29/11/93 --- CREATION
C           V1.R2.M0 --- 05/12/93 --- ORDER ORIGINAL SEGMENTS USING
C                                     ISEGO().
C                                 --- REMOVE RVESM(,0) , ZVESM(,0)
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MVESM            , ISTART           , JSTART
     *        ,  NVESM            , MSEGO
      INTEGER*4  ISEGO(MSEGO)
      LOGICAL    LSTART
C
C..I/O
      REAL*4     RVESM(MVESM,2) , ZVESM(MVESM,2)
C
C..OUTPUT
      INTEGER*4  NVESO            , IER
C
C..PROGRAM
      INTEGER*4  INOSE            , ITAIL            , JTAIL
      REAL*4     RNOSE            , ZNOSE
     *        ,  RTAIL(2)         , ZTAIL(2)
C
C---------------------------- INITIALIZE -------------------------------
C
      IER              = 0
      NVESO            = 0
C
C------------------------------ CHECK ----------------------------------
C
C
      IF( ISTART.LT.1 .OR. ISTART.GT.NVESM ) IER = -1
      IF( JSTART.LT.1 .OR. JSTART.GT.2     ) IER = IER - 2
C
      IF( MSEGO.LT.MVESM ) IER = -4
C
      IF( IER.NE.0 ) GOTO 9999
C
C------------------- STARTING POSITION FOR ORDERING --------------------
C
      NVESO            = 0
C
      INOSE            = ISTART
C
      NVESO            = NVESO + 1
      RNOSE            = RVESM(INOSE,JSTART)
      ZNOSE            = ZVESM(INOSE,JSTART)
C
      ISEGO(NVESO)     = ISTART * ( 2*JSTART - 3 )
C
C----------------------------- MAIN ------------------------------------
C (1) FOR EACH VESSEL SEGMENT PAIR FIND WHICH VERTEX OF ANOTHER
C     VESSEL SEGMENT PAIR SHARES THE SAME VERTEX.  (NO ORDERING OF THE
C     VESSEL SEGMENT PAIRS IS ASSUMED).
C (2) THIS VERTEX IS STORED IN SEQUENTIAL (NOSE-TO-TAIL) ORDER VECTOR
C (3) IF A SHARED VERTEX IS NOT FOUND THEN SET THE ERROR CONDITION
C     AND EXIT.
C-----------------------------------------------------------------------
C
C.. START LOOP
   10 CONTINUE
C
C.. LOOP OVER OF SEGMENTS TO FIND TAIL SEGMENT TO ABOVE NOSE SEGMENT
      DO 100 ITAIL     = 1 , NVESM
C
C.. EXCLUDE TAIL SEGMENT IS SAME AS NOSE SEGMENT
         IF( INOSE.NE.ITAIL ) THEN
C
C.. PRIMARY COORDINATES OF TAIL SEGMENT
             RTAIL(1)  = RVESM(ITAIL,1)
             ZTAIL(1)  = ZVESM(ITAIL,1)
C
C.. SECONDARY COORDINATES OF TAIL SEGMENT
             RTAIL(2)  = RVESM(ITAIL,2)
             ZTAIL(2)  = ZVESM(ITAIL,2)
C
C.. DON'T CONSIDER UNITARY SEGMENTS (UNLIKELY PROPOSITION !)
             IF( RTAIL(1).EQ.RTAIL(2) .AND. ZTAIL(1).EQ.ZTAIL(2) )
     >           GOTO 100
C
C.. DOES PRIMARY COORDS OF NOSE SEGMENT MATCH ANY COORDS OF TAIL SEGMENT
C.. IF SO, THE PICK OTHER VERTEX FOR FURTHER PROCESSING
                  IF( RNOSE.EQ.RTAIL(1) .AND. ZNOSE.EQ.ZTAIL(1) ) THEN
                 JTAIL = 2
             ELSE IF( RNOSE.EQ.RTAIL(2) .AND. ZNOSE.EQ.ZTAIL(2) ) THEN
                 JTAIL = 1
             ELSE
                 JTAIL = 0
             END IF
C
C.. IF A MATCH HAS OCCURED THEN PLACE OTHER TAIL COORD IN ORDER VECTOR
            IF( JTAIL.NE.0 ) THEN
C
C.. ERROR : IF NVESO + 1 > MVESM
                IF( NVESO+1.GT.MVESM ) THEN
                    IER        = -4
                    GOTO 9999
                END IF
C
C.. PUT SECONDARY COORDS INTO SEQUENTAIL ORDER SEGMENT VECTOR
                NVESO          = NVESO + 1
                RNOSE          = RTAIL(JTAIL)
                ZNOSE          = ZTAIL(JTAIL)
                ISEGO(NVESO)   = ITAIL * ( 2*JTAIL - 3 )
                GOTO 200
C
            END IF
C
         END IF
C
C.. CLOSE TAIL SEGMENT LOOP
  100 CONTINUE
C
C.. ERROR : IF NO TAIL SEGMENT IS LOCATED
      IER = INOSE
C
C.. SET TAIL SEGMENT TO BE NEW NOSE SEGMENT AND REPEAT PROCESS
C   BUT ONLY IF ITAIL HAS NOT LOOPED BACK TO THE STARTING POSITION
  200 CONTINUE
C
      IF( IER.EQ.0 .AND. ITAIL.NE.ISTART ) THEN
          INOSE        = ITAIL
          GOTO 10
      END IF
C
C.. IF LSTART = .TRUE. THEN END OF JOURNEY SHOULD BE NON-JSTART VERTEX
C                           OF SEGMENT ISTART AND NOT, AS WOULD BE
C                           NORMAL, JSTART.
      IF( LSTART ) NVESO = NVESO - 1
C
C---------------------------- FINAL CHECKS -----------------------------
C
CX    IF( NVESO.NE.NVESM+1 ) IER = -5
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SEGORD( MVESM
     I                 , NVESM , RVESM  , ZVESM , IVESM
     I                 , NSEGO , ISEGO
     I                 , MWORK , IWORK  , WORK
     O                 , IER )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : VESSEL SEGMENT PAIR ORDERING
C                  ---          ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO ORDER SEGMENT PAIRS IN THE SAME FASHION AS THE
C           SEQUENTIAL ORDERED SEGMENTS.
C
C INPUT   :  (I*4)   MVESM     = MAXIMUM NUMBER OF VESSEL SEGMENT PAIRS
C            (I*4)   NSEGO     = SIZE OF ISEGO() (.GE.MVESM)
C            (I*4)   ISEGO()   > 0 --- SEGMENT PAIR INDEX WHICH MATCHES
C                                      SEQUENTIAL ORDERED SEGMENT
C                                      (DO NOT REVERSE PAIRS)
C                              = 0 --- NOT APPLICABLE
C                              < 0 --- SEGMENT PAIR INDEX WHICH MATCHES
C                                      SEQUENTIAL ORDERED SEGMENT
C                                      (REVERSE PAIRS)
C            (I*4)   MWORK     = WORK ARRAY SIZE (.GE.4*NVESM)
C            (I*4)   WORK()    = REAL WORK ARRAY
C            (R*4)   IWORK()   = INTEGER WORK ARRAY
C
C I/O     :  (I*4)   NVESM     = NO. OF VESSEL SEGMENT PAIRS
C            (R*4)   RVESM(,1) = R-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = R-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C            (R*4)   ZVESM(,1) = Z-COORD OF VESSEL SEGMENT 1ST PAIR PNT.
C                         (,2) = Z-COORD OF VESSEL SEGMENT 2ND PAIR PNT.
C            (I*4)   IVESM(,1) = WALL/ALBEDO POLYGON FORMING SEGMENT
C                         (,2) = VOID/PLASMA POLYGON FORMING SEGMENT
C                         (,3) = LINE DRAWING TYPE FOR SEGMENT
C                                (0=FULL 1=DOTTED 2=DASHED 3=LT.FULL)
C
C OUTPUT  :  (I*4)   IER       = 0 --- ROUTINE SUCCESSFUL
C                              =-1 --- ERROR
C
C PROGRAM :  (I*4)   I         = GENERAL INTEGER
C            (I*4)   IBASE     = BASE    INTEGER
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 05/12/93 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MVESM            , MSEGO          , MWORK
     >        ,  NVESM            , NSEGO
      INTEGER*4  ISEGO(NSEGO)
     >        ,  IWORK(MWORK)
      REAL*4     WORK(MWORK)
C
C..I/O
      REAL*4     RVESM(MVESM,2)   , ZVESM(MVESM,2)
      INTEGER*4  IVESM(MVESM,3)
C
C..OUTPUT
      INTEGER*4  IER
C
C..PROGRAM
      INTEGER*4  I                , IBASE
C
C---------------------------- INITIALIZE -------------------------------
C
      IER                   = 0
C
C------------------------------ CHECKS ---------------------------------
C
      IF( MWORK.LT.4*NVESM ) THEN
          IER = -1
          GOTO 9999
      END IF
C
C----------------- STORE ORIGINAL RVESM , ZVESM & IVESM ----------------
C
      IBASE                 = NVESM
C
      DO 100 I              = 1 , NVESM
C
         WORK(I+0*IBASE)    = RVESM(I,1)
         WORK(I+1*IBASE)    = ZVESM(I,1)
         WORK(I+2*IBASE)    = RVESM(I,2)
         WORK(I+3*IBASE)    = ZVESM(I,2)
         IWORK(I+0*IBASE)   = IVESM(I,1)
         IWORK(I+1*IBASE)   = IVESM(I,2)
C
         RVESM(I,1)         = 0.00D+00
         ZVESM(I,1)         = 0.00D+00
         RVESM(I,2)         = 0.00D+00
         ZVESM(I,2)         = 0.00D+00
         IVESM(I,1)         = 0
         IVESM(I,2)         = 0
C
  100 CONTINUE
C
C------------------- ORDER ORIGINAL RVESM AND ZVESM --------------------
C
      NVESM                 = 0
C
      DO 200 I              = 1 , NSEGO
         IF( ISEGO(I).NE.0 ) THEN
C
             NVESM          = NVESM + 1
C
             IVESM(NVESM,1) = IWORK(IABS(ISEGO(I))+0*IBASE)
             IVESM(NVESM,2) = IWORK(IABS(ISEGO(I))+1*IBASE)
C
C..STORE PAIRS
             IF( ISEGO(I).GT.0 ) THEN
                 RVESM(NVESM,1) = WORK(IABS(ISEGO(I))+0*IBASE)
                 ZVESM(NVESM,1) = WORK(IABS(ISEGO(I))+1*IBASE)
                 RVESM(NVESM,2) = WORK(IABS(ISEGO(I))+2*IBASE)
                 ZVESM(NVESM,2) = WORK(IABS(ISEGO(I))+3*IBASE)
C
C..STORE 'REVERSED' PAIRS
             ELSE
                 RVESM(NVESM,2) = WORK(IABS(ISEGO(I))+0*IBASE)
                 ZVESM(NVESM,2) = WORK(IABS(ISEGO(I))+1*IBASE)
                 RVESM(NVESM,1) = WORK(IABS(ISEGO(I))+2*IBASE)
                 ZVESM(NVESM,1) = WORK(IABS(ISEGO(I))+3*IBASE)
C
             END IF
C
         END IF
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MOVREC( IOUT
     I                 , NSTRUC , RSTRUC , ZSTRUC , OFFSET
     I                 , RMIN   , ZMIN   , RLEN   , ZLEN
     O                 , IRES   )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MOVE NIMBUS RECTANGLE
C           ---         ---
C VERSION : V1.R1.M0
C
C PURPOSE : THE NIMBUS RECTANGLE WILL BE MOVED TO CONTAIN ALL VESSEL
C           STRUCTURE.
C
C INPUT   :  (I*4)   IOUT      > 0 --- CHANNEL STREAM FOR MESSAGES
C                              <=0 --- NO MESSAGES
C            (I*4)   NSTRUC    = NUMBER OF VESSEL STRUCTURE POINTS
C            (R*8)   RSTRUC()  = R-COORDS OF VESSEL STRUCTURE POINTS
C            (R*8)   ZSTRUC()  = Z-COORDS OF VESSEL STRUCTURE POINTS
C            (R*8)   OFFSET    = OFFSET FOR RECTANGULAR EXPANSION
C
C I/O     :  (R*8)   RMIN      = R-COORD  OF MINIMUM POINT OF NIMBUS
C                                RECTANGLE
C            (R*8)   ZMIN      = Z-COORD  OF MINIMUM POINT OF NIMBUS
C                                RECTANGLE
C            (R*8)   RLEN      = R-LENGTH OF NIMBUS RECTANGLE
C            (R*8)   ZLEN      = Z-LENGTH OF NIMBUS RECTANGLE
C
C OUTPUT  :  (LOG)   IRES      = 0000 --- NO   CHANGE
C                              = 0001 --- RMIN CHANGED
C                              = 0010 --- RLEN CHANGED
C                              = 0100 --- ZMIN CHANGED
C                              = 1000 --- ZLEN CHANGED
C                              = XXXX --- COMBINATIONS OF THE ABOVE
C
C PROGRAM :  (R*8)   RMAX      = RMIN + RLEN (ORIGINAL RECTANGLE)
C            (R*8)   ZMAX      = ZMIN + ZLEN (ORIGINAL RECTANGLE)
C            (R*8)   RORI(1)   = RMIN (ORIGINAL RECTANGLE)
C                        (2)   = RMAX (ORIGINAL RECTANGLE)
C                        (3)   = RLEN (ORIGINAL RECTANGLE)
C            (R*8)   ZORI(1)   = ZMIN (ORIGINAL RECTANGLE)
C                        (2)   = ZMAX (ORIGINAL RECTANGLE)
C                        (3)   = ZLEN (ORIGINAL RECTANGLE)
C            (R*8)   RACT(1)   = RMIN (STRUCTURAL RECTANGLE)
C                        (2)   = RMAX (STRUCTURAL RECTANGLE)
C            (R*8)   ZACT(1)   = ZMIN (STRUCTURAL RECTANGLE)
C                        (2)   = ZMAX (STRUCTURAL RECTANGLE)
C            (R*8)   OFFSET    = RECTANGLE OFFSET FACTOR
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 14/02/95 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  IOUT
     &        ,  NSTRUC
      REAL*8     RSTRUC(NSTRUC) , ZSTRUC(NSTRUC) , OFFSET
      LOGICAL    LMESS
C
C..I/O
      REAL*8     RMIN           , ZMIN
     &        ,  RLEN           , ZLEN
C
C..OUTPUT
      INTEGER*4  IRES
C
C..PROGRAM
      REAL*8     RORI(3)       , ZORI(3)
     &        ,  RACT(2)       , ZACT(2)
     &        ,  SMIN          , SMAX
C
C---------------------------- INITIALIZE -------------------------------
C
      IRES    = 0000
C
C-------------------- MAXIMUM OF ORIGINAL RECTANGLE --------------------
C
      RORI(1) = RMIN
      RORI(2) = RMIN + RLEN
      RORI(3) = RLEN
C
      ZORI(1) = ZMIN
      ZORI(2) = ZMIN + ZLEN
      ZORI(3) = ZLEN
C
C------------- CALCULATE PROPOSED RECTANGLE (R,Z - MIN , MAX) ----------
C
      RACT(1) = SMIN( RSTRUC(1) , NSTRUC )
      RACT(2) = SMAX( RSTRUC(1) , NSTRUC )
C
      ZACT(1) = SMIN( ZSTRUC(1) , NSTRUC )
      ZACT(2) = SMAX( ZSTRUC(1) , NSTRUC )
C
C-------------------------- USE MAXIMUM RECTANGLE ----------------------
C
      IF( RACT(1).LT.RORI(1) ) THEN
          RMIN = RACT(1) - OFFSET*RORI(3)
          RLEN = RACT(2) - RMIN
          IRES = IRES + 0001
      END IF
C
      IF( RACT(2).GT.RORI(2) ) THEN
          RLEN = ( RACT(2) + OFFSET*RORI(3) ) - RMIN
          IRES = IRES + 0010
      END IF
C
      IF( ZACT(1).LT.ZORI(1) ) THEN
          ZMIN = ZACT(1) - OFFSET*ZORI(3)
          ZLEN = ZACT(2) - ZMIN
          IRES = IRES + 0100
      END IF
C
      IF( ZACT(2).GT.ZORI(2) ) THEN
          ZLEN = ( ZACT(2) + OFFSET*ZORI(3) ) - ZMIN
          IRES = IRES + 1000
      END IF
C
C------------------------- DISPLAY CHANGES (IF ANY) --------------------
C
      IF( IRES.GT.0 .AND. IOUT.GT.0 ) THEN
C.. (HEADER)
          WRITE(IOUT,*) ' '
          WRITE(IOUT,1000)
          WRITE(IOUT,1010)
C.. (R-VALUES)
          IF( RMIN.NE.RORI(1) ) WRITE(IOUT,1020) 'RMIN' , RORI(1) , RMIN
          IF( RMIN+RLEN.NE.RORI(2) )
     &        WRITE(IOUT,1020) 'RMAX' , RORI(2) , RMIN+RLEN
          IF( RLEN.NE.RORI(3) ) WRITE(IOUT,1020) 'RLEN' , RORI(3) , RLEN
C.. (Z-VALUES)
          IF( ZMIN.NE.ZORI(1) ) WRITE(IOUT,1020) 'ZMIN' , ZORI(1) , ZMIN
          IF( ZMIN+ZLEN.NE.ZORI(2) )
     &        WRITE(IOUT,1020) 'ZMAX' , ZORI(2) , ZMIN+ZLEN
          IF( ZLEN.NE.ZORI(3) ) WRITE(IOUT,1020) 'ZLEN' , ZORI(3) , ZLEN
C.. (FOOTER)
          WRITE(IOUT,1000)
          WRITE(IOUT,*)' '
      END IF
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( '************************************************' )
 1010 FORMAT( '  WARNING(LINKPG) : GEOMETRY RECTANGLE CHANGED'
     &      / '                    TO ENCLOSE ALL STRUCTURE:-'   )
 1020 FORMAT( 13X , A , ' :' , 1PE12.4 , ' ->' , E12.4 )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE RDPUMP( INPUMP , FPUMP  , LPUMP , MLK
     O                 , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : READ PUMP DATA
C           -  - ----
C VERSION : V1.R11.M0
C
C PURPOSE : READ PUMP STRUCTURE FROM A DYNAMICALLY OPENED DATASET THEN
C           TO IDENTIFY EXCEPTIONAL VERTICES (I.E THOES WHICH WILL BY
C           USED FOR GUIDENCE ONLY BUT WILL NOT ACTUALLY BE USED)
C
C INPUT   : (I*4) INPUMP       = INPUT CHANNEL TO READ PUMP FILE
C           (C60) FPUMP        = FULLY QUALIFIED PUMP FILE (NO QUOTES)
C           (LOG) LPUMP        = .T. --- SWITCH ON  PUMP IN PUMP
C                                        STRUCTURE
C                              = .F. --- SWITCH OFF PUMP IN PUMP
C                                        STRUCTURE
C           (I*4) MLK          = MAX. NO. OF LEAK REGIONS ALLOWED
C
C OUTPUT  : (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- MPUMP > 100
C                              = 2 --- ILLEGAL CHANNEL # INPUMP
C                              = 3 --- 'FPUMP' DOES NOT EXIST
C                              = 4 --- NO. OF PUMP POLYGONS EXCEEDS MAX
C                              = 5 --- NO. OF PUMP VERTICES EXCEEDS MAX
C                              = 6 --- SPECIAL VALUE BRACKET PROBLEM
C                              = 7 --- PUMP RECTANGLE HAS NOT BEEN READ
C                              = 8 --- TWO PUMP POLYGON LABEL ARE SAME
C                              = 9 --- PUMP LABEL NOT SPECIFIED
C                              =10 --- NRPUMP > MPUMP
C                              =11 --- NRPUMP,LRPUMP HAS NOT BEEN READ
C                              =12 --- FPUMP EOF READING RVPUMP,ZVPUMP
C                              =13 --- FPUMP EOF READING LRPUMP()
C                              =14 --- ACTUAL PUMP HAS NOT BEEN
C                                      SPECIFIED WITH 'P'
C                              =15 --- NO. OF PSB'S EXCEEDS MAX
C                              =16 --- PSB LABEL NOT SPECIFIED
C                              =17 --- NO. OF PSB DATA PNTS. EXCEEDS MAX
C                              =18 --- FPUMP EOF READING IDPSB()
C                              =19 --- LAPSB() DOES NOT MATCH A LAPUMP()
C                              =20 --- PSB "ONE-TO-ONE" LINKAGE BROKEN
C                              =21 --- NO. OF DWB'S EXCEEDS MAX
C                              =22 --- DWB LABEL NOT SPECIFIED
C                              =23 --- NO. OF DWB DATA PNTS. EXCEEDS MAX
C                              =24 --- FPUMP EOF READING IVDWB()
C                              =25 --- LADWB() DOES NOT MATCH A LAPUMP()
C                              =26 --- NLRS > MLRS
C                              =27 --- LRS() IS REPEATED BY ANOTHER LRS
C                              =28 --- NO PUMP LEAK REGION FOUND FOR LRS
C                              =29 --- INVALID PUMP LEAK REGION FOR LRS
C                              =30 --- LSR COORD MISMATCH
C                              =31 --- UNDEFINED COORDS FOR ALL LALRS()
C                              =32 --- NWGAP > MWGAP
C                              =33 --- WALL GAP COORDS NOT FOUND
C                              =34 --- MLK > MBUFF
C                              =35 --- NLK > MLK
C                              =35 --- EOF READING LEAK ALBEDO VALUES
C
C /CPUMP/ : (SEE 'cpump')
C
C PROGRAM : (I*4) MBUFF        = MAX. ARRAY SIZE OF BUFFER()
C           (I*4) IBUFF()      = GENERAL INTEGER ARRAY
C           (R*8) X()          = GENERAL REAL*8  ARRAY
C           (C*11)BUFFER()     = GENERAL STRINGS
C           (C*80)STRING       = GENERAL STRING
C
C           (I*4) I            = BUFFER() INDEX
C           (I*4) J            = CHARACTER POSITION
C           (I*4) IVERT        = VERTEX INDEX
C           (I*4) JOPEN  + 1   = START POSITION FOR TRANSLATION OF
C                                BUFFER() INTO VERTEX COORDINATE
C           (I*4) JCLOSE + 1   = STOP  POSITION FOR TRANSLATION OF
C                                BUFFER() INTO VERTEX COORDINATE
C           (R*4) XREAD        = GENERAL REAL
C           (LOG) LTRAN        = GENERAL LOGICAL
C           (LOG) LPREC        = .T. --- PUMP RECTANGLE HAS BEEN READ
C           (I*4) NLK          = NO. OF LEAK ALBEDO VALUES READ
C
C ROUTINE : CHTLTU             = CONVERT LOWER CASE CHARACTERS TO UPPER
C
C NOTE    : 1) DO NOT CHANGE DATA FORMAT WITHOUT CONSIDERING LENGTH OF
C              BUFFER().
C           2) SPECIAL VALUES (I.E ITPUMP(,,)=1) ARE SIGNALED IN THE
C              PUMP FILE BY BEING ENCLOSED IN MATCHING ROUND BRACKETS
C              (I.E '(' & ')').
C           3) DATA IN FPUMP MUST BE IN CGS UNITS.
C           4) PUMP SEGMENT BLOCKS MUST MAP ONTO A PUMP STRUCTURE
C              POLYGON
C           5) TO FORM A SEGMENT FROM ONE PSB TO ANOTHER (I.E FROM
C              ONE PUMP STRUCTURE POLYGON TO ANOTHER) SET A PSB
C              WITH JUST ONE DATA POINT THEN THE NEXT PSB WITH
C              AGAIN JUST ONE DATA POINT.  A SEGMENT WILL BE CREATED
C              BETWEEN THESE POINTS.  NOTE THAT THE "ONE-TO-ONE" PSB'S
C              MUST BE READ WITHOUT ANY INTERVENING NORMAL PSB.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 01/03/95 --- CREATION
C           V1.R2.M0 --- 13/03/95 --- ISPTYP
C           V1.R3.M0 --- 16/03/95 --- PUMP SEGMENT BLOCKS
C           V1.R4.M0 --- 27/03/95 --- NVPUMP() < 0 OPTION
C           V1.R5.M0 --- 04/04/95 --- REMOVE NVPUMP() < 0 OPTION
C                                 --- SETUP DIVERTOR WALL BLOCKS
C           V1.R6.M0 --- 27/04/95 --- LPMPON INTO ARGUEMENT LIST
C           V1.R6.M1 --- 02/05/95 --- RENAME LPMPON TO LPUMP
C           V1.R6.M2 --- 18/10/95 --- AUTOMATIC CALCULATION OF NRPUMP
C           V1.R7.M0 --- 30/10/95 --- IPTPSB()
C           V1.R8.M0 --- 06/02/96 --- LEAK RECYCLING SEGMENTS (LRS)
C                                 --- WALL GAP SEGMENTS
C                                 --- DEFAULTS FOR PSEMPO, ETC IN FILE
C           V1.R10.M0 -- 12/03/96 --- CIR & REC PUMP STRUCTURES
C           V1.R11.M0 -- 21/06/97 --- 'IGOPT' OPTION INTO PUMP FILE
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  INPUMP , MLK
      LOGICAL    LPUMP
      CHARACTER  FPUMP*60
C
C..OUTPUT
      INTEGER*4  IER
      CHARACTER  MESS*(*)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..WSPACE
C
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4  MBUFF
      PARAMETER( MBUFF = 100 )
C
      INTEGER*4  I                , J          , IVERT
     &        ,  JOPEN            , JCLOSE     , IBUFF(MBUFF) , NLK
      REAL*4     XREAD
      REAL*8     X(2)
      CHARACTER  CBUFF(MBUFF)*11  , STRING*80
      LOGICAL    LTRAN            , LPREC
C
C----------------------------- INITIALISE ------------------------------
C
      IER     = 0
C
      ISPTYP  = 0
C
      IGOPT   = 0
C
      NPUMP   = 0
      NDWB    = 0
      NPSB    = 0
      NLRS    = 0
      NWGAP   = 0
      NLK     = 0
C
      CALL RESETI( ITPUMP(1,1,1) , MPUMP*MVPUMP*3 , 0 )
      CALL RESETI( IBUFF(1)      , MBUFF          , 0 )
      CALL RESETR( RLRS(1,1)     , MLRS*2         , 0.00D+00 )
      CALL RESETR( ZLRS(1,1)     , MLRS*2         , 0.00D+00 )
      CALL RESETR( RWGAP(1,1)    , MWGAP*2        , 0.00D+00 )
      CALL RESETR( ZWGAP(1,1)    , MWGAP*2        , 0.00D+00 )
      CALL RESETR( PMPDEF(1)     , MDEF           , -1.00D+30 )
      CALL RESETR( RPGAP(1,1)    , MWGAP*2        , 0.00D+00 )
      CALL RESETR( ZPGAP(1,1)    , MWGAP*2        , 0.00D+00 )
C
      LPREC   = .FALSE.
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( MVPUMP.GT.MBUFF/2 ) THEN
          WRITE(MESS,9010) MVPUMP , MBUFF/2
          IER = 1
          GOTO 9999
      END IF
C
      IF( INPUMP.LE.0 ) THEN
          WRITE(MESS,9020) INPUMP
          IER = 2
          GOTO 9999
      END IF
C
C----------------------------- CHECK FILE ------------------------------
C
      INQUIRE( FILE=FPUMP , EXIST=LTRAN )
C
C------------------------------ OPEN FILE ------------------------------
C
      IF( LTRAN ) THEN
          OPEN( UNIT=INPUMP , FILE=FPUMP )
C#QQ      OPEN( UNIT=INPUMP , FILE=FPUMP , ACTION='READ' )
      ELSE
          WRITE(MESS,9030)
          CLOSE (INPUMP)
          IER = 3
          GOTO 9999
      END IF
C
C------------------------------ READ DATA ------------------------------
C
   10 READ(INPUMP,1000,END=100) CBUFF(1) , (CBUFF(I+1),I=1,6)
C
C-----------------------------------------------------------------------
C------------------------------- PUMP POLYGONS  ------------------------
C-----------------------------------------------------------------------
C
      IF( CBUFF(1)(3:5).EQ.'POL' ) THEN
C
C.. PUMP POLYGON NUMBER
          NPUMP         = NPUMP + 1
          IF( NPUMP.GT.MPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9040) NPUMP , CBUFF(1)(7:10) , MPUMP
              IER       = 4
              GOTO 9999
          END IF
C
C.. PUMP LABEL
          LAPUMP(NPUMP) = CBUFF(1)(7:10)
          CALL CHRLTU(LAPUMP(NPUMP),LAPUMP(NPUMP))
          IF( LAPUMP(NPUMP).EQ.'    ' ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9040) NPUMP , LAPUMP(NPUMP)
              IER       = 9
              GOTO 9999
          END IF
C
C.. NUMBER OF VERTICES FOR THIS PUMP POLYGON
          READ(CBUFF(2),*) XREAD
          NVPUMP(NPUMP) = XREAD
          IF( NVPUMP(NPUMP).GT.MVPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9050) NPUMP,LAPUMP(NPUMP)
     &                       , NVPUMP(NPUMP),MVPUMP
              IER       = 5
              GOTO 9999
          END IF
C
C.. READ VERTEX COORDINATES (ODD=R-COORDS ; EVEN=Z-COORDS)
          READ(INPUMP,1010,END=20)
     &        ( CBUFF(I) , I=1,NVPUMP(NPUMP)*2 )
          GOTO 25
C
C.. FILE EOF ON READING
   20     WRITE(MESS,9120) NPUMP , NVPUMP(NPUMP)
          IER = 12
          GOTO 9999
C
C.. PROCESS EACH VERTEX INTO COORDINATES AND WATCH FOR SPECIAL VALUES
   25     DO 120 I         = 1 , NVPUMP(NPUMP)*2
C (IS 'I' ODD (T) OR EVEN (F) ?)
             LTRAN         = I.NE.(I/2)*2
C (CONVERT CBUFF INDEX INTO PUMP VERTEX INDEX)
             IVERT         = (I+1) / 2
C (INITIALISE READING AREA CBUFF)
             JOPEN         = 0
             JCLOSE        = 0
C (ANY SPECIAL VALUES)
             DO 140 J      = 1 , LEN(CBUFF(I))
                IF( CBUFF(I)(J:J).EQ.'(' ) THEN
                    JOPEN  = J
                ELSE IF( CBUFF(I)(J:J).EQ.')' ) THEN
                    JCLOSE = J
                END IF
  140        CONTINUE
C (TAG SPECIAL VALUES)
             IF( JOPEN.EQ.JCLOSE ) THEN
                 JOPEN                   = 0
                 JCLOSE                  = LEN(CBUFF(I)) + 1
             ELSE
                 IF( LTRAN ) THEN
                   ITPUMP(NPUMP,IVERT,1) = 1
                 ELSE
                   ITPUMP(NPUMP,IVERT,1) = ITPUMP(NPUMP,IVERT,1) + 2
                 END IF
             END IF
C (STORE COORDINATES : ODD=R-COORDS ; EVEN=Z-COORDS)
             IF( JCLOSE-JOPEN.GT.1 ) THEN
                 IF( LTRAN ) THEN
                     READ(CBUFF(I)(JOPEN+1:JCLOSE-1),*)
     &                    RPUMP(NPUMP,IVERT)
                 ELSE
                     READ(CBUFF(I)(JOPEN+1:JCLOSE-1),*)
     &                    ZPUMP(NPUMP,IVERT)
                 END IF
             ELSE
                 CLOSE (INPUMP)
                 WRITE(MESS,9060) NPUMP , LAPUMP(NPUMP), CBUFF(I)
                 IER       = 6
                 GOTO 9999
             END IF
C
  120     CONTINUE
C
C-----------------------------------------------------------------------
C------------------------------- CIR STRUCTURE  ------------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'CIR' ) THEN
C
C.. PUMP POLYGON NUMBER
          NPUMP         = NPUMP + 1
          IF( NPUMP.GT.MPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9040) NPUMP , CBUFF(1)(7:10) , MPUMP
              IER       = 4
              GOTO 9999
          END IF
C
C.. PUMP LABEL
          LAPUMP(NPUMP) = CBUFF(1)(7:10)
          CALL CHRLTU(LAPUMP(NPUMP),LAPUMP(NPUMP))
          IF( LAPUMP(NPUMP).EQ.'    ' ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9040) NPUMP , LAPUMP(NPUMP)
              IER       = 9
              GOTO 9999
          END IF
C
C.. COORDINATES
          NVPUMP(NPUMP) = -1
          READ(CBUFF(2),*) RPUMP(NPUMP,1)
          READ(CBUFF(3),*) ZPUMP(NPUMP,1)
          READ(CBUFF(4),*) RPUMP(NPUMP,2)
C
C-----------------------------------------------------------------------
C-------------------------------- PUMP WINDOW --------------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'REC' ) THEN
          IF( CBUFF(1)(6:10).NE.'     ' ) THEN
              READ(CBUFF(1)(6:10),*) XREAD
              ISPTYP = XREAD
          END IF
          READ(CBUFF(2),*) GPUMP(1)
          READ(CBUFF(3),*) GPUMP(2)
          READ(CBUFF(4),*) GPUMP(3)
          READ(CBUFF(5),*) GPUMP(4)
          LPREC = .TRUE.
C
C-----------------------------------------------------------------------
C--------------------------- PUMP SEGMENT REGIONS ----------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'SEG' ) THEN
C
C.. PUMP SEGMENT BLOCK
          NPSB          = NPSB  + 1
          IF( NPSB.GT.2*MPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9150) 'PUMP SEGMENT BLOCK'
     &                       ,  NPSB , CBUFF(1)(7:10) , 2*MPUMP
              IER       = 15
              GOTO 9999
          END IF
C
C.. PUMP SEGMENT BLOCK LABEL
          LAPSB(NPSB) = CBUFF(1)(7:10)
          CALL CHRLTU(LAPSB(NPSB),LAPSB(NPSB))
          IF( LAPSB(NPSB).EQ.'    ' ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9160) 'PUMP SEGMENT BLOCK' , NPSB , LAPSB(NPSB)
              IER       = 16
              GOTO 9999
          END IF
C
C.. NUMBER OF DATA POINTS FOR THIS PUMP SEGMENT BLOCK
          READ(CBUFF(2),*) XREAD
          NDPSB(NPSB) = XREAD
          IF( NDPSB(NPSB).GT.MVPUMP+1 ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9170) 'PUMP SEGMENT BLOCK'
     &                       ,  NPSB,LAPSB(NPSB),NDPSB(NPSB),MVPUMP+1
              IER       = 17
              GOTO 9999
          END IF
C
C.. PLOT TYPE FOR THIS PUMP SEGMENT BLOCK
          IF( CBUFF(3).EQ.'           ' ) THEN
              IPTPSB(NPSB) = 0
          ELSE
              READ(CBUFF(3),*) XREAD
              IPTPSB(NPSB) = XREAD
          END IF
C
C.. READ DATA POINTS
          READ(INPUMP,1010,END=30) ( CBUFF(I) , I=1,NDPSB(NPSB) )
          GOTO 35
C
C.. FILE EOF ON READING
   30     WRITE(MESS,9180) 'PUMP SEGMENT BLOCK' , NPSB , NDPSB
          IER = 18
          GOTO 9999
C
C.. PROCESS EACH VERTEX INTO COORDINATES AND WATCH FOR SPECIAL VALUES
   35     DO 160 I         = 1 , NDPSB(NPSB)
             READ(CBUFF(I),*) XREAD
             IDPSB(NPSB,I) = XREAD
  160     CONTINUE
C
C-----------------------------------------------------------------------
C--------------------------- PUMP REGIONAL SETUPS ----------------------
C--- (TERMINATED BY THE SAME CHARS IN COLS 1->6 OR END IN COLS 3->5) ---
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'REG' ) THEN
          NRPUMP        = 0
C
C.. READ EACH LINE
   40     STRING = '      '
          READ(INPUMP,'(A)',END=44) STRING
C
C.. TEST TERMINATION CONDITION
          IF( STRING(3:5).EQ.'END' ) THEN
              GOTO 46
          ELSE
              J       = 1
              DO 42 I = 2 , 6
                 IF( STRING(I:I).EQ.STRING(I-1:I-1) ) J = J + 1
   42         CONTINUE
              IF( J.EQ.6 ) GOTO 46
          END IF
C
C.. UPDATE NRPUMP AND TEST IF EXCEEDED MRPUMP
          NRPUMP        = NRPUMP + 1
          IF( NRPUMP.GT.MPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9100) NRPUMP , MPUMP
              IER       = 10
              GOTO 9999
          END IF
C
C.. READ INDIVIDUAL REGIONAL SETUPS
          READ(STRING,'(A)',END=44)  LRPUMP(NRPUMP)
          GOTO 40
C
C.. FILE EOF ON READING
   44     WRITE(MESS,9130) NRPUMP
          IER = 13
          GOTO 9999
C
   46     CONTINUE
C
C-----------------------------------------------------------------------
C-------------------------- DIVERTOR WALL BLOCKS -----------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'DIV' ) THEN
C
C.. DIVERTOR WALL BLOCK
          NDWB          = NDWB  + 1
          IF( NDWB.GT.MPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9150) 'DIVERTOR WALL BLOCK'
     &                       ,  NDWB , CBUFF(1)(7:10) , MPUMP
              IER       = 21
              GOTO 9999
          END IF
C
C.. DIVERTOR WALL BLOCK LABEL
          LADWB(NDWB) = CBUFF(1)(7:10)
          CALL CHRLTU(LADWB(NDWB),LADWB(NDWB))
          IF( LADWB(NDWB).EQ.'    ' ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9160) 'DIVERTOR WALL BLOCK'
     &                       ,  NDWB , LADWB(NDWB)
              IER       = 22
              GOTO 9999
          END IF
C
C.. NUMBER OF DATA POINTS FOR THIS DIVERTOR WALL BLOCK
          READ(CBUFF(2),*) XREAD
          NVDWB(NDWB) = XREAD
          IF( NVDWB(NDWB).GT.MVPUMP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9170) 'DIVERTOR WALL BLOCK'
     &                       ,  NDWB,LADWB(NDWB),NVDWB(NDWB),MVPUMP
              IER       = 23
              GOTO 9999
          END IF
C
C.. READ DATA POINTS
          READ(INPUMP,1010,END=50) ( CBUFF(I) , I=1,NVDWB(NDWB) )
          GOTO 55
C
C.. FILE EOF ON READING
   50     WRITE(MESS,9180) 'DIVERTOR WALL BLOCK' , NDWB , NVDWB
          IER = 24
          GOTO 9999
C
C.. PROCESS EACH VERTEX INTO COORDINATES AND WATCH FOR SPECIAL VALUES
   55     DO 170 I         = 1 , NVDWB(NDWB)
             READ(CBUFF(I),*) XREAD
             IVDWB(NDWB,I) = XREAD
  170     CONTINUE
C
C-----------------------------------------------------------------------
C--------------------------- LEAK RECYCLING SEGMENTS -------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'LRS' ) THEN
C
C.. UPDATE NLRS AND TEST IF EXCEEDED MLRS
          NLRS          = NLRS + 1
          IF( NLRS.GT.MLRS ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9210) NLRS , MLRS
              IER       = 26
              GOTO 9999
          END IF
C
C.. READ INDIVIDUAL LEAK RECYCLING SEGMENT PAIRS
          LRS(NLRS)   = CBUFF(1)(01:01)
          LALRS(NLRS) = CBUFF(1)(07:10)
          IF( CBUFF(2).NE.' ' ) READ(CBUFF(2),*) RLRS(NLRS,1)
          IF( CBUFF(3).NE.' ' ) READ(CBUFF(3),*) ZLRS(NLRS,1)
          IF( CBUFF(4).NE.' ' ) READ(CBUFF(4),*) RLRS(NLRS,2)
          IF( CBUFF(5).NE.' ' ) READ(CBUFF(5),*) ZLRS(NLRS,2)
C
C-----------------------------------------------------------------------
C------------------------------ WALL GAP SEGMENTS ----------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'GAP' ) THEN
C
C.. UPDATE NWGAP AND TEST IF EXCEEDED MWGAP
          NWGAP         = NWGAP + 1
          IF( NWGAP.GT.MWGAP ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9270) CBUFF(1)(07:10) , NWGAP , MWGAP
              IER       = 32
              GOTO 9999
          END IF
C
C.. SET INDIVIDUAL LABEL AND TRANSPARANCY VALUES FOR GAP SEGMENT
          LAWGAP(NWGAP) = CBUFF(1)(07:10)
          READ(CBUFF(2),*) PWGAP(NWGAP,1)
          IF( CBUFF(3).NE.' ' ) THEN
              READ(CBUFF(3),*) PWGAP(NWGAP,2)
          ELSE
              PWGAP(NWGAP,2) = PWGAP(NWGAP,1)
          END IF
C
C.. READ GAP SEGMENTS COORDINATES
          READ(INPUMP,1000,END=60) CBUFF(1) , ( CBUFF(I) , I=2,5 )
          IF( CBUFF(1).NE.'          ' ) THEN
              WRITE(MESS,9280) LAWGAP(NWGAP) , NWGAP
              IER = 33
              GOTO 9999
          ELSE
              GOTO 65
          END IF
C
C.. FILE EOF ON READING
   60     WRITE(MESS,9280) LAWGAP(NWGAP) , NWGAP
          IER = 33
          GOTO 9999
C
C.. PROCESS EACH VERTEX INTO COORDINATES AND WATCH FOR SPECIAL VALUES
   65     IF( CBUFF(2).NE.' ' ) READ(CBUFF(2),*) RWGAP(NWGAP,1)
          IF( CBUFF(3).NE.' ' ) READ(CBUFF(3),*) ZWGAP(NWGAP,1)
          IF( CBUFF(4).NE.' ' ) READ(CBUFF(4),*) RWGAP(NWGAP,2)
          IF( CBUFF(5).NE.' ' ) READ(CBUFF(5),*) ZWGAP(NWGAP,2)
C
C-----------------------------------------------------------------------
C------------------------------ DEFAULT PARAMETERS ---------------------
C-----------------------------------------------------------------------
C
C..IGOPT
      ELSE IF( CBUFF(1)(2:6).EQ.'IGOPT' ) THEN
          READ(CBUFF(2),*) XREAD
          IGOPT = XREAD
C..PSEMPO
      ELSE IF( CBUFF(1)(2:7).EQ.'PSEMPO' ) THEN
          READ(CBUFF(2),*) PMPDEF(1)
C
C..PSEMPI
      ELSE IF( CBUFF(1)(2:7).EQ.'PSEMPI' ) THEN
          READ(CBUFF(2),*) PMPDEF(2)
C
C..PSEMPT
      ELSE IF( CBUFF(1)(2:7).EQ.'PSEMPT' ) THEN
          READ(CBUFF(2),*) PMPDEF(3)
C
C..PSEMPX
      ELSE IF( CBUFF(1)(2:7).EQ.'PSEMPX' ) THEN
          READ(CBUFF(2),*) PMPDEF(4)
C
C..ALBPMP
      ELSE IF( CBUFF(1)(2:7).EQ.'ALBPMP' ) THEN
          READ(CBUFF(2),*) PMPDEF(5)
C
C..ALBLK()
      ELSE IF( CBUFF(1)(2:7).EQ.'ALBLK ' ) THEN
C
C.........MAX. NO. OF LEAKS > MAX. ALLOWED IN ROUTINE
          IF( MLK.GT.MBUFF .OR. MLK.GT.MDEF-11) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9290) MLK , MIN0(MBUFF,MDEF-11)
              IER       = 34
              GOTO 9999
          END IF
C
C.........NO. OF LEAKS TO READ > NO. ALLOWED
          READ(CBUFF(2),*) XREAD
          NLK = XREAD
          IF( NLK.GT.MLK ) THEN
              CLOSE (INPUMP)
              WRITE(MESS,9300) NLK , MLK
              IER       = 35
              GOTO 9999
          END IF
C
C.........READ LEAK ALBEDO VALUES
          READ(INPUMP,1010,END=70) ( CBUFF(I) , I=1,NLK )
          GOTO 75
C
C.........FILE EOF ON READING
   70     WRITE(MESS,9310) NLK
          IER = 36
          GOTO 9999
C
C.........STORE VALUES
   75     DO 78 I = 1 , NLK
             READ(CBUFF(I),*) PMPDEF(I+10)
   78     CONTINUE
C
C-----------------------------------------------------------------------
C------------------------------- END OF READING ------------------------
C-----------------------------------------------------------------------
C
      ELSE IF( CBUFF(1)(3:5).EQ.'END' ) THEN
          GOTO 100
      END IF
C
      GOTO 10
C
  100 CLOSE (INPUMP)
C
      IF( .NOT.LPREC ) THEN
          WRITE(MESS,9070)
          IER = 7
          GOTO 9999
      END IF
C
      IF( NRPUMP.LE.0 ) THEN
          WRITE(MESS,9110)
          IER = 11
          GOTO 9999
      END IF
C
C-------------------- CHECK FOR IDENTICAL PUMP LABELS ------------------
C
      DO 200 I      = 1 , NPUMP
         DO 220 J   = 1 , NPUMP
            IF( I.NE.J .AND. LAPUMP(I).EQ.LAPUMP(J) ) THEN
                WRITE(MESS,9080) LAPUMP(I) , I , J
                IER = 8
                GOTO 9999
            END IF
  220    CONTINUE
  200 CONTINUE
C
C-------------------- CHECK FOR SPECIFIC PUMP 'P' LABEL ----------------
C
      J           = 0
      DO 240 I    = 1 , NRPUMP
         CALL CHRLTU(LRPUMP(I),LRPUMP(I))
         IF( LRPUMP(I)(1:1).EQ.'P' ) THEN
             IF( LPUMP ) THEN
                 J = J + 1
             ELSE
                 LRPUMP(I)(1:1) = 'O'
             END IF
         END IF
  240 CONTINUE
C
      IF( LPUMP .AND. J.LE.0 ) THEN
          WRITE(MESS,9140)
          IER = 14
          GOTO 9999
      END IF
C
C------------------ CHECK LAPSB() MATCHES ANY LAPUMP() -----------------
C
      JOPEN       = 0
C
      DO 270 I    = 1 , NPSB
         IVERT    = 0
C
         DO 260 J = 1 , NPUMP
            IF( LAPSB(I).EQ.LAPUMP(J) ) IVERT = J
  260    CONTINUE
C
         IF( IVERT.LE.0 ) THEN
             WRITE(MESS,9190) 'PUMP SEGEMNT BLOCK' , I , LAPSB(I)
             IER = 19
             GOTO 9999
         ELSE
C.. (REPLACE LAPSB() BY ACTUAL PUMP NO. VALUE)
             WRITE(LAPSB(I),'(I4)') IVERT
         END IF
C
C.. (CHECK ANY ONE TO ONE LINKAGE BETWEEN PSB'S)
         IF( NDPSB(I).EQ.1 ) THEN
             IF( JOPEN.EQ.0 ) THEN
                 JOPEN = I
                 IF( I.EQ.NPSB ) THEN
                     WRITE(MESS,9200) 'PUMP SEGMENT BLOCK' , JOPEN , I-1
                     IER = 20
                     GOTO 9999
                 END IF
             ELSE
                 JOPEN = 0
             END IF
         ELSE IF( JOPEN.GT.0 ) THEN
             WRITE(MESS,9200) 'PUMP SEGMENT BLOCK' , JOPEN , I
             IER = 20
             GOTO 9999
         END IF
C
  270 CONTINUE
C
C------------------ CHECK LADWB() MATCHES ANY LAPUMP() -----------------
C
      DO 290 I    = 1 , NDWB
         IVERT    = 0
C
         DO 280 J = 1 , NPUMP
            IF( LADWB(I).EQ.LAPUMP(J) ) IVERT = J
  280    CONTINUE
C
         IF( IVERT.LE.0 ) THEN
             WRITE(MESS,9190) 'DIVERTOR WALL BLOCK' , I , LADWB(I)
             IER = 25
             GOTO 9999
         ELSE
C.. (REPLACE LADWB() BY ACTUAL PUMP NO. VALUE)
             WRITE(LADWB(I),'(I4)') IVERT
         END IF
C
  290 CONTINUE
C
C--------------------- LEAK RECYCLING SEGMENT CHECKS  ------------------
C
      DO 300 I = 1 , NLRS
C
C........IS LRS(I) REPEATED BY ANOTHER LEAK RECYCLING SEGMENT ?
         DO 310 J = 1 , NLRS
            IF( J.NE.I .AND. LRS(J).EQ.LRS(I) ) THEN
                WRITE(MESS,9220) LRS(I)
                IER = 27
                GOTO 9999
            END IF
  310    CONTINUE
C
C........DOES PUMP LEAK REGION ACTUALLY EXIST ?
         IF( LRS(I).GE.'1' .AND. LRS(I).LE.'9' ) THEN
             DO 320 J = 1 , NRPUMP
                IF( LRPUMP(J)(1:1).EQ.LRS(I) ) GOTO 325
  320        CONTINUE
             WRITE(MESS,9230) LRS(I) , I , LALRS(I)
             IER = 28
             GOTO 9999
C
C........INVALID PUMP LEAK REGION SPECIFIER (I.E NOT 1,...,9 OR BLANK)
         ELSE IF( LRS(I).NE.' ' ) THEN
             WRITE(MESS,9240) LRS(I) , I , LALRS(I)
             IER = 29
             GOTO 9999
         END IF
C
C........IS LRS # I A POINT AND NOT A SEGMENT ?
  325    IF( RLRS(I,1).EQ.RLRS(I,2) .AND. ZLRS(I,1).EQ.ZLRS(I,2) ) THEN
             LTRAN = .TRUE.
         ELSE
             LTRAN = .FALSE.
         END IF
C
C........HAS LALRS() BEEN USED BY ANOTHER LEAK RECYCLING SEGMENT ?
         DO 330 J = 1 , NLRS
C
            IF( RLRS(J,1).EQ.RLRS(J,2).AND.ZLRS(J,1).EQ.ZLRS(J,2) ) THEN
                LPREC = .TRUE.
            ELSE
                LPREC = .FALSE.
            END IF
C
            IF( J.NE.I .AND. LALRS(J).EQ.LALRS(I) ) THEN
                IF( LTRAN .AND. .NOT.LPREC ) THEN
                    RLRS(I,1) = RLRS(J,1)
                    RLRS(I,2) = RLRS(J,2)
                    ZLRS(I,1) = ZLRS(J,1)
                    ZLRS(I,2) = ZLRS(J,2)
                    LTRAN     = .FALSE.
                ELSE IF( .NOT.LPREC .AND.
     &                  (RLRS(J,1).NE.RLRS(I,1) .OR.
     &                   RLRS(J,2).NE.RLRS(I,2) .OR.
     &                   ZLRS(J,1).NE.ZLRS(I,1) .OR.
     &                   ZLRS(J,2).NE.ZLRS(I,2)     ) ) THEN
                    WRITE(MESS,9250) I , J , LALRS(J)
                    IER = 30
                    GOTO 9999
                END IF
            END IF
  330    CONTINUE
C
         IF( LTRAN ) THEN
             WRITE(MESS,9260) LALRS(I)
             IER = 31
             GOTO 9999
         END IF
C
  300 CONTINUE
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( A10 , 6A11 )
 1010 FORMAT( 10X , 6A11 )
C
 9010 FORMAT( 'MAX. NO. OF PUMP VERTICES ' , I5
     &      , ') > 0.5 * INTERNAL MAX. MBUFF (' , I5 , ')' )
 9020 FORMAT( 'ILLEGAL CHANNEL NUMBER --- INPUMP =' , I5 )
 9030 FORMAT( 'PUMP FILE DOES NOT EXIST --- CHECK FPUMP' )
 9040 FORMAT( 'PUMP POLYGON (#' , I2 , ' = ' , A
     &      , ') > MAX. ALLOWED (' , I5 , ')' )
 9050 FORMAT( 'PUMP POLYGON (#' , I2 , ' = ' , A
     &      , ') --- NO. OF VERTICES (' , I5
     &      , ') > MAX. ALLOWED (' , I2 , ')' )
 9060 FORMAT( 'PUMP POLYGON (#' , I2 , ' = ' , A
     &      , ') --- SPECIAL VALUE PROBLEM FOR '
     &      , A )
 9070 FORMAT( 'PUMP STRUCTURE RECTANGLE HAS NOT BEEN READ FROM FPUMP ' )
 9080 FORMAT( 'PUMP LABELS (' , A , ') ARE THE SAME FOR PUMP '
     &       , I2 , ' & ' , I2 )
 9090 FORMAT( 'PUMP POLYGON (#' , I2
     &      , ') LABEL NOT SPECIFIED (' , A , ')' )
 9100 FORMAT( 'PUMP REGIONAL SETUPS (' , I5
     &      , ') > MAX. ALLOWED (' , I5 , ')' )
 9110 FORMAT( 'PUMP REGIONAL SETUPS HAS NOT BEEN READ FROM FPUMP ' )
 9120 FORMAT( 'PUMP POLYGON (#' , I2
     &      , ') - FILE EOF BEFORE ALL ' , I2 , ' VERTICES READ' )
 9130 FORMAT( 'REGIONAL SETUPS - FILE EOF BEFORE ALL '
     &      , I2 , ' LINES READ' )
 9140 FORMAT( 'REGIONAL SETUPS - ACTUAL PUMP HAS NOT BEEN SPECIFIED '
     &      , 'WITH LABEL ''P'' ' )
 9150 FORMAT( A , ' (#' , I2 , ' = ' , A
     &      , ') > MAX. ALLOWED (' , I5 , ')' )
 9160 FORMAT( A , ' (#' , I2
     &      , ') LABEL NOT SPECIFIED (' , A , ')' )
 9170 FORMAT( A , ' (#' , I2 , ' = ' , A
     &      , ') --- NO. OF DATA POINTS (' , I5
     &      , ') > MAX. ALLOWED (' , I2 , ')' )
 9180 FORMAT( A , ' (#' , I2
     &      , ') - FILE EOF BEFORE ALL ' , I2 , ' DATA POINTS READ' )
 9190 FORMAT( A , ' (#' , I2 , ' = ' , A
     &      , ') LABEL DOES NOT MATCH A PUMP POLYGON LABEL' )
 9200 FORMAT( A , ' (#' , I2
     &      , ') DOES NOT ONE-TO-ONE LINK ONTO ' , I2 )
 9210 FORMAT( 'LEAK RECYCLING SEGMENTS (' , I5
     &      , ') > MAX. ALLOWED (' , I5 , ')' )
 9220 FORMAT( ' PUMP LEAK REGION ID (' , A
     &      , ') IS REPEATED IN THE LRS SPECIFICATIONS' )
 9230 FORMAT( ' CAN NOT FIND PUMP LEAK REGION ID (' , A
     &      , ') FOR LRS #' , I2 , ' LABELLED ' , A )
 9240 FORMAT( ' INVALID PUMP LEAK REGION ID (' , A
     &      , ') FOR LRS #' , I2 , ' LABELLED ' , A )
 9250 FORMAT( ' LSR #' , I2 , ' AND LSR #' , I2
     &      , ' MISMATCHED COORDS. BUT ARE LABELLED ',A )
 9260 FORMAT( ' UNDEFINED COORDINATES FOR ALL LRS LABELLED ' , A )
 9270 FORMAT( ' WALL GAP SEGMENT ' , A , ' (#' , I2
     &      ,     ') HAS EXCEEDED MWGAP (' , I2 , ')' )
 9280 FORMAT( ' WALL GAP SEGMENT ' , A , ' (#' , I2
     &      ,    ') COORDS NOT ON NEXT LINE OR EOF' )
 9290 FORMAT( ' MAX. NO. OF ALBEDO LEAKS (' , I2
     &      ,     ') HAS EXCEEDED MBUFF (' , I2 , ')' )
 9300 FORMAT( ' NO. OF ALBEDO LEAK VALUES (' , I2
     &      ,     ') HAS EXCEEDED MLK (' , I2 , ')' )
 9310 FORMAT( ' FILE EOF BEFORE ALL ' , I2 , ' ALBEDO DATA READ' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE PPUMP( IOUT
     I                , MPOLY  , MVPOLY
     I                , NPOLY  , NVPOLY
     I                , RPOLY  , ZPOLY  , ITAGRM
     O                , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : PROCESS PUMP DATA
C           -       ---
C VERSION : V1.R1.M0
C
C PURPOSE : 1) IDENTIFY EACH WALL NIMBUS POLYGON ENCLOSING PUMP VERTEX
C              AND PLACE RESULT INTO ITPUMP(,,2).
C           2) REPLACE SPECIAL VALUE PUMP COORDS BY APPROPRIATE COORDS
C              ACCORDING TO ITPUMP(,,1).
C
C INPUT   : (I*4) IOUT         = OUTPUT CHANNEL FOR 'GA15' MESSAGES
C           (I*4) MPOLY        = MAX. NO. OF NIMBUS POLYGONS
C           (I*4) MVPOLY       = MAX. NO. OF VERTICES/NIMBUS POLYGON
C
C           (R*8) RPOLY(M,V)   = R OF VERTEX # V IN NIMBUS POLYGON M
C           (R*8) ZPOLY(M,V)   = Z OF VERTEX # V IN NIMBUS POLYGON M
C           (I*4) ITAGRM(M)    =  1 --- NIMB POLY IN MAIN CORE
C                              =  2 --- NIMB POLY IN MAIN SOL
C                              =  3 --- NIMB POLY IN RHS DIV SOL
C                              =  4 --- NIMB POLY IN LHS DIV SOL
C                              =  5 --- NIMB POLY IN RHS DIV PRIV
C                              =  6 --- NIMB POLY IN LHS DIV PRIV
C                              =  7 --- NIMB POLY IN INNER ESCAPE FIGURE
C                              =  8 --- NIMB POLY IN SOL VOID
C                              =  9 --- NIMB POLY IN SOL WALL
C                              = 10 --- NIMB POLY IN RHS DIV WALL
C                              = 11 --- NIMB POLY IN PRIV. DIV WALL
C                              = 12 --- NIMB POLY IN LHS DIV WALL
C                              = 13 --- NIMB POLY IN PRIV. VOID BUFFLE
C                              = 14 --- NIMB POLY IN PRIV. DIV VOID
C                              = 15 --- PUMP VOID.
C                              = 16 --- REST OF PUMP.
C                              = 17 --- NIMB POLY IN OUTER RHS DIV VOID
C                              = 18 --- NIMB POLY IN OUTER LHS DIV VOID
C                              = 19 --- NIMB POLY IN OUTER RHS DIV WALL
C                              = 20 --- NIMB POLY IN OUTER LHS DIV WALL
C                              = 21 --- NIMB POLY IN RHS DIV WALL CORNER
C                              = 22 --- NIMB POLY IN LHS DIV WALL CORNER
C
C OUTPUT  : (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- SEE 'LOCPMP'
C                              > 1 --- SEE 'FIXPMP'
C
C NOTE    : COMMON BLOCK /CPUMP/ IS USED IN LOCPMP & FIXPMP ROUTINES
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 02/03/95 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  IOUT
     &        ,  MPOLY                  , MVPOLY
     &        ,  NPOLY                  , NVPOLY(MPOLY)
     &        ,  ITAGRM(MPOLY)
      REAL*8     RPOLY(MPOLY,MVPOLY)    , ZPOLY(MPOLY,MVPOLY)
C
C..OUTPUT
      INTEGER*4  IER
      CHARACTER  MESS*(*)
C
C-------------------------------- INITIALISE ---------------------------
C
      IER = 0
C
C------------ LOCATE PUMP VERTICES ON NIMBUS WALL POLYGON MAP ----------
C
      CALL LOCPMP( IOUT
     &           , MPOLY      , MVPOLY
     &           , NPOLY      , NVPOLY(1)
     &           , RPOLY(1,1) , ZPOLY(1,1) , ITAGRM(1)
     &           , MESS       , IER    )
      IF( IER.NE.0 ) GOTO 9999
C
C------------------- FIX SPECIAL VALUE PUMP VERTICES -------------------
C
      CALL FIXPMP( MPOLY       , MVPOLY
     &           , NPOLY      , NVPOLY(1)
     &           , RPOLY(1,1) , ZPOLY(1,1)
     &           , MESS       , IER    )
      IF( IER.NE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE LOCPMP( IOUT
     I                 , MPOLY  , MVPOLY
     I                 , NPOLY  , NVPOLY
     I                 , RPOLY  , ZPOLY  , ITAGRM
     O                 , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : LOCATE EACH PUMP VERTEX TO NIMBUS WALL POLYGON MAP
C           ---         - --
C VERSION : V1.R2.M0
C
C PURPOSE : IDENTIFY EACH WALL NIMBUS POLYGON ENCLOSING PUMP VERTEX
C           AND PLACE RESULT INTO ITPUMP(,,2).
C
C INPUT   : (I*4) IOUT         = OUTPUT CHANNEL FOR 'GA15' MESSAGES
C
C           (I*4) MPOLY        = MAX. NO. OF NIMBUS POLYGONS
C           (I*4) MVPOLY       = MAX. NO. OF VERTICES/NIMBUS POLYGON
C           (R*8) RPOLY(M,V)   = R OF VERTEX # V IN NIMBUS POLYGON M
C           (R*8) ZPOLY(M,V)   = Z OF VERTEX # V IN NIMBUS POLYGON M
C           (I*4) ITAGRM(M)    =  1 --- NIMB POLY IN MAIN CORE
C                              =  2 --- NIMB POLY IN MAIN SOL
C                              =  3 --- NIMB POLY IN RHS DIV SOL
C                              =  4 --- NIMB POLY IN LHS DIV SOL
C                              =  5 --- NIMB POLY IN RHS DIV PRIV
C                              =  6 --- NIMB POLY IN LHS DIV PRIV
C                              =  7 --- NIMB POLY IN INNER ESCAPE FIGURE
C                              =  8 --- NIMB POLY IN SOL VOID
C                              =  9 --- NIMB POLY IN SOL WALL
C                              = 10 --- NIMB POLY IN RHS DIV WALL
C                              = 11 --- NIMB POLY IN PRIV. DIV WALL
C                              = 12 --- NIMB POLY IN LHS DIV WALL
C                              = 13 --- NIMB POLY IN PRIV. VOID BUFFLE
C                              = 14 --- NIMB POLY IN PRIV. DIV VOID
C                              = 15 --- PUMP VOID.
C                              = 16 --- REST OF PUMP.
C                              = 17 --- NIMB POLY IN OUTER LHS DIV VOID
C                              = 18 --- NIMB POLY IN OUTER LHS DIV VOID
C                              = 19 --- NIMB POLY IN OUTER RHS DIV WALL
C                              = 20 --- NIMB POLY IN OUTER LHS DIV WALL
C                              = 21 --- NIMB POLY IN RHS DIV WALL CORNER
C                              = 22 --- NIMB POLY IN LHS DIV WALL CORNER
C
C OUTPUT  : (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- MVPOLY > MAXVER
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C PROGRAM :  (I*4) M           = NIMBUS POLYGON
C            (I*4) MV          = NIMBNUS POLYGON VERTEX
C            (I*4) I           = PUMP POLYGON
C            (I*4) J           = PUMP POLYGON VERTEX
C            (I*4) MWORK       = IWORK - MAXVER (MAX. WORKING SPACE)
C
C            (I*4) MAXVER      = MAX. ALLOWED VALUE OF MVPOLY
C
C ROUTINE : (R*8) GA15AD       = SET UP BOUNDARY
C           (R*8) GA15BD       = TEST IF POINT IS IN,ON,OUT OF BOUNDARY
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 02/03/95 --- CREATION
C           V1.R2.M0 --- 27/03/95 --- NVPUMP() < 0 OPTION
C           V1.R3.M0 --- 04/04/95 --- REMOVE NVPUMP() < 0 OPTION
C                                 --- REMOVE LTRAN AND NDWB/IVDWB()
C                                     CALCULATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  IOUT
     &        ,  MPOLY                  , MVPOLY
     &        ,  NPOLY                  , NVPOLY(MPOLY)
     &        ,  ITAGRM(MPOLY)
      REAL*8     RPOLY(MPOLY,MVPOLY)    , ZPOLY(MPOLY,MVPOLY)
C
C..OUTPUT
      INTEGER*4  IER
      CHARACTER  MESS*(*)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4   MAXVER
      PARAMETER(  MAXVER=20)
C
      INTEGER*4   M               , MV          , NWORK
     &        ,   I               , J
      REAL*8      RESULT
C
C-------------------------------- INITIALISE ---------------------------
C
      IER = 0
C
C-------------------------------- CHECK INPUT --------------------------
C
      IF( MVPOLY.GT.MAXVER ) THEN
          WRITE(IOUT,9010) NVPOLY , MAXVER
          IER = 1
          GOTO 9999
      ELSE
          NWORK = IWORK - MAXVER
      END IF
C
C---------------------- ID WALL POLYGON TO PUMP VERTEX -----------------
C
      DO 100 M = 1 , NPOLY
C
C.. CONSIDER ONLY WALL POLYGONS (I.E ITAGRM(M) = 9->12 & 19->22)
         IF( (ITAGRM(M).LT.9  .OR.  ITAGRM(M).GT.22) .OR.
     &       (ITAGRM(M).GT.12 .AND. ITAGRM(M).LT.19)      ) GOTO 100
C
C.. COPY NIMBUS WALL POLYGON VERTICES TO A TEMPORARY ARRAY
         DO 120 MV = 1 , NVPOLY(M)
            XDUM(NWORK+MV) = RPOLY(M,MV)
            YDUM(NWORK+MV) = ZPOLY(M,MV)
  120    CONTINUE
C
C.. FORCE CLOSURE ON TEMPORARY ARRAY
         XDUM(NWORK+NVPOLY(M)+1) = XDUM(NWORK+1)
         YDUM(NWORK+NVPOLY(M)+1) = YDUM(NWORK+1)
C
C.. DECLARE POLYGON BOUNDARY
         CALL GA15AD(
     &                NVPOLY(M)+1   , 1
     &              , WORKSP(1)     , NWORK         , LNDSP(1,1) , LND
     &              , XDUM(NWORK+1) , YDUM(NWORK+1)
     &              , TDUM(1)       , XDUM(1)       , YDUM(1)    , IOUT)
C
C.. TEST EACH PUMP VERTEX FOR ENCLOSE IN/ON POLYGON BOUNDARY
         DO 160 I    = 1 , NPUMP
            DO 140 J = 1 , NVPUMP(I)
               CALL GA15BD(
     &                RPUMP(I,J)    , ZPUMP(I,J)    , RESULT
     &              , NVPOLY(M)+1   , 1
     &              , WORKSP(1)     , NWORK         , LNDSP(1,1) , LND
     &              , XDUM(NWORK+1) , YDUM(NWORK+1)
     &              , TDUM(1)       , XDUM(1)       , YDUM(1)    , IOUT)
              IF( RESULT.GE.0.0D+00 ) ITPUMP(I,J,2) = M
  140       CONTINUE
  160    CONTINUE
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      DO 220 I              = 1 , NPUMP
         DO 200 J           = 1 , NVPUMP(I)
            IF( ITPUMP(I,J,2).LE.0 ) THEN
CW              WRITE(IOUT,'(A,I2,1X,A,A,I2,A,I6)')
CW   &                 ' PUMP =' , I , LAPUMP(I) , ' VERTEX #' , J
CW   &                ,' *** DOES NOT LIE IN/ON NIMB REG ***'
            ELSE
CW              WRITE(IOUT,'(A,I2,1X,A,A,I2,A,I6)')
CW   &                 ' PUMP =' , I , LAPUMP(I) , ' VERTEX #' , J
CW   &                ,' NIMB REG = ' , ITPUMP(I,J,2) + 2
            END IF
 200     CONTINUE
 220  CONTINUE
C
C-----------------------------------------------------------------------
C
 9010 FORMAT( 'MAX. NO. OF NIMBUS VERTICES (' , I2
     &      , ') > INTERNAL MAX. MAXVER (' , I5 , ')' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE FIXPMP( MPOLY  , MVPOLY
     I                 , NPOLY  , NVPOLY
     I                 , RPOLY  , ZPOLY
     O                 , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : FIX EACH PUMP SPECIAL VERTEX TO A NIMBUS WALL POLYGON SIDE
C           ---      - --
C VERSION : V1.R2.M0
C
C PURPOSE : MOVE SPECIAL VERTICES OF THE PUMP (SIGNALLED BY ITPUMP(,,1))
C           UNTIL THEY 1) LIE ON THE SAME SIDE OF THE ENCLOSING NIMBUS
C                         WALL POLYGON OF A VERTEX TO WHICH THEY ARE
C                         RELATIVE (ISPTYP.LE.0)
C                   OR 2) LIE ON THE BOUNDARY OF THEIR ENCLOSING NIMBUS
C                         WALL POLYGON (ISTYP.GT.0)
C
C INPUT   : (I*4) IOUT         = OUTPUT CHANNEL FOR 'GA15' MESSAGES
C
C           (I*4) MPOLY        = MAX. NO. OF NIMBUS POLYGONS
C           (I*4) MVPOLY       = MAX. NO. OF VERTICES/NIMBUS POLYGON
C           (I*4) NPOLY        = NO. OF NIMBUS POLYGONS
C           (I*4) NVPOLY()     = NO. OF VERTICES/NIMBUS POLYGON
C                                (NVPOLY.LE.MAXVER )
C           (R*8) RPOLY(M,V)   = R OF VERTEX # V IN NIMBUS POLYGON M
C           (R*8) ZPOLY(M,V)   = Z OF VERTEX # V IN NIMBUS POLYGON M
C
C OUTPUT  : (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 2 --- SPECIAL VALUE PUMP VERTEX DOES
C                                      NOT LIE IN/ON WALL NIMBUS POLYGON
C                              = 3 --- PROJECTION DOES NOT CROSS
C                                      NIMBUS WALL POLYGON BOUNDARY
C                              = 4 --- MVPOLY > MROOT
C                              = 5 --- MVREL  > MVREL
C                              = 6 --- NOR BORDERING POLYGON FOUND
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C PROGRAM :  (I*4) I           = PUMP POLYGON
C            (I*4) J           = PUMP POLYGON VERTEX
C            (I*4) M           = NIMBUS POLYGON ENCLOSING VERTEX
C            (I*4) MV          = NIMBUS POLYGON VERTEX NO. OR ROOT NO.
C            (I*4) NROOT       = NO. OF ROOTS
C            (I*4) K           = GENERAL INTEGER
C            (R*8) DISMIN      = MIN. DIST. BETWEEN SPECIAL VALUE PROJ.
C                                NIMBUS POLYGON BOUNDARY INTERSECTION
C            (R*8) DIST        = DIST. BETWEEN SPECIAL VALUE PROJECTION
C                                NIMBUS POLYGON BOUNDARY INTERSECTION
C            (I*4) MVREL       = MAX. NO. OF RELATIVE VERTICES
C            (I*4) NVREL       = NO. OF RELATIVE VERTICES
C            (I*4) N           = GENERAL RELATIVE VERTEX
C            (I*4) IV          = NIMBUS WALL POLYGON SIDE A SPECIAL
C                                RELATIVE VERTEX SHOULD BE MOVED TO
C
C ROUTINE :  (R*8) PYTHGS      = STRAIGHT LINE LENGTH CALCULATOR
C
C NOTE    : 1) ALL SPECIAL VALUE PUMP VERTICES MUST BE MAPPED ONTO A
C              NIMBUS WALL POLYGON.
C           2) ISPTYP=0 --- SPECIAL VALUE VERTICES ARE ALL TAKEN TO MEAN
C                           - FORCE THE VERTEX TO HIT THE SAME SIDE OF
C                           THE SAME POLYGON AS THE FIRST VERTEX WHICH
C                           HAS THE SAME SPECIAL R OR Z VALUE.  THIS
C                           PREVENTS THE USER GIVEN THE SAME Z VALUE BUT
C                           THE INCLINATION AND CLOSENESS OF POLYGONS
C                           GIVING A SPECIAL-SPECIAL LINE WHICH CROSSES
C                           POLYGON BOUNDARIES.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 02/03/95 --- CREATION
C           V1.R2.M0 --- 13/03/95 --- ISPTYP DISTINCTION
C           V1.R3.M0 --- 09/05/95 --- FILL ITPUMP(,,3)
C
C- .....................................................................
C
      INCLUDE  'plun'
C
C..INPUT
      INTEGER*4  MPOLY                  , MVPOLY
     &        ,  NPOLY                  , NVPOLY(MPOLY)
      REAL*8     RPOLY(MPOLY,MVPOLY)    , ZPOLY(MPOLY,MVPOLY)
C
C..OUTPUT
      INTEGER*4  IER
      CHARACTER  MESS*(*)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4   MROOT           , MVREL
      PARAMETER(  MROOT = IWORK/2 , MVREL = IWORK/2 )
      INTEGER*4   I               , J           , M           , MV
     &        ,   NROOT           , L1(MROOT)   , L2(MROOT)   , K
     &        ,   N               , NVREL       , IV          , M0
     &        ,   IVREL
      REAL*8      DISMIN          , DIST
C
C..ROUTINES
      REAL*8      PYTHGS
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( MVPOLY+1.GT.MROOT) THEN
          WRITE(MESS,9040) MVPOLY , MROOT
          IER = 4
          GOTO 9999
      END IF
C
C----------------------------- INITIALISE ------------------------------
C
      NVREL = 0
C
      CALL RESETR( TDUM(1) , MVREL , 0.00D+00 )
C
C-----------------------------------------------------------------------
C
      DO 100 I = 1 , NPUMP
C
         DO 200 J = 1 , NVPUMP(I)
C
C.. ONLY PROCESS SPECIAL VALUE PUMP VERTICES
            IF( ITPUMP(I,J,1).LE.0 ) GOTO 200
C
C.. SPECIAL VALUE VERTEX MUST BE MAPPED ONTO A NIMBUS WALL POLYGON
            IF( ITPUMP(I,J,2).LE.0 ) THEN
                WRITE(MESS,9020) LAPUMP(I) , J
                IER = 2
                GOTO 9999
            ELSE
                M = ITPUMP(I,J,2)
            END IF
C
            IF( ITPUMP(I,J,1).EQ.1 ) THEN
C
C.. REPLACE R-COORDINATE
                WRITE(LOUT,*)
     &             ' *** ERROR(FIXPMP) *** REPLACE PUMP R : N/A'
                CALL EXITX(LOUT)
C
            ELSE IF( ITPUMP(I,J,1).EQ.2 ) THEN
C
C.. RELATIVE SPECIAL VERTEX MAPPING ?
                IV               = 0
                IF( ISPTYP.LE.0 ) THEN
                    DO 250 N     = 1 , NVREL
                       IF( ZPUMP(I,J).EQ.TDUM(N) ) THEN
                           M     = LNDSP(2,2*N-1)
                           IV    = LNDSP(2,2*N  )
                           IVREL = N
                           GOTO 10
                       END IF
  250               CONTINUE
                END IF
C
C.. REPLACE Z-COORDINATE
   10           DO 320 MV         = 1 , NVPOLY(M)
                   XDUM(MV)       = RPOLY(M,MV)
                   YDUM(MV)       = ZPOLY(M,MV)
  320           CONTINUE
                XDUM(NVPOLY(M)+1) = XDUM(1)
                YDUM(NVPOLY(M)+1) = YDUM(1)
C
                XDUM(MROOT+1)     = RPUMP(I,J)
                XDUM(MROOT+2)     = RPUMP(I,J)
                YDUM(MROOT+1)     = ZPUMP(I,J)+1.0D+02*ZPUMP(I,J)
                YDUM(MROOT+2)     = ZPUMP(I,J)-1.0D+02*ZPUMP(I,J)
C
                IF( IV.GT.0 ) THEN
                    CALL ROOT(2    ,XDUM(IV)     ,YDUM(IV)
     &                       ,2    ,XDUM(MROOT+1),YDUM(MROOT+1)
     &                       ,1    ,WORKSP(1)    ,WORKSP(MROOT+1)
     &                       ,L1(1),L2(1)        ,NROOT         )
                    IF( NROOT.LE.0 ) THEN
                        IF( IV.LT.NVPOLY(M) ) THEN
                            K = IV + 1
                        ELSE
                            K = 1
                        END IF
                        WRITE(MESS,9035) LAPUMP(I),J,'Z',M+2,IV,K
                        IER = 3
                        GOTO 9999
                    ELSE
                        K             = 1
                        ZPUMP(I,J)    = WORKSP(MROOT+1)
                        ITPUMP(I,J,3) = MZONE(IVREL,1)
                    END IF
                ELSE
                    CALL ROOT(NVPOLY(M)+1,XDUM(1)      ,YDUM(1)
     &                       ,2          ,XDUM(MROOT+1),YDUM(MROOT+1)
     &                       ,MROOT      ,WORKSP(1)    ,WORKSP(MROOT+1)
     &                       ,L1(1)      ,L2(1)        ,NROOT         )
                    IF( NROOT.LE.0 ) THEN
                        IF( ISPTYP.LE.0 ) THEN
                            WRITE(MESS,9030) LAPUMP(I) , J ,'Z-REL',M+2
                        ELSE
                            WRITE(MESS,9030) LAPUMP(I) , J ,'Z' , M+2
                        END IF
                        IER = 3
                        GOTO 9999
                    ELSE
                        DISMIN        = 1.0D+30
                        DO 340 MV     = 1 , NROOT
                           DIST       = PYTHGS(RPUMP(I,J),ZPUMP(I,J)
     &                                 ,WORKSP(MV),WORKSP(MROOT+MV))
                           IF( DIST.LE.DISMIN ) THEN
                               DISMIN = DIST
                               K      = MV
                           END IF
  340                   CONTINUE
C.. (RELATIVE SPECIAL VALUE VERTEX OPTION)
                        IF( ISPTYP.LE.0 ) THEN
                            DO 360 N  = 1 , NVREL
                               IF( ZPUMP(I,J).EQ.TDUM(N) ) THEN
                                   IVREL = N
                                   GOTO 20
                               END IF
  360                       CONTINUE
                            IF( NVREL+1.GT.MVREL ) THEN
                                WRITE(MESS,9050) LAPUMP(I) , J , MVREL
                                IER = 5
                                GOTO 9999
                            ELSE
                                NVREL              = NVREL + 1
                                IVREL              = NVREL
                                TDUM(NVREL)        = ZPUMP(I,J)
                                LNDSP(1,2*NVREL-1) = I
                                LNDSP(1,2*NVREL  ) = J
                                LNDSP(2,2*NVREL-1) = M
                                LNDSP(2,2*NVREL  ) = L1(K)
                                CALL PNEIGH( M      , L1(K)
     &                                     , MPOLY  , MVPOLY
     &                                     , NPOLY  , NVPOLY
     &                                     , RPOLY  , ZPOLY
     &                                     , M0     )
                               IF( M0.EQ.0 ) THEN
                                   WRITE(MESS,9060) LAPUMP(I) , J
                                   IER = 6
                                   GOTO 9999
                               ELSE
                                   MZONE(NVREL,1)   = M0
                               END IF
                            END IF
                        END IF
   20                   CONTINUE
                        ZPUMP(I,J)    = WORKSP(MROOT+K)
                        ITPUMP(I,J,3) = MZONE(IVREL,1)
                    END IF
                END IF
C
            ELSE IF( ITPUMP(I,J,1).EQ.3 ) THEN
C
C.. REPLACE R & Z - COORDINATES
                WRITE(LOUT,*)
     &             ' *** ERROR(FIXPMP) *** REPLACE PUMP R & Z  : N/A'
                CALL EXITX(LOUT)
C
            END IF
C
  200    CONTINUE
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 9020 FORMAT( 'PUMP POLYGON ' , A , ' VERTEX #' , I2
     &      , ' IS SPECIAL'
     &      , ' : NOT ENCLOSED BY A NIMBUS WALL POLYGON')
 9030 FORMAT( 'PUMP POLYGON ' , A , ' VERTEX #' , I2
     &      , ' IS (' , A , ') SPECIAL'
     &      , ' : PROJ. DOES NOT CUT POLYGON ' , I5 )
 9035 FORMAT( 'PUMP POLYGON ' , A , ' VERTEX #' , I2
     &      , ' IS (' , A , '-REL)'
     &      , ' : PROJ DOES NOT CUT POLY' , I5 , ' VTX ' , I2 ,'->', I2)
 9040 FORMAT( 'MAX. NO. OF NIMBUS POLYGON VERTICES (' , I5
     &      , ') + 1 > INTERNAL WORKING ARRAY MROOT (' , I5 , ')' )
 9050 FORMAT( 'PUMP POLYGON ' , A , ' VERTEX #' , I2
     &      , ' EXCEEDS MAX. NO. OF RELATIVE VERTICES (' , I5 , ')' )
 9060 FORMAT( 'NO BORDERING POLYGON FOR ' , A , ' VERTEX # ' , I2 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETBAF( LOUT  , M    , MIBAF , LBUFLE , IALB , EPS
     O                 , NIBAF , IBAF )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET BAFFLES ASSOCIATED WITH POLYGON
C           --- ---
C PURPOSE : TO GET A LIST OF BAFFLES (MAIN & EXTRA) WHICH ARE CONTAINED
C           OR CUT PRIVATE VOID POLYGON #M.
C
C INPUT   : LOUT        = OUTPUT CHANNEL
C           M           = NIMBUS WALL POLYGON
C           MIBAF       = ARRAY SIZE OF IBAF()
C           LBUFLE      = .T. --- SWITCH ON BAFFLE (NEED IALB = 2)
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C           EPS         = TOLENCE LEVEL
C
C OUTPUT  : NIBAF       = NO. OF BAFFLES CONTAINED OR CUT
C           IBAF()      = POLYGON INDEX OF BAFFLE
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/: (SEE 'wspace')
C
C ROUTINES: ROOT              = INTERSCTION OF TWO POLYGONS
C           GA15A             = POINT ENCLOSED BY POLYGON ?
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 25/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , M , MIBAF , IALB
      REAL*8    EPS
      LOGICAL   LBUFLE
C
C..OUTPUT
      INTEGER*4 NIBAF , IBAF(MIBAF)
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../CLINK/
      INCLUDE  'clink'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PARAMETERS
      INTEGER*4  MV12
      PARAMETER( MV12 = MRG + 1 )
C
C..LOCALS
      INTEGER*4 I , IV , NV , NV1 , NV2 , L1 , L2 , NROOT , ITYPG
      REAL*8    RV1(MV12) , ZV1(MV12) , RV2(MV12) , ZV2(MV12)
     &        , RINT      , ZINT      , RESULT
C
C-----------------------------------------------------------------------
C-------------------------- INITIALISATION -----------------------------
C-----------------------------------------------------------------------
C
      NIBAF = 0  ! NO. OF BAFFLE CONTAINED/CUT POLYGON #M
C
      CALL RESETI( IBAF(1) , MV12 , -1 )
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C----------------- ONLY PRIVATE VOID POLYGONS ALLOWED ------------------
C-----------------------------------------------------------------------
C
      IF( MPOLYT(M).NE.6 ) GOTO 9999
C
      IF( .NOT.(LBUFLE .AND. IALB.EQ.2) ) GOTO 9999
C
C-----------------------------------------------------------------------
C-------------- CREATE A CLOSED POLYGON FROM POLYGON #M ----------------
C-----------------------------------------------------------------------
C
      IF( NVERTM(M).GT.0 ) THEN
          NV1        = NVERTM(M)        ! NO. OF VERTICES
          DO IV      = 1 , NV1
             RV1(IV) = RVERTM(M,IV)
             ZV1(IV) = ZVERTM(M,IV)
          ENDDO
      ELSE IF( NVERTM(M).LT.0 ) THEN
          ITYPG      = ABS(NVERTM(M))
          NV1        = NVERTG(ITYPG)    ! NO. OF VERTICES
          DO IV      = 1 , NV1
             RV1(IV) = RVERTG(ITYPG,IV)
             ZV1(IV) = ZVERTG(ITYPG,IV)
          ENDDO
      ELSE
          WRITE(LOUT,9000) M
          CALL EXITX(LOUT)
      ENDIF
C
      NV1            = NV1 + 1
      RV1(NV1)       = RV1(1)
      ZV1(NV1)       = ZV1(1)
C
C-----------------------------------------------------------------------
C---------------------- LOOP OVER ALL BAFFLES --------------------------
C----------------- SET I = 0 TO BE THE MAIN BAFFLE ---------------------
C-----------------------------------------------------------------------
C
      DO I = 0 , NBUFMX
C
C....... CREATE CLOSED POLYGON FROM BAFFLE
         IF( I.EQ.0 ) THEN
             IF( NBUFLE.LE.0 ) GOTO 200
             NV2        = NBUFLE
             DO IV      = 1 , NV2
                RV2(IV) = RBUFLE(IV)
                ZV2(IV) = ZBUFLE(IV)
             ENDDO
         ELSE
             IF( NBUFX(I).LE.0 ) GOTO 200
             NV2        = NBUFX(I)
             DO IV      = 1 , NV2
                RV2(IV) = RBUFX(I,IV)
                ZV2(IV) = ZBUFX(I,IV)
             ENDDO
         ENDIF
C
         NV2            = NV2 + 1
         RV2(NV2)       = RV2(1)
         ZV2(NV2)       = ZV2(1)
C
C....... DOES BAFFLE INTERSECT POLYGON #M (ONLY ONE ROOT NEEDED)
         CALL ROOT( NV1 , RV1(1) , ZV1(1)
     &            , NV2 , RV2(1) , ZV2(1)
     &            , 1   , RINT   , ZINT
     &            , L1  , L2     , NROOT  )
C
C....... IF NO INTERSECTION THEN DOES ENTIRE BAFFLE LIE IN #M ?
         IF( NROOT.EQ.0 ) THEN
C
             CALL GA15AD( NV1       , 1
     &                  , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &                  , RV1(1)    , ZV1(1)
     &                  , TDUM(1)   , XDUM(1) , YDUM(1)    , LOUT )
C
             NV = 0
             DO IV = 1 , NV2 - 1
                CALL GA15BD( RV2(IV)   , ZV2(IV) , RESULT
     &                     , NV1       , 1
     &                     , WORKSP(1) , IWORK   , LNDSP(1,1) , LND
     &                     , RV1(1)    , ZV1(1)
     &                     , TDUM(1)   , XDUM(1) , YDUM(1)    , LOUT )
                IF( RESULT.GE.EPS ) THEN
                    NV = NV + 1   ! BAFFLE VERTEX IS ENCLOSED
                ELSE
                    GOTO 100      ! BAFFLE VERTEX IS NOT ENCLOSED
                ENDIF
  100        ENDDO
C
             IF( NV.EQ.NV2-1 ) NROOT = 1   ! ENTIRE BAFFLE ENCLOSED
C
         ENDIF
C
C....... IS BAFFLE CONTAINED/CUT POLYGON #M ?
         IF( NROOT.GT.0 ) THEN
             NIBAF       = NIBAF + 1
             IBAF(NIBAF) = NPOLYK(2) + I + 1
         ENDIF
C
  200 ENDDO
C
C----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(GETBAF) : POLYGON HAS NO VERTICES !!!!'
     &        / '                     M =' , I7 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETDWB( LOUT  , M     , MIDWB , LPMPST
     O                 , NIDWB , IDWB  , LIDWB )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET DIVERTOR WALL BLOCK
C           --- -        -    -
C PURPOSE : TO DETERMINE IF NIMBUS WALL POLYGON #M INTERSECTS A
C           DIVERTOR WALL BLOCK (D.W.B) AND IF SO RETURN WHICH ONES.
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) M            = NIMBUS WALL POLYGON
C           (I*4) MIDWB        = ARRAY SIZE OF IDWB() & LIDWB()
C           (LOG) LPMPST       = .T. --- PUMP STRUCTURE EXIST
C
C OUTPUT  : (I*4) NIDWB        = NO. OF DWB`S WHICH INTERSECT NPOLY
C           (I*4) IDWB()       = INDIVIDUAL WHICH INTERSECT NPOLY
C           (I*4) LDWB()       = CONVESION OF IDWB() TO NIMBUS
C                                REGIONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C ROUTINES: I4CHRV            = CONVERT CHARACTER TO INTEGER
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 25/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT   , M , MIDWB
      LOGICAL   LPMPST
C
C..OUTPUT
      INTEGER*4 NIDWB  , IDWB(MIDWB) , LIDWB(MIDWB)
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      INTEGER*4 I4CHRV
C
C..LOCALS
      INTEGER*4    I , IER
      CHARACTER*80 MESS
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION  ---------------------------
C-----------------------------------------------------------------------
C
      NIDWB = 0
C
      CALL RESETI( IDWB(1)  , MIDWB , 0 )
      CALL RESETI( LIDWB(1) , MIDWB , 0 )
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C------------- ONLY NON-PLASMA & NON-BULK POLYGONS ALLOWED -------------
C-----------------------------------------------------------------------
C
      IF( MPOLYT(M).EQ.1 .OR. MPOLYT(M).EQ.2 ) GOTO 9999
C
      IF( .NOT.LPMPST ) GOTO 9999
C
C-----------------------------------------------------------------------
C----------------- IS POLYGON A DIVERTOR PUMP WALL ? -------------------
C-----------------------------------------------------------------------
C
      CALL LOCDWB( MPG         , 5           , MIDWB
     &           , M           , NVERTM(1)
     &           , RVERTM(1,1) , ZVERTM(1,1)
     &           , NIDWB       , IDWB(1)
     &           , MESS        , IER         )
C
      IF( IER.NE.0 ) THEN
          WRITE(LOUT,9000) MESS
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C----------------- CONVERT IDWB() TO NIMBUS REGIONS --------------------
C-----------------------------------------------------------------------
C
      IF( NIDWB.GT.0 ) THEN
          DO I        = 1 , NIDWB
             LIDWB(I) = I4CHRV( LADWB( IDWB(I)) ) + NPOLYC(5) - 1
          ENDDO
      ENDIF
C
C----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(GETDWB) : ERROR FROM S.R. LOCDWB !!!!'
     &        / '                     ' , A , ' , IER =' , I7 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE LOCDWB( MPOLY , MVERT , MIDWB
     I                 , NPOLY , NVERT
     I                 , RVERT , ZVERT
     O                 , NIDWB , IDWB
     O                 , MESS  , IER   )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : LOCATE DIVERTOR WALL BLOCK
C           ---    -        -    -
C VERSION : V1.R2.M0
C
C PURPOSE : TO DETERMINE IF NIMBUS WALL POLYGON # NPOLY INTERSECTS A
C           DIVERTOR WALL BLOCK (D.W.B) AND IF SO RETURN WHICH ONES.
C
C INPUT   : (I*4) MPOLY        = MAX. NO. OF NIMBUS POLYGONS ALLOWED
C           (I*4) MVERT        = MAX. NO OF VERTICES/POLYGON
C           (I*4) MIDWB        = ARRAY SIZE OF IDWB()
C
C           (I*4) NPOLY        = NIMBUS WALL POLYGON
C           (I*4) NVERT(M)     = NO. OF VERTICES FOR POLYGON # M
C           (R*8) RVERT(M,V)   = R OF VERTEX # V IN NIMBUS POLYGON # M
C           (R*8) ZVERT(M,V)   = Z OF VERTEX # V IN NIMBUS POLYGON # M
C
C OUTPUT  : (I*4) NIDWB        = NO. OF DWB`S WHICH INTERSECT NPOLY
C           (I*4) IDWB()       = INDIVIDUAL WHICH INTERSECT NPOLY
C           (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- MVPUMP > IWORK
C                              = 2 --- NVERT  > IWORK
C                              = 3 --- NIDWB  > MIDWB
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C PROGRAM : (R*8) EPS          = DISTANCE TOLERENCE
C           (I*4) I            = GENERAL INTEGER
C           (I*4) J            = GENERAL INTEGER
C           (I*4) IPUMP        = PUMP INDEX NUMBER
C           (I*4) NWORK        = IWORK / 2
C           (I*4) NROOT        = NO. OF INTERSECTION POINTS
C           (R*4) DIST         = DISTANCE FROM INTERSECTION TO
C                                DWB VERTEX
C
C ROUTINE :  (I*4) I4CHRV      = CONVERT STRING INTO INTEGER*4
C            (R*8) PYTHGS      = DISTANCE CALCULATOR
C            (   ) ROOT        = CALCULATES INTERSECTION OF TWO POLYGONS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 04/04/95 --- CREATION
C           V1.R2.M0 --- 09/05/95 --- CONSIDERING BORDERING POLYGONS
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MPOLY                  , MVERT
     &        ,  NPOLY                  , NVERT(MPOLY)
      REAL*8     RVERT(MPOLY,MVERT)     , ZVERT(MPOLY,MVERT)
C
C..OUTPUT
      INTEGER*4  MIDWB
     &        ,  NIDWB                  , IDWB(MIDWB)
     &        ,  IER
      CHARACTER  MESS*(*)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      REAL*8      EPS
      PARAMETER(  EPS = 1.00D-06 )
C
      INTEGER*4   I                , J           , K     , II
     &        ,   IPUMP            , NWORK       , NROOT
      REAL*8      DIST
C
C..ROUTINES
      INTEGER*4   I4CHRV
      REAL*8      PYTHGS
C
C----------------------------- INITIALISE ------------------------------
C
      IER                 = 0
      NIDWB               = 0
C
      NWORK               = IWORK / 2
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( MVPUMP.GT.NWORK ) THEN
          WRITE(MESS,9010) MVPUMP , NWORK
          IER = 1
      END IF
C
      IF( NVERT(NPOLY)+1.GT.NWORK ) THEN
          WRITE(MESS,9020) NVERT(NPOLY) , NPOLY+2 , NWORK
          IER = 2
      END IF
C
C-------------------- SETUP POLYGON ARRAY (PERIODIC) -------------------
C
      DO 100 J            = 1 , NVERT(NPOLY)
         XDUM(J)          = RVERT(NPOLY,J)
         YDUM(J)          = ZVERT(NPOLY,J)
  100 CONTINUE
C
      XDUM(NVERT(NPOLY)+1)= XDUM(1)
      YDUM(NVERT(NPOLY)+1)= YDUM(1)
C
C--------------------------- TEST EACH D.W.B ---------------------------
C
      DO 200 I            = 1 , NDWB
C
C.. PUMP INDEX NUMBER
C
         IPUMP            = I4CHRV( LADWB(I) )
C
C.. ASSEMBLE D.W.B INTO DUMMY ARRAY
C
         DO 220 J         = 1 , NVDWB(I)
            WORKSP(J)     = RPUMP(IPUMP,IVDWB(I,J))
            TDUM(J)       = ZPUMP(IPUMP,IVDWB(I,J))
  220    CONTINUE
C
C.. DOES NIMBUS WALL POLYGON INTERSECT D.W.B ?
C
         XDUM(NWORK+1)   = 0.0D+00
         XDUM(NWORK+2)   = 0.0D+00
         YDUM(NWORK+1)   = 0.0D+00
         YDUM(NWORK+2)   = 0.0D+00
C
         CALL ROOT( NVERT(NPOLY)+1 , XDUM(1)       , YDUM(1)
     &            , NVDWB(I)       , WORKSP(1)     , TDUM(1)
     &            , 2              , XDUM(NWORK+1) , YDUM(NWORK+1)
     &            , MZONE(1,1)     , MZONE(1,2)    , NROOT         )
C.. A NIMBUS WALL POLYGON IS CONTAINED IN A D.W.B IF :-
C..        1) NROOT = 2
C..   OR   2) NROOT = 1 & A D.W.B VERTEX LIES IN THE SAME NIMBUS WALL
C..                       POLYGON. THIS VERTEX MUST NOT BE THE SAME AS
C..                       THE INTERSECTION POINT!
C
         IF( NROOT.EQ.1 ) THEN
             DO 240 J             = 1 , NVDWB(I)
                IF( ITPUMP(IPUMP,IVDWB(I,J),2).EQ.NPOLY .OR.
     &              ITPUMP(IPUMP,IVDWB(I,J),3).EQ.NPOLY      ) THEN
                    XDUM(NWORK+2) = RPUMP(IPUMP,IVDWB(I,J))
                    YDUM(NWORK+2) = ZPUMP(IPUMP,IVDWB(I,J))
                    DIST          = PYTHGS(XDUM(NWORK+1),YDUM(NWORK+1)
     &                                    ,XDUM(NWORK+2),YDUM(NWORK+2))
                    IF( DIST.GT.EPS ) THEN
                        NROOT     = NROOT + 1
                        GOTO 10
                    END IF
                END IF
  240        CONTINUE
         END IF
C
C.. STORE POSITIVE ANSWER TO ABOVE QUESTION
C
   10    IF( NROOT.GE.2 ) THEN
             NIDWB            = NIDWB + 1
             IF( NIDWB.GT.MIDWB ) THEN
                 WRITE(MESS,9030)
                 IER          = 3
                 GOTO 9999
             ELSE
                 IDWB(NIDWB)  = I
             END IF
         END IF
C
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
 9010 FORMAT( 'MVPUMP (' , I5 , ') EXCEEDS IWORK (' , I5 , ')' )
 9020 FORMAT( 'NO. OF VERTICES (' , I5 , ') + 1 FOR NIMBUS WALL POL ('
     &      , I5 , ') EXCEEDS NWORK (' , I5 , ')' )
 9030 FORMAT( 'NIDWB (' , I5 , ') EXCEEDS ARRAY SIZE (' , I5 , ')' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SETSEG( ITYPE  , MSEG   , MSIZE
     I                 , COMM   , ITAGRM
     I                 , PLASMA , VOID   , WALL   , ALBEDO , DIVPMP
     I                 , MHZWA  , MHZVO  , IVHZWA
     I                 , MWGAP  , NWGAP
     I                 , IWGAP  , IMWGAP
     I                 , MWREG  , GWREG
     O                 , NSEG   , RSEG   , ZSEG   , ISEG   , GSEG
     O                 , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : SETUP SEGMENTS
C           ---   ---
C PURPOSE : TO DEDUCE SEGMENT PAIRS FOR VESSEL (LSTUDY=T) OR PLASMA
C           BOUNDARY (LSTUDY=F).  THEN TO ORDER ON A NOSE TO TAIL
C           BASIS THE SEGMENTS.
C
C INPUT   : (I*4) ITYPE        = 1 --- DEDUCE VESSEL SEGMENT PAIRS
C                              = 2 --- DEDUCE PLASMA BOUNDARY
C                                      SEGMENT PAIRS
C
C           (I*4) MSEGM        = ARRAY DIMENSION SIZE OF RSEG,ZSEG,ISEG
C           (I*4) MSIZE        = DIMMENSION SIZE OF COMM() & ITAGRM()
C
C           (C*1) COMM(M+2)    = MAPPING SYMBOL FOR NIMBUS POLYGON # M+2
C           (I*4) ITAGRM(M)    = MACRO-ZONE REGION POLYGON # M BELONGS
C                                (SEE LINKPG FOR FULL DESCRIPTION)
C
C           (C*1) PLASMA       = MAPPING SYMBOL FOR 'PLASMA'
C           (C*1) VOID         = MAPPING SYMBOL FOR 'VOID'
C           (C*1) WALL         = MAPPING SYMBOL FOR 'WALL'
C           (C*1) ALBEDO       = MAPPING SYMBOL FOR 'ALBEDO'
C           (C*1) DIVPMP       = MAPPING SYMBOL FOR 'DIVERTOR PUMP'
C
C           HORIZONTAL TARGET ESCAPE FIGURES ONLY :-
C           ----------------------------------------
C           (I*4) MHZWA(1)     = TARGET POLYGON TOUCHING SOL ON RHS
C                      (2)     = TARGET POLYGON TOUCHING SOL ON LHS
C           (I*4) MHZVO(1)     = SOL VOID POLYGON TOUCHING MHZWA(1)
C                      (2)     = SOL VOID POLYGON TOUCHING MHZWA(2)
C           (I*4) IVHZWA(1,)   = VERTICIES OF MHZWA(1) TO BE USED AS
C                                VESSEL SEGMENTS
C                 IVHZWA(2,)   = VERTICIES OF MHZWA(2) TO BE USED AS
C                                VESSEL SEGMENTS
C
C           (I*4) MWGAP        = MAXIMUM NUMBER OF PUMP GAP LINES
C           (I*4) NWGAP        = ACTUAL  NUMBER OF PUMP GAP LINES
C           (I*4) IWGAP(I,J)   = ORIGINAL NIMBUS POLYGON CONTAINING
C                                VERTEX # J OF PUMP GAP LINE # I
C           (I*4) IMWGAP(I,J)  = NEW      NIMBUS POLYGON CONTAINING
C                                VERTEX # J OF PUMP GAP LINE # I
C
C           (I*4) MWREG       = NUMBER OF REGIONS
C           (C*2) GWREG()     = WALL SEGMENT REGION LABELS
C                      (1)    = OUTER TARGET
C                      (2)    = OUTER CORNER
C                      (3)    = OUTER DIVERTOR
C                      (4)    = MAIN SOL
C                      (5)    = INNER DIVERTOR
C                      (6)    = INNER CORNER
C                      (7)    = INNER TARGET
C                      (8)    = PRIVATE VOID
C                      (9)    = COMPOUND BUFFLE
C                      (10)   = NON-COMPOUND BUFFLE
C
C OUTPUT  : (I*4) NSEG         = NO. OF SEGMENT PAIRS
C
C           (R*4) RSEG(I,1)    = R-COORDINATE OF 1ST PAIR OF SEGMENT # I
C                     (I,2)    = R-COORDINATE OF 2ND PAIR OF SEGMENT # I
C                 ZSEG(I,1)    = Z-COORDINATE OF 1ST PAIR OF SEGMENT # I
C                     (I,2)    = Z-COORDINATE OF 2ND PAIR OF SEGMENT # I
C
C           ITYPE = 1 :-
C           ------------
C           (I*4) ISEG(I,1)    = WALL/ALBEDO/DIVPMP
C                                FORMING SEGMENT # I
C                     (I,2)    = PLASMA/VOID FORMING SEGMENT # I
C           (C**) GSEG(I)      = GROUP SEGMENT # I BELONGS TO
C                              = OT --- OUTER TARGET
C                              = OC --- OUTER CORNER
C                              = OD --- OUTER DIVERTOR
C                              = IT --- INNER TARGET
C                              = IC --- INNER CORNER
C                              = ID --- INNER DIVERTOR
C                              = MS --- MAIN SOL
C                              = PV --- PRIVATE VOID
C
C           ITYPE = 2 :-
C           ------------
C           (I*4) ISEG(I,1)    = PLASMA      FORMING SEGMENT # I
C                     (I,2)    = WALL/ALBEDO/DIVPMP/VOID
C                                FORMING SEGMENT # I
C           (C**) GSEG(I)      = GROUP SEGMENT # I BELONGS TO
C                              = OT --- OUTER TARGET
C                              = OD --- OUTER DIVERTOR
C                              = IT --- INNER TARGET
C                              = ID --- INNER DIVERTOR
C
C           (C**) MESS         = ERROR MESSAGE
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- ITYPE NOT RECOGNISED
C                              = 2 --- ERROR IN 'SETORD'
C                              = 3 --- ERROR IN 'VESORD'
C                              = 4 --- ERROR IN 'SEGORD'
C                              = 5 --- NSEG > MSEG
C                              = 6 --- NPAIR(1) > IWORK
C                              = 7 --- MORE THAN ONE GAP POLYGON
C                                      CONTAINED IN A WALL POLYGON
C
C /CPOLYG/: (SEE 'c09')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C ROUTINE : (R*8) PYTHGS       = STRAIGHT LINE LENGTH CALCULATOR
C
C PROGRAM : (I*4) I            = GENERAL INTEGER
C           (I*4) J            = GENERAL INTEGER
C           (I*4) IG           = GAP LINE INDEX
C           (I*4) IV           = GAP VERTEX INDEX
C           (I*4) M            = NIMBUS POLYGON UNDER INVESTIGATION
C           (I*4) M0           = NIMBUS POLYGON COMPARED WITH M
C           (I*4) IERR         = INTERNAL ERROR NUMBER
C           (I*4) MVERT(1)     = NO. OF VERTICES IN POLYGON # M
C                      (2)     = NO. OF VERTICES IN POLYGON # M0
C           (I*4) NPAIR(1)     = SEGMENT PAIR NUMBER FOR POLYGON # M
C                      (2)     = SEGMENT PAIR NUMBER FOR POLYGON # M0
C           (I*4) ISTART       = SEGMENT FROM WHICH TO START ORDERING
C           (I*4) JSTART       = VERTEX OF SEGMENT # ISTART FROM WHICH
C                                TO START ORDERING
C           (I*4) NSEGOD       = NO. OF ORDERED SEQUENTIAL SEGMENTS
C           (R*4) XR4()        = GENERAL REAL*4
C           (R*4) YR4()        = GENERAL REAL*4
C           (R*8) X()          = GENERAL REAL*8
C           (I*4) LTRAN        = GENERAL LOGICAL
C           (I*4) LNORM(1)     = .T. --- POLYGON # M  IS SPECIAL
C                      (2)     = .T. --- POLYGON # M0 IS SPECIAL
C           (C24) CTYPE        = SEGMENT TYPE STRING
C
C ROUTINE : (R*8) PYTHGS       = LENGTH OF A LINE
C           (R*8) XPROD        = CROSS-PRODUCT
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 04/04/95 --- CREATION
C           V1.R2.M0 --- 05/04/95 --- FOR ITYPE = 2 THEN ALLOW
C                                     PRIVATE REGION VOID TO BE JUST ONE
C                                     POLYGON
C           V1.R3.M0 --- 16/06/95 --- MHZWA(), MHZVO() & IVHZWA()
C                                     INTO ARGUEMENT LIST
C           V1.R4.M0 --- 13/02/98 --- SEE (20A) BELOW
C           V1.R5.M0 --- 16/03/98 --- MWGAP, NWGAP, IWGAP(,) & IMWGAP(,)
C                                     FOR GAP POLYGONS IN SETTING WALL
C                                     SEGMENTS, SEE (21)
C           V1.R5.M1 --- 27/03/98 --- EQUIVALENCE BUFFER()
C
C- .....................................................................
C
C..INPUT
      INTEGER*4   ITYPE        , MSEG   , MSIZE
      INTEGER*4   ITAGRM(MSIZE), MHZWA(2) , MHZVO(2) , IVHZWA(2,2)
      INTEGER*4   MWGAP        , NWGAP  , MWREG
      INTEGER*4   IWGAP(MWGAP,2) , IMWGAP(MWGAP,2)
      CHARACTER*1 COMM(MSIZE)  , PLASMA , VOID , WALL , ALBEDO , DIVPMP
      CHARACTER*2 GWREG(MWREG)
C
C..OUTPUT
      INTEGER*4   NSEG           , ISEG(MSEG,2) , IER
      REAL*4      RSEG(MSEG,2)   , ZSEG(MSEG,2)
      CHARACTER   GSEG(MSEG)*(*) , MESS*(*)
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PARAMETERS
      REAL*8     EPS
      PARAMETER( EPS = 1.0D-08 )
C
C..ROUTINES
      REAL*8      PYTHGS       , XPROD
C
C..PROGRAM
      INTEGER*4   I            , J           , IG          , IV
     &        ,   M            , M0          , MGAP
     &        ,   I0           , I1
     &        ,   IV0          , IV1         , IV2
     &        ,   MVERT(2)     , NPAIR(2)
     &        ,   ISTART       , JSTART      , NSEGOD
     &        ,   IERR
      REAL*8      X(5)
      REAL*4      XR4(2)       , YR4(2)
      LOGICAL     LTRAN        , LNORM(2)
      CHARACTER   CTYPE(2)*24
C
C..
      REAL*4      SBUFER(4*MDIM)
      EQUIVALENCE (BUFFER(1),SBUFER(1))
C
C..DATA
      DATA CTYPE/ 'NIMBUS  VESSEL  SEGMENTS'
     &          , 'PLASMA BOUNDARY SEGMENTS' /
C
C----------------------------- INITIALISE ------------------------------
C
      IER          = 0
      NSEG         = 0
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( ITYPE.LT.1 .OR. ITYPE.GT.2 ) THEN
          WRITE(MESS,9010) ITYPE
          IER      = 1
          GOTO 9999
      END IF
C
C-----------------------------------------------------------------------
C
C.(1) LOOP AROUND ALL NIMBUS POLYGONS (EXCL. CORE, PUMP & BUFFLE)
      DO 100 M     = NPOLYK(1)+1 , NPOLYK(2)
C
C.(2) PROCESS REQUIRED POLYGON TYPE (ACCORDING TO ITYPE)
         IF( ITYPE.EQ.1 ) THEN
             LTRAN = COMM(M+2).EQ.WALL   .OR.
     &               COMM(M+2).EQ.ALBEDO .OR.
     &               COMM(M+2).EQ.DIVPMP
         ELSE IF( ITYPE.EQ.2 ) THEN
             LTRAN = COMM(M+2).EQ.WALL   .OR.
     &               COMM(M+2).EQ.ALBEDO .OR.
     &               COMM(M+2).EQ.DIVPMP .OR.
     &               COMM(M+2).EQ.VOID
         END IF
C
         IF( LTRAN ) THEN
C
C.(3) IS FIGURE 'M' AN ORDINARY (NORMAL) POLYGON OR A SPECIAL POLYGON ?
             IF( NVERTM(M).GE.0 ) THEN
                 MVERT(1)  = NVERTM(M)
                 LNORM(1)  = .TRUE.
             ELSE
                 MVERT(1)  = NVERTG(IABS(NVERTM(M)))
                 LNORM(1)  = .FALSE.
             END IF
C
C.(4) PAIR NUMBER FOR FIGURE 'M'
             NPAIR(1)      = 0
C
C.(5) LOOP AROUND ALL FIGURES UPTO, BUT EXCLUDING, CORE, PUMP & BUFFLE
             DO 120 M0     = 1 , NPOLYK(2)
                IF( M0.EQ.NPOLYK(1) ) GOTO 120
C
C.(6) COMPARE POLYGON # M WITH LINKED POLYGON OF REQUIRED TYPE
                IF( ITYPE.EQ.1 ) THEN
                    LTRAN  = COMM(M0+2).EQ.PLASMA .OR.
     &                       COMM(M0+2).EQ.VOID
                ELSE
                    LTRAN  = COMM(M0+2).EQ.PLASMA
                END IF
C
                IF( LTRAN )THEN
C
C.(7) IS FIGURE 'M0' AN ORDINARY (NORMAL) POLYGON OR A SPECIAL POLYGON ?
                    IF( NVERTM(M0).GE.0 ) THEN
                        MVERT(2) = NVERTM(M0)
                        LNORM(2) = .TRUE.
                    ELSE
                        MVERT(2) = NVERTG(IABS(NVERTM(M0)))
                        LNORM(2) = .FALSE.
                    END IF
C
C.(8) PAIR NUMBER FOR FIGURE 'M0'
                    NPAIR(2)     = 0
C
C.(9) LOOP AROUND VERTICES OF FIGURE 'M0'
                    DO 140 J     = 1 , MVERT(2)
C
C(10) GET VERTEX COORDINATES OF FIGURE 'M0'
                       IF( LNORM(2) ) THEN
                           XDUM(2) = RVERTM(M0,J)
                           YDUM(2) = ZVERTM(M0,J)
                       ELSE
                           XDUM(2) = RVERTG(IABS(NVERTM(M0)),J)
                           YDUM(2) = ZVERTG(IABS(NVERTM(M0)),J)
                       END IF
C
C(11) LOOP AROUND VERTICES OF FIGURE 'M'
                       DO 160 I    = 1 , MVERT(1)
C
C(12) GET VERTEX COORDINATES OF FIGURE 'M'
                          IF( LNORM(1) ) THEN
                              XDUM(1) = RVERTM(M,I)
                              YDUM(1) = ZVERTM(M,I)
                          ELSE
                              XDUM(1) = RVERTG(IABS(NVERTM(M)),I)
                              YDUM(1) = ZVERTG(IABS(NVERTM(M)),I)
                          END IF
C
C(13) CHECK FOR INTERFACE COORDINATES
                          IF( XDUM(1).EQ.XDUM(2) .AND.
     &                        YDUM(1).EQ.YDUM(2)       ) THEN
C
C(14) STORE NIMBUS SEGMENT
                              NPAIR(1)              = NPAIR(1) + 1
                              NPAIR(2)              = NPAIR(2) + 1
                              IF( NPAIR(1).GT.IWORK ) THEN
                                  WRITE(MESS,9060) NPAIR(1) , IWORK
                                  IER               = 6
                                  GOTO 9999
                              ELSE
                                  LNDSP(1,NPAIR(1)) = M
                                  LNDSP(2,NPAIR(1)) = M0
                                  WORKSP(NPAIR(1))  = XDUM(1)
                                  TDUM(NPAIR(1))    = YDUM(1)
                                  GOTO 140
                              END IF
C
                          END IF
C
  160                  CONTINUE
  140               CONTINUE
C
C(15) LEAVE LOOP AFTER NIMBUS SEGMENT PAIRS FOUND (ORDINARY)
                    IF( NPAIR(2).EQ.2 ) THEN
                        IF( LNORM(1) ) GOTO 10
                    ELSE
                        NPAIR(1) = MAX0( NPAIR(1)-NPAIR(2) , 0 )
                    END IF
C
                END IF
C
  120        CONTINUE
C
   10        CONTINUE
C
C(21) GAP POLYGONS CONTAINED IN MAIN WALL POLYGON (ITYPE=1 ONLY)
             IF( ITYPE.EQ.1 .AND. NPAIR(1).EQ.2 ) THEN
C.... DOES WALL POLYGON (M) CONTAIN A PUMP GAP POLYGON (M0) ?
C     (NOTE: ONLY ONE GAP POLYGON PER WALL POLYGON ALLOWED)
                 M0       = 0
                 DO IG    = 1 , NWGAP
                    DO IV = 1 , 2
                       IF( M.EQ.IWGAP(IG,IV) ) THEN
                           IF( M0.EQ.0 ) THEN
                               M0 = IMWGAP(IG,IV)
                           ELSE
                               WRITE(MESS,9070) M
                               IER = 7
                               GOTO 9999
                           ENDIF
                       ENDIF
                    ENDDO
                 ENDDO
C.... <BEGIN> ADJUSTMENT FOR GAP PORTION OF SEGMENT
                 IF( M0.GT.0  ) THEN
C.... FIND WHICH VERTEX OF 'M0' MATCHES A SEGMENT VERTEX
                    DO IV = 1 , NVERTM(M0)
                       X(1) = PYTHGS( RVERTM(M0,IV) , ZVERTM(M0,IV)
     &                              , WORKSP(1)     , TDUM(1)       )
                       X(2) = PYTHGS( RVERTM(M0,IV) , ZVERTM(M0,IV)
     &                              , WORKSP(2)     , TDUM(2)       )
                       IF( X(1).LE.EPS ) THEN
                           IV0 = IV
                           I0  = 1
                           I1  = 2
                       ELSE IF( X(2).LE.EPS ) THEN
                           IV0 = IV
                           I0  = 2
                           I1  = 1
                       ENDIF
                    ENDDO
C.... ABORT IF NEXT VERTEX, TO IV0, MATCHES NEXT SEGMENT POINT (I1)
                    IV1 = IV0 + 1
                    IF( IV1.GT.NVERTM(M0) ) IV1 = 1
                    X(1) = PYTHGS( WORKSP(I1)     , TDUM(I1)
     &                           , RVERTM(M0,IV1)  , ZVERTM(M0,IV1)  )
                    IF ( X(1).LE.EPS ) GOTO 20
C.... ABORT IF LAST VERTEX, TO IV0, MATCHES NEXT SEGMENT POINT (I1)
                    IV2 = IV0 - 1
                    IF( IV2.LT.1 ) IV2 = NVERTM(M0)
                    X(2) = PYTHGS( WORKSP(I1)     , TDUM(I1)
     &                           , RVERTM(M0,IV2) , ZVERTM(M0,IV2) )
                    IF ( X(2).LE.EPS ) GOTO 20
C
C.... FIND NEXT VERTEX OF 'M0' WHICH LIES ON THE SEGMENT LINE
C     (CALCULATES DISTANCE OF VERTEX PERPENDICULAR TO SEGMENT LINE)
                    X(3) = XPROD( WORKSP(I0)      , TDUM(I0)
     &                          , WORKSP(I1)      , TDUM(I1)
     &                          , RVERTM(M0,IV1)  , ZVERTM(M0,IV1) )
                    X(4) = XPROD( WORKSP(I0)      , TDUM(I0)
     &                          , WORKSP(I1)      , TDUM(I1)
     &                          , RVERTM(M0,IV2)  , ZVERTM(M0,IV2) )
                    X(3) = ABS( X(3) / X(1) )
                    X(4) = ABS( X(4) / X(2) )
C
                    IF( X(3).LT.X(4) ) THEN
                        IV1  = IV1
                        X(5) = X(3)
                    ELSE
                        IV1  = IV2
                        X(5) = X(4)
                    END IF
C
C.... ABORT IF VERTEX IS GREATER THAN 'EPS' FROM SEGMENT LINE
                    IF( X(5).GT.EPS ) GOTO 20
C
C.... ABORT IF PROPOSED
C
C.......................................................................
C.... TO RECAP : IV0 (BASE GAP VERTEX) .EQ. I0 (BASE WALL VERTEX)
C.... ========   IV1 (NEXT GAP VERTEX) .NE. I1 (NEXT WALL VERTEX)
C.......................................................................
C
C.... ABORT IF GAP PORTION LENGTH .GE. ORIGINAL SEGMENT LENGTH
                    X(1) = PYTHGS( WORKSP(1) , TDUM(1)
     &                           , WORKSP(2) , TDUM(2) )
                    X(2) = PYTHGS( RVERTM(M0,IV0) , ZVERTM(M0,IV0)
     &                           , RVERTM(M0,IV1) , ZVERTM(M0,IV1) )
                    IF( X(2).GE.X(1) ) GOTO 20
C.... SAVE ORIGINAL I1 ('NEXT' SEGMENT VERTEX)
                    X(1)      = WORKSP(I1)
                    X(2)      = TDUM(I1)
C.... ORIGINAL SEGMENT BECOMES A GAP (M0) AND A WALL (M) PORTIONS
C     (IN THAT ORDER, I.E. GAP FIRST THEN WALL)
C     NB. PLASMA NEIGHBOUR = LNDSP(2,1), IS UNCHANGED FROM SECTION (14)
C         AND APPLIES TO BOTH GAP AND WALL PORTIONS.
                    NPAIR(1)   = 4
                    LNDSP(1,1) = M0
                    LNDSP(1,3) = M
C (NOT NEEDED)      LNDSP(2,1) = LNDSP(2,1)
                    LNDSP(2,3) = LNDSP(2,1)
                    WORKSP(1)  = RVERTM(M0,IV0)
                    WORKSP(2)  = RVERTM(M0,IV1)
                    WORKSP(3)  = WORKSP(2)
                    WORKSP(4)  = X(1)
                    TDUM(1)    = ZVERTM(M0,IV0)
                    TDUM(2)    = ZVERTM(M0,IV1)
                    TDUM(3)    = TDUM(2)
                    TDUM(4)    = X(2)
C.... <END> ADJUSTMENT FOR GAP PORTION OF SEGMENT
                 ENDIF
C.... <END> GAP POLYGONS CONTAINED IN MAIN WALL POLYGON (ITYPE=1 ONLY)
             ENDIF
C
   20        CONTINUE
C
C(16) ASSEMBLE NIMBUS SEGMENT PAIRS
             DO I    = 1 , NPAIR(1) , 2
C.... TRAP DIMENSION OVERFLOW OF SEGMENT NUMBER
                IF( NSEG.GE.MSEG ) THEN
                    WRITE(MESS,9020) CTYPE(ITYPE) , NSEG+1 , MSEG
                    IER          = 2
                    GOTO 9999
                 END IF
C.... FILL SEGMENTS
                 NSEG             = NSEG + 1
                 RSEG(NSEG,1)     = WORKSP(I)
                 ZSEG(NSEG,1)     = TDUM(I)
                 RSEG(NSEG,2)     = WORKSP(I+1)
                 ZSEG(NSEG,2)     = TDUM(I+1)
                 IF( ITYPE.EQ.1 ) THEN
                     ISEG(NSEG,1) = LNDSP(1,I)
                     ISEG(NSEG,2) = LNDSP(2,I)
                 ELSE
                     ISEG(NSEG,1) = LNDSP(2,I)
                     ISEG(NSEG,2) = LNDSP(1,I)
                 END IF
             ENDDO
C....
         END IF
C
  100 CONTINUE
C
C(X)  HORIZONTAL TARGET ESCAPE FIGURE PATCH (FOR ITYPE=1 ONLY!)
C
      IF( ITYPE.EQ.1 ) THEN
C.. LHS
          IF( MHZWA(2).GT.0 ) THEN
              NSEG         = NSEG + 1
              RSEG(NSEG,1) = RVERTM(MHZWA(2),IVHZWA(2,1))
              ZSEG(NSEG,1) = ZVERTM(MHZWA(2),IVHZWA(2,1))
              RSEG(NSEG,2) = RVERTM(MHZWA(2),IVHZWA(2,2))
              ZSEG(NSEG,2) = ZVERTM(MHZWA(2),IVHZWA(2,2))
              ISEG(NSEG,1) = MHZWA(2)
              ISEG(NSEG,2) = MHZVO(2)
          END IF
C.. RHS
          IF( MHZWA(1).GT.0 ) THEN
              NSEG         = NSEG + 1
              RSEG(NSEG,1) = RVERTM(MHZWA(1),IVHZWA(1,1))
              ZSEG(NSEG,1) = ZVERTM(MHZWA(1),IVHZWA(1,1))
              RSEG(NSEG,2) = RVERTM(MHZWA(1),IVHZWA(1,2))
              ZSEG(NSEG,2) = ZVERTM(MHZWA(1),IVHZWA(1,2))
              ISEG(NSEG,1) = MHZWA(1)
              ISEG(NSEG,2) = MHZVO(1)
          END IF
C
      END IF
C
C(17) INITIALIZE SEQUENTIAL ORDERING
C     NOTE :-
C            ISTART = SEGMENT WHICH HAS VERTICIES,
C                     ( XR4(1) , YR4(1) ) & ( XR4(2) , YR4(2) )
C            JSTART = VERTEX WHICH MATCHES ( XR4(2) , YR4(2) )
C
C.. TOP POINT ON RHS PRIVATE REGION NEAREST TO VOID
      XR4(1) = RPOLY( NXWPG+1 , NJPOLY(NXWPG+1) )
      YR4(1) = ZPOLY( NXWPG+1 , NJPOLY(NXWPG+1) )
C
C.. TOP POINT ON RHS PRIVATE REGION ADJACIENT TO ABOVE RING
      XR4(2) = RPOLY( NXWPG+2 , NJPOLY(NXWPG+2) )
      YR4(2) = ZPOLY( NXWPG+2 , NJPOLY(NXWPG+2) )
C
C.. FIND ISTART AND JSTART
      CALL SETORD( MSEG
     &           , NSEG   , RSEG(1,1)  , ZSEG(1,1)
     &           , XR4(1) , YR4(1)     , XR4(2)    , YR4(2)
     &           , ISTART , JSTART     , IERR      )
C
      IF( IERR.NE.0 ) THEN
          WRITE(MESS,9030) CTYPE(ITYPE) , IERR
          IER = 3
          GOTO 9999
      END IF
C
C(18) ASSEMBLE SEGMENT PAIRS INTO SEQUENTIAL ORDERED VECTOR
C     STARTING AT VERTEX # JSTART OF SEGMENT # ISTART
C
      CALL VESORD( MSEG   , ISTART     , JSTART    , .TRUE.
     &           , NSEG   , RSEG(1,1)  , ZSEG(1,1)
     &           , MDIM   , MZONE(1,1)
     &           , NSEGOD , IERR       )
C
      IF( IERR.NE.0 ) THEN
          WRITE(MESS,9040) CTYPE(ITYPE) , IERR
          IER = 4
          GOTO 9999
      END IF
C
C(19) ASSEMBLE SEGMENT PAIRS INTO SEQUENTIAL ORDER
C     SEGMENT PAIRS
C
      CALL SEGORD( MSEG
     &           , NSEG   , RSEG(1,1)  , ZSEG(1,1) , ISEG(1,1)
     &           , NSEGOD , MZONE(1,1)
     &           , MDIM/2 , MZONE(1,2) , SBUFER(1)
     &           , IERR   )
C
      IF( IERR.NE.0 ) THEN
          WRITE(MESS,9050) CTYPE(ITYPE) , IERR
          IER = 5
          GOTO 9999
      END IF
C
C(20) SET SEGMENT GROUPING
C
C     NOTE: THE LAST SEGMENT OF THE TARGET REGION AND THE FIRST
C     ----  SEGMENT OF THE DIVERTOR REGION WILL BOTH SHARE THE
C           SAME TARGET WALL POLYGON, I.E AN L-SHAPE ASSEMBLY.
C     THUS: SEGMENTS WITH,
C     ----  TARGET WALL POLY. IN CONTACT WITH PLASMA = TARGET   SEGMENT
C           TARGET WALL POLY. IN CONTACT WITH VOID   = DIVERTOR SEGMENT
C           (THIS IS A WALL GROUNPING ISSUE I.E. ITYPE=1)
C     SEE : (20A) BELOW FOR THE CODING
C     ----
C
      DO 200 I    = 1 , NSEG
C
         IF( ITYPE.EQ.1 ) THEN
             M    = ISEG(I,1)
         ELSE
             M    = ISEG(I,2)
         END IF
C.. PRIVATE VOID
         IF( ITAGRM(M).EQ.11 .OR. ITAGRM(M).EQ.14 ) THEN
             GSEG(I) = GWREG(8)
C.. OUTER TARGET
         ELSE IF( ITAGRM(M).EQ.10 ) THEN
C(20A)
             IF( ITYPE.EQ.1 .AND. COMM(ISEG(I,2)+2).NE.PLASMA ) THEN
                 GSEG(I) = GWREG(3)
             ELSE
                 GSEG(I) = GWREG(1)
             END IF
C.. INNER TARGET
         ELSE IF( ITAGRM(M).EQ.12 ) THEN
C(20A)
             IF( ITYPE.EQ.1 .AND. COMM(ISEG(I,2)+2).NE.PLASMA ) THEN
                 GSEG(I) = GWREG(5)
             ELSE
                 GSEG(I) = GWREG(7)
             END IF
C.. OUTER CORNER
         ELSE IF( ITAGRM(M).EQ.21 ) THEN
             GSEG(I) = GWREG(2)
C.. INNER CORNER
         ELSE IF( ITAGRM(M).EQ.22 ) THEN
             GSEG(I) = GWREG(6)
C.. OUTER DIVERTOR
         ELSE IF( ITAGRM(M).EQ.17 .OR. ITAGRM(M).EQ.19 ) THEN
             GSEG(I) = GWREG(3)
C.. INNER DIVERTOR
         ELSE IF( ITAGRM(M).EQ.18 .OR. ITAGRM(M).EQ.20 ) THEN
             GSEG(I) = GWREG(5)
C.. MAIN SOL
         ELSE
             GSEG(I) = GWREG(4)
         END IF
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
 9010 FORMAT( 'ITYPE (' , I4 , ') NOT KNOWN' )
 9020 FORMAT( 'NO. OF ' , A , ' (' , I6 ,') EXCEEDS MAXIMUM ALLOWED ('
     &      , I6 , ')' )
 9030 FORMAT( 'UNABLE TO INIT. I & J-START FOR ' , A
     &      , ', IERR (SETORD) =' ,I5 )
 9040 FORMAT( 'UNABLE TO COMPLETE ' , A , ', IERR (VESORD) ='  , I5 )
 9050 FORMAT( 'UNABLE TO RE-ORDER ' , A , ', IERR (SEGORD) =' , I5 )
 9060 FORMAT( 'NO. OF PAIRS (' , I5 , ') EXCEEDS MAXIMUM ALLOWED ('
     &      , I6 , ')' )
 9070 FORMAT( 'POLYGON ' , I5 , ' CONTAINS MORE THAN ONE GAP POLYGON' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE PNEIGH( NPGTST , IPGSID
     I                 , MPOLY  , MVPOLY
     I                 , NPOLY  , NVPOLY
     I                 , RPOLY  , ZPOLY
     O                 , NPGFND )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : POLYGON NEIGHBOUR (NIMBUS POLYGONS)
C           -       - --
C VERSION : V1.R2.M0
C
C PURPOSE : TO FIND A POLYGON WHICH HAS THE SAME VERTICES FORMING SIDE
C           'NPGSID' OF POLYGON 'NPGTST'.
C
C INPUT   : (I*4) NPGTST       = POLYGON TO TEST
C           (I*4) IPGSID       = BORDER SIDE
C
C           (I*4) MPOLY        = MAX. NO. OF NIMBUS POLYGONS
C           (I*4) MVPOLY       = MAX. NO. OF VERTICES/NIMBUS POLYGON
C           (I*4) NPOLY        = NO. OF NIMBUS POLYGONS
C           (I*4) NVPOLY()     = NO. OF VERTICES/NIMBUS POLYGON
C                                (NVPOLY.LE.MAXVER )
C           (R*8) RPOLY(M,V)   = R OF VERTEX # V IN NIMBUS POLYGON M
C           (R*8) ZPOLY(M,V)   = Z OF VERTEX # V IN NIMBUS POLYGON M
C
C OUTPUT  : (I*4) NPGFND       = POLYGON BORDERING 'NPGTST' ON REQUIRED
C                                SIDE
C                              = 0 --- NO POLYGON BORDERS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 09/05/95 --- CREATION
C           V1.R2.M0 --- 21/08/95 --- IF BOTH VERTICES DO NOT MATCH THEN
C                                     USE GRAIDIENT COMPARISON AS LONG
C                                     AS ONE VERTEX DOES MATCH
C                                     (CURRENTLY ONLY WORKS FOR ZERO
C                                      GRADIENTS)
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  NPGTST                 , IPGSID
     &        ,  MPOLY                  , MVPOLY
     &        ,  NPOLY                  , NVPOLY(MPOLY)
      REAL*8     RPOLY(MPOLY,MVPOLY)    , ZPOLY(MPOLY,MVPOLY)
C
C..OUTPUT
      INTEGER*4  NPGFND
C
C..PROGRAM
      INTEGER*4  M    , MV   , NPGBUP
     &        , IP    , IM   , IM0
      REAL*8     R(4) , Z(4) , GRADA  , GRADB
     &        , SM    , SM0
      LOGICAL    L31  , L32  , L41    , L42
C
C..PARAMETER
      REAL*8     EPS
      PARAMETER( EPS = 1.0D-10 )
C
C-------------------------------- INITIALIZE --------------------------
C
      NPGFND          = 0
C
C--------------------- SET UP TEST SIDE OF TEST POLYGON ---------------
C
      R(1)            = RPOLY(NPGTST,IPGSID)
      Z(1)            = ZPOLY(NPGTST,IPGSID)
C
      IF( IPGSID.LT.NVPOLY(NPGTST) ) THEN
          R(2)        = RPOLY(NPGTST,IPGSID+1)
          Z(2)        = ZPOLY(NPGTST,IPGSID+1)
      ELSE
          R(2)        = RPOLY(NPGTST,1)
          Z(2)        = ZPOLY(NPGTST,1)
      END IF
C
      IF( R(1).NE.R(2) ) THEN
          GRADA = ( Z(2) - Z(1) ) / ( R(2) - R(1) )
      ELSE
          GRADA = 1.0D+30
      END IF
C
C-----------------------------------------------------------------------
C
      DO 100 M       = 1 , NPOLY
         IF( M.EQ.NPGTST ) GOTO 100
C
         NPGBUP      = 0
C
         DO 150 MV   = 1 , NVPOLY(M)
C
            R(3)     = RPOLY(M,MV)
            Z(3)     = ZPOLY(M,MV)
C
            IF( MV.LT.NVPOLY(M) ) THEN
                R(4) = RPOLY(M,MV+1)
                Z(4) = ZPOLY(M,MV+1)
            ELSE
                R(4) = RPOLY(M,1)
                Z(4) = ZPOLY(M,1)
            END IF
C
            IF( R(3).NE.R(4) ) THEN
                GRADB = ( Z(4) - Z(3) ) / ( R(4) - R(3) )
            ELSE
                GRADB = 1.0D+30
            END IF
C
            L31 = R(3).EQ.R(1) .AND. Z(3).EQ.Z(1)
            L32 = R(3).EQ.R(2) .AND. Z(3).EQ.Z(2)
            L41 = R(4).EQ.R(1) .AND. Z(4).EQ.Z(1)
            L42 = R(4).EQ.R(2) .AND. Z(4).EQ.Z(2)
C
            IF( ( L31 .AND. L42 ) .OR. ( L32 .AND. L41 ) ) THEN
               NPGFND = M
               GOTO 9999
            ELSE IF( ( L31 .OR. L32 .OR. L41 .OR. L42 ) .AND.
     >                 DABS(GRADA-GRADB).LE.EPS ) THEN
               IF( L31 .OR. L32 ) THEN
                   IP  = 3
                   IM0 = 4
                   IF( L31 ) IM = 2
                   IF( L32 ) IM = 1
               ELSE IF( L41 .OR. L42 ) THEN
                   IP  = 4
                   IM0 = 3
                   IF( L41 ) IM = 2
                   IF( L42 ) IM = 1
               END IF
               SM  = DSIGN(1.0D0,R(IP)-R(IM) )
               SM0 = DSIGN(1.0D0,R(IP)-R(IM0))
               IF( SM.EQ.SM0 ) NPGBUP = M
            END IF
C
  150    CONTINUE
C
         IF( NPGBUP.GT.0 ) THEN
             NPGFND = NPGBUP
             GOTO 9999
         END IF
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE TRMCAT( INTRIM , MFTRIM
     I                 , PRETRM , PROTRM , TARTRM
     O                 , TRMFIL , MESS   , IER    )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : TRIM FILE NAMES AND CHECK CATALOGUE
C           -- -                      ---
C VERSION : V1.R1.M0
C
C PURPOSE : FORM 'MFTRIM' TRIM FILES WITH :-
C                 TRMFIL() = PRETRM
C                            PROTRM
C                            .
C                            TARTRM
C           THEN TO CHECK FOR THE FILE'S EXISTANCE
C
C INPUT   : (I*4) INTRIM       = STREAM NUMBER
C           (I*4) MFTRIM       = NO. OF TRIM FILES TOP FORM
C           (C**) PRETRM       = PREFIX FOR TRIM FILES
C           (C**) PROTRM()     = PROJECTILE ATOMIC SYMBOL
C           (C**) TARTRM()     = TARGET ATOMIC SYMBOL
C
C OUTPUT  : (C**) TRMFIL()     = FULL TRIM FILE NAME
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- 'PRETRM' IS BLANK
C                              = 2 --- 'PRETRM' HAS LEADING BLANKS
C                              = 3 --- 'PROTRM' IS BLANK
C                              = 4 --- 'PROTRM' HAS LEADING BLANKS
C                              = 5 --- 'TARTRM' IS BLANK
C                              = 6 --- 'TARTRM' HAS LEADING BLANKS
C                              = 7 --- FILE DOES NOT EXIST
C
C PROGRAM : (I*4) IPRE         = LAST NON-BLANK IN 'PRETRM'
C           (I*4) IPRO         = LAST NON-BLANK IN 'PROTRM'
C           (I*4) ITAR         = LAST NON-BLANK IN 'TARTRM'
C           (I*4) IFBLNK       = FIRST BLANK FOUND
C           (LOG) LEXIST       = .T. --- TRIM FILE EXIST
C
C ROUTINES: (I*4) LEN()        = LENGTH OF A STRING
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 16/05/95 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 INTRIM , MFTRIM
      CHARACTER PRETRM*(*) , PROTRM(MFTRIM)*(*) , TARTRM(MFTRIM)*(*)
C
C..OUTPUT
      INTEGER*4 IER
      CHARACTER MESS*(*) , TRMFIL(MFTRIM)*(*)
C
C..PROGRAM
      INTEGER*4 IPRE   , IPRO , ITAR , IFBLNK
     &        , I      , N
      LOGICAL   LEXIST
C
C..ROUTINES
      INTEGER*4 LEN
C
C-----------------------------------------------------------------------
C
      IPRE     = 0
      IFBLNK   = 0
      DO 100 I = 1 , LEN(PRETRM)
         IF( PRETRM(I:I).NE.' ' ) IPRE = I
         IF( PRETRM(I:I).EQ.' ' .AND. IFBLNK.EQ.0 ) IFBLNK = I
 100  CONTINUE
C
      IF( IPRE.LE.0 ) THEN
          WRITE(MESS,9010) 'PREFIX'
          IER = 1
          GOTO 9999
      ELSE IF( IFBLNK.LE.IPRE ) THEN
          WRITE(MESS,9020) 'PREFIX'
          IER = 2
          GOTO 9999
      END IF
C
C-----------------------------------------------------------------------
C
  10  DO 200 N = 1 , MFTRIM
C
         IPRO     = 0
         IFBLNK   = 0
         DO 220 I = 1 , LEN(PROTRM(N))
            IF( PROTRM(N)(I:I).NE.' ' ) IPRO = I
            IF( PROTRM(N)(I:I).EQ.' ' .AND. IFBLNK.EQ.0 ) IFBLNK = I
 220     CONTINUE
C
         IF( IPRO.LE.0 ) THEN
             WRITE(MESS,9010) 'PROJECTILE'
             IER = 3
             GOTO 9999
         ELSE IF( IFBLNK.LE.IPRO ) THEN
             WRITE(MESS,9020) 'PROJECTILE'
             IER = 4
             GOTO 9999
         END IF
C
         ITAR     = 0
         IFBLNK   = 0
         DO 240 I = 1 , LEN(TARTRM(N))
            IF( TARTRM(N)(I:I).NE.' ' ) ITAR = I
            IF( TARTRM(N)(I:I).EQ.' ' .AND. IFBLNK.EQ.0 ) IFBLNK = I
 240     CONTINUE
C
         IF( ITAR.LE.0 ) THEN
             WRITE(MESS,9010) 'TARGET'
             IER = 5
             GOTO 9999
         ELSE IF( IFBLNK.LE.ITAR ) THEN
             WRITE(MESS,9020) 'TARGET'
             IER = 6
             GOTO 9999
         END IF
C
         TRMFIL(N) = PRETRM(1:IPRE)    //
     &               PROTRM(N)(1:IPRO) // '.' //
     &               TARTRM(N)(1:ITAR)
C
         INQUIRE( FILE=TRMFIL(N) , EXIST=LEXIST )
         IF( .NOT.LEXIST ) THEN
             WRITE(MESS,9040) TRMFIL(N)
             IER = 7
             GOTO 9999
         END IF
C
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
 9010 FORMAT( A , ' TRIM NAME MUST NOT BE BLANK' )
 9020 FORMAT( A , ' TRIM NAME MUST NOT HAVE LEADING BLANKS' )
 9040 FORMAT( A , ' DOES NOT EXIST' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE RNGCUT( NPOL   , RPOL  , ZPOL
     I                 , ISTART , ISTOP , IEXCL , IRES )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : RING CUTTING
C           - -- ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO TEST IF POLYGON (RPOL(),ZPOL()) INTERSECTS
C           (RPOLY(I,J),(ZPOLY(I,J)) RINGS EXCLUDING RING = IEXCL
C
C INPUT   : (I*4) NPOL         = NO. OF TEST POLYGON VERTICES
C           (R*8) RPOL()       = R-COORDINATES OF THOSE VERTICES
C           (R*8) ZPOL()       = Z-COORDINATES OF THOSE VERTICES
C           (I*4) ISTART       = STARTING  RING FOR SCAN
C           (I*4) ISTOP        = FINISHING RING FOR SCAN
C           (I*4) IEXCL        = EXCLUSION RING FROM SCAN RANGE
C
C OUTPUT  : (I*4) IRES         = 1ST RING CUT
C
C /CPOLYG/: (SEE 'c09')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C PROGRAM : (I*4) I            = RING INDEX
C           (I*4) J            = POINT ALONG RING
C           (I*4) N            = ROOT INDEX
C           (I*4) NROOT        = NO. OF ROOTS (CUTS)
C           (R*8) EPS          = TOLERANCE AMOUNT FOR ROOTS
C
C ROUTINES: (R*8) PYTHGS       = LENGTH BETWEEN TWO POINTS
C           (I*4) I4CHRV       = CONVERT STRING TO INTEGER
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 19/05/95 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 NPOL       , ISTART     , ISTOP , IEXCL
      REAL*8    RPOL(NPOL) , ZPOL(NPOL)
C
C..OUTPUT
      INTEGER*4 IRES
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4   I   , J , N , NROOT
      REAL*8      EPS
C
C..ROUTINES
      REAL*8      PYTHGS
C
C-----------------------------------------------------------------------
C
      PARAMETER( EPS    = 3.0D-05 )
C
      IRES     = 0
C
C-----------------------------------------------------------------------
C
      DO 100 I = ISTART , ISTOP
         IF( I.NE.IEXCL ) THEN
C
             DO 120 J   = 1 , NJPOLY(I)
                XDUM(J) = RPOLY(I,J)
                YDUM(J) = ZPOLY(I,J)
  120        CONTINUE
C
             CALL ROOT( NPOL       , RPOL(1)    , ZPOL(1)
     &                , NJPOLY(I)  , XDUM(1)    , YDUM(1)
     &                , 2          , WORKSP(1)  , TDUM(1)
     &                , LNDSP(1,1) , LNDSP(1,1) , NROOT   )
C
             MZONE(1,1)      = NROOT
             DO 140 N        = 1 , MZONE(1,1)
                DO 160 J     = 1 , NPOL
                   BUFFER(1) = PYTHGS( WORKSP(N) , TDUM(N)
     &                               , RPOL(J)   , ZPOL(J) )
                   IF( BUFFER(1).LE.EPS ) NROOT = MAX0(NROOT-1,0)
  160           CONTINUE
  140        CONTINUE
C
             IF( NROOT.GT.0 ) THEN
                 IRES = I
                 GOTO 9999
             END IF
C
         END IF
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE CHKLRS( MPLAS , NPLAS , RPLAS , ZPLAS
     I                 , MVES  , NVES  , RVES  , ZVES
     I                 , LOUT  , MGEN  , RGEN  , ZGEN
     O                 , IER   , MESS  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : CHECK LEAK RECYCLING SEGMENTS
C           --  - -    -         -
C VERSION : V1.R1.M0
C
C PURPOSE : TO TEST IF EACH LEAK RECYCLING SEGMENTS IN ENTIRELY BETWEEN
C           THE PLASMA BOUNDARY AND THE VESSEL BOUNDARY.
C
C INPUT   : (I*4) MPLAS        = MAX. NO. OF PLASMA BOUNDARY SEGMENTS
C           (I*4) NPLAS        = NO. OF PLASMA BOUNDARY SEGMENTS
C           (R*4) RPLAS(,)     = R-COORDINATES OF THOSE SEGMENTS
C           (R*4) ZPLAS(,)     = Z-COORDINATES OF THOSE SEGMENTS
C
C           (I*4) MVES         = MAX. NO. OF VESSEL BOUNDARY SEGMENTS
C           (I*4) NVES         = NO. OF VESSEL BOUNDARY SEGMENTS
C           (R*4) RVES(,)      = R-COORDINATES OF THOSE SEGMENTS
C           (R*4) ZVES(,)      = Z-COORDINATES OF THOSE SEGMENTS
C
C           (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MGEN         = NO. OF RGEN() & ZGEN()
C           (R*8) RGEN()       = GENERAL REAL
C           (R*8) ZGEN()       = GENERAL REAL
C
C OUTPUT  : (I*4) IER          = 0 --- ALL SEGMENTS O.K
C                              = I --- SEGMENT # I HAS FAILED
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C PROGRAM : (I*4) I            = GENERAL INTEGER
C           (I*4) J            = GENERAL INTEGER
C           (I*4) L            = GENERAL INTEGER
C           (I*4) N            = GENERAL INTEGER
C           (R*8) RESULT       = GA15 RESULT
C           (I*4) NROOT        = NO. OF ROOTS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 19/01/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MPLAS , MVES   , NPLAS , NVES , LOUT , MGEN
      REAL*4     RPLAS(MPLAS,2) , ZPLAS(MPLAS,2)
     &        ,  RVES(MVES,2)   , ZVES(MVES,2)
      REAL*8     RGEN(MGEN)     , ZGEN(MGEN)
C
C..OUTPUT
      INTEGER*4  IER
      CHARACTER  MESS*(*)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4  I , J , L , N , NROOT
      REAL*8     RESULT
C
C----------------------------- INITIALISE ------------------------------
C
      IER = 0
C
C---------- CHECK ALL LRS' ARE WITHIN PLASMA/VESSEL INTERFACE ----------
C
      DO 100 L = 1 , 2
C
C-----------------------------------------------------------------------
C
C..STORE BOUNDARY
         IF( L.EQ.1 ) THEN
             N                = NPLAS
             DO 200 I         = 1 , N
                BUFFER(I)     = RPLAS(I,1)
                BUFFER(MDIM+I)= ZPLAS(I,1)
  200        CONTINUE
         ELSE
             N                = NVES
             DO 210 I         = 1 , N
                BUFFER(I)     = RVES(I,1)
                BUFFER(MDIM+I)= ZVES(I,1)
  210        CONTINUE
         END IF
         BUFFER(N+1)          = BUFFER(1)
         BUFFER(MDIM+N+1)     = BUFFER(MDIM+1)
C
C..SETUP BOUNDARY CHECKING
         CALL GA15AD( N+1      , 1
     &              , WORKSP(1), IWORK         , LNDSP(1,1), LND
     &              , BUFFER(1), BUFFER(MDIM+1)
     &              , TDUM(1)  , XDUM(1)       , YDUM(1)   , LOUT )
C
         DO 220 I = 1 , NLRS
C
C..CHECK EACH SEGMENT IS OUTSIDE PLASMA BOUNDARY OR INSIDE VESSEL
            DO 240 J = 1 , 2
               RGEN(J) = RLRS(I,J)
               ZGEN(J) = ZLRS(I,J)
               CALL GA15BD( RGEN(J)  , ZGEN(J)       , RESULT
     &                    , N+1      , 1
     &                    , WORKSP(1), IWORK         , LNDSP(1,1), LND
     &                    , BUFFER(1), BUFFER(MDIM+1)
     &                    , TDUM(1)  , XDUM(1)       , YDUM(1) , LOUT)
               IF( L.EQ.1 .AND. RESULT.GE.0.0D+00 ) THEN
                   IER = I
                   WRITE(MESS,9000) I , LALRS(I) , J , 'IN' , 'PLASMA'
                   GOTO 9999
               ELSE IF( L.EQ.2 .AND. RESULT.LE.0.0D+00 ) THEN
                   IER = I
                   WRITE(MESS,9000) I , LALRS(I) , J , 'OUT' , 'VESSEL'
                   GOTO 9999
               END IF
  240       CONTINUE
C
C..CHECK SEGMENT DOES NOT CROSS BOUNDARY
            NROOT = 0
            CALL ROOT( N+1        , BUFFER(1)        , BUFFER(MDIM+1)
     &               , 2          , RGEN(1)          , ZGEN(1)
     &               , 1          , RGEN(3)          , ZGEN(3)
     &               , MZONE(1,1) , MZONE(1,2)       , NROOT          )
            IF( NROOT.GT.0 ) THEN
                IER = I
                IF( L.EQ.1 ) THEN
                    WRITE(MESS,9010) I , LALRS(I) , 'PLASMA'
                ELSE
                    WRITE(MESS,9010) I , LALRS(I) , 'VESSEL'
                END IF
                GOTO 9999
            END IF
C
  220    CONTINUE
C
C-----------------------------------------------------------------------
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( ' LRS #' , I2 , ' (LABELLED ' , A , ') HAS VERTEX #' , I2
     &      , 1X , A , 'SIDE THE ' , A ,' BOUNDARY!' )
 9010 FORMAT( ' LRS #' , I2 , ' (LABELLED ' , A
     &      , ') CROSSES THE ' , A , ' BOUNDARY!' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE WALGAP( LOUT
     I                 , MPG    , MRG    , MR     , NPOLY
     I                 , NVERTM , RVERTM , ZVERTM , ITAGES
     I                 , RPX    , ZPX    , RMARKG , ZMARKG
     O                 , IPSEMP , PSEMP  , PSEMG  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : WALL GAP
C           ---  ---
C VERSION : V1.R7.M0
C
C PURPOSE : SET IPSEMP(I) TO A NIMBUS REGION IF ESCAPE FIGURE CUTS
C           THE WALL GAP SEGMENT MORE THAN ONCE.  THEN FILL PSEMP(I)
C           AND PSEMG(I) WITH GAP TRANSPARANCY VALUES.  IF
C           THE NIMBUS REGION IS ALREADY GIVEN IN IPSEMP() THEN
C           DO NOT RE-SET IT.
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MPG          = MAX. NO. OF NIMBUS POLYGONS ALLOWED
C           (I*4) MRG          = MAX. NO. OF VERTICES ALLOWED
C           (I*4) MR           = MAX. NO. OF IPSEMP() ELEMENTS
C           (I*4) NPOLY        = NO. OF POLYGONS
C           (I*4) NVERTM(M)    = NO. OF VERTICES FOR POLYGON # M
C           (R*8) RVERTM(M,V)  = R-COORDINATES OF POLYGON # M VERTEX # V
C           (R*8) ZVERTM(M,V)  = Z-COORDINATES OF POLYGON # M VERTEX # V
C           (I*4) ITAGES(M)    < 0 --- NIMBUS POLYGON # M LIES IN THE
C                                      PUMP STRUCTURE
C           (R*8) RPX          = R-COORD OF X-POINT
C           (R*8) ZPX          = Z-COORD OF X-POINT
C           (R*8) RMARKG(1)    = R-COORD OF MAX. VERTEX ON OUTER TARGET
C                       (2)    = R-COORD OF MAX. VERTEX ON INNER TARGET
C           (R*8) ZMARKG(1)    = Z-COORD OF MAX. VERTEX ON OUTER TARGET
C                       (2)    = Z-COORD OF MAX. VERTEX ON INNER TARGET
C
C OUTPUT  : (I*4) IPSEMP()     = NIMBUS REGION IDENTIFIED AS A PART OF
C                                THE WALL GAP.
C           (R*4) PSEMP()      = PLASMA SIDE TRANSPARANCY FOR ABOVE
C           (R*4) PSEMG()      = PUMP   SIDE TRANSPARANCY FOR ABOVE
C
C /CPUMP/ : (SEE 'cpump')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C ROUTINES: (R*8) SMIN1()      = MINIMUM VALUE IN AN ARRAY AND INDEX
C           (R*8) SMAX1()      = MAXIMUM VALUE IN AN ARRAY AND INDEX
C
C PROGRAM : (I*4) I            = GENERAL INTEGER
C           (I*4) J            = GENERAL INTEGER
C           (I*4) M            = POLYGON INDEX
C           (I*4) NROOT        = NO. OF INTERSECTIONS
C           (R*8) ZMIN(I)      = MINIMUM OF GAP # I (AT EXIT)
C           (R*8) ZMAX(I)      = MAXIMUM OF GAP # I (AT EXIT/ENTRANCE)
C           (R*8) ZLOW         = MAXIMUM OF GAP (AT ENTRANCE)
C           (R*8) ZUPP         = MAXIMUM OF GAP (AT ENTRANCE)
C           (LOG) LTRAN        = GENERAL LOGICAL
C
C NOTES   : IT IS ASSUMED THAT LOWER POINT OF GAP CHANNEL IS HORIZONTAL
C           WITH RESPECT TO THE VESSEL BOUNDARY.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 19/01/96 --- CREATION
C           V1.R2.M0 --- 03/07/96 --- PRINT EFF. GAP LENGTHS & POLYGONS
C           V1.R3.M0 --- 01/08/96 --- APPLY GAPS TO ESCAPE FIGURES WHICH
C                                     HAVE VALUES ITAGES()=-1 OR -3 I.E.
C                                     RHS AND LHS PUMP SIDES
C           V1.R4.M0 --- 30/05/96 --- EXTEND GAPS TO ESCAPE FIGURES WHICH
C                                     HAVE VALUE ITAGES()=-2 I.E
C                                     TOP PUMP SIDE
C           V1.R5.M0 --- 30/10/97 --- PRINT LENGTHS OF GAP CHANNEL AT
C                                     VESSEL ENTRANCE AND EXIT FROM
C                                     CHANNEL
C                                 --- PASS X-POINT COORDS (RPX,ZPX)
C                                 --- PASS ZMARKG()
C           V1.R6.M0 --- 31/10/97 --- STORE MGAP(,) AND NMGAP() IN
C                                     COMMON BLOCK /CPUMP/
C           V1.R7.M0 --- 10/11/97 --- RPGAP(,) & ZPGAP(,) IN /CPUMP/
C                                 --- RMARKG(,) INTO ARGUMENT LIST
C                                 --- PRINT-OUT PLASMA SIDE COORDS
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  LOUT
     &        ,  MPG             , MRG             , MR  , NPOLY
     &        ,  NVERTM(MPG)     , ITAGES(MPG)
      REAL*8     RVERTM(MPG,MRG) , ZVERTM(MPG,MRG)
     &        ,  RPX             , ZPX
     &        ,  RMARKG(2)       , ZMARKG(2)
C
C..OUTPUT
      INTEGER*4  IPSEMP(MR)
      REAL*8     PSEMP(MR)    , PSEMG(MR)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..ROUTINES
      REAL*8     SMAX1 , SMIN1
C
C..PROGRAM
      INTEGER*4  I , J , M , NROOT , LMIN , LMAX
      REAL*8     RZMIN(MWGAP) , ZMIN(MWGAP)
     &        ,  RZMAX(MWGAP) , ZMAX(MWGAP)
     &        ,  RZLOW        , ZLOW
     &        ,  RZUPP        , ZUPP
      LOGICAL    LTRAN
      CHARACTER  CTRAN*5
C
C-----------------------------------------------------------------------
C
      CALL RESETI( NMGAP(1)  , MWGAP       , 0        )
      CALL RESETI( MGAP(1,1) , MWGAP*MXGAP , 0        )
C
      CALL RESETR( ZMIN(1)   , MWGAP       , 1.0D+30  )
      CALL RESETR( ZMAX(1)   , MWGAP       , -1.0D+30 )
C
C.. PROCESS WALL POLYGONS CUTTING PUMP STRUCTURE
      DO 100 M = 1 , NPOLY
         IF( ITAGES(M).LT.0 ) THEN
C
C.. COPY POLYGON VERTICES INTO GENERAL ARRAY AND CLOSE LOOP
             DO 120 I        = 1 , NVERTM(M)
                XDUM(I)      = RVERTM(M,I)
                YDUM(I)      = ZVERTM(M,I)
  120       CONTINUE
            XDUM(NVERTM(M)+1) = XDUM(1)
            YDUM(NVERTM(M)+1) = YDUM(1)
C
C.. LOOP OVER ALL WALL GAP SEGMENTS
            DO 140 I         = 1 , NWGAP
C
C.. COPY WALL GAP SEGMENTS INTO GENERAL ARRAY
               BUFFER(1)     = RWGAP(I,1)
               BUFFER(2)     = RWGAP(I,2)
               BUFFER(3)     = ZWGAP(I,1)
               BUFFER(4)     = ZWGAP(I,2)
C
C.. FIND INTERSECTION OF POLYGON AND GAP
               CALL ROOT( NVERTM(M)+1 , XDUM(1)    , YDUM(1)
     &                  , 2           , BUFFER(1)  , BUFFER(3)
     &                  , 10          , TDUM(1)    , TDUM(11)
     &                  , MZONE(1,1)  , MZONE(1,2) , NROOT     )
C
               IF( NROOT.GT.1 ) THEN
C
C.. HAS POLYGON ALREADY BEEN DEFINED ?
                   LTRAN     = .TRUE.
                   DO 160 J  = 1 , MR
                      IF( IPSEMP(J).EQ.M+2 ) LTRAN = .FALSE.
  160              CONTINUE
C
C.. STORE POLYGON AND TRANSPARANCY VALUE
                   IF( LTRAN ) THEN
                       DO 180 J = 1 , MR
                          IF( IPSEMP(J).EQ.0 ) THEN
                              NMGAP(I)   = NMGAP(I) + 1
                              IF(NMGAP(I).LT.MXGAP) MGAP(I,NMGAP(I)) = M
                              IPSEMP(J)  = M+2
                              PSEMP(J)   = PWGAP(I,1)
                              PSEMG(J)   = PWGAP(I,2)
                              WORKSP(1)  = SMIN1(TDUM(11),NROOT,LMIN)
                              WORKSP(2)  = SMAX1(TDUM(11),NROOT,LMAX)
                              IF( WORKSP(1).LT.ZMIN(I) ) THEN
                                 ZMIN(I) = WORKSP(1)
                                 RZMIN(I)= TDUM(LMIN)
                              END IF
                              IF( WORKSP(2).GT.ZMAX(I) ) THEN
                                 ZMAX(I) = WORKSP(2)
                                 RZMAX(I)= TDUM(LMAX)
                              END IF
                              GOTO 185
                          END IF
  180                  CONTINUE
  185                  CONTINUE
                   END IF
               END IF
C
  140       CONTINUE
C
         END IF
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      IF( LOUT.GT.0 ) THEN
C
          WRITE(LOUT,1000)
C
          DO 200 I = 1 , NWGAP
C.. IS GAP ON OUTER/INNER SIDE OF X-POINT ?
             IF(  RWGAP(I,1).GT.RPX ) THEN
                 CTRAN = 'OUTER'
                 J     = 1
             ELSE
                 CTRAN = 'INNER'
                 J     = 2
             END IF
C.. PRINT OUT LENGTHS AND GAP POLYGON LIST
             IF( I.GT.1 ) WRITE(LOUT,*) ' '
C
             IF( NMGAP(I).GT.0 ) THEN
C
                 IF( IGOPT.EQ.1 ) THEN
                     ZLOW  = ZPGAP(J,1)
                     RZLOW = RPGAP(J,1)
                     ZUPP  = ZPGAP(J,2)
                     RZUPP = RPGAP(J,2)
                 ELSE
                     ZLOW  = ZMIN(I)
                     RZLOW = 1.0D+30
                     IF( ZMAX(I).GE.ZMARKG(J) ) THEN
                         ZUPP  = ZMARKG(J)
                         RZUPP = RMARKG(J)
                     ELSE
                         ZUPP  = ZMAX(I)
                         RZUPP = 1.0D+30
                     END IF
                 END IF
C
                 IF( ZLOW.LT.ZUPP ) THEN
                     WRITE(LOUT,1010) CTRAN , LAWGAP(I)
     &                              , 'ENTRANCE (PLASMA SIDE)'
     &                              , DABS( ZUPP - ZLOW )
     &                              , RZLOW , ZLOW
     &                              , RZUPP , ZUPP
                 ELSE
                     WRITE(LOUT,1010) CTRAN , LAWGAP(I)
     &                              , 'ENTRANCE (PLASMA SIDE)'
     &                              , DABS( ZUPP - ZLOW )
     &                              , RZUPP , ZUPP
     &                              , RZLOW , ZLOW
                 END IF
C
                 IF( ZMIN(I).LT.ZMAX(I) ) THEN
                     WRITE(LOUT,1010) CTRAN , LAWGAP(I)
     &                              , 'EXIT     (PUMP   SIDE)'
     &                              , DABS( ZMAX(I) - ZMIN(I) )
     &                              , RZMIN(I) , ZMIN(I)
     &                              , RZMAX(I) , ZMAX(I)
                 ELSE
                     WRITE(LOUT,1010) CTRAN , LAWGAP(I)
     &                              , 'EXIT     (PUMP   SIDE)'
     &                              , DABS( ZMAX(I) - ZMIN(I) )
     &                              , RZMAX(I) , ZMAX(I)
     &                              , RZMIN(I) , ZMIN(I)
                 END IF
C
                 WRITE(LOUT,1020) CTRAN , LAWGAP(I)
                 WRITE(LOUT,1025) (MGAP(I,J)+2,J=1,NMGAP(I))
             ELSE
                 WRITE(LOUT,1030) CTRAN , LAWGAP(I)
             END IF
  200     CONTINUE
C
          WRITE(LOUT,1040)
C
      END IF
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(/ 1X , 126('-') )
 1010 FORMAT( 1X , A , ' GAP CHANNEL ' , A , ' --- ' , A
     &      , ' LENGTH IS' , F8.3 , 'CM'
     &      / 28X , 'COORDS : ('
     &      , F7.2 , ',' , F7.2 , ') & (' , F7.2 , ',' , F7.2 , ')' )
 1020 FORMAT( 1X , A , ' GAP CHANNEL ' , A , ' --- CUTS POLYGONS :-' )
 1025 FORMAT(  12I6 )
 1030 FORMAT( 1X , A , ' GAP CHANNEL ' , A
     &      , ' HAS NOT CUT THROUGH ANY WALL POLYGONS' )
 1040 FORMAT(  1X , 126('-') /)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE DEFPMP( LOUT   , MLK
     &                 , PSEMPO , PSEMPI , PSEMPT , PSEMPX
     &                 , ALBPMP , ALBLK  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : DEFAULTS FOR PUMP PARAMETERS
C           ---          - --
C VERSION : V1.R1.M0
C
C PURPOSE : SET THE PUMP PARAMETERS TO THE VALUES GIVEN IN THE
C           PUMP FILE IF THEY LESS THAN ZERO
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MLK          = MAX. NO. OF LEAK REGIONS
C
C I/O     : (R*8) PSEMPO       = PROBABILITY OF SEMI-PERMEABILITY OF
C                                OUTER SOL DIVERTOR REGIONS
C           (R*8) PSEMPI       = PROBABILITY OF SEMI-PERMEABILITY OF
C                                INNER SOL DIVERTOR REGIONS
C           (R*8) PSEMPT       = PROBABILITY OF SEMI-PERMEABILITY OF
C                                TARGET DIVERTOR REGIONS
C           (R*8) ALBPMP       = ALBEDO FOR PUMP REGION (=1.0-PUMP EFF)
C           (R*8) ALBLK()      = ALBEDO FOR PUMP LEAK REGION
C
C /CPUMP/ : (SEE 'cpump')
C
C PROGRAM : (I*4) I            = GENERAL INTEGER
C           (I*4) IGOT         = 1 --- DEFAULT FROM 'NAMELIST'
C                              = 2 --- DEFAULT FROM 'PUMP FILE'
C                              = 3 --- DEFAULT FROM 'CODE DEFAULT'
C           (C*11) STRING()    = STRING REFERING TO IGOT
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 06/02/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  LOUT   , MLK
C
C..I/O
      REAL*8     PSEMPO , PSEMPI     , PSEMPT , PSEMPX
     &        ,  ALBPMP , ALBLK(MLK)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..PROGRAM
      INTEGER*4  I , IGOT
      CHARACTER  STRING(3)*11
C
      DATA STRING/ '(NAMELIST) ' , '(PUMP FILE)' , '(CODE)     ' /
C
C-----------------------------------------------------------------------
C
      IF( LOUT.GT.0 ) WRITE(LOUT,1000)
C
C-----------------------------------------------------------------------
C
C..PSEMPO
      CALL DEFAUL( PSEMPO , PMPDEF(1) , 0.06D+00 , PSEMPO , IGOT )
      IF( LOUT.GT.0 ) WRITE(LOUT,1010) 'PSEMPO' , PSEMPO , STRING(IGOT)
C
C..PSEMPI
      CALL DEFAUL( PSEMPI , PMPDEF(2) , 0.04D+00 , PSEMPI , IGOT )
      IF( LOUT.GT.0 ) WRITE(LOUT,1010) 'PSEMPI' , PSEMPI , STRING(IGOT)
C
C..PSEMPT
      CALL DEFAUL( PSEMPT , PMPDEF(3) , 0.03D+00 , PSEMPT , IGOT )
      IF( LOUT.GT.0 ) WRITE(LOUT,1010) 'PSEMPT' , PSEMPT , STRING(IGOT)
C
C..PSEMPX
      CALL DEFAUL( PSEMPX , PMPDEF(4) , 0.00D+00 , PSEMPX , IGOT )
      IF( LOUT.GT.0 ) WRITE(LOUT,1010) 'PSEMPX' , PSEMPX , STRING(IGOT)
C
C..ALBPMP
      CALL DEFAUL( ALBPMP , PMPDEF(5) , 0.80D+00 , ALBPMP , IGOT )
      IF( LOUT.GT.0 ) WRITE(LOUT,1010) 'ALBPMP' , ALBPMP , STRING(IGOT)
C
C..ALBLK
      DO 100 I = 1 , MLK
         CALL DEFAUL( ALBLK(I) , PMPDEF(10+I)  , 1.00D+00
     &              , ALBLK(I) , IGOT           )
         IF( LOUT.GT.0 ) WRITE(LOUT,1020) 'ALBLK'      , I , ALBLK(I)
     &                                  , STRING(IGOT)
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      IF( LOUT.GT.0 ) WRITE(LOUT,1030)
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(/ 1X , 62('-') )
 1010 FORMAT( ' PUMP PARAMETER ''' , A
     &      ,  '''    IS SET TO ' , 1PE12.4 , 2X , A )
 1020 FORMAT( ' PUMP PARAMETER ''' , A , '(' , I2
     &        , ')'' IS SET TO ' , 1PE12.4 , 2X , A )
 1030 FORMAT(  1X , 62('-') / )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DEFAUL( DEFOLD , DEFNEW , DEFBUP , DEFNOW , IGOT )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : DEFAULTS
C           -----
C VERSION : V1.R1.M0
C
C PURPOSE : TO SET DEFNOW TO DEFOLD OR DEFNEW OR DEFBUP
C
C INPUT   : (R*8) DEFOLD       = OLD DEFAULT
C           (R*8) DEFNEW       = NEW DEFAULT
C           (R*8) DEFBUP       = BACK-UP DEFAULT
C
C OUTPUT  : (R*8) DEFNOW       = CURRENT DEFAULT
C           (I*4) IGOT         = 1 --- DEFNOW = DEFOLD
C                              = 2 --- DEFNOW = DEFNEW
C                              = 3 --- DEFNOW = DEFBUP
C
C NOTES   : IF DEFOLD >= 0.0 THEN SET DEFNOW = DEFOLD
C           IF DEFOLD <  0.0  THEN ....
C                        IF DEFNEW >= 0.0  THEN SET DEFNOW = DEFNEW
C                   ELSE IF DEFNEW <  0.0  THEN SET DEFNOW = DEFBUP
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 06/02/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      REAL*8     DEFOLD , DEFNEW , DEFBUP
C
C..OUTPUT
      INTEGER*4  IGOT
      REAL*8     DEFNOW
C
C-----------------------------------------------------------------------
C
      IF( DEFOLD.GE.0.0D+00 ) THEN
          DEFNOW = DEFOLD
          IGOT   = 1
      ELSE IF( DEFNEW.GE.0.00D+00 ) THEN
          DEFNOW = DEFNEW
          IGOT   = 2
      ELSE
          DEFNOW = DEFBUP
          IGOT   = 3
      END IF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DEFCIR( MVESC
     &                 , XGAUGE , YGAUGE , RGAUGE , LGAUGE )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : DEFAULTS FOR PUMP 'CIR' GAUGE STRUCTURES
C           ---          - --
C VERSION : V1.R2.M0
C
C PURPOSE : TO OVERRIDE THE GAUGE PARAMETERS READ FROM THE PUMP FILE
C           IF GAUGE VALUES ARE LESS THAN 1.0D+30
C
C INPUT   : (I*4) MVESC        = MAX. NO. OF GAUGE VALUES
C           (R*8) XGAUGE()     = R-COORD OF GAUGE WITH LABEL LGAUGE()
C           (R*8) YGAUGE()     = Z-COORD OF GAUGE WITH LABEL LGAUGE()
C           (R*8) RGAUGE()     = RADIUS  OF GAUGE WITH LABEL LGAUGE()
C           (R*8) LGAUGE()     = GAUGE LABEL
C
C /CPUMP/ : (SEE 'cpump')
C
C METHOD  : 1) FIND 'CIR' STRUCTURES I.E NVPUMP()=-1
C           2) THEN FIND THOSE WHICH ARE DENOTED BY A PUMP REGION
C           3) COMPARE LABEL OF 2) WITH LGAUGE()
C           4) UPDATE VALUE IF XGAUGE,ETC<1.0D+30
C
C NOTE    : CONTINUE TO TEST ALL LGAUGE() LABELS WITH EACH ONE
C           SUPERCEEDING THE PREVIOUS (AS LONG AS <1.0D+3))
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 28/02/96 --- CREATION
C           V1.R2.M0 --- 03/04/96 --- IGAUGE() ARRAY
C           V1.R3.M0 --- 17/04/96 --- IGAUGE() INTO /CPUMP/
C
C- .....................................................................
C
C..INPUT
      INTEGER*4   MVESC
      REAL*8      XGAUGE(MVESC) , YGAUGE(MVESC) , RGAUGE(MVESC)
      CHARACTER*1 LGAUGE(MVESC)
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..PROGRAM
      INTEGER*4  I , J , L
C
C-----------------------------------------------------------------------
C
      CALL RESETI( IGAUGE(1)    , 10            , 0        )
C
      DO 100 L             = 1 , MVESC
         CALL CHRLTU(LGAUGE(L),LGAUGE(L))
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      DO 200 I             = 1 , NPUMP
         IF( NVPUMP(I).EQ.-1 ) THEN
             DO 220 J      = 1 , NRPUMP
                IF( LAPUMP(I).EQ.LRPUMP(J)(14:17) ) THEN
                  DO 240 L = 1 , MVESC
                    IF( LGAUGE(L).EQ.LRPUMP(J)(1:1) ) THEN
                       IF( XGAUGE(L).LT.1.0D+30 ) RPUMP(I,1) = XGAUGE(L)
                       IF( YGAUGE(L).LT.1.0D+30 ) ZPUMP(I,1) = YGAUGE(L)
                       IF( RGAUGE(L).LT.1.0D+30 ) RPUMP(I,2) = RGAUGE(L)
                       IF( LGAUGE(L).EQ.'G' ) THEN
                           IGAUGE(1) = I
                       ELSE IF( LGAUGE(L).EQ.'K' ) THEN
                           IGAUGE(2) = I
                       END IF
                    END IF
  240             CONTINUE
                END IF
  220        CONTINUE
         END IF
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE PMPCIR( MCIR , NCIR , XCIR )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : PUMP 'CIR' STRUCTURES
C           - --  ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO STORE THE PUMP 'CIR' STRUCTURES
C
C INPUT   : (I*4) MCIR         = MAX. NO. OF PUMP 'CIR' STRUCTURES
C
C OUTPUT  : (I*4) NCIR         = NO. OF PUMP 'CIR' STRUCTURES
C           (R*4) XCIR(,1)     = X-COORDINATE OF CIRCLE CENTRE
C                     (,2)     = Y-COORDINATE OF CIRCLE CENTRE
C                     (,3)     = RADIUS OF CIRCLE
C
C /CPUMP/ : (SEE 'cpump')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 26/02/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MCIR
C
C..OUTPUT
      INTEGER*4  NCIR
      REAL*4     XCIR(MCIR,3)
C
C../CPUMP/
      INCLUDE 'cpump'
C
C..PROGRAM
      INTEGER*4  I
C
C-----------------------------------------------------------------------
C
      NCIR = 0
C
C-----------------------------------------------------------------------
C
      DO 100 I          = 1 , MPUMP
         IF( NVPUMP(I).EQ.-1 .AND. RPUMP(I,2).GT.0.0D+00 ) THEN
             NCIR       = NCIR + 1
             IF( NCIR.LE.MCIR ) THEN
                 XCIR(NCIR,1) = RPUMP(I,1)
                 XCIR(NCIR,2) = ZPUMP(I,1)
                 XCIR(NCIR,3) = RPUMP(I,2)
             END IF
         END IF
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CHKCIR(X1,Y1,X2,Y2,X0,Y0,R,ICHK)
C
C     GIVEN THE SEGMENT (X1,Y1)--(X2,Y2)
C     AND THE CIRCLE CENTED IN (X0,Y0) AND RADIUS R,
C     DETERMINE IF THE SEGMENT IS (PARTIALLY) INTERNAL
C     TO THE CIRCLE  (ICHK=1)
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
      ICHK = 0
C
      WX = X2-X1
      WY = Y2-Y1
      AX = X1-X0
      AY = Y1-Y0
      A  = WX**2 + WY**2
      B  = AX*WX+AY*WY
      C  = AX**2 + AY**2 -R**2
      D  = B**2-A*C
      IF(D.LT.0.0) GOTO 100
      D  = DSQRT(D)
      T1 = (-B - D)/A
      T2 = (-B + D)/A
      IF(     T1.GE.0D0 .AND. T1.LE.1.0D0
     &   .OR. T2.GE.0D0 .AND. T2.LE.1.0D0
     &   .OR. T1.LE.0D0 .AND. T2.GE.1.0D0
     &  )     ICHK = 1
C
  100 RETURN
      END
C
C=======================================================================
      SUBROUTINE POLCIR( MPOLY , RCENT , ZCENT  , RADIUS , ICHK )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : POLYGON WITH A CIRCLE
C           ---             ---
C VERSION : V1.R2.M0
C
C PURPOSE : TO DETERMINE IF POLYGON # MPOLY CUTS OR CONTAINS THE
C           SPECIFIED CIRCLE.
C
C INPUT   : (I*4) MPOLY        = NIMBUS POLYGON INDEX
C           (R*8) RCENT        = R-COORDINATE OF CIRCLE CENTRE
C           (R*8) ZCENT        = Z-COORDINATE OF CIRCLE CENTRE
C           (R*8) RADIUS       = RADIUS       OF CIRCLE CENTRE
C
C OUTPUT  : (I*4) ICHK         = 1 --- POLYGON WITH CIRCLE
C
C ROUTINE :       GCHECK       = NIMBUS ROUTINE TO CHECK IF A POINT
C                                IS INTERNAL TO A POLYGON
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 03/04/96 --- CREATION
C           V1.R2.M0 --- 18/04/96 --- 'GCHECK' CALL TO TEST IF A CIRCLE
C                                     IS CONTAINED ENTIRELY WITHIN A
C                                     POLYGON.
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MPOLY
      REAL*8     RCENT , ZCENT  , RADIUS
C
C..OUTPUT
      INTEGER*4  ICHK
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C..PROGRAM
      INTEGER*4  M , N   , NVERT , ITYPE
      REAL*4     R4(MRG) , Z4(MRG)
      REAL*8     R8(2)   , Z8(2)
C
C---------------------------- INITIALISATION ---------------------------
C
      IF( NVERTM(MPOLY).GE.0 ) THEN
          ITYPE = 0
          NVERT = NVERTM(MPOLY)
      ELSE
          ITYPE = IABS(NVERTM(MPOLY))
          NVERT = NVERTG( ITYPE )
      END IF
C
C--------------- DOES THE CIRCLE CROSS POLYGON BOUNDARY ? --------------
C
      DO 100 N = 1 , NVERT
C
         IF( ITYPE.EQ.0 ) THEN
             R8(1)     = RVERTM(MPOLY,N)
             Z8(1)     = ZVERTM(MPOLY,N)
             IF( N.LT.NVERT ) THEN
                 R8(2) = RVERTM(MPOLY,N+1)
                 Z8(2) = ZVERTM(MPOLY,N+1)
             ELSE
                 R8(2) = RVERTM(MPOLY,1)
                 Z8(2) = ZVERTM(MPOLY,1)
             END IF
         ELSE
             R8(1)     = RVERTG(ITYPE,N)
             Z8(1)     = ZVERTG(ITYPE,N)
             IF( N.LT.NVERT ) THEN
                 R8(2) = RVERTG(ITYPE,N+1)
                 Z8(2) = ZVERTG(ITYPE,N+1)
             ELSE
                 R8(2) = RVERTG(ITYPE,1)
                 Z8(2) = ZVERTG(ITYPE,1)
             END IF
         END IF
C
         CALL CHKCIR( R8(1) , Z8(1) , R8(2)  , Z8(2)
     &              , RCENT , ZCENT , RADIUS
     &              , ICHK  )
C
         IF( ICHK.EQ.1 ) GOTO 9999
C
  100 CONTINUE
C
C--------------- IS THE CIRCLE CONTAINED WITHIN A POLYGON ? ------------
C
      DO 200 N     = 1 , NVERT
         IF( ITYPE.EQ.0 ) THEN
             R4(N) = RVERTM(MPOLY,N)
             Z4(N) = ZVERTM(MPOLY,N)
         ELSE
             R4(N) = RVERTG(ITYPE,N)
             Z4(N) = ZVERTG(ITYPE,N)
         END IF
  200 CONTINUE
C
      R8(1) = RCENT
      R8(2) = ZCENT
C
      CALL GCHECK( NVERT , R4(1) , Z4(1) , R8(1) , ICHK )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SETLRS( LOUT , MCLRS , LLRS , XLRS , YLRS )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : SET LRS
C           --- ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO OVERRIDE LRS WITH USER GIVEN SETTINGS, IF LABELS MATCH
C           AND SETTINGS ARE LESS THAN 1.0D+30
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MCLRS        = MAX. NO. OF LRS OVERRIDE SETTINGS
C           (C**) LLRS()       = LRS LABEL (I.E LALRS) LABEL TO OVERRIDE
C           (R*8) XLRS(,)      = R-COORDINATE OF LRS SEGMENT
C           (R*8) YLRS(,)      = Z-COORDINATE OF LRS SEGMENT
C
C /CPUMP/ : (SEE 'cpump')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 03/04/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT          , MCLRS
      REAL*8        XLRS(MCLRS,2) , YLRS(MCLRS,2)
      CHARACTER*(*) LLRS(MCLRS)
C
C../CPUMP/
      INCLUDE 'cpump'
C
C..PROGRAM
      INTEGER*4     I , J
      CHARACTER     RESULT*15
C
C---------------------------- INITIALISATION ---------------------------
C
      IF( LOUT.GT.0 .AND. NLRS.GT.0 ) WRITE(LOUT,1000)
C
      DO 100 I = 1 , NLRS
         RESULT = 'BY PUMP FILE'
         DO 150 J = 1 , MCLRS
            IF( LALRS(I).NE.'    ' .AND. LALRS(I).EQ.LLRS(J) ) THEN
                IF( XLRS(J,1).LT.1.0D+30 ) RLRS(I,1) = XLRS(J,1)
                IF( XLRS(J,2).LT.1.0D+30 ) RLRS(I,2) = XLRS(J,2)
                IF( YLRS(J,1).LT.1.0D+30 ) ZLRS(I,1) = YLRS(J,1)
                IF( YLRS(J,2).LT.1.0D+30 ) ZLRS(I,2) = YLRS(J,2)
                RESULT = 'BY /NIMBIN/'
                GOTO 10
            END IF
  150    CONTINUE
   10    IF( LOUT.GT.0 )
     &       WRITE(LOUT,1010) LALRS(I) , RLRS(I,1) , ZLRS(I,1)
     &                                 , RLRS(I,2) , ZLRS(I,2)
     &                                 , RESULT
  100 CONTINUE
C
      IF( LOUT.GT.0 .AND. NLRS.GT.0 ) WRITE(LOUT,1020)
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(/ 1X , 110('-') )
 1010 FORMAT( ' LEAK RECYCLING SEGMENT ' , A
     &      , ' IS SET TO (' , 1P , E12.4 , ',' , E12.4
     &      , ') & (' , E12.4 , ',' , E12.4 , ')', 2X , A )
 1020 FORMAT(  1X , 110('-') / )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE SETGAP( LOUT   , MCGAP
     &                 , LGAP   , XGAP   , YGAP , PGAP
     &                 , RMARKG , ZMARKG )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : SET GAP
C           --- ---
C VERSION : V1.R3.M0
C
C PURPOSE : TO OVERRIDE GAP WITH USER GIVEN SETTINGS, IF LABELS MATCH
C           AND SETTINGS ARE LESS THAN 1.0D+30
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MCGAP        = MAX. NO. OF GAP OVERRIDE SETTINGS
C           (C**) LGAP()       = GAP LABEL (I.E. LAWGAP) TO OVERRIDE
C           (R*8) XGAP(,)      = R-COORDINATE OF GAP SEGMENT
C           (R*8) YGAP(,)      = Z-COORDINATE OF GAP SEGMENT
C           (R*8) PGAP(,1)     = PLASMA SIDE TRANSPARANCY OF GAP
C                 PGAP(,2)     = PUMP   SIDE TRANSPARANCY OF GAP
C           (R*8) RMARKG(1)    = R-COORD OF MAX. VERTEX ON OUTER TARGET
C                       (2)    = R-COORD OF MAX. VERTEX ON INNER TARGET
C           (R*8) ZMARKG(1)    = Z-COORD OF MAX. VERTEX ON OUTER TARGET
C                       (2)    = Z-COORD OF MAX. VERTEX ON INNER TARGET
C
C NOTES   : IF YGAP(,1) = -1.0D+30 THEN AUTO-CALCULATION OF Z-VALUES
C           IS PERFORMED.
C
C /CPUMP/ : (SEE 'cpump')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 03/04/96 --- CREATION
C           V1.R2.M0 --- 23/05/96 --- AUTO-CALCULATION FOR Z-VALUES
C                                 --- ZMARKG() INTO ARGUMENT LIST
C           V1.R3.M0 --- 07/11/97 --- RMARKG() INTO ARGUMENT LIST
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT          , MCGAP
      REAL*8        XGAP(MCGAP,2) , YGAP(MCGAP,2) , PGAP(MCGAP,2)
     &        ,     RMARKG(2)     , ZMARKG(2)
      CHARACTER*(*) LGAP(MCGAP)
C
C../CPUMP/
      INCLUDE 'cpump'
C
C..PROGRAM
      INTEGER*4     I , J , IOUT , IINN
      REAL*8        RMIN , RMAX , RMID , ZLEN
      CHARACTER     RESULT(MWGAP)*25
C
C---------------------------- INITIALISATION ---------------------------
C
      IF( LOUT.GT.0 .AND. NWGAP.GT.0 ) WRITE(LOUT,1000)
C
C----------------------------- OVER-RIDE ? -----------------------------
C
      DO I = 1 , NWGAP
         RESULT(I) = 'BY PUMP FILE'
         DO J = 1 , MCGAP
            IF( LAWGAP(I).NE.'    ' .AND. LAWGAP(I).EQ.LGAP(J) ) THEN
                IF( XGAP(J,1).LT.1.0D+30 ) RWGAP(I,1) = XGAP(J,1)
                IF( XGAP(J,2).LT.1.0D+30 ) RWGAP(I,2) = XGAP(J,2)
                IF( YGAP(J,1).LT.1.0D+30 ) ZWGAP(I,1) = YGAP(J,1)
                IF( YGAP(J,2).LT.1.0D+30 ) ZWGAP(I,2) = YGAP(J,2)
                IF( PGAP(J,1).LT.1.0D+30 ) PWGAP(I,1) = PGAP(J,1)
                IF( PGAP(J,2).LT.1.0D+30 ) PWGAP(I,2) = PGAP(J,2)
                RESULT(I) = 'BY /NIMBIN/'
                GOTO 100
            END IF
         ENDDO
  100 ENDDO
C
C------------------------ FIND OUTER AND INNER GAPS --------------------
C
      RMIN = 1.0D+30
      RMAX = -1.0D+30
C
      DO I = 1 , NWGAP
         RMID = 0.5D+00 * ( RWGAP(I,1) + RWGAP(I,2) )
         IF( RMID.GE.RMAX ) THEN
             RMAX = RMID
             IOUT = I
         END IF
         IF( RMID.LE.RMIN ) THEN
             RMIN = RMID
             IINN = I
         END IF
      ENDDO
C
C-------------------- AUTO-CALCULATION OF Z-VALUES ? -------------------
C (SHIFT ZWGAP(I,1) BY 1% OF ZLEN TO MAKE SURE IT'LL CUT IT'S POLYGON)
C
      DO I = 1 , NWGAP
         IF( ZWGAP(I,1).LE.-1.0D+30 ) THEN
             ZLEN = ZWGAP(I,2)
             IF( I.EQ.IOUT ) THEN
                 ZWGAP(I,1) = ZMARKG(1)
             ELSE IF( I.EQ.IINN ) THEN
                 ZWGAP(I,1) = ZMARKG(2)
             ELSE
                 WRITE(LOUT,9000) I , LAWGAP(I)
                 CALL EXITX(LOUT)
             END IF
             ZWGAP(I,1) = ZWGAP(I,1) + ZLEN*1.0D-02
             ZWGAP(I,2) = ZWGAP(I,1) - ZLEN
             RESULT(I)  = RESULT(I)(1:15)//' +++ AUTO'
          END IF
      ENDDO
C
C--------------------------- OUTPUT RESULTS ----------------------------
C
      IF( LOUT.GT.0 ) THEN
          DO I = 1 , NWGAP
             IF( I.GT.1 ) WRITE(LOUT,*) ' '
             WRITE(LOUT,1010) LAWGAP(I)  , RWGAP(I,1) , ZWGAP(I,1)
     &                                   , RWGAP(I,2) , ZWGAP(I,2)
             WRITE(LOUT,1015) PWGAP(I,1)*1.0D+02 , PWGAP(I,2)*1.0D+02
     &                      , RESULT(I)
          ENDDO
          WRITE(LOUT,*) ' '
          WRITE(LOUT,1030) RMARKG(1) , ZMARKG(1)
     &                   , RMARKG(2) , ZMARKG(2)
      ENDIF
C
C---------------------------- FINIALISATION ----------------------------
C
      IF( LOUT.GT.0 .AND. NWGAP.GT.0 ) WRITE(LOUT,1020)
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(/ 1X , 126('-') )
 1010 FORMAT( ' GAP ' , A
     &      , ' : SET TO (' , F8.2 , ',' , F8.2
     &      , ') & (' , F8.2 , ',' , F8.2 , ')' )
 1015 FORMAT( 12X , 'WITH PSEMP(PLASMA SIDE) =', F6.2
     &      , '% & PSEMP(PUMP SIDE) =', F6.2 , '%' , 2X , A )
 1020 FORMAT(  1X , 126('-') / )
 1030 FORMAT( ' MAXIMUMS : '
     &      , 'OUTER WALL = ' , '(' , F8.2 , ',' , F8.2 , ')'
     &      / 12X
     &      , 'INNER WALL = ' , '(' , F8.2 , ',' , F8.2 , ')' )
C
 9000 FORMAT( / ' *** ERROR *** SETGAP : GAP NOT OUTER OR INNER.'
     &        , ' I = ' , I5 , ' LABEL = ' , A )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MARKPG
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MARK VALUES OF POLYGON POINTS
C           ----           -   -
C VERSION : V1.R1.M0
C
C PURPOSE : TO FIND THE MAXIMUM POINTS ON (RPOLY,ZPOLY) ON THE OUTER
C           AND INNER TARGETS.
C
C INPUT   : SEE /CPOLY/
C
C I/O     :
C
C OUTPUT  : SEE /CPOLYG/
C
C /CPOLYG/: (SEE 'c09')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 20/05/96 --- CREATION
C
C- .....................................................................
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C..PROGRAM
      INTEGER*4 I , J , L
C
C--------------------------------- INITIALISE --------------------------
C
      CALL RESETI( MARKG(1,1) , MDIM1G*MDIM2G , 0        )
      CALL RESETR( RMARKG(1)  , MDIM1G        , -1.0D-30 )
      CALL RESETR( ZMARKG(1)  , MDIM2G        , -1.0D-30 )
C
C------------------------------ TARGET MAXIMUMS ------------------------
C (NB. J=1 --- INNER TARGET ; J=NJPOLY(I) --- OUTER TARGET)
C
      DO I = LCFSPG+1 , NCPG
         DO L = 1 , 2
            IF( L.EQ.1 ) THEN
                J = NJPOLY(I)
            ELSE
                J = 1
            END IF
            IF( ZPOLY(I,J).GT.ZMARKG(L) ) THEN
                ZMARKG(L)  = ZPOLY(I,J)
                RMARKG(L)  = RPOLY(I,J)
                MARKG(L,1) = I
                MARKG(L,2) = J
            END IF
         ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      FUNCTION IBNDCK( LOUT , XPNT , YPNT , NBND , XBND , YBND )
      IMPLICIT NONE
      INTEGER*4 IBNDCK
C
C+ .....................................................................
C
C ROUTINE : BOUNDARY INTEGRITY CHECK
C           -  --              -   -
C VERSION : V1.R1.M0
C
C PURPOSE : TO TEST IF POINT (X,Y) IS INTERNAL, ON OR EXTERNAL TO
C           CLOSED POLYGON BOUNDARY RP(),ZP().
C
C INPUT   : (I*4) LOUT         = MESSAGE CHANNEL
C           (R*8) XPNT         = X-COORDINATE OF POINT
C           (R*8) YPNT         = Y-COORDINATE OF POINT
C           (I*4) NBND         = NO. OF VERTICES FORMING BOUNDARY
C           (R*8) XBND()       = X-COORDINATES OF BOUNDARY VERTICES
C           (R*8) YBND()       = Y-COORDINATES OF BOUNDARY VERTICES
C
C I/O     :
C
C OUTPUT  : (I*4) IBNDCK       = -9 --- NOT A CLOSED BOUNDARY
C                              = -1 --- POINT EXTERNAL TO BOUNDARY
C                              =  0 --- POINT ON          BOUNDARY
C                              = +1 --- POINT INTERNAL TO BOUNDARY
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 28/05/97 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  LOUT , NBND
      REAL*8     XPNT , YPNT , XBND(NBND) , YBND(NBND)
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      REAL*8     EPS
      PARAMETER ( EPS = 3.0D-05 )
      INTEGER*4  I
      REAL*8     RESULT
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( XBND(1).NE.XBND(NBND) .AND. YBND(1).NE.YBND(NBND) ) THEN
          IBNDCK = -9
          GOTO 9999
      END IF
C
C--------------------------- SET-UP BOUNDARY ---------------------------
C
      CALL GA15AD( NBND      , 1
     &           , WORKSP(1) , IWORK         , LNDSP(1,1), LND
     &           , XBND(1)   , YBND(1)
     &           , TDUM(1)   , XDUM(1)       , YDUM(1)   , LOUT )
C
C------------------------------ CHECK POINT ----------------------------
C
      CALL GA15BD( XPNT      , YPNT          , RESULT
     &           , NBND      , 1
     &           , WORKSP(1) , IWORK         , LNDSP(1,1), LND
     &           , XBND(1)   , YBND(1)
     &           , TDUM(1)   , XDUM(1)       , YDUM(1)   , LOUT )
C
C-------------------------------- RESULTS ------------------------------
      IF( RESULT.GE.EPS ) THEN
C.. INTERNAL
          IBNDCK = +1
      ELSE IF( RESULT.LT.-EPS ) THEN
C.. EXTERNAL
          IBNDCK = -1
      ELSE
C.. ON
          IBNDCK = 0
      END IF
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE CPARR( MDIM1  , MDIM2 , IVALUE , NDIM2 , VEC2D
     &                , LCLOSE , MVEC
     &                , VEC1D  , IER   )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : COPY ARRAY
C           - -  ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO COPY A  2-D MATRIX INTO A 1-D VECTOR.
C
C INPUT   : (I*4) MDIM1        = LEADING  DIMENSION OF 2-D MATRIX
C           (I*4) MDIM2        = TRAILING DIMENSION OF 2-D MATRIX
C           (I*4) IVALUE       = FIRST DIMENSION ELEMENT TO COPY
C           (I*4) NDIM2        = NO. OF VALUES IN 2ND DIMENSION TO COPY
C           (R*8) VEC2D(,)     = 2-D MATRIX
C           (LOG) LCLOSE       = .T. --- SET LAST VALUE TO FIRST
C           (I*4) MVEC         = DIMENSION OF 1-D VECTOR
C
C I/O     :
C
C OUTPUT  : (R*8) VEC1D()      = 1-D VECTOR
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- IVALUE .GT. MDIM1
C                              = 2 --- NDIM2  .GT. MDIM2
C                              = 3 --- NDIM2  .GT. MVEC
C                              = 4 --- NDIM2+1.GT. MVEC & LCLOSE
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 28/05/97 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  MDIM1 , MDIM2 , IVALUE , NDIM2 , MVEC
      REAL*8     VEC2D(MDIM1,MDIM2)
      LOGICAL    LCLOSE
C
C..OUTPUT
      INTEGER*4  IER
      REAL*8     VEC1D(MVEC)
C
C..PROGRAM
      INTEGER*4  I
C
C---------------------------- CHECK INPUT ------------------------------
C
      IF( IVALUE.GT.MDIM1 ) THEN
          IER = 1
      ELSE IF( NDIM2.GT.MDIM2 ) THEN
          IER = 2
      ELSE IF( NDIM2.GT.MVEC  ) THEN
          IER = 3
      ELSE IF( LCLOSE .AND. NDIM2+1.GT.MVEC  ) THEN
          IER = 4
      ELSE
          IER = 0
      END IF
C
C----------------------------- COPY ARRAYS -----------------------------
C
      DO I = 1 , NDIM2
         VEC1D(I) = VEC2D(IVALUE,I )
      ENDDO
C
C--------------------------- CLOSE THE VECTOR --------------------------
C
      IF( LCLOSE ) VEC1D(NDIM2+1) = VEC1D(1)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      FUNCTION IMGAP( M , MDIM1 , MDIM2 , IWGAP , IMWGAP )
      IMPLICIT NONE
      INTEGER*4 IMGAP
C
C+ .....................................................................
C
C ROUTINE : NIMBUS GAP POLYGON
C             -    ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO TEST IF NIMBUS POLYGON # M CONTAINS A CREATED GAP
C           POLYGON.
C
C INPUT   : (I*4) M            = NIMBUS POLYGON UNDER TEST
C           (I*4) MDIM1        = LEADING  DIMENSION OF IWGAP() & IMWGAP
C           (I*4) MDIM2        = TRAILING DIMENSION OF IWGAP() & IMWGAP
C           (I*4) IWGAP(I,J)   = NIMBUS POLYGON CONTAINING VERTEX # J
C                                OF GAP LINE # I
C           (I*4) IMWGAP(I,J)  = GAP POLYGON CREATED BY VERTEX # J
C                                OF GAP LINE # I
C
C I/O     :
C
C OUTPUT  : (I*4) IMGAP        = 0 --- NO ASSOCIATION
C                              > 0 --- GAP POLYGON INDEX
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 02/06/97 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  M , MDIM1 , MDIM2
      INTEGER*4  IWGAP(MDIM1,MDIM2) , IMWGAP(MDIM1,MDIM2)
C
C..PROGRAM
      INTEGER*4  I , IV
C
C------------------------------ INITIALISE -----------------------------
C
      IMGAP = 0
C
C-------------------------------- PROCESS ------------------------------
C
      DO I = 1 , MDIM1
         DO IV = 1 , MDIM2
            IF( M.EQ.IWGAP(I,IV) .AND. IWGAP(I,IV).GT.0 ) THEN
                IMGAP = IMWGAP(I,IV)
                GOTO 9999
            END IF
         ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE INTLINJ( M    , R1   , Z1     , R2      , Z2
     O                  , RCUT , ZCUT , IVCUT1 , IVCUT2  , NROOT )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : INTERSECTION WITH LINE (NON-JETTO)
C           ---               ---
C VERSION : V2.R1.M1
C
C PURPOSE : FINDS THE FIRST TWO BORDERING VERTICES OF POLY # M, THE
C           LINE JOINING POINTS (R1,Z1) TO (R2,Z2), CUTS (IF ANY)
C
C INPUT   : (I*4) M            = INDEX OF POLYGON UNDER INVESTIGATION
C           (R*8) R1           = R-COORD OF 1ST LINE POINT
C           (R*8) Z1           = Z-COORD OF 1ST LINE POINT
C           (R*8) R2           = R-COORD OF 2ND LINE POINT
C           (R*8) Z2           = Z-COORD OF 2ND LINE POINT
C
C OUTPUT  : (R*8) RCUT         = R-COORD OF 1ST INTERSECTION
C         : (R*8) ZCUT         = Z-COORD OF 1ST INTERSECTION
C           (I*4) IVCUT1       = 1ST BORDERING CUT VERTEX OF POLYGON
C           (I*4) IVCUT2       = 2ND BORDERING CUT VERTEX OF POLYGON
C           (I*4) NROOT        = NO. OF CUTS OF LINE WITH POLYGON
C
C /CPOLYG/: (SEE 'c09')
C
C /WSPACE/:  WORKSPACE         = WORKING SPACE
C
C ROUTINES:       ROOT()       = FIND INTERSECTION OF LINE WITH POLYGON
C
C PROGRAM : (I*4) I            = GENERAL INTEGER
C           (I*4) J            = GENERAL INTEGER
C           (I*4) M            = POLYGON INDEX
C           (I*4) NROOT        = NO. OF INTERSECTIONS
C
C (C)     : JET JOINT UNDERTAKING, 1997
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C
C HISTORY : V1.R1.M0 --- 04/06/97 --- CREATION
C           V2.R1.M0 --- 27/10/97 --- RE-ENGINEER TO REPLACE /CPUMP/
C                                     BY INPUT ARGUMENTS
C           V2.R1.M1 --- 23/07/98 --- RENAME FROM 'INTLIN' TO 'INTLINJ'
C                                     TO AVOID NAME CLASH WITH JETTO
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  M
      REAL*8     R1 , Z1 , R2 , Z2
C
C..OUTPUT
      INTEGER*4  IVCUT1 , IVCUT2 , NROOT
      REAL*8     RCUT   , ZCUT
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../WSPACE/
      INCLUDE  'wspace'
C
C..PROGRAM
      INTEGER*4  I
C
C----------------------------- INITIALISE ------------------------------
C
      IVCUT1 = 0
      IVCUT2 = 0
C
C---------------------------- CHECK INPUT ------------------------------
C
      IF( NVERTM(M).LE.0 ) GOTO 9999
C
C--------------- COPY POLYGON VERTICES INTO 1-D ARRAY ------------------
C
      DO I       = 1 , NVERTM(M)
         XDUM(I) = RVERTM(M,I)
         YDUM(I) = ZVERTM(M,I)
      ENDDO
C
C---------------------- CLOSE POLYGON 1-D ARRAY ------------------------
C
      XDUM(NVERTM(M)+1) = XDUM(1)
      YDUM(NVERTM(M)+1) = YDUM(1)
C
C--------------- COPY WALL GAP SEGMENTS INTO 1-D ARRAY -----------------
C
      BUFFER(1)     = R1
      BUFFER(2)     = R2
      BUFFER(3)     = Z1
      BUFFER(4)     = Z2
C
C------------------ FIND INTERSECTION OF POLYGON AND GAP ---------------
C
      CALL ROOT( NVERTM(M)+1 , XDUM(1)    , YDUM(1)
     &         , 2           , BUFFER(1)  , BUFFER(3)
     &         , 2           , TDUM(1)    , TDUM(11)
     &         , MZONE(1,1)  , MZONE(1,2) , NROOT     )
C
C----------------------- STORE BORDERING VERTICES ----------------------
C    (NB. NVERTM(M)+1 IS A CYCLIC POINT AND MUST BE RE-MAPPED TO '1' )
C
      IF( NROOT.EQ.1 ) THEN
          RCUT = TDUM(1)
          ZCUT = TDUM(11)
          IVCUT1 = MZONE(1,1)
          IF( IVCUT1.EQ.NVERTM(M)+1 ) IVCUT1 = 1
          IVCUT2 = IVCUT1 + 1
          IF( IVCUT2.EQ.NVERTM(M)+1 ) IVCUT2 = 1
      END IF
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE BUFTMP( LOUT , IBUFX )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : BUFFLE TEMPORARY
C           ---    - --
C VERSION : V1.R1.M0
C
C PURPOSE : COPY,
C                RBUFX(IBUFX,) --> RBUFLX()
C                ZBUFX(IBUFX,) --> ZBUFLX()
C
C INPUT   : (I*4) LOUT      = OUTPUT CHANNEL
C           (I*4) IBUFX     = EXTRA BAFFLE TO REDUCE
C
C OUTPUT  : SEE /CBAFFLE/
C
C /CPOLYG/: (SEE 'c09')
C
C AUTHOR  : JAMES SPENCE
C           JET K1/0/80
C           TEL   - +44 (0) 1235 464865  (EXT. 4865)
C           EMAIL - JSPENCE@JET.UK
C
C HISTORY : V1.R1.M0 --- 30-JUN-97 --- CREATION
C
C.......................................................................
C
C.. INPUT
      INTEGER*4 LOUT , IBUFX
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C.. PROGRAM
      INTEGER*4 IER
C
C----------------------------- CHECK INPUT -----------------------------
C
      IF( IBUFX.LE.0 ) THEN
          WRITE(LOUT,9000) IBUFX
          CALL EXITX(LOUT)
      END IF
C
      IF( IBUFX.GT.NBUFMX ) THEN
          WRITE(LOUT,9010) IBUFX , NBUFMX
          CALL EXITX(LOUT)
      END IF
C
      IF( NBUFX(IBUFX).LE.0 ) THEN
          WRITE(LOUT,9020) IBUFX
          CALL EXITX(LOUT)
      END IF
C
C------------------------------ R-COORDS -------------------------------
C
      CALL C2DT1D( MBUFX  , MBUFLE       , RBUFX(1,1)
     &           , IBUFX  , NBUFX(IBUFX)
     &           , MBUFLE , RBUFLX(1)    , IER        )
C
      IF( IER.NE.0 ) THEN
          WRITE(LOUT,9030) 'R' , IER
          CALL EXITX(LOUT)
      END IF
C
C------------------------------ R-COORDS -------------------------------
C
      CALL C2DT1D( MBUFX  , MBUFLE       , ZBUFX(1,1)
     &           , IBUFX  , NBUFX(IBUFX)
     &           , MBUFLE , ZBUFLX(1)    , IER        )
C
      IF( IER.NE.0 ) THEN
          WRITE(LOUT,9030) 'Z' , IER
          CALL EXITX(LOUT)
      END IF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT(  ' *** ERROR(BUFTMP) : IBUFX (',I2,') IS ILLEGAL' )
 9010 FORMAT(  ' *** ERROR(BUFTMP) : IBUFX (',I2,') .GT. NBUFMX ('
     &      , I2 , ')' )
 9020 FORMAT(  ' *** ERROR(BUFTMP) : IBUFX (',I2,') HAS ' , I2
     &      , 'COORDS' )
 9030 FORMAT(  ' *** ERROR(BUFTMP) : UNABLE TO REDUCE 2D '
     &      , A , '-MATRIX TO 1D.'
     &      / '               IER =' , I2 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE C2DT1D( M2D1 , M2D2 , X2D
     &                 , N2D1 , N2D2
     &                 , M1D  , X1D  , IER )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : CHANGE 2D TO 1D
C           -      -- -  --
C VERSION : V1.R1.M0
C
C PURPOSE : TO REDUCE 2D MATRIX 2ND ELEMENTS INTO A 1D VECTOR
C
C INPUT   : (I*4) M2D1     = 1ST DIMENSION OF 2-D MATRIX
C           (I*4) M2D2     = 2ND DIMENSION OF 2-D MATRIX
C           (R*8) X2D(,)   = 2-D MATRIX
C           (I*4) N2D1     = 1ST ELEMENT TO KEEP FIXED
C           (I*4) N2D2     = NO. OF 2ND ELEMENTS TO REDUCE
C           (I*4) M1D      = DIMENSION OF 1-D VECTOR
C
C OUTPUT  : (R*8) X1D()    = 1-D VECTOR
C           (I*4) IER      = 0 --- ROUTINE SUCCESSFUL
C                          = 1 --- N2D1 .GT. M2D1
C                          = 2 --- N2D2 .GT. M2D2
C                          = 3 --- N2D2 .GT. M1D
C
C AUTHOR  : JAMES SPENCE
C           JET K1/0/80
C           TEL   - +44 (0) 1235 464865  (EXT. 4865)
C           EMAIL - JSPENCE@JET.UK
C
C HISTORY : V1.R1.M0 --- 30-JUN-97 --- CREATION
C
C.......................................................................
C
C.. INPUT
      INTEGER*4 M2D1 , M2D2 , N2D1 , N2D2 , M1D
      REAL*8    X2D(M2D1,M2D2)
C
C.. OUTPUT
      INTEGER*4 IER
      REAL*8    X1D(M1D)
C
C.. PROGRAM
      INTEGER*4 I
C
C---------------------------- CHECK INPUT ------------------------------
C
      IF( N2D1.GT.M2D1 ) THEN
          IER = 1
      ELSE IF( N2D2.GT.M2D2 ) THEN
          IER = 2
      ELSE IF( N2D2.GT.M1D ) THEN
          IER = 3
      ELSE
          IER = 0
      END IF
C
      IF( IER.NE.0 ) GOTO 9999
C
C------------------------------ PROCESS --------------------------------
C
      DO 100 I = 1 , N2D2
         X1D(I) = X2D(N2D1,I)
  100 CONTINUE
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE POLCUT( NPOLY , NLINE , RLINE , ZLINE , NCUTS )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : POLYGON CUT
C           ---     ---
C VERSION : V1.R2.M0
C
C PURPOSE : TO DETERMINE IF NIMBUS POLYGON # M CUTS GIVEN LINE.
C
C INPUT   : (I*4) NPOLY    = NUMBUS POLYGON INDEX
C           (I*4) NLINE    = NO. OF POINTS FORMING LINE
C           (R*8) RLINE()  = R-COORDS OF LINE POINTS
C           (R*8) ZLINE()  = Z-COORDS OF LINE POINTS
C
C OUTPUT  : (I*4) NCUTS    = NUMBER OF CUTS
C
C /CPOLYG/: (SEE 'c09')
C
C /SWORK1/: WORK SPACE
C
C ROUTINE : (R*8) PYTHGS()     = LENGTH OF LINE
C
C AUTHOR  : JAMES SPENCE
C           JET K1/0/80
C           TEL   - +44 (0) 1235 464865  (EXT. 4865)
C           EMAIL - JSPENCE@JET.UK
C
C HISTORY : V1.R1.M0 --- 30/06/97 --- CREATION
C           V1.R2.M0 --- 05/05/98 --- REMOVE MCUTS FROM ARGUMENT LIST
C                                 --- EPS = 5.0E-03 -> 5.0E-02
C           V1.R2.M1 --- 11/05/98 --- EPS BACK TO 5.0E-03
C
C.......................................................................
C
C.. INPUT
      INTEGER*4 NPOLY , NLINE , MCUTS
      REAL*8    RLINE(NLINE)  , ZLINE(NLINE)
C
C.. OUTPUT
      INTEGER*4 NCUTS
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../SWORK1/
      INTEGER*4  NDIM
      PARAMETER( NDIM = 10 )
C
      COMMON/SWORK1/ R1 , Z1 , R2 , Z2 , R3 , Z3 , L1 , L2 , L3
C
      INTEGER*4 L1(NDIM) , L2(NDIM) , L3(NDIM)
      REAL*8    R1(NDIM) , Z1(NDIM) , R2(NDIM) , Z2(NDIM)
     &        , R3(NDIM) , Z3(NDIM)
C
C.. PROGRAM
      REAL*8    EPS
      PARAMETER( EPS = 5.0D-03 )
C
      INTEGER*4 I     , IV , MVERT , NROOT
      REAL*8    DIST  , PYTHGS
      LOGICAL   LSAME
C
C---------- REDUCE 2-D OPEN ARRAY TO A 1-D CLOSED VECTOR ---------------
C
C.. NO. OF VERTICES
      MVERT     = NVERTM(NPOLY)
C
C.. REDUCTION TO 1-D VECTOR
      DO IV     = 1 , MVERT
         R1(IV) = RVERTM(NPOLY,IV)
         Z1(IV) = ZVERTM(NPOLY,IV)
      ENDDO
C
C.. CLOSE 1-D VECTOR
      R1(MVERT+1) = R1(1)
      Z1(MVERT+1) = Z1(1)
C
C----------- FIND INTERSECTIONS OF VECTOR WITH INTERFACE LINE ----------
C
      CALL ROOT( MVERT+1 , R1(1)    , Z1(1)
     &         , NLINE   , RLINE(1) , ZLINE(1)
     &         , NDIM    , R2(1)    , Z2(1)
     &         , L2(1)   , L3(1)    , NROOT    )
C
C----------------- DROP ROOTS NEAR EQUAL TO VECTOR POINTS --------------
C
      L1(1)      = NROOT
C
      NCUTS      = 0
C
      DO I       = 1 , NROOT
         LSAME   = .FALSE.
         DO IV   = 1 , MVERT
            DIST = PYTHGS( R1(IV) , Z1(IV) , R2(I) , Z2(I) )
            IF( DIST.LE.EPS ) THEN
                LSAME = .TRUE.
                GOTO 10
            END IF
         ENDDO
   10    IF( .NOT.LSAME ) THEN
             NCUTS     = NCUTS + 1
             R3(NCUTS) = R2(I)
             Z3(NCUTS) = Z2(I)
         END IF
      ENDDO
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      FUNCTION LBREC( R , Z , RMIN , ZMIN , RMAX , ZMAX )
      IMPLICIT NONE
      LOGICAL LBREC
C
C+ .....................................................................
C
C ROUTINE : BOUNDRY OF RECTANGLE
C           -          ---
C VERSION : V1.R1.M0
C
C PURPOSE : TO TEST IF POINT (R,Z) IS INSIDE THE PRESCRIBE RECTANGLE.
C
C INPUT   : (R*8) R        = R-COORDINATE
C           (R*8) Z        = Z-COORDINATE
C           (R*8) RMIN     = R-COORDINATE OF MINIMUM VERTEX
C           (R*8) ZMIN     = Z-COORDINATE OF MINIMUM VERTEX
C           (R*8) RMAX     = R-COORDINATE OF MAXIMUM VERTEX
C           (R*8) ZMAX     = Z-COORDINATE OF MAXIMUM VERTEX
C
C OUTPUT  : (LOG) LBREC    = .T. --- POINT IS INSIDE RECTANGEL
C
C (C)     : JET JOINT UNDERTAKING (1997)
C
C AUTHOR  : JAMES SPENCE
C           JET K1/0/80
C           TEL   - +44 (0) 1235 464865  (EXT. 4865)
C           EMAIL - JSPENCE@JET.UK
C
C HISTORY : V1.R1.M0 --- 12/09/97 --- CREATION
C
C- .....................................................................
C
C.. INPUT
      REAL*8 R , Z , RMIN ,ZMIN , RMAX , ZMAX
C
C.. PROGRAM
      REAL*8  R1 , R2 , Z1 , Z2
C
C--------------------------- INITIALISATION ----------------------------
C
C.. TRUE MINIMUM/MAXIMUM R-VALUES
      IF( RMIN.LE.RMAX ) THEN
          R1 = RMIN
          R2 = RMAX
      ELSE
          R1 = RMAX
          R2 = RMIN
      END IF
C
C.. TRUE MINIMUM/MAXIMUM Z-VALUES
      IF( ZMIN.LE.ZMAX ) THEN
          Z1 = ZMIN
          Z2 = ZMAX
      ELSE
          Z1 = ZMAX
          Z2 = ZMIN
      END IF
C
C-----------------------------------------------------------------------
C
      IF( (R.GE.R1.AND.R.LE.R2 ) .AND. (Z.GE.Z1.AND.Z.LE.Z2 ) ) THEN
          LBREC = .TRUE.
      ELSE
          LBREC = .FALSE.
      END IF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      FUNCTION NEARX( IOUT , M , IV1 , IV2 , RPX , ZPX )
      IMPLICIT NONE
      INTEGER*4 NEARX
C
C+ .....................................................................
C
C ROUTINE : VERTEX NEAREST THE X-POINT
C                  ----        -
C VERSION : V1.R1.M0
C
C PURPOSE : TO FIND WHICH OF THE TWO VERTICES IS NEAREST TO THE
C           X-POINT (RPX,ZPX)
C
C INPUT   : (I*4) IOUT         = MESSAGE CHANNEL
C           (I*4) M            = INDEX OF POLYGON UNDER INVESTIGATION
C           (I*4) IV1          = 1ST VERTEX
C           (I*4) IV2          = 2ND VERTEX
C           (R*8) RPX          = R-COORD OF X-POINT
C           (R*8) ZPX          = Z-COORD OF X-POINT
C
C OUTPUT  : (I*4) NEARX        = IV1 OR IV2
C
C /CPOLYG/: (SEE 'c09')
C
C ROUTINES: (R*8) PYTHGS()     = DISTANCE BETWEEN TWO POINTS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 06/02/96 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  IOUT , M   , IV1 , IV2
      REAL*8     RPX  , ZPX
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C..ROUTINES
      REAL*8 PYTHGS
C
C..PROGRAM
      REAL*8 DIST1 , DIST2
C
C---------------------------- CHECK INPUT ------------------------------
C
C.. DOES POLYGON EXIST ?
      IF( NVERTM(M).LE.0 ) THEN
          WRITE(IOUT,9000) M
          CALL EXITX(IOUT)
      END IF
C
C.. ARE VERTEX INDICES VALID
      IF( IV1.LE.0 .OR. IV1.GT.NVERTM(M) ) THEN
          WRITE(IOUT,9010) M
          CALL EXITX(IOUT)
      END IF
C
      IF( IV2.LE.0 .OR. IV2.GT.NVERTM(M) ) THEN
          WRITE(IOUT,9010) M
          CALL EXITX(IOUT)
      END IF
C
C------------------ DISTANCE FROM VERTEX TO X-POINT --------------------
C
      DIST1 = PYTHGS( RVERTM(M,IV1) , ZVERTM(M,IV1) , RPX , ZPX )
      DIST2 = PYTHGS( RVERTM(M,IV2) , ZVERTM(M,IV2) , RPX , ZPX )
C
C---------------------- CLOSEST VERTEX TO X-POINT ----------------------
C
      IF( DIST1.LE.DIST2 ) THEN
          NEARX = IV1
      ELSE
          NEARX = IV2
      END IF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( ' *** ERROR (NEARX) : POLYGON ' , I6 , ' IS ILLEGAL' )
 9010 FORMAT( ' *** ERROR (NEARX) : ILLEGAL VERTEX INDEX FOR POLYGON '
     &      , I6 )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      FUNCTION LSTR(ASTR)
C
C**********************************************************************C
C                                                                      C
C        MODULE : LSTR                                                 C
C                                                                      C
C      FUNCTION : RETURNS THE EFFECTIVE LENGTH OF A GIVEN STRING       C
C                 (IGNORING TRAILING BLANKS)                           C
C                                                                      C
C----------------------------------------------------------------------C
C                                                                      C
C         INPUT :    ASTR  -  CHARACTER STRING                         C
C                                                                      C
C----------------------------------------------------------------------C
C                                                                      C
C        OUTPUT :  LSTR    -  EFFECTIVE LENGTH OF LSTR                 C
C                                                                      C
C----------------------------------------------------------------------C
C                                                                      C
C       COMMONS :                                                      C
C                                                                      C
C**********************************************************************C
C
      CHARACTER*(*) ASTR
C
C
      DO 10 I = LEN(ASTR),1,-1
        IF (ASTR(I:I) .NE. ' ') GO TO 20
   10 CONTINUE
C
   20 CONTINUE
      LSTR   = I
C
C
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MONTON( NVEC , VEC , RANGE1 , RANGE2 , IER )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MONOTONIC
C           --- ---
C VERSION : V1.R1.M0
C
C PURPOSE : CHECK VECTOR IS MONOTONICALLY INCREASING
C           AND IS IN THE EXCLUSIVE RANGE VMIN -> VMAX
C
C INPUT   : (I*4) NVEC         = NUMBER OF ELEMENTS IN VEC()
C           (R*8) VEC()        = VECTOR ARRAY
C           (R*8) RANGE1       = LOWER BOUNDARY OF RANGE
C           (R*8) RANGE2       = UPPER BOUNDARY OF RANGE
C
C OUTPUT  : (I*4) IER          = 0 --- SUCCESSFUL CHECK
C                              = 1 --- NOT MONOTONICALLY INCREASING
C                              = 2 --- AN ELEMENT IS OUT OF RANGE
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1997)
C
C HISTORY : V1.R1.M0 --- 25/11/97 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4  NVEC
      REAL*8     VEC(NVEC) , RANGE1 , RANGE2
C
C..OUTPUT
      INTEGER*4  IER
C
C..LOCALS
      INTEGER*4  I
      REAL*8     XMIN , XMAX
C
C------------------------------- INITIALISE ----------------------------
C
      IER = 0
C
C------------------------------- CHECK INPUT ---------------------------
C
      IF( RANGE1.LE.RANGE2 ) THEN
          XMIN = RANGE1
          XMAX = RANGE2
      ELSE
          XMIN = RANGE2
          XMAX = RANGE1
      END IF
C
C----------------------- CHECK MONOTONICALLY INCREASING ----------------
C
      DO I = 2 , NVEC
          IF( VEC(I).LE.VEC(I-1) ) THEN
              IER = 1
              GOTO 9999
          END IF
      ENDDO
C
C--------------------------- CHECK RANGE OF VALUES ---------------------
C
      DO I = 1 , NVEC
         IF( VEC(I).LE.XMIN .OR. VEC(I).GE.XMAX ) THEN
             IER = 2
             GOTO 9999
         END IF
      ENDDO
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE LENREG( LOUT
     I                 , MVES  , MWREG
     I                 , NVES  , RVES  , ZVES   , GVES
     I                 , GWREG
     O                 , AWREG )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : LENGTH OF WALL SEGMENT REGIONS
C           ---                    ---
C PURPOSE : TO RETURN THE LENGTHS OF WALL SEGMENT REGIONS
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MVES         = MAX. NO. OF VESSEL SEGMENTS
C           (I*4) MWREG        = MAX. NO. OF REGIONS
C           (I*4) NVES         = ACTUAL NO. OF VESSEL SEGMENTS
C           (R*4) RVES(,)      = R-COORD. SEGMENT PAIR OF NIMBUS VESSEL
C           (R*4) ZVES(,)      = Z-COORD. SEGMENT PAIR OF NIMBUS VESSEL
C           (C*2) GVES()       = GROUPING FOR EACH INDIVIDUAL SEGMENT
C                              = SEE GWREG()
C           (C*2) GWREG()      = WALL SEGMENT REGION LABEL, SAME AS GVES()
C
C OUTPUT  : (R*8) AWREG()      = LENGTH OF REGION #X
C
C ROUTINES: (R*8) PYTHGS()     = LENGTH OF A LINE
C
C NOTE    : 1) IT IS ASSUMED THAT SEGMENTS ARE ORDERED.
C           2) NON-COMPOUND BAFFLE SEGMENTS WILL BE EXCLUDED.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1997)
C
C HISTORY : V1.R1.M0 --- 10/03/98 --- CREATION (BASED ON OLD SUMREG)
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT
     &        ,     MVES , MWREG , NVES
      REAL*4        RVES(MVES,2) , ZVES(MVES,2)
      CHARACTER*(*) GVES(MVES) , GWREG(MWREG)
C
C..OUTPUT
      REAL*8        AWREG(MWREG)
C
C..ROUTINES
      REAL*8        PYTHGS
C
C..LOCALS
      INTEGER*4     I    , J    , IREG
      REAL*8        X(2) , Y(2) , XLEN
C
C------------------------------- INITIALISE ----------------------------
C
      CALL RESETR( AWREG(1)     , MWREG            , 0.0D+00 )
C
C-------------------------- LOOP OVER EACH SEGMENT ---------------------
C
C.. <BEGIN> LOOP OVER EACH VESSEL SEGMENT
      DO I = 1 , NVES
C
C.. FIND WHICH REGION SEGMENT BELONGS (EXCL. NON-COMPOUND BAFFLES)
         IREG = 0
C
         DO J = 1 , MWREG
            IF( GVES(I).EQ.GWREG(J) .AND. GVES(I).NE.GWREG(10) ) THEN
                IREG = J
                GOTO 10
            ENDIF
         ENDDO
C
   10    CONTINUE
C
C.. <BEGIN> PROCESS VALID SEGMENTS
         IF( IREG.GT.0 ) THEN
C
C.. LENGTH OF SEGMENT (MUST COVERT REAL*4 TO REAL*8)
             X(1) = RVES(I,1)
             Y(1) = ZVES(I,1)
             X(2) = RVES(I,2)
             Y(2) = ZVES(I,2)
             XLEN = PYTHGS( X(1) , Y(1) , X(2) , Y(2) )
C
C.. ADD UP LENGTHS FOR EACH REGION
             AWREG(IREG) = AWREG(IREG) + XLEN
C
C.. DIAGNOSTIC OUTPUT
CW           WRITE(LOUT,*) '  '
CW           WRITE(LOUT,*) ' REG,IVES    =' , GWREG(IREG) , I
CW           WRITE(LOUT,*) ' RSEG,ZSEG1  =' , RVES(I,1)   , ZVES(I,1)
CW           WRITE(LOUT,*) ' RSEG,ZSEG2  =' , RVES(I,2)   , ZVES(I,2)
CW           WRITE(LOUT,*) ' LEN,AWREG   =' , XLEN        , AWREG(IREG)
C
C.. <END> PROCESS VALID REGION
         ENDIF
C
C.. <END> LOOP OVER EACH VESSEL SEGMENT
      ENDDO
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE FLXREG( LOUT
     I                 , MVES  , MWREG , MFLX   , MIONH
     I                 , NVES  , GVES
     I                 , NIONH , FLUXD , MAPFLX , GWREG
     O                 , FWREG  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : FLUXES OF WALL SEGMENT REGIONS
C           -- -           ---
C PURPOSE : TO CALCULATE THE SUMMS OF FLUXES OVER EACH WALL SEGMENT
C           REGION
C
C INPUT   : (I*4) LOUT         = OUTPUT CHANNEL
C           (I*4) MVES         = MAX. NO. OF VESSEL SEGMENTS
C           (I*4) MWREG        = MAX. NO. OF REGIONS
C           (I*4) MFLX         = MAX. NO. OF FLUXES
C           (I*4) MIONH        = MAX. NO. OF HYDROGEN SPECIES
C           (I*4) NVES         = ACTUAL NO. OF VESSEL SEGMENTS
C           (I*4) NIONH        = NO. OF HYDROGEN SPECIES
C           (R*8) FLUXD(,)     = H-NEUTRAL IMPLANTATION FLUX TO WALL
C           (I*4) MAPFLX(I)    = MAPPING OF VESSEL SEGMENT TO FLUX WALL INDEX
C           (C*2) GVES()       = GROUPING FOR EACH INDIVIDUAL SEGMENT
C                              = SEE GWREG()
C           (C*2) GWREG()      = VESSEL SEGMENT REGION LABELS
C                      (1)     = OUTER TARGET
C                      (2)     = OUTER CORNER
C                      (3)     = OUTER DIVERTOR
C                      (4)     = MAIN SOL (OUTSIDE DIVERTOR REGION)
C                      (5)     = INNER DIVERTOR
C                      (6)     = INNER CORNER
C                      (7)     = INNER TARGET
C                      (8)     = PRIVATE VOID
C                      (9)     = COMPOUND BUFFLES
C                      (10)    = BAFFLES (NON-COMPOUND)
C
C OUTPUT  : (R*8) FWREG(,,)    = FLUX   OF REGION #X FOR EACH SPECIES
C
C NOTE    : 1) IT IS ASSUMED THAT SEGMENTS ARE ORDERED.
C           2) BAFFLE SEGMENTS ARE COMBINED INTO A COMPOUND BAFFLE WITH
C              SINGLE SEGMENT LENGTH EQUAL TO THE TOTAL LENGTH OF THE
C              ORIGINAL BAFFLE.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1997)
C
C HISTORY : V1.R1.M0 --- 10/03/98 --- CREATION (BASED ON OLD SUMREG)
C           V1.R1.M1 --- 19/08/98 --- BUG FIX : REMOVE RVES() & ZVES()
C                                     DECLARATION AS NEVER USED
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT
     &        ,     MVES , MWREG , MFLX , MIONH , NVES , NIONH
      INTEGER*4     MAPFLX(MVES)
      REAL*8        FLUXD(MVES,MIONH)
      CHARACTER*(*) GVES(MVES) , GWREG(MWREG)
C
C..OUTPUT
      REAL*8        FWREG(MWREG,MFLX,MIONH)
C
C..LOCALS
      INTEGER*4     I    , J    , IREG , IFLX , IHS
C
C------------------------------- INITIALISE ----------------------------
C
      CALL RESETR( FWREG(1,1,1) , MWREG*MFLX*MIONH , 0.0D+00 )
C
C-------------------------- LOOP OVER EACH SEGMENT ---------------------
C
C.. <BEGIN> LOOP OVER EACH VESSEL SEGMENT
      DO I = 1 , NVES
C
C.. FIND WHICH REGION SEGMENT BELONGS (EXCL. NON-COMPOUND BAFFLES)
         IREG = 0
C
         DO J = 1 , MWREG
            IF( GVES(I).EQ.GWREG(J) .AND. GVES(I).NE.GWREG(10) ) THEN
                IREG = J
                GOTO 10
            ENDIF
         ENDDO
C
   10    CONTINUE
C
C.. FLUX POINT MAPPED FROM VESSEL SEGMENT
         IFLX = MAPFLX(I)
C
C.. <BEGIN> PROCESS VALID SEGMENTS AND MAPPINGS
         IF( IREG.GT.0 .AND. IFLX.GT.0 ) THEN
C
C.. <BEGIN> LOOP OVER EACH HYDROGEN SPECIES
             DO IHS = 1 , NIONH
C
C.. ADD UP APPROPRIATE FLUXES
                FWREG(IREG,1,IHS) = FWREG(IREG,1,IHS) + FLUXD(IFLX,IHS)
C
C.. DIAGNOSTIC OUTPUT
CW              WRITE(LOUT,*) '  '
CW              WRITE(LOUT,*) ' REG,IVES   =' , GWREG(IREG) , I
CW              WRITE(LOUT,*) ' MAPFLX(I)  =' , MAPFLX(I)
CW              WRITE(LOUT,*) ' FLUXD,FWREG='
CW   &                      , FLUXD(IFLX,IHS)  , FWREG(IREG,1,IHS)
C
C.. <END> LOOP OVER EACH HYDROGEN SPECIES
             ENDDO
C
C.. <END> PROCESS VALID SEGMENTS
         ENDIF
C
C.. <END> LOOP OVER EACH VESSEL SEGMENT
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT(/' *** ERROR : (LINKPG/SUMREG) MWREG EXCEEDED, MWREG =',I4)
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CHKVEC( LOUT , NVEC , MVEC , VECNAM )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : CHECK VECTOR DIMENSIONS
C           --  - ---
C PURPOSE : OUTPUT AN ERROR MESSAGE IF POLYGON LIMIT WILL BE EXCEEDED.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NVEC        = CURRENT NUMBER OF ELEMENTS
C           MPG         = MAX. NUMBER OF ELEMENTS
C           VECNAM      = NAME OF VECTOR
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 17/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT , NVEC , MVEC
      CHARACTER*(*) VECNAM
C
C-----------------------------------------------------------------------
C
      IF( NVEC.GE.MVEC ) THEN
          WRITE(LOUT,9000) VECNAM , MVEC
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(LINKPG) : DIMENSIONS EXCEEDED !!!!'
     &        / '                     INCREASE ' , A , ' (', I7 , ')' )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CKPOLY( LOUT , NPOLY , MPG , POLTYP )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : CHECK POLYGON CREATION
C           -   - ----
C PURPOSE : OUTPUT AN ERROR MESSAGE IF POLYGON LIMIT WILL BE EXCEEDED.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = CURRENT NUMBER OF POLYGONS CREATED
C           MPG         = MAX. NUMBER OF POLYGONS ALLOWED
C           POLTYP      = POLYGON TYPE (E.G. TARGET, CORNER, ETC)
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 05/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT , NPOLY , MPG
      CHARACTER*(*) POLTYP
C
C-----------------------------------------------------------------------
C
      IF( NPOLY.GE.MPG ) THEN
          WRITE(LOUT,9000) POLTYP , MPG
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(LINKPG) : ' , A , ' POLYGON CREATION !!!!'
     &        / '                     NO. OF POLYGONS EXCEEDS MAX.'
     &        / '                     INCREASE MPG (', I7 , ')'
     &        / '                     NB. MRG(NIMBUS) >= MPG(CPOLYG)+2')
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CHKSEG( LOUT , NSEG , MSEG , SEGTYP )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : CHECK SEGMENT CREATION
C           --  - ---
C PURPOSE : OUTPUT AN ERROR MESSAGE IF SEGMENT LIMIT WILL BE EXCEEDED.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NSEG        = CURRENT NUMBER OF SEGMENTS CREATED
C           MSEG        = MAX. NUMBER OF SEGMENTS ALLOWED
C           SEGTYP      = SEGMENT TYPE (E.G. TARGET, CORNER, ETC)
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 05/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT , NSEG , MSEG
      CHARACTER*(*) SEGTYP
C
C-----------------------------------------------------------------------
C
      IF( NSEG.GE.MSEG ) THEN
          WRITE(LOUT,9000) SEGTYP , MSEG
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(LINKPG) : ' , A , ' SEGMENT CREATION !!!!'
     &        / '                     NO. OF SEGMENTS EXCEEDS MAX.'
     &        / '                     INCREASE MSEG (' , I7 , ')'
     &        / '                     NB. MSEG IS SAME AS NDIM1'
     &        )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE WRPOLY( IFILE , LPMPST , IVIEW , VIEW , NPOLY )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : WRITE NIMBUS POLYGONS
C           --           ----
C PURPOSE : TO WRITE NIMBUS POLYGONS TO NIMBUS (MC) FILE.
C
C INPUT   : IFILE       > 0   --- CHANNEL FOR WRITING NIMBUS POLYGONS
C                       = 0   --- CREATE BUT DON'T WRITE POLYGONS
C           LPMPST      = .T. --- PUMP STRUCTURE EXISTS
C           IVIEW       =  0 --- NIMBUS GEOMETRY MAP PICTURE (GEOM())
C                       = -1 --- ABOVE +
C                                NIMBUS GEOMETRY MAP PICTURE (VIEW())
C           VIEW(1)     = RMIN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C               (2)     = ZMIN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C               (3)     = RLEN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C               (4)     = ZLEN OF USER-DEFINED WINDOW (IVIEW=-1 ONLY)
C           NPOLY       = TOTAL NUMBER OF NIMBYS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CPUMP/ : (SEE 'cpump')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 05/11/98 --- CREATION
C
C.......................................................................
C
C..INPUT
      INTEGER*4 IFILE , IVIEW , NPOLY
      REAL*8    VIEW(4)
      LOGICAL   LPMPST
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..LOCALS
      INTEGER*4 M , ITYPG , I , IV , NVERT
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C-----------------------------------------------------------------------
C
      IF( IFILE.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C---------------------- NIMBUS WINDOW DEFINITION -----------------------
C-----------------------------------------------------------------------
C
      WRITE(IFILE,1010) ' CIR' , 1 , 0.0D+00 , 0.0D+00 , 1.0D+06
      WRITE(IFILE,1010) ' REC' , 2 , ( GEOM(IV) , IV=1,4 )
C
C-----------------------------------------------------------------------
C--------------------------- NIMBUS POLYGONS ---------------------------
C-----------------------------------------------------------------------
C
      DO M = 1 , NPOLY
C
C.... STANDARD POLYGONS
         IF( NVERTM(M).GT.0 ) THEN
             NVERT = NVERTM(M)
             WRITE(IFILE,1010) ' POL' , M + 2 , DFLOAT( NVERT )
             WRITE(IFILE,1020)
     &            ( RVERTM(M,IV), ZVERTM(M,IV), IV=1,NVERT )
C
C.... SPECIAL POLYGONS
         ELSE IF( NVERTM(M).LT.0 .AND. NVERTM(M).GT.-100 ) THEN
             ITYPG = ABS( NVERTM(M) )
             NVERT = NVERTG(ITYPG)
             WRITE(IFILE,1010) ' POL' , M + 2 , DFLOAT( NVERT )
             WRITE(IFILE,1020)
     &            ( RVERTG(ITYPG,IV), ZVERTG(ITYPG,IV), IV=1,NVERT )
C
C.... MAIN BAFFLE POLYGON
         ELSE IF( NVERTM(M).EQ.-100 ) THEN
             NVERT = NBUFLE
             WRITE(IFILE,1010) ' POL' , M + 2 , DFLOAT( NVERT )
             WRITE(IFILE,1020)
     &            ( RBUFLE(IV), ZBUFLE(IV), IV=1,NVERT )
C
C.... EXTRA BAFFLE POLYGONS
         ELSE IF( NVERTM(M).LT.-100 .AND. NVERTM(M).GT.-200 ) THEN
             I     = ABS( NVERTM(M) ) - 100
             NVERT = NBUFX(I)
             WRITE(IFILE,1010) ' POL' , M + 2 , DFLOAT( NVERT )
             WRITE(IFILE,1020)
     &            ( RBUFX(I,IV), ZBUFX(I,IV), IV=1,NVERT )
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C------------------- PUMP POLYGONS & PRESSURE GAUGES -------------------
C-----------------------------------------------------------------------
C
      IF( LPMPST ) THEN
C
          M    = NPOLY    ! LAST POLYGON BEFORE PUMP
C
          DO I = 1 , NPUMP
C
C........... PUMP POLYGONS
             IF( NVPUMP(I).GT.0 ) THEN
                 NVERT = NVPUMP(I)
                 WRITE(IFILE,1010) ' POL' , M + 2 + I , DFLOAT(NVERT)
                 WRITE(IFILE,1020)
     &                ( RPUMP(I,IV), ZPUMP(I,IV), IV=1,NVERT )
C
C........... PRESSURE GAUGES
             ELSE IF( NVPUMP(I).EQ.-1 ) THEN
                 WRITE(IFILE,1010) ' CIR' , M + 2 + I
     &                           , RPUMP(I,1) , ZPUMP(I,1) , RPUMP(I,2)
             ENDIF
C
          ENDDO
C
      ENDIF
C
C-----------------------------------------------------------------------
C--------------------------- DISPLAY WINDOW-----------------------------
C-----------------------------------------------------------------------
C
      IF( IVIEW.LT.0 ) WRITE(IFILE,1030) ' REC' , ( VIEW(IV), IV=1,4 )
C
C-----------------------------------------------------------------------
C------------------------ END POLYGON SECTION --------------------------
C-----------------------------------------------------------------------
C
      WRITE(IFILE,1010) ' END'
C
C-----------------------------------------------------------------------
C
 1010 FORMAT( 1X , A4 , I5 , 1P , 6E11.4 )
 1020 FORMAT( ( 10X , 1P , 6E11.4 ) )
 1030 FORMAT( 1X , A4 , 5X , 1P , 6E11.4 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKESCG( LOUT    , LPASS   , LPWALL , LPSEG , LBUFLE
     I                 , RPX     , ZPX     , PROJ   , EPS   , ZESCUT
     I                 , MP      , MITAG2  , ITAG
     I                 , MALBPG  , IALBPG
     I                 , MSEG    , MTAGS2
     I                 , IOPEN   , NXW     , JPRGT  , JPLFT
     I                 , MPWALL  , NPWALL  , FPWALL , IALB
     O                 , NSEG    , ITAGS
     O                 , NPOLY   )
      IMPLICIT NONE
C
C.......................................................................
C
C ROUTINE : MAKE ESCAPE FIGURE POLYGONS
C           - -  ---               -
C PURPOSE : TO CONSTRUCT NIMBUS POLYGONS FOR ESCAPE FIGURES, THAT IS
C           EXTRA-PLASMA POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C           LPWALL      = .T. --- USE ACTUAL PRIVATE REGION VESSEL
C                                 WALL ACROSS THE PRIVATE REGION COVER
C           LPSEG       = .T. --- EXPLICIT SOURCE SEGMENTS AROUND
C                                 PRIVATE VOID/ALBEDO/WALL REGION
C           LBUFLE      = .T. --- SWITCH ON BAFFLE (NEED IALB = 2)
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C           EPS         = TOLERENCE LEVEL
C           ZESCUT      = IF ALL VERTICES OF POLYGON ARE ABOVE OR ON
C                         ZESCUT THEN FORCE ITAGES(M)=2
C
C           MPG         = MAXIMUM NUMBER OF K-POINTS ALLOWED
C           MITAG2      = 2ND DIMENSION OF ITAG(,)
C           ITAG(K,1)   = RING POINT K LIES ON
C               (K,2)   = ROW  POINT K LIES ON, IF ANY.
C               (K,3)   = Y-SWEEP INFORMATION FOR POINT K
C               (K,4)   = X-SWEEP INFORMATION FOR POINT K
C               (K,5)   = M.C     INFORMATION FOR POINT K
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C           MSEG        = MAX. NUMBER OF SEGMENTS
C           MTAGS2      = 2ND DIMENSION OF ITAGS(,)
C
C           IOPEN       = FIRST OPEN RING
C           NXW         = LAST  OPEN RING
C           JPRGT       = FIRST NORMAL NOT CONNECTED TO PRIVATE REGION
C           JPLFT       = LAST  NORMAL NOT CONNECTED TO PRIVATE REGION
C
C           MPWALL      = MAXIMUM NUMBER OF EXTRA POINTS TO INSERT
C                         IN THE LINE JOINING THE EXTRAPOLATIONS OF
C                         THE PROVATE REGION VESSEL WALL END-POINTS
C           NPWALL      = ACTUAL NUMBER OF THE ABOVE
C           FPWALL()    = FRACTIONAL POSITIONS ALONG THE ABOVE LINE
C                         (MONOTONIC AND IN THE EXCLSUIVE RANGE (0,1)
C
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C
C I/O     : NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 05/11/98 --- CREATION
C
C.......................................................................
C
C..INPUT
      INTEGER*4 LOUT   , MP     , MITAG2 , MALBPG
     &        , MSEG   , MTAGS2
     &        , IOPEN  , NXW    , JPRGT  , JPLFT
     &        , MPWALL , NPWALL , IALB
      INTEGER*4 ITAG(MP,MITAG2) , IALBPG(MALBPG)
      REAL*8    RPX , ZPX , PROJ , EPS , ZESCUT , FPWALL(MPWALL)
      LOGICAL   LPASS , LPWALL , LPSEG , LBUFLE
C
C..I/O
      INTEGER*4 NSEG , ITAGS(MSEG,MTAGS2) , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C-----------------------------------------------------------------------
C------------------------ START OF ESCAPE FIGURES ----------------------
C-----------------------------------------------------------------------
C
      NPOLYK(1) = NPOLY + 1
C
C-----------------------------------------------------------------------
C------------------------- INNER ESCAPE FIGURE -------------------------
C-----------------------------------------------------------------------
C
      CALL MKINNG( LOUT , NPOLY )
C
C-----------------------------------------------------------------------
C------------------ WETTED WALL RING ESCAPE FIGURES --------------------
C-----------------------------------------------------------------------
C
      CALL MKWALG( LOUT   , LPASS
     I           , RPX    , ZPX        , PROJ      , ZESCUT
     I           , MP     , MITAG2     , ITAG(1,1)
     I           , MALBPG , IALBPG(1)
     I           , MSEG   , MTAGS2
     I           , IOPEN  , NXW        , JPRGT     , JPLFT
     O           , NSEG   , ITAGS(1,1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C------------------- WETTED TARGET ESCAPE FIGURES ----------------------
C-----------------------------------------------------------------------
C
      CALL MKTARG( LOUT
     I           , RPX    , ZPX        , PROJ , EPS
     I           , MALBPG , IALBPG(1)
     I           , MSEG   , MTAGS2
     I           , NXW
     O           , NSEG   , ITAGS(1,1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C---------------- GENERATE CORNER/PUMP-GAP POLYGONS --------------------
C------------------ (BEFORE PRIVATE COVER & VOID) ----------------------
C-----------------------------------------------------------------------
C
      IF( IESCF.EQ.0 ) THEN
          CALL MKCPGG( LOUT
     I               , RPX    , ZPX
     I               , MALBPG , IALBPG(1)
     O               , NPOLY  )
      ENDIF
C
C-----------------------------------------------------------------------
C--------------- PRIVATE REGION COVER ESCAPE FIGURES -------------------
C-----------------------------------------------------------------------
C
      CALL MKCOVG( LOUT   , LPASS     , LPWALL
     I           , RPX    , ZPX       , PROJ      , EPS
     I           , MALBPG , IALBPG(1)
     I           , MPWALL , NPWALL    , FPWALL(1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C------------------- PRIVATE VOID ESCAPE FIGURES -----------------------
C-----------------------------------------------------------------------
C
      CALL MKVOIG( LOUT   , LPASS     , LPWALL , LPSEG
     I           , MSEG   , MTAGS2    , IALB
     O           , NSEG   , ITAGS(1,1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C---------------- GENERATE CORNER/PUMP-GAP POLYGONS --------------------
C------------------- (AFTER PRIVATE COVER & VOID) ----------------------
C-----------------------------------------------------------------------
C
      IF( IESCF.EQ.1 ) THEN
          CALL MKCPGG( LOUT
     I               , RPX    , ZPX
     I               , MALBPG , IALBPG(1)
     O               , NPOLY  )
      ENDIF
C
C-----------------------------------------------------------------------
C------------------------- END OF ESCAPE FIGURES -----------------------
C-----------------------------------------------------------------------
C
      NPOLYK(2) = NPOLY
C
C-----------------------------------------------------------------------
C--------------------------- BAFFLE FIGURES ----------------------------
C-----------------------------------------------------------------------
C
      IF( LBUFLE .AND. IALB.EQ.2 ) THEN
          CALL MKBAFG( LOUT  , LBUFLE
     I               , IALB
     O               , NPOLY )
      ENDIF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKINNG( LOUT , NPOLY )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE INNER ESCAPE FIGURE (I.E. BULK) POLYGON
C           - -  --                                 _
C PURPOSE : TO CREATE INNER ESCAPE FIGURE, THAT IS FIGURE INTERNAL TO
C           THE INNERMOST RING (I.E. THE BULK).
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C NOTE    : THIS FIGURE IS CLASSED AS A SPECIAL POLYGON SINCE IT
C           WILL CONTAIN MORE VERTICES THAN A STANDARD POLYGON.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 05/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 J , NVERT , ITYPG
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C-----------------------------------------------------------------------
C
      CALL CKPOLY( LOUT , NPOLY , MPG , 'BULK' )
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      NPOLY         = NPOLY + 1    ! INDEX OF NEW FIGURE
      ITYPG         = 3            ! SPECIAL POLYGON INDEX
      NVERTM(NPOLY) = -ITYPG       ! IDENITIFY SPECIAL POLYGON
      ITAGRM(NPOLY) = 7            ! INTERNAL ESCAPE FIGURE REGION
      MPOLYT(NPOLY) = 2            ! INTERNAL ESCAPE FIGURE
C
C-----------------------------------------------------------------------
C----------- CONSTRUCT INNER ESCAPE FIGURE FROM RING # 1 ---------------
C      (NB. J = 1 & J = NJPOLY(I) ARE THE SAME FOR A CLOSED RING)
C-----------------------------------------------------------------------
C
      NVERT         = 0            ! NUMBER OF VERTICES IN FIGURE
C
      DO J          = 1 , NJPOLY(1) - 1
         NVERT      = NVERT + 1
         RVERTG(ITYPG,NVERT) = RPOLY(1,J)
         ZVERTG(ITYPG,NVERT) = ZPOLY(1,J)
      ENDDO
C
      NVERTG(ITYPG) = NVERT        ! NO. OF VERTICES IN FIGURE
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKWALG( LOUT   , LPASS
     I                 , RPX    , ZPX    , PROJ  , ZESCUT
     I                 , MP     , MITAG2 , ITAG
     I                 , MALBPG , IALBPG
     I                 , MSEG   , MTAGS2
     I                 , IOPEN  , NXW    , JPRGT , JPLFT
     O                 , NSEG   , ITAGS
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE WALL RING ESCAPE FIGURES POLYGONS
C           - -  --                           _
C PURPOSE : TO CREATE WALL RING ESCAPE FIGURES, THAT IS POLYGONS COMING
C           FROM RING NXWPG.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C           ZESCUT      = IF ALL VERTICES OF POLYGON ARE ABOVE OR ON
C                         ZESCUT THEN FORCE ITAGES(M)=2
C
C           MPG         = MAXIMUM NUMBER OF K-POINTS ALLOWED
C           MITAG2      = 2ND DIMENSION OF ITAG(,)
C           ITAG(K,1)   = RING POINT K LIES ON
C               (K,2)   = ROW  POINT K LIES ON, IF ANY.
C               (K,3)   = Y-SWEEP INFORMATION FOR POINT K
C               (K,4)   = X-SWEEP INFORMATION FOR POINT K
C               (K,5)   = M.C     INFORMATION FOR POINT K
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C           MSEG        = MAX. NUMBER OF SEGMENTS
C           MTAGS2      = 2ND DIMENSION OF ITAGS(,)
C
C           IOPEN       = FIRST OPEN RING
C           NXW         = LAST  OPEN RING
C           JPRGT       = FIRST NORMAL NOT CONNECTED TO PRIVATE REGION
C           JPLFT       = LAST  NORMAL NOT CONNECTED TO PRIVATE REGION
C
C I/O     : NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: GETVTX      = FIND ON WHICH VERTEX RING A POLYGON
C                         VERTEX LIES (I.E. IP1 OR I)
C           LBREC       = CHECK IF POINT IS INSIDE NIMBUS RECTANGLE
C           VESS62      = BREAKS POLYGONS UP DUE TO VESSEL
C           IREGON      = ASSIGNS REGIONS TO POLYGONS
C           CHKALB      = ASSIGNS POLYGON AS AN ALBEDO, IF REQUIRED
C           CKPOLY      = CHECK POLYGON  LIMITS
C           CHKSEG      = CHECK SEGMENTS LIMITS
C
C NOTES   : 1. LAST OPEN POLYGON RING IS CONSTRUCTED AS FOLLOWS :-
C
C               WALL      VOID    PLASMA
C               ++++  |   ++++  | ++++++   |
C                     |         |          |
C                     |        2|----------|1
C                     |         |..    (M1)|
C             (LHS)   |         |  ..      |
C                     |         |    (N)   |
C                     |         |      ..  |
C                     |         |(M2)    ..|
C                     |        3|----------|4
C                     |         |          |
C                     |         |          |
C                 (VESSEL)    (IP1)       (I)
C                             UPPER       LOWER
C                             VERTEX      VERTEX
C                             RING        RING
C
C              WHERE, IP1    = NXWPG = LAST VERTEX RING
C                     N      = PLASMA POLYGON CONTAINING K-MESH POINT
C                     M1,M2  = NIMBUS POLYGONS CONTAINED IN POLYGON #N
C
C                     ON THE LHS --- VERTICES 1 & 2 ARE ON THE TOP-SIDE
C                     ON THE RHS --- VERTICES 4 & 3 ARE ON THE TOP-SIDE
C                     FOR ALL    --- VERTICES 1 & 4 ARE ON NEAR SIDE
C
C           2. ESCAPE FIGURE EXTRAPOLATIONS :-
C                A) Z >= GEOM(6) --- EXTRAPOLATE R BUT KEEP Z FIXED
C                                    (I.E HORIZONTAL)
C                B) Z < GEOM(6)  --- EXTRAPOLATE BOTH R AND Z
C
C           3. DEPENDING OF THE SKEW OF THE GEOMETRY IT IS POSSIBLE
C              THAT FOR Z > GEOM(6) & Z < ZPX, THE GEOM(5) COULD
C              LEAD TO EXTRAPOLATING IN THE WRONG DIRECTION.
C              USE OF THE MIN-POINT OF RHS MIN & LHS MAX IF IP1
C              FIXES THIS ISSUE FOR THIS Z-RANGE.
C
C METHOD  : 1. LOOP OVER I (SEE NOTES 1.)
C           2. OBTAIN PLASMA POLYGON FROM ABOVE.
C           3. LOOP OVER EACH NIMBUS POLYGON CONTAINED IN 2. ABOVE.
C           4. IGNORE POLYGONS WITH LESS THAN TWO VERTICES ON IP1
C           5. PRODUCE ESCAPE FIGURE BY EXTRAPOLATING (SEE NOTES 2.)
C           6. USE S.R 'VESS62' TO SPLIT NEWLY CREATED ESCAPE FIGURE
C              INTO WALL POLYGONS AND VOID POLYGONS WHERE THE VESSEL
C              IS THE BOUNDARY BETWEEN THE TWO REGIONS.
C
C           7. LABEL NEW POLYGONS VIA ITAGES & ITAGRM
C           8. GET VESSEL SEGMENT DATA.
C           9. COLLECT END POINT OF I NECESSARY FOR POSSIBLE CORNER.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 09/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MP     , MITAG2 , MALBPG
     &        , MSEG  , MTAGS2
     &        , IOPEN , NXW    , JPRGT  , JPLFT
      INTEGER*4 ITAG(MP,MITAG2) , IALBPG(MALBPG)
      REAL*8    RPX , ZPX , PROJ , ZESCUT
      LOGICAL   LPASS
C
C..I/O
      INTEGER*4 NSEG , ITAGS(MSEG,MTAGS2) , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      LOGICAL   LBREC
C
C..LOCALS
      INTEGER*4 I  , NI , IP1 , NIP1
     &        , J  , K , L , N , M , IV , LV , IVERT(4) , IPOLY
     &        , IR , NEWPG
      REAL*8    XPROJ , RRMIN , RLMAX , RCIP1
     &        , RSAVE(4)    , ZSAVE(4) , RROOT(2) , ZROOT(2)
      LOGICAL   LTRAN
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      I         = NXWPG - 1    ! LOWER VERTEX RING OF NXWPG
      IP1       = I + 1        ! UPPER VERTEX RING OF NXWPG
C
      RRMIN     = UDEF         ! RHS MIN OF IP1
      RLMAX     = -RRMIN       ! LHS MAX OF IP1
C
C-----------------------------------------------------------------------
C----------------------- MID-POINT OF RING IP1 -------------------------
C-----------------------------------------------------------------------
C
      DO J  = 1 , NJPOLY(IP1)
         IF( J.LE.NJPOLY(IP1)/2 ) THEN
             IF( ZPOLY(IP1,J).GE.GEOM(6) .AND. RPOLY(IP1,J).GT.RLMAX )
     &           RLMAX = RPOLY(IP1,J)
         ELSE
             IF( ZPOLY(IP1,J).GE.GEOM(6) .AND. RPOLY(IP1,J).LT.RRMIN )
     &           RRMIN = RPOLY(IP1,J)
         END IF
      ENDDO
C
      RCIP1 = ( RRMIN + RLMAX ) * 5.00D-01
C
C-----------------------------------------------------------------------
C----------------------- START LOWER VERTEX LOOP -----------------------
C-----------------------------------------------------------------------
C
      DO J  = NJP(I) , 1 , -1
         N  = KORP(I,J)    ! PLASMA POLYGON INDEX
         K  = KORKG(N)     ! K-MESH AT CENTRE OF N
C
C-----------------------------------------------------------------------
C---------------------- START NIMBUS POLYGON LOOP ----------------------
C-----------------------------------------------------------------------
C
         DO L = 1 , NM(N)
            M = KORM(N,L)  ! NIMBUS POLYGON
C
C.......... FIND WHICH VERTICES LIW ON UPPER AND LOWER VERTEX RINGS
            CALL GETVTX( NVERTM(1) , ITAGM(1,1) , MPG
     &                 , M         , I          , IP1
     &                 , NIP1      , IVERT(1)   , IVERT(2)
     &                 , NI        , IVERT(3)   , IVERT(4) )
C
C.......... IGNORE NIMBUS POLYGONS WHICH HAVE LESS THAN TWO IP1 VERTICES
            IF( NIP1.LE.1 ) GOTO 200
C
C-----------------------------------------------------------------------
C----------------------- CREATE NEW POLYGON ----------------------------
C-----------------------------------------------------------------------
C
C.......... CHECK POLYGON LIMIT
            CALL CKPOLY( LOUT , NPOLY , MPG , 'WALL' )
C
C.......... INCREMENT POLYGON INDEX
            NPOLY         = NPOLY + 1  ! INDEX OF NEW FIGURE
            NVERTM(NPOLY) = 4          ! NO. OF VERTICES IN NEW POLYGON
            MPOLYT(NPOLY) = 3          ! WETTED WALL RING
C
C.......... 1ST VERTEX : ON UPPER VERTEX RING
            RVERTM(NPOLY,1) = RVERTM(M,IVERT(1))
            ZVERTM(NPOLY,1) = ZVERTM(M,IVERT(1))
C
C.......... 4TH VERTEX : ON UPPER VERTEX RING
            RVERTM(NPOLY,4) = RVERTM(M,IVERT(2))
            ZVERTM(NPOLY,4) = ZVERTM(M,IVERT(2))
C
C.......... 2ND/3RD VERTEX : EXTRAPOLATION FROM X-POINT OR PLASMA CENTRE
            XPROJ = PROJ
C
            DO IV = 2 , 3
C
               IF( IV.EQ.2 ) THEN
                   LV = 1  ! VERTEX 2 IS EXTRAPOLATED FROM VERTEX 1
               ELSE
                   LV = 4  ! VERTEX 3 IS EXTRAPOLATED FROM VERTEX 4
               ENDIF
C
  100          IF( ZVERTM(NPOLY,LV).GT.ZPX ) THEN
                   RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                              + (RVERTM(NPOLY,LV)-RPX) * XPROJ
                   ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
               ELSE IF( ZVERTM(NPOLY,LV).LT.GEOM(6) ) THEN
                   RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                              + (RVERTM(NPOLY,LV)-GEOM(5)) * XPROJ
                   ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
     &                              + (ZVERTM(NPOLY,LV)-GEOM(6)) * XPROJ
               ELSE
                   RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                              + (RVERTM(NPOLY,LV)-RCIP1) * XPROJ
                   ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
               ENDIF
C
C............. INCREASE XPROJ UNTIL VERTEX LIES OUTSIDE NIMBUS RECTANGLE
               LTRAN = LBREC( RVERTM(NPOLY,IV) , ZVERTM(NPOLY,IV)
     &                      , GEOM(1)          , GEOM(2)
     &                      , GEOM(1)+GEOM(3)  , GEOM(2)+GEOM(4)  )
               IF( LTRAN ) THEN
                   XPROJ = 1.5D+00 * XPROJ  ! INCREASE PROJECTION
                   GOTO 100
               ENDIF
C
            ENDDO
C
C-----------------------------------------------------------------------
C------------------------ SAVE ORIGINAL VERTICES -----------------------
C-----------------------------------------------------------------------
C
            RSAVE(1) = RVERTM(NPOLY,1)
            RSAVE(2) = RVERTM(NPOLY,2)
            RSAVE(3) = RVERTM(NPOLY,3)
            RSAVE(4) = RVERTM(NPOLY,4)
C
            ZSAVE(1) = ZVERTM(NPOLY,1)
            ZSAVE(2) = ZVERTM(NPOLY,2)
            ZSAVE(3) = ZVERTM(NPOLY,3)
            ZSAVE(4) = ZVERTM(NPOLY,4)
C
C-----------------------------------------------------------------------
C----------------- CREATE NEW POLYGONS DUE TO VESSEL -------------------
C-----------------------------------------------------------------------
C
            IF( NVES.GT.0 ) THEN
                CALL VESS62( LOUT        , LPASS
     &                     , MVES        , MPG   , 5   , MPG
     &                     , NVES        , NPOLY       , NVERTM(1)
     &                     , RVES(1)     , ZVES(1)     , ZESCUT
     &                     , RVERTM(1,1) , ZVERTM(1,1)
     &                     , ITAGES(1)   , NEWPG
     &                     , RROOT(1)    , ZROOT(1)
     &                     , RROOT(2)    , ZROOT(2)    )
            ELSE
                NEWPG     = 0
                RROOT(1)  = UDEF      ! LHS INTERSECTION
                ZROOT(1)  = UDEF
                RROOT(2)  = UDEF      ! RHS INTERSECTION
                ZROOT(2)  = UDEF
            ENDIF
C
C-----------------------------------------------------------------------
C---------------- ASSIGN REGIONS TO ALL NEW POLYGONS -------------------
C-----------------------------------------------------------------------
C
C.......... REGIONAL ASSIGMENT OF K-MESH POINT
            CALL IREGON( MP , ITAG(1,1) , JPRGT , JPLFT , NXW , IOPEN
     &                 , K  , IR        )
C
            IF( IR.EQ.3 ) THEN
                IR = -2
            ELSE IF( IR.EQ.4 ) THEN
                IR = -3
            ELSE
                IR = 0
            END IF
C
C.......... REGIONAL ASSIGNMENT OF NIMBUS POLYGONS
            DO IPOLY = NPOLY - NEWPG , NPOLY
C
               IF( ITAGES(IPOLY).EQ.1 ) THEN
                   IF( IR.EQ.-2 ) THEN
                       ITAGRM(IPOLY) = 17
                   ELSE IF( IR.EQ.-3 ) THEN
                       ITAGRM(IPOLY) = 18
                   ELSE
                       ITAGRM(IPOLY) = 8
                   END IF
               ELSE
                   IF( IR.EQ.-2 ) THEN
                       ITAGRM(IPOLY) = 19
                   ELSE IF( IR.EQ.-3 ) THEN
                       ITAGRM(IPOLY) = 20
                   ELSE
                       ITAGRM(IPOLY) = 9
                   END IF
               END IF
C
C............. IS POLYGON AN ALBEDO ?
               CALL CHKALB( MALBPG , IALBPG(1)     , IR
     &                    , IPOLY  , ITAGES(IPOLY)      )
C
C............. POLYGON CREATED FROM WETTED WALL RING
               MPOLYT(IPOLY) = 3
C
            ENDDO
C
C-----------------------------------------------------------------------
C-------------------------- FORM SEGMENTS ------------------------------
C-----------------------------------------------------------------------
C
            IF( IDTAGM(M,1).EQ.0 ) THEN
                CALL CHKSEG( LOUT , NSEG , MSEG , 'WALL' )
                NSEG          = NSEG + 1
                ITAGS(NSEG,1) = M
                ITAGS(NSEG,2) = IVERT(1)
                ITAGS(NSEG,3) = IVERT(2)
                ITAGS(NSEG,4) = 0
            ENDIF
C
C-----------------------------------------------------------------------
C------------- UPDATE DATA FOR POSSIBLE CORNER POLYGONS ----------------
C-----------------------------------------------------------------------
C
C.......... RHS CORNER DATA (FROM 1ST ESCAPE FIGURE ON RHS)
            IF( J.EQ.1 ) THEN
                RVINT(1)   = RROOT(2)  ! RHS CORNER/VESSEL INTERSECTION
                ZVINT(1)   = ZROOT(2)
C
                RCORN(1,1) = RSAVE(4)  ! HORIZ TOP-SIDE PLASMA VERTEX
                ZCORN(1,1) = ZSAVE(4)
                RCORN(1,2) = RVINT(1)  ! VESSEL INTERSECTION ON TOP SIDE
                ZCORN(1,2) = ZVINT(1)
                RCORN(1,3) = RSAVE(3)  ! HORIZ TOP-SIDE EXTRAP VERTEX
                ZCORN(1,3) = ZSAVE(3)
C
C.......... LHS CORNER DATA (FROM 1ST ESCAPE FIGURE ON LHS)
            ELSE IF( J.EQ.NJP(I) ) THEN
                RVINT(2)   = RROOT(1)  ! LHS CORNER/VESSEL INTERSECTION
                ZVINT(2)   = ZROOT(1)
C
                RCORN(2,1) = RSAVE(1)  ! HORIZ TOP-SIDE PLASMA VERTEX
                ZCORN(2,1) = ZSAVE(1)
                RCORN(2,2) = RVINT(2)  ! VESSEL INTERSECTION ON TOP SIDE
                ZCORN(2,2) = ZVINT(2)
                RCORN(2,3) = RSAVE(2)  ! HORIZ TOP-SIDE EXTRAP VERTEX
                ZCORN(2,3) = ZSAVE(2)
            END IF
C
C-----------------------------------------------------------------------
C---------------------- FINISH NIMBUS POLYGON LOOP ---------------------
C-----------------------------------------------------------------------
C
  200    ENDDO
C
C-----------------------------------------------------------------------
C-------------------- FINISH LOWER VERTEX RING LOOP --------------------
C-----------------------------------------------------------------------
C
      ENDDO
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKTARG( LOUT
     I                 , RPX    , ZPX    , PROJ , EPS
     I                 , MALBPG , IALBPG
     I                 , MSEG   , MTAGS2
     I                 , NXW
     O                 , NSEG   , ITAGS
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE WETTED TARGET ESCAPE FIGURES POLYGONS
C           - -         ---                       -
C PURPOSE : TO CREATE TARGET ESCAPE FIGURES, THAT IS POLYGONS COMING
C           FROM WETTED TARGET RING TIPS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C           EPS         = TOLERENCE LEVEL
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C           MSEG        = MAX. NUMBER OF SEGMENTS
C           MTAGS2      = 2ND DIMENSION OF ITAGS(,)
C
C           NXW         = LAST  OPEN RING
C
C I/O     : NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: GETVTX      = FIND ON WHICH VERTEX RING A POLYGON
C                         VERTEX LIES (I.E. IP1 OR I)
C           LBREC       = CHECK IF POINT IS INSIDE NIMBUS RECTANGLE
C           IREGON      = ASSIGNS REGIONS TO POLYGONS
C           CHKALB      = ASSIGNS POLYGON AS AN ALBEDO, IF REQUIRED
C           CKPOLY      = CHECK POLYGON  LIMITS
C           CHKSEG      = CHECK SEGMENTS LIMITS
C           PYTHGS      = DISTANCE BETWEEN TWO POINTS
C           RNGCUT      = TEST IF A LINE INTERSECTIONS A VERTEX RING
C           PNEIGH      = FIND NEIGHBOURING NIMBUS POLYGON
C
C NOTES   : 1. WETTED TARGET POLYGONS ARE CONSTRUCTED AS FOLLOWS :-
C
C                                  LHS TARGET WALL
C                                  +++++++++++++++
C         J=NJP(I) |---...--|----------|-...---|-------|--...---|
C                  |       2|..    (M1)|1      |       |        |
C                  |        |  ..      |       |       |        |
C                  |        |    (N)   |       |       |        |
C                  |        |      ..  |       |       |        |
C                  |        |(M2)    ..|       |       |        |
C                  |       3|----------|4      |       |        |
C                  |        |          |       |       |        |
C                  |        |          |       |       |        |
C               (NXWPG)...(IP1)       (I)...(LCFS+1)(NCPG)...(NXWPG+1)
C
C                                  RHS TARGET WALL
C                                  +++++++++++++++
C         J = 1    |-----...---|-----|----...-|----------|--...---|
C                  |           |     |       4|(M1)    ..|3       |
C                  |           |     |        |      ..  |        |
C                  |           |     |        |   (N)    |        |
C                  |           |     |        |  ..      |        |
C                  |           |     |        |..    (M2)|        |
C                  |           |     |       1|----------|2       |
C                  |           |     |        |          |        |
C                  |           |     |        |          |        |
C                  |           |     |        |          |        |
C               (NXWPG+1)...(NCPG)(LCFS+1)...(I)       (IP1)...(NXWPG)
C
C              WHERE, IP1    = UPPER VERTEX RING
C                     N      = PLASMA POLYGON CONTAINING K-MESH POINT
C                     M1,M2  = NIMBUS POLYGONS CONTAINED IN POLYGON #N
C
C                     ON THE LHS --- VERTICES 1 & 2 ARE ON THE TOP-SIDE
C                     ON THE RHS --- VERTICES 4 & 3 ARE ON THE TOP-SIDE
C                     FOR ALL    --- VERTICES 1 & 4 ARE ON NEAR SIDE
C
C           2. THE TARGET IS SPLIT ARE FOLLOWS :-
C
C                LHS --- I = NXWPG  + 1 -> NCPG       : REGION # 1
C                                                       (PRIV. REG.)
C                LHS --- I = LCFSPG + 1 -> NXWPG  - 1 : REGION # 2
C                                                       (SOL)
C                RHS --- I = NXWPG  - 1 -> LCFSPG + 1 : REGION # 3
C                                                       (SOL)
C                RHS --- I = NCPG       -> NXWPG  + 1 : REGION # 3
C                                                       (PRIV. REG.)
C
C              ** I & IP1 MAY LIE IN EITHER OF THE ABOVE REGIONS,
C                 BUT IP1 WILL ALWAYS BE NEAREST TO THE SOL WALL.
C
C              ** ISIDE = 1 ---- RHS TARGET REGION
C                 ISIDE = 2 ---- LHS TARGET REGION
C
C           3. ESCAPE FIGURE EXTRAPOLATIONS :-
C                TRY TO EXTRAPOLATE IN R WITH FIXED Z, IF THIS CUTS
C                THE VESSEL THEN EXTRAOLATE R & Z
C
C METHOD  : 1. LOOP OVER THE FOUR REGIONS ABOVE (SEE NOTES 2.).
C           2. GET TARGET POINT ON VERTEX RING FOR REGION.
C           3. OBTAIN PLASMA POLYGON FROM ABOVE.
C           4. LOOP OVER EACH NIMBUS POLYGON CONTAINED IN 3. ABOVE.
C           5. IGNORE POLYGONS WITH ARE NOT IN CONTACT WITH THE WALL.
C           6. PRODUCE ESCAPE FIGURE BY EXTRAPOLATING VERTICES (SEE
C              NOTES 3.).
C
C           7. LABEL NEW POLYGONS VIA ITAGES & ITAGRM
C           8. GET VESSEL SEGMENT DATA.
C           9. COLLECT WALL POINT OF I NECESSARY FOR POSSIBLE CORNER.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 10/11/98 --- CREATION
C           V1.R2.M0 --- 01/12/98 --- IF IESCF = 0 THEN FORM CORNER
C           V1.R3.M0 --- 02/03/99 --- WHEN FORMING DATA FOR CORNERS
C                                     CHECK FOR VESSEL CUTS ON THE
C                                     POLYGON MAKING THE HORIZONTAL
C                                     SIDE.
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MALBPG
     &        , MSEG  , MTAGS2
     &        , NXW
      INTEGER*4 IALBPG(MALBPG)
      REAL*8    RPX , ZPX , PROJ , EPS
C
C..I/O
      INTEGER*4 NSEG , ITAGS(MSEG,MTAGS2) , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      LOGICAL   LBREC
      REAL*8    PYTHGS
C
C..LOCALS
      INTEGER*4 ITREG , IMIN , IMAX , ISTEP , ISIDE
     &        , I  , IP1 , NI  , NIP1
     &        , N  , M   , M0  , IGEN(4) , IVERT(4) , IV , IV0 , IV1
     &        , L  , LV  , LL  , IR
     &        , MH , MNH , NV
      REAL*8    DIST(2) , XPROJ , RGEN(4) , ZGEN(4)
     &        , RSAVE(2,4) , ZSAVE(2,4)
      LOGICAL   LTRAN(2) , LHORIZ
C
C-----------------------------------------------------------------------
C----------------------- START TARGET REGION LOOP ----------------------
C-----------------------------------------------------------------------
C
      DO ITREG = 1 , 4
C
C....... SET BOUNDS FOR RING #I IN PARTICULAR TARGET REGION
         IF( ITREG.EQ.1 ) THEN
             IMIN = NXWPG  + 1
             IMAX = NCPG
         ELSE IF( ITREG.EQ.2 ) THEN
             IMIN = LCFSPG + 1
             IMAX = NXWPG  - 1
         ELSE IF( ITREG.EQ.3 ) THEN
             IMIN = NXWPG  - 1
             IMAX = LCFSPG + 1
         ELSE IF( ITREG.EQ.4 ) THEN
             IMIN = NCPG
             IMAX = NXWPG + 1
         ELSE
             WRITE(LOUT,9000)
             CALL EXITX(LOUT)
         ENDIF
C
C....... SET RING #I STEP DIRECTION
         IF( IMIN.GT.IMAX ) THEN
             ISTEP = -1
         ELSE
             ISTEP = +1
         ENDIF
C
C....... LABEL SIDE FOR TARGET REGION
         IF( ITREG.GT.2 ) THEN
             ISIDE = 1    ! RHS TARGET
         ELSE
             ISIDE = 2    ! LHS TARGET
         ENDIF
C
C-----------------------------------------------------------------------
C----------------------- START LOWER VERTEX LOOP -----------------------
C-----------------------------------------------------------------------
C
         DO I = IMIN , IMAX , ISTEP
C
C.......... PLASMA POLYGON INDEX
            IF( ISIDE.EQ.1 ) THEN
                N = KORP(I,1)        ! RHS TARGET
            ELSE
                N = KORP(I,NJP(I))   ! LHS TARGET
            ENDIF
C
C.......... RING #IP1
            IP1 = ITAGP(N,2)
C
C-----------------------------------------------------------------------
C---------------------- START NIMBUS POLYGON LOOP ----------------------
C-----------------------------------------------------------------------
C
            DO L = 1 , NM(N)
               M = KORM(N,L)  ! NIMBUS POLYGON
C
C............. FIND WHICH VERTICES LIE ON UPPER AND LOWER VERTEX RINGS
               CALL GETVTX( NVERTM(1) , ITAGM(1,1) , MPG
     &                    , M         , I          , IP1
     &                    , NIP1      , IGEN(1)    , IGEN(2)
     &                    , NI        , IGEN(3)    , IGEN(4) )
C
C............. PICK TWO VERTICES ON TARGET SIDE OF POLYGON
               IF( ISIDE.EQ.1 ) THEN
                   IVERT(1) = IGEN(2)   ! RHS
                   IVERT(2) = IGEN(3)   ! RHS
               ELSE
                   IVERT(1) = IGEN(4)   ! LHS
                   IVERT(2) = IGEN(1)   ! LHS
               ENDIF
C
               IF( (ISIDE.EQ.1 .AND. NI  .EQ.0) .OR.
     &             (ISIDE.EQ.2 .AND. NIP1.EQ.0)      ) THEN
                    IVERT(2) = IVERT(1) + 1
                    IF( IVERT(2).GT.NVERTM(M) ) IVERT(2) = 1
               ENDIF
C
               IF( (ISIDE.EQ.1 .AND. NIP1.EQ.0) .OR.
     &             (ISIDE.EQ.2 .AND. NI  .EQ.0)      ) THEN
                    IVERT(1) = IVERT(2) - 1
                    IF( IVERT(1).LT.1 ) IVERT(1) = NVERTM(M)
               ENDIF
C
C............. ARE THE TWO VERTICES OF M IN CONTACT WITH THE WALL ?
               DO LL  = 1 , NM(N)
                  M0  = KORM(N,LL)
                  IF( M0.NE.M ) THEN
C.................... ALL OTHER NIMBUS POLYGONS IN PLASMA POLYGON #N
                      LTRAN(1)   = .FALSE.
                      LTRAN(2)   = .FALSE.
                      DO IV0     = 1 , NVERTM(M0)
                         DIST(1) = PYTHGS( RVERTM(M0,IV0)
     &                                   , ZVERTM(M0,IV0)
     &                                   , RVERTM(M,IVERT(1))
     &                                   , ZVERTM(M,IVERT(1)) )
                         DIST(2) = PYTHGS( RVERTM(M0,IV0)
     &                                   , ZVERTM(M0,IV0)
     &                                   , RVERTM(M,IVERT(2))
     &                                   , ZVERTM(M,IVERT(2)) )
                         IF( DIST(1).LE.EPS ) LTRAN(1) = .TRUE.
                         IF( DIST(2).LE.EPS ) LTRAN(2) = .TRUE.
C....................... IF TRUE THEN M IS NOT IN CONTACT WITH TARGET !!
                         IF( LTRAN(1) .AND. LTRAN(2) ) GOTO 200
                      ENDDO
                  ENDIF
               ENDDO
C
C-----------------------------------------------------------------------
C----------------------- CREATE NEW POLYGON ----------------------------
C-----------------------------------------------------------------------
C
C............. CHECK POLYGON LIMIT
               CALL CKPOLY( LOUT , NPOLY , MPG , 'TARGET' )
C
C............. INCREMENT POLYGON INDEX
               NPOLY         = NPOLY + 1  ! INDEX OF NEW FIGURE
               NVERTM(NPOLY) = 4          ! NO. OF VERTICES IN POLYGON
C
C............. 1ST VERTEX : ON UPPER VERTEX RING
               RVERTM(NPOLY,1) = RVERTM(M,IVERT(1))
               ZVERTM(NPOLY,1) = ZVERTM(M,IVERT(1))
C
C............. 4TH VERTEX : ON UPPER VERTEX RING
               RVERTM(NPOLY,4) = RVERTM(M,IVERT(2))
               ZVERTM(NPOLY,4) = ZVERTM(M,IVERT(2))
C
C.......... 2ND/3RD VERTEX : EXTRAPOLATION FROM X-POINT OR PLASMA CENTRE
               XPROJ = PROJ
C
               DO IV = 2 , 3
C
                  IF( IV.EQ.2 ) THEN
                      LV = 1  ! VERTEX 2 IS EXTRAPOLATED FROM VERTEX 1
                  ELSE
                      LV = 4  ! VERTEX 3 IS EXTRAPOLATED FROM VERTEX 4
                  ENDIF
C
  100             RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                             + (RVERTM(NPOLY,LV)-RPX) * XPROJ
                  ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
     &                             + (ZVERTM(NPOLY,LV)-ZPX) * XPROJ
C
C................ INCREASE XPROJ UNTIL VERTEX LIES OUTSIDE NIMBUS RECT.
                  LTRAN(1) = LBREC( RVERTM(NPOLY,IV) , ZVERTM(NPOLY,IV)
     &                            , GEOM(1)          , GEOM(2)
     &                            , GEOM(1)+GEOM(3)  , GEOM(2)+GEOM(4) )
                  IF( LTRAN(1) ) THEN
                      XPROJ = 1.5D+00 * XPROJ  ! INCREASE PROJECTION
                      GOTO 100
                  ENDIF
C
               ENDDO
C
C-----------------------------------------------------------------------
C------------- SAVE ORIGINAL NON-HORIZONTALISED VERTICES ? -------------
C-------------- ONLY FOR TOP-MOST LHS/RHS POINTS POLYGON ---------------
C-----------------------------------------------------------------------
C
               IF( ( ITREG.EQ.1 .AND. I.EQ.IMIN ) .OR.
     &             ( ITREG.EQ.4 .AND. I.EQ.IMAX )      ) THEN
                   DO IV = 1 , 4
                      RSAVE(ISIDE,IV) = RVERTM(NPOLY,IV)
                      ZSAVE(ISIDE,IV) = ZVERTM(NPOLY,IV)
                   ENDDO
               ENDIF
C
C-----------------------------------------------------------------------
C--------------- SHOULD THIS POLYGON BE HORIZONTALISED ? ---------------
C-----------------------------------------------------------------------
C
C............. INITIALISATION
               IGEN(1) = 0       ! FIRST RING CUT BY VERTEX # 1
               IGEN(4) = 0       ! FIRST RING CUT BY VERTEX # 4
               LHORIZ  = .FALSE. ! HORIZONTALISE ?
C
C............. FIRST SIDE
               RGEN(1) = RVERTM(NPOLY,1)  ! FIXED VERTEX
               ZGEN(1) = ZVERTM(NPOLY,1)
               RGEN(2) = RVERTM(NPOLY,2)  ! EXTRAPOLATED VERTEX
               ZGEN(2) = ZGEN(1)          ! (MAKE HORIZONTAL)
               CALL RNGCUT( 2          , RGEN(1) , ZGEN(1)
     I                    , LCFSPG + 1 , NCPG    , 0
     O                    , IGEN(1)    )
C
C............. SECOND SIDE
               RGEN(3) = RVERTM(NPOLY,4)  ! FIXED VERTEX
               ZGEN(3) = ZVERTM(NPOLY,4)
               RGEN(4) = RVERTM(NPOLY,3)  ! EXTRAPOLATED VERTEX
               ZGEN(4) = ZGEN(3)          ! (MAKE HORIZONTAL)
               CALL RNGCUT( 2          , RGEN(3) , ZGEN(3)
     I                    , LCFSPG + 1 , NCPG    , 0
     O                    , IGEN(4)    )
C
C............. RE-CALCULATE Z-COORD OF EXTRAPOLATED POINTS ?
               IF( IGEN(1).EQ.0 .AND. IGEN(4).EQ.0 ) THEN
                   LHORIZ          = .TRUE.
                   ZVERTM(NPOLY,2) = ZGEN(2)   ! I.E. ZVERTM(NPOLY,1)
                   ZVERTM(NPOLY,3) = ZGEN(4)   ! I.E. ZVERTM(NPOLY,4)
                   IHORIZ(NPOLY)   = 1
               ENDIF
C
C-----------------------------------------------------------------------
C--------- INSERT VESSEL INTERSECTION IN SOL/TARGET POLYGON ------------
C-----------------------------------------------------------------------
C
               IF( LHORIZ .AND. NVES.GT.0 ) THEN
C
C................. TARGET POLYGONS AT WALL BOUNDARY ONLY
                   IF( (ITREG.EQ.2 .AND. I.EQ.IMAX) .OR.
     &                 (ITREG.EQ.3 .AND. I.EQ.IMIN)      ) THEN
C
C..................... VERTEX INDEX OF NEWLY INSERTED POINT
                       IF( ISIDE.EQ.1 ) THEN
                           IV0 = 2             ! RHS INSERTION VERTEX
                       ELSE
                           IV0 = NVERTM(NPOLY) ! LHS INSERTION VERTEX
                       ENDIF
C
C..................... MAKE SPACE FOR INTERSECTION POINT
                       DO IV = NVERTM(NPOLY) , IV0 , -1
                          RVERTM(NPOLY,IV+1) = RVERTM(NPOLY,IV)
                          ZVERTM(NPOLY,IV+1) = ZVERTM(NPOLY,IV)
                       ENDDO
C
C..................... PLUG IN INTERSECTION POINT
                       RVERTM(NPOLY,IV0) = RVINT(ISIDE)
                       ZVERTM(NPOLY,IV0) = ZVINT(ISIDE)
C
C..................... NEW NUMBER OF VERTICES IN POLYGON
                       NVERTM(NPOLY) = NVERTM(NPOLY) + 1
C
C..................... PLASMA SIDE VERTEX ON INSERTION SIDE
                       IF( ISIDE.EQ.1 ) THEN
                           IV1 = IV0 - 1       ! RHS PLASMA SIDE VERTEX
                       ELSE
                           IV1 = IV0 + 1       ! LHS PLASMA SIDE VERTEX
                       ENDIF
C
C..................... NEIGHBOURING VOID POLYGON OF THIS WALL POLYGON
                       MHZWA(ISIDE)    = NPOLY
                       IVHZWA(ISIDE,1) = MIN0( IV0 , IV1 )
                       IVHZWA(ISIDE,2) = MAX0( IV0 , IV1 )
                       CALL PNEIGH( NPOLY        , IVHZWA(ISIDE,1)
     &                            , MPG          , 5
     &                            , NPOLY-1      , NVERTM(1)
     &                            , RVERTM(1,1)  , ZVERTM(1,1)
     &                            , MHZVO(ISIDE) )
C
                   ENDIF
C
               ENDIF
C
C-----------------------------------------------------------------------
C----- UPPER-MOST HORIZONTAL & LOWER-MOST NON-HORIZONTAL POLYGON -------
C-----------------------------------------------------------------------
C
               IF( LHORIZ ) THEN
C................. UPPER-MOST HORIZONTAL TARGET POLYGON
                   IF( ISIDE.EQ.1 ) THEN
                       MCORN(ISIDE,1) = NPOLY
                   ELSE
                      IF( MCORN(ISIDE,1).EQ.0 ) MCORN(ISIDE,1) = NPOLY
                   ENDIF
               ELSE
C................. LOWER-MOST NON-HORIZONTAL TARGET POLYGON
                   IF( ISIDE.EQ.1 ) THEN
                       IF( MCORN(ISIDE,2).EQ.0 ) MCORN(ISIDE,2) = NPOLY
                   ELSE
                       MCORN(ISIDE,2) = NPOLY
                   ENDIF
               ENDIF
C
C-----------------------------------------------------------------------
C------------------- ASSIGN REGION TO NEW POLYGONS ---------------------
C-----------------------------------------------------------------------
C
C............. POLYGON REGIONAL ASSIGNMENT
               IF( ISIDE.EQ.1 ) THEN
                   ITAGRM(NPOLY) = 10    ! RHS TARGET
                   IR            = -6
                   IF( NPOLYK(6).EQ.0 ) NPOLYK(6) = NPOLY
               ELSE
                   ITAGRM(NPOLY) = 12    ! LHS TARGET
                   IR            = -7
                   IF( NPOLYK(5).EQ.0 ) NPOLYK(5) = NPOLY
               ENDIF
C
C............. POLYGON IS A WALL
               ITAGES(NPOLY) = 2
C
C............. IS POLYGON AN ALBEDO ?
               CALL CHKALB( MALBPG , IALBPG(1)     , IR
     &                    , NPOLY  , ITAGES(NPOLY)      )

C............. POLYGON CREATED FROM TARGET
               MPOLYT(NPOLY) = 4
C
C............. STORE ESCAPE FIGURES FOR START OF TARGET REGIONS
               IF( ITREG.EQ.1 .AND. NPOLYK(5).EQ.0 ) THEN
                   IF( NPOLYK(5).EQ.0 ) NPOLYK(5) = NPOLY   ! LHS
               ELSE IF( ITREG.EQ.3 .AND. NPOLYK(6).EQ.0 ) THEN
                   IF( NPOLYK(6).EQ.0 ) NPOLYK(6) = NPOLY   ! RHS
               ENDIF
C
C-----------------------------------------------------------------------
C-------------------------- FORM SEGMENTS ------------------------------
C-----------------------------------------------------------------------
C
               IF( ISIDE.EQ.1 ) THEN
                   IF( ISEGK(4).EQ.0 ) ISEGK(4) = NSEG   ! RHS
               ELSE
                   IF( ISEGK(3).EQ.0 ) ISEGK(3) = NSEG   ! LHS
               ENDIF
C
               IF( IDTAGM(M,1).EQ.0 ) THEN
                   CALL CHKSEG( LOUT , NSEG , MSEG , 'TARGET' )
                   NSEG          = NSEG + 1
                   ITAGS(NSEG,1) = M
                   ITAGS(NSEG,2) = IVERT(1)
                   ITAGS(NSEG,3) = IVERT(2)
                   ITAGS(NSEG,4) = 1
               ENDIF
C
C-----------------------------------------------------------------------
C--------------------- FINISH NIMBUS POLYGON LOOP ----------------------
C-----------------------------------------------------------------------
C
  200       ENDDO
C
C-----------------------------------------------------------------------
C---------------------- FINISH LOWER VERTEX LOOP -----------------------
C-----------------------------------------------------------------------
C
         ENDDO
C
C-----------------------------------------------------------------------
C---------------------- FINISH TARGET REGION LOOP ----------------------
C-----------------------------------------------------------------------
C
      ENDDO
C
C-----------------------------------------------------------------------
C----------------- UPDATE DATA FOR CORNER POLYGONS ---------------------
C-- (02/03/99)
C-- NB. 1. HORIZONTAL TARGET POLYGON MAY CONTAIN FIVE VERTICES
C--        RATHER THAN FOUR DUE TO VESSEL CUT WHICH WILL BE AT
C--        VERTEX 2 (ON RHS) OR VERTEX 4 (ON LHS).
C--     2. CONSTRUCTION OF LHS CORNER IS UNAFFECTED AS IT USES VERTICES
C--        1 AND 2 OF THE HORIZONTAL POLYGON (I.E. NOT ON CUT SIDE).
C--     3. CONSTRUCTION OF RHS CORNER IS AFFECTED AS IT USES THE LAST
C--        TWO VERTICES (I.E. CUT IS AT 2ND VERTEX AND SO AFFECTS
C--        THOSE ABOVE IT).
C--     4. SO, FOR RHS CORNER NEEDS TO TAKE INTO CONSIDERATION THE
C--        POSSIBILITY OF A VESSEL CUT VERTEX.
C-----------------------------------------------------------------------
C
      DO ISIDE = 1 , 2
C
C....... POLYGONS FORMING CORNER
         MH    = MCORN(ISIDE,1)    ! POLYGON FOR HORIZONTAL SIDE
         MNH   = MCORN(ISIDE,2)    ! POLYGON FOR NON-HORIZONTAL SIDE
C
C....... VERTICES FOR CORNERS (SEE FIGURE IN HEADER FOR EXPLANATION)
C....... (SEE ABOVE NOTE FOR HANDLING OF RHS DIFFERENT TO LHS)
         IF( ISIDE.EQ.1 ) THEN
             IF( MH.GT.0 ) THEN
                 NV   = NVERTM(MH)  ! LAST VERTEX OF POLYGON #NH
             ELSE
                 NV   = 4           ! FOR BACKWARDS COMPATABILITY
             ENDIF
             IVERT(1) = NV    ! RHS HORIZ     UPPER-SIDE PLASMA VERTEX
             IVERT(2) = NV-1  ! RHS HORIZ     UPPER-SIDE EXTRAP VERTEX
             IVERT(3) = 1     ! RHS NON-HORIZ LOWER-SIDE PLASMA VERTEX
             IVERT(4) = 2     ! RHS NON-HORIZ LOWER-SIDE EXTRAP VERTEX
         ELSE
             IVERT(1) = 1     ! LHS HORIZ     UPPER-SIDE PLASMA VERTEX
             IVERT(2) = 2     ! LHS HORIZ     UPPER-SIDE EXTRAP VERTEX
             IVERT(3) = 4     ! LHS NON-HORIZ LOWER-SIDE PLASMA VERTEX
             IVERT(4) = 3     ! LHS NON-HORIZ LOWER-SIDE EXTRAP VERTEX
         ENDIF
C
C....... HORIZONTAL BORDER (FROM HORIZONTAL TARGET POLYGON)
         IF( MH.GT.0 ) THEN
             RCORN(ISIDE,1) = RVERTM(MH,IVERT(1))   ! PLASMA VERTEX
             ZCORN(ISIDE,1) = ZVERTM(MH,IVERT(1))
             RCORN(ISIDE,2) = UDEF                  ! SWITCH OFF VES CUT
             ZCORN(ISIDE,2) = UDEF
             RCORN(ISIDE,3) = RVERTM(MH,IVERT(2))   ! EXTRAP VERTEX
             ZCORN(ISIDE,3) = ZVERTM(MH,IVERT(2))
         ENDIF
C
C....... NON-HORIZONTAL BORDER (FROM NON-HORIZONTAL TARGET POLYGON)
         IF( MNH.GT.0 ) THEN
             RCORN(ISIDE,4) = RVERTM(MNH,IVERT(4))  ! EXTRAP VERTEX
             ZCORN(ISIDE,4) = ZVERTM(MNH,IVERT(4))
             RCORN(ISIDE,5) = RVERTM(MNH,IVERT(3))  ! PLASMA VERTEX
             ZCORN(ISIDE,5) = ZVERTM(MNH,IVERT(3))
C
C....... CORNERS CREATED IMMEDIATELY AFTER THIS ROUTINE
         ELSE IF( IESCF.EQ.0 ) THEN
             RCORN(ISIDE,4) = RSAVE(ISIDE,IVERT(2)) ! EXTRAP VERTEX
             ZCORN(ISIDE,4) = ZSAVE(ISIDE,IVERT(2))
             RCORN(ISIDE,5) = RSAVE(ISIDE,IVERT(1)) ! PLASMA VERTEX
             ZCORN(ISIDE,5) = ZSAVE(ISIDE,IVERT(1))
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(MKTARG) : TARGET POLYGON CREATION !!!!'
     &        / '                     ILLEGAL TARGET REGION' )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKCORG( LOUT
     I                 , MALBPG , IALBPG
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE CORNER ESCAPE FIGURE POLYGONS
C           - -  ---                      -
C PURPOSE : TO CREATE RHS & LHS CORNER ESCAPE FIGURES POLYGONS, THAT IS
C           POLYGONS WHICH BRIDGE HORIZONTAL AND NON-HORIZONTAL
C           POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: CHKALB      = ASSIGNS POLYGON AS AN ALBEDO, IF REQUIRED
C
C NOTES   : 1. CORNER POLYGONS ARE CONSTRUCTED AS FOLLOWS :-
C
C                      4
C                      |\
C                      |  \
C                      |    \
C                      |      \
C                      |  LHS   \
C                      |(ISIDE=2) \
C                      |            \
C                      3------2------1
C                                   (5)
C
C
C                                    4
C                                   /|
C                                 /  |
C                               /    |
C                             /      |
C                           /  RHS   |
C                         /(ISIDE=1) |
C                       /            |
C                      1------2------3
C                     (5)
C
C METHOD  : 1. FEED RCORN(S,IV) INTO RVERTM(,) AND
C              FEED ZCORN(S,IV) INTO ZVERTM(,) BUT IGNORE UDEF
C           2. CORNER IS BUILT UP AS PRESCRIBED IN RCORN & ZCORN
C              WHICH SHOULD BE ANTI-CLOCKWISE FROM VERTEX 1 (OR 5)
C
C           3. LABEL NEW POLYGONS VIA ITAGES & ITAGRM
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 13/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MALBPG
      INTEGER*4 IALBPG(MALBPG)
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 ISIDE , NVERT , IV , IR , IMIN , IMAX , ISTEP
C
C-----------------------------------------------------------------------
C-------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      NPOLYC(1)  = 0   ! LHS  CORNER POLYGON
      NPOLYC(2)  = 0   ! RHS  CORNER POLYGON
C
C-----------------------------------------------------------------------
C---------------------- CREATE LHS & RHS CORNERS -----------------------
C----------- FOR HISTORICAL REASONS LHS IS CREATED BEFORE RHS ----------
C-----------------------------------------------------------------------
C
      DO ISIDE = 2 , 1 , -1
C
C....... CHOSE (ANTI-CLOCKWISE) ORDER OF VERTICES
         IF( ISIDE.EQ.1 ) THEN
             IMIN = 1   ! RHS
             IMAX = 4   ! RHS
         ELSE
             IMIN = 5   ! LHS
             IMAX = 2   ! LHS
         ENDIF
C
C....... SET VERTEX STEP DIRECTION
         IF( IMIN.GT.IMAX ) THEN
             ISTEP = -1
         ELSE
             ISTEP = +1
         ENDIF
C
C-----------------------------------------------------------------------
C------------------------- CREATE NEW POLYGON --------------------------
C-----------------------------------------------------------------------
C
C....... CHECK POLYGON LIMIT
         CALL CKPOLY( LOUT , NPOLY , MPG , 'CORNER' )
C
C....... INCREMENT POLYGON INDEX
         NPOLY         = NPOLY + 1  ! INDEX OF NEW FIGURE
         NVERT         = 0          ! TOTAL NUMBER OF VERTICES
C
C....... VERTICES (IGNORE SWITCHED OFF VERTICES, I.E. UDEF)
         DO IV         = IMIN , IMAX , ISTEP
            IF( RCORN(ISIDE,IV).NE.UDEF ) THEN
                NVERT               = NVERT + 1
                RVERTM(NPOLY,NVERT) = RCORN(ISIDE,IV)
                ZVERTM(NPOLY,NVERT) = ZCORN(ISIDE,IV)
            ENDIF
         ENDDO
C
C....... NUMBER OF VERTICES IN CORNER POLYGON
         IF( NVERT.LE.0 ) THEN
             WRITE(LOUT,9000)
             CALL EXITX(LOUT)
         ELSE
             NVERTM(NPOLY) = NVERT
         ENDIF
C
C-----------------------------------------------------------------------
C---------------- ASSIGN REGIONS TO ALL NEW POLYGONS -------------------
C-----------------------------------------------------------------------
C
C....... POLYGON REGIONAL ASSIGNMENT
         IF( ISIDE.EQ.1 ) THEN
             ITAGRM(NPOLY) = 21     ! POLYGON REGION
             IR            = -4
             NPOLYC(2)     = NPOLY  ! RHS CORNER POLYGON
         ELSE
             ITAGRM(NPOLY) = 22     ! POLYGON REGION
             IR            = -5
             NPOLYC(1)     = NPOLY  ! LHS CORNER POLYGON
         ENDIF
C
C....... POLYGONS ARE WALLS
         ITAGES(NPOLY) = 2
C
C....... IS POLYGON AN ALBEDO ?
         CALL CHKALB( MALBPG , IALBPG(1)     , IR
     &              , NPOLY  , ITAGES(NPOLY)      )
C
C....... POLYGON IS A CORNER
         MPOLYT(NPOLY) = 7
C
C-----------------------------------------------------------------------
C-------------------------- FINISH SIDE LOOP ---------------------------
C-----------------------------------------------------------------------
C
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(MKCORG) : CORNER POLYGON CREATION !!!!'
     &        / '                     NO VERTICES FOUND FOR POLYGON.' )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MATGAP( LOUT , NPOLY )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MATCH GAP
C           ---   ---
C PURPOSE : TO MATCH GAP VERTEX TO NIMBUS WALL POLYGON.  THERE CAN ONLY
C           BE ONE GAP PER NIMBUS POLYGON.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CPUMP/ : (SEE 'cpump')
C
C ROUTINES: CPARR       = COPY 2-D ARRAY TO 1-D
C           IBNDCK      = IS POINT INTERNAL TO POLYGON ?
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 13/11/98 --- CREATION
C           V1.R2.M0 --- 02/03/99 --- TRAP IWGAP(,) = 0
C                                 --- BUG FIX PRINTOUT OF 9010
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CPUMP/
      INCLUDE 'cpump'
C
C..ROUTINES
      INTEGER*4 IBNDCK
C
C..LOCALS
      INTEGER*4 I , I0 , IV , IV0 , M , IER , IPASS , iii
      REAL*8    RGEN(6) , ZGEN(6)
C
C-----------------------------------------------------------------------
C----------------------- CHECK FOR PUMP GAPS ---------------------------
C-----------------------------------------------------------------------
C
      IF( NWGAP.LE.0 ) THEN
          CALL RESETI( IWGAP(1,1) , MWGAP*2 , 0 )
          GOTO 9999
      ENDIF
C
C-----------------------------------------------------------------------
C--------------- LOOP OVER ALL EXTERNAL ESCAPE FIGURES -----------------
C-----------------------------------------------------------------------
C
      DO M = NPOLYK(1) , NPOLY
C
C....... <BEGIN> DISALLOW ALL SPECIAL NIMBUS POLYGONS
         IF( NVERTM(M).GT.0 ) THEN
C
C........... COPY R-COORD VERTICES OF POLYGON #M INTO CYCLIC 1-D ARRAY
             CALL CPARR( MPG     , 5   , M , NVERTM(M) , RVERTM(1,1)
     I                 , .TRUE.  , 6
     O                 , RGEN(1) , IER )
C
             IF( IER.NE.0 ) THEN
                 WRITE(LOUT,9000) 'R' , M , IER
                 CALL EXITX(LOUT)
             ENDIF
C
C........... COPY Z-COORD VERTICES OF POLYGON #M INTO CYCLIC 1-D ARRAY
             CALL CPARR( MPG     , 5   , M , NVERTM(M) , ZVERTM(1,1)
     I                 , .TRUE.  , 6
     O                 , ZGEN(1) , IER )
C
             IF( IER.NE.0 ) THEN
                 WRITE(LOUT,9000) 'Z' , M , IER
                 CALL EXITX(LOUT)
             ENDIF
C
C....... MATCH POLYGON TO GAP
             DO I        = 1 , NWGAP
                DO IV    = 1 , 2
                   IPASS = IBNDCK( LOUT
     I                           , RWGAP(I,IV) , ZWGAP(I,IV)
     I                           , NVERTM(M)+1 , RGEN(1)     , ZGEN(1) )
                   IF( IPASS.GE.0 ) IWGAP(I,IV) = M
                ENDDO
             ENDDO
C
C....... <END> DISALLOW ALL SPECIAL NIMBUS POLYGONS
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C----------- CHECK ALL GAPS VERTICES LIE IN A NIMBUS POLYGON -----------
C-----------------------------------------------------------------------
C
      DO I = 1 , NWGAP
         DO IV = 1 , 2
            IF( IWGAP(I,IV).EQ.0 ) THEN
                WRITE(LOUT,9020) LAWGAP(I)   , IV
     &                         , RWGAP(I,IV) , ZWGAP(I,IV)
                CALL EXITX(LOUT)
            ENDIF
         ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C--------- A POLYGON CAN ONLY CONTAIN, AT MOST, ONE GAP VERTEX ---------
C-----------------------------------------------------------------------
C
C.... <BEGIN> FOCUS GAP FOCUS
      DO I = 1 , NWGAP
C
C....... <BEGIN> LOOP OVER ALL VERTEX OF THIS GAP
         DO IV = 1 , 2
C
C.......... <BEGIN> LOOP OVER ALL THE OTHER GAPS
            DO I0 = 1 , NWGAP
C
C............. <BEGIN> LOOP OVER ALL THE VERTICES OF THESE OTHER GAPS
               DO IV0 = 1 , 2
C
C................ DON'T COMPARE FOCUS WITH ITSELF !!
                  IF( I.EQ.I0 .AND. IV.EQ.IV0 ) GOTO 100
C
C................ CHECK FOR SAME POLYGON (I.E. IWGAP(I,IV)
                  IF( IWGAP(I,IV).EQ.IWGAP(I0,IV0) ) THEN
                     WRITE(LOUT,9010) IWGAP(I,IV) + 2
     &                              , LAWGAP(I)     , IV
     &                              , RWGAP(I,IV)   , ZWGAP(I,IV)
     &                              , LAWGAP(I0)    , IV0
     &                              , RWGAP(I0,IV0) , ZWGAP(I0,IV0)
                     CALL EXITX(LOUT)
                  ENDIF
C
C............. <END> LOOP OVER ALL THE VERTICES OF THESE OTHER GAPS
  100          ENDDO
C
C.......... <END> LOOP OVER ALL THE OTHER GAPS
            ENDDO
C
C....... <BEGIN> LOOP OVER ALL VERTEX OF THIS GAP
         ENDDO
C
C.... <BEGIN> FOCUS GAP FOCUS
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT(/ ' *** ERROR(MATGAP) : INVALID ' , A
     &       , '-COORD ''CPARR'' ARGUMENTS FOR M=' , I5
     &       , '  --> IER=' , I2 /)
 9010 FORMAT(/ ' *** ERROR(MATGAP) : ONLY ONE GAP VERTEX MAY LIE IN'
     &       , ' NIMBUS POLYGON # ' , I5 , ', OFFENDING VERTICES -'
     &       / 21X , 'GAP LABEL = ' , A , '  VERTEX # ' , I2 , ' : ('
     &             , 1PE11.4 , ',' , E11.4 , ')'
     &       / 21X , 'GAP LABEL = ' , A , '  VERTEX # ' , I2 , ' : ('
     &             ,   E11.4 , ',' , E11.4 , ')' /)
 9020 FORMAT(/ ' *** ERROR(MATGAP) : GAP VERTEX DOES NOT LIE IN A'
     &       , ' NIMBUS POLYGON, OFFENDING VERTEX -'
     &       / 21X , 'GAP LABEL = ' , A , '  VERTEX # ' , I2 , ' : ('
     &             , 1PE11.4 , ',' , E11.4 , ')' /)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKGAPG( LOUT
     I                 , RPX    , ZPX
     I                 , MALBPG , IALBPG
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE GAP ESCAPE FIGURES POLYGONS
C           - -  ---                    -
C PURPOSE : TO CREATE RHS & LHS GAP ESCAPE FIGURES POLYGONS, THAT IS
C           POLYGONS WHICH INSIDE ANOTHER EXTERNAL ESCAPE FIGURE
C           POLYGON.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CPUMP/ : (SEE 'cpump')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: CKPOLY      = CHECK POLYGON  LIMITS
C           MATGAP      = MATCH GAP VERTEX TO NIMBUS WALL POLYGON
C           NEARX       = FIND NEAREST OF TWO VERTICES TO A POINT
C
C METHOD  : 1. NEW GAP POLYGONS ARE CREATED IN AN ESCAPE FIGURE
C              CONTAINING A GAP SEGMENT VERTEX.
C           2. GAP VERTICES IN CORNER ESCAPE FIGURES ARE
C              TRIANGULAR.
C           3. GAP VERTICES IN NON-CORNERS ARE RECTANGULAR.
C
C           4. LABEL NEW POLYGONS VIA ITAGES & ITAGRM
C
C NOTES   : 1. GAP SEGMENTS CONSIST OF ONLY TWO VERTICES
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 13/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MALBPG
      INTEGER*4 IALBPG(MALBPG)
      REAL*8    RPX , ZPX
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C../CPUMP/
      INCLUDE 'cpump'
C
C..ROUTINES
      INTEGER*4 NEARX
C
C..LOCALS
      INTEGER*4 I , IV , M , L , NROOT
     &        , ICUT(6)
      REAL*8    RCUT(2) , ZCUT(2)
      LOGICAL   LTRAN
C
C-----------------------------------------------------------------------
C------------------------ INITIALISATION -------------------------------
C-----------------------------------------------------------------------
C
      NPOLYC(7) = 0   ! FIRST POLYGON CONTAINING A GAP VERTEX
      NPOLYC(8) = 0   ! LAST  POLYGON CONTAINING A GAP VERTEX
C
C-----------------------------------------------------------------------
C-------------------- CREATE PUMP GAP POLYGONS ? -----------------------
C-----------------------------------------------------------------------
C
      IF( NWGAP.LE.0 .OR. IGOPT.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C-------------------- MATCH GAP TO ESCAPE FIGURE -----------------------
C-------------------- I.E. FILL IWGAP(IGAP,IVGAP) ----------------------
C-----------------------------------------------------------------------
C
      CALL MATGAP( LOUT , NPOLY )
C
C-----------------------------------------------------------------------
C----------------------- START PUMP GAP LOOP ---------------------------
C-----------------------------------------------------------------------
C
      DO I = 1 , NWGAP
C
C-----------------------------------------------------------------------
C--------------------- START GAP VERTEX LOOP ---------------------------
C-----------------------------------------------------------------------
C
         DO IV = 1 , 2
C
            M     = IWGAP(I,IV)  ! NIMBUS POLYON CONTAINING THIS VERTEX
            LTRAN = .FALSE .     ! CREATE QUAD-SIDED GAP POLYGON ?
C
C-----------------------------------------------------------------------
C---------------- VERTEX OF POLYGON CUTTING GAP SEGMENT ----------------
C-----------------------------------------------------------------------
C
C.......... FIND VERTEX LINE (ICUT(1) TO ICUT(2)) CUTTING GAP SEGMENT
            CALL INTLINJ( M
     I                  , RWGAP(I,1) , ZWGAP(I,1)
     I                  , RWGAP(I,2) , ZWGAP(I,2)
     O                  , RCUT(1)    , ZCUT(1)
     O                  , ICUT(1)    , ICUT(2)
     O                  , NROOT      )
C
C.......... MUST ONLY BE ONE INTERSECTION WITH VERTEX LINE
            IF( NROOT.NE.1 ) THEN
                WRITE(LOUT,9000) NROOT , M+2 , LAWGAP(I)
                CALL EXITX(LOUT)
            ENDIF
C
C.......... PICK VERTEX, ON VERTEX LINE, NEAREST X-POINT
            ICUT(3) = NEARX( LOUT , M , ICUT(1) , ICUT(2) , RPX , ZPX )
C
C-----------------------------------------------------------------------
C---------- VERTEX OF POLYGON CUTTING NORMAL TO GAP VERTEX -------------
C-----------------------------------------------------------------------
C
C.......... FOR NON-CORNER POLYGONS ONLY
            IF( M.NE.NPOLYC(1) .AND. M.NE.NPOLYC(2) ) THEN
C
C.............. FIND VERTEX LINE CUTTING NORMAL TO GAP VERTEX
                CALL INTLINJ( M
     I                      , RWGAP(I,IV) , ZWGAP(I,IV)
     I                      , RPX         , ZWGAP(I,IV)
     O                      , RCUT(2)     , ZCUT(2)
     O                      , ICUT(4)     , ICUT(5)
     O                      , NROOT       )
C
C.............. MUST ONLY BE ONE INTERSECTION WITH VERTEX LINE
                IF( NROOT.NE.1 ) THEN
                    WRITE(LOUT,9010) NROOT , M+2 , LAWGAP(I)
                    CALL EXITX(LOUT)
                ENDIF
C
C.............. VERTEX ON VERTEX LINE MUST BE ICUT(3)
                IF( ICUT(4).EQ.ICUT(3) .OR. ICUT(5).EQ.ICUT(3) ) THEN
                    LTRAN = .TRUE.
                ELSE
                    WRITE(LOUT,9020) M+2 , LAWGAP(I)
                    CALL EXITX(LOUT)
                ENDIF
C
            END IF
C
C-----------------------------------------------------------------------
C---------------------- CREATE NEW POLYGON -----------------------------
C-----------------------------------------------------------------------
C
C.......... CHECK POLYGON LIMIT
            CALL CKPOLY( LOUT , NPOLY , MPG , 'PUMP GAP' )
C
C.......... INCREMENT POLYGON INDEX
            NPOLY = NPOLY + 1  ! INDEX OF NEW FIGURE
C
C.......... 1ST VERTEX OF NEW POLYGON
            RVERTM(NPOLY,1) = RVERTM(M,ICUT(1))
            ZVERTM(NPOLY,1) = ZVERTM(M,ICUT(1))
C
C.......... 2ND VERTEX OF NEW POLYGON
            RVERTM(NPOLY,2) = RVERTM(M,ICUT(2))
            ZVERTM(NPOLY,2) = ZVERTM(M,ICUT(2))
C
C.......... REMAINING VERTICES OF NEW POLYGON (QUAD OR TRI)
            IF( LTRAN ) THEN
                IF( RCUT(2).GT.RPX ) THEN
                    RVERTM(NPOLY,3) = RCUT(2)
                    ZVERTM(NPOLY,3) = ZCUT(2)
                    RVERTM(NPOLY,4) = RWGAP(I,IV)
                    ZVERTM(NPOLY,4) = ZWGAP(I,IV)
                ELSE
                    RVERTM(NPOLY,3) = RWGAP(I,IV)
                    ZVERTM(NPOLY,3) = ZWGAP(I,IV)
                    RVERTM(NPOLY,4) = RCUT(2)
                    ZVERTM(NPOLY,4) = ZCUT(2)
                ENDIF
                NVERTM(NPOLY)       = 4
                RPGAP(I,IV)         = RCUT(2)
                ZPGAP(I,IV)         = ZCUT(2)
            ELSE
                RVERTM(NPOLY,3)     = RWGAP(I,IV)
                ZVERTM(NPOLY,3)     = ZWGAP(I,IV)
                NVERTM(NPOLY)       = 3
                RPGAP(I,IV)         = RVERTM(M,ICUT(3))
                ZPGAP(I,IV)         = ZVERTM(M,ICUT(3))
            ENDIF
C
C-----------------------------------------------------------------------
C---------------- ASSIGN REGIONS TO ALL NEW POLYGONS -------------------
C-----------------------------------------------------------------------
C
C.......... POLYGON REGIONAL ASSIGNMENT
            IF( NPOLYC(7).EQ.0 ) THEN
                NPOLYC(7) = NPOLY  ! FIRST POLYGON CONTAINING GAP VERTEX
            ELSE
                NPOLYC(8) = NPOLY  ! LAST POLYGON  CONTAINING GAP VERTEX
            ENDIF
C
C.......... POLYGON CONTAINING GAP VERTEX
            IMWGAP(I,IV)  = NPOLY
C
C.......... GAP POLYGONS ARE THE SAME AS THE HOST ESCAPE FIGURE
            ITAGES(NPOLY) = ITAGES(M)
            ITAGRM(NPOLY) = ITAGRM(M)
C
C.......... POLYGON IS A PUMP GAP
            MPOLYT(NPOLY) = 8
C
C-----------------------------------------------------------------------
C-------------------- FINISH GAP VERTEX LOOP ---------------------------
C-----------------------------------------------------------------------
C
         ENDDO
C
C-----------------------------------------------------------------------
C---------------------- FINISH PUMP GAP LOOP ---------------------------
C-----------------------------------------------------------------------
C
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT(/ ' *** ERROR(MKGAPG) : INTLINJ HAS FOUND ' , I2
     &       , ' CUTS IN POLYGON ' , I5 , ' BY GAP LINE ' , A / )
 9010 FORMAT(/ ' *** ERROR(MKGAPG) : INTLINJ HAS FOUND ' , I2
     &       , ' CUTS IN POLYGON ' , I5 , ' BY GAP/NORMAL LINE ' , A /)
 9020 FORMAT(/ ' *** ERROR(MKGAPG) : POLYGON SIDES CUT BY "GAP LINE"'
     &       , ' AND "NORMAL TO GAP LINE" DO NOT SHARE A COMMON VERTEX.'
     &       / '                     SITUATION NOT CATERED FOR IN CODE.'
     &       / '                     (POLYGON =' , I6
     &         , ' & GAP LINE =' , A , ')' /)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKCOVG( LOUT   , LPASS  , LPWALL
     I                 , RPX    , ZPX    , PROJ   , EPS
     I                 , MALBPG , IALBPG
     I                 , MPWALL , NPWALL , FPWALL
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE PRIVATE REGION VOID COVER POLYGON
C           - -                      ---       -
C PURPOSE : TO CREATE WALL ESCAPE FIGURE FOR THE AREA BETWEEN THE
C           LHS AND RHS PLASMA POINTS, THAT IS THE PRIVATE REGION
C           VOID COVER
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C           LPWALL      = .T. --- USE ACTUAL PRIVATE REGION VESSEL
C                                 WALL ACROSS THE PRIVATE REGION COVER
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C           EPS         = TOLERENCE LEVEL
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C           MPWALL      = MAXIMUM NUMBER OF EXTRA POINTS TO INSERT
C                         IN THE LINE JOINING THE EXTRAPOLATIONS OF
C                         THE PROVATE REGION VESSEL WALL END-POINTS
C           NPWALL      = ACTUAL NUMBER OF THE ABOVE
C           FPWALL()    = FRACTIONAL POSITIONS ALONG THE ABOVE LINE
C                         (MONOTONIC AND IN THE EXCLSUIVE RANGE (0,1)
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: MKSCOV      = SIMPLE  PRIVATE REGION COVER
C           VESCOV      = COMPLEX PRIVATE REGION COVER
C
C METHOD  : 1. CREATE A SIMPLE 4-SIDED POLYGON.
C           2. THEN REPLACE WITH BY MORE COMPLEX POLYGONS MATCHING
C              THE VESSEL (LPWALL = .TRUE.).
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 16/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MALBPG , MPWALL , NPWALL
      INTEGER*4 IALBPG(MALBPG)
      REAL*8    RPX , ZPX , PROJ , EPS , FPWALL(MPWALL)
      LOGICAL   LPASS , LPWALL
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      LOGICAL   LBREC
C
C..LOCALS
      INTEGER*4 M , IR
C
C-----------------------------------------------------------------------
C----------- CREATE SIMPLE 4-SIDED POLYGON FOR PRIVATE COVER -----------
C-----------------------------------------------------------------------
C
      CALL MKSCOV( LOUT
     I           , RPX   , ZPX , PROJ
     O           , NPOLY )
C
C-----------------------------------------------------------------------
C--------- REPLACE SIMPLE 4-SIDED POLYGON BY ONES DUE TO VESSEL --------
C-----------------------------------------------------------------------
C
      IF( LPWALL .AND. NVES.GT.0 ) THEN
          CALL VESCOV( LOUT   , LPASS
     I               , RPX    , ZPX    , PROJ      , EPS
     I               , MPWALL , NPWALL , FPWALL(1)
     O               , NPOLY  )
      ENDIF
C
C-----------------------------------------------------------------------
C-------------------------- ASSIGN ALBEDOS -----------------------------
C-----------------------------------------------------------------------
C
      DO M  = NPOLYK(7) , NPOLY
         IR = -1
         CALL CHKALB( MALBPG , IALBPG(1) , IR
     &              , M      , ITAGES(M)      )
      ENDDO
C
C-----------------------------------------------------------------------
C------------- UPDATE DATA FOR POSSIBLE CORNER POLYGONS ----------------
C------- (IF "IESCF = 0" THEN CORNER HAS ALREADY BEEN GENERATED)--------
C-----------------------------------------------------------------------
C
      IF( IESCF.EQ.1 ) CALL CORCOV( LOUT , NPOLY )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKSCOV( LOUT
     I                 , RPX    , ZPX    , PROJ
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE SIMPLE PRIVATE REGION VOID COVER POLYGON
C           - -  -                     ---       -
C PURPOSE : TO CREATE A SIMPLE 4-SIDED WALL ESCAPE FIGURE FOR THE AREA
C           BETWEEN THE LHS AND RHS PLASMA POINTS, THAT IS THE
C           PRIVATE REGION VOID COVER
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: LBREC       = CHECK IF POINT IS INSIDE NIMBUS RECTANGLE
C           CKPOLY      = CHECK POLYGON  LIMITS
C
C METHOD  : 1. TAKE THE LAST PLASMA POINTS ON THE LHS & RHS OF THE
C              PRIVATE REGION.
C           2. EXTRAPOLATE THESE TWO TIPS FROM THE X-POINT.
C           3. JOIN THE TWO TIPS AND THEIR EXTRAPOLATED VALUES.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 18/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
      REAL*8    RPX , ZPX , PROJ
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      LOGICAL   LBREC
C
C..LOCALS
      INTEGER*4 I , J , IV , LV
      REAL*8    XPROJ
      LOGICAL   LTRAN
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C-----------------------------------------------------------------------
C
      CALL CKPOLY( LOUT , NPOLY , MPG , 'PRIVATE REGION WALL COVER' )
C
C-----------------------------------------------------------------------
C------------------------- INITIALISATION ------------------------------
C-----------------------------------------------------------------------
C
      I = NXWPG + 1              ! FIRST VERTEX TING IN PRIVATE REGION
C
C-----------------------------------------------------------------------
C---------------------- CREATE NEW POLYGON -----------------------------
C-----------------------------------------------------------------------
C
C.... INCREMENT POLYGON INDEX
      NPOLY         = NPOLY + 1  ! INDEX OF NEW FIGURE
      NVERTM(NPOLY) = 4          ! NO. OF VERTICES
C
C.... 1ST VERTEX : FROM RHS TIP
      RVERTM(NPOLY,1) = RPOLY( I , NJPOLY(I) )
      ZVERTM(NPOLY,1) = ZPOLY( I , NJPOLY(I) )
C
C.... 4TH VERTEX : FROM LHS TIP
      RVERTM(NPOLY,4) = RPOLY( I , 1 )
      ZVERTM(NPOLY,4) = ZPOLY( I , 1 )
C
C.... 2ND/3RD VERTEX : EXTRAPOLATION FROM X-POINT OR PLASMA CENTRE
      XPROJ = PROJ
C
      DO IV = 2 , 3
C
         IF( IV.EQ.2 ) THEN
             LV = 1  ! VERTEX 2 IS EXTRAPOLATED FROM VERTEX 1
         ELSE
             LV = 4  ! VERTEX 3 IS EXTRAPOLATED FROM VERTEX 4
         ENDIF
C
  200    RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                    + ( RVERTM(NPOLY,LV) - RPX ) * XPROJ
         ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
     &                    + ( ZVERTM(NPOLY,LV) - ZPX ) * XPROJ
C
C....... INCREASE XPROJ UNTIL VERTEX LIES OUTSIDE NIMBUS RECT.
         LTRAN = LBREC( RVERTM(NPOLY,IV) , ZVERTM(NPOLY,IV)
     &                , GEOM(1)          , GEOM(2)
     &                , GEOM(1)+GEOM(3)  , GEOM(2)+GEOM(4) )
C
         IF( LTRAN ) THEN
             XPROJ = 1.5D+00 * XPROJ  ! INCREASE PROJECTION
             GOTO 200
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C----------- ASSEMBLE SIMPLE INFINITY LINE (ANTI-CLOCKWISE) ------------
C--------------- I.E. FROM RVERTM(M,2) TO RVERTM(M,3) ------------------
C-----------------------------------------------------------------------
C
C.... FIRST VERTEX OF INFINITY LINE
      NINF       = 1
      RINF(NINF) = RVERTM(NPOLY,3)     ! LHS
      ZINF(NINF) = ZVERTM(NPOLY,3)
C
C.... LAST VERTEX
      NINF       = NINF + 1
      RINF(NINF) = RVERTM(NPOLY,2)     ! RHS
      ZINF(NINF) = ZVERTM(NPOLY,2)
C
C-----------------------------------------------------------------------
C------------------------ MARK THIS POLYGON ----------------------------
C-----------------------------------------------------------------------
C
      NPOLYK(7)     = NPOLY  ! 1ST POLYGON OF PRIVATE REGION COVER
      NPOLYK(8)     = 1      ! NUMBER OF POLYGONS IN COVER
C
C-----------------------------------------------------------------------
C-------------------- ASSIGN REGION TO NEW POLYGON ---------------------
C-----------------------------------------------------------------------
C
      ITAGRM(NPOLY) = 11     ! PRIVATE REGION VOID COVER
      ITAGES(NPOLY) = 2      ! WALL POLYGON
      MPOLYT(NPOLY) = 5      ! POLYGON CREATED FROM PRIVATE COVER
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE VESCOV( LOUT   , LPASS
     I                 , RPX    , ZPX    , PROJ   , EPS
     I                 , MPWALL , NPWALL , FPWALL
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : VESSEL IN PRIVATE REGION COVER
C           ---                      ---
C PURPOSE : TO TAKE THE FOUR-SIDED PRIVATE REGION COVER POLYGON AND
C           SPLIT IT TO MATCH THE VESSEL IN THIS REGION.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C           EPS         = TOLERENCE LEVEL
C
C           MPWALL      = MAXIMUM NUMBER OF EXTRA POINTS TO INSERT
C                         IN THE LINE JOINING THE EXTRAPOLATIONS OF
C                         THE PROVATE REGION VESSEL WALL END-POINTS
C           NPWALL      = ACTUAL NUMBER OF THE ABOVE
C           FPWALL()    = FRACTIONAL POSITIONS ALONG THE ABOVE LINE
C                         (MONOTONIC AND IN THE EXCLSUIVE RANGE (0,1)
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: PYTHGS      = DISTANCE BETWEEN TWO POINTS
C           FXPOLY      = CREATE POLYGONS BEWTEEN TWO BOUNDARIES
C
C METHOD  : 1. TAKE PRIVATE REGION VOID COVER POLYGON (4-SIDED)
C              AND CREATE A 6-SIDED POLYGON EXTENDED ON BOTH ENDS TO
C              THE X-POINT.
C           2. FIND INTERSECTION OF ABOVE WITH VESSEL.
C           3. GET INFINITY LINE (LEFT TO RIGHT).
C           4. GET PRIVATE REGION VESSEL/VOID INTERFACE (LEFT TO RIGHT).
C           5. CREATE POLYGONS BETWEEN 3. & 4 USING S.R. 'FXPOLY'.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 16/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MPWALL , NPWALL
      REAL*8    RPX , ZPX , PROJ , EPS , FPWALL(MPWALL)
      LOGICAL   LPASS
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      REAL*8    PYTHGS
C
C..PARAMETERS
      INTEGER*4 MROOT
      PARAMETER( MROOT = 3 )
C
C..LOCALS
      INTEGER*4 M , NV , NROOT , IV , ISTART , ISTOP , IER , IR
     &        , ICUT1(4*MWAL)  , ICUT2(4*MWAL)
      REAL*8    RV(6) , ZV(6) , RCUT(MROOT) , ZCUT(MROOT)
     &        , DIST(2)
      LOGICAL   LINIT
C
C..DATA
      DATA LINIT/ .TRUE. /
C
C-----------------------------------------------------------------------
C------------------------- INITIALISATION ------------------------------
C-----------------------------------------------------------------------
C
      M = NPOLY   ! THE SIMPLE 4-SIDED POLYGON REPRESENTING VOID COVER
C
C-----------------------------------------------------------------------
C-------------------------- CHECK INPUT --------------------------------
C-----------------------------------------------------------------------
C
      IF( NVES.LE.0 ) GOTO 9999
C
      IF( ITAGRM(M).NE.11 ) THEN
          WRITE(LOUT,9000) M+2 , ITAGRM(M)
          CALL EXITX(LOUT)
      ENDIF
C
      IF( NVERTM(M).NE.4 ) THEN
          WRITE(LOUT,9010) M+2 , NVERTM(M)
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C--------------- EXTENT VOID COVER POLYGON TO X-POINT ------------------
C------------------- (THIS IS A SIX-SIDED SHAPE) -----------------------
C-----------------------------------------------------------------------
C
C.... 1ST VERTEX
      NV     = 1
      RV(NV) = RPX
      ZV(NV) = ZPX
C
C.... VERTICES 2 TO NVERTN(M)+1
      DO IV = 1 , NVERTM(M)
         NV       = NV + 1
         RV(IV+1) = RVERTM(M,IV)
         ZV(IV+1) = ZVERTM(M,IV)
      ENDDO
C
C.... LAST VERTEX = 1ST VERTEX, I.E CLOSES THE POLYGON
      NV     = NV + 1
      RV(NV) = RV(1)
      ZV(NV) = ZV(1)
C
C-----------------------------------------------------------------------
C--------- FIND VESSEL POINTS BETWEEN RHS & LHS PLASMA TIPS ------------
C---------- I.E. BETWEEN POINTS RVERTM(M,1) & RVERTM(M,4) --------------
C-----------------------------------------------------------------------
C
C.... VESSEL INTERSECTION WITH EXTENDED POLYGON
C.... NB. ICUT1(1) = VESSEL VERTEX BEFORE 1ST CUT
C....     ICUT1(2) = VESSEL VERTEX BEFORE 2ND CUT
      CALL ROOT( NVES     , RVES(1)  , ZVES(1)
     &         , NV       , RV(1)    , ZV(1)
     &         , MROOT    , RCUT(1)  , ZCUT(1)
     &         , ICUT1(1) , ICUT2(1) , NROOT   )
C
C.... ONLY TWO CUTS ARE ALLOWED (A LHS AND A RHS CUT = PLASMA TIPS)
      IF( NROOT.NE.2 ) THEN
          WRITE(LOUT,9020) NROOT
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C---------- ASSEMBLE COMPLEX INFINITY LINE (ANTI-CLOCKWISE) ------------
C--------------- I.E. FROM RVERTM(M,2) TO RVERTM(M,3) ------------------
C-----------------------------------------------------------------------
C
C.... FIRST VERTEX OF INFINITY LINE
      NINF       = 1
      RINF(NINF) = RVERTM(M,3)
      ZINF(NINF) = ZVERTM(M,3)
C
C.... EXTRA VERTICES ON THE INFINITY LINE
      DO IV         = 1 , NPWALL
         NINF       = NINF + 1
         RINF(NINF) = RVERTM(M,3)
     &              + FPWALL(IV) * ( RVERTM(M,2) - RVERTM(M,3) )
         ZINF(NINF) = ZVERTM(M,3)
     &              + FPWALL(IV) * ( ZVERTM(M,2) - ZVERTM(M,3) )
      ENDDO
C
C.... LAST VERTEX
      NINF       = NINF + 1
      RINF(NINF) = RVERTM(M,2)
      ZINF(NINF) = ZVERTM(M,2)
C
C-----------------------------------------------------------------------
C-------- ASSEMBLE VOID/VESSEL INTERFACE LINE (ANTI-CLOCKWISE) ---------
C--------------- I.E. FROM RVERTM(M,1) TO RVERTM(M,4) ------------------
C-----------------------------------------------------------------------
C
C.... FIRST VERTEX OF VOID/VESSEL INTERFACE LINE  (LHS)
      NWAL        = 1
      RWAL(NWAL)  = RVERTM(M,4)
      ZWAL(NWAL)  = ZVERTM(M,4)
      IVWAL(NWAL) = 0
C
C.... NEXT VERTICES ARE ALL VESSEL POINTS ICUT1(1) & ICUT1(2)
      IF( ICUT1(1).NE.ICUT1(2) ) THEN
C
C........ VESSEL VERTEX RANGE (REMEMBER CYCLIC NATURE OF VESSEL)
          ISTART = ICUT1(1)  ! VESSEL VERTEX BEFORE 1ST CUT
          ISTOP  = ICUT1(2)  ! VESSEL VERTEX AFTER  2ND CUT
C
C........ CHECK IF ISTART IS LAST VESSEL VERTEX
          IF( ISTART.EQ.NVES ) THEN
              ISTART = 1
          ELSE IF( ISTOP .EQ.NVES ) THEN
              ISTOP  = 1
          ENDIF
C
C........ LOOP OVER VESSEL VERTICES FROM ISTART+1 TO ISTOP
          IV = ISTART + 1
C
C........ CHECK IF IV IS LAST VESSEL VERTEX
  100     IF( IV.EQ.NVES ) IV = 1
C
C........ DISTANCE OF IV FROM CUTS
          DIST(1) = PYTHGS( RVERTM(M,1) , ZVERTM(M,1)
     &                    , RVES(IV)    , ZVES(IV)    )
          DIST(2) = PYTHGS( RVERTM(M,4) , ZVERTM(M,4)
     &                    , RVES(IV)    , ZVES(IV)    )
C
C........ DON'T INCLUDE POINTS ON OR VERY NEAR CUTS
          IF( DIST(1).LE.EPS .OR. DIST(2).LE.EPS ) THEN
              GOTO 200
          ELSE
              NWAL        = NWAL + 1
              RWAL(NWAL)  = RVES(IV)
              ZWAL(NWAL)  = ZVES(IV)
              IVWAL(NWAL) = IV
          ENDIF
C
C........ INCREMENT VESSEL VERTEX INDEX
  200     IV = IV + 1
C
C........ GET NEXT VERTEX ?
          IF( IV.NE.ISTOP+1 ) GOTO 100
C
      ENDIF
C
C.... LAST VERTEX OF VOID/VESSEL INTERFACE LINE (RHS)
      NWAL        = NWAL + 1
      RWAL(NWAL)  = RVERTM(M,1)
      ZWAL(NWAL)  = ZVERTM(M,1)
      IVWAL(NWAL) = 0
C
C.... CHECK ORDER OF WALL IS FROM LHS (LOW R) TO RHS (HIGH R)
      IF( RWAL(1).GT.RWAL(NWAL) ) THEN
          CALL REVERS( NWAL , RWAL(1)  )
          CALL REVERS( NWAL , ZWAL(1)  )
          CALL REVERI( NWAL , IVWAL(1) )
      ENDIF
C
C-----------------------------------------------------------------------
C------------------ DIAGNOSTICS (FIRST ENTRY ONLY) ---------------------
C-----------------------------------------------------------------------
C
      IF( LINIT ) THEN
C
          WRITE(LOUT,*)
          WRITE(LOUT,2000)
C
C....... VOID/VESSEL INTERFACE LINE
          WRITE(LOUT,2010)
          DO IV = 1 , NWAL
             WRITE(LOUT,1000) IV , RWAL(IV) , ZWAL(IV)
          ENDDO
C
C....... INFINITY LINE
          WRITE(LOUT,2020)
          DO IV = 1 , NINF
             WRITE(LOUT,1000) IV , RINF(IV) , ZINF(IV)
          ENDDO
C
          WRITE(LOUT,2000)
C
          LINIT = .FALSE.
C
      ENDIF
C
C-----------------------------------------------------------------------
C----------------- CREATE NEW POLYGONS DUE TO VESSEL -------------------
C-----------------------------------------------------------------------
C
      IF( NWAL.GT.2 ) THEN
          CALL FXCOV( LOUT  , LPASS
     I              , RPX   , ZPX   , PROJ
     O              , NPOLY )
      ENDIF
C
C-----------------------------------------------------------------------
C---------------- ASSIGN REGIONS TO ALL NEW POLYGONS -------------------
C------------- SAME SETTINGS ARE SIMPLE 4-SIDED POLYGON ----------------
C-----------------------------------------------------------------------
C
C.... NB. NPOLYK(8) WAS INITIALISED WHEN NPOLYK(7) WAS DEFINED
      DO M         = NPOLYK(7) + 1 , NPOLY
         NPOLYK(8) = NPOLYK(8) + 1        ! NUMBER OF POLYGONS IN COVER
         ITAGRM(M) = ITAGRM( NPOLYK(7) )
         MPOLYT(M) = MPOLYT( NPOLYK(7) )  ! PRIVATE COVER
      ENDDO
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( 4X , I2 , '.   (' , F11.2 , ',' , F11.2 , ')' )
C
 2000 FORMAT( 1X , 126('-') )
 2010 FORMAT(   ' PRIVATE REGION VOID/VESSEL INTERFACE :-' )
 2020 FORMAT( / ' PRIVATE REGION INFINITY    BOUNDARY  :-' )
C
 9000 FORMAT( / ' *** ERROR(VESCOV) : POLYGON (' , I6
     &        , ') IS NOT A PRIVATE REGION COVER, ITAGRM =' , I4 )
 9010 FORMAT( / ' *** ERROR(VESCOV) : POLYGON (' , I6
     &        , ') MUST BE FOUR-SIDED, NVERT =' , I4 )
 9020 FORMAT( / ' *** ERROR(VESCOV) : UNABLE TO USE VESSEL WALL IN'
     &        , ' PRIVATE REGION. --- NROOT =' , I2 /)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKVOIG( LOUT   , LPASS  , LPWALL , LPSEG
     I                 , MSEG   , MTAGS2 , IALB
     O                 , NSEG   , ITAGS
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE PRIVATE REGION VOID POLYGONS
C           - -                 ---      -
C PURPOSE : TO CREATE A ESCAPE FIGUES(S) FOR THE PROVATE REGION VOID.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C           LPWALL      = .T. --- USE ACTUAL PRIVATE REGION VESSEL
C                                 WALL ACROSS THE PRIVATE REGION COVER
C           LPSEG       = .T. --- EXPLICIT SOURCE SEGMENTS AROUND
C                                 PRIVATE VOID/ALBEDO/WALL REGION
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C
C           MSEG        = MAX. NUMBER OF SEGMENTS
C           MTAGS2      = 2ND DIMENSION OF ITAGS(,)
C
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C
C I/O     : NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: MKSVOI      = SIMPLE PRIVATE VOID REGION
C           VESVOI      = COMPLEX PROVATE VOID REGION
C
C METHOD  : 1. CREATE A SPECIAL POLYGON FOR THE PRIVATE VOID REGION.
C           2. THEN REPLACE WITH BY MORE COMPLEX POLYGONS MATCHING
C              THE VESSEL (LPWALL = .TRUE.).
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 17/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
     &        , MSEG  , MTAGS2 , IALB
      LOGICAL   LPASS , LPWALL , LPSEG
C
C..I/O
      INTEGER*4 NSEG , ITAGS(MSEG,MTAGS2) , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
C
C..LOCALS
C
C-----------------------------------------------------------------------
C------------ CREATE SPECIAL POLYGON FOR THE PRIVATE VOID --------------
C-----------------------------------------------------------------------
C
      CALL MKSVOI( LOUT  , LPSEG
     I           , MSEG  , MTAGS2 , IALB
     O           , NSEG  , ITAGS
     O           , NPOLY )
C
C-----------------------------------------------------------------------
C----------- REPLACE SIMPLE POLYGON BY ONES DUE TO VESSEL --------------
C-----------------------------------------------------------------------
C
      IF( LPWALL .AND. NWAL.GT.0 .AND. NVES.GT.0 ) THEN
         CALL VESVOI( LOUT   , LPASS
     O               , NPOLY  )
      ENDIF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKSVOI( LOUT   , LPSEG
     I                 , MSEG   , MTAGS2 , IALB
     O                 , NSEG   , ITAGS
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE SIMPLE PRIVATE REGION VOID POLYGON
C           - -                        ---      -
C PURPOSE : TO CREATE A SPECIAL POLYGON FOR THE PRIVATE VOID REGION.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPSEG       = .T. --- EXPLICIT SOURCE SEGMENTS AROUND
C                                 PRIVATE VOID/ALBEDO/WALL REGION
C
C           MSEG        = MAX. NUMBER OF SEGMENTS
C           MTAGS2      = 2ND DIMENSION OF ITAGS(,)
C
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C
C I/O     : NSEG        = TOTAL NUMBER OF SOURCE SEGMENTS
C           ITAGS(IS,1) = NON-ESCAPE FIGURE NIMBUS POLYGON ASSOCIATED
C                         WITH SOURCE SEGMENT 'IS'
C                (IS,2) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 1ST POINT OF SOURCE SEGMENT
C                (IS,3) = VERTEX OF ASSOCIATED NIMBUS POLYGON
C                         CORRESPONDING TO 2ND POINT OF SOURCE SEGMENT
C                (IS,4) = 0 --- PERPENDICULAR SEGMENT
C                       = 1 --- POLOIDAL SEGMENT
C                       = 2 --- DIVERTOR SEGMENT (NO LONGER PRESENT)
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: GETVTX      = FIND ON WHICH VERTEX RING A POLYGON
C                         VERTEX LIES (I.E. IP1 OR I)
C           CKPOLY      = CHECK POLYGON  LIMITS
C
C METHOD  : 1. POLYGON IS A SPECIAL POLYGON DESCRIBING THE PARAMETER
C              OF THE PRIVATE VOID REGION.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 17/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
     &        , MSEG  , MTAGS2 , IALB
      LOGICAL   LPSEG
C
C..I/O
      INTEGER*4 NSEG , ITAGS(MSEG,MTAGS2) , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
C
C..LOCALS
      INTEGER*4 I , IP1 , J , ITYPG , NVERT
     &        , N , M , L , NI , NIP1 , IVERT(4)
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C-----------------------------------------------------------------------
C
      CALL CKPOLY( LOUT , NPOLY , MPG , 'PRIVATE VOID' )
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      NPOLY         = NPOLY + 1    ! INDEX OF NEW FIGURE
      ITYPG         = 4            ! SPECIAL POLYGON INDEX
      NVERTM(NPOLY) = -ITYPG       ! IDENITIFY SPECIAL POLYGON
C
      I             = NXWPG + 1    ! LOWER VERTEX RING OF NXWPG + 1
      IP1           = I + 1        ! UPPER VERTEX RING OF NXWPG + 1
C
      ISEGK(7)      = NSEG         ! LAST SEGMENT BEFORE PRIVATE VOID
C
C-----------------------------------------------------------------------
C--------- CONSTRUCT SPECIAL POLYGON SURROUNDING PRIVATE VOID ----------
C-----------------------------------------------------------------------
C
      NVERT         = 0            ! NUMBER OF VERTICES IN FIGURE
C
      DO J          = 1 , NJPOLY(I)
         NVERT      = NVERT + 1
         RVERTG(ITYPG,NVERT) = RPOLY(I,J)
         ZVERTG(ITYPG,NVERT) = ZPOLY(I,J)
      ENDDO
C
      NVERTG(ITYPG) = NVERT        ! NO. OF VERTICES IN FIGURE
C
C-----------------------------------------------------------------------
C-------------------------- FORM SEGMENTS ------------------------------
C-----------------------------------------------------------------------
C
C.... FOLLOW SEGMENTS AROUND PRIVATE VOID
      IF( LPSEG ) THEN
C
C.... <BEGIN> LOOP OVER PLASMA POLYGONS IN RING #I
          DO J = 1 , NJP(I)
             N = KORP(I,J)
C
C........... <BEGIN> LOOP OVER NIMBUS POLYGONS IN PLASMA POLYGON #N
             DO L = 1 , NM(N)
                M = KORM(N,L)
C
C.............. FIND WHICH VERTICES LIE ON UPPER AND LOWER VERTEX RINGS
                CALL GETVTX( NVERTM(1) , ITAGM(1,1) , MPG
     &                     , M         , I          , IP1
     &                     , NIP1      , IVERT(1)   , IVERT(2)
     &                     , NI        , IVERT(3)   , IVERT(4) )
C
C.............. SEGMENTS FROM POLYGONS WITH TWO VERTICES IN RING #I
                IF( NI.EQ.2 ) THEN
                    CALL CHKSEG( LOUT , NSEG , MSEG , 'PRIVATE VOID' )
                    NSEG          = NSEG + 1
                    ITAGS(NSEG,1) = M
                    ITAGS(NSEG,2) = IVERT(3)
                    ITAGS(NSEG,3) = IVERT(4)
                    ITAGS(NSEG,4) = 0
                ENDIF
C
C........... <END> LOOP OVER NIMBUS POLYGONS IN PLASMA POLYGON #N
             ENDDO
C
C........ <END> LOOP OVER PLASMA POLYGONS IN RING #I
          ENDDO
C
      ENDIF
C
C-----------------------------------------------------------------------
C------------------------ MARK THIS POLYGON ----------------------------
C-----------------------------------------------------------------------
C
      NPOLYK(9)     = NPOLY  ! 1ST POLYGON OF PRIVATE VOID
      NPOLYK(10)    = 1      ! NUMBER OF POLYGONS IN PRIVATE VOID
C
C-----------------------------------------------------------------------
C-------------------- ASSIGN REGION TO NEW POLYGON ---------------------
C-----------------------------------------------------------------------
C
      IF( IALB.EQ.1 ) THEN
          ITAGES(NPOLY) = 3   ! PRIVATE VOID IS DEFINED AS AN ALBEDO
      ELSE IF( IALB.EQ.2 ) THEN
          ITAGES(NPOLY) = 1   ! PRIVATE VOID IS DEFINED AS A VOID
      ELSE
          ITAGES(NPOLY) = 2   ! PRIVATE VOID IS DEFINED AS A WALL
      ENDIF
C
      ITAGRM(NPOLY)     = 14  ! PRIVATE VOID REGION
      MPOLYT(NPOLY)     = 6   ! POLYGON CREATED BY PRIVATE VOID
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE VESVOI( LOUT   , LPASS
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : VESSEL IN PRIVATE VOID
C           ---               ---
C PURPOSE : TO TAKE THE SPECIAL PRIVATE VOID POLYGON AND SPLIT IT
C           TO MATCH THE VESSEL AT THE COVER OF THIS REGIO.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: GETVTX      = FIND ON WHICH VERTEX RING A POLYGON
C                         VERTEX LIES (I.E. IP1 OR I)
C           CKPOLY      = CHECK POLYGON  LIMITS
C           FXPOLY      = CREATE POLYGONS BEWTEEN TWO BOUNDARIES
C
C METHOD  : 1. GET PLASMA/PRIVATE VOID INTERFACE.
C           2. GET VESSEL/VOID INTERFACE BUT DROP FIRST AND LAST POINTS
C              AS THESE ARE ON 1.
C           3. CREATE POLYGONS BETWEEN 1. & 2 USING S.R. 'FXPOLY'.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 17/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
     &        , MSEG  , MTAGS2 , IALB
      LOGICAL   LPASS
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..PARAMETERS
      INTEGER*4 MLINE
      PARAMETER( MLINE = MRG )
C
C
C..LOCALS
      INTEGER*4 ITYPG , IER , NPLINE , NVLINE , M , IV
     &        , LTOP(4*MLINE)
      REAL*8    RPLINE(MLINE) , ZPLINE(MLINE)
     &        , RVLINE(MLINE) , ZVLINE(MLINE)
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C-----------------------------------------------------------------------
C
      CALL CKPOLY( LOUT , NPOLY , MPG , 'PRIVATE VOID' )
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      ITYPG         = ABS( NVERTM(NPOLY) )
C
C-----------------------------------------------------------------------
C-------------------- CREATE 1-D INTERFACE LINES -----------------------
C-----------------------------------------------------------------------
C
C.... PLASMA/VOID INTERFACE LINE
      NPLINE        = NVERTG(ITYPG)
      IF( NPLINE.GT.MLINE ) THEN
          WRITE(LOUT,9000) NPLINE
          CALL EXITX(LOUT)
      ENDIF
C
      DO IV         = 1 , NVERTG(ITYPG)
         RPLINE(IV) = RVERTG(ITYPG,IV)
         ZPLINE(IV) = ZVERTG(ITYPG,IV)
      ENDDO
C
C.... VESSEL/VOID INTERFACE LINE
C.... (NOT 1ST/LAST POINTS AS THESE ARE IN THE PLASMA/VOID LINE)
      NVLINE        = MAX( NWAL - 2 , 0 )
      IF( NVLINE.GT.MLINE ) THEN
          WRITE(LOUT,9000) NVLINE
          CALL EXITX(LOUT)
      ENDIF
C
      DO IV         = 1 , NWAL-2
         RVLINE(IV) = RWAL(IV+1)
         ZVLINE(IV) = ZWAL(IV+1)
      ENDDO
C
C-----------------------------------------------------------------------
C----------------- CREATE NEW POLYGONS DUE TO VESSEL -------------------
C-----------------------------------------------------------------------
C
      CALL FXPOLY( LOUT        , 1           , LPASS
     I           , MPG         , MRG         , MLINE
     I           , NVLINE      , RVLINE(1)   , ZVLINE(1)
     I           , NPLINE      , RPLINE(1)   , ZPLINE(1)
     O           , NPOLY       , NVERTM(1)
     O           , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O           , LTOP(1)     , IER         )
C
      IF( IER.NE.0 ) THEN
          WRITE(LOUT,9010) ' VOID ' , IER
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C---------------- ASSIGN REGIONS TO ALL NEW POLYGONS -------------------
C------------ SAME SETTINGS ARE ORIGINAL SPECIAL POLYGON ---------------
C-----------------------------------------------------------------------
C
C.... NB. NPOLYK(10) WAS INITIALISED WHEN NPOLYK(9) WAS DEFINED
      DO M          = NPOLYK(9) + 1 , NPOLY
         NPOLYK(10) = NPOLYK(10) + 1         ! NO. OF POLYGONS IN COVER
         ITAGRM(M)  = ITAGRM( NPOLYK(9) )
         MPOLYT(M)  = MPOLYT( NPOLYK(9) )
      ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(VESVOI) : PRIVATE VOID CREATION !!!!'
     &        / '                     INCREASE MLINE ABOVE (' , I7 , ')'
     &        )
 9010 FORMAT( / ' *** ERROR(VESVOI) : UNABLE TO SET PRIVATE REGION'
     &        , A , 'POLYGONS --- IER =' , I2
     &        / 21X , 'TRY CHANGING NPWALL & FPWALL() IN /NIMBIN/' /)
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MKBAFG( LOUT  , LBUFLE
     I                 , IALB
     O                 , NPOLY )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE BAFFLE POLYGONS
C           - -  ---        -
C PURPOSE : TO ESSENTIALLY MAKE THE BAFFLE(S) POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LBUFLE      = .T. --- SWITCH ON BAFFLE (NEED IALB = 2)
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 19/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , IALB
      LOGICAL   LBUFLE
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 IB
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C------- BAFFLE'S ONLY EXIST IN PRIVATE VOID REGION MARKED VOID --------
C-----------------------------------------------------------------------
C
      IF( .NOT.LBUFLE .OR. IALB.NE.2 ) GOTO 9999
C
C-----------------------------------------------------------------------
C-------------------- ASSIGN REGIONS TO MAIN BAFFLE --------------------
C-----------------------------------------------------------------------
C
      IF( NBUFLE.GT.0 ) THEN
C
C........ CHECK POLYGON LIMIT
          CALL CKPOLY( LOUT , NPOLY , MPG , 'MAIN BAFFLE' )
C
C........ INCREMENT POLYGON INDEX
          NPOLY  = NPOLY  + 1    ! INDEX OF NEW FIGURE
C
C........ ASSIGN VERTEX
          NVERTM(NPOLY) = -100 ! MAIN BAFFLE
C
C........ ASSIGN REGIONS
          ITAGRM(NPOLY) = 13   ! POLYGON IS A BAFFLE
          ITAGES(NPOLY) = 2    ! POLYGON IS A WALL
C
C........ POLYGON CREATED BY BAFFLES
          MPOLYT(NPOLY) = 9    ! BAFFLE
C
      ENDIF
C
C-----------------------------------------------------------------------
C------------------- ASSIGN REGIONS TO EXTRA BAFFLES -------------------
C-----------------------------------------------------------------------
C
      DO IB = 1 , NBUFMX
C
         IF( NBUFX(IB).GT.0 ) THEN
C
C........... CHECK POLYGON LIMIT
             CALL CKPOLY( LOUT , NPOLY , MPG , 'EXTRA BAFFLES' )
C
C........... INCREMENT POLYGON INDEX
             NPOLY  = NPOLY  + 1              ! INDEX OF NEW FIGURE
C
C........... ASSIGN VERTEX
             NVERTM(NPOLY) = -100 - IB  ! EXTRA BAFFLE #IB
C
C........... ASSIGN REGIONS
             ITAGRM(NPOLY) = 13         ! POLYGON IS A BAFFLE
             ITAGES(NPOLY) = 2          ! POLYGON IS A WALL
C
C........... POLYGON CREATED BY BAFFLES
             MPOLYT(NPOLY) = 9          ! BAFFLE
C
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKPUMP( LOUT , LPMPST , NPOLY , RPX , ZPX )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE PUMP
C           - -  ----
C PURPOSE : TO ESSENTIALLY MAKE THE PUMP STRUCTURE.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPMPST      = .T. --- PUMP STRUCTURE EXISTS
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C ROUTINES: PPUMP       = PROCESS PUMP
C           GETDWB      = IS POLYGON A DIVERTOR PUMP WALL
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 19/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , NPOLY
      REAL*8    RPX  , ZPX
      LOGICAL   LPMPST
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..ROUTINES
      INTEGER*4 LEN
C
C..PARAMETERS
      INTEGER*4    MIDWB
      PARAMETER(   MIDWB = 500 )
C
C..LOCALS
      INTEGER*4 IER , M , NIDWB , IDWB(MIDWB) , LIDWB(MIDWB)
      LOGICAL   LINIT , LTRAN
C
C..DATA
      DATA LINIT/ .TRUE. /
C
C..LOCALS
      INTEGER*4    I , J , L
      CHARACTER*80 MESS
C
C-----------------------------------------------------------------------
C---------------------------- INITIALISATION ---------------------------
C-----------------------------------------------------------------------
C
      NPOLYC(5)  = 0    ! START OF PUMP STRUCTURE POLYGONS
      NPOLYC(6)  = 0    ! END   OF PUMP STRUCTURE POLYGONS
C
C-----------------------------------------------------------------------
C----------------------------- CHECK INPUT -----------------------------
C-----------------------------------------------------------------------
C
      IF( .NOT.LPMPST ) GOTO 9999
C
C-----------------------------------------------------------------------
C----------------------------- PROCESS PUMP ----------------------------
C-----------------------------------------------------------------------
C
      IF( LINIT ) THEN
          CALL PPUMP( LOUT
     I              , MPG         , 5
     I              , NPOLYK(2)   , NVERTM(1)
     I              , RVERTM(1,1) , ZVERTM(1,1) , ITAGRM(1)
     O              , MESS        , IER         )
          IF( IER.NE.0 ) THEN
              WRITE(LOUT,'(2A)') ' *** ERROR (PPUMP) : ' , MESS
              CALL EXITX(LOUT)
          END IF
      ENDIF
C
C-----------------------------------------------------------------------
C------------------------- IDENTIFY REGIONS ----------------------------
C-----------------------------------------------------------------------
C
      NPOLYC(5) = NPOLY + 1                 ! START OF PUMP STRUCTURE
      NPOLYC(6) = NPOLYC(5) + NPUMP - 1     ! END   OF PUMP STRUCTURE
C
C-----------------------------------------------------------------------
C------------- POLYGONS WHICH BELONG TO DIVERTOR PUMP WALL -------------
C------------ ONLY FOR POLYGONS ABOVE PLASMA/INNER FIGURES -------------
C-----------------------------------------------------------------------
C
      DO M = NPOLYK(1) + 1 , NPOLY
C
C....... DOES POLYGON BELONG TO DIVERTOR PUMP WALL ?
         CALL GETDWB( LOUT  , M       , MIDWB    , LPMPST
     O              , NIDWB , IDWB(1) , LIDWB(1) )
C
C....... POLYGON IS INDEED A DIVERTOR PUMP WALL
         IF( NIDWB.GT.0 ) THEN
C
C........... DEFINE TOP SIDE OF DIVERTOR REGION
             LTRAN = ITAGRM(M).EQ.10 .OR. ITAGRM(M).EQ.12 .OR.
     &               ITAGRM(M).EQ.21 .OR. ITAGRM(M).EQ.22 .OR.
     &               ITAGRM(M).EQ.11
C
C........... RE-DEFINE ITAGES() FOR DIVERTOR PUMP WALL POLYGONS
             IF( LTRAN .AND. IHORIZ(M).EQ.0 ) THEN
                 ITAGES(M) = -2       ! TOP SIDE
             ELSE IF( RVERTM(M,1).LT.RPX ) THEN
                 ITAGES(M) = -3       ! LHS SIDE
             ELSE IF( RVERTM(M,1).GT.RPX ) THEN
                 ITAGES(M) = -1       ! RHS SIDE
             ENDIF
C
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C-------------- SUBSTITUTE PUMP LABELS BY NIMBUS REGIONS ---------------
C-----------------------------------------------------------------------
C
      IF( LINIT ) THEN
          DO L = 1 , NRPUMP
             DO I = 1 , NPUMP
                DO J = 1 , LEN(LRPUMP(L))
                   IF( LRPUMP(L)(J:J+3).EQ.LAPUMP(I) ) THEN
                       WRITE(LRPUMP(L)(J:J+3),1000) NPOLYC(5)+I-1 + 2
                   ENDIF
                ENDDO
             ENDDO
          ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C---------------------- STOP RE-INITIALISATIONS ------------------------
C-----------------------------------------------------------------------
C
      IF( LINIT ) LINIT = .FALSE.
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( I4 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MKCPGG( LOUT
     I                 , RPX    , ZPX
     I                 , MALBPG , IALBPG
     O                 , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAKE CORNER & PUMP-GAP POLYGONS
C           - -  -        -    -       -
C PURPOSE : TO ESSENTIALLY MAKE THE PUMP STRUCTURE.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C
C           MALBPG      = DIMENSION OF IALBPG()
C           IALBPG()    >  0 --- NIMBUS REGIONS TO BE SET AS ALBEDOS
C                       = -1 --- NIMBUS REGIONS IN PRIV. REGION COVER
C                                TO BE SET AS ALBEDOS
C                       = -2 --- NIMBUS REGIONS IN OUTER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -3 --- NIMBUS REGIONS IN INNER DIVERTOR WALL
C                                TO BE SET AS ALBEDOS
C                       = -4 --- NIMBUS REGIONS IN OUTER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -5 --- NIMBUS REGIONS IN INNER CORNER WALL
C                                TO BE SET AS ALBEDOS
C                       = -6 --- NIMBUS REGIONS IN OUTER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       = -7 --- NIMBUS REGIONS IN INNER DIVERTOR TARGET
C                                TO BE SET AS ALBEDOS
C                       (ORDER OF IALBPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C I/O     : NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 22/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT  , MALBPG
      INTEGER*4 IALBPG(MALBPG)
      REAL*8    RPX , ZPX
C
C..I/O
      INTEGER*4 NPOLY
C
C-----------------------------------------------------------------------
C----------------------- CORNER ESCAPE FIGURES -------------------------
C-----------------------------------------------------------------------
C
      CALL MKCORG( LOUT
     I           , MALBPG , IALBPG(1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C---------------------- PUMP GAP ESCAPE FIGURES ------------------------
C-----------------------------------------------------------------------
C
      CALL MKGAPG( LOUT
     I           , RPX    , ZPX
     I           , MALBPG , IALBPG(1)
     O           , NPOLY  )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE POLRNG( LOUT , NPOLY  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : POLYGON RANGES
C           ---     - --
C PURPOSE : TO DEFINE THE RANGES OF POLYGON REGIONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = TOTAL NUMBER OF NIMBUS POLYGONS
C
C /CPOLYG/: (SEE 'c09')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 24/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C..LOCALS
      INTEGER*4 M , IR , IR0
      LOGICAL   LTRAN
C
C-----------------------------------------------------------------------
C-------------------------- INITIALISATION -----------------------------
C-----------------------------------------------------------------------
C
      CALL RESETI( MPOLYS(1) , MDIMSE , 0 )
      CALL RESETI( MPOLYE(1) , MDIMSE , 0 )
C
C-----------------------------------------------------------------------
C----------------------- FILL POLYGON RANGES ---------------------------
C-----------------------------------------------------------------------
C
      DO M  = 1 , NPOLY
C
C....... POLYGON REGION
         IR = MPOLYT(M)
C
C....... VALID IR VALUES ONLY
         IF( IR.LT.1 .OR. IR.GT.MDIMSE ) THEN
             WRITE(LOUT,9000) M , IR
             CALL EXITX(LOUT)
         ENDIF
C
C....... LOWER LIMIT OF RANGE
         IF( MPOLYS(IR).EQ.0 ) MPOLYS(IR) = M
C
C....... UPPER LIMIT OF RANGE
         MPOLYE(IR) = M
C
      ENDDO
C
C-----------------------------------------------------------------------
C------------------- CHECK INTEGRITY OF REGIONS ------------------------
C-----------------------------------------------------------------------
C
      DO IR = 1 , MDIMSE
C
C....... REGION NOT PRESENT (NOT AN ERROR)
         IF( MPOLYS(IR).EQ.0 .OR. MPOLYE(IR).EQ.0 ) GOTO 200
C
C....... INVALID REGION (START OR END OF RANGE NOT SET)
         IF( MPOLYS(IR).EQ.0 ) THEN
             WRITE(LOUT,9010) 'MPOLYS' , IR
             CALL EXITX(LOUT)
         ELSE IF( MPOLYE(IR).EQ.0 ) THEN
             WRITE(LOUT,9010) 'MPOLYE' , IR
             CALL EXITX(LOUT)
         ENDIF
C
C....... INVALID RANGE (RANGE CROSSES ANOTHER REGION)
         DO IR0 = 1 , MDIMSE
            IF( MPOLYS(IR0).EQ.0 .OR. MPOLYE(IR0).EQ.0 .OR. IR.EQ.IR0 )
     &          GOTO 100
            LTRAN = ( MPOLYS(IR).GE.MPOLYS(IR0)
     &                          .AND.
     &                MPOLYS(IR).LE.MPOLYE(IR0) )
     &                          .OR.
     &              ( MPOLYE(IR).GE.MPOLYS(IR0)
     &                          .AND.
     &                MPOLYE(IR).LE.MPOLYE(IR0) )
            IF( LTRAN ) THEN
                WRITE(LOUT,9020) IR  , MPOLYS(IR)  , MPOLYE(IR)
     &                         , IR0 , MPOLYS(IR0) , MPOLYE(IR0)
                CALL EXITX(LOUT)
            ENDIF
  100    ENDDO
C
  200 ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(POLRNG) : ILLEGAL POLYGON REGION!!!!'
     &        / '                     M =' , I5 , ' & MPOLYT = ' , I3 )
 9010 FORMAT( / ' *** ERROR(POLRNG) : ' , A , ' NOT SET!!!!'
     &        / '                     IR =' , I3 )
 9020 FORMAT( / ' *** ERROR(POLRNG) : REGION IS NOT CONTINUIOUS!!!!'
     &        / '                     IR  =' , I3
     &        , ' RANGE =' , I5 , ' ->' , I5
     &        / '                     IR0 =' , I3
     &        , ' RANGE =' , I5 , ' ->' , I5 )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE MAPREG( LOUT , NPOLY  , LPMPST , IALB
     I                 , CCIR , CREC   , CPLAS  , CVOID  , CWALL
     I                 , CALB , CPLATE , CDVPMP )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : MAP REGIONS
C           --- ---
C PURPOSE : TO ASSIGN CHARACTER (MAPS) TO NIMBUS REGIONS
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = NUMBER OF POLYGONS CREATED
C           LPMPST      = .T. --- PUMP STRUCTURE EXISTS
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C
C           CCIR        = CHARACTER FOR NIMBUS CIRCLE REGION
C           CREC        = CHARACTER FOR NIMBUS RECTANGLE REGION
C           CPLAS       = CHARACTER FOR PLASMA REGIONS
C           CVOID       = CHARACTER FOR VOID   REGIONS
C           CWALL       = CHARACTER FOR WALL   REGIONS
C           CALB        = CHARACTER FOR ALBEDO REGIONS
C           CPLATE      = CHARACTER FOR DIVERTOR PLATE REGIONS
C           CDVPMP      = CHARACTER FOR DIVERTOR PUMP WALL REGIONS
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C NOTES   : 1. REGIONS ARE DEFINED AS FOLLOWS,
C                REGION 1     = NIMBUS GEOMETRY CIRCLE    REGION
C                REGION 2     = NIMBUS GEOMETRY RECTANGLE REGION
C                REGION M+2   = REGIONS FOR NIMBUS POLYGONS,
C                               M=1 -> M=(LAST BEFORE PUMP STRUCTURE)
C                PUMP REGIONS = REGIONS FOR PUMP STRUCTURE ARE DEFINED
C                               IN PUMP FILE, SEE LRPUMP()
C                LAST REGION  = DUMMY REGION
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 24/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4     LOUT   , NPOLY  , IALB
      CHARACTER*(*) CCIR   , CREC   , CPLAS  , CVOID , CWALL
     &            , CALB   , CPLATE , CDVPMP
      LOGICAL       LPMPST
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..LOCALS
      INTEGER*4    IR , IRSAV , M , L
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      IR       = 0         ! NO. OF NIMBUS REGIONS CREATED, SO FAR
C
C-----------------------------------------------------------------------
C------------------------ NIMBUS CIRCLE REGION -------------------------
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      COMM(IR) = CCIR      ! REGION 1
C
C-----------------------------------------------------------------------
C---------------------- NIMBUS RECTANGLE REGION ------------------------
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      COMM(IR) = CREC      ! REGION 2
C
C-----------------------------------------------------------------------
C----------------------- REGIONS FROM POLYGONS -------------------------
C-----------------------------------------------------------------------
C
      DO M = 1 , NPOLY
C
C....... INCREMENT NUMBER OF REGIONS (IN THIS BLOCK IR = M + 2 )
         IR = IR + 1
C
C....... PLASMA REGIONS
         IF( MPOLYT(M).EQ.1 ) THEN
             IF( IDTAGM(M,1).EQ.0 ) THEN
                 COMM(IR) = CPLAS    ! PLASMA
             ELSE
                 COMM(IR) = CPLATE   ! DIVERTOR/PLASMA PLATE
             ENDIF
C
C....... INNER (I.E. BULK) REGION
         ELSE IF( MPOLYT(M).EQ.2 ) THEN
             COMM(IR) = CVOID
C
C....... PRIVATE VOID IS A WALL
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.0 ) THEN
             COMM(IR) = CWALL
C
C....... PRIVATE VOID IS AN ALBEDO
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.1 ) THEN
             COMM(IR) = CALB
C
C....... PRIVATE VOID IS A VOID
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.1 ) THEN
             COMM(IR) = CVOID
C
C....... VOID REGIONS
         ELSE IF( ITAGES(M).EQ.1 ) THEN
             COMM(IR) = CVOID
C
C....... WALL REGIONS
         ELSE IF( ITAGES(M).EQ.2 ) THEN
             COMM(IR) = CWALL
C
C....... ALBEDO REGIONS
         ELSE IF( ITAGES(M).GT.2 ) THEN
             COMM(IR) = CALB
C
C....... DIVERTOR PUMP WALL REGIONS
         ELSE IF( ITAGES(M).LT.0 ) THEN
             COMM(IR) = CDVPMP
C
C....... UNDEFINED REGION
         ELSE
             WRITE(LOUT,9000) M , ITAGES(M) , MPOLYT(M)
             CALL EXITX(LOUT)
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C---------------------- PUMP STRUCTURE REGIONS -------------------------
C-----------------------------------------------------------------------
C
      IRSAV = IR    ! LAST REGION BEFORE ANY PUMP STRUCTURE
C
      IF( LPMPST ) THEN

C........ LOOP OVER NO. OF PUMP REGIONAL SETUPS
          DO L = 1 , NRPUMP
             IF( L.EQ.1 ) THEN
                 IR = IR + 1
                 COMM(IR) = LRPUMP(L)(1:1)
             ELSE IF( LRPUMP(L)(2:5).NE.LRPUMP(L-1)(2:5) .AND.
     &                LRPUMP(L)(5:5).NE.'*'                    ) THEN
                 IR = IR + 1
                 COMM(IR) = LRPUMP(L)(1:1)
             ENDIF
          ENDDO
C
      ENDIF
C
C-----------------------------------------------------------------------
C--------------------------- DUMMY REGION ------------------------------
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      COMM(IR) = CVOID
C
C-----------------------------------------------------------------------
C----------------------- SET REGION VALUE ------------------------------
C-----------------------------------------------------------------------
C
      NIMREG(1) = IR      ! TOTAL NO. OF REGIONS
      NIMREG(2) = IRSAV   ! REGION BEFORE ANY PUMP STRUCTURE OR DUMMY
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(MAPREG) : ILLEGAL DEFINED REGION !!!!'
     &        / '                    M =' , I5
     &                               , ', ITAGES =' , I3
     &                               , ', MPOLYT =' , I3 )
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE WRREG( IFILE , LOUT , NPOLY , LPMPST , LBUFLE
     &                , IALB  , EPS )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : WRITE NIMBUS REGIONS
C           --           ---
C PURPOSE : TO WRITE NIMBUS REGIONS TO NIMBUS (MC) FILE.
C
C INPUT   : IFILE       > 0   --- CHANNEL FOR WRITING NIMBUS REGIONS
C                       = 0   --- CREATE BUT DON'T WRITE POLYGONS
C           LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = NUMBER OF POLYGONS CREATED
C           LPMPST      = .T. --- PUMP STRUCTURE EXISTS
C           LBUFLE      = .T. --- SWITCH ON BAFFLE (NEED IALB = 2)
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C           EPS         = TOLERENCE LEVEL
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C ROUTINES: GETDWB      = POLYGONS BELONGING TO DIVERTOR PUMP WALL
C           GETBAF      = BAFFLE POLYGONS CONTAINED/CUTS POLYGON
C           IMGAP       = PUMP GAP POLYGON CONTAINED IN POLYGON
C           POLCIR      = DOES POLYGON CONTAIN OR CUT CIRCLE ?
C           LSTR        = LENGTH OF STRING EXCLUDING TRAILING BLANKS
C
C NOTES   : 1. REGIONS ARE DEFINED AS FOLLOWS,
C                REGION 1     = NIMBUS GEOMETRY CIRCLE    REGION
C                REGION 2     = NIMBUS GEOMETRY RECTANGLE REGION
C                REGION M+2   = REGIONS FOR NIMBUS POLYGONS,
C                               M=1 -> M=(LAST BEFORE PUMP STRUCTURE)
C                PUMP REGIONS = REGIONS FOR PUMP STRUCTURE ARE DEFINED
C                               IN PUMP FILE, SEE LRPUMP()
C                LAST REGION  = DUMMY REGION
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 24/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 IFILE  , LOUT   , NPOLY , IALB
      REAL*8    EPS
      LOGICAL   LPMPST , LBUFLE
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..ROUTINES
      INTEGER*4 IMGAP , LSTR
C
C..PARAMETERS
      INTEGER*4  MIDWB , MIBAF
      PARAMETER( MIDWB = 500 , MIBAF = 500 )
C
C..LOCALS
      INTEGER*4 IR , M , M0 , L , I , IRES
     &        , NIDWB , IDWB(MIDWB) , LIDWB(MIDWB)
     &        , NIBAF , IBAF(MIBAF)
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C-----------------------------------------------------------------------
C
      IF( IFILE.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      IR       = 0         ! NO. OF NIMBUS REGIONS CREATED, SO FAR
C
C-----------------------------------------------------------------------
C------------------------ NIMBUS CIRCLE REGION -------------------------
C----- FIRST NUMBER IS REGION INDEX ; OTHERS ARE DEFINED IN NIMBUS -----
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      WRITE(IFILE,1000) IR , 1 , -2   ! REGION 1
C
C-----------------------------------------------------------------------
C---------------------- NIMBUS RECTANGLE REGION ------------------------
C----- FIRST NUMBER IS REGION INDEX ; OTHERS ARE DEFINED IN NIMBUS -----
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      WRITE(IFILE,1000) IR , 3 , +5   ! REGION 2
C
C-----------------------------------------------------------------------
C----------------------- REGIONS FROM POLYGONS -------------------------
C---- FIRST NUMBER IS REGION INDEX ; OTHERS REGIONS ADDED/SUBTRACTED ---
C-----------------------------------------------------------------------
C
      DO M = 1 , NPOLY
C
C....... INCREMENT NUMBER OF REGIONS (IN THIS BLOCK IR = M + 2 )
         IR = IR + 1
C
C....... PLASMA REGIONS
         IF( MPOLYT(M).EQ.1 ) THEN
             IF( IDTAGM(M,1).EQ.0 ) THEN
                 WRITE(IFILE,1000) IR , IR         ! PLASMA
             ELSE
                 WRITE(IFILE,1000) IR , IR  , +2   ! DIV/PLASMA PLATE
             ENDIF
C
C....... INNER (I.E. BULK) REGION
         ELSE IF( MPOLYT(M).EQ.2 ) THEN
             WRITE(IFILE,1000) IR , IR
C
C....... PRIVATE VOID IS A WALL (NO BAFFLES ALLOWED)
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.0 ) THEN
             WRITE(IFILE,1000) IR , IR , +2
C
C....... PRIVATE VOID IS AN ALBEDO (NO BAFFLES ALLOWED)
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.1 ) THEN
             WRITE(IFILE,1000) IR , IR , +2
C
C....... PRIVATE VOID IS A VOID (MAY CONTAIN BAFFLES)
         ELSE IF( MPOLYT(M).EQ.6 ) THEN
             CALL GETBAF( LOUT  , M       , MIBAF , LBUFLE , IALB , EPS
     O                  , NIBAF , IBAF(1) )
             IF( NIBAF.EQ.0 ) THEN
                 WRITE(IFILE,1000) IR , IR
             ELSE
                 WRITE(IFILE,1000) IR , IR
     &                           , ( -(IBAF(I) + 2), I=1,NIBAF ) , +2
             ENDIF
C
C....... BAFFLES
         ELSE IF( MPOLYT(M).EQ.9 ) THEN
             WRITE(IFILE,1000) IR , IR
C
C....... SOL VOID (MAY CONTAIN SOL PRESSURE GAUGE)
         ELSE IF( ITAGES(M).EQ.1 ) THEN
             IRES = 0   ! DOES POLYGON CONTAIN/CUT SOL PRESSURE GAUGE ?
             IF( IGAUGE(2).GT.0 ) THEN
                 L = IGAUGE(2)
                 CALL POLCIR( M
     I                      , RPUMP(L,1) , ZPUMP(L,1) , RPUMP(L,2)
     O                      , IRES       )
             ENDIF
             IF( IRES.EQ.0 ) THEN
                 WRITE(IFILE,1000) IR , IR
             ELSE
                 WRITE(IFILE,1000) IR , IR
     &                           , -(NPOLYC(5) + IGAUGE(2) - 1 + 2)
             ENDIF
C
C....... WALL REGIONS (MAY CONTAIN PUMP GAP)
         ELSE IF( ITAGES(M).EQ.2 ) THEN
             M0 = IMGAP( M , MWGAP , 2 , IWGAP , IMWGAP )
             IF( M0.GT.0 ) THEN
                 WRITE(IFILE,1000) IR , IR , +2 , -(M0+2)
             ELSE
                 WRITE(IFILE,1000) IR , IR , +2
             ENDIF
C
C....... ALBEDO REGIONS (MAY CONTAIN PUMP GAP)
         ELSE IF( ITAGES(M).GT.2 ) THEN
             M0 = IMGAP( M , MWGAP , 2 , IWGAP , IMWGAP )
             IF( M0.GT.0 ) THEN
                 WRITE(IFILE,1000) IR , IR , +2 , -(M0+2)
             ELSE
                 WRITE(IFILE,1000) IR , IR , +2
             ENDIF
C
C....... DIVERTOR PUMP WALL REGIONS (MAY CONTAIN PUMP GAP)
         ELSE IF( ITAGES(M).LT.0 ) THEN
             CALL GETDWB( LOUT  , M       , MIDWB    , LPMPST
     O                  , NIDWB , IDWB(1) , LIDWB(1) )
             M0 = IMGAP( M , MWGAP , 2 , IWGAP , IMWGAP )
             IF( M0.GT.0 ) THEN
                 WRITE(IFILE,1000) IR , IR
     &                           , LIDWB(1)+2,(-(LIDWB(I)+2),I=2,NIDWB)
     &                           , -(M0+2)
             ELSE
                 WRITE(IFILE,1000) IR , IR
     &                           , LIDWB(1)+2,(-(LIDWB(I)+2),I=2,NIDWB)
             ENDIF
C
C....... UNDEFINED REGION
         ELSE
             WRITE(LOUT,9000) M , ITAGES(M) , MPOLYT(M)
             CALL EXITX(LOUT)
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C---------------------- PUMP STRUCTURE REGIONS -------------------------
C----- NB. LRPUMP(L)(2:5) = **** MEANS A CONTINUATION OF A REGION ------
C-----------------------------------------------------------------------
C
      IF( LPMPST ) THEN
C
          DO L = 1 , NRPUMP
             WRITE(IFILE,1010) LRPUMP(L)(2:LSTR(LRPUMP(L)))
             IF( LRPUMP(L)(2:5).NE.'****' ) IR = IR + 1
          ENDDO
C
      ENDIF
C
C-----------------------------------------------------------------------
C--------------------------- DUMMY REGION ------------------------------
C----- FIRST NUMBER IS REGION INDEX ; OTHERS ARE DEFINED IN NIMBUS -----
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      WRITE(IFILE,1000) IR , 5 , +3
C
C-----------------------------------------------------------------------
C------------------------ END REGION SECTION ---------------------------
C-----------------------------------------------------------------------
C
      WRITE(IFILE,1010) ' END'
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( I5 , 6X , 11I6 )
 1010 FORMAT( ( 1X , A ) )
C
 9000 FORMAT( / ' *** ERROR(WRREG) : ILLEGAL DEFINED REGION !!!!'
     &        / '                    M =' , I5
     &                               , ', ITAGES =' , I3
     &                               , ', MPOLYT =' , I3 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETPHY( M     , MP    , NIONH
     I                 , DENSE , DENSI , TEMPE , TEMPI , VPAR  , HMASS
     O                 , N     , K     , DE    , TE    , TI    , DV   )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET NIMBUS POLYGON PHYSICAL VALUES
C           ---                ---
C PURPOSE : TO RETURN PLASMA POLYGON, K-MESH VALUE, DENSITY,
C           TEMPERATURES & DRIFT VELOCITY FOR A GIVEN NIMBUS POLYGON.
C
C INPUT   : M           = NIMBUS POLYGON
C           MP          = MAX. NO. OF MESH-VALUES ALLOWED
C           NIONH       = NO. OF HYDROGEN SPECIES
C
C           DENSE(K)    = ELECTRON DENSITY     AT MESH POINT K (CM-3)
C           DENSI(K,IH) = ION      DENSITY     AT MESH POINT K (CM-3)
C           TEMPE(K)    = ELECTRON TEMPERATURE AT MESH POINT K (EV)
C           TEMPI(K)    = ION      TEMPERATURE AT MESH POINT K (EV)
C           VPAR(K,IH)  = PARALLEL VELOCITY    AT MESH POINT K (CM/S)
C           HMASS(K,IH) = MASS OF ION (A.U)
C
C OUTPUT  : N           = PLASMA POLYGON ASSOCIATED WITH #M
C           K           = K-MESH VALUES ASSOCIATED WITH #N
C           DE          = ELECTRON DENSITY OF MESH POINT K
C           TE          = ELECTRON TEMP    OF MESH POINT K
C           TI          = ION      TEMP    OF MESH POINT K
C           DV          = DRIFT VELOCITY   OF MESH POINT K
C
C /CPOLYG/: (SEE 'cpolyg')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 27/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 M , MP , NIONH
      REAL*8    DENSE(MP) , DENSI(MP,NIONH) , TEMPE(MP) , TEMPI(MP)
     &        , VPAR(MP,NIONH) , HMASS(NIONH)
C
C..OUTPUT
      INTEGER*4 N  , K
      REAL*8    DE , TE , TI , DV
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C..LOCALS
      INTEGER*4 IH
      REAL*8    VPARA , HMASA , DENSA
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      N  = 0
      K  = 0
      DE = 0.0D+00
      TE = 0.0D+00
      TI = 0.0D+00
      DV = 0.0D+00
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C------------------------ PLASMA POLYGONS ONLY -------------------------
C-----------------------------------------------------------------------
C
      IF( M.LE.0 .OR. NIONH.LE.0 ) GOTO 9999
C
      IF( MPOLYT(M).NE.1 ) GOTO 9999
C
C-----------------------------------------------------------------------
C--------------------- BASIC PHYSICAL QUANTITIES -----------------------
C-----------------------------------------------------------------------
C
      N  = ITAGM(M,1)
      K  = KORKG(N)
C
      DE = DENSE(K)
      TE = TEMPE(K)
      TI = TEMPI(K)
C
C-----------------------------------------------------------------------
C------------------------ DERIVED QUANTITIES ---------------------------
C------------------- AVERAGE FOR HYDROGEN SPECIES ----------------------
C-----------------------------------------------------------------------
C
      VPARA     = 0.0D+00
      HMASA     = 0.0D+00
      DENSA     = 0.0D+00
C
      DO IH     = 1 , NIONH
         VPARA  = VPARA + ( VPAR(K,IH) * DENSI(K,IH) )
         HMASA  = HMASA + ( HMASS(IH)  * DENSI(K,IH) )
         DENSA  = DENSA + DENSI(K,IH)
      ENDDO
C
      IF( DENSA.GT.0.0D+00 ) THEN
          VPARA = VPARA / DENSA
          HMASA = HMASA / DENSA
          DV    = ( ABS(VPARA) * 1.02D-06 ) / SQRT( (TE + TI )/HMASA )
      ELSE
          DV    = 0.0D+00
      ENDIF
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETTEM( LOUT , M
     O                 , TE   , TI )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET TEMPERATURES FOR WALL POLYGON
C           --- ---
C PURPOSE : TO RETURN TEMPERATURES FOR NIMBUS WALL POLYGON.
C
C INPUT   : LOUT        = OUTPUT CHANNEL
C           M           = NIMBUS POLYGON
C
C OUTPUT  : TE          = ELECTRON TEMP OF WALL POLYGON
C           TI          = ION      TEMP OF WALL POLYGON
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 27/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , M
C
C..OUTPUT
      REAL*8    TE , TI
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C------------------------ WALL POLYGONS ONLY ---------------------------
C-----------------------------------------------------------------------
C
      IF( ITAGES(M).EQ.0 ) THEN
          WRITE(LOUT,9000) M
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C------------------ GET APPROPRIATE WALL TEMPERATURES ------------------
C-----------------------------------------------------------------------
C
      IF( ITAGRM(M).EQ.10 .OR. ITAGRM(M).EQ.12 ) THEN
          TE = TEVTA
          TI = TIVTA
      ELSE IF( ITAGRM(M).EQ.19 .OR. ITAGRM(M).EQ.20 .OR.
     &         ITAGRM(M).EQ.21 .OR. ITAGRM(M).EQ.22      ) THEN
          TE = TEVDV
          TI = TIVDV
      ELSE IF( ITAGRM(M).EQ.11 .OR. ITAGRM(M).EQ.13 ) THEN
          TE = TEVPR
          TI = TIVPR
      ELSE
          TE = TEVWL
          TI = TIVWL
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(GETTEM) : NOT A WALL POLYGON !!!!'
     &        / '                     M =' , I5 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETEMI( LOUT   , M , IAEMIS , MNUTPG , INUTPG , EMISW
     O                 , EMISX  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET TEMPERATURES FOR WALL POLYGON
C           --- ---
C PURPOSE : TO RETURN TEMPERATURES FOR NIMBUS WALL POLYGON.
C
C INPUT   : LOUT        = OUTPUT CHANNEL
C           M           = NIMBUS POLYGON
C           IAEMIS      = 1 --- ATOMIC RE-EMISSION
C                         0 --- MOLECULAR RE-EMISSION
C                        -1 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + ATOMIC RE-EMISSION OUTSIDE INUTPG()
C                        -2 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + MOLECULAR RE-EMISSION OUTSIDE INUTPG()
C           MNUTPG      = DIMENSION OF INUTPG()
C           INUTPG()    >  0 --- NIMBUS WALL REGION SET AS NEUTRAL
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -1 --- NIMBUS WALL REG. IN PRIV. REGION COVER
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -3 --- NIMBUS WALL REG. IN INNER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -4 --- NIMBUS WALL REG. IN OUTER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -5 --- NIMBUS WALL REG. IN INNER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -6 --- NIMBUS WALL REG. IN OUTER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -7 --- NIMBUS WALL REG. IN INNER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -8 --- BUFFLE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -9 --- ENTIRE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                                (INCL. BUFFLE)
C                       (ORDER OF INUTPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C           EMISW       = ORIGINAL EMISSION TYPE OF POLYGON #M
C
C OUTPUT  : EMISX       = 'X'   --- POLYGON #M IS A NEUTRAL RECYCLOR
C                       = EMISW --- POLYGON #M IS NOT A NEUTRAL RECYCLOR
C
C /POLYG/ : (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 27/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , M , IAEMIS , MNUTPG
      INTEGER*4 INUTPG(MNUTPG)
      CHARACTER EMISW*(*)
C
C..OUTPUT
      CHARACTER EMISX*(*)
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 IRES
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C------------------------ WALL POLYGONS ONLY ---------------------------
C-----------------------------------------------------------------------
C
      IF( ITAGES(M).EQ.0 ) THEN
          WRITE(LOUT,9000) M
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C------------------- IS POLYGON A NEUTRAL RECYCLOR ? -------------------
C-----------------------------------------------------------------------
C
      EMISX = EMISW
C
      IF( IAEMIS.EQ.-1 .OR. IAEMIS.EQ.-2 ) THEN
          CALL CHKNUT( MNUTPG , INUTPG(1) , ITAGRM(M) , M , IRES )
          IF( IRES.GT.0 ) EMISX = 'X'
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(GETEMI) : NOT A WALL POLYGON !!!!'
     &        / '                     M =' , I5 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE GETPSP( LOUT   , M      , MPSP
     I                 , IPSEMP , PSEMP  , PSEMG
     I                 , PSEMPO , PSEMPI , PSEMPT
     O                 , POUTB  , PINB   )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : GET TEMPERATURES FOR WALL POLYGON
C           --- ---
C PURPOSE : TO RETURN TEMPERATURES FOR NIMBUS WALL POLYGON.
C
C INPUT   : LOUT        = OUTPUT CHANNEL
C           M           = NIMBUS POLYGON
C           MPSP        = DIMENSION OF IPSEMP(), PSEMP() & PSEMG()
C
C           IPSEMP()    = NIMBUS REGION IN WHICH THE SEMI-PERMEABILITY
C                         FRACTION IS SPECIFIED OVERRIDING ABOVE
C           PSEMP()     = SEMI-PERMEABILITY PROBABILITY FRACTION
C                         FOR EACH SPECIFIED REGION (OUTWARD)
C           PSEMG()     = SEMI-PERMEABILITY PROBABILITY FRACTION
C                         FOR EACH SPECIFIED REGION (INWARD)
C           PSEMPO      = PROBABILITY OF SEMI-PERMEABILITY OF OUTER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPT      = PROBABILITY OF SEMI-PERMEABILITY OF TARGET
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPI      = PROBABILITY OF SEMI-PERMEABILITY OF INNER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C
C OUTPUT  : POUTB       = OUTBOARD SEMI-PERMEABILITY FRACTION
C                         (I.E. AWAY FROM PLASMA CENTRE)
C           PINB        = INBOARD  SEMI-PERMEABILITY FRACTION
C                         (I.E. TOWARDS PLASMA CENTRE)
C
C /POLYG/ : (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 27/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT , M , MPSP
      INTEGER*4 IPSEMP(MPSP)
      REAL*8    PSEMP(MPSP) , PSEMG(MPSP)
     &        , PSEMPO      , PSEMPI      , PSEMPT
C
C..OUTPUT
      REAL*8    POUTB , PINB
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 ILOCAL
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C--------- WALL POLYGONS WHICH ARE PART OF PUMP STRUCTURE ONLY ---------
C-----------------------------------------------------------------------
C
      IF( ITAGES(M).GE.0 ) THEN
          WRITE(LOUT,9000) M
          CALL EXITX(LOUT)
      ENDIF
C
C-----------------------------------------------------------------------
C--------------- IS THE TRANSPARENCY GLOBAL OR LOCAL ? -----------------
C-----------------------------------------------------------------------
C
      CALL CHKPSP( MPSP , IPSEMP(1) , M , ILOCAL )
C
C-----------------------------------------------------------------------
C----------------------- SET TRANSPARENCY ------------------------------
C-----------------------------------------------------------------------
C
      IF( ILOCAL.GT.0 ) THEN
          POUTB = PSEMP(ILOCAL)
          PINB  = PSEMG(ILOCAL)
      ELSE IF( ITAGES(M).EQ.-1 ) THEN
          POUTB = PSEMPO
          PINB  = POUTB
      ELSE IF( ITAGES(M).EQ.-2 ) THEN
          POUTB = PSEMPT
          PINB  = POUTB
      ELSE IF( ITAGES(M).EQ.-3 ) THEN
          POUTB = PSEMPI
          PINB  = POUTB
      ELSE
          WRITE(LOUT,9010) M , ITAGES(M)
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(GETPSP) : NOT A WALL POLYGON, IN PUMP !!!!'
     &        / '                     M =' , I5 )
 9010 FORMAT( / ' *** ERROR(GETPSP) : INVALID WALL/PUMP POLYGON !!!!'
     &        / '                     M =' , I5 , ', ITAGES =' , I3 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE WRPHYR( IFILE  , LOUT   , NPOLY  , LPMPST
     &                 , IALB   , IAEMIS , ICORE  , ICHARG
     &                 , IOPTRC
     &                 , MP     , MFLH   , MDIM   , MLK
     &                 , MSEMPB
     &                 , MIONH  , NIONH  , MWREG  , MMPG
     &                 , DENSE  , DENSI  , TEMPE  , TEMPI
     &                 , VPAR   , HMASS  , TEVGAP
     &                 , FLHCHM , MTOREG , RMATW  , INUTPG
     &                 , IPSEMP , PSEMP  , PSEMG
     &                 , PSEMPO , PSEMPI , PSEMPT , PSEMPX
     &                 , PSEMPB
     &                 , ALBPG  , ALBEPG , ALBATO
     &                 , ALBPMP , ALBLK  )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : WRITE PHYSICAL DESCRIPTIONS OF REGIONS
C           --    ---                      -
C PURPOSE : TO WRITE THE PHYSICAL DESCRIPTION (TEMPS, DENS, ETC) TO
C           THE NIMBUS INPUT (MC) FILE.
C
C INPUT   : IFILE       > 0   --- CHANNEL FOR WRITING NIMBUS REGIONS
C                       = 0   --- CREATE BUT DON'T WRITE POLYGONS
C           LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = NUMBER OF POLYGONS CREATED
C           LPMPST      = .T. --- PUMP STRUCTURE EXISTS
C
C           IALB        = 0 --- PRIVATE VOID REGION IS A WALL
C                         1 --- PRIVATE VOID REGION IS AN ALBEDO
C                         2 --- PRIVATE VOID REGION IS A VOID
C           IAEMIS      = 1 --- ATOMIC RE-EMISSION
C                         0 --- MOLECULAR RE-EMISSION
C                        -1 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + ATOMIC RE-EMISSION OUTSIDE INUTPG()
C                        -2 --- NEUTRALS ARE RECYCLED IN REGION INUTPG()
C                               WITH E=EATMR
C                               + MOLECULAR RE-EMISSION OUTSIDE INUTPG()
C           ICORE       = 1 --- IF THE CORE IS TO BE CONSIDERED
C           ICHARG      = CHARGE OF IONIZED HEAVY IMPURITY GOING BACK
C                         TO WALLS
C           IOPTRC      = OPTION FOR RECYCLING OF IMPLANTED H
C
C           MP          = MAX. NO. OF MESH-VALUES ALLOWED
C           MFLH        = DIMENSION OF FLHCHM()
C           MDIM        = DIMENSION OF ALBPG(), ALBEPG(), INUTPG()
C                         & IPSEMP()
C           MLK         = MAX. NO. OF LEAK SEGMENTS
C           MSEMPB      = MAX. NO. OF EXTRA BAFFLES
C           MIONH       = MAX. NO. OF HYDROGEN SPECIES
C           NIONH       = NO. OF HYDROGEN SPECIES
C           MWREG       = NUMBER OF WALL (SEGMENT) REGIONS
C           MMPG        = MAX. NO. OF POLYGONS (INPUT FROM INTFAC)
C
C           DENSE(K)    = ELECTRON DENSITY     AT MESH POINT K (CM-3)
C           DENSI(K,IH) = ION      DENSITY     AT MESH POINT K (CM-3)
C           TEMPE(K)    = ELECTRON TEMPERATURE AT MESH POINT K (EV)
C           TEMPI(K)    = ION      TEMPERATURE AT MESH POINT K (EV)
C           VPAR(K,IH)  = PARALLEL VELOCITY    AT MESH POINT K (CM/S)
C           HMASS(K,IH) = MASS OF ION (A.U)
C           TEVGAP      = TEMPERATURE OF VOIDS (EV)
C           FLHCHM(M)   = CHEMICAL FLUX TERM FOR POLYGON #M
C           MTOREG(M)   = WALL SEGMENT REGION ASSOCIATED WITH NIMBUS #M
C           RMATW(,,)   = FOR IMPLANTATION FLUXES (FOR IOPTRC=2)
C
C           INUTPG()    >  0 --- NIMBUS WALL REGION SET AS NEUTRAL
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -1 --- NIMBUS WALL REG. IN PRIV. REGION COVER
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -2 --- NIMBUS WALL REG. IN OUTER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -3 --- NIMBUS WALL REG. IN INNER DIVERTOR WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -4 --- NIMBUS WALL REG. IN OUTER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -5 --- NIMBUS WALL REG. IN INNER CORNER WALL
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -6 --- NIMBUS WALL REG. IN OUTER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -7 --- NIMBUS WALL REG. IN INNER DIV. TARGET
C                                SET AS NEUTRAL RECYCLER AT E=EATMR
C                       = -8 --- BUFFLE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                       = -9 --- ENTIRE WALL TO BE SET AS A RECYCLER
C                                REFLECTOR/RECYCLER WITH E=EATMR
C                                (INCL. BUFFLE)
C                       (ORDER OF INUTPG() IS IMPORTANT AS FIRST REGION
C                       IS TAKEN, REGARDLESS OF HOW OFTEN IT IS REPEATED
C                       IN THE LIST, IMPLICITLY OR EXPLICITLY)
C
C           IPSEMP()    = NIMBUS REGION IN WHICH THE SEMI-PERMEABILITY
C                         FRACTION IS SPECIFIED OVERRIDING ABOVE
C           PSEMP()     = SEMI-PERMEABILITY PROBABILITY FRACTION
C                         FOR EACH SPECIFIED REGION (OUTWARD)
C           PSEMG()     = SEMI-PERMEABILITY PROBABILITY FRACTION
C                         FOR EACH SPECIFIED REGION (INWARD)
C           PSEMPO      = PROBABILITY OF SEMI-PERMEABILITY OF OUTER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPT      = PROBABILITY OF SEMI-PERMEABILITY OF TARGET
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPI      = PROBABILITY OF SEMI-PERMEABILITY OF INNER SOL
C                         DIVERTOR REGIONS (PUMP STRUCTURE ONLY)
C           PSEMPX      = PROBABILITY OF SEMI-PERMEABILITY OF CHERVON
C                         IN PUMP STRUCTURE (PUMP STRUCTURE ONLY)
C           PSEMPB(I)   = PROBABILITY OF SEMI-PERMEABILITY OF BAFFLE
C                         I = 0 --- MAIN BAFFLE
C                         I > 0 --- EXTRA BAFFLE INDEX
C                         (1.0D+30 --- USE BAFFLE WITHOUT THIS)
C
C           ALBPG()     = ALBEDO REFLECTIVITY FRACTION
C           ALBEPG()    = ENERGY = E*ALBEPG()
C           ALBATO      = PROBABILITY THAT FUEL ATOMS AND ENERGETIC
C                         HELIUM ARE ALBEDOED AS ATOMS WITH
C                         ENERGY=E*ALBENE(IR)
C           ALBPMP      = ALBEDO FOR PUMP (=1.0-PUMP EFF)
C           ALBLK(L)    = ALBEDO OF LEAK #L
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C /CPUMP/ : (SEE 'cpump')
C
C ROUTINES: GETPHY            = GET PHYSICAL VALUES FOR POLYGON #M
C           GETTEM            = GET APPROPRIATE WALL TEMPERATURES
C           INDLRS            = INDEX OF LEAK
C           (I*4) I4CHRV       = CONVERT STRING TO INTEGER
C
C NOTES   : 1. REGIONS ARE DEFINED AS FOLLOWS,
C                REGION 1     = NIMBUS GEOMETRY CIRCLE    REGION
C                REGION 2     = NIMBUS GEOMETRY RECTANGLE REGION
C                REGION M+2   = REGIONS FOR NIMBUS POLYGONS,
C                               M=1 -> M=(LAST BEFORE PUMP STRUCTURE)
C                PUMP REGIONS = REGIONS FOR PUMP STRUCTURE ARE DEFINED
C                               IN PUMP FILE, SEE LRPUMP()
C                LAST REGION  = DUMMY REGION
C           2. REGION 1 IS NOT USED
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 26/11/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 IFILE      , LOUT   , NPOLY
     &        , IALB       , IAEMIS , ICORE , ICHARG , IOPTRC
     &        , MP         , MFLH   , MDIM  , MLK    , MSEMPB
     &        , MIONH      , NIONH  , MWREG , MMPG
      INTEGER*4 INUTPG(MDIM)   , IPSEMP(MDIM)    , MTOREG(MMPG)
      REAL*8    DENSE(MP)      , DENSI(MP,NIONH) , TEMPE(MP) , TEMPI(MP)
     &        , VPAR(MP,NIONH) , HMASS(NIONH)    , TEVGAP
     &        , FLHCHM(MFLH)   , RMATW(MIONH,NIONH,MWREG)
     &        , PSEMP(MDIM)    , PSEMG(MDIM)
     &        , PSEMPO         , PSEMPI          , PSEMPT    , PSEMPX
     &        , PSEMPB(0:MSEMPB)
     &        , ALBPG(MDIM)    , ALBEPG(MDIM)    , ALBATO
     &        , ALBPMP         , ALBLK(MLK)
      LOGICAL   LPMPST
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C../CPUMP/
      INCLUDE  'cpump'
C
C..ROUTINES
      INTEGER*4  INDLRS , I4CHRV
C
C..PARAMETERS
      REAL*8     UNITS
      PARAMETER( UNITS = 1.0D-13 )
C
C..LOCALS
      INTEGER*4 IR , I , L , M , N , K , IH , IWR , IB
     &        , IBOUND , IBOUNW , ISTARW , IBALB , IRES , NPTLRS
      REAL*8    DE     , DEW
     &        , TE     , TEW
     &        , TI     , TIW
     &        , DV
     &        , ALB    , ALBENE , POUTB , PINB
      CHARACTER*1 EMISD , EMISW , EMISX , CHARGD , CHARG
      CHARACTER*4 SYMD  , SYMW
      LOGICAL   LTRAN
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C-----------------------------------------------------------------------
C
      IF( IFILE.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      IBOUND    = 0            ! (SEE NIMBUS)
      IBOUNW    = 1            ! (SEE NIMBUS)
      ISTARW    = 0            ! (SEE NIMBUS)
      MPMPG     = 0            ! REGION OF ACTUAL PUMP
      IB        = 0            ! NO. OF BAFFLES
C
      DEW       = 0.0D+00      ! DENSITY OF REGION (AT WALL)
      ALB       = 1.0D+00      ! ALBEDO REFLECTIVITY FRACTION
      ALBENE    = 1.0D+00      ! ENERGY OF ALBEDO
C
      EMISD     = ' '          ! VOID/PLASMA EMISSION TYPE
      SYMD      = '    '       ! VOID/PLASMA SYMBOL
      CHARGD    = ' '          ! VOID/PLASMA & ALBEDO CHARGE
C
C-----------------------------------------------------------------------
C----------------------- DERIVED INITIALISATIONS -----------------------
C-----------------------------------------------------------------------
C
      IF( IALB.EQ.1 ) THEN
          IBALB = 2
      ELSE
          IBALB = IBOUNW
      ENDIF
C
      IF( IZINDW.NE.0 ) THEN
          SYMW  = SYMBOL(IZINDW)    ! CHEMICAL SYMBOL OF WALL
      ELSE
          SYMW  = '?   '            ! CHEMICAL SYMBOL OF WALL
      ENDIF
C
      IF( IAEMIS.EQ.+1 .OR. IAEMIS.EQ.-1 ) THEN
          EMISW = 'A'               ! ATOMIC    EMISSION
      ELSE IF( IAEMIS.EQ.0 .OR. IAEMIS.EQ.-2 ) THEN
          EMISW = 'M'               ! MOLECULAR EMISSION
      ELSE
          WRITE(LOUT,9010) IAEMIS
          CALL EXITX(LOUT)
      ENDIF
C
      WRITE(CHARG,2000) ICHARG
C
C-----------------------------------------------------------------------
C---------------------- NIMBUS RECTANGLE REGION ------------------------
C-----------------------------------------------------------------------
C
      IR       = 2
      WRITE(IFILE,1000) IR , -1
C
C-----------------------------------------------------------------------
C----------------------- REGIONS FROM POLYGONS -------------------------
C--------- NB. DENSITY IS IN CM-3 / 1.0E+13 UNITS FOR NIMBUS -----------
C-----------------------------------------------------------------------
C
      DO M = 1 , NPOLY
C
C....... INCREMENT NUMBER OF REGIONS (IN THIS BLOCK IR = M + 2 )
         IR     = IR + 1
C
C....... WRITE WALL MATERIAL DATA (WALLS ONLY) ?
         LTRAN  = .FALSE.
C
C....... PLASMA REGIONS
         IF( MPOLYT(M).EQ.1 ) THEN
             CALL GETPHY( M         , MP         , NIONH
     I                  , DENSE(1)  , DENSI(1,1) , TEMPE(1) , TEMPI(1)
     I                  , VPAR(1,1) , HMASS(1)
     O                  , N         , K
     O                  , DE        , TE         , TI       , DV      )
             WRITE(IFILE,1010) '1'        , IR
     &                       , DE * UNITS , TE     , TI    , DV
     &                       , ISTARW     , IBOUND , EMISD , CHARGD
     &                       , SYMD
C
C....... INNER (I.E. BULK) REGION (USE VALUES FOR M=1)
         ELSE IF( MPOLYT(M).EQ.2 ) THEN
             CALL GETPHY( 1         , MP         , NIONH
     I                  , DENSE(1)  , DENSI(1,1) , TEMPE(1) , TEMPI(1)
     I                  , VPAR(1,1) , HMASS(1)
     O                  , N         , K
     O                  , DE        , TE         , TI       , DV      )
             IF( ICORE.EQ.1 ) THEN
                 WRITE(IFILE,1010) '1'        , IR
     &                           , DE * UNITS , TE , TI    , DV
             ELSE
                 WRITE(IFILE,1000) IR , -2
             ENDIF
C
C....... PRIVATE VOID IS A WALL
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.0 ) THEN
             WRITE(IFILE,1010) ' '     , IR
     &                       , DEW     , TEVPR  , TEVPR  , FLHCHM(M)
     &                       , ISTARW  , IBOUNW , EMISX  , CHARG
     &                       , SYMW
             LTRAN = .TRUE.
C
C....... PRIVATE VOID IS AN ALBEDO
         ELSE IF( MPOLYT(M).EQ.6 .AND. IALB.EQ.1 ) THEN
             WRITE(IFILE,1010) '1'     , IR
     &                       , DEW     , TEVPR  , TEVPR  , FLHCHM(M)
     &                       , ISTARW  , IBALB  , EMISX  , CHARGD
     &                       , SYMW    , '+'
             WRITE(IFILE,1020) ALB , ALBATO , ALBENE
             LTRAN = .TRUE.
C
C....... PRIVATE VOID IS A VOID
         ELSE IF( MPOLYT(M).EQ.6 ) THEN
             WRITE(IFILE,1010) '1'     , IR
     &                       , 0.0D+00 , TEVGAP , TEVGAP , 0.0D+00
     &                       , ISTARW  , 0      , EMISD  , CHARGD
     &                       , SYMD
C
C....... BAFFLES (ARE ORDERED SEQUENTIALLY FROM MAIN BAFFLE)
         ELSE IF( MPOLYT(M).EQ.9 ) THEN
             CALL GETEMI( LOUT  , M , IAEMIS , MDIM , INUTPG(1) , EMISW
     O                  , EMISX )
             IB    = IB + 1         ! BAFFLE INDEX
             POUTB = PSEMPB(IB-1)   ! TRANSPARANCY OF BAFFLE
             IF( POUTB.GE.1.0D+30 ) THEN
                 WRITE(IFILE,1010) ' '    , IR
     &                           , DEW    , TEVPR  , TIVPR , FLHCHM(M)
     &                           , ISTARW , IBOUNW , EMISX , CHARG
     &                           , SYMW
             ELSE
                 WRITE(IFILE,1010) '1'    , IR
     &                           , DEW    , TEVPR  , TIVPR , FLHCHM(M)
     &                           , ISTARW , IBOUNW , EMISW , CHARGD
     &                           , SYMW   , '+'
                 WRITE(IFILE,1020) POUTB , 0.0D+00 , 0.0D+00
     &                                   , 0.0D+00 , 0.0D+00 , POUTB
             ENDIF
             LTRAN = .TRUE.
C
C....... SOL VOID
         ELSE IF( ITAGES(M).EQ.1 ) THEN
             WRITE(IFILE,1010) '1'     , IR
     &                       , 0.0D+00 , TEVGAP , TEVGAP , 0.0D+00
     &                       , ISTARW  , 0      , EMISD  , CHARGD
     &                       , SYMD
C
C....... WALL REGIONS
         ELSE IF( ITAGES(M).EQ.2 ) THEN
             CALL GETTEM( LOUT  , M , TE   , TI )
             CALL GETEMI( LOUT  , M , IAEMIS , MDIM , INUTPG(1) , EMISW
     O                  , EMISX )
             WRITE(IFILE,1010) ' '    , IR
     &                       , DEW    , TE     , TI    , FLHCHM(M)
     &                       , ISTARW , IBOUNW , EMISX , CHARG
     &                       , SYMW
             LTRAN = .TRUE.
C
C....... ALBEDO REGIONS
         ELSE IF( ITAGES(M).GT.2 ) THEN
             L     = ITAGES(M) - 3     ! INDEX IN ALBEDO ARRAY'S FOR #M
             CALL GETTEM( LOUT  , M , TE   , TI )
             CALL GETEMI( LOUT  , M , IAEMIS , MDIM , INUTPG(1) , EMISW
     O                  , EMISX )
             WRITE(IFILE,1010) '1'    , IR
     &                       , DEW    , TE  , TI    , FLHCHM(M)
     &                       , ISTARW , 2   , EMISX , CHARGD
     &                       , SYMW   , '+'
             WRITE(IFILE,1020) ALBPG(L) , ALBATO , ALBEPG(L)
             LTRAN = .TRUE.
C
C....... DIVERTOR PUMP WALL REGIONS
         ELSE IF( ITAGES(M).LT.0 ) THEN
             CALL GETTEM( LOUT  , M , TE   , TI )
             CALL GETPSP( LOUT      , M        , MDIM
     I                  , IPSEMP(1) , PSEMP(1) , PSEMG(1)
     I                  , PSEMPO    , PSEMPI   , PSEMPT
     O                  , POUTB     , PINB     )
             WRITE(IFILE,1010) '1'    , IR
     &                       , DEW    , TE     , TI    , FLHCHM(M)
     &                       , ISTARW , IBOUNW , EMISW , CHARGD
     &                       , SYMW   , '+'
             WRITE(IFILE,1020) POUTB , 0.0D+00 , 0.0D+00
     &                               , 0.0D+00 , 0.0D+00 , PINB
             LTRAN = .TRUE.
C
C....... UNDEFINED REGION
         ELSE
             WRITE(LOUT,9000) M , ITAGES(M) , MPOLYT(M)
             CALL EXITX(LOUT)
         ENDIF
C
C....... WRITE MATERIAL OF WALLS ?
         IF( IOPTRC.EQ.2 .AND. LTRAN ) THEN
             IWR = MTOREG(M)    ! A VALUE OF '0' IS ALLOWABLE
             IF( IWR.LT.0 .OR. IWR.GT.MWREG ) THEN
                 WRITE(LOUT,9020) M , IWR
                 CALL EXITX(LOUT)
             ENDIF
             DO IH=1,NIONH
                WRITE(IFILE,1030) '   ' , 0.0D+00
     &                          , (RMATW(L,IH,IWR), L=1,NIONH)
             ENDDO
         ENDIF
C
      ENDDO
C
C-----------------------------------------------------------------------
C---------------------- PUMP STRUCTURE REGIONS -------------------------
C----- NB. LRPUMP(L)(2:5) = **** MEANS A CONTINUATION OF A REGION ------
C-----------------------------------------------------------------------
C
      IF( LPMPST ) THEN
C
C........ LOOP OVER PUMP REGIONS
          DO I = NIMREG(2) + 1 , NIMREG(1) - 1
C
C........... INCREMENT NUMBER OF REGIONS
             IR     = IR + 1
C
C........... WRITE WALL MATERIAL DATA ? (WALLS ONLY)
             LTRAN  = .FALSE.
C
C........... PUMP VOID & PRESSURE GAUGES
             IF( COMM(I).EQ.' ' .OR.
     &           COMM(I).EQ.'G' .OR. COMM(I).EQ.'K' ) THEN
                 WRITE(IFILE,1010) '1'     , IR
     &                           , 0.0D+00 , TEVGAP , TEVGAP , 0.0D+00
     &                           , ISTARW  , 0      , EMISD  , CHARGD
     &                           , SYMD
C
C........... ACTUAL PUMP
             ELSE IF( COMM(I).EQ.'P' ) THEN
                 WRITE(IFILE,1010) '1'     , IR
     &                           , DEW     , TEVSD , TIVSD   , 0.0D+00
     &                           , ISTARW  , 2     , EMISW   , CHARGD
     &                           , SYMW    , '+'
                 WRITE(IFILE,1020) ALBPMP , 0.0D+00 , -1.0D+00
                 MPMPG = I
C
C........... LEAKS
             ELSE IF( COMM(I).GE.'1' .AND. COMM(I).LE.'9' ) THEN
                 N      = I4CHRV( COMM(I) )          ! ELEMENT OF ARRAY
                 NPTLRS = INDLRS( COMM(I) , LOUT )   ! LEAK INDEX
                 WRITE(IFILE,1010) '1'     , IR
     &                           , DEW     , TEVSD , TIVSD   , 0.0D+00
     &                           , ISTARW  , 2     , EMISW   , CHARGD
     &                           , SYMW    , '+'
                 WRITE(IFILE,1020) ALBLK(N) , 0.0D+00 , 0.0D+00
     &                           , FLOAT(NPTLRS)
C
C........... CHEVERON IN PUMP STRUCTURE
             ELSE IF( COMM(I).EQ.'X' .AND. PSEMPX.GT.0.0D+00 ) THEN
                 WRITE(IFILE,1010) '1'     , IR
     &                           , DEW     , TEVSD  , TIVSD   , 0.0D+00
     &                           , ISTARW  , IBOUNW , EMISW   , CHARGD
     &                           , SYMW    , '+'
                 WRITE(IFILE,1020) PSEMPX   , 0.0D+00 , 0.0D+00
     &                           , 0.0D+00 , 0.0D+00 , PSEMPX
                 LTRAN = .TRUE.
C
C........... WALLS OF PUMP STRUCTURE
             ELSE
                 WRITE(IFILE,1010) ' '     , IR
     &                           , DEW     , TEVSD  , TIVSD   , 0.0D+00
     &                           , ISTARW  , IBOUNW , EMISW   , '0'
     &                           , SYMW
                 LTRAN = .TRUE.
C
             ENDIF
C
C........... WRITE MATERIAL OF WALLS ?
             IF( IOPTRC.EQ.2 .AND. LTRAN ) THEN
                 IWR = MTOREG(I)    ! A VALUE OF '0' IS ALLOWABLE
                 IF( IWR.LT.0 .OR. IWR.GT.MWREG ) THEN
                     WRITE(LOUT,9020) M , IWR
                     CALL EXITX(LOUT)
                 ENDIF
                 DO IH=1,NIONH
                    WRITE(IFILE,1030) '   ' , 0.0D+00
     &                              , (RMATW(L,IH,IWR), L=1,NIONH)
                 ENDDO
             ENDIF
C
          ENDDO
C
      ENDIF
C
C-----------------------------------------------------------------------
C--------------------------- DUMMY REGION ------------------------------
C-----------------------------------------------------------------------
C
      IR       = IR + 1
      WRITE(IFILE,1000) IR , -1
C
C-----------------------------------------------------------------------
C
 1000 FORMAT( I6 , 48X , I6 )
 1010 FORMAT( 1X , A1 , I4 , 1P , 4E12.4 , 2I3 , A1 , A1 , A4 , A1 )
 1020 FORMAT( 6X , 1P , 6E12.4 )
 1030 FORMAT( 1X , A3 , 2X , F6.3 , T68,'RECMAT',T13,1P,3E12.4)
C
 2000 FORMAT( I1 )
C
 9000 FORMAT( / ' *** ERROR(WRPHYR) : ILLEGAL DEFINED REGION !!!!'
     &        / '                     M =' , I5
     &                               , ', ITAGES =' , I3
     &                               , ', MPOLYT =' , I3 )
 9010 FORMAT( / ' *** ERROR(WRPHYR) : ILLEGAL EMISSION TYPE !!!!'
     &        / '                     IAEMIS =' , I5 )
 9020 FORMAT( / ' *** ERROR(WRPHYR) : ILLEGAL MTOREG !!!!'
     &        / '                     M =' , I5
     &                               , ', MTOREG =' , I3 )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE CORCOV( LOUT , NPOLY )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : CORNERS FROM PRIVATE REGION COVER
C           --                          ---
C PURPOSE : TO OBTAIN CORNER DATA FROM PRIVATE REGION COVER POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           NPOLY       = NUMBER OF POLYGONS CREATED
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C NOTES   : 1. THE INFINITY LINE IS ALWAYS ORDERED LHS TO RHS.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 03/12/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT   , NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4 ISIDE , M , M0 , I , IV , IV0 , IV1 , IVM1 , IVP1
      REAL*8    RMIN  , RMAX
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C-----------------------------------------------------------------------
C
      IF( IESCF.LE.0 ) GOTO 9999
C
C-----------------------------------------------------------------------
C------------ LOCATE POLYGONS/VERTICES TOUCHING HORIZONTAL -------------
C-----------------------------------------------------------------------
C
C.... <BEGIN> LOOP OVER RHS & LHS SIDES
      DO ISIDE = 1 , 2
C
C....... HAS NON-HORIZONTAL BORDERING POLYGON ALREADY BEEN FOUND ?
         IF( MCORN(ISIDE,2).GT.0 ) GOTO 300
C
C....... <BEGIN> LOOP OVER PRIVATE COVER POLYGONS
         DO M = NPOLYK(7) , NPOLY
C
C.......... PROCESS ONLY NON-HORIZONTAL POLYGONS
            IF( IHORIZ(M).NE.0 ) GOTO 100
C
C.......... <BEGIN> LOOP OVER EACH VERTEX IN POLYGON
            DO IV = 1 , NVERTM(M)
C
C............. NEIGHBOURING VECTICES OF #IV
               IVM1 = IV - 1
               IVP1 = IV + 1
               IF( IVM1.LT.1         ) IVM1 = NVERTM(M)
               IF( IVP1.GT.NVERTM(M) ) IVP1 = 1
C
C............. DOES VERTEX #IV TOUCH PLASMA-SIDE VERTEX OF HORIZ POLY
               IF( RVERTM(M,IV).EQ.RCORN(ISIDE,1) .AND.
     &             ZVERTM(M,IV).EQ.ZCORN(ISIDE,1)       ) THEN
C
C................. FIND PROPER SIDE OF NON-HORIZ POLYGON
                   IF( ISIDE.EQ.1 ) THEN
                       I = NINF   ! RHS EXTREME ON INFINITY LINE
                   ELSE
                       I = 1      ! LHS EXTREME ON INFINITY LINE
                   ENDIF
C
                   IF( RVERTM(M,IVM1).EQ.RINF(I) .AND.
     &                 ZVERTM(M,IVM1).EQ.ZINF(I)       ) THEN
                       M0  = M       ! BORDERING NON-HORIZ POLYGON
                       IV0 = IV      ! PLASMA-SIDE VERTEX
                       IV1 = IVM1    ! EXTRAP. VERTEX
                       GOTO 200
                   ELSE IF( RVERTM(M,IVP1).EQ.RINF(I) .AND.
     &                      ZVERTM(M,IVP1).EQ.ZINF(I)       ) THEN
                       M0  = M       ! BORDERING NON-HORIZ PLOYGON
                       IV0 = IV      ! PLASMA-SIDE VERTEX
                       IV1 = IVP1    ! EXTRAP. VERTEX
                       GOTO 200
                   ENDIF
               ENDIF
C
C.......... <END> LOOP OVER EACH VERTEX IN POLYGON
            ENDDO
C
C....... <END> LOOP OVER PRIVATE COVER POLYGONS
  100    ENDDO
C
C....... UPDATE DATA FOR CORNER POLYGON ?
  200    IF( M0.GT.0 ) THEN
             MCORN(ISIDE,2) = M0
             RCORN(ISIDE,4) = RVERTM(M0,IV1)
             ZCORN(ISIDE,4) = ZVERTM(M0,IV1)
             RCORN(ISIDE,5) = RVERTM(M0,IV0)
             ZCORN(ISIDE,5) = ZVERTM(M0,IV0)
         ELSE IF( ISIDE.EQ.1 ) THEN
             WRITE(LOUT,9000) 'RHS'
             CALL EXITX(LOUT)
         ELSE IF( ISIDE.EQ.2 ) THEN
             WRITE(LOUT,9000) 'LHS'
             CALL EXITX(LOUT)
         ENDIF
C
C.... <END> LOOP OVER RHS & LHS SIDES
  300 ENDDO
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(CORCOV) : UNABLE TO DETERMINE ' , A
     &                              ,' CORNER !!!!' )
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE FXCOV( LOUT  , LPASS
     I                , RPX   , ZPX   , PROJ
     O                , NPOLY )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : FIX COMPLEX PRIVATE REGION COVER POLYGONS
C           - -                        ---
C PURPOSE : TO CREATE COMPLEX PRIVATE REGION COVER POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           LPASS       = .T. --- DON'T STOP ON ERROR UNLESS FATEL
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C
C I/O     : NPOLY       = NUMBER OF POLYGONS CREATED
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: CKPOLY      = CHECK POLYGON  LIMITS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 04/12/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
      REAL*8    RPX   , ZPX , PROJ
      LOGICAL   LPASS
C
C..I/O
      INTEGER*4 NPOLY
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4  IV    , IER ,  ITOP(4*MWAL)
      LOGICAL    LSIMP
C
C-----------------------------------------------------------------------
C----------------- CREATE ANY HORIZONTAL COVER POLYGONS ----------------
C-----------------------------------------------------------------------
C
      CALL HZCOV( LOUT
     I          , RPX   , ZPX   , PROJ
     O          , NPOLY , LSIMP )
C
C-----------------------------------------------------------------------
C------------- NON-HORIZONTAL COMPONENTS OF VESSEL/VOID LINE -----------
C-----------------------------------------------------------------------
C
      NWALR = 0   ! NO. OF POINTS IN REDUCED VESSEL/VOID LINE
C
      DO IV = 1 , NWAL
         IF( IHWAL(IV).LE.0 ) THEN
             NWALR        = NWALR + 1
             RWALR(NWALR) = RWAL(IV)
             ZWALR(NWALR) = ZWAL(IV)
         ENDIF
      ENDDO
C
C-----------------------------------------------------------------------
C---------------- CREATE DUMMY POLYGON FOR S.R 'FXPOLY' ----------------
C---- REQUIRED IF SIMPLE COVER POLYGON WAS REPLACED IN S.R 'HZCOV' -----
C-------- SINCE POLYGON 'NPOLY' WILL BE OVER-WRITTEN BY FXPOLY ---------
C-----------------------------------------------------------------------
C
      IF( LSIMP ) THEN
          CALL CKPOLY( LOUT , NPOLY , MPG
     &               , 'VERTICAL VESS/PR VOID COVER' )
          NPOLY         = NPOLY + 1
          NVERTM(NPOLY) = 0
      ENDIF
C
C-----------------------------------------------------------------------
C----------------- CREATE NON-HORIZONTAL COVER POLYGONS ----------------
C---- REMEMBER THAT POLYGON 'NPOLY' WILL BE OVER-WRITTEN BY FXPOLY -----
C-----------------------------------------------------------------------
C
      CALL FXPOLY( LOUT        , 2           , LPASS
     I           , MPG         , MRG         , MWAL
     I           , NINF        , RINF(1)     , ZINF(1)
     I           , NWALR       , RWALR(1)    , ZWALR(1)
     O           , NPOLY       , NVERTM(1)
     O           , RVERTM(1,1) , ZVERTM(1,1) , ITAGES(1)
     O           , ITOP(1)     , IER         )
C
      IF( IER.NE.0 ) THEN
          WRITE(LOUT,9000) ' WALL ' , IER
          CALL EXITX(LOUT)
      ELSE IF( NVERTM(NPOLY).EQ.0 ) THEN
          NPOLY = NPOLY - 1    ! NO NEW POLYGONS CREATED BY FXPOLY
                               ! SO, REMOVE DUMMY POLYGON
      ENDIF
C
C-----------------------------------------------------------------------
C
 9000 FORMAT( / ' *** ERROR(FXCOV) : UNABLE TO SET PRIVATE REGION'
     &        , A , 'POLYGONS --- IER =' , I2
     &        / 21X , 'TRY CHANGING NPWALL & FPWALL() IN /NIMBIN/' /)
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE HZCOV( LOUT
     I                , RPX   , ZPX   , PROJ
     O                , NPOLY , LSIMP )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : HORIZONTAL VESSEL/PRIVATE REGION VOID COVER POLYGONS
C           -   -                            ---
C PURPOSE : TO CREATE HORIZONTAL POLYGONS FROM THE VESSEL/PRIVATE
C           VOID LINE AND TO LABEL THOSE POINTS WHICH CREATED THE
C           POLYGONS.
C
C INPUT   : LOUT        = OUTPUT CHANNEL FOR MESSAGES
C           RPX         = R-COORD OF X-POINT
C           ZPX         = Z-COORD OF X-POINT
C           PROJ        = PROJECTION FACTOR FOR EXTRAPOLATIONS
C
C I/O     : NPOLY       = NUMBER OF POLYGONS CREATED
C
C OUTPUT  : LSIMP       = .T. --- SIMPLE COVER POLYGON HAS BEEN
C                                 REPLACED
C
C /CPOLYG/: (SEE 'c09')
C
C /CLINK/ : (SEE 'clink')
C
C ROUTINES: LBREC       = CHECK IF POINT IS INSIDE NIMBUS RECTANGLE
C           CKPOLY      = CHECK POLYGON  LIMITS
C
C NOTES   : 1. INFINITY LINE IS CONSTRUCTED LEFT TO RIGHT
C           2. VESSEL/PRIVATE VOID INTERFACE LINE IS CONSTRUCTED
C              FROM THE LEFT SIDE OVER THE OVER TO THE RIGHT
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 04/12/98 --- CREATION
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LOUT
      REAL*8    RPX , ZPX , PROJ
C
C..I/O
      INTEGER*4 NPOLY
C
C..OUTPUT
      LOGICAL   LSIMP
C
C../CPOLYG/ & /CLINK/ PARAMETERS
      INCLUDE  'p09'
C
C../CPOLYG/
      INCLUDE  'c09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..ROUTINES
      LOGICAL LBREC
C
C..LOCALS
      INTEGER*4 I , IP1 , IV , LV , ISIDE , M
     &        , ISTART(2) , ISTOP(2) , IVERT(2)
      REAL*8    XPROJ
      LOGICAL   LTRAN , LSIDE(2)
C
C-----------------------------------------------------------------------
C--------------------------- INITIALISATION ----------------------------
C-----------------------------------------------------------------------
C
      CALL RESETI( IHWAL(1)  , MWAL , 0 )
      CALL RESETI( ISTART(1) , 2    , 0 )
      CALL RESETI( ISTOP(1)  , 2    , 0 )
C
      LSIMP = .FALSE.       ! HAS SIMPLE COVER POLYGON BEEN REPLACED ?
C
      LSIDE(1) = .FALSE.    ! PROCESS RHS
      LSIDE(2) = .FALSE.    ! PROCESS LHS
C
C-----------------------------------------------------------------------
C---------------------------- CHECK INPUT ------------------------------
C-----------------------------------------------------------------------
C
      IF( IESCF.NE.1 ) GOTO 9999
C
C-----------------------------------------------------------------------
C-------- IDENTIFY LHS & RHS POINTS ON VESSEL/PRIVATE VOID LINE --------
C------------- REMEMBER LINE IS CONSTRUCTED LEFT TO RIGHT --------------
C-----------------------------------------------------------------------
C
C.... FIND LHS & RHS STARTING POINT AND FINISHING POINT
      ISTART(2) = 1    ! LHS STARTING POINT
C
      DO I = 1 , NWAL
         IF( IVWAL(I).EQ.IVMAX(2) ) ISTOP(2)  = I   ! LHS TIP
         IF( IVWAL(I).EQ.IVMAX(1) ) ISTART(1) = I   ! RHS TIP
      ENDDO
C
      ISTOP(1) = NWAL  ! RHS FINISHING POINT
C
C.... PROCESS RESPECIVE SIDES
      IF( ISTOP(2).GT.0  ) LSIDE(2) = .TRUE.        ! PROCESS LHS
      IF( ISTART(1).GT.0 ) LSIDE(1) = .TRUE.        ! PROCESS RHS
C
C.... LABEL RESPECTIVE HORIZONTAL SIDES (SPECIAL LABEL FOR VESS TIPS)
      DO ISIDE = 1 , 2
         IF( LSIDE(ISIDE) ) THEN
C
             DO I = ISTART(ISIDE) , ISTOP(ISIDE)
                IHWAL(I) = ISIDE
             ENDDO
C
             IF( ISIDE.EQ.1 ) THEN
                 IHWAL( ISTART(1) ) = -ISIDE
             ELSE
                 IHWAL( ISTOP(2) )  = -ISIDE
             ENDIF
C
         ENDIF
      ENDDO
C
C-----------------------------------------------------------------------
C-------------- CREATE LHS/RHS HORIZONTAL COVER POLYGONS ---------------
C-----------------------------------------------------------------------
C
      DO I = 1 , NWAL - 1
C
C....... NEXT VERTEX
         IP1 = I + 1
C
C....... REMEMBER CYCLIC NATURE OF VESSEL
         IF( IP1.EQ.NVES ) IP1 = 1
C
C....... GET VERTEX SIDE
         ISIDE  = ABS( IHWAL(I) )
C
C....... SKIP ANY POLYGONS ?
         IF( IHWAL(I).EQ.0 .OR.
     &       ( IHWAL(I).LT.0 .AND. IHWAL(IP1).EQ.0 ) ) GOTO 200
C
C....... REPLACE SIMPLE COVER POLYGON OR CREATE NEW PLOYGON
         IF( .NOT.LSIMP ) THEN
             LSIMP = .TRUE.   ! SIMPLE COVER POLYGON BEING REPLACED
                              ! (I.E. KEEP NPOLY THE SAME)
         ELSE
             CALL CKPOLY( LOUT , NPOLY , MPG
     &                  , 'HORIZ VESS/PR VOID COVER' )
             NPOLY = NPOLY + 1
         ENDIF
C
C....... 1ST VERTEX : PLASMA SIDE VERTEX  (UPPER-MOST FOR LHS)
         RVERTM(NPOLY,1) = RWAL(IP1)
         ZVERTM(NPOLY,1) = ZWAL(IP1)
C
C....... 4TH VERTEX : PLASMA SIDE VERTEX  (UPPER-MOST FOR LHS)
         RVERTM(NPOLY,4) = RWAL(I)
         ZVERTM(NPOLY,4) = ZWAL(I)
C
C....... 2ND/3RD VERTEX : EXTRAPOLATION FROM X-POINT
         XPROJ = PROJ
C
         DO IV = 2 , 3
C
            IF( IV.EQ.2 ) THEN
                LV = 1  ! VERTEX 2 IS EXTRAPOLATED FROM VERTEX 1
            ELSE
                LV = 4  ! VERTEX 3 IS EXTRAPOLATED FROM VERTEX 4
            ENDIF
C
  100       RVERTM(NPOLY,IV) = RVERTM(NPOLY,LV)
     &                       + ( RVERTM(NPOLY,LV) - RPX ) * XPROJ
            ZVERTM(NPOLY,IV) = ZVERTM(NPOLY,LV)
C
C.......... INCREASE XPROJ UNTIL VERTEX LIES OUTSIDE NIMBUS RECT.
            LTRAN = LBREC( RVERTM(NPOLY,IV) , ZVERTM(NPOLY,IV)
     &                   , GEOM(1)          , GEOM(2)
     &                   , GEOM(1)+GEOM(3)  , GEOM(2)+GEOM(4) )
C
            IF( LTRAN ) THEN
                XPROJ = 1.5D+00 * XPROJ  ! INCREASE PROJECTION
                GOTO 100
            ENDIF
C
         ENDDO
C
C....... SET TYPES FOR NEW POLYGON
         ITAGES(NPOLY) = 2    ! WALL POLYGON
         IHORIZ(NPOLY) = 1    ! HORIZONTAL POLYGON
         NVERTM(NPOLY) = 4    ! NO. OF VERTICES IN POLYGON
C
C....... UPPER-MOST HORIZONTAL COVER POLYGON
         IF( ISIDE.EQ.2 ) THEN
             MCORN(ISIDE,1) = NPOLY     ! LAST  LHS POLYGON
         ELSE IF( I.EQ.ISTART(1) ) THEN
             MCORN(ISIDE,1) = NPOLY     ! FIRST RHS POLYGON
         ENDIF
C
  200 ENDDO
C
C-----------------------------------------------------------------------
C----------------- UPDATE DATA FOR CORNER POLYGONS ---------------------
C-----------------------------------------------------------------------
C
      DO ISIDE = 1 , 2
C
C....... SKIP SIDE ?
         IF( .NOT.LSIDE(ISIDE) ) GOTO 300
C
C....... VERTICES FOR CORNERS (SEE FIGURE IN HEADER FOR EXPLANATION)
         IF( ISIDE.EQ.1 ) THEN
             IVERT(1) = 4   ! RHS HORIZ     UPPER-SIDE PLASMA VERTEX
             IVERT(2) = 3   ! RHS HORIZ     UPPER-SIDE EXTRAP VERTEX
         ELSE
             IVERT(1) = 1   ! LHS HORIZ     UPPER-SIDE PLASMA VERTEX
             IVERT(2) = 2   ! LHS HORIZ     UPPER-SIDE EXTRAP VERTEX
         ENDIF
C
C....... HORIZONTAL BORDER (FROM HORIZNTAL TARGET POLYGON)
         IF( MCORN(ISIDE,1).GT.0 ) THEN
             M              = MCORN(ISIDE,1)      ! POLYGON INDEX
             RCORN(ISIDE,1) = RVERTM(M,IVERT(1))  ! HORIZ PLASMA VERTEX
             ZCORN(ISIDE,1) = ZVERTM(M,IVERT(1))
             RCORN(ISIDE,2) = UDEF                ! SWITCH OFF VESS CUT
             ZCORN(ISIDE,2) = UDEF
             RCORN(ISIDE,3) = RVERTM(M,IVERT(2))  ! HORIZ EXTRAP VERTEX
             ZCORN(ISIDE,3) = ZVERTM(M,IVERT(2))
         ENDIF
C
  300 ENDDO
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SETLNK( )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : SET /CLINK/ VARIABLES
C           ---   - --
C PURPOSE : INITIALISES SOME ARRAYS IN COMMON BLOCK /CLINK/.
C
C INPUT   : NONE
C
C OUTPUT  : (SEE CLINK/)
C
C /CLINK/ : (SEE 'clink')
C
C NOTES   : 1. THIS COULD BE A /BLOCKDATA/ BUT AS NIMBUS HAS MANY
C              IT WAS DECIDED TO USE A SIMPLE SUBROUTINE.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C (C)     : JET JOINT UNDERTAKING (1998)
C
C HISTORY : V1.R1.M0 --- 03/03/98 --- CREATION
C
C- .....................................................................
C
C..PARAMETERS
      INCLUDE  'p09'
C
C../CLINK/
      INCLUDE  'clink'
C
C..LOCALS
      INTEGER*4   I
     &          , INDDAT(MSYM)
      CHARACTER*4 SYMDAT(0:MSYM)
C
C-----------------------------------------------------------------------
C
      DATA SYMDAT / '????'
     &            , 'FE  ' , 'CU  ' , 'C   ' , 'MO  ' , 'NI  '
     &            , 'W   ' , 'AL  ' , 'AU  ' , 'BE  ' , 'SI  '
     &            , 'TA  ' , 'TI  ' , 'V   ' , 'ZR  ' , 'NE  '
     &            , 'HE  ' , 'N   ' , 'O   ' /
C
      DATA INDDAT /
     &               26    ,  29    ,   6    ,  42    ,  28
     &            ,  74    ,  13    ,  79    ,   4    ,  14
     &            ,  73    ,  22    ,  23    ,  40    ,  10
     &            ,   2    ,   7    ,   8    /
C
C------------------------- INITIALISE ARRAYS ---------------------------
C
      DO I = 0 , MSYM
         SYMBOL(I) = SYMDAT(I)
      ENDDO
C
      DO I = 1 , MSYM
         INDEX(I) = INDDAT(I)
      ENDDO
C
C-----------------------------------------------------------------------
C
      RETURN
      END
