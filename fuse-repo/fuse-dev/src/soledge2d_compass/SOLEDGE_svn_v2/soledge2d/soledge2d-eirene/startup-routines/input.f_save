!pb  20.03.08:  allocate and nullify estiml(1) if no input block 10F 
!pb             is available
!pb  01.08.07:  save NLSRON in case of coupled run with short cycle
!    20.06.07:  check NVOLPR against NSPEZV_DIM
!pb  22.05.07:  input of NPTSDEL added in block 7
!pb  20.04.07:  check of geometry flags added
!pb  20.04.07:  check for casename of NLFEM or NLTET
!pb  20.04.07:  option for reading triangle grid from Eirene input
!pb             file removed
!pb  22.03.07:  LEVGEO=6 --> LEVGEO=10
!pb  21.03.07:  logicals in block 1 cleaned up
!pb  02.03.07:  fourth secondary group in species specification cards
!pb             introduced
!pb  02.03.07:  remove ESCD2* arrays, use local variables instead
!pb             sum up ESCD1 and ESCD2 contributions
!pb  12.01.07:  one additional line in input block 4 defining the
!pb             HYDKIN default model
!pb  09.01.07:  input of reaction cards (block 4) rewritten using
!pb             read_token
!pb  01.12.06:  bug fix: advance line in input for tetrahedrons
!pb  01.11.06:  definition of NCOPI is changed: NCOPI is number of
!pb             coupling tallies used in UPTCOP
!pb             no longer multiplied by NPLSI to get NCPVI
!pb  09.10.06:  save NZADD for higher timesteps
!dr  20.04.06:  fort.10 added as density-model in block 5.
!dr             Also other density model may now refere to test-
!dr             particle tallies, for post processing and iteration
!pb  02.03.06:  NLRAY: switch on raytracing method for stratum
!pb  20.01.06:  line of sight for cell based spectrum introduced
!pb  12.01.06:  flag for cell based spectrum added in block 10F
C    24.09 05:  CALL TO IF2COP NOW LATER, AFTER ALL PLASMA DATA ARE SET
C               SO THAT IF2COP CAN BE USED WITHOUT HAVING TO USE IF1COP
C
cdr june-05:  spectrum input (10F) extended: SPC_SHIFT,.....
cdr                                SPCPLT_X,SPCPLT_Y,SPCPLT_SAME
cdr           see corresponding changes in CESTIM (ESTIML...)
cdr  28.4.04: nhsts(ispz) introduce, to select species
cdr           for trajectory plot
cdr           default: = 0: "plot trajectory for this species"
cdr           new    : =-1: "do not plot trajectory for this species"
cdr           see modifications in plt2d.f from 28.4.04
cpb sept-05:  specification of filenames for reaction databases in input
cpb           block 4 added. Lines are inserted between number of reactions
cpb           and reaction cards
cpb           example:
cpb           CFILE AMJUEL /home/boerner/Database/AMdata/amjuel.tex
 
      SUBROUTINE EIRENE_INPUT
C
C   READ INPUT DATA AND SET DEFAULT VALUES
C
      USE EIRMOD_PRECISION
      USE EIRMOD_PARMMOD
      USE EIRMOD_COMUSR
      USE EIRMOD_CADGEO
      USE EIRMOD_CCONA
      USE EIRMOD_CGRPTL
      USE EIRMOD_CLOGAU
      USE EIRMOD_CPL3D
      USE EIRMOD_CPLOT
      USE EIRMOD_CINIT
      USE EIRMOD_COMSIG
      USE EIRMOD_CREF
!pb      USE EIRMOD_CREFMOD
      USE EIRMOD_CPOLYG
      USE EIRMOD_CGRID
      USE EIRMOD_CZT1
      USE EIRMOD_CTRCEI
      USE EIRMOD_CCOUPL
      USE EIRMOD_CGEOM
      USE EIRMOD_CSDVI
      USE EIRMOD_CSDVI_COP
      USE EIRMOD_COMPRT
      USE EIRMOD_CPES
      USE EIRMOD_COMNNL
      USE EIRMOD_COMSOU
      USE EIRMOD_CSTEP
      USE EIRMOD_COMSPL
      USE EIRMOD_CTEXT
      USE EIRMOD_CLGIN
      USE EIRMOD_COMXS
      USE EIRMOD_CSPEI
      USE EIRMOD_CTRIG
      USE EIRMOD_CTETRA
      USE EIRMOD_CESTIM
      USE EIRMOD_CUPD
      USE EIRMOD_PHOTON
 
      IMPLICIT NONE
 
      INCLUDE 'mpif.h'
C
      TYPE TEMPERATURE
        DOUBLE PRECISION          :: TE, TI
        INTEGER                   :: IN, IDION
        TYPE(TEMPERATURE),POINTER :: NEXT
      END TYPE TEMPERATURE
C
      TYPE DENSITY
        DOUBLE PRECISION      :: DI
        INTEGER               :: IN, IDION
        TYPE(DENSITY),POINTER :: NEXT
      END TYPE DENSITY
C
      TYPE VELOCITY
        DOUBLE PRECISION       :: VX, VY, VZ
        INTEGER                :: IZ, IN, IDION
        TYPE(VELOCITY),POINTER :: NEXT
      END TYPE VELOCITY
C
      TYPE VOLUMEP
        DOUBLE PRECISION     :: VOL
        INTEGER              :: IN
        TYPE(VOLUMEP),POINTER :: NEXT
      END TYPE VOLUMEP
C
      TYPE(TEMPERATURE),POINTER :: TEMPLIST, TEMPCUR
      TYPE(DENSITY),POINTER :: DENLIST, DENCUR
      TYPE(VELOCITY),POINTER :: VELLIST, VELCUR
      TYPE(VOLUMEP),POINTER :: VOLLIST, VOLCUR
C
      TYPE SURFACE
        CHARACTER(70)         :: MODNAME
        INTEGER               :: NOSURF
        TYPE(SURFACE),POINTER :: NEXT
      END TYPE SURFACE
C
      TYPE REFMODEL
        CHARACTER(70) :: REFNAME
        INTEGER       :: JLREF,JLSPT
        INTEGER, DIMENSION(:), POINTER :: JSRS,JSRC
        REAL(DP)      :: ZNMLR,EWALLR,EWBINR,FSHEATR
        REAL(DP), DIMENSION(:,:), POINTER :: TRANSPR
        REAL(DP), DIMENSION(:), POINTER ::
     .                                   RCYCFR,RCYCTR,RCPRMR,
     .                                   EXPPLR,EXPELR,EXPILR,
     .                                   RCYCSR,RCYCCR,STPRMR
        TYPE(REFMODEL),POINTER :: NEXT
      END TYPE REFMODEL
C
      TYPE(SURFACE), POINTER :: SURFLIST, SURFCUR, SURFCUR2
      TYPE(REFMODEL), POINTER :: REFLIST, REFCUR
 
      TYPE REFFILE
        CHARACTER(420) :: RFILE
        TYPE(REFFILE), POINTER :: NEXT
      END TYPE REFFILE
 
      TYPE(REFFILE), POINTER :: REFFILES, CURFILE
 
      TYPE(EIRENE_SPECTRUM), POINTER :: ESPEC, SSPEC
C
      REAL(DP) :: AFF(3,3), AFFI(3,3), FP(6)
      REAL(DP) :: RP1, SA, SI, THMAX, SM, SPP, DTIMVO, SAVE, VOLTOT_TAL,
     .          XLREF, YLREF, ZLREF, XLROT, YLROT, ZLROT, XLCOR, SPH,
     .          YLCOR, ZLCOR, ALR, ROTNRM, XSH, RPSDL,
     .          YSH, ALROT, REFNRM, ZSH, RMN, DPP, RMX,
     .          SPCMN, SPCMX,SPC_SHIFT,
     .          SPCPLT_X,SPCPLT_Y,SPCPLT_SAME, SPCVX, SPCVY, SPCVZ,
     .          VNORM, RCMIN, RCMAX, ESCD2A, ESCD2M, ESCD2I, ESCD2PH,
     .          ESCD2P
      REAL(DP) :: tpb1, tpb2, SECOND_OWN
      REAL(DP), ALLOCATABLE :: SAREA_SAVE(:)
      INTEGER :: IHELP(NLIMPS), IPRSF(12), NUMTAL(12), IADTYP(0:4)
      INTEGER :: JP, KT, IM, II, IP, IA, NFLGS, NSPZS1, NSPZS2, IPH,
     .           NTLVF, NSRF, NTLS, I1000, NSP, NTL, ICHORI, IRAD,
     .           ILIMPS, ISS, ILA, IB, ILE, INT, NSOPT, IIN, ITEND,
     .           EIRENE_ILLZ, IZ, ISTREAM, ITALI, IAN, IAB, IBEND, IEN, 
     .           NO, IGO, IRPTA3, IRPTE2, IRPTE3, ITINI, IH, IDIMP,
     .           JDUMMY, IRPTA1, IRPTA2, IRPTE1, NLJ, I1, I2, I3,
     .           NTIME0, NITER0, IERROR, IREAD, I, ISTS, J, IST,
     .           IPOS2, IPOS0, NM, K, JJ, IPOS1, NRGEN, INUM, NTLSF,
     .           L, INILGJ, INI, ICO, IS, NTLV, ID, IRE, NSC,
     .           IN, INELGJ, NPRCSF, MXL, NSPZV1, NSPZV2, NFLGV,
     .           IPRCSF, IR, MT, MP, NDUMM, NUMSEC, NDUMM1, NDUMM2,
     .           NRTAL1, NCOPI, NCOPII, NCOPIE, NFR, NREAC_ADD, IPLN,
     .           NDUMM3, NDUMM4, NRE, ISPSRF, ISPTYP, NSPS, IPTYP, IPSP,
     .           IANF, IEND, IDEFLT_SPUT, IDEFLT_SPEZ, ITLVOUT, NTLVOUT,
     .           ITLSOUT, NTLSOUT, IPLSTI, IPLSV, IFILE, ISRFCLL,
     .           IDIREC, ISTCHR, JFEXMN, JFEXMX, ITOK, IER, IL, ILOGS,
     .           IUNIN_SAVE
      INTEGER, SAVE :: NZADD
      INTEGER, EXTERNAL :: EIRENE_IDEZ
      LOGICAL :: LHELP(NLIMPS), NLSRON_SAVE(NSTRA)
      LOGICAL :: LRPS3D, LRPSCN, LHYDDEF, LINCLUDE
      CHARACTER(10) :: CDATE, CTIME
      CHARACTER(12) :: CHR, HYDKIN_DEFAULT, CADAPT
      CHARACTER(420) :: ZEILE, FILE, ULINE
      CHARACTER(8) :: FILNAM, varname, spcname
      CHARACTER(4) :: H123, CLAB
      CHARACTER(9) :: REAC
      CHARACTER(50) :: REAC2
      CHARACTER(3) :: CRC
      CHARACTER(400) :: PATH
      CHARACTER(72), ALLOCATABLE, SAVE ::
     .               TXTTLA(:), TXTTLC(:), TXTTLR(:), TXTTLT(:)
      CHARACTER(24), ALLOCATABLE, SAVE ::
     .               TXTSCA(:), TXTSCC(:), TXTSCR(:), TXTSCT(:),
     .               TXTUTA(:), TXTUTC(:), TXTUTR(:), TXTUTT(:)
      CHARACTER(6) :: HANDLE
      CHARACTER(2) :: ELNAME
C
C  DO NOT READ ANY INPUT, IF THIS IS NOT THE VERY FIRST ITERATION
C  STEP IN THIS RUN. IITER IS THE ACTUAL ITERATION NUMBER
C  DO NOT READ ANY INPUT, IF THIS IS NOT THE VERY FIRST TIMESTEP
C  IN THIS RUN. ITIMV IS THE ACTUAL TIMESTEP NUMBER
C
C  INITIALIZE SOME DATA AND SET DEFAULTS
C
      IREAD=1
C
C  UNIT NUMBER FOR INPUT FILE: MUST BE DIFFERENT FROM: 5,8,10,11,12
C  13,14, AND 15
      IUNIN=1
C
C  UNIT NUMBER FOR OUTPUT FILE: MUST BE DIFFERENT FROM: 5,8,10,11,12
C  13,14, AND 15 AND IUNIN
      IUNOUT=6
C
      IF (IITER.GT.1) GOTO 4000
      IF (ITIMV.GT.1) GOTO 4000
 
!pb      TPB1=SECOND_OWN()
C
      IREAD=0
      IERROR=0
C
      NAINI=0
      NCPVI=0
      NBGVI=0
      MTSURF=0
C
C  SET DEFAULT REACTION MODELS
C
      CALL EIRENE_SETUP_DEFAULT_REACTIONS
 
C
C  SET DEFAULT SOURCE MODEL
C
      NSTRAI=0
C
C  SET DEFAULT 'ADDITIONAL SURFACE' AND 'STANDARD SURFACE' DATA
C
      NBITS=BIT_SIZE(I)
      CALL EIRENE_SET_DEF_SURF_DATA
 
      ALLOCATE (SAREA_SAVE(NLIMPS))
      SAREA_SAVE = 666.
 
      NULLIFY(SURFLIST)
      NULLIFY(REFLIST)
C
C  SET DEFAULT DATA FOR BLOCK 13
C
      DTIMV=1.D30
      TIME0=0.
      NSNVI=0
      NTMSTP=1
 
C  BY DEFAULT SWITCH OFF MOMENTUM DENSITY TALLIES
C  FOR USE OF THOSE TALLIES THEY NEED TO BE
C  SWITCHED ON IN BLOCK 11 EXPLICITELY
 
C  LV?DEN.. IS AN ALIAS FOR AN ENTRY IN ARRAY LMISTALV
C  THEREFORE .TRUE. MEANS: SWITCHED OFF
      LVXDENA  = .TRUE.
      LVXDENM  = .TRUE.
      LVXDENI  = .TRUE.
      LVXDENPH = .TRUE.
      LVYDENA  = .TRUE.
      LVYDENM  = .TRUE.
      LVYDENI  = .TRUE.
      LVYDENPH = .TRUE.
      LVZDENA  = .TRUE.
      LVZDENM  = .TRUE.
      LVZDENI  = .TRUE.
      LVZDENPH = .TRUE.
 
C  SET DEFAULT VALUE FOR LHABER
      LHABER = .FALSE.
C
      CALL EIRENE_LEER(2)
C
99    CONTINUE
C
C  READ TEXT DESCRIBING THE RUN, 100--199
C
100   CONTINUE
C
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time vo einlesen ',tpb2-tpb1
!pb      tpb1 = tpb2
 
      CALL DATE_AND_TIME(CDATE,CTIME)
      READ(CDATE(1:4),*) I1
      READ(CDATE(5:6),*) I2
      READ(CDATE(7:8),*) I3
      WRITE (iunout,'(1X,A6,1X,2(I2,1X),I4)') 'DATE: ',I3,I2,I1
      READ(CTIME(1:2),*) I1
      READ(CTIME(3:4),*) I2
      READ(CTIME(5:6),*) I3
      WRITE (iunout,'(1X,A6,1X,3(I2,1X))') 'TIME: ',I1,I2,I3
      CALL EIRENE_LEER(2)
C
      READ (IUNIN,'(A72)') TXTRUN
      WRITE (iunout,'(1X,A72)') TXTRUN
      CALL EIRENE_LEER(1)
109   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1).EQ.'*') THEN
        IF (ZEILE(1:3).NE.'***') WRITE (iunout,'(1X,A72)') ZEILE
        CALL EIRENE_LEER(1)
        GOTO 109
      ELSE
        READ (ZEILE,6666) NMACH,NMODE,NTCPU,NFILE,NITER0,NITER,
     .                    NTIME0,NTIME
      ENDIF
      IITER=MAX0(1,NITER0)
      ITIMV=MAX0(1,NTIME0)
 
      READ (IUNIN,'(A72)') ZEILE
      IF ((INDEX(ZEILE,'F') + INDEX(ZEILE,'f') + INDEX(ZEILE,'T') +
     .     INDEX(ZEILE,'t')) == 0) THEN
        READ (ZEILE,6666) NOPTIM,NOPTM1,NGEOM_USR,NCOUP_INPUT,
     .                    NSMSTRA,NSTORAM,NGSTAL,NRTAL1,NREAC_ADD
        READ (IUNIN,6665) NLSCL,NLTEST,NLANA,NLDRFT,NLCRR,
     .                    NLERG,NLIDENT,NLONE,LTSTV
      ELSE
C  THESE DEFAULTS HAVE ALREADY BEEN SET IN FIND-PARAM
!       NOPTIM = 1
!       NOPTM1 = 1
!       NGEOM_USR = 0
!       NCOUP_INPUT = 1
!       NSMSTRA = 1
!       NSTORAM = 9
!       NGSTAL = 0
!       NRTAL1 = 0     ONLY FOR FIND-PARAM, NOT USED ANY FURTHER
!       NREAC_ADD = 0  ONLY FOR FIND-PARAM, NOT USED ANY FURTHER
        READ (ZEILE,6665) NLSCL,NLTEST,NLANA,NLDRFT,NLCRR,
     .                    NLERG,NLIDENT,NLONE,LTSTV
      END IF
 
      READ (IUNIN,'(A420)') ZEILE
      IREAD=1
      I1 = INDEX(ZEILE,'CFILE')
      DO WHILE (I1 /= 0)
        I2 = VERIFY(ZEILE(I1+5:),' ') + I1 + 4
        I3 = SCAN(ZEILE(I2+1:),' ')
        HANDLE=REPEAT(' ',6)
        HANDLE(1:I3) = ZEILE(I2:I2+I3-1)
        DO IFILE = 1,NDBNAMES
          IF (INDEX(DBHANDLE(IFILE),HANDLE) /= 0) EXIT
        END DO
        IF (IFILE <= NDBNAMES) THEN
          IANF = I2+I3+VERIFY(ZEILE(I2+I3:),' ')-1
          IEND = IANF+SCAN(ZEILE(IANF+1:),' ')-1
          DBFNAME(IFILE)(1:IEND-IANF+1) = ZEILE(IANF:IEND)
        ELSE
          WRITE (IUNOUT,*) ' WRONG NAME FOR DATABASE ENTERED '
          WRITE (IUNOUT,*) ' DATABASE DEFINITION FOR ',HANDLE,
     .                     ' IGNORED '
        END IF
        READ (IUNIN,'(A420)') ZEILE
        I1 = INDEX(ZEILE,'CFILE')
      END DO
 
      NFILEN=EIRENE_IDEZ(NFILE,1,5)
      NFILEM=EIRENE_IDEZ(NFILE,2,5)
      NFILEL=EIRENE_IDEZ(NFILE,3,5)
      NFILEK=EIRENE_IDEZ(NFILE,4,5)
      NFILEJ=EIRENE_IDEZ(NFILE,5,5)
      CALL EIRENE_LEER(2)
      CALL EIRENE_MASAGE
     .  ('*** 1. DATA FOR OPERATING MODE                   ')
      CALL EIRENE_LEER(1)
      IF (NMACH.EQ.1) THEN
        CALL EIRENE_MASAGE
     .  ('       EIRENE RUN ON CRAY                      ')
      ELSEIF (NMACH.EQ.2) THEN
        CALL EIRENE_MASAGE
     .  ('       EIRENE RUN ON IBM                       ')
      ELSEIF (NMACH.EQ.3) THEN
        CALL EIRENE_MASAGE
     .  ('       EIRENE RUN ON FACOM                     ')
      ELSEIF (NMACH.EQ.4) THEN
        CALL EIRENE_MASAGE
     .  ('       EIRENE RUN ON VAX                       ')
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NMODE.NE.0) THEN
        CALL EIRENE_MASAGE
     .  ('       EIRENE READS ADDITIONAL DATA FROM FILE  ')
        CALL EIRENE_MASAGE
     .  ('       INTERFACING ROUTINE INFCOP IS CALLED    ')
        CALL EIRENE_MASAGE
     .  ('       AT ENTRIES IF0COP (GEOMETRY)            ')
        CALL EIRENE_MASAGE
     .  ('                  IF1COP (BACKGROUND MEDIUM)   ')
        CALL EIRENE_MASAGE
     .  ('                  IF2COP (BOUNDARY CONDITIONS) ')
        IF (NMODE.GT.0) THEN
          CALL EIRENE_MASAGE
     .  ('       RETURN DATA TO EXTERNAL CODE:         ')
          CALL EIRENE_MASAGE
     .  ('       ENTRIES IF3COP AND IF4COP ARE         ')
          CALL EIRENE_MASAGE
     .  ('       CALLED AT THE END OF EACH STRATUM     ')
          CALL EIRENE_MASAGE
     .  ('       AND AT THE END OF THE RUN, RESP.      ')
        ELSE
          CALL EIRENE_MASAGE
     .  ('       NO RETURN OF DATA TO EXTERNAL CODE:   ')
          CALL EIRENE_MASAGE
     .  ('       ENTRIES IF3COP AND IF4COP             ')
          CALL EIRENE_MASAGE
     .  ('       ARE NOT CALLED                        ')
        ENDIF
        WRITE (iunout,*) '       NMODE= ',NMODE
      ELSE
        CALL EIRENE_MASAGE
     .  ('       EIRENE RUN AS STAND ALONE CODE          ')
        CALL EIRENE_MASAGE
     .  ('       INTERFACING ROUTINE INFCOP IS NOT CALLED')
      ENDIF
      CALL EIRENE_LEER(1)
      WRITE (iunout,*) '       EIRENE ASSUMES A TOTAL CPUTIME '
      WRITE (iunout,*) '       OF ',NTCPU,' SECONDS'
      CALL EIRENE_LEER(1)
      IF (NFILEN.EQ.1) THEN
        WRITE (iunout,*) '       EIRENE SAVES OUTPUT DATA '
        WRITE (iunout,*) '       ON FILES FT10 AND FT11 AFTER'
        WRITE (iunout,*)
     .    '       HAVING COMPUTED THE PARTICLE HISTORIES '
      ELSEIF (NFILEN.EQ.2) THEN
        WRITE (iunout,*) '       EIRENE READS OUTPUT DATA FROM '
        WRITE (iunout,*)
     .    '       AN EARLIER RUN FROM FILES FT10 AND FT11 '
        WRITE (iunout,*) '       NO NEW HISTORIES ARE COMPUTED       '
      ELSEIF (NFILEN.EQ.6) THEN
        WRITE (iunout,*) '       EIRENE SAVES OUTPUT DATA '
        WRITE (iunout,*) '       ON FILES FT10 AND FT11 AFTER'
        WRITE (iunout,*)
     .    '       HAVING COMPUTED THE PARTICLE HISTORIES '
        WRITE (iunout,*) '       FOR THE SUM OVER STRATA TALLIES ONLY '
      ELSEIF (NFILEN.EQ.7) THEN
        WRITE (iunout,*) '       EIRENE READS OUTPUT DATA FROM '
        WRITE (iunout,*)
     .    '       AN EARLIER RUN FROM FILES FT10 AND FT11 '
        WRITE (iunout,*) '       FOR THE SUM OVER STRATA TALLIES ONLY '
        WRITE (iunout,*) '       NO NEW HISTORIES ARE COMPUTED       '
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NFILEM.EQ.1) THEN
        WRITE (iunout,*) '       EIRENE SAVES GEOMETRICAL DATA '
        WRITE (iunout,*) '       ON FILE FT12'
      ELSEIF (NFILEM.EQ.2) THEN
        WRITE (iunout,*) '       EIRENE READS GEOMETRICAL DATA FROM '
        WRITE (iunout,*) '       AN EARLIER RUN FROM FILE FT12 '
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NFILEL.EQ.1) THEN
        WRITE (iunout,*) '       EIRENE SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
      ELSEIF (NFILEL.EQ.2) THEN
        WRITE (iunout,*) '       EIRENE READS PLASMA, A&M DATA      '
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (iunout,*) '       FILE FT13 '
      ELSEIF (NFILEL.EQ.3) THEN
        WRITE (iunout,*) '       EIRENE READS PLASMA, A&M DATA '
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (iunout,*) '       FILE FT13  AND '
        WRITE (iunout,*) '       SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
      ELSEIF (NFILEL.EQ.4) THEN
        WRITE (iunout,*) '       EIRENE READS PLASMA AND A&M DATA      '
        WRITE (iunout,*) '       FROM FILE FT13 AND'
        WRITE (iunout,*) '       SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
        WRITE (iunout,*)
     .  '       SOURCE DISTRIBUTION IS NEWLY DETERMINED'
      ELSEIF (NFILEL.EQ.6) THEN  !  AS OPTION NFILEL=1, BUT XDR FORMAT
        WRITE (iunout,*) '       EIRENE SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
        WRITE (iunout,*) '       IN XDR FORMAT              '
      ELSEIF (NFILEL.EQ.7) THEN  !  AS OPTION NFILEL=2, BUT XDR FORMAT
        WRITE (iunout,*) '       EIRENE READS PLASMA, A&M DATA      '
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (iunout,*) '       FILE FT13 '
        WRITE (iunout,*) '       IN XDR FORMAT              '
      ELSEIF (NFILEL.EQ.8) THEN  !  AS OPTION NFILEL=3, BUT XDR FORMAT
        WRITE (iunout,*) '       EIRENE READS PLASMA, A&M DATA '
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA FROM'
        WRITE (iunout,*) '       FILE FT13  AND '
        WRITE (iunout,*) '       SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
        WRITE (iunout,*) '       IN XDR FORMAT              '
      ELSEIF (NFILEL.EQ.9) THEN  !  AS OPTION NFILEL=4, BUT XDR FORMAT
        WRITE (iunout,*) '       EIRENE READS PLASMA AND A&M DATA      '
        WRITE (iunout,*) '       FROM FILE FT13 AND'
        WRITE (iunout,*) '       SAVES PLASMA DATA, A&M DATA'
        WRITE (iunout,*) '       AND SOURCE DISTRIBUTION DATA'
        WRITE (iunout,*)
     .    '       ON FILE FT13 AT END OF RUN, I.E., AFTER'
        WRITE (iunout,*) '       LAST TIMESTEP OR ITERATION '
        WRITE (iunout,*) '       IN XDR FORMAT              '
        WRITE (iunout,*)
     .  '       SOURCE DISTRIBUTION IS NEWLY DETERMINED'
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NFILEK.EQ.1) THEN
        WRITE (iunout,*)
     .    '       EIRENE SAVES DATA FOR RECOMMENDED INPUT'
        WRITE (iunout,*) '       MODIFICATIONS ON FILE FT14'
      ELSEIF (NFILEK.EQ.2) THEN
        WRITE (iunout,*)
     .    '       EIRENE READS DATA FOR RECOMMENDED INPUT'
        WRITE (iunout,*)
     .    '       MODIFICATIONS FROM FILE FT14, AND CARRIES'
        WRITE (iunout,*) '       THEM OUT IN THIS RUN'
      ELSEIF (NFILEK.EQ.3) THEN
        WRITE (iunout,*)
     .    '       EIRENE READS OLD DATA FOR RECOMMENDED INPUT'
        WRITE (iunout,*)
     .    '       MODIFICATIONS FROM FILE FT14, AND CARRIES'
        WRITE (iunout,*) '       THEM OUT IN THIS RUN'
        WRITE (iunout,*)
     .    '       EIRENE SAVES NEW DATA FOR RECOMMENDED INPUT'
        WRITE (iunout,*)
     .    '       MODIFICATIONS ON FILE FT14 FOR NEXT RUN'
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NFILEJ.EQ.1) THEN
        WRITE (iunout,*) '       EIRENE SAVES SNAPSHOT POPULATION AT '
        WRITE (iunout,*) '       END OF LAST TIMESTEP ON FILE FT15'
      ELSEIF (NFILEJ.EQ.2) THEN
        WRITE (iunout,*) '       EIRENE READS SNAPSHOT POPULATION FOR'
        WRITE (iunout,*) '       STRATUM NSTRAI+1 FOR FIRST TIMESTEP'
        WRITE (iunout,*) '       FROM FILE FT15'
      ELSEIF (NFILEJ.EQ.3) THEN
        WRITE (iunout,*) '       EIRENE READS SNAPSHOT POPULATION FOR'
        WRITE (iunout,*) '       STRATUM NSTRAI+1 FOR FIRST TIMESTEP '
        WRITE (iunout,*) '       FROM  FILE FT15 '
        WRITE (iunout,*) '       EIRENE SAVES NEW SNAPSHOT POPULATION'
        WRITE (iunout,*) '       AT END OF LAST TIMESTEP ON FILE FT15'
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NITER.GE.1) THEN
        WRITE (iunout,*) '       EIRENE RUN IN ITERATIVE MODE.      '
        WRITE (iunout,*) '       ITERATIONS: ',IITER,' TO ',NITER
        WRITE (iunout,*)
     .    '       SUBROUTINE "EIRENE_MODUSR" IS CALLED AFTER EACH'
        WRITE (iunout,*) '       ITERATION '
      ELSE
        WRITE (iunout,*) '       EIRENE RUN IN NONITERATIVE MODE     '
      ENDIF
      CALL EIRENE_LEER(1)
      IF (NTIME.GE.1) THEN
        WRITE (iunout,*) '       EIRENE RUN IN TIME DEP. MODE.       '
        WRITE (iunout,*) '       TIME CYCLES: ',ITIMV,' TO ',NTIME
        WRITE (iunout,*)
     .    '       SUBROUTINE EIRENE_"TMSUSR" IS CALLED AFTER EACH'
        WRITE (iunout,*) '       TIME CYCLE '
      ELSE
        WRITE (iunout,*) '       EIRENE RUN IN STATIONARY MODE         '
      ENDIF
      CALL EIRENE_LEER(1)
C
C
C  READ DATA FOR STANDARD MESH, 200---299
C
200   CONTINUE
C
      IF (IREAD == 0) READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 2. DATA FOR STANDARD MESH                ')
      CALL EIRENE_LEER(1)
      IREAD=0
C
201   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
        WRITE (iunout,'(1X,A72)') ZEILE
        CALL EIRENE_LEER(1)
        GOTO 201
      ENDIF
      READ (ZEILE,6666) (INDGRD(J),J=1,3)
C
C INPUT SUB-BLOCK 2A
C
C  RADIAL MESH
210   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
        GOTO 210
      ENDIF
      READ (ZEILE,6665) NLRAD
      IF (NLRAD) THEN
C
        READ (IUNIN,6665) NLSLB,NLCRC,NLELL,NLTRI,NLPLG,NLFEM,NLTET,
     .                    NLGEN
 
! CHECK GEOMETRY SWITCHES
       ILOGS = 0
       IF (NLSLB) ILOGS = ILOGS + 1
       IF (NLCRC) ILOGS = ILOGS + 1
       IF (NLELL) ILOGS = ILOGS + 1
       IF (NLTRI) ILOGS = ILOGS + 1
       IF (NLPLG) ILOGS = ILOGS + 1
       IF (NLFEM) ILOGS = ILOGS + 1
       IF (NLTET) ILOGS = ILOGS + 1
       IF (NLGEN) ILOGS = ILOGS + 1
       IF ((ILOGS == 0) .OR. (ILOGS > 1)) THEN
         WRITE (IUNOUT,*) ' ERROR IN GEOMETRY SPECIFICATION '
         WRITE (IUNOUT,*) ' ONE AND ONLY ONE OF THE FOLLOWING ',
     .                    ' FLAGS MAY BE .TRUE. '
         WRITE (IUNOUT,*) 'NLSLB = ',NLSLB
         WRITE (IUNOUT,*) 'NLCRC = ',NLCRC
         WRITE (IUNOUT,*) 'NLELL = ',NLELL
         WRITE (IUNOUT,*) 'NLTRI = ',NLTRI
         WRITE (IUNOUT,*) 'NLPLG = ',NLPLG
         WRITE (IUNOUT,*) 'NLFEM = ',NLFEM
         WRITE (IUNOUT,*) 'NLTET = ',NLTET
         WRITE (IUNOUT,*) 'NLGEN = ',NLGEN
         CALL EIRENE_EXIT_OWN(1)
       END IF
 
       READ (IUNIN,6666) NR1ST,NRSEP,NRPLG,NPPLG,NRKNOT,NCOOR
        IF (INDGRD(1).LE.5) THEN
          IF (NLSLB.OR.NLCRC.OR.NLELL.OR.NLTRI) THEN
            READ (IUNIN,6664) RIA,RGA,RAA,RRA
            IF (NLELL.OR.NLTRI) THEN
              READ (IUNIN,6664) EP1IN,EP1OT,EP1CH,EXEP1
              READ (IUNIN,6664) ELLIN,ELLOT,ELLCH,EXELL
              IF (NLTRI) THEN
                READ (IUNIN,6664) TRIIN,TRIOT,TRICH,EXTRI
              ENDIF
            ENDIF
          ENDIF
          IF (NLPLG) THEN
            READ(IUNIN,6664) XPCOR,YPCOR,ZPCOR,PLREFL
            READ (IUNIN,6666) (NPOINT(1,K),NPOINT(2,K),K=1,NPPLG)
            DO 212 I=1,NR1ST
              READ (IUNIN,6664) (XPOL(I,J),YPOL(I,J),    J=1,NRPLG)
212         CONTINUE
            IF (PLREFL.GT.0.D0) NR1ST=NR1ST+1
          ENDIF
          IF (NLFEM .OR. NLTET) THEN
            READ (IUNIN,'(A72)') ZEILE
            CLAB = ZEILE(1:4)
            CALL EIRENE_UPPERCASE(CLAB)
            IF (INDEX(ZEILE,'CASE')==0) THEN
              WRITE (IUNOUT,*) ' ERROR IN GEOMETRY SPECIFICATION '
              WRITE (IUNOUT,*)
     .          ' TRIANGLE OR TETRAHEDRON GRID SWITCHED ON '
              WRITE (IUNOUT,*) ' BUT NO CASENAME SPECIFIED '
              CALL EIRENE_EXIT_OWN(1)
            END IF
 
            READ (ZEILE(6:),'(A66)') CASENAME
            CASENAME=ADJUSTL(CASENAME)
            I2=INDEX(CASENAME,' ')
 
            IF (NLFEM) CALL EIRENE_READ_TRIANG (CASENAME(1:I2))
            IF (NLTET) CALL EIRENE_READ_TETRA (CASENAME(1:I2))
 
            READ (IUNIN,'(A72)') ZEILE
            IREAD = 1
            IF ( (ZEILE(1:1) .NE. '*') .AND.
     .           (INDEX('FTft',ZEILE(1:1)) == 0) )
     .        READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          END IF
          IF (NLGEN) THEN
            NRGEN=NR1ST
          ENDIF
        ELSEIF (INDGRD(1).EQ.6) THEN
C  IS THERE ONE MORE LINE, OR IS NLPOL THE NEXT VARIABLE
          READ (IUNIN,'(A72)') ZEILE
          IPOS1=INDEX(ZEILE,'T')
          IPOS2=INDEX(ZEILE,'F')
          IF (IPOS1.GT.0.OR.IPOS2.GT.0) THEN
            WRITE (iunout,*) 'ONE INPUT LINE MISSING IN BLOCK 2A '
            WRITE (iunout,*) 'AUTOMATIC CORRECTION PERFORMED '
!pb            READ (ZEILE(IPOS1:IPOS1),'(L1)') NLPOL
            READ (ZEILE,'(L1)') NLPOL
            GOTO 222
          ENDIF
          IF (NLSLB.OR.NLCRC.OR.NLELL.OR.NLTRI) THEN
            READ (ZEILE,6664) RIA,RGA,RAA
          ELSEIF (NLPLG) THEN
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          ELSEIF (NLFEM) THEN
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          ELSEIF (NLTET) THEN
            READ (ZEILE,6664) XPCOR,YPCOR,ZPCOR
          ENDIF
        ENDIF
      ENDIF
C
C  POLOIDAL MESH
C
C INPUT SUB-BLOCK 2B
C
220   IF (IREAD == 0) READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 220
      READ (ZEILE,6665) NLPOL
C
222   READ (IUNIN,6665) NLPLY,NLPLA,NLPLP
      READ (IUNIN,6666) NP2ND,NPSEP,NPPLA,NPPER
      IF (INDGRD(2).LE.5) THEN
        READ (IUNIN,6664) YIA,YGA,YAA,YYA
      ELSEIF (INDGRD(2).EQ.6) THEN
      ENDIF
C
C  TOROIDAL MESH
C
C INPUT SUB-BLOCK 2C
C
230   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 230
      IREAD=1
      READ (ZEILE,6665) NLTOR
      IREAD=0
C
      READ (IUNIN,6665) NLTRZ,NLTRA,NLTRT
      READ (IUNIN,6666) NT3RD,NTSEP,NTTRA,NTPER
      IF (INDGRD(3).LE.5) THEN
        READ (IUNIN,6664) ZIA,ZGA,ZAA,ZZA,ROA
      ELSEIF (INDGRD(3).EQ.6) THEN
      ENDIF
C
C  MESH MULTIPLICATION
C
C INPUT SUB-BLOCK 2D
C
240   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 240
      IREAD=1
      READ (ZEILE,6665) NLMLT
      IREAD=0
C
      IF (NLMLT) THEN
        READ (IUNIN,6666) NBMLT
        READ (IUNIN,6664) (VOLCOR(NM),NM=1,NBMLT)
        READ (IUNIN,'(A72)') ZEILE
      ELSE
        NBMLT=1
        VOLCOR(1)=1.D0
C  FIND START OF NEXT INPUT BLOCK: 2E. SEARCH FOR *, T OR F
241     READ (IUNIN,'(A72)') ZEILE
        IPOS0=INDEX(ZEILE,'*')
        IPOS1=INDEX(ZEILE,'T')
        IPOS2=INDEX(ZEILE,'F')
        IF (IPOS0.EQ.0.AND.IPOS1.EQ.0.AND.IPOS2.EQ.0) GOTO 241
      ENDIF
      IREAD=1
C
C  ADDITIONAL CELLS OUTSIDE STANDARD MESH
C
250   IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
C
C INPUT SUB-BLOCK 2E
C
      IF (ZEILE(1:1) .EQ. '*') THEN
        IREAD=0
        GOTO 250
      ENDIF
      READ (ZEILE,6665) NLADD
      IREAD=0
C
      IF (NLADD) THEN
        READ (IUNIN,6666) NRADD
        READ (IUNIN,6664) (VOLADD(NM),NM=1,NRADD)
      ELSE
C  FIND START OF NEXT INPUT BLOCK: 3A
252     READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:3) .NE. '***') GOTO 252
        IREAD=1
      ENDIF
C
C
C  READING FOR INPUT BLOCK 2 DONE
C
      NBMLT=MAX0(1,NBMLT)
      NR1ST=MAX0(1,NR1ST)
      NP2ND=MAX0(1,NP2ND)
      IF (.NOT.NLPOL) NP2ND=1
      NT3RD=MAX0(1,NT3RD)
      IF (.NOT.NLTOR) NT3RD=1
C
      IF (NLPLG.AND.INDGRD(1).LE.4) THEN
        IF (NLPOL.AND.NRPLG.NE.NP2ND) GOTO 994
      ENDIF
!pb      IF (NLFEM.AND.INDGRD(1).LT.6) THEN
!pb        GOTO 992
!pb      ENDIF
C
C  READ DATA FOR NON DEFAULT SURFACE MODELS ON STANDARD SURFACES
C  300--349
C
300   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL
     .  EIRENE_MASAGE('*** 3A. DATA FOR NON DEFAULT STANDARD SURFACES')
310   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 310
      IREAD=1
      READ(ZEILE,6666) NSTSI
      IREAD=0
      WRITE (iunout,*) '        NSTSI= ',NSTSI
      CALL EIRENE_LEER(1)
      DO 311 ISTS=1,NSTSI
        NLJ=NLIM+ISTS
        IF (IREAD.EQ.0) THEN
          READ (IUNIN,'(A72)') TXTSFL(NLJ)
        ELSE
          READ (ZEILE,'(A72)') TXTSFL(NLJ)
          IREAD=0
        ENDIF
        READ (IUNIN,6666) JDUMMY,IDIMP,INUMP(ISTS,IDIMP),IRPTA1,
     .                    IRPTE1,IRPTA2,IRPTE2,IRPTA3,IRPTE3
 
        IF (.NOT.(NLFEM.OR.NLTET.OR.NLGEN)) THEN
        IF ((IDIMP == 1) .AND. (INUMP(ISTS,IDIMP) > N1ST)) THEN
          WRITE (iunout,*) ' ERROR IN SPECIFICATION OF NON DEFAULT '
          WRITE (iunout,*) ' SURFACE ',ISTS
          WRITE (iunout,*) ' NUMBER OF RADIAL SURFACE > N1ST '
          WRITE (iunout,*) ' CHECK INPUT FILE '
          CALL EIRENE_EXIT_OWN(1)
        ELSEIF ((IDIMP == 2) .AND. (INUMP(ISTS,IDIMP) > N2ND)) THEN
          WRITE (iunout,*) ' ERROR IN SPECIFICATION OF NON DEFAULT '
          WRITE (iunout,*) ' SURFACE ',ISTS
          WRITE (iunout,*) ' NUMBER OF POLOIDAL SURFACE > N2ND '
          WRITE (iunout,*) ' CHECK INPUT FILE '
          CALL EIRENE_EXIT_OWN(1)
!pb        ELSEIF ((IDIMP == 3) .AND. (INUMP(ISTS,IDIMP) > N3RD)) THEN
        ELSEIF ((IDIMP == 3) .AND.
     .          ((NLTOR.AND.(INUMP(ISTS,IDIMP) > N3RD)) .OR.
     .           (NLTRA.AND.(INUMP(ISTS,IDIMP) > NTTRA)))) THEN
          WRITE (iunout,*) ' ERROR IN SPECIFICATION OF NON DEFAULT '
          WRITE (iunout,*) ' SURFACE ',ISTS
          WRITE (iunout,*) ' NUMBER OF TOROIDAL SURFACE > N3RD '
          WRITE (iunout,*) ' CHECK INPUT FILE '
          CALL EIRENE_EXIT_OWN(1)
        END IF
        END IF
C
C  OLD INPUT VERSION BEGIN
        IF (IDIMP.EQ.1.AND.IRPTA1.NE.IRPTE1) THEN
          WRITE (iunout,*) 'WARNING FROM INPUT BLOCK 3A, ISTS= ',ISTS
          WRITE (iunout,*) 'NEW INPUT FOR IRPTA,IRPTE....'
          WRITE (iunout,*) 'AUTOMATIC CORRECTION CARRIED OUT '
          IRPTA2=IRPTA1
          IRPTE2=IRPTE1
          IRPTA1=INUMP(ISTS,1)
          IRPTE1=INUMP(ISTS,1)
        ELSEIF (IDIMP.EQ.1.AND.IRPTA1.EQ.0.AND.IRPTE1.EQ.0) THEN
          IRPTA1=INUMP(ISTS,1)
          IRPTE1=INUMP(ISTS,1)
        ELSEIF (IDIMP.EQ.2.AND.IRPTA2.EQ.0.AND.IRPTE2.EQ.0) THEN
          IRPTA2=INUMP(ISTS,2)
          IRPTE2=INUMP(ISTS,2)
        ELSEIF (IDIMP.EQ.3.AND.IRPTA3.EQ.0.AND.IRPTE3.EQ.0) THEN
          IRPTA3=INUMP(ISTS,3)
          IRPTE3=INUMP(ISTS,3)
        ENDIF
C  OLD INPUT VERSION DONE
C
C  OVERWRITE DEFAULTS FOR IRPTA, IRPTE ARRAYS
        IF (IDIMP.NE.1) THEN
          IF (IRPTA1.GT.1) IRPTA(ISTS,1)=IRPTA1
          IF (IRPTE1.LE.1.OR.IRPTE1.GT.NR1ST) THEN
            IRPTE(ISTS,1)=MAX(2,NR1ST)
          ELSE
            IRPTE(ISTS,1)=IRPTE1
          ENDIF
          IF ((IDIMP.EQ.2.AND.IRPTE2.GT.NP2ND).OR.
     .        (IDIMP.EQ.3.AND.IRPTE3.GT.NT3RD)) THEN
            WRITE (iunout,*) 'WARNING:'
            WRITE (iunout,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (iunout,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        IF (IDIMP.NE.2) THEN
          IF (IRPTA2.GT.1) IRPTA(ISTS,2)=IRPTA2
!pb          IF (IRPTE2.LE.1.OR.IRPTE2.GT.NP2ND) THEN
          IF (IRPTE2.LE.1.OR.IRPTE2.GT.MAX(NP2ND,NRPLG)) THEN
!pb            IRPTE(ISTS,2)=MAX(2,NP2ND)
            IRPTE(ISTS,2)=MAX(2,NP2ND,NRPLG)
          ELSE
            IRPTE(ISTS,2)=IRPTE2
          ENDIF
          IF ((IDIMP.EQ.1.AND.IRPTE1.GT.NR1ST).OR.
     .        (IDIMP.EQ.3.AND.IRPTE3.GT.NT3RD)) THEN
            WRITE (iunout,*) 'WARNING:'
            WRITE (iunout,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (iunout,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        IF (IDIMP.NE.3) THEN
          IF (IRPTA3.GT.1) IRPTA(ISTS,3)=IRPTA3
          IF (IRPTE3.LE.1.OR.IRPTE3.GT.NT3RD) THEN
            IRPTE(ISTS,3)=MAX(2,NT3RD)
          ELSE
            IRPTE(ISTS,3)=IRPTE3
          ENDIF
!pb          IF ((IDIMP.EQ.1.AND.IRPTE1.GT.NR1ST).OR.
!pb     .        (IDIMP.EQ.2.AND.IRPTE2.GT.NP2ND)) THEN
          IF ((IDIMP.EQ.1.AND.IRPTE1.GT.NR1ST).OR.
     .        (IDIMP.EQ.2.AND.IRPTE2.GT.MAX(NP2ND,NRPLG))) THEN
            WRITE (iunout,*) 'WARNING:'
            WRITE (iunout,*) 'NON-DEFAULT STANDART SURFACE NO. ',ISTS
            WRITE (iunout,*) 'OUT OF RANGE. INVISIBLE!'
          ENDIF
        ENDIF
        READ (IUNIN,6666) ILIIN(NLJ),ILSIDE(NLJ),ILSWCH(NLJ),
     .                    ILEQUI(NLJ),ILTOR(NLJ),ILCOL(NLJ),
     .                    ILFIT(NLJ),ILCELL(NLJ),ILBOX(NLJ),
     .                    ILPLG(NLJ)
        IF (ABS(ILCOL(NLJ)).EQ.7) THEN
          WRITE (iunout,*) 'COLOUR FLAG ILCOL CHANGED FOR SURFACE NO. ',
     .                      NLJ
          WRITE (iunout,*) 'COLOUR NO. 7 IS RESERVED FOR "NON-ANALOG'
          WRITE (iunout,*)
     .      'SURFACES" (SPLITTING, R.R., WEIGHT WINDOWS,..)'
          ILCOL(NLJ)=ILCOL(NLJ)-2
        ENDIF
312     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1).EQ.'*') THEN
C  SKIP READING LOCAL SURFACE INTERACTION MODEL, USE: DEFAULT
          GOTO 314
        ELSEIF (ILIIN(NLJ).LE.0) THEN
          GOTO 312
        ELSEIF (ZEILE(1:8).EQ.'SURFMOD_') THEN
          ALLOCATE(SURFCUR)
          SURFCUR%MODNAME = TRIM(ADJUSTL(ZEILE(9:)))
          SURFCUR%NOSURF = NLJ
          SURFCUR%NEXT => SURFLIST
          SURFLIST => SURFCUR
          IREAD=0
          GOTO 314
        ELSE
          READ (ZEILE,6666) ILREF(NLJ),ILSPT(NLJ),ISRS(1,NLJ),
     .                      ISRC(1,NLJ)
          IREAD=0
          READ (IUNIN,6664) ZNML(NLJ),EWALL(NLJ),EWBIN(NLJ),
     .                      TRANSP(1,1,NLJ),TRANSP(1,2,NLJ),FSHEAT(NLJ)
          READ (IUNIN,6664) RECYCF(1,NLJ),RECYCT(1,NLJ),RECPRM(1,NLJ),
     .                      EXPPL(1,NLJ),EXPEL(1,NLJ),EXPIL(1,NLJ)
          READ (IUNIN,'(A72)') ZEILE
          IREAD=1
C  READ ONE MORE LINE FOR NON-DEFAULT SPUTTER MODEL
          IF (ZEILE(1:1).NE.'*') THEN
            READ (ZEILE,6664) RECYCS(1,NLJ),RECYCC(1,NLJ),SPTPRM(1,NLJ)
            IREAD=0
          ELSEIF (ILSPT(NLJ).NE.0) THEN
            WRITE (iunout,*) 'WARNING: SPUTTERING AT NON DEF. SURFACE ',
     .                        ISTS
            WRITE (iunout,*)
     .        'BUT NO PARAMETERS RECYCS, RECYCC ARE READ '
            WRITE (iunout,*)
     .  'DEFAULT MODEL: "NO SPUTTERING" IS USED. EIRMOD_'
            WRITE (iunout,*) 'DO YOU REALLY WANT THIS?'
            ILSPT(NLJ)=0
          ENDIF
        ENDIF
C
314     CONTINUE
C
311   CONTINUE
C
C     READ DATA FOR ADDITIONAL SURFACES 350--399
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 3B. DATA FOR ADDITIONAL SURFACES           ')
350   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1).EQ.'*') THEN
        WRITE (iunout,'(1X,A72)') ZEILE
        GOTO 350
      ENDIF
      IREAD=0
      READ (ZEILE,6666) NLIMI
      WRITE (iunout,*) '        NLIMI= ',NLIMI
      CALL EIRENE_LEER(1)
C
      IF (NLIMI.GT.0) THEN
        DO 353 I=1,NLIMI
          IHELP(I)=IGJUM0(I)
353     CONTINUE
351     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:3).EQ.'CH0') THEN
          IREAD=0
          CALL EIRENE_DEKEY (ZEILE(4:72),IHELP,1,1,1,NLIMPS)
          GOTO 351
        ENDIF
        DO 352 I=1,NLIMI
          IGJUM0(I)=IHELP(I)
352     CONTINUE
      ENDIF
C
      DO 360 I=1,NLIMI
        IF (IREAD.NE.0) THEN
          READ (ZEILE,'(A72)') TXTSFL(I)
        ELSE
          READ (IUNIN,'(A72)') TXTSFL(I)
        ENDIF
        WRITE (iunout,*) TXTSFL(I)
        IREAD=0
        IF (IGJUM0(I).NE.0) THEN
361       READ (IUNIN,'(A72)') ZEILE
          IREAD=1
          IF (ZEILE(1:1).EQ.'*') GOTO 369
          IF (ZEILE(1:9).EQ.'TRANSFORM') GOTO 368
          GOTO 361
        ENDIF
C
C   GENERAL SURFACE DATA
362     READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:3).EQ.'CH1') THEN
          IF (NLIMPB >= NLIMPS) THEN
            CALL EIRENE_DEKEY (ZEILE(4:72),IGJUM1,0,NLIMPS,I,NLIMPS)
          ELSE
            CALL EIRENE_DEKEYB
     .  (ZEILE(4:72),IGJUM1,0,NLIMPS,I,NLIMPB,NBITS)
          END IF
          GOTO 362
        ELSEIF (ZEILE(1:3).EQ.'CH2') THEN
          IF (NLIMPB >= NLIMPS) THEN
            CALL EIRENE_DEKEY (ZEILE(4:72),IGJUM2,0,NLIMPS,I,NLIMPS)
          ELSE
            CALL EIRENE_DEKEYB
     .  (ZEILE(4:72),IGJUM2,0,NLIMPS,I,NLIMPB,NBITS)
          END IF
          GOTO 362
        ELSE
          READ (ZEILE,6664) RLB(I),SAREA_SAVE(I),RLWMN(I),RLWMX(I)
          IF (SAREA_SAVE(I).LE.0.D0) SAREA_SAVE(I)=666.
          READ (IUNIN,6666) ILIIN(I),ILSIDE(I),ILSWCH(I),
     .                      ILEQUI(I),ILTOR(I),ILCOL(I),
     .                      ILFIT(I),ILCELL(I),ILBOX(I),
     .                      ILPLG(I)
          IF (ABS(ILCOL(I)).EQ.7) THEN
            WRITE (iunout,*)
     .        'COLOUR FLAG ILCOL CHANGED FOR SURFACE NO. ',I
            WRITE (iunout,*) 'COLOUR NO. 7 IS RESERVED FOR "NON-ANALOG'
            WRITE (iunout,*)
     .        'SURFACES" (SPLITTING, R.R., WEIGHT WINDOWS,..)'
            ILCOL(I)=ILCOL(I)-2
          ENDIF
C  READ SURFACE COEFFICIENTS
          IF (RLB(I).LT.2.) THEN
            READ (IUNIN,6664) A0LM(I),A1LM(I),A2LM(I),A3LM(I),A4LM(I),
     .                        A5LM(I)
            READ (IUNIN,6664) A6LM(I),A7LM(I),A8LM(I),A9LM(I)
          ELSEIF (RLB(I).LT.3.) THEN
            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
     .                        P2(3,I)
          ELSEIF (RLB(I).LT.5.) THEN
            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
     .                        P2(3,I)
            READ (IUNIN,6664) P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),
     .                        P4(3,I)
          ELSEIF (RLB(I).LT.7.) THEN
            READ (IUNIN,6664) P1(1,I),P1(2,I),P1(3,I),P2(1,I),P2(2,I),
     .                        P2(3,I)
            READ (IUNIN,6664) P3(1,I),P3(2,I),P3(3,I),P4(1,I),P4(2,I),
     .                        P4(3,I)
            READ (IUNIN,6664) P5(1,I),P5(2,I),P5(3,I),P6(1,I),P6(2,I),
     .                        P6(3,I)
          ENDIF
        ENDIF
C  READ BOUNDARY DATA
        IF (RLB(I).GT.0..AND.RLB(I).LT.2.) THEN
          READ (IUNIN,6664) XLIMS1(1,I),YLIMS1(1,I),ZLIMS1(1,I),
     .                      XLIMS2(1,I),YLIMS2(1,I),ZLIMS2(1,I)
        ELSEIF (RLB(I).LE.0.D0) THEN
          IH=-RLB(I)
          ILIN(I)=EIRENE_IDEZ(IH,1,2)
          ISCN(I)=EIRENE_IDEZ(IH,2,2)
          DO 363 J=1,ILIN(I)
            READ (IUNIN,6664) ALIMS(J,I),XLIMS(J,I),YLIMS(J,I),
     .                        ZLIMS(J,I)
363       CONTINUE
          DO 364 J=1,ISCN(I)
            READ (IUNIN,6664) ALIMS0(J,I),XLIMS1(J,I),YLIMS1(J,I),
     .                        ZLIMS1(J,I),XLIMS2(J,I),YLIMS2(J,I)
            READ (IUNIN,6664) ZLIMS2(J,I),XLIMS3(J,I),YLIMS3(J,I),
     .                        ZLIMS3(J,I)
364       CONTINUE
        ENDIF
C
C READ LOCAL SURFACE INTERACTION MODEL FOR SURFACE NO. I
C
367     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1).EQ.'*') THEN
C  SKIP READING LOCAL SURFACE INTERACTION MODEL, USE: DEFAULT
          GOTO 369
        ELSEIF (ZEILE(1:9).EQ.'TRANSFORM') THEN
C  TRANSFORM BLOCK
          GOTO 368
        ELSEIF (ILIIN(I).LE.0) THEN
C  TRANSPARENT: SKIP READING SURFACE INTERACTION MODEL
          GOTO 367
        ELSEIF (ZEILE(1:8).EQ.'SURFMOD_') THEN
          ALLOCATE(SURFCUR)
          SURFCUR%MODNAME = TRIM(ADJUSTL(ZEILE(9:)))
          SURFCUR%NOSURF = I
          SURFCUR%NEXT => SURFLIST
          SURFLIST => SURFCUR
          IREAD=0
          GOTO 368
        ELSE
C  READ LOCAL REFLECTION MODEL
          READ (ZEILE,6666) ILREF(I),ILSPT(I),ISRS(1,I),ISRC(1,I)
          IREAD=0
          READ (IUNIN,6664) ZNML(I),EWALL(I),EWBIN(I),
     .                      TRANSP(1,1,I),TRANSP(1,2,I),FSHEAT(I)
          READ (IUNIN,6664) RECYCF(1,I),RECYCT(1,I),RECPRM(1,I),
     .                      EXPPL(1,I),EXPEL(1,I),EXPIL(1,I)
          READ (IUNIN,'(A72)') ZEILE
          IREAD=1
C  READ ONE MORE LINE FOR NON-DEFAULT SPUTTER MODEL
          IF (ZEILE(1:1).NE.'*'.AND.ZEILE(1:9).NE.'TRANSFORM') THEN
            READ (ZEILE,6664) RECYCS(1,I),RECYCC(1,I),SPTPRM(1,I)
            IREAD=0
          ELSEIF (ILSPT(I).NE.0) THEN
            WRITE (iunout,*) 'WARNING: SPUTTERING FOR ADD. SURFACE ',I
            WRITE (iunout,*)
     .        'BUT NO PARAMETERS RECYCS, RECYCC ARE READ '
            WRITE (iunout,*)
     .  'DEFAULT MODEL: "NO SPUTTERING" IS USED. EIRMOD_'
            WRITE (iunout,*) 'DO YOU REALLY WANT THIS?'
            ILSPT(I)=0
          ENDIF
        ENDIF
C
368     IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:9).NE.'TRANSFORM') GOTO 369
C
C  TRANSFORM FROM CONVENIENT CO-ORDINATE SYSTEM TO EIRENE CO-ORDINATE
C  SYSTEM. THIS IS POSSIBLE FOR ALL SURFACES READ BY NOW, I.E. FROM
C  ITINI=1 TO ITEND=I
        IREAD=0
        READ (IUNIN,6666) ITINI,ITEND
        IF (ITINI.LT.1) ITINI=I
        IF (ITEND.GT.I) ITEND=I
        READ (IUNIN,6664) XLCOR,YLCOR,ZLCOR
        READ (IUNIN,6664) XLREF,YLREF,ZLREF
        READ (IUNIN,6664) XLROT,YLROT,ZLROT,ALROT
C  SHIFT
        XSH=XLCOR
        IF (XSH.NE.0.D0) CALL EIRENE_XSHADD(XSH,ITINI,ITEND)
        YSH=YLCOR
        IF (YSH.NE.0.D0) CALL EIRENE_YSHADD(YSH,ITINI,ITEND)
        ZSH=ZLCOR
        IF (ZSH.NE.0.D0) CALL EIRENE_ZSHADD(ZSH,ITINI,ITEND)
C  REFLECTION
        REFNRM=XLREF*XLREF+YLREF*YLREF+ZLREF*ZLREF
        IF (REFNRM.GT.EPS10) THEN
          CALL EIRENE_SETREF(AFF,AFFI,1,XLREF,YLREF,ZLREF)
          CALL EIRENE_ROTADD(AFF,AFFI,ITINI,ITEND)
        ENDIF
C  ROTATION
        ROTNRM=XLROT*XLROT+YLROT*YLROT+ZLROT*ZLROT
        ALR=ALROT
        IF (ALR.NE.0..AND.ROTNRM.GT.EPS10) THEN
          CALL EIRENE_SETROT(AFF,AFFI,1,XLROT,YLROT,ZLROT,ALROT)
          CALL EIRENE_ROTADD(AFF,AFFI,ITINI,ITEND)
        ENDIF
        GOTO 368
C
369     CONTINUE
C
360   CONTINUE
C
C  READ DATA FOR SPECIES SPECIFICATION AND ATOMIC PHYSICS MODULE
C  400--499
C
400   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL EIRENE_MASAGE
     .  ('*** 4. DATA FOR SPECIES SPECIFICATION AND   ')
      CALL EIRENE_MASAGE
     .  ('       ATOMIC PHYSICS MODULE                ')
      CALL EIRENE_LEER(1)
 
! CHECK FOR INCLUDE LINE
      READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      ULINE = ZEILE
      CALL EIRENE_UPPERCASE(ULINE)
      I1 = INDEX(ULINE,'INCLUDE')
      LINCLUDE = .FALSE.
      IF (I1 > 0) THEN
        IREAD = 0
        CALL EIRENE_READ_TOKEN(ZEILE(I1+7:),' ',FILE,ITOK,IER,.FALSE.)
        LINCLUDE = .TRUE.
        IUNIN_SAVE = IUNIN
        IUNIN = 2
        OPEN (IUNIN,FILE=FILE,FORM='FORMATTED',ACCESS='SEQUENTIAL')
      END IF
C
      IF (IREAD == 0) READ (IUNIN,*)
      WRITE (iunout,*)
     .  '       ATOMIC REACTION CARDS, NREACI DATA FIELDS'
 
      READ (IUNIN,'(A72)') ZEILE
      CALL EIRENE_UPPERCASE(ZEILE)
      IEND=INDEX(ZEILE,'DEFAULT')
      LHYDDEF =.FALSE.
      IF (IEND > 0) THEN
        LHYDDEF =.TRUE.
        CALL
     .  EIRENE_READ_TOKEN(ZEILE(IEND+7:),' ',HYDKIN_DEFAULT,ITOK,IER,
     .                  .FALSE.)
 
        IEND = IEND + 7 + ITOK
        CALL EIRENE_READ_TOKEN(ZEILE(IEND+1:),' ',CADAPT,ITOK,IER,
     .                  .FALSE.)
 
        READ (IUNIN,'(A72)') ZEILE
 
      END IF
 
      READ (ZEILE,*) NREACI
      WRITE (iunout,*) '       NREACI= ',NREACI
      CALL EIRENE_LEER(1)
      IF (NPHOTI > 0) CALL EIRENE_PH_INIT(0)
      IL = 0
C
411   READ (IUNIN,'(A80)') ZEILE
      IF (ZEILE(1:1).NE.'*') THEN
C
C  READ ONE REACTION FROM FILE "FILNAM"
C
        IL = IL + 1
        READ (ZEILE,66661) IR,FILNAM,H123
        IEND = 16
!  READ REAC
        IF (INDEX(FILNAM,'CONST') == 0) THEN
          CALL
     .  EIRENE_READ_TOKEN(ZEILE(IEND:),' ',REAC2,ITOK,IER,.FALSE.)
          IEND = IEND + ITOK
          IF (IER > 0) THEN
            WRITE (iunout,*)
     .        ' REACTIONSTRING FOR REACTION ',IR,' TOO LONG '
            CALL EIRENE_EXIT_OWN(1)
          END IF
        ELSE
          REAC2=REPEAT(' ',LEN(REAC2))
!  CHECK LINE FOR FT-FLAG (IFTFLG)
          ITOK = INDEX(ZEILE(IEND:),'FT')
          IF (ITOK /= 0) THEN
            REAC2(1:9) = ZEILE(IEND+ITOK:IEND+ITOK+8)
            IEND = IEND+ITOK+2
            CALL
     .  EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.FALSE.)
            IEND = IEND + ITOK
          END IF
        END IF
!  READ CRC
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CRC,ITOK,IER,.FALSE.)
        IEND = IEND + ITOK
        IF (IER > 0) THEN
          WRITE (iunout,*) ' CRC-STRING FOR REACTION ',IR,' TOO LONG '
          CALL EIRENE_EXIT_OWN(1)
        END IF
!  READ MP
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.FALSE.)
        IEND = IEND + ITOK
        READ (CHR,*) MP
        IF (IER > 0) THEN
          WRITE (iunout,*) ' ERROR READING MP FOR REACTION ',IR
          CALL EIRENE_EXIT_OWN(1)
        END IF
!  READ MT
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.FALSE.)
        IEND = IEND + ITOK
        READ (CHR,*) MT
        IF (IER > 0) THEN
          WRITE (iunout,*) ' ERROR READING MT FOR REACTION ',IR
          CALL EIRENE_EXIT_OWN(1)
        END IF
!  READ DPP
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.TRUE.)
        IEND = IEND + ITOK
        READ (CHR,'(E12.4)') DPP
        IF (IER > 0) THEN
          WRITE (iunout,*) ' ERROR READING DPP FOR REACTION ',IR
          CALL EIRENE_EXIT_OWN(1)
        END IF
!  READ RMN
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.TRUE.)
        IEND = IEND + ITOK
        READ (CHR,'(E12.4)') RMN
        IF (IER > 0) THEN
          WRITE (iunout,*) ' ERROR READING RMN FOR REACTION ',IR
          CALL EIRENE_EXIT_OWN(1)
        END IF
!  READ RMX
        CALL EIRENE_READ_TOKEN(ZEILE(IEND:),' ',CHR,ITOK,IER,.TRUE.)
        IEND = IEND + ITOK
        READ (CHR,'(E12.4)') RMX
        IF (IER > 0) THEN
          WRITE (iunout,*) ' ERROR READING RMX FOR REACTION ',IR
          CALL EIRENE_EXIT_OWN(1)
        END IF
 
        IF (INDEX(ZEILE,'ADAS') .NE. 0) THEN
          READ (IUNIN,'(4X,A2,1X,I3)') ELNAME,IZ
          CALL EIRENE_LOWERCASE(ELNAME)
        ELSE
          ELNAME = ' '
          IZ = 0
        END IF
 
        REACLINES(IL)%NO = IR
        REACLINES(IL)%FILE = FILNAM
        REACLINES(IL)%H_SELECT = H123
        REACLINES(IL)%REAC_STRING = REAC2
        REACLINES(IL)%REACTYP = CRC
        REACLINES(IL)%MP = MP
        REACLINES(IL)%MT = MT
        REACLINES(IL)%DPP = DPP
        REACLINES(IL)%RMN = RMN
        REACLINES(IL)%RMX = RMX
        REACLINES(IL)%ELEMENT = ELNAME
        REACLINES(IL)%IZ = IZ
        REACLINES(IL)%JFEXMN = 0
        REACLINES(IL)%JFEXMX = 0
        REACLINES(IL)%FP = 0._DP
 
        IRLINES = IL
 
        IF (IR.GT.NREACI) THEN
            CALL EIRENE_MASPRM('NREACI',6,NREACI,'IR',2,IR,IERROR)
        ENDIF
        MASSP(IR)=MP
        MASST(IR)=MT
        DELPOT(IR)=DPP
C  IFEXMN,IFEXMX,FPARM:
C  ASYMPTOTICS FOR CROSS SECTIONS (SECOND INDEX=1) OR RATES (SECOND
C  INDEX=2) , OVERWRITES ASYMPTOTICS IN DATA FILES, IF THERE ARE SUCH
csw added branch
        FP = 0._DP
        IF (INDEX(H123,'P.').eq.0) then
          IF (INDEX(H123,'H.1 ').NE.0) J=1
          IF (INDEX(H123,'H.1 ').EQ.0) J=2
          RCMIN = -20.
          RCMAX =  20.
          JFEXMN = 0
          JFEXMX = 0
          IF (RMN.GT.0.D0) THEN
            READ (IUNIN,66664) JFEXMN,(FP(I),I=1,3)
            RCMIN=LOG(RMN)
          ENDIF
          IF (RMX.GT.0.D0) THEN
            READ (IUNIN,66664) JFEXMX,(FP(I),I=4,6)
            RCMAX=LOG(RMX)
          ENDIF
          REACLINES(IL)%JFEXMN = JFEXMN
          REACLINES(IL)%JFEXMX = JFEXMX
          REACLINES(IL)%FP = FP
        else
          RCMIN=-20.
          RCMAX= 20.
          JFEXMN=0
          JFEXMX=0
        endif
csw end branch
C
        CALL EIRENE_SLREAC (IR,FILNAM,H123,REAC2,CRC,
     .               RCMIN,RCMAX,FP,JFEXMN,JFEXMX,ELNAME,IZ)
        GOTO 411
      ENDIF
C
420   WRITE (iunout,*)
     .  '*4A.   NEUTRAL ATOMS SPECIES CARDS, NATMI SPECIES'
      READ (IUNIN,*) NATMI
      WRITE (iunout,*) '       NATMI= ',NATMI
      CALL EIRENE_LEER(1)
      NATMI_IN = NATMI
C
      NSPH=NPHOTI
      DO 421 IATM=1,NATMI
        ISPZ=NSPH+IATM
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSA(IATM),NCHARA(IATM),
     .                       NDUMM1,NDUMM2,
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),NUMSEC,
     .                       NRCA(IATM),NFOLA(IATM),NGENA(IATM),
     .                       NHSTS(ISPZ)
C  DEFAULTS FOR ATOMIC SPECIES:
        NPRT(ISPZ)=1
        DO 422 K=1,NRCA(IATM)
          IF (NUMSEC .LT. 3) THEN
            READ (IUNIN,6666) IREACA(IATM,K),IBULKA(IATM,K),
     .                        ISCD1A(IATM,K),ISCD2A(IATM,K),
     .                        ISCDEA(IATM,K),IESTMA(IATM,K),
     .                        IBGKA(IATM,K)
          ELSE IF (NUMSEC .EQ. 3) THEN
            READ (IUNIN,6666) IREACA(IATM,K),IBULKA(IATM,K),
     .                        ISCD1A(IATM,K),ISCD2A(IATM,K),
     .                        ISCD3A(IATM,K),
     .                        ISCDEA(IATM,K),IESTMA(IATM,K),
     .                        IBGKA(IATM,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' THREE SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1A = ',ISCD1A(IATM,K)
            WRITE (iunout,*) ' ISCD2A = ',ISCD2A(IATM,K)
            WRITE (iunout,*) ' ISCD3A = ',ISCD3A(IATM,K)
            WRITE (iunout,*) ' ISCDEA = ',ISCDEA(IATM,K)
            WRITE (iunout,*) ' IESTMA = ',IESTMA(IATM,K)
            WRITE (iunout,*) ' IBGKA  = ',IBGKA(IATM,K)
          ELSE IF (NUMSEC .EQ. 4) THEN
            READ (IUNIN,6666) IREACA(IATM,K),IBULKA(IATM,K),
     .                        ISCD1A(IATM,K),ISCD2A(IATM,K),
     .                        ISCD3A(IATM,K),ISCD4A(IATM,K),
     .                        ISCDEA(IATM,K),IESTMA(IATM,K),
     .                        IBGKA(IATM,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' FOUR SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1A = ',ISCD1A(IATM,K)
            WRITE (iunout,*) ' ISCD2A = ',ISCD2A(IATM,K)
            WRITE (iunout,*) ' ISCD3A = ',ISCD3A(IATM,K)
            WRITE (iunout,*) ' ISCD4A = ',ISCD4A(IATM,K)
            WRITE (iunout,*) ' ISCDEA = ',ISCDEA(IATM,K)
            WRITE (iunout,*) ' IESTMA = ',IESTMA(IATM,K)
            WRITE (iunout,*) ' IBGKA  = ',IBGKA(IATM,K)
          END IF
          READ (IUNIN,6664) EELECA(IATM,K),EBULKA(IATM,K),
     .                      ESCD1A(IATM,K),ESCD2A,
     .                      FREACA(IATM,K),FLDLMA(IATM,K)
          ESCD1A(IATM,K) = ESCD1A(IATM,K)+ESCD2A
          NSC = 0
          IF (ISCD3A(IATM,K) > 0) NSC = 3
          IF (ISCD4A(IATM,K) > 0) NSC = 4
          IF (NSC > 0) THEN
            IF ((REACDAT(IREACA(IATM,K))%NOSEC > 0) .AND.
     .          (REACDAT(IREACA(IATM,K))%NOSEC /= NSC)) THEN
              WRITE (IUNOUT,*) ' INCONSISTENCY FOUND CONCERNING',
     .              ' REACTION ',IREACA(IATM,K)
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' PREVIOUSLY WAS ',REACDAT(IREACA(IATM,K))%NOSEC
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' NOW IS         ',NSC
              WRITE (IUNOUT,*) ' USE EIRMOD_',
     .              MAX(REACDAT(IREACA(IATM,K))%NOSEC,NSC),
     .              ' SECONDARIES '
              REACDAT(IREACA(IATM,K))%NOSEC =
     .              MAX(REACDAT(IREACA(IATM,K))%NOSEC,NSC)
            ELSE
              REACDAT(IREACA(IATM,K))%NOSEC = NSC
            END IF
          END IF
422     CONTINUE
421   CONTINUE
C
C  READ NEUTRAL MOLECULES SPECIES CARDS
C
      READ (IUNIN,*)
      WRITE (iunout,*)
     .  '*4B.   NEUTRAL MOLECULE SPECIES CARDS, NMOLI SPECIES'
430   READ (IUNIN,*) NMOLI
      WRITE (iunout,*) '       NMOLI= ',NMOLI
      CALL EIRENE_LEER(1)
      NMOLI_IN=NMOLI
      NSPA=NSPH+NATMI
      DO 431 IMOL=1,NMOLI
        ISPZ=NSPA+IMOL
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSM(IMOL),NCHARM(IMOL),
     .                       NPRT(ISPZ),NDUMM,
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),NUMSEC,
     .                       NRCM(IMOL),NFOLM(IMOL),NGENM(IMOL),
     .                       NHSTS(ISPZ)
        IF (ISRT(ISPZ,1).LT.0) THEN
          WRITE (iunout,*) 'INPUT ERROR IN BLOCK 4B '
          WRITE (iunout,*) 'MOLECULAR SPECIES ',IMOL,':'
          WRITE (iunout,*) 'ISRT LT 0 OPTION IS NOT AVAILABLE ANYMORE'
          WRITE (iunout,*) 'PROBABLY YOU MEAN: ISRT= ',NMOLI+1
          IERROR=IERROR+1
        ENDIF
        DO 432 K=1,NRCM(IMOL)
          IF (NUMSEC .LT. 3) THEN
            READ (IUNIN,6666) IREACM(IMOL,K),IBULKM(IMOL,K),
     .                        ISCD1M(IMOL,K),ISCD2M(IMOL,K),
     .                        ISCDEM(IMOL,K),IESTMM(IMOL,K),
     .                        IBGKM(IMOL,K)
          ELSE IF (NUMSEC .EQ. 3) THEN
            READ (IUNIN,6666) IREACM(IMOL,K),IBULKM(IMOL,K),
     .                        ISCD1M(IMOL,K),ISCD2M(IMOL,K),
     .                        ISCD3M(IMOL,K),
     .                        ISCDEM(IMOL,K),IESTMM(IMOL,K),
     .                        IBGKM(IMOL,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' THREE SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1M = ',ISCD1M(IMOL,K)
            WRITE (iunout,*) ' ISCD2M = ',ISCD2M(IMOL,K)
            WRITE (iunout,*) ' ISCD3M = ',ISCD3M(IMOL,K)
            WRITE (iunout,*) ' ISCDEM = ',ISCDEM(IMOL,K)
            WRITE (iunout,*) ' IESTMM = ',IESTMM(IMOL,K)
            WRITE (iunout,*) ' IBGKM  = ',IBGKM(IMOL,K)
          ELSE IF (NUMSEC .EQ. 4) THEN
            READ (IUNIN,6666) IREACM(IMOL,K),IBULKM(IMOL,K),
     .                        ISCD1M(IMOL,K),ISCD2M(IMOL,K),
     .                        ISCD3M(IMOL,K),ISCD4M(IMOL,K),
     .                        ISCDEM(IMOL,K),IESTMM(IMOL,K),
     .                        IBGKM(IMOL,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' FOUR SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1M = ',ISCD1M(IMOL,K)
            WRITE (iunout,*) ' ISCD2M = ',ISCD2M(IMOL,K)
            WRITE (iunout,*) ' ISCD3M = ',ISCD3M(IMOL,K)
            WRITE (iunout,*) ' ISCD4M = ',ISCD4M(IMOL,K)
            WRITE (iunout,*) ' ISCDEM = ',ISCDEM(IMOL,K)
            WRITE (iunout,*) ' IESTMM = ',IESTMM(IMOL,K)
            WRITE (iunout,*) ' IBGKM  = ',IBGKM(IMOL,K)
          END IF
          READ (IUNIN,6664) EELECM(IMOL,K),EBULKM(IMOL,K),
     .                      ESCD1M(IMOL,K),ESCD2M,FREACM(IMOL,K)
          ESCD1M(IMOL,K) = ESCD1M(IMOL,K)+ESCD2M
          NSC = 0
          IF (ISCD3M(IMOL,K) > 0) NSC = 3
          IF (ISCD4M(IMOL,K) > 0) NSC = 4
          IF (NSC > 0) THEN
            IF ((REACDAT(IREACM(IMOL,K))%NOSEC > 0) .AND.
     .          (REACDAT(IREACM(IMOL,K))%NOSEC /= NSC)) THEN
              WRITE (IUNOUT,*) ' INCONSISTENCY FOUND CONCERNING',
     .              ' REACTION ',IREACM(IMOL,K)
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' PREVIOUSLY WAS ',REACDAT(IREACM(IMOL,K))%NOSEC
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' NOW IS         ',NSC
              WRITE (IUNOUT,*) ' USE EIRMOD_',
     .              MAX(REACDAT(IREACM(IMOL,K))%NOSEC,NSC),
     .              ' SECONDARIES '
              REACDAT(IREACM(IMOL,K))%NOSEC =
     .              MAX(REACDAT(IREACM(IMOL,K))%NOSEC,NSC)
            ELSE
              REACDAT(IREACM(IMOL,K))%NOSEC = NSC
            END IF
          END IF
432     CONTINUE
431   CONTINUE
C
C  READ TEST PARTICLE IONS SPECIES CARDS
C
      READ (IUNIN,*)
      WRITE (iunout,*) '*4C.   TEST IONS SPECIES CARDS, NIONI SPECIES '
440   READ (IUNIN,*) NIONI
      WRITE (iunout,*) '       NIONI= ',NIONI
      CALL EIRENE_LEER(1)
      NIONI_IN=NIONI
      NSPAM=NSPH+NATMI+NMOLI
      DO 441 IION=1,NIONI
        ISPZ=NSPAM+IION
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSI(IION),NCHARI(IION),
     .                       NPRT(ISPZ),NCHRGI(IION),
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),NUMSEC,
     .                       NRCI(IION),NFOLI(IION),NGENI(IION),
     .                       NHSTS(ISPZ)
        DO 442 K=1,NRCI(IION)
          IF (NUMSEC .LT. 3) THEN
            READ (IUNIN,6666) IREACI(IION,K),IBULKI(IION,K),
     .                        ISCD1I(IION,K),ISCD2I(IION,K),
     .                        ISCDEI(IION,K),IESTMI(IION,K),
     .                        IBGKI(IION,K)
          ELSE IF (NUMSEC .EQ. 3) THEN
            READ (IUNIN,6666) IREACI(IION,K),IBULKI(IION,K),
     .                        ISCD1I(IION,K),ISCD2I(IION,K),
     .                        ISCD3I(IION,K),
     .                        ISCDEI(IION,K),IESTMI(IION,K),
     .                        IBGKI(IION,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*) ' THREE SECONDARY GROUPS FOR SPECIES ',
     .                    TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1I = ',ISCD1I(IION,K)
            WRITE (iunout,*) ' ISCD2I = ',ISCD2I(IION,K)
            WRITE (iunout,*) ' ISCD3I = ',ISCD3I(IION,K)
            WRITE (iunout,*) ' ISCDEI = ',ISCDEI(IION,K)
            WRITE (iunout,*) ' IESTMI = ',IESTMI(IION,K)
            WRITE (iunout,*) ' IBGKI  = ',IBGKI(IION,K)
          ELSE IF (NUMSEC .EQ. 4) THEN
            READ (IUNIN,6666) IREACI(IION,K),IBULKI(IION,K),
     .                        ISCD1I(IION,K),ISCD2I(IION,K),
     .                        ISCD3I(IION,K),ISCD4I(IION,K),
     .                        ISCDEI(IION,K),IESTMI(IION,K),
     .                        IBGKI(IION,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*) ' FOUR SECONDARY GROUPS FOR SPECIES ',
     .                    TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1I = ',ISCD1I(IION,K)
            WRITE (iunout,*) ' ISCD2I = ',ISCD2I(IION,K)
            WRITE (iunout,*) ' ISCD3I = ',ISCD3I(IION,K)
            WRITE (iunout,*) ' ISCD4I = ',ISCD4I(IION,K)
            WRITE (iunout,*) ' ISCDEI = ',ISCDEI(IION,K)
            WRITE (iunout,*) ' IESTMI = ',IESTMI(IION,K)
            WRITE (iunout,*) ' IBGKI  = ',IBGKI(IION,K)
          END IF
          READ (IUNIN,6664) EELECI(IION,K),EBULKI(IION,K),
     .                      ESCD1I(IION,K),ESCD2I,FREACI(IION,K)
          ESCD1I(IION,K) = ESCD1I(IION,K)+ESCD2I
          NSC = 0
          IF (ISCD3I(IION,K) > 0) NSC = 3
          IF (ISCD4I(IION,K) > 0) NSC = 4
          IF (NSC > 0) THEN
            IF ((REACDAT(IREACI(IION,K))%NOSEC > 0) .AND.
     .          (REACDAT(IREACI(IION,K))%NOSEC /= NSC)) THEN
              WRITE (IUNOUT,*) ' INCONSISTENCY FOUND CONCERNING',
     .              ' REACTION ',IREACI(IION,K)
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' PREVIOUSLY WAS ',REACDAT(IREACI(IION,K))%NOSEC
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' NOW IS         ',NSC
              WRITE (IUNOUT,*) ' USE EIRMOD_',
     .              MAX(REACDAT(IREACI(IION,K))%NOSEC,NSC),
     .              ' SECONDARIES '
              REACDAT(IREACI(IION,K))%NOSEC =
     .              MAX(REACDAT(IREACI(IION,K))%NOSEC,NSC)
            ELSE
              REACDAT(IREACI(IION,K))%NOSEC = NSC
            END IF
          END IF
442     CONTINUE
441   CONTINUE
C
      READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:3) == '***') THEN
        IREAD=1
        NPHOTI=0
        NPHOTI_IN=NPHOTI
        GOTO 500
      END IF
      IREAD=0
      WRITE (iunout,*)
     .  '*4D.   NEUTRAL PHOTONS SPECIES CARDS, NPHOTI SPECIES'
      READ (IUNIN,*) NPHOTI
      WRITE (iunout,*) '       NPHOTI= ',NPHOTI
      CALL EIRENE_LEER(1)
      NPHOTI_IN=NPHOTI
C
      DO 451 IPHOT=1,NPHOTI
        ISPZ=IPHOT
        READ (IUNIN,66666) I,TEXTS(ISPZ),NDUMM1,NDUMM2,
     .                       NDUMM3,NDUMM4,
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),NUMSEC,
     .                       NRCPH(IPHOT),NFOLPH(IPHOT),NGENPH(IPHOT),
     .                       NHSTS(ISPZ)
C  DEFAULTS FOR PHOTONIC SPECIES:
        NPRT(ISPZ)=1
        DO 452 K=1,NRCPH(IPHOT)
          IF (NUMSEC .LT. 3) THEN
            READ (IUNIN,6666) IREACPH(IPHOT,K),IBULKPH(IPHOT,K),
     .                        ISCD1PH(IPHOT,K),ISCD2PH(IPHOT,K),
     .                        ISCDEPH(IPHOT,K),IESTMPH(IPHOT,K),
     .                        IBGKPH(IPHOT,K)
          ELSE IF (NUMSEC .EQ. 3) THEN
            READ (IUNIN,6666) IREACPH(IPHOT,K),IBULKPH(IPHOT,K),
     .                        ISCD1PH(IPHOT,K),ISCD2PH(IPHOT,K),
     .                        ISCD3PH(IPHOT,K),
     .                        ISCDEPH(IPHOT,K),IESTMPH(IPHOT,K),
     .                        IBGKPH(IPHOT,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' THREE SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1PH = ',ISCD1PH(IPHOT,K)
            WRITE (iunout,*) ' ISCD2PH = ',ISCD2PH(IPHOT,K)
            WRITE (iunout,*) ' ISCD3PH = ',ISCD3PH(IPHOT,K)
            WRITE (iunout,*) ' ISCDEPH = ',ISCDEPH(IPHOT,K)
            WRITE (iunout,*) ' IESTMPH = ',IESTMPH(IPHOT,K)
            WRITE (iunout,*) ' IBGKPH  = ',IBGKPH(IPHOT,K)
          ELSE IF (NUMSEC .EQ. 4) THEN
            READ (IUNIN,6666) IREACPH(IPHOT,K),IBULKPH(IPHOT,K),
     .                        ISCD1PH(IPHOT,K),ISCD2PH(IPHOT,K),
     .                        ISCD3PH(IPHOT,K),ISCD4PH(IPHOT,K),
     .                        ISCDEPH(IPHOT,K),IESTMPH(IPHOT,K),
     .                        IBGKPH(IPHOT,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' FOUR SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1PH = ',ISCD1PH(IPHOT,K)
            WRITE (iunout,*) ' ISCD2PH = ',ISCD2PH(IPHOT,K)
            WRITE (iunout,*) ' ISCD3PH = ',ISCD3PH(IPHOT,K)
            WRITE (iunout,*) ' ISCD4PH = ',ISCD4PH(IPHOT,K)
            WRITE (iunout,*) ' ISCDEPH = ',ISCDEPH(IPHOT,K)
            WRITE (iunout,*) ' IESTMPH = ',IESTMPH(IPHOT,K)
            WRITE (iunout,*) ' IBGKPH  = ',IBGKPH(IPHOT,K)
          END IF
          READ (IUNIN,6664) EELECPH(IPHOT,K),EBULKPH(IPHOT,K),
     .                      ESCD1PH(IPHOT,K),ESCD2PH,
     .                      FREACPH(IPHOT,K),FLDLMPH(IPHOT,K)
          ESCD1PH(IPHOT,K) = ESCD1PH(IPHOT,K)+ESCD2PH
          NSC = 0
          IF (ISCD3PH(IPHOT,K) > 0) NSC = 3
          IF (ISCD4PH(IPHOT,K) > 0) NSC = 4
          IF (NSC > 0) THEN
            IF ((REACDAT(IREACPH(IPHOT,K))%NOSEC > 0) .AND.
     .          (REACDAT(IREACPH(IPHOT,K))%NOSEC /= NSC)) THEN
              WRITE (IUNOUT,*) ' INCONSISTENCY FOUND CONCERNING',
     .              ' REACTION ',IREACPH(IPHOT,K)
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' PREVIOUSLY WAS ',REACDAT(IREACPH(IPHOT,K))%NOSEC
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' NOW IS         ',NSC
              WRITE (IUNOUT,*) ' USE EIRMOD_',
     .              MAX(REACDAT(IREACPH(IPHOT,K))%NOSEC,NSC),
     .              ' SECONDARIES '
              REACDAT(IREACPH(IPHOT,K))%NOSEC =
     .              MAX(REACDAT(IREACPH(IPHOT,K))%NOSEC,NSC)
            ELSE
              REACDAT(IREACPH(IPHOT,K))%NOSEC = NSC
            END IF
          END IF
452     CONTINUE
451   CONTINUE
C
C  READ DATA FOR PLASMA-BACKGROUND , 500--599
C
500   CONTINUE
C
      IF (IREAD == 0)  READ (IUNIN,'(A72)') ZEILE
C     WRITE (iunout,*) ZEILE
      CALL EIRENE_MASAGE
     .  ('*** 5. DATA FOR PLASMA BACKGROUND            ')
      CALL EIRENE_LEER(1)
C
C  READ BULK IONS SPECIES CARDS
C
      READ (IUNIN,'(A72)') ZEILE
C     WRITE (iunout,*) ZEILE
      WRITE (iunout,*) '*5A.   BULK ION SPECIES CARDS, NPLSI SPECIES '
510   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 510
      READ(ZEILE,6666) NPLSI
      WRITE (iunout,*) '       NPLSI= ',NPLSI
      CALL EIRENE_LEER(1)
      NPLSI_IN=NPLSI
      NSPAMI=NSPAM+NIONI
      NSPTOT=NSPAMI+NPLSI
      DO 511 IPLS=1,NPLSI
        ISPZ=NSPAMI+IPLS
        READ (IUNIN,66666) I,TEXTS(ISPZ),NMASSP(IPLS),NCHARP(IPLS),
     .                       NPRT(ISPZ),NCHRGP(IPLS),
     .                       ISRF(ISPZ,1),ISRT(ISPZ,1),NUMSEC,
     .                       NRCP(IPLS),NDUMM1,NDUMM2,
     .                       NHSTS(ISPZ),NDUMM4,
     .                       CDENMODEL(IPLS),NRE
        CALL EIRENE_UPPERCASE (CDENMODEL(IPLS))
        DO 512 K=1,NRCP(IPLS)
          IF (NUMSEC .LT. 3) THEN
            READ (IUNIN,6666) IREACP(IPLS,K),IBULKP(IPLS,K),
     .                        ISCD1P(IPLS,K),ISCD2P(IPLS,K),
     .                        ISCDEP(IPLS,K)
          ELSE IF (NUMSEC .EQ. 3) THEN
            READ (IUNIN,6666) IREACP(IPLS,K),IBULKP(IPLS,K),
     .                        ISCD1P(IPLS,K),ISCD2P(IPLS,K),
     .                        ISCD3P(IPLS,K),ISCDEP(IPLS,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' THREE SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1P = ',ISCD1P(IPLS,K)
            WRITE (iunout,*) ' ISCD2P = ',ISCD2P(IPLS,K)
            WRITE (iunout,*) ' ISCD3P = ',ISCD3P(IPLS,K)
            WRITE (iunout,*) ' ISCDEP = ',ISCDEP(IPLS,K)
          ELSE IF (NUMSEC .EQ. 4) THEN
            READ (IUNIN,6666) IREACP(IPLS,K),IBULKP(IPLS,K),
     .                        ISCD1P(IPLS,K),ISCD2P(IPLS,K),
     .                        ISCD3P(IPLS,K),ISCD4P(IPLS,K),
     .                        ISCDEP(IPLS,K)
            WRITE (iunout,*) ' WARNING !!! '
            WRITE (iunout,*)
     .        ' FOUR SECONDARY GROUPS USED FOR SPECIES ',
     .          TEXTS(ISPZ)
            WRITE (iunout,*) ' ISCD1P = ',ISCD1P(IPLS,K)
            WRITE (iunout,*) ' ISCD2P = ',ISCD2P(IPLS,K)
            WRITE (iunout,*) ' ISCD3P = ',ISCD3P(IPLS,K)
            WRITE (iunout,*) ' ISCD4P = ',ISCD4P(IPLS,K)
            WRITE (iunout,*) ' ISCDEP = ',ISCDEP(IPLS,K)
          END IF
          READ (IUNIN,6664) EELECP(IPLS,K),EBULKP(IPLS,K),
     .                      ESCD1P(IPLS,K),ESCD2P,FREACP(IPLS,K)
          ESCD1P(IPLS,K) = ESCD1P(IPLS,K)+ESCD2P
          NSC = 0
          IF (ISCD3P(IPLS,K) > 0) NSC = 3
          IF (ISCD4P(IPLS,K) > 0) NSC = 4
          IF (NSC > 0) THEN
            IF ((REACDAT(IREACP(IPLS,K))%NOSEC > 0) .AND.
     .          (REACDAT(IREACP(IPLS,K))%NOSEC /= NSC)) THEN
              WRITE (IUNOUT,*) ' INCONSISTENCY FOUND CONCERNING',
     .              ' REACTION ',IREACP(IPLS,K)
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' PREVIOUSLY WAS ',REACDAT(IREACP(IPLS,K))%NOSEC
              WRITE (IUNOUT,*) ' NUMBER OF SECONDARIES FOUND',
     .              ' NOW IS         ',NSC
              WRITE (IUNOUT,*) ' USE EIRMOD_',
     .              MAX(REACDAT(IREACP(IPLS,K))%NOSEC,NSC),
     .              ' SECONDARIES '
              REACDAT(IREACP(IPLS,K))%NOSEC =
     .              MAX(REACDAT(IREACP(IPLS,K))%NOSEC,NSC)
            ELSE
              REACDAT(IREACP(IPLS,K))%NOSEC = NSC
            END IF
          END IF
512     CONTINUE
        IF (LEN_TRIM(CDENMODEL(IPLS)) > 0) THEN
          ALLOCATE (TDMPAR(IPLS)%TDM)
          TDMPAR(IPLS)%TDM%NRE=MAX(NRE,1)
          ALLOCATE (TDMPAR(IPLS)%TDM%ISP(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%ITP(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%ISTR(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%FNAME(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%H2(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%REACTION(TDMPAR(IPLS)%TDM%NRE))
          ALLOCATE (TDMPAR(IPLS)%TDM%CR(TDMPAR(IPLS)%TDM%NRE))
          SELECT CASE (CDENMODEL(IPLS))
          CASE ('FORT.13   ')
            READ (IUNIN,6666) TDMPAR(IPLS)%TDM%ISP(1)
                              TDMPAR(IPLS)%TDM%ITP(1)=4
          CASE ('FORT.10   ')
            READ (IUNIN,6666) TDMPAR(IPLS)%TDM%ISP(1),
     .                        TDMPAR(IPLS)%TDM%ITP(1),
     .                        TDMPAR(IPLS)%TDM%ISTR(1)
          CASE ('CONSTANT  ')
            READ (IUNIN,6664) TDMPAR(IPLS)%TDM%TVAL,
     .                        TDMPAR(IPLS)%TDM%DVAL,
     .                        TDMPAR(IPLS)%TDM%VXVAL,
     .                        TDMPAR(IPLS)%TDM%VYVAL,
     .                        TDMPAR(IPLS)%TDM%VZVAL
          CASE ('MULTIPLY  ')
            READ (IUNIN,'(3I6,6x,3E12.4)')
     .           TDMPAR(IPLS)%TDM%ISP(1),
     .           TDMPAR(IPLS)%TDM%ITP(1),
     .           TDMPAR(IPLS)%TDM%ISTR(1),
     .           TDMPAR(IPLS)%TDM%DFACTOR,
     .           TDMPAR(IPLS)%TDM%TFACTOR,
     .           TDMPAR(IPLS)%TDM%VFACTOR
          CASE ('SAHA      ')
!PB   TO BE WRITTEN
          CASE ('BOLTZMANN ')
            READ (IUNIN,'(3I6,6x,2E12.4)')
     .           TDMPAR(IPLS)%TDM%ISP(1),
     .           TDMPAR(IPLS)%TDM%ITP(1),
     .           TDMPAR(IPLS)%TDM%ISTR(1),
     .           TDMPAR(IPLS)%TDM%G_BOLTZ,
     .           TDMPAR(IPLS)%TDM%DELTAE
          CASE ('CORONA    ')
            READ (IUNIN,'(3I6,1X,A6,1X,A4,A9,A3,E12.4)')
     .           TDMPAR(IPLS)%TDM%ISP(1),
     .           TDMPAR(IPLS)%TDM%ITP(1),
     .           TDMPAR(IPLS)%TDM%ISTR(1),
     .           TDMPAR(IPLS)%TDM%FNAME(1),
     .           TDMPAR(IPLS)%TDM%H2(1),
     .           TDMPAR(IPLS)%TDM%REACTION(1),
     .           TDMPAR(IPLS)%TDM%CR(1),
     .           TDMPAR(IPLS)%TDM%A_CORONA
            IF (INDEX(TDMPAR(IPLS)%TDM%H2(1),'H.2') == 0) THEN
              WRITE (iunout,*)
     .          ' WRONG REACTION SPECIFIED FOR CORONA MODEL '
              WRITE (iunout,*) ' ONLY H.2 REACTIONS ARE PERMITTED '
              WRITE (iunout,*) ' IPLS = ',IPLS
              CALL EIRENE_EXIT_OWN(1)
            END IF
          CASE ('COLRAD    ')
            DO I=1, TDMPAR(IPLS)%TDM%NRE
              READ (IUNIN,'(3I6,1X,A6,1X,A4,A9,A3)')
     .             TDMPAR(IPLS)%TDM%ISP(I),
     .             TDMPAR(IPLS)%TDM%ITP(I),
     .             TDMPAR(IPLS)%TDM%ISTR(I),
     .             TDMPAR(IPLS)%TDM%FNAME(I),
     .             TDMPAR(IPLS)%TDM%H2(I),
     .             TDMPAR(IPLS)%TDM%REACTION(I),
     .             TDMPAR(IPLS)%TDM%CR(I)
              IF (INDEX(TDMPAR(IPLS)%TDM%H2(1),'H.11') == 0. AND.
     .            INDEX(TDMPAR(IPLS)%TDM%H2(1),'H.12') == 0.) THEN
                WRITE (iunout,*)
     .            ' WRONG REACTION SPECIFIED FOR COLRAD MODEL '
                WRITE (iunout,*) ' ONLY H.11 OR H.12 REACTIONS '
                WRITE (IUNOUT,*) ' ARE PERMITTED '
                WRITE (iunout,*) ' IPLS = ',IPLS
                CALL EIRENE_EXIT_OWN(1)
              END IF
            END DO
          CASE DEFAULT
!PB  NOTHING TO BE DONE
          END SELECT
        END IF
511   CONTINUE
C
      DO I=1,NSPZ
        CALL EIRENE_UPPERCASE (TEXTS(I))
      END DO
C
520   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') THEN
C       WRITE (iunout,*) ZEILE
        GOTO 520
      ENDIF
      CALL EIRENE_MASAGE
     .  ('*5B.   PLASMA BACKGROUND DATA                ')
      CALL EIRENE_LEER(1)
      READ (ZEILE,6666) (INDPRO(J),J=1,12)
C  Te profile
      IF (INDPRO(1).LE.5.AND.NPLSI.GT.0)
     .  READ (IUNIN,6664) TE0,TE1,TE2,TE3,TE4,TE5
C  Ti profile(s)
      NPLSTI = 1
      IF ((INDPRO(2) < 0) .OR. (INDPRO(2) > 9)) NPLSTI=NPLS
      NLMLTI=NPLSTI > 1
      MPLSTI=1
      IF (NLMLTI) MPLSTI = (/ (I,I=1,NPLS) /)
      INDPRO(2)=IABS(INDPRO(2))
      IF (INDPRO(2) > 9) INDPRO(2) = MOD(INDPRO(2),10)
      IF (INDPRO(2).LE.5.AND.NPLSI.GT.0) THEN
        IF (NLMLTI) THEN
          READ (IUNIN,6664) (TI0(I),TI1(I),TI2(I),TI3(I),TI4(I),TI5(I),
     .                       I=1,NPLSI)
        ELSE
C  ONLY ONE COMMON ION TEMPERATURE FOR ALL SPECIES
          READ (IUNIN,6664)  TI0(1),TI1(1),TI2(1),TI3(1),TI4(1),TI5(1)
          DO 530 IPLS=2,NPLSTI
            TI0(IPLS)=TI0(1)
            TI1(IPLS)=TI1(1)
            TI2(IPLS)=TI2(1)
            TI3(IPLS)=TI3(1)
            TI4(IPLS)=TI4(1)
            TI5(IPLS)=TI5(1)
530       CONTINUE
        ENDIF
      ENDIF
c  di profiles
      IF (INDPRO(3).LE.5)
     .  READ (IUNIN,6664) (DI0(I),DI1(I),DI2(I),DI3(I),DI4(I),DI5(I),
     .                     I=1,NPLSI)
c  vi profile(s)
      NLMACH=INDPRO(4).LT.0
      NPLSV = NPLS
      IF (IABS(INDPRO(4)) > 9) NPLSV = 1
 
      INDPRO(4)=IABS(INDPRO(4))
      IF (INDPRO(4) > 9) INDPRO(4) = MOD(INDPRO(4),10)
      NLMLV = NPLSV > 1
      IF (.not.NLMLV) THEN
        MPLSV = 1
      ELSE
        MPLSV = (/ (I,I=1,NPLS) /)
      ENDIF
      IF (INDPRO(4).LE.5) THEN
        IF (.not. NLMLV) THEN
          READ (IUNIN,6664) VX0(1),VX1(1),VX2(1),VX3(1),VX4(1),VX5(1)
          READ (IUNIN,6664) VY0(1),VY1(1),VY2(1),VY3(1),VY4(1),VY5(1)
          READ (IUNIN,6664) VZ0(1),VZ1(1),VZ2(1),VZ3(1),VZ4(1),VZ5(1)
        ELSE
          READ (IUNIN,6664) (VX0(I),VX1(I),VX2(I),VX3(I),VX4(I),VX5(I),
     .                       I=1,NPLSI)
          READ (IUNIN,6664) (VY0(I),VY1(I),VY2(I),VY3(I),VY4(I),VY5(I),
     .                       I=1,NPLSI)
          READ (IUNIN,6664) (VZ0(I),VZ1(I),VZ2(I),VZ3(I),VZ4(I),VZ5(I),
     .                       I=1,NPLSI)
        END IF
      ENDIF
c  pitch -profile
      IF (INDPRO(5).LE.5)
     .  READ (IUNIN,6664) B0,B1,B2,B3,B4,B5
c  cell volume -profile
      IF (INDPRO(12).LE.5) THEN
        READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:3) .EQ. '***') THEN
          WRITE (iunout,*) 'ONE INPUT LINE MISSING IN BLOCK 5 '
          WRITE (iunout,*) 'AUTOMATIC CORRECTION PERFORMED '
          VL0=0
        ELSE
          READ (ZEILE,6664) VL0,VL1,VL2,VL3,VL4,VL5
          IREAD=0
        ENDIF
      ENDIF
 
      IF (LINCLUDE) THEN
        CLOSE (IUNIN)
        IUNIN = IUNIN_SAVE
        LINCLUDE =.FALSE.
 
        DO
          READ (IUNIN,'(A72)') ZEILE
          IF ((ZEILE(1:3) == '***') .AND.
     ,        (INDEX(ZEILE,'6.') > 0)) EXIT
        END DO
        IREAD = 1
      END IF
 
      IF (LHYDDEF) CALL EIRENE_SETUP_HYDKIN_REACTIONS(HYDKIN_DEFAULT,
     .  CADAPT)
C
C  READ  DATA FOR REFLECTION MODEL  600--699
C
600   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      NULLIFY(REFFILES)
      CALL EIRENE_MASAGE
     .  ('*** 6. GENERAL DATA FOR REFLECTION MODEL    ')
      CALL EIRENE_LEER(1)
C
610   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 610
      READ (ZEILE,6665) NLTRIM
      IREAD=0
      IF (NLTRIM) THEN
        READ (IUNIN,'(A420)') ZEILE
        IREAD=1
        IF (INDEX(ZEILE,'PATH')+INDEX(ZEILE,'path').EQ.0) THEN
C  NO PATH SPECIFIED FOR REFLECTION DATA BASE
          WRITE (iunout,*)
     .      ' NO PATH SPECIFIED FOR REFLECTION DATA BASE '
          WRITE (iunout,*) ' OLD VERSION USED '
          LTRMOL=.TRUE.
C  SKIP LINES CONTAINING SPECIFICATIONS FOR DATA BASES AND
C  CONTINUE READING
615       IF (INDEX(ZEILE,'ON')+INDEX(ZEILE,'on').EQ.0) THEN
            READ (ZEILE,6664) (DATD(IATM),IATM=1,NATMI_IN)
            IREAD=0
            GOTO 620
          ELSE
            READ (IUNIN,'(A72)') ZEILE
            IREAD=1
            GOTO 615
          ENDIF
        ELSE
C  PATH SPECIFICATION FOR DATA BASE FOUND
          LTRMOL=.FALSE.
          READ (ZEILE(7:),'(A400)') PATH
          WRITE (iunout,*) ' PATH = ',PATH
          PATH=ADJUSTL(PATH)
          I2=INDEX(PATH,' ')
          IF ((I2 == 0) .AND. (ZEILE(408:408) /= ' ')) THEN
            WRITE (iunout,*) ' PATH FOR TRIM REFLECTION DATABASE IS',
     .                  ' TOO LONG !'
            CALL EIRENE_EXIT_OWN(1)
          END IF
          FILE=REPEAT(' ',420)
          FILE(1:)=PATH(1:I2-1)
          NFR=0
          READ (IUNIN,'(A72)') ZEILE
625       IF (INDEX(ZEILE,'ON')+INDEX(ZEILE,'on').EQ.0) THEN
            READ (ZEILE,6664) (DATD(IATM),IATM=1,NATMI_IN)
            IREAD=0
            GOTO 620
          ELSE
            NFR=NFR+1
            READ (ZEILE,'(A8)') FILNAM
            WRITE (iunout,*) ' NFR =',NFR,' FILNAM = ',FILNAM
            FILE(I2:)=FILNAM
            WRITE (iunout,'(A,A)') ' FILE = ',FILE
            ALLOCATE (CURFILE)
            CURFILE%RFILE = FILE
            CURFILE%NEXT => REFFILES
            REFFILES => CURFILE
            READ (IUNIN,'(A72)') ZEILE
            GOTO 625
          ENDIF
        ENDIF
      ENDIF
      READ (IUNIN,6664) (DATD(IATM),IATM=1,NATMI_IN)
620   READ (IUNIN,6664) (DMLD(IMOL),IMOL=1,NMOLI_IN)
      READ (IUNIN,6664) (DIOD(IION),IION=1,NIONI_IN)
      READ (IUNIN,6664) (DPLD(IPLS),IPLS=1,NPLSI_IN)
      IF (NPHOTI > 0)
     .  READ (IUNIN,6664) (DPHD(IPHOT),IPHOT=1,NPHOTI_IN)
 
      IF (ASSOCIATED(REFFILES)) THEN
        NHD6 = NFR
      ELSE
        NHD6 = 8
      END IF
      NH0=NHD1*NHD2*NHD6
      NH1=NH0*NHD3
      NH2=NH1*NHD4
      NH3=NH2*NHD5
      CALL EIRENE_ALLOC_CREF
!pb      CALL EIRENE_ALLOC_CREFMOD
      NFLR = 0
      DO WHILE (ASSOCIATED(REFFILES))
        NFLR = NFLR + 1
        REFFIL(NFLR) = REFFILES%RFILE
        CURFILE => REFFILES
        REFFILES => REFFILES%NEXT
        DEALLOCATE(CURFILE)
      END DO
 
      READ (IUNIN,6664) ERMIN,ERCUT,RPROB0,RINTEG(1),EINTEG(1),AINTEG(1)
      DO
        IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:3) .EQ. '***') THEN
          IREAD = 1
          EXIT
        END IF
        IF (ZEILE(1:8) /= 'SURFMOD_') CYCLE
        ALLOCATE (REFCUR)
        ALLOCATE (REFCUR%JSRS(nspz))
        ALLOCATE (REFCUR%JSRC(nspz))
        ALLOCATE (REFCUR%TRANSPR(nspz,2))
        ALLOCATE (REFCUR%RCYCFR(nspz))
        ALLOCATE (REFCUR%RCYCTR(nspz))
        ALLOCATE (REFCUR%RCPRMR(nspz))
        ALLOCATE (REFCUR%EXPPLR(nspz))
        ALLOCATE (REFCUR%EXPELR(nspz))
        ALLOCATE (REFCUR%EXPILR(nspz))
        ALLOCATE (REFCUR%RCYCSR(nspz))
        ALLOCATE (REFCUR%RCYCCR(nspz))
        ALLOCATE (REFCUR%STPRMR(nspz))
        REFCUR%REFNAME = TRIM(ADJUSTL(ZEILE(9:)))
        IREAD=0
        READ (IUNIN,6666) REFCUR%JLREF,REFCUR%JLSPT,
     .                    REFCUR%JSRS(1),REFCUR%JSRC(1)
        READ (IUNIN,6664) REFCUR%ZNMLR,REFCUR%EWALLR,REFCUR%EWBINR,
     .                    REFCUR%TRANSPR(1,1:2),REFCUR%FSHEATR
        READ (IUNIN,6664) REFCUR%RCYCFR(1),REFCUR%RCYCTR(1),
     .                    REFCUR%RCPRMR(1),REFCUR%EXPPLR(1),
     .                    REFCUR%EXPELR(1),REFCUR%EXPILR(1)
        DO I=2,NSPZ
          REFCUR%JSRS(I) = REFCUR%JSRS(1)
          REFCUR%JSRC(I) = REFCUR%JSRC(1)
          REFCUR%TRANSPR(I,1:2)=REFCUR%TRANSPR(1,1:2)
          REFCUR%RCYCFR(I) = REFCUR%RCYCFR(1)
          REFCUR%RCYCTR(I) = REFCUR%RCYCTR(1)
          REFCUR%RCPRMR(I) = REFCUR%RCPRMR(1)
          REFCUR%EXPPLR(I) = REFCUR%EXPPLR(1)
          REFCUR%EXPELR(I) = REFCUR%EXPELR(1)
          REFCUR%EXPILR(I) = REFCUR%EXPILR(1)
        END DO
C
C  DEFAULT
        REFCUR%RCYCSR=RECYCS(1,0)
        REFCUR%RCYCCR=RECYCC(1,0)
        REFCUR%STPRMR=SPTPRM(1,0)
C
        READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        ideflt_sput=-1
        ideflt_spez=-1
C  READ ONE MORE LINE FOR NON-DEFAULT SPUTTER MODEL
        do while (ZEILE(1:1).NE.'*'.AND.ZEILE(1:8).NE.'SURFMOD_')
          varname = zeile(1:8)
          call EIRENE_uppercase (varname)
          spcname = zeile(10:17)
          call EIRENE_uppercase (spcname)
          ispz=-1
          ico=0
          do is=1,nspz
            if (texts(is) == spcname) then
              if (ico == 0) then
                ispz = is
                ico = 1
              else
                call EIRENE_leer(2)
                write (iunout,*) ' WARNING !! '
                write (iunout,*)
     .             ' ambigous species names found in surface ',
     .             'model "',REFCUR%REFNAME,'"'
                write (iunout,*) varname,'is modified for species ',ispz
              end if
            end if
          end do     ! end of "is"-loop
          ideflt_spez=1   !tentatively assume: species card
          select case (varname)
          case ('ISRS')
            if (ispz > 0)
     .          read (zeile(18:),'(I6)') REFCUR%JSRS(ispz)
          case ('ISRC')
            if (ispz > 0)
     .          read (zeile(18:),'(I6)') REFCUR%JSRC(ispz)
          case ('TRANSP1')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%TRANSPR(ispz,1)
          case ('TRANSP2')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%TRANSPR(ispz,2)
          case ('RECYCF')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%RCYCFR(ispz)
          case ('RECYCT')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%RCYCTR(ispz)
          case ('RECPRM')
            if (ispz >0)
     .          read (zeile(18:),'(E12.4)') REFCUR%RCPRMR(ispz)
          case ('EXPPL')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%EXPPLR(ispz)
          case ('EXPEL')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%EXPELR(ispz)
          case ('EXPIL')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%EXPILR(ispz)
          case ('RECYCS')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%RCYCSR(ispz)
          case ('RECYCC')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%RCYCCR(ispz)
          case ('SPTPRM')
            if (ispz > 0)
     .          read (zeile(18:),'(E12.4)') REFCUR%STPRMR(ispz)
 
          case default
c  not a species card, hence: a sputer model card
            if (ispz < 0) then
              READ (ZEILE,6664) REFCUR%RCYCSR(1),REFCUR%RCYCCR(1),
     .                          REFCUR%STPRMR(1)
              DO I=2,NSPZ
                REFCUR%RCYCSR(I) = REFCUR%RCYCSR(1)
                REFCUR%RCYCCR(I) = REFCUR%RCYCCR(1)
                REFCUR%STPRMR(I) = REFCUR%STPRMR(1)
              ENDDO
              ideflt_sput=1
              ideflt_spez=-1
            end if
          end select
          if ((ideflt_spez > 0) .and. (ispz < 0)) then
            write (iunout,*)
     .        ' wrong card in species dep. reflection model'
            write (iunout,*) zeile
          end if
          READ (IUNIN,'(A72)') ZEILE
          IREAD=1
C
        END do    ! end of do-while loop (search for * or for SURFMOD_)
C all lines of this particular SURFMOD_... are read now
C
        IF (ideflt_sput.le.0.and.REFCUR%JLSPT.NE.0) THEN
          WRITE (iunout,*) 'WARNING: SPUTTERING FOR MODEL ',
     .                      REFCUR%REFNAME
          WRITE (iunout,*) 'BUT NO PARAMETERS RECYCS, RECYCC ARE READ '
          WRITE (iunout,*)
     .  'DEFAULT MODEL: "NO SPUTTERING" IS USED. EIRMOD_'
          WRITE (iunout,*) 'DO YOU REALLY WANT THIS?'
          REFCUR%JLSPT=0
        ENDIF
        L=LEN_TRIM(REFCUR%REFNAME)
        WRITE (iunout,*) 'SURFACE MODEL "',REFCUR%REFNAME(1:L),
     .                   '" DEFINED'
        REFCUR%NEXT => REFLIST
        REFLIST => REFCUR
      END DO
C
C  READ DATA FOR PRIMARY SOURCE  700--799
C
700   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 7. DATA FOR PRIMARY SOURCES, NSTRAI STRATA   ')
C
710   READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:1) .EQ. '*') GOTO 710
      READ (ZEILE,6666) NSTRAI
      IREAD=0
      WRITE (iunout,*) '       NSTRAI= ',NSTRAI
      CALL EIRENE_LEER(1)
!pb      READ (IUNIN,6666) (INDSRC(ISTRA),ISTRA=1,NSTRAI)
      READ (IUNIN,6666) (INDSRC(IST),IST=1,NSTRAI)
      READ (IUNIN,6664) ALLOC
      DO 712 ISTRA=1,NSTRAI
        IF (INDSRC(ISTRA).EQ.6) GOTO 712
        I=ISTRA
        IF (IREAD.EQ.0) THEN
          READ (IUNIN,'(A72)') TXTSOU(ISTRA)
        ELSEIF (IREAD.EQ.1) THEN
          READ (ZEILE,'(A72)') TXTSOU(ISTRA)
          IREAD=0
        ENDIF
713     READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1) .EQ. '*') GOTO 713
        READ (ZEILE,6665) NLAVRP(ISTRA),NLAVRT(I),NLSYMP(I),NLSYMT(I),
     .                    NLRAY(ISTRA)
        IREAD=0
        READ (IUNIN,6666) NPTS(ISTRA),NINITL(I),NEMODS(I),NAMODS(I),
     .                    NPTSDEL(I),NRAYEN(ISTRA)
csw if npts < 0 --> npts = infty
        if(npts(istra).lt.0) npts(istra) = huge(1)-1
        READ (IUNIN,66662) FLUX(ISTRA),SCALV(ISTRA),IVLSF(ISTRA),
     .                    ISCLS(ISTRA),ISCLT(ISTRA),ISCL1(ISTRA),
     .                    ISCL2(ISTRA),ISCL3(ISTRA),ISCLB(ISTRA),
     .                    ISCLA(ISTRA)
        READ (IUNIN,6665) NLATM(ISTRA),NLMOL(ISTRA),NLION(I),NLPLS(I)
        READ (IUNIN,6666) NSPEZ(ISTRA)
        READ (IUNIN,6665) NLPNT(ISTRA),NLLNE(ISTRA),
     .                    NLSRF(ISTRA),NLVOL(ISTRA),NLCNS(ISTRA)
C  SAME FOR POINT-, LINE-, SURFACE- AND VOLUME SOURCES
        READ (IUNIN,6666) NSRFSI(ISTRA)
        IF (NSRFSI(ISTRA).GT.NSRFS)
     .    CALL
     .  EIRENE_MASPRM('NSRFS',5,NSRFS,'NSRFSI(I)',9,NSRFSI(I),IERROR)
        DO 715 J=1,NSRFSI(ISTRA)
          READ (IUNIN,6666) INUM,INDIM(J,I),INSOR(J,I),
     .                      INGRDA(J,I,1),INGRDE(J,I,1),
     .                      INGRDA(J,I,2),INGRDE(J,I,2),
     .                      INGRDA(J,I,3),INGRDE(J,I,3)
          READ (IUNIN,6664) SORWGT(J,I),SORLIM(J,I),
     .                      SORIND(J,I),SOREXP(J,I),SORIFL(J,I)
          READ (IUNIN,6666) NRSOR(J,I),NPSOR(J,I),NTSOR(J,I),
     .                      NBSOR(J,I),NASOR(J,I),NISOR(J,I),ISTOR(J,I)
          READ (IUNIN,6664) SORAD1(J,I),SORAD2(J,I),SORAD3(J,I),
     .                      SORAD4(J,I),SORAD5(J,I),SORAD6(J,I)
715     CONTINUE
C  VELOCITY SPACE DISTRIBUTION
        READ (IUNIN,6664) SORENI(ISTRA),SORENE(I),SORVDX(I),SORVDY(I),
     .                    SORVDZ(ISTRA)
        READ (IUNIN,6664) SORCOS(I),SORMAX(I),SORCTX(I),SORCTY(I),
     .                    SORCTZ(ISTRA),RAYFRAC(ISTRA)
C
712   CONTINUE
C
      READ (IUNIN,*)
C     READ ADDITIONAL DATA FOR SOME SPECIFIC ZONES
C
800   CONTINUE
C
      CALL EIRENE_MASAGE ('*** 8. ADDITIONAL DATA FOR SPECIFIC ZONES ')
810   READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:1) .EQ. '*') GOTO 810
      READ (ZEILE,6666) NZADD
      IREAD=0
      WRITE (iunout,*) '       NZADD= ',NZADD
      CALL EIRENE_LEER(1)
      NULLIFY(TEMPLIST)
      NULLIFY(DENLIST)
      NULLIFY(VELLIST)
      NULLIFY(VOLLIST)
      DO 811 I=1,NZADD
        IF (IREAD.EQ.0) READ (IUNIN,*)
        IREAD=0
        READ (IUNIN,6666) INI,INE
        IF (INI.GT.NRAD.OR.INI.LE.0) GOTO 998
        IF (INE.GT.NRAD) GOTO 998
        IF (INE.LE.0) INE=INI
812     READ (IUNIN,'(A72)') ZEILE
C  IGJUM3 FLAG
        IF (ZEILE(1:3).EQ.'CH3') THEN
          INILGJ=MAX(1,MIN(NOPTIM,INI))
          INELGJ=MIN(NOPTIM,INE)
          DO 821 IN=INILGJ,INELGJ
          IF (NLIMPB >= NLIMPS) THEN
            CALL EIRENE_DEKEY (ZEILE(4:72),IGJUM3,0,NOPTIM,IN,NLIMPS)
          ELSE
            CALL EIRENE_DEKEYB
     .  (ZEILE(4:72),IGJUM3,0,NOPTIM,IN,NLIMPB,NBITS)
          END IF
821         CONTINUE
          GOTO 812
C  TEMPERATURE
        ELSEIF (ZEILE(1:1).EQ.'T') THEN
          DO 822 IN=INI,INE
            ALLOCATE(TEMPCUR)
            READ (ZEILE(2:72),66664) TEMPCUR%IDION,TEMPCUR%TE,
     .                               TEMPCUR%TI
            TEMPCUR%IN = IN
            TEMPCUR%NEXT => TEMPLIST
            TEMPLIST => TEMPCUR
822       CONTINUE
          GOTO 812
C  DENSITY
        ELSEIF (ZEILE(1:1).EQ.'D') THEN
          DO 823 IN=INI,INE
            ALLOCATE(DENCUR)
            READ (ZEILE(2:72),66664) DENCUR%IDION,DENCUR%DI
            DENCUR%IN = IN
            DENCUR%NEXT => DENLIST
            DENLIST => DENCUR
823       CONTINUE
          GOTO 812
C  VELOCITY (CM/SEC OR MACH)
        ELSEIF ((ZEILE(1:1).EQ.'V'.AND.ZEILE(2:2).NE.'L')
     .       .OR.ZEILE(1:1).EQ.'M') THEN
          DO 824 IN=INI,INE
            ALLOCATE(VELCUR)
            READ (ZEILE(2:72),66664) VELCUR%IDION,VELCUR%VX,VELCUR%VY,
     .                               VELCUR%VZ
            IF (ZEILE(1:1).EQ.'M') THEN
              VELCUR%IZ=1
            ELSEIF (ZEILE(1:1).EQ.'V') THEN
              VELCUR%IZ=-1
            ENDIF
            VELCUR%IN = IN
            VELCUR%NEXT => VELLIST
            VELLIST => VELCUR
824       CONTINUE
          GOTO 812
C  VOLUME
        ELSEIF (ZEILE(1:2).EQ.'VL') THEN
          DO 825 IN=INI,INE
            ALLOCATE(VOLCUR)
            READ (ZEILE(3:72),6664) VOLCUR%VOL
            VOLCUR%IN = IN
            VOLCUR%NEXT => VOLLIST
            VOLLIST => VOLCUR
825       CONTINUE
          GOTO 812
        ELSEIF (ZEILE(1:1).EQ.'*') THEN
          IREAD=1
          GOTO 811
        ELSE
          GOTO 998
        ENDIF
811   CONTINUE
 
C
C  READ DATA FOR STATISTICS AND NONANALOG MODEL, 900--999
C
900   CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL EIRENE_MASAGE
     .  ('*** 9. DATA FOR STATISTIC AND NONANALOG MODEL   ')
C
910   READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 910
C  DATA FOR CONDITIONAL EXPECTATION ESTIMATOR
      READ (ZEILE,6665) (NLPRCA(J),J=1,NATMI_IN),
     .                  (NLPRCM(J),J=1,NMOLI_IN),
     .                  (NLPRCI(J),J=1,NIONI_IN),
     .                  (NLPRCPH(J),J=1,NPHOTI_IN)
      READ (IUNIN,6666) NPRCSF
      NPRCSF=MIN0(NLIMPS,NPRCSF)
      IPRCSF=1
911   CONTINUE
      IF (IPRCSF.LE.NPRCSF) THEN
        READ (IUNIN,6666) (IPRSF(J),J=1,12)
        DO J=1,12
        IF (IPRSF(J).GT.0.AND.IPRSF(J).LE.NLIMPS)
     .     NLPRCS(IPRSF(J))=.TRUE.
        ENDDO
        IPRCSF=IPRCSF+12
        GOTO 911
      ENDIF
C  DATA FOR SPLITTING AND RUSSIAN ROULETTE
      READ (IUNIN,6666) MAXLEV,MAXRAD,MAXPOL,MAXTOR,MAXADD
      MXL=15
      IF (MAXLEV.GT.MXL)
     .    CALL EIRENE_MASPRM('MXL',3,MXL,'MAXLEV',6,MAXLEV,IERROR)
      IF (ABS(MAXRAD).GT.N1ST)
     .    CALL EIRENE_MASPRM('N1ST',4,N1ST,'MAXRAD',6,MAXRAD,IERROR)
      IF (MAXPOL.GT.N2ND)
     .    CALL EIRENE_MASPRM('N2ND',4,N2ND,'MAXPOL',6,MAXPOL,IERROR)
      IF (MAXTOR.GT.N3RD)
     .    CALL EIRENE_MASPRM('N3RD',4,N3RD,'MAXTOR',6,MAXTOR,IERROR)
      IF (MAXADD.GT.NLIM)
     .    CALL EIRENE_MASPRM('NLIM',4,NLIM,'MAXADD',6,MAXADD,IERROR)
      DO IN=1,MAXRAD
        READ (IUNIN,66665) ID,NSSPL(IN),PRMSPL(IN)
      ENDDO
      DO IN=1,MAXPOL
        READ (IUNIN,66665) ID,NSSPL(N1ST+IN),PRMSPL(N1ST+IN)
      ENDDO
      DO IN=1,MAXTOR
        READ (IUNIN,66665) ID,NSSPL(N1ST+N2ND+IN),PRMSPL(N1ST+N2ND+IN)
      ENDDO
      DO IN=1,MAXADD
        READ (IUNIN,66665) ID,NSSPL(N1ST+N2ND+N3RD+IN),
     .                        PRMSPL(N1ST+N2ND+N3RD+IN)
      ENDDO
C  DATA FOR BIAS SAMPLING
      READ (IUNIN,6664) WMINV,WMINS,WMINC,WMINL
      WMINV=MAX(WMINV,EPS60)
      WMINS=MAX(WMINS,EPS60)
      WMINC=MAX(WMINC,EPS60)
      READ (IUNIN,6664) SPLPAR
C  DATA FOR STANDARD DEVIATION
      READ (IUNIN,*)
      CALL EIRENE_LEER(1)
      WRITE (iunout,*) '       CARDS FOR STANDARD DEVIATION '
      READ (IUNIN,6666) NSIGVI,NSIGSI,NSIGCI,NSIGI_BGK,NSIGI_COP,
     .                  NSIGI_SPC
      WRITE (iunout,*) '       NSIGVI,NSIGSI,NSIGCI= ',
     .                         NSIGVI,NSIGSI,NSIGCI
      WRITE (iunout,*) '       NSIGI_BGK,NSIGI_COP = ',
     .                         NSIGI_BGK,NSIGI_COP
      WRITE (iunout,*) '       NSIGI_SPC           = ',NSIGI_SPC
      CALL EIRENE_LEER(1)
      DO 913 J=1,NSIGVI
        READ (IUNIN,6666) IGH(J),IIH(J)
913   CONTINUE
      DO 914 J=1,NSIGSI
        READ (IUNIN,6666) IGHW(J),IIHW(J)
914   CONTINUE
      DO 915 J=1,NSIGCI
        READ (IUNIN,6666) IGHC(1,J),IIHC(1,J),IGHC(2,J),IIHC(2,J)
915   CONTINUE
C
C   READ DATA FOR ADDITIONAL AND SURFACE AVERAGED TALLIES
      READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 10. DATA FOR ADDITIONAL TALLIES, COLLISION   ')
      CALL EIRENE_MASAGE
     .  ('        ESTIMATORS  AND ALGEBRAIC EXPRESSIONS    ')
C
1010  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1010
      READ (ZEILE,6666) NADVI,NCLVI,NALVI,NADSI,NALSI,NADSPC
      WRITE (iunout,*) '        NADVI,NCLVI,NALVI= ',
     .                     NADVI,NCLVI,NALVI
      WRITE (iunout,*) '        NADSI,NALSI,NADSPC= ',
     .                     NADSI,NALSI,NADSPC
      CALL EIRENE_LEER(1)
C
C
1000  CONTINUE
C
      READ (IUNIN,*)
      CALL
     .  EIRENE_MASAGE('*** 10A. DATA FOR ADDITIONAL TALLIES           ')
      ALLOCATE (TXTTLA(NADVI))
      ALLOCATE (TXTSCA(NADVI))
      ALLOCATE (TXTUTA(NADVI))
      DO 1020 J=1,NADVI
1021    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1021
        READ (ZEILE,6666) IADVE(J),IADVS(J),IADVT(J),IADRC(J)
        READ (IUNIN,'(A72)') TXTTLA(J)
        READ (IUNIN,'(2A24)') TXTSCA(J),TXTUTA(J)
1020  CONTINUE
      READ (IUNIN,*)
      CALL
     .  EIRENE_MASAGE('*** 10B. DATA FOR COLLISION ESTIMATORS         ')
      ALLOCATE (TXTTLC(NCLVI))
      ALLOCATE (TXTSCC(NCLVI))
      ALLOCATE (TXTUTC(NCLVI))
      DO 1030 J=1,NCLVI
1031    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1031
        READ (ZEILE,6666) ICLVE(J),ICLVS(J),ICLVT(J),ICLRC(J)
        READ (IUNIN,'(A72)') TXTTLC(J)
        READ (IUNIN,'(2A24)') TXTSCC(J),TXTUTC(J)
1030  CONTINUE
      READ (IUNIN,*)
      CALL EIRENE_MASAGE('*** 10C. DATA FOR ALGEBRAIC EXPRESSIONS     ')
      ALLOCATE (TXTTLR(NALVI))
      ALLOCATE (TXTSCR(NALVI))
      ALLOCATE (TXTUTR(NALVI))
      DO 1040 J=1,NALVI
1041    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1041
        READ (ZEILE,'(A72)') CHRTAL(J)
        READ (IUNIN,'(A72)') TXTTLR(J)
        READ (IUNIN,'(2A24)') TXTSCR(J),TXTUTR(J)
1040  CONTINUE
C
      READ (IUNIN,*)
      CALL
     .  EIRENE_MASAGE('*** 10D. DATA FOR ADDITIONAL SURFACE TALLIES   ')
      DO 1050 J=1,NADSI
1051    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1051
        READ (ZEILE,6666) IADSE(J),IADSS(J),IADST(J),IADSC(J)
        READ (IUNIN,'(A72)') TXTTLW(J,NTLSA)
        READ (IUNIN,'(2A24)') TXTSPW(J,NTLSA),TXTUNW(J,NTLSA)
1050  CONTINUE
C
      READ (IUNIN,*)
      CALL EIRENE_MASAGE('*** 10E. DATA FOR ALGEBRAIC SURFACE TALLIES ')
      DO 1060 J=1,NALSI
1061    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1061
        READ (ZEILE,'(A72)') CHRTLS(J)
        READ (IUNIN,'(A72)') TXTTLW(J,NTLSR)
        READ (IUNIN,'(2A24)') TXTSPW(J,NTLSR),TXTUNW(J,NTLSR)
1060  CONTINUE
C
      READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:3) == '** ') THEN
        CALL
     .  EIRENE_MASAGE('*** 10F. DATA FOR SPECTRA                   ')
        IF (NADSPC > 0) THEN
          ALLOCATE(ESTIML(NADSPC))
          IF (NSMSTRA > 0) ALLOCATE(SMESTL(NADSPC))
        ELSE
          ALLOCATE(ESTIML(1))
          NULLIFY (ESTIML(1)%PSPC)
        END IF
        DO J=1,NADSPC
          DO
            READ (IUNIN,'(A72)') ZEILE
            IF (ZEILE(1:1) .NE. '*') EXIT
          END DO
          READ (ZEILE,'(12I6)') ISPSRF, IPTYP, IPSP, ISPTYP, NSPS,
     .                          ISRFCLL, IDIREC
          READ (IUNIN,'(6E12.4)') SPCMN, SPCMX, SPC_SHIFT,
     .                             SPCPLT_X,SPCPLT_Y,SPCPLT_SAME
          SPCVX = 0._DP
          SPCVY = 0._DP
          SPCVZ = 0._DP
          IF (IDIREC /= 0) THEN
            READ (IUNIN,'(6E12.4)') SPCVX, SPCVY, SPCVZ
            VNORM = SQRT(SPCVX**2+SPCVY**2+SPCVZ**2)+EPS60
            SPCVX = SPCVX / VNORM
            SPCVY = SPCVY / VNORM
            SPCVZ = SPCVZ / VNORM
            IF (ISRFCLL == 0) THEN
              WRITE (IUNOUT,*) ' SPECTRUM NUMBER ',J
              WRITE (IUNOUT,*) ' DEFINITION OF LINE OF SIGHT FOR',
     .                         ' SURFACE SPECTRUM IS NOT FORSEEN '
              WRITE (IUNOUT,*) ' SPECIFICATION OF DIRECTION IS',
     .                         ' IGNORED '
              IDIREC = 0
            END IF
          END IF
          IF (ISPSRF > 0) THEN
            IF ((ISRFCLL == 0) .AND. (ISPSRF > NLIMI)) THEN
              WRITE (iunout,*)
     .          ' SURFACE INDEX FOR SPECTRUM OUT OF BOUNDS'
              WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
              WRITE (iunout,*) ' SURFACE NUMBER = ',ISPSRF
              IERROR = IERROR + 1
            END IF
            IF (((ISRFCLL == 1) .AND. (ISPSRF > NRTAL)) .OR.
     .          ((ISRFCLL == 2) .AND. (ISPSRF > NRAD))) THEN
              WRITE (iunout,*)
     .          ' CELL INDEX FOR SPECTRUM OUT OF BOUNDS'
              WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
              WRITE (iunout,*) ' CELL NUMBER = ',ISPSRF
              IERROR = IERROR + 1
            END IF
          ELSEIF (ISPSRF < 0) THEN
            ISPSRF = ABS(ISPSRF)
            IF (ISPSRF > NSTSI) THEN
              WRITE (iunout,*)
     .          ' SURFACE INDEX FOR SPECTRUM OUT OF BOUNDS'
              WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
              WRITE (iunout,*) ' SURFACE NUMBER = ',ISPSRF
              IERROR = IERROR + 1
            END IF
            ISPSRF = NLIM+ISPSRF
          ELSE
            WRITE (iunout,*) ' SURFACE INDEX 0 NOT FORSEEN '
            WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
            IERROR = IERROR + 1
          END IF
 
          IF ((IPTYP < 0) .OR. (IPTYP > 4)) THEN
            WRITE (iunout,*) ' PARTICLE TYPE ',IPTYP,' NOT FORSEEN '
            WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
            IERROR = IERROR + 1
          ELSE
            IF (((IPTYP == 0).AND.((IPSP < 0).OR.(IPSP > NPHOTI))) .OR.
     .          ((IPTYP == 1).AND.((IPSP < 0).OR.(IPSP > NATMI))) .OR.
     .          ((IPTYP == 2).AND.((IPSP < 0).OR.(IPSP > NMOLI))) .OR.
     .          ((IPTYP == 3).AND.((IPSP < 0).OR.(IPSP > NIONI))) .OR.
     .          ((IPTYP == 4).AND.((IPSP < 0).OR.(IPSP > NPLSI)))) THEN
              WRITE (iunout,*) ' PARTICLE SPECIES INDEX OUT OF BOUNDS '
              WRITE (iunout,*) ' SPECTRUM NUMBER = ',J
              WRITE (iunout,*) ' SPECIES NUMBER = ',IPSP
              IERROR = IERROR + 1
            END IF
          END IF
 
          IF ((ISRFCLL == 0) .AND. (ISPTYP > 2)) THEN
            WRITE (IUNOUT,*) ' WRONG TYPE OF SPECTRUM SPECIFIED '
            WRITE (IUNOUT,*) ' SPECTRUM NUMBER = ',J
            WRITE (IUNOUT,*) ' SPECTRUM TYPE = ',ISPTYP
          END IF
 
          ALLOCATE(ESPEC)
          ESPEC%ISPCSRF = ISPSRF
          ESPEC%IPRTYP = IPTYP
          ESPEC%IPRSP = IPSP
          ESPEC%ISPCTYP = ISPTYP
          ESPEC%NSPC = NSPS
          ESPEC%IMETSP = 0
          ESPEC%ISRFCLL = ISRFCLL
          ESPEC%IDIREC = IDIREC
          ESPEC%LOG = .FALSE.
          ESPEC%SPCMIN=SPCMN
          ESPEC%SPCMAX=SPCMX
          ESPEC%ESP_00=SPC_SHIFT
          ESPEC%SPC_XPLT=SPCPLT_X
          ESPEC%SPC_YPLT=SPCPLT_Y
          ESPEC%SPC_SAME=SPCPLT_SAME
          ESPEC%SPCVX=SPCVX
          ESPEC%SPCVY=SPCVY
          ESPEC%SPCVZ=SPCVZ
          ESPEC%ESP_MIN=1.E30
          ESPEC%ESP_MAX=-1.E30
          ESPEC%SPCDEL=(SPCMX-SPCMN)/REAL(NSPS,DP)
          ESPEC%SPCDELI=1._DP/ESPEC%SPCDEL
          ALLOCATE(ESPEC%SPC(0:NSPS+1))
!          IF (NSIGI_SPC > 0) THEN
            ALLOCATE(ESPEC%SDV(0:NSPS+1))
            ALLOCATE(ESPEC%SGM(0:NSPS+1))
!          END IF
          ESPEC%SPC(0:NSPS+1) = 0._DP
          IF (NSMSTRA > 0) THEN
            ALLOCATE(SSPEC)
            ALLOCATE(SSPEC%SPC(0:NSPS+1))
!            IF (NSIGI_SPC > 0) THEN
              ALLOCATE(SSPEC%SDV(0:NSPS+1))
              ALLOCATE(SSPEC%SGM(0:NSPS+1))
!            END IF
            SSPEC = ESPEC
            SMESTL(J)%PSPC => SSPEC
          END IF
          ESTIML(J)%PSPC => ESPEC
        END DO
        IREAD=0
      ELSE
        IF (.NOT.ALLOCATED(ESTIML)) THEN
          ALLOCATE(ESTIML(1))
          NULLIFY (ESTIML(1)%PSPC)
        END IF
      END IF
C
C   READ DATA FOR NUMERICAL AND GRAPHICAL OUTPUT 1100--1199
C
1100  CONTINUE
C
      IF (IREAD == 0) READ (IUNIN,*)
      CALL EIRENE_LEER(1)
      CALL EIRENE_MASAGE
     .  ('*** 11. DATA FOR NUMERICAL AND GRAPHICAL OUTPUT  ')
c
c  search for input block 11a
1110  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1110
      READ (ZEILE,6665) TRCPLT,TRCHST,TRCNAL,TRCMOD,TRCSIG,
     .                  TRCGRD,TRCSUR,TRCREF,TRCFLE,TRCAMD,
     .                  TRCINT,TRCLST,TRCSOU,TRCREC,TRCTIM,
     .                  TRCBLA,TRCBLM,TRCBLI,TRCBLP,TRCBLE,
     .                  TRCBLPH,TRCTAL
      READ (IUNIN,6665) (TRCSRC(J),J=0,NSTRA)
C
      READ (IUNIN,6666) NVOLPR, NSPCPR
      NVOLPR=MIN(NVOLPR,NSPEZV_DIM)
      WRITE (iunout,*) '        NVOLPR= ',NVOLPR
      CALL EIRENE_LEER(1)
      DO 1120 J=1,NVOLPR
        READ (IUNIN,6666) NTLV,NFLGV,NSPZV1,NSPZV2,NTLVF
        IF (NTLV.LT.-NTALI.OR.NTLV.GT.NTALV) GOTO 990
        IF ((NTLVF.NE.0).AND.(NTLVF.LT.70)) GOTO 995
        NPRTLV(J)  =NTLV
        NFLAGV(J)  =NFLGV
        NSPEZV(J,1)=NSPZV1
        NSPEZV(J,2)=NSPZV2
        NTLVFL(J)  =NTLVF
1120  CONTINUE
C
      READ (IUNIN,6666) NSURPR
      IF(NSURPR > NLIMPS) THEN
         WRITE (iunout,*) 'NSURPR > NLIMPS, EXIT.'
         WRITE (iunout,*) ' NSURPR, NLIMPS ', NSURPR, NLIMPS
         CALL EIRENE_EXIT_OWN(1)
      ENDIF
      NSURPR=MIN(NSURPR,NLIMPS)
      WRITE (iunout,*) '        NSURPR= ',NSURPR
      CALL EIRENE_LEER(1)
      DO 1130 J=1,NSURPR
        READ (IUNIN,6666) NSRF,NTLS,NFLGS,NSPZS1,NSPZS2,NTLSF
        IF (NSRF.LT.0) NSRF=NLIM+IABS(NSRF)
        IF (NSRF.EQ.0.AND.NLIM+NSTSI.LT.NLIMPS) NSRF=NLIM+NSTSI+1
        IF (NSRF.LE.0.OR.NSRF.GT.NLIMPS) GOTO 991
        NPRSRF(J)=NSRF
        NPRTLS(J)=NTLS
        NFLAGS(J)=NFLGS
        NSPEZS(J,1)=NSPZS1
        NSPEZS(J,2)=NSPZS2
        NTLSFL(J)=NTLSF
1130  CONTINUE
 
c  overrule default switching on/off of volume averaged tallies
 
      READ (IUNIN,'(A72)') ZEILE
      CALL EIRENE_UPPERCASE(ZEILE)
      IREAD=1
      IF ((ZEILE(1:1) .NE.'*') .AND. (SCAN(ZEILE,'FT') == 0)) THEN
 
c  there are ntlvout volume tallies to be dealt with
c  and ntlsout surface tallies
 
        IREAD=0
        READ (ZEILE,6666) NTLVOUT
        ITLVOUT=0
        DO WHILE ((NTLVOUT > 0) .AND. (ITLVOUT < NTLVOUT))
          READ (IUNIN,6666) (NUMTAL(J),J=1,12)
          DO J=1,12
            IF ((NUMTAL(J) /= 0) .AND. (ABS(NUMTAL(J)) <= NTALV)) THEN
              IF (NUMTAL(J) < 0) THEN
                LMISTALV(ABS(NUMTAL(J))) = .TRUE.  ! SWITCHED OFF
              ELSE
                LMISTALV(NUMTAL(J)) = .FALSE.      ! SWITCHED ON
              END IF
            END IF
          END DO
          ITLVOUT=ITLVOUT+12
        END DO
 
c  overrule default switching on/off of surface averaged tallies
 
        READ (IUNIN,6666) NTLSOUT
        ITLSOUT=0
        DO WHILE ((NTLSOUT > 0) .AND. (ITLSOUT < NTLSOUT))
          READ (IUNIN,6666) (NUMTAL(J),J=1,12)
          DO J=1,12
            IF ((NUMTAL(J) /= 0) .AND. (ABS(NUMTAL(J)) <= NTALS)) THEN
              IF (NUMTAL(J) < 0) THEN
                LMISTALS(ABS(NUMTAL(J))) = .TRUE.  ! SWITCHED OFF
              ELSE
                LMISTALS(NUMTAL(J)) = .FALSE.      ! SWITCHED ON
              END IF
            END IF
          END DO
          ITLSOUT=ITLSOUT+12
        END DO
      END IF
 
 
C  search for input block 11b
 
1131  IF (IREAD == 0) READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:1) .EQ. '*') GOTO 1131
C  2D GEOMETRY PLOT
      READ (ZEILE,6665) PL1ST,PL2ND,PL3RD,PLADD,PLHST,
     .                  PLCUT(1),PLCUT(2),PLCUT(3),PLBOX,PLSTOR,
     .                  PLNUMV,PLNUMS,PLARR,LRPSCUT
      READ (IUNIN,6666) NPLINR,NPLOTR,NPLDLR,NPLINP,NPLOTP,NPLDLP,
     .                  NPLINT,NPLOTT,NPLDLT
C  3D GEOMETRY PLOT
      DO 1140 J=1,5
        READ (IUNIN,6662) PL3A(J),TEXTLA(J),IPLTA(J),
     .                (IPLAA(J,I),IPLEA(J,I),I=1,IPLTA(J))
1140   CONTINUE
      DO 1141 J=1,3
        READ (IUNIN,6662) PL3S(J),TEXTLS(J),IPLTS(J),
     .                (IPLAS(J,I),IPLES(J,I),I=1,IPLTS(J))
1141  CONTINUE
C
      READ (IUNIN,6664) CH2MX,CH2MY,      CH2X0,CH2Y0,CH2Z0
      READ (IUNIN,6664) CH3MX,CH3MY,CH3MZ,CH3X0,CH3Y0,CH3Z0
      READ (IUNIN,6664) ANGLE1,ANGLE2,ANGLE3
C
C  PARTICLE HISTORY PLOTS IN 2D OR 3D GEOMETRY PLOTS
      READ (IUNIN,6666) I1TRC,I2TRC,(ISYPLT(J),J=1,8),ILINIE
C
 
c  search for input block 11c
 
1151  READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:1) .EQ. '*') GOTO 1151
C  DATA FOR PLOTS OF VOLUME AVERAGED TALLIES
      READ (ZEILE,6666) NVOLPL
      WRITE (iunout,*) '        NVOLPL= ',NVOLPL
      CALL EIRENE_LEER(1)
C
      IF (NVOLPL.GT.NPTAL)
     .  CALL EIRENE_MASPRM('NPTAL',5,NPTAL,'NVOLPT',6,NVOLPL,IERROR)
C
      IF (NVOLPL.LE.0) GOTO 1175
      READ (IUNIN,6665) (PLTSRC(J),J=0,NSTRA)
      IF (LRPSCUT) THEN
        READ (IUNIN,6664) CUTPLANE(1:4)
!  TEST IF CUTPLANE IS AXIS-PARALLEL
        IF ((SUM(ABS(CUTPLANE(2:4)))-1._DP > EPS10) .OR.
     .      (CUTPLANE(2)*CUTPLANE(3) > 0._DP) .OR.
     .      (CUTPLANE(2)*CUTPLANE(4) > 0._DP) .OR.
     .      (CUTPLANE(3)*CUTPLANE(4) > 0._DP)) THEN
          WRITE (iunout,*) ' PLANE IS NOT PARALLEL TO ONE AXIS '
          WRITE (iunout,*) ' CUTTING OF TETRAHEDRONS ABANDONNED '
          WRITE (iunout,*) ' LRPSCUT SET TO .FALSE. '
          LRPSCUT = .FALSE.
        END IF
      END IF
      IPLANE=1
      LRAPS3D=.FALSE.
      LR3DCON=.FALSE.
      RAPSDEL=-HUGE(1._DP)
      DO 1150 J=1,NVOLPL
1152    READ (IUNIN,'(A72)') ZEILE
        IF (ZEILE(1:1) .EQ. '*') GOTO 1152
        READ (ZEILE,6666) NSP
        IF (NSP.GT.NPLT)
     .    CALL EIRENE_MASPRM('NPLT',4,NPLT,'NSP',3,NSP,IERROR)
        NSPTAL(J)=NSP
        READ (IUNIN,6665) PLTL2D(J),PLTL3D(J),PLTLLG(J),PLTLER(J)
        READ (IUNIN,6664) TALZMI(J),TALZMA(J),TALXMI(J),TALXMA(J),
     .                    TALYMI(J),TALYMA(J)
        IF (PLTL2D(J)) THEN
          READ (IUNIN,6665) LHIST2(J),LSMOT2(J)
          DO 1160 I=1,NSPTAL(J)
            READ (IUNIN,6666) ISPTAL(J,I),NTL,
     .                        NPLIN2(J,I),NPLOT2(J,I),NPLDL2(J,I)
            IF (NTL.LT.-NTALI.OR.NTL.GT.NTALV.OR.NTL.EQ.0) GOTO 990
            NPTALI(J,I)=NTL
1160      CONTINUE
        ENDIF
        IF (PLTL3D(J)) THEN
          READ (IUNIN,6665) LHIST3(J),LCNTR3(J),LSMOT3(J),
     .                      LRAPS3(J),LVECT3(J),LRPVC3(J),
     .                      LRPS3D,LRPSCN
          READ (IUNIN,6665) LPRAD3(J),LPPOL3(J),LPTOR3(J)
          DO 1161 I=1,NSPTAL(J)
            READ (IUNIN,6666) ISPTAL(J,I),NTL,IPROJ3(J,I),
     .                        NPLI13(J,I),NPLO13(J,I),
     .                        NPLI23(J,I),NPLO23(J,I),IPLN
            IF (NTL.LT.-NTALI.OR.NTL.GT.NTALV.OR.NTL.EQ.0) GOTO 990
            NPTALI(J,I)=NTL
1161      CONTINUE
          READ (IUNIN,6664) TALW1(J),TALW2(J),FCABS1(J),FCABS2(J),
     .                      RPSDL
          IF (FCABS1(J).LE.0.0D0) FCABS1(J)=1.0D0
          IF (FCABS2(J).LE.0.0D0) FCABS2(J)=1.0D0
          LRAPS3D=LRAPS3D.OR.LRPS3D
          LR3DCON=LR3DCON.OR.LRPSCN
          IPLANE=MAX(IPLANE,IPLN)
          RAPSDEL=MAX(RAPSDEL,RPSDL)
        ENDIF
1150  CONTINUE
      IF (NLTRA) RAPSDEL=RAPSDEL*DEGRAD
C
C  SKIP INPUT LINES, UNTIL INPUT BLOCK 12 STARTS
1175  READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:3) .EQ. '***') GOTO 1205
      GOTO 1175
C
C  READ DATA FOR DIAGNOSTIC MODULE  1200--1299
C
1200  CONTINUE
C
1205  CALL EIRENE_MASAGE
     .  ('*** 12. DATA FOR DIAGNOSTIC MODULE              ')
1210  READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:1) .EQ. '*') GOTO 1210
      READ (ZEILE,6666) NCHORI,NCHENI
      NCHOR = NCHORI
      NCHEN = NCHENI
      WRITE (iunout,*) '        NCHORI,NCHENI= ',NCHORI,NCHENI
      CALL EIRENE_LEER(1)
      IF (IABS(NCHENI).GT.NCHEN)
     .    CALL
     .  EIRENE_MASPRM('NCHEN',5,NCHEN,'IABS(NCHENI)',12,IABS(NCHENI),
     .                 IERROR)
      IF (NCHORI.LE.0) GOTO 1230
      CALL EIRENE_ALLOC_COMSIG
      CALL EIRENE_INIT_COMSIG
      DO 1220 ICHORI=1,NCHORI
        READ (IUNIN,'(A72)') TXTSIG(ICHORI)
        READ (IUNIN,6666) NCHTAL(ICHORI),NSPSCL(ICHORI),NSPNEW(ICHORI),
     .                    ISTCHR
        READ (IUNIN,6666) NSPSTR(ICHORI),NSPSPZ(ICHORI),
     .                    NSPINI(ICHORI),NSPEND(ICHORI),
     .                    NSPBLC(ICHORI),NSPADD(ICHORI)
        READ (IUNIN,6664) EMIN1(ICHORI),EMAX1(ICHORI),ESHIFT(ICHORI)
        READ (IUNIN,66664) IPIVOT(ICHORI),
     .                     XPIVOT(ICHORI),YPIVOT(ICHORI),ZPIVOT(ICHORI)
        READ (IUNIN,66664) ICHORD(ICHORI),
     .                     XCHORD(ICHORI),YCHORD(ICHORI),ZCHORD(ICHORI)
        NLSTCHR(ICHORI) = ISTCHR > 0
1220  CONTINUE
      READ (IUNIN,6665) PLCHOR,PLSPEC
1230  CONTINUE
C  SKIP READING REST OF THIS BLOCK
      READ (IUNIN,'(A72)') ZEILE
      IREAD=0
      IF (ZEILE(1:3).NE.'***') GOTO 1230
      IREAD=1
C
C  READ DATA FOR NONLINEAR MODE  1300--1399
C
1300  CONTINUE
C
      IF (IREAD.EQ.0) READ (IUNIN,*)
      IREAD=0
      CALL EIRENE_MASAGE
     .  ('*** 13. DATA FOR ITERATIVE AND TIME DEP. OPTION ')
C
      READ (IUNIN,6666) NPRNLI
      WRITE (iunout,*) '        NPRNLI= ',NPRNLI
      CALL EIRENE_LEER(1)
      IF (NLERG.AND.NPRNLI.LE.0) THEN
C  NO TIME HORIZON DEFINED, DESPITE NLERG=.TRUE.
C  THEREFORE: SET A DEFAULT TIME HORIZON HERE
        NPRNLI=100
      ENDIF
      IF (NPRNLI.LE.0) GOTO 1350
      READ (IUNIN,'(A72)') ZEILE
      IREAD=1
      IF (ZEILE(1:1).EQ.'*') THEN
C  DATA FOR DEFAULT TIME HORIZON
        NTIME0=0
        NTIME=1
        DTIMV=1.D0
        TIME0=0.D0
        NPTST=0
        NTMSTP=1
        NSNVI=0
        GOTO 1350
      ENDIF
      READ (ZEILE,6666) NPTST,NTMSTP
      IREAD=0
      READ (IUNIN,6664) DTIMV,TIME0
C   READ DATA FOR SNAPSHOT TALLIES
      READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 13A. DATA FOR SNAPSHOT TALLIES           ')
      READ (IUNIN,6666) NSNVI
      WRITE (iunout,*) '        NSNVI= ',NSNVI
      CALL EIRENE_LEER(1)
      ALLOCATE (TXTTLT(NSNVI))
      ALLOCATE (TXTSCT(NSNVI))
      ALLOCATE (TXTUTT(NSNVI))
      DO 1320 J=1,NSNVI
1321    READ (IUNIN,'(A72)') ZEILE
        IREAD=1
        IF (ZEILE(1:1) .EQ. '*') GOTO 1321
        READ (ZEILE,6666) ISNVE(J),ISNVS(J),ISNVT(J),ISNRC(J)
        IREAD=0
!        READ (IUNIN,'(A72)') TXTTAL(J,NTALT)
!        READ (IUNIN,'(2A24)') TXTSPC(J,NTALT),TXTUNT(J,NTALT)
        READ (IUNIN,'(A72)') TXTTLT(J)
        READ (IUNIN,'(2A24)') TXTSCT(J),TXTUTT(J)
1320  CONTINUE
C
      IF (NTIME.LE.0) THEN
        WRITE (iunout,*) 'ERROR IN INPUT: TIME DEP. MODE BUT NTIME.LE.0'
        CALL EIRENE_EXIT_OWN(1)
      ENDIF
1350  CONTINUE
C  SKIP READING REST OF THIS BLOCK
      IF (IREAD.EQ.0) READ (IUNIN,'(A72)') ZEILE
      IF (ZEILE(1:3).NE.'***') GOTO 1350
      IREAD=1
C
      IF (NTIME.GE.1) THEN
C  DEFINE ONE MORE SURFACE
        NSTSI=NSTSI+1
C  CHECK STORAGE
        CALL EIRENE_LEER(1)
        IF (NSTSI.GT.NSTS) THEN
          CALL EIRENE_MASPRM('NSTS',4,NSTS,'NSTSI',5,NSTSI,IERROR)
          CALL EIRENE_EXIT_OWN(1)
        ENDIF
C
C  SET DEFAULTS FOR "TIME HORIZON"
C
        TXTSFL(NLIM+NSTSI)='"TIME HORIZON"                           '
        ILIIN(NLIM+NSTSI)=2
C
C
cdr     IF (NFILEJ.EQ.2.OR.NFILEJ.EQ.3) THEN
cdr functioniert noch nicht, falls mehrere timesteps, davon nur
cdr der erste: initialisierung, die anderen: fortsetzung.
cdr denn dann wird bei der fortsetzung das stratum nicht gemacht.
cdr wg. goto 4000. angefangen: "mkcens" (make stratum for census array)
C
C  DEFINE ONE MORE STRATUM
          NSTRAI=NSTRAI+1
C  CHECK STORAGE
          IF (NSTRAI.GT.NSTRA) THEN
            CALL EIRENE_MASPRM('NSTRA',5,NSTRA,'NSTRAI',6,NSTRAI,IERROR)
            CALL EIRENE_EXIT_OWN(1)
          ENDIF
C
C  SET DEFAULTS FOR SOURCE DUE TO INITIAL CONDITION, VALID ONLY FOR
C  FIRST TIMESTEP. MODIFIED FOR LATER TIMESTEPS IN SUBR. TMSTEP
C
          TXTSOU(NSTRAI)='SOURCE DUE TO INITIAL CONDITION          '
C  SOURCE DISTRIBUTION SAMPLED FROM CENSUS ARRAYS RPARTC,IPARTC
          NLCNS(NSTRAI)=.TRUE.
          NLPNT(NSTRAI)=.FALSE.
          NLLNE(NSTRAI)=.FALSE.
          NLSRF(NSTRAI)=.FALSE.
          NLVOL(NSTRAI)=.FALSE.
C  DO NOT CALL IF2COP(NSTRAI)
          INDSRC(NSTRAI)=-1
C
          NLAVRP(NSTRAI)=.FALSE.
          NLAVRT(NSTRAI)=.FALSE.
          NLSYMP(NSTRAI)=.FALSE.
          NLSYMT(NSTRAI)=.FALSE.
          NPTS(NSTRAI)=0
          NINITL(NSTRAI)=2000*NINITL(NSTRAI-1)+1
          NEMODS(NSTRAI)=1
          NAMODS(NSTRAI)=1
          FLUX(NSTRAI)=0.
          NLATM(NSTRAI)=.FALSE.
          NLMOL(NSTRAI)=.FALSE.
          NLION(NSTRAI)=.FALSE.
          NLPLS(NSTRAI)=.FALSE.
          NSPEZ(NSTRAI)=0
          NSRFSI(NSTRAI)=0
C
          SORENI(NSTRAI)=0.
          SORENE(NSTRAI)=0.
          SORVDX(NSTRAI)=0.
          SORVDY(NSTRAI)=0.
          SORVDZ(NSTRAI)=0.
          SORCOS(NSTRAI)=0.
          SORMAX(NSTRAI)=0.
          SORCTX(NSTRAI)=0.
          SORCTY(NSTRAI)=0.
          SORCTZ(NSTRAI)=0.
C
C  NEW TIMESTEP
C
          IF (DTIMVN.LE.0.D0) THEN
            DTIMVN=DTIMV
C         ELSE
C           DTIMVN=DTIMVN
          ENDIF
C
C  OLD TIMESTEP
C
C  READ INITIAL POPULATION FROM PREVIOUS RUN, OVERWRITE DEFAULTS
C
        IPRNL=0
        IF (NFILEJ.EQ.2.OR.NFILEJ.EQ.3) THEN
          CALL EIRENE_RSNAP
          DTIMVO=DTIMV
C
          WRITE (iunout,*) 'INITIAL POPULATION FOR FIRST TIMESTEP'
          WRITE (iunout,*) 'READ FROM FILE FT 15 '
          WRITE (iunout,*) 'PARTICLES AND FLUX STORED FOR INITIAL '
          WRITE (iunout,*) 'DISTRIBUTION IN PREVIOUS RUN '
          CALL EIRENE_MASJ1('IPRNL   ',IPRNL)
          CALL EIRENE_MASR1('FLUX    ',FLUX(NSTRAI))
C
          IF (DTIMVN.NE.DTIMVO) THEN
            FLUX(NSTRAI)=FLUX(NSTRAI)*DTIMVO/DTIMVN
C
            WRITE (iunout,*) 'FLUX IS RESCALED BY DTIMV_OLD/DTIMV_NEW '
            CALL EIRENE_MASR1('FLUX    ',FLUX(NSTRAI))
            CALL EIRENE_LEER(1)
          ENDIF
C
          CALL EIRENE_LEER(2)
          IF (TIME0.GT.0.) THEN
            DO I=1,IPRNL
              RPARTC(10,I)=TIME0
            ENDDO
            WRITE (iunout,*) 'PARTICLE CLOCK RESET TO TIME0'
            WRITE (iunout,*) 'FIRST TIMESTEP RUNS FROM TIM1 TO TIM2:  '
            CALL EIRENE_MASR2('TIM1, TIM2      ',TIME0,TIME0+DTIMV)
            CALL EIRENE_LEER(2)
          ENDIF
C
        ENDIF
C
        DTIMV=DTIMVN
C
        IF (NPTST.EQ.0) THEN
          NPTS(NSTRAI)=IPRNL
          NLMOVIE=.FALSE.
        ELSEIF (NPTST.GT.0) THEN
          NPTS(NSTRAI)=NPTST
          NLMOVIE=.FALSE.
        ELSEIF (NPTST.LT.0) THEN
          NPTS(NSTRAI)=IPRNL
          NLMOVIE=.TRUE.
        ENDIF
C
        IF (NPTS(NSTRAI).GT.0.AND.FLUX(NSTRAI).GT.0) THEN
          NSRFSI(NSTRAI)=1
          SORWGT(1,NSTRAI)=1.D0
        ENDIF
C
      ENDIF
1399  CONTINUE
C
1500  IF (IERROR.GT.0) THEN
        WRITE (iunout,*) IERROR,' INPUT OR PARAMETER ERRORS DETECTED '
        WRITE (iunout,*)
     .    ' SEE THE ERRORMESSAGES LISTED ABOVE AND CORRECT '
        WRITE (iunout,*) ' THE ERRORS BEFORE RE-EXECUTION '
        CALL EIRENE_EXIT_OWN(1)
      ENDIF
C
      CALL EIRENE_PAGE
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time nach einlesen ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
6662  FORMAT (L1,1X,A24,1X,I1,1X,4(2I3,1X))
6664  FORMAT (6E12.4)
6665  FORMAT (12(5L1,1X))
6666  FORMAT (12I6)
66661 FORMAT (I3,1X,A6,1X,A4,A9,A3,2I3,3E12.4)
66662 FORMAT (2E12.4,10I6)
66664 FORMAT (I6,6X,5E12.4)
66665 FORMAT (2I6,4E12.4)
66666 FORMAT (I2,1X,A8,12(I3),1X,A10,1X,I2)
C
C   MODIFICATION OF INPUT DUE TO EITHER INCONSISTENCIES OR DUE
C   TO COUPLED NEUTRAL-PLASMA (OR NEUTRAL-NEUTRAL) CALCULATIONS
C   SOME FURTHER CONSTANTS ARE SET.      STATEM. NO. 2000 --> 4000
C
C
C   GEOMETRY, GRIDS
C
      IF (NLSLB) LEVGEO=1
      IF (NLCRC) LEVGEO=2
      IF (NLELL) LEVGEO=2
      IF (NLTRI) LEVGEO=2
      IF (NLPLG) LEVGEO=3
      IF (NLFEM) LEVGEO=4
      IF (NLTET) LEVGEO=5
      IF (NLGEN) LEVGEO=10
      IF (NLFEM) THEN
        NLPOL=.FALSE.
!pbjs        NLTOR=.FALSE.
        IF (INDPRO(1).NE.3.AND.INDPRO(1).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(1),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' FINITE ELEMENT MESH '
          WRITE (iunout,*)
     .      ' INDPRO(1) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(1)=3
        ENDIF
        IF (INDPRO(2).NE.3.AND.INDPRO(2).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(2),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' FINITE ELEMENT MESH '
          WRITE (iunout,*)
     .      ' INDPRO(2) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(2)=3
        ENDIF
        IF (INDPRO(3).NE.3.AND.INDPRO(3).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(3),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' FINITE ELEMENT MESH '
          WRITE (iunout,*)
     .      ' INDPRO(3) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(3)=3
        ENDIF
        IF (INDPRO(4).NE.3.AND.INDPRO(4).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(4),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' FINITE ELEMENT MESH '
          WRITE (iunout,*)
     .      ' INDPRO(4) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(4)=3
        ENDIF
      ENDIF
      IF (NLTET) THEN
        IF (INDPRO(1).NE.3.AND.INDPRO(1).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(1),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' TETRAHEDRON MESH '
          WRITE (iunout,*)
     .      ' INDPRO(1) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(1)=3
        ENDIF
        IF (INDPRO(2).NE.3.AND.INDPRO(2).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(2),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' TETRAHEDRON MESH '
          WRITE (iunout,*)
     .      ' INDPRO(2) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(2)=3
        ENDIF
        IF (INDPRO(3).NE.3.AND.INDPRO(3).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(3),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' TETRAHEDRON MESH '
          WRITE (iunout,*)
     .      ' INDPRO(3) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(3)=3
        ENDIF
        IF (INDPRO(4).NE.3.AND.INDPRO(4).LT.5) THEN
          WRITE (iunout,*) ' PROFILE OPTION ',INDPRO(4),
     .                     ' NOT FORESEEN FOR'
          WRITE (iunout,*) ' TETRAHEDRON MESH '
          WRITE (iunout,*)
     .      ' INDPRO(4) IS SET TO 3 <=> CONSTANT PROFILE '
          INDPRO(4)=3
        ENDIF
      ENDIF
C
      NP2ND=MIN0(N2ND,NP2ND)
      NT3RD=MIN0(N3RD,NT3RD)
      IF (NLTOR.AND.NLTRA) NTTRA=NT3RD
      NR1P2=0
      IF (NLPOL.OR.NLTOR) NR1P2=NR1ST
      NP2T3=0
      IF (NLTOR) NP2T3=NP2ND
      IF (.NOT.NLADD) NRADD=0
      IF (.NOT.NLMLT) NBMLT=1
 
      DO IN=1,NRAD
        NCLTAL(IN)=IN
      END DO
      NR1TAL = NR1ST
      NP2TAL = NP2ND
      NT3TAL = NT3RD
C
C  SOURCE PARAMETERS AND (REFLECTING) BOUNDARY CONDITIONS,
C  ON ADDITIONAL AND NON DEFAULT STANDARD SURFACES
C
      DO J=0,NLIMPS
C
        RINTEG(J)=RINTEG(1)
        EINTEG(J)=EINTEG(1)
        AINTEG(J)=AINTEG(1)
        DO ISPZ=1,NSPZ
          ISRS(ISPZ,J)=ISRS(1,J)
          ISRC(ISPZ,J)=ISRC(1,J)
          TRANSP(ISPZ,1,J)=TRANSP(1,1,J)
          TRANSP(ISPZ,2,J)=TRANSP(1,2,J)
          RECYCF(ISPZ,J)=RECYCF(1,J)
          RECYCT(ISPZ,J)=RECYCT(1,J)
          RECPRM(ISPZ,J)=RECPRM(1,J)
          EXPPL(ISPZ,J)=EXPPL(1,J)
          EXPEL(ISPZ,J)=EXPEL(1,J)
          EXPIL(ISPZ,J)=EXPIL(1,J)
          RECYCS(ISPZ,J)=RECYCS(1,J)
          RECYCC(ISPZ,J)=RECYCC(1,J)
          SPTPRM(ISPZ,J)=SPTPRM(1,J)
        end do
      end do
 
      DO WHILE (ASSOCIATED(REFLIST))
        NULLIFY(SURFCUR2)
        SURFCUR => SURFLIST
        DO WHILE (ASSOCIATED(SURFCUR))
          IF (SURFCUR%MODNAME == REFLIST%REFNAME) THEN
            NLJ = SURFCUR%NOSURF
            ILREF(NLJ) = REFLIST%JLREF
            ILSPT(NLJ) = REFLIST%JLSPT
            ISRS(:,NLJ) = REFLIST%JSRS
            ISRC(:,NLJ) = REFLIST%JSRC
            ZNML(NLJ) = REFLIST%ZNMLR
            EWALL(NLJ) = REFLIST%EWALLR
            EWBIN(NLJ) = REFLIST%EWBINR
            TRANSP(:,1,NLJ) = REFLIST%TRANSPR(:,1)
            TRANSP(:,2,NLJ) = REFLIST%TRANSPR(:,2)
            FSHEAT(NLJ) = REFLIST%FSHEATR
            RECYCF(:,NLJ) = REFLIST%RCYCFR
            RECYCT(:,NLJ) = REFLIST%RCYCTR
            RECPRM(:,NLJ) = REFLIST%RCPRMR
            EXPPL(:,NLJ) = REFLIST%EXPPLR
            EXPEL(:,NLJ) = REFLIST%EXPELR
            EXPIL(:,NLJ) = REFLIST%EXPILR
            RECYCS(:,NLJ) = REFLIST%RCYCSR
            RECYCC(:,NLJ) = REFLIST%RCYCCR
            SPTPRM(:,NLJ) = REFLIST%STPRMR
            IF (.NOT.ASSOCIATED(SURFCUR2)) THEN
              SURFLIST => SURFCUR%NEXT
              DEALLOCATE(SURFCUR)
              SURFCUR => SURFLIST
            ELSE
              SURFCUR2%NEXT => SURFCUR%NEXT
              DEALLOCATE(SURFCUR)
              SURFCUR => SURFCUR2%NEXT
            END IF
          ELSE
            SURFCUR2 => SURFCUR
            SURFCUR => SURFCUR%NEXT
          END IF
        END DO
        REFCUR => REFLIST
        REFLIST => REFLIST%NEXT
        DEALLOCATE (REFCUR%JSRS)
        DEALLOCATE (REFCUR%JSRC)
        DEALLOCATE (REFCUR%TRANSPR)
        DEALLOCATE (REFCUR%RCYCFR)
        DEALLOCATE (REFCUR%RCYCTR)
        DEALLOCATE (REFCUR%RCPRMR)
        DEALLOCATE (REFCUR%EXPPLR)
        DEALLOCATE (REFCUR%EXPELR)
        DEALLOCATE (REFCUR%EXPILR)
        DEALLOCATE (REFCUR%RCYCSR)
        DEALLOCATE (REFCUR%RCYCCR)
        DEALLOCATE (REFCUR%STPRMR)
        DEALLOCATE (REFCUR)
      ENDDO
 
      IF (ASSOCIATED(SURFLIST)) THEN
        WRITE (iunout,*)
     .    ' SURFACE DATA HAVE NOT BEEN DEFINED FOR MODEL:'
        DO WHILE (ASSOCIATED(SURFLIST))
          WRITE (iunout,*) SURFLIST%MODNAME
          SURFCUR => SURFLIST
          SURFLIST => SURFLIST%NEXT
          DEALLOCATE(SURFCUR)
        END DO
        WRITE (iunout,*) ' EXECUTION IS STOPPED '
        CALL EIRENE_EXIT_OWN(1)
      END IF
 
      DO 2000 J=0,NLIMPS
        IF (ILCOL(J).LT.0) IGFIL(J)=1
        ILCOL(J)=MAX0(1,IABS(ILCOL(J)))
        IF (ILIIN(J).LE.0.OR.ILIIN(J).GE.3) ILSPT(J)=0
        IF (ILIIN(J).LE.0) TRANSP(:,1,J)=0.D0
        IF (ILIIN(J).LE.0) TRANSP(:,2,J)=0.D0
        ISPUT(1,J)=EIRENE_IDEZ(ILSPT(J),1,2)
        ISPUT(2,J)=EIRENE_IDEZ(ILSPT(J),2,2)
        IF (ISPUT(1,J).NE.0.AND.ALL(RECYCS(:,J).EQ.0._DP)) THEN
          JJ=J
          IF (JJ.GT.NLIMI) JJ=-(J-NLIMI)
          WRITE (IUNOUT,*) 'WARNING: SURFACE NO. ',JJ,
     .                     'HAS A PHYSICAL SPUTTER MODEL, BUT ',
     .                     'SPUTTER YIELD IS SCALED TO ZERO (RECYCS=0)'
        ENDIF
        IF (ISPUT(2,J).NE.0.AND.ALL(RECYCC(:,J).EQ.0._DP)) THEN
          JJ=J
          IF (JJ.GT.NLIMI) JJ=-(J-NLIMI)
          WRITE (IUNOUT,*) 'WARNING: SURFACE NO. ',JJ,
     .                     'HAS A CHEMICAL SPUTTER MODEL, BUT ',
     .                     'SPUTTER YIELD IS SCALED TO ZERO (RECYCC=0)'
        ENDIF
        IF (ILIIN(J).EQ.2) RECYCF(:,J)=0.
        IF (ILIIN(J).EQ.2) RECYCT(:,J)=0.
C
        SAVE=ZNML(J)
        ZNML(J)=DBLE(IDINT(SAVE/100.D0))
        ZNCL(J)=SAVE-100.*ZNML(J)
        DO 2001 ISPZ=1,NSPZ
          ISRF(ISPZ,J)=ISRF(ISPZ,1)
          ISRT(ISPZ,J)=ISRT(ISPZ,1)
2001    CONTINUE
2000  CONTINUE
C
      INMP1I=0
      INMP2I=0
      INMP3I=0
C
      DO 2019 ISTS=1,NSTSI
        NLJ=NLIM+ISTS
        ISWICH(1,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),1,6)
        IF (ISWICH(1,NLJ).EQ.1) ISWICH(1,NLJ)=-1
        IF (ISWICH(1,NLJ).EQ.2) ISWICH(1,NLJ)=1
        ISWICH(2,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),2,6)
        IF (ISWICH(2,NLJ).EQ.1) ISWICH(2,NLJ)=-1
        IF (ISWICH(2,NLJ).EQ.2) ISWICH(2,NLJ)=1
        ISWICH(3,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),3,6)
        IF (ISWICH(3,NLJ).EQ.1) ISWICH(3,NLJ)=-1
        IF (ISWICH(3,NLJ).EQ.2) ISWICH(3,NLJ)=1
        ISWICH(4,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),4,6)
        IF (ISWICH(4,NLJ).EQ.1) ISWICH(4,NLJ)=-1
        IF (ISWICH(4,NLJ).EQ.2) ISWICH(4,NLJ)=1
        ISWICH(5,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),5,6)
        IF (ISWICH(5,NLJ).EQ.1) ISWICH(5,NLJ)=-1
        IF (ISWICH(5,NLJ).EQ.2) ISWICH(5,NLJ)=1
        ISWICH(6,NLJ)=EIRENE_IDEZ(ILSWCH(NLJ),6,6)
        IF (ISWICH(6,NLJ).EQ.1) ISWICH(6,NLJ)=-1
        IF (ISWICH(6,NLJ).EQ.2) ISWICH(6,NLJ)=1
C
        IF (ISWICH(4,NLJ).NE.0.OR.ISWICH(5,NLJ).NE.0.OR.
     .      ISWICH(6,NLJ).NE.0) THEN
          ILBLCK(NLJ)=EIRENE_IDEZ(ILCELL(NLJ),4,4)
          I1000=1000*ILBLCK(NLJ)
          ILACLL(NLJ)=ILCELL(NLJ)-I1000
        ENDIF
C
        IF (ILSWCH(NLJ).NE.0.AND.ILIIN(NLJ).GT.0) THEN
          DO ISPZ=1,NSPZ
            IF (TRANSP(ISPZ,1,NLJ).NE.0..OR.TRANSP(ISPZ,2,NLJ).NE.0.)
     .      THEN
              WRITE (iunout,*)
     .          'EXIT FROM TIMEA0: SURFACE NO. ISTS OPERATING'
              WRITE (iunout,*)
     .          'A SWITCH BUT IS SOMETIMES TRANSPARENT AND '
              WRITE (iunout,*)
     .          'SOMETIMES REFLECTING (SEMI-TRANSPARENCY OPTION)'
              WRITE (iunout,*)
     .          'POSSIBLE FIXES: SEE MANUAL, CHAPTER 2, SECTION 6'
              WRITE (iunout,*) 'ISTS= ',ISTS
              CALL EIRENE_EXIT_OWN(1)
            ENDIF
          ENDDO
        ENDIF
C
C  SET NON DEFAULT STANDARD SURFACE IDENTIFIERS INMP...
C
C  RADIAL SURFACE
        DO 2014 IR=1,NR1ST
          IF (IR.EQ.INUMP(ISTS,1)) THEN
            INMP1I(IR,0,0)=ISTS
            DO J=IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              INMP1I(IR,J,0)=ISTS
              DO K=IRPTA(ISTS,3),IRPTE(ISTS,3)-1
                INMP1I(IR,0,K)=ISTS
                INMP1I(IR,J,K)=ISTS
              END DO
            END DO
          ENDIF
2014    CONTINUE
C  POLOIDAL SURFACE
        DO 2016 JP=1,NP2ND
          IF (JP.EQ.INUMP(ISTS,2)) THEN
            INMP2I(0,JP,0)=ISTS
            DO I=IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              INMP2I(I,JP,0)=ISTS
              DO K=IRPTA(ISTS,3),IRPTE(ISTS,3)-1
                INMP2I(0,JP,K)=ISTS
                INMP2I(I,JP,K)=ISTS
              END DO
            END DO
          ENDIF
2016    CONTINUE
C  TOROIDAL SURFACE
        DO 2018 KT=1,NT3RD
          IF (KT.EQ.INUMP(ISTS,3)) THEN
            INMP3I(0,0,KT)=ISTS
            DO I=IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              INMP3I(I,0,KT)=ISTS
              DO J=IRPTA(ISTS,2),IRPTE(ISTS,2)-1
                INMP3I(0,J,KT)=ISTS
                INMP3I(I,J,KT)=ISTS
              END DO
            END DO
          ENDIF
2018    CONTINUE
C
2019  CONTINUE
C
      NLSYMT(0)=.TRUE.
      NLSYMP(0)=.TRUE.
      DO 2028 ISTRA=1,NSTRAI
        IF (INDSRC(ISTRA).EQ.6) GOTO 2028
        IF (.NOT.NLSRF(ISTRA))
     .  THMAX=MAX(0._DP,MIN(PIA,SORMAX(ISTRA)*DEGRAD))
        IF (NLSRF(ISTRA))
     .  THMAX=MAX(0._DP,MIN(PIHA,SORMAX(ISTRA)*DEGRAD))
        IF (NAMODS(ISTRA).EQ.1) THEN
          RP1=SORCOS(ISTRA)+1.
          SORCOS(ISTRA)=1./RP1
!pb          IF (ABS(COS(THMAX)).LE.EPS10) THEN
          IF (ABS(COS(THMAX)).LE.EPS5) THEN
            SORMAX(ISTRA)=1.
          ELSE
            SORMAX(ISTRA)=1.-COS(THMAX)**RP1
          ENDIF
        ELSEIF (NAMODS(ISTRA).EQ.2) THEN
          SORCOS(ISTRA)=SORCOS(ISTRA)*DEGRAD
          SORMAX(ISTRA)=THMAX
        ELSE
          WRITE (iunout,*) 'INPUT ERROR: ISTRA,NAMODS(ISTRA)='
          WRITE (iunout,*) '             ',ISTRA,NAMODS(ISTRA)
          CALL EIRENE_EXIT_OWN(1)
        ENDIF
        NLSYMT(0)=NLSYMT(0).AND.NLSYMT(ISTRA)
        NLSYMP(0)=NLSYMP(0).AND.NLSYMP(ISTRA)
2028  CONTINUE
C
C
C  SPECIES INDEX DISTRIBUTION OF PRIMARY SOURCE PARTICLES
C  OR FOR THERMAL PARTICLE REFLECTION MODEL
C
      NATMIM=NATMI-1
      NMOLIM=NMOLI-1
      NIONIM=NIONI-1
      NPLSIM=NPLSI-1
      NPHOTIM=NPHOTI-1
      SA=0.
      SI=0.
      SM=0.
      SPP=0.
      SPH=0.
      DO J=1,NIONI
        SI=SI+DIOD(J)
        DION(J)=SI
      END DO
      DO J=1,NMOLI
        SM=SM+DMLD(J)
        DMOL(J)=SM
      END DO
      DO J=1,NATMI
        SA=SA+DATD(J)
        DATM(J)=SA
      END DO
      DO J=1,NPLSI
        SPP=SPP+DPLD(J)
        DPLS(J)=SPP
      END DO
      DO J=1,NPHOTI
        SPH=SPH+DPHD(J)
        DPHOT(J)=SPH
      END DO
C
C  NORMALIZE DISTRIBUTION AND CUMULATIVE DISTRIBUTION
      DO IION=1,NIONI
        DIOD(IION)=DIOD(IION)/(SI+1.D-60)
        DION(IION)=DION(IION)/(SI+1.D-60)
      END DO
      DO IMOL=1,NMOLI
        DMLD(IMOL)=DMLD(IMOL)/(SM+1.D-60)
        DMOL(IMOL)=DMOL(IMOL)/(SM+1.D-60)
      END DO
      DO IATM=1,NATMI
        DATD(IATM)=DATD(IATM)/(SA+1.D-60)
        DATM(IATM)=DATM(IATM)/(SA+1.D-60)
      END DO
      DO IPLS=1,NPLSI
        DPLD(IPLS)=DPLD(IPLS)/(SPP+1.D-60)
        DPLS(IPLS)=DPLS(IPLS)/(SPP+1.D-60)
      END DO
      DO IPHOT=1,NPHOTI
        DPHD(IPHOT)=DPHD(IPHOT)/(SPH+1.D-60)
        DPHOT(IPHOT)=DPHOT(IPHOT)/(SPH+1.D-60)
      END DO
C
C
C  ATOMIC WEIGHT OF TEST IONS  =RMASSI(IION)
      DO IION=1,NIONI
        RMASSI(IION)=NMASSI(IION)*PMASSA
        RSQDVI(IION)=1._DP/SQRT(RMASSI(IION))*CVELAA
        CVRSSI(IION)=RMASSI(IION)*CVELI2
        ALMASI(IION)=LOG10(RMASSI(IION))
      END DO
C  ATOMIC WEIGHT OF ATOMS  =RMASSA(IATM)
      DO IATM=1,NATMI
        RMASSA(IATM)=NMASSA(IATM)*PMASSA
        RSQDVA(IATM)=1._DP/SQRT(RMASSA(IATM))*CVELAA
        CVRSSA(IATM)=RMASSA(IATM)*CVELI2
        ALMASA(IATM)=LOG10(RMASSA(IATM))
      END DO
C  ATOMIC WEIGHT OF MOLECULES
      DO IMOL=1,NMOLI
        RMASSM(IMOL)=NMASSM(IMOL)*PMASSA
        RSQDVM(IMOL)=1._DP/SQRT(RMASSM(IMOL))*CVELAA
        CVRSSM(IMOL)=RMASSM(IMOL)*CVELI2
        ALMASM(IMOL)=LOG10(RMASSM(IMOL))
      END DO
C  ATOMIC WEIGHT OF BULK IONS
      DO IPLS=1,NPLSI
        RMASSP(IPLS)=NMASSP(IPLS)*PMASSA
csw check photon in bulk
        if(rmassp(ipls) > 0._DP) then
          RSQDVP(IPLS)=1._DP/SQRT(RMASSP(IPLS))*CVELAA
          CVRSSP(IPLS)=RMASSP(IPLS)*CVELI2
          ALMASP(IPLS)=LOG10(RMASSP(IPLS))
        else
          rsqdvp(ipls)=0.
          cvrssp(ipls)=0.
          almasp(ipls)=0.
        endif
csw end check
      END DO
C
C
C  SET SOME ARRAYS TO SPEED UP COMPUTATIONS
C
C  1ST: SPECIES FLAGS:
        DO IPH=0,NPHOTP
        DO IA=0,NATMP
        DO IM=0,NMOLP
        DO II=0,NIONP
        DO IP=0,NPLSP
          ISPEZ(-1,IPH,IA,IM,II,IP)=-1
          ISPEZ(0,IPH,IA,IM,II,IP)=IPH
          ISPEZ(1,IPH,IA,IM,II,IP)=NPHOTI+IA
          ISPEZ(2,IPH,IA,IM,II,IP)=NPHOTI+NATMI+IM
          ISPEZ(3,IPH,IA,IM,II,IP)=NPHOTI+NATMI+NMOLI+II
          ISPEZ(4,IPH,IA,IM,II,IP)=NPHOTI+NATMI+NMOLI+NIONI+IP
        ENDDO
        ENDDO
        ENDDO
        ENDDO
        ENDDO
        DO IZ=1,NPHOTI
          ISPEZI(IZ,-1)=0
          ISPEZI(IZ,0)=IZ
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NPHOTI+1,NPHOTI+NATMI
          ISPEZI(IZ,-1)=1
          ISPEZI(IZ,0)=0
          ISPEZI(IZ,1)=IZ-NPHOTI
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NPHOTI+NATMI+1,NPHOTI+NATMI+NMOLI
          ISPEZI(IZ,-1)=2
          ISPEZI(IZ,0)=0
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=IZ-NPHOTI-NATMI
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NPHOTI+NATMI+NMOLI+1,NPHOTI+NATMI+NMOLI+NIONI
          ISPEZI(IZ,-1)=3
          ISPEZI(IZ,0)=0
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=IZ-NPHOTI-NATMI-NMOLI
          ISPEZI(IZ,4)=0
        ENDDO
        DO IZ=NPHOTI+NATMI+NMOLI+NIONI+1,NPHOTI+NATMI+NMOLI+NIONI+NPLSI
          ISPEZI(IZ,-1)=4
          ISPEZI(IZ,0)=0
          ISPEZI(IZ,1)=0
          ISPEZI(IZ,2)=0
          ISPEZI(IZ,3)=0
          ISPEZI(IZ,4)=IZ-NPHOTI-NATMI-NMOLI-NIONI
        ENDDO
 
      IF (NPHOTI > 0) CALL EIRENE_PH_INIT(1)
      CALL EIRENE_SETAMD(0)
      CALL EIRENE_ALLOC_COMUSR(2)
      CALL EIRENE_ALLOC_CTEXT(2)
 
      CALL EIRENE_SETTXT
 
      IF (NADVI > 0) THEN
        TXTTAL(1:NADVI,NTALA) = TXTTLA(1:NADVI)
        TXTSPC(1:NADVI,NTALA) = TXTSCA(1:NADVI)
        TXTUNT(1:NADVI,NTALA) = TXTUTA(1:NADVI)
      END IF
 
      IF (NCLVI > 0) THEN
        TXTTAL(1:NCLVI,NTALC) = TXTTLC(1:NCLVI)
        TXTSPC(1:NCLVI,NTALC) = TXTSCC(1:NCLVI)
        TXTUNT(1:NCLVI,NTALC) = TXTUTC(1:NCLVI)
      END IF
 
      IF (NALVI > 0) THEN
        TXTTAL(1:NALVI,NTALR) = TXTTLR(1:NALVI)
        TXTSPC(1:NALVI,NTALR) = TXTSCR(1:NALVI)
        TXTUNT(1:NALVI,NTALR) = TXTUTR(1:NALVI)
      END IF
 
      IF (NSNVI > 0) THEN
        TXTTAL(1:NSNVI,NTALT) = TXTTLT(1:NSNVI)
        TXTSPC(1:NSNVI,NTALT) = TXTSCT(1:NSNVI)
        TXTUNT(1:NSNVI,NTALT) = TXTUTT(1:NSNVI)
      END IF
 
      DEALLOCATE (TXTTLA)
      DEALLOCATE (TXTSCA)
      DEALLOCATE (TXTUTA)
      DEALLOCATE (TXTTLC)
      DEALLOCATE (TXTSCC)
      DEALLOCATE (TXTUTC)
      DEALLOCATE (TXTTLR)
      DEALLOCATE (TXTSCR)
      DEALLOCATE (TXTUTR)
      IF (NPRNLI > 0) THEN
        DEALLOCATE (TXTTLT)
        DEALLOCATE (TXTSCT)
        DEALLOCATE (TXTUTT)
      END IF
C
C
C  ADDITIONAL INPUT FOR THIS RUN COMES FROM EITHER
C  ANOTHER CODE (DATA FILE) OR FROM AN EARLIER RUN OF EIRENE
C
3000  CONTINUE
C
C  INPUT BLOCK 14 BEGIN
C
C  READ DATA IN INTERFACING SUBROUTINE INFCOP  1400 -- 1499
C
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time vor block 14 ',tpb2-tpb1
!pb      tpb1 = tpb2
 
      IF (IREAD.EQ.0) READ (IUNIN,*)
      CALL EIRENE_MASAGE
     .  ('*** 14. DATA FOR INTERFACING ROUTINE "INFCOP"   ')
      IF (NMODE.EQ.0) THEN
        WRITE (iunout,*) '        SUBR. INFCOP NOT CALLED. '
        READ (IUNIN,6666) NAINI,NCOPII,NCOPIE
        NCOPI=NCOPIE
        WRITE (iunout,*) '        NAINI, NCOPI = ',NAINI,NCOPI
        IF (NAINI.GT.NAIN) THEN
          CALL EIRENE_MASPRM('NAIN',4,NAIN,'NAINI',5,NAINI,IERROR)
          GOTO 1500
        ENDIF
        NCPVI=NCOPI
        IF (NCPVI.GT.NCPV) THEN
          CALL EIRENE_MASPRM('NCOP',4,NCOP,'NCOPI',5,NCOPI,IERROR)
          CALL EIRENE_EXIT_OWN(1)
        ENDIF
        CALL EIRENE_ALLOC_CCOUPL(2)
        DO 3020 J=1,NAINI
3021      READ (IUNIN,'(A72)') ZEILE
          IF (ZEILE(1:1) .EQ. '*') GOTO 3021
          READ (ZEILE,6666) NAINS(J),NAINT(J)
          READ (IUNIN,'(A72)') TXTPLS(J,NTALN)
          READ (IUNIN,'(2A24)') TXTPSP(J,NTALN),TXTPUN(J,NTALN)
3020    CONTINUE
      ELSEIF (NMODE.NE.0) THEN
        NAINI=0
C  READ BLOCK 14 AND GEOMETRY FROM EXTERNAL DATABASE (FT30)
        CALL EIRENE_IF0COP
      ENDIF
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time nach if0cop ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
C  INPUT BLOCK 14 DONE
C
C
C  PLOTTING AND TEXT
C
      IF (NPLOTR.LE.0) NPLOTR=NR1ST
      IF (NPLOTP.LE.0) NPLOTP=NP2ND
      IF (NPLOTT.LE.0) NPLOTT=NT3RD
      NPLOTR=MIN0(NPLOTR,NR1ST)
      if (nltri.or.nltet) NPLOTR=MIN0(NPLOTR,NR1ST-1)
      NPLINR=MAX0(NPLINR,1)
      NPLDLR=MAX0(NPLDLR,1)
      NPLOTP=MIN0(NPLOTP,NP2ND)
      NPLINP=MAX0(NPLINP,1)
      NPLDLP=MAX0(NPLDLP,1)
      NPLOTT=MIN0(NPLOTT,NT3RD)
      NPLINT=MAX0(NPLINT,1)
      NPLDLT=MAX0(NPLDLT,1)
      PL1ST=PL1ST.AND.NR1ST.GT.1
      PL2ND=PL2ND.AND.NP2ND.GT.1
      PL3RD=PL3RD.AND.NT3RD.GT.1
      PLADD=PLADD.AND.NLIMI.GT.0
      NLPL2D=PL1ST.OR.PL2ND.OR.PL3RD.OR.PLADD
      NLPL3D=PL3A(1).OR.PL3A(2).OR.PL3A(3).OR.PL3A(4).OR.PL3A(5).OR.
     .       PL3S(1).OR.PL3S(2).OR.PL3S(3)
      PLHST=PLHST.AND.(NLPL2D.OR.NLPL3D)
      PLCHOR=PLCHOR.AND.NVOLPL.EQ.0
      TRCSUR=TRCSUR.AND.(NLIMI.GT.0.OR.NSTSI.GT.0)
      LPRADR=.FALSE.
      LPPOLR=.FALSE.
      LPTORR=.FALSE.
 
      IF ((NVOLPL > 0) .AND.
     .    (ANY(PLTL2D(1:NVOLPL)) .OR.
     .    (ANY(PLTL3D(1:NVOLPL)).AND.LEVGEO<=3))) CALL
     .  EIRENE_ALLOC_CGRPTL
 
      IF (NSIGVI > 0) THEN
        J=1
        DO WHILE (J <= NSIGVI)
          IF (LMISTALV(IIH(J))) THEN
            WRITE (iunout,*)
     .        ' NO STATISTICS IS DONE FOR VOLUME TALLY NO. ',IIH(J)
            WRITE (iunout,*) ' BECAUSE TALLY HAS BEEN SWITCHED OFF '
            IGH(J)=IGH(NSIGVI)
            IIH(J)=IIH(NSIGVI)
            NSIGVI=NSIGVI-1
          ELSE
            J=J+1
          END IF
        END DO
      END IF
 
      IF (NSIGSI > 0) THEN
        J=1
        DO WHILE (J <= NSIGSI)
          IF (LMISTALS(IIHW(J))) THEN
            WRITE (iunout,*)
     .        ' NO STATISTICS IS DONE FOR SURFACE TALLY NO. ',IIHW(J)
            WRITE (iunout,*) ' BECAUSE TALLY HAS BEEN SWITCHED OFF '
            IGHW(J)=IGHW(NSIGSI)
            IIHW(J)=IIHW(NSIGSI)
            NSIGSI=NSIGSI-1
          ELSE
            J=J+1
          END IF
        END DO
      END IF
 
      IF (NSIGCI > 0) THEN
        J=1
        DO WHILE (J <= NSIGCI)
          IF (LMISTALV(IIHC(1,J)) .OR. LMISTALV(IIHC(2,J))) THEN
            WRITE (iunout,*)
     .        ' NO CORRELATION COEFFICIENT IS CALCULATED ',
     .        ' BETWEEN TALLIES ',IIHC(1,J),' AND ',IIHC(2,J)
            WRITE (iunout,*) ' BECAUSE TALLIES HAVE BEEN SWITCHED OFF '
            IGHC(1,J)=IGHC(1,NSIGCI)
            IIHC(1,J)=IIHC(1,NSIGCI)
            IGHC(2,J)=IGHC(2,NSIGCI)
            IIHC(2,J)=IIHC(2,NSIGCI)
            NSIGCI=NSIGCI-1
          ELSE
            J=J+1
          END IF
        END DO
      END IF
 
      IF (.NOT.LBGKV) NSIGI_BGK=0
      IF (.NOT.LCOPV) NSIGI_COP=0
C
C  NO MODIFICATION OF INPUT VARIABLES BEYOND THIS POINT
C  WITHOUT WARNING
C  EXCEPT IN SUBROUTINE MODUSR FOR THE NEXT ITERATION STEP
C         IN SUBROUTINE TMSUSR FOR THE NEXT TIME STEP
C
C
      CALL EIRENE_INIUSR
C
C  SET DERIVED INPUT PARAMETERS, GRIDS AND PROFILES
C
      NSURF=NR1ST*NP2ND*NT3RD*NBMLT
      NSTRD=NR1ST*NP2ND*NT3RD
      NBLCKS=NBMLT*NP2ND*NT3RD
      NSBOX=NSURF+NRADD
      NSBOX_TAL=NR1TAL*NP2TAL*NT3TAL*NBMLT+NRADD
      IF (NSBOX.GT.NRAD) THEN
        CALL EIRENE_MASPRM('NRAD',4,NRAD,'NSBOX',5,NSBOX,IERROR)
        CALL EIRENE_EXIT_OWN(1)
      ENDIF
      NSURFM=NSURF-1
      NR1STM=NR1ST-1
      NP2NDM=NP2ND-1
      NT3RDM=NT3RD-1
      NTTRAM=NTTRA-1
      NBMLTP=NBMLT+1
 
      IF (LEVGEO == 4) THEN
        NGITT = COUNT(INMTI(1:3,1:NTRII) .NE. 0) + 1
      ELSE IF (LEVGEO == 5) THEN
        NGITT = COUNT(INMTIT(1:4,1:NTET) .NE. 0) + 1
      END IF
 
      CALL EIRENE_SET_PARMMOD(3)
      CALL EIRENE_ALLOC_CGEOM(2)
      CALL EIRENE_ALLOC_COMUSR(3)
      SAREA(1:NLIMPS) = SAREA_SAVE(1:NLIMPS)
      DEALLOCATE (SAREA_SAVE)
 
C
      NSIGI=NSIGVI+NSIGSI+NSIGCI
      NCPVI_STAT=0
      IF (NSIGI_COP > 0) NCPVI_STAT=NCPVI+NPLSI+2
      IF (NCPVI_STAT > NCPV_STAT) THEN
        CALL EIRENE_MASPRM('NCPVI_STAT',10,NCPVI_STAT,
     .              'NCPV_STAT',9,NCPV_STAT,IERROR)
        CALL EIRENE_EXIT_OWN(1)
      END IF
C
      CALL EIRENE_PAGE
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time vor grid ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
      IF (NFILEM.LE.1) THEN
C
C  SET GRIDS AND VOLUMES OF THE CELLS FOR THE STANDARD MESHES
C
C  SET RADIAL OR X GRID
        IF (NLRAD) CALL EIRENE_GRID (1)
C  SET POLOIDAL OR Y GRID
!pb        IF (NLPOL) CALL EIRENE_GRID (2)
        IF (NLPOL.OR.(LEVGEO ==2).OR.(LEVGEO == 3)) CALL EIRENE_GRID (2)
C  SET TOROIDAL OR Z GRID
        IF (NLTOR) CALL EIRENE_GRID (3)
C
        IF (INDPRO(12).LT.4) THEN
C  INITIALIZE SUBROUTINE VOLUME FOR LATER CALLS
C  TO BE WRITTEN:    CALL VOLUME(0)
C  SET VOLUMES, 1ST DIMENSION (R/X-GRID)
          IF (NLRAD) CALL EIRENE_VOLUME(1)
C  SET VOLUMES, 2ND DIMENSION (THETA/Y-GRID)
          IF (NLPOL) CALL EIRENE_VOLUME(2)
C  SET VOLUMES, 3RD DIMENSION (PHI/Z-GRID)
         IF (NLTOR) CALL EIRENE_VOLUME(3)
C  SET VOLUMES, IN ADDITIONAL CELL REGION
          IF (NLADD) CALL EIRENE_VOLUME(4)
        ELSEIF (INDPRO(12).EQ.4) THEN
C  READ VOLUMES FROM STREAM ISTREAM=VL0
          ISTREAM=VL0
          ITALI=NTALO
          CALL EIRENE_READTL(TXTPLS(1,ITALI),TXTPSP(1,ITALI),
     .                TXTPUN(1,ITALI),
     .                VOL,NR1ST,NP2ND,NT3RD,NBMLT,NSBOX,
     .                3,ISTREAM)
C  TAKE VOLUMES FROM USER SUPPLIED ROUTINE
        ELSEIF (INDPRO(12).EQ.5) THEN
          CALL EIRENE_PROUSR (VOL,5+5*NPLS,0._DP,0._DP,0._DP,0._DP,
     .                              0._DP,0._DP,0._DP,NSBOX)
C  TAKE VOLUMES FROM EXTERNAL FILE
C  THIS CAN BE DONE ONLY AFTER CALL TO IF1COP
C  BECAUSE ONLY THEN WILL WORKARRAY BE FILLED FOR CELL VOLUMES
C       ELSEIF (INDPRO(12).EQ.6) THEN
C         CALL PROFR (VOL,5+5*NPLS,1,1,NSURF)
C         IF (NLADD) CALL VOLUME(4)
C       ELSEIF (INDPRO(12).EQ.7) THEN
C         CALL PROFR (VOL,5+5*NPLS,1,1,NSBOX)
        ENDIF
C
C  MULTIPLY GEOMETRICAL DATA, IF NBMLT.GT.1
C
        IF (NBMLT.GT.1) CALL EIRENE_MULTIG
C
C  SET CELL DIAMETER
C
        IF (LEVGEO == 5) THEN
!  Tetrahedra
          WHERE (VOL > EPS10)
            CELDIA = VOL**(1._DP/3._DP)
          ELSEWHERE
            CELDIA = 0._DP
          END WHERE
        ELSE
!  CYLINDRICAL OR TOROIDAL MESH
          WHERE (AREA > EPS10)
            CELDIA = SQRT(AREA/PIA)
          ELSEWHERE
            CELDIA = 0.D0
          END WHERE
        END IF
C
C   INCLUDE INFORMATION PROVIDED BY INPUT BLOCK 8: ADDITIONAL
C   DATA FOR SPECIFIC ZONES
C
        DO WHILE (ASSOCIATED(VOLLIST))
          VOL(VOLLIST%IN) = VOLLIST%VOL
          VOLCUR => VOLLIST
          VOLLIST => VOLLIST%NEXT
          DEALLOCATE(VOLCUR)
        ENDDO
        IF (NPHOTI > 0) CALL EIRENE_PH_INIT(2)
C
C   MODIFY SOME GEOMETRICAL DATA, USER SUPPLIED ROUTINE
C
        CALL EIRENE_GEOUSR
 
        IF (LEVGEO == 4) CALL EIRENE_CUT_ADS_CELL
C
C  SET SOME DATA FOR ADDITIONAL SURFACES: INITIALIZE SUBR. TIMEA
C
        CALL EIRENE_TIMEA0
C
C   MODIFY THE BOUNDARIES OF SOME SURFACES TO AVOID ROUND OFF
C   ERRORS
C
        CALL EIRENE_SETFIT (TRCSUR)
C
C   SET THE COEFFICIENTS OF SOME SURFACES IDENTICAL TO THOSE
C   OF SOME OTHER, TO AVOID ROUND OFF ERRORS
C
        CALL EIRENE_SETEQ
C
        IF (LEVGEO.EQ.3.OR.LEVGEO.EQ.4) CALL EIRENE_WRMESH
C
C
        CALL EIRENE_INTVOL (VOL,1,1,NSBOX,VOLTOT,
     .               NR1ST,NP2ND,NT3RD,NBMLT)
        WRITE (iunout,*) ' VOLTOT     ',VOLTOT
C
C  SET 'VISIBLE ADDITIONAL SURFACES' RANGES
Cc
        NLIMII=1
        NLIMIE=NLIMI
C
        NSOPT=MIN(NOPTIM,NSBOX)
        DO 8004 J=1,NSOPT
          IF (NLIMPB >= NLIMPS) THEN
            DO 8005 I=1,NLIMI
              LHELP(I) = IGJUM3(J,I)==0
8005        CONTINUE
            IIN=EIRENE_ILLZ(NLIMI,LHELP,1)+1
            IEN=NLIMI-EIRENE_ILLZ(NLIMI,LHELP,-1)
          ELSE
            IIN = 1
            IEN = NLIMI
! NO='1111....111'B ALL BITS SET TO 1
            NO=NOT(0)
! NUMBER OF INTEGERS USED TO STORE SURFACE INFORMATION
            IGO=NLIMI/NBITS
            IF (MOD(NLIMI,NBITS) > 0) IGO = IGO + 1
! CHECK FOR FIRST ACTIVE SURFACE
            DO I=1,IGO
              IF (IAND(IGJUM3(J,I),NO) /= NO) THEN
                IBEND = NBITS-1
                IF (I == IGO) IBEND = NLIMI-(I-1)*NBITS - 1
                DO IB=0,IBEND
                  IF (.NOT.BTEST(IGJUM3(J,I),IB)) THEN
                    ILA=IB
                    EXIT
                  END IF
                END DO
                IIN = (I-1)*NBITS+ILA+1
              END IF
            END DO
! CHECK FOR LAST ACTIVE SURFACE
            DO I=IGO,1,-1
              IF (IAND(IGJUM3(J,I),NO) /= NO) THEN
                IBEND = NBITS-1
                IF (I == IGO) IBEND = NLIMI-(I-1)*NBITS - 1
                DO IB=IBEND,0,-1
                  IF (.NOT.BTEST(IGJUM3(J,I),IB)) THEN
                    ILA=IB
                    EXIT
                  END IF
                END DO
                IEN = (I-1)*NBITS+ILA+1
              END IF
            END DO
          END IF
 
          NLIMII(J)=IIN
          NLIMIE(J)=IEN
8004    CONTINUE
C
C  ALL GEOMETRICAL DATA (GRIDS, VOLUMES, SWITCHES) ARE DEFINED NOW
C
C   SAVE GEOMETRICAL DATA ON FILE FT12
C
        DO 8006 IRAD=1,NSBOX
          VOLG(IRAD)=VOL(IRAD)
8006    CONTINUE
C
        DO ILIMPS=1,NLMPGS
          AREAG(ILIMPS)=SAREA(ILIMPS)
        ENDDO
C
        IF (NFILEM.EQ.1) CALL EIRENE_WRGEOM(TRCFLE)
C
      ELSEIF (NFILEM.EQ.2) THEN
C
C   RESTORE GEOMETRICAL DATA FROM FILE FT12
C
        CALL EIRENE_RGEOM(TRCFLE)
C
        DO 8010 IRAD=1,NSBOX
          VOL(IRAD)=VOLG(IRAD)
8010    CONTINUE
C
        DO ILIMPS=1,NLMPGS
          SAREA(ILIMPS)=AREAG(ILIMPS)
        ENDDO
C
C
      ENDIF
C
      DO 8011 IS=1,NLIMPS
        IF (ILACLL(IS).NE.0.AND..NOT.NLADD) THEN
          WRITE (iunout,*) 'ADDITIONAL CELL SWITCHES DEFINED, BUT NO '
          WRITE (iunout,*) 'ADDITIONAL CELLS DEFINED'
          ISS=IS
          IF (ISS.GT.NLIM) ISS=-(ISS-NLIM)
          WRITE (iunout,*) 'SURFACE NO. IS= ',ISS
          WRITE (iunout,*) 'CHECK INPUT BLOCK 2E'
          CALL EIRENE_EXIT_OWN(1)
        ELSEIF (ILBLCK(IS).NE.0.AND..NOT.(NLMLT.OR.NLADD)) THEN
          WRITE (iunout,*) 'BLOCK SWITCHES DEFINED, BUT NEITHER BLOCKS'
          WRITE (iunout,*) 'NOR ADDITIONAL CELLS DEFINED'
          ISS=IS
          IF (ISS.GT.NLIM) ISS=-(ISS-NLIM)
          WRITE (iunout,*) 'SURFACE NO. IS= ',ISS
          WRITE (iunout,*) 'CHECK INPUT BLOCKS 2D AND 2E'
          CALL EIRENE_EXIT_OWN(1)
        ENDIF
8011  CONTINUE
C
4000  CONTINUE
C
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time vor plasma definition ',tpb2-tpb1
!pb      tpb1 = tpb2
 
      IF (ANY(INDPRO(1:6) == 6)) CALL EIRENE_ALLOC_BCKGRND
      IF (NMODE.NE.0.AND.IITER.LE.1) THEN
C  READ PLASMA BACKGROUND FROM EXTERNAL DATABASE (FT31) (NOT NLPLAS)
C  OR FROM COMMON BRAEIR (NLPLAS)
        CALL EIRENE_IF1COP
      ENDIF
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer if1cop ',tpb2-tpb1
!pb      tpb1 = tpb2
C
      IF (NSTEP > 0) CALL EIRENE_ALLOC_CSTEP
C
!PB VOLTAL INITIALIZED WITH EPS60 TO AVOID ZERODIVISIONS (E.G. IN CUT CELLS)
      VOLTAL = EPS60
      DO IN=1,NSBOX
        INT = NCLTAL(IN)
        IF (INT > 0) VOLTAL(INT) = VOLTAL(INT) + VOL(IN)
      END DO
      CALL EIRENE_INTVOL (VOLTAL,1,1,NSBOX_TAL,VOLTOT_TAL,
     .             NR1TAL,NP2TAL,NT3TAL,NBMLT)
      WRITE (iunout,*) ' VOLTOT_TAL ',VOLTOT_TAL
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer intvol(voltal) ',tpb2-tpb1
!pb      tpb1 = tpb2
C
      IF ((NFILEL.LE.1).OR.(NFILEL == 6)) THEN
C
C  SET PLASMA PARAMETERS AND SOURCE PARAMETERS
C
        CALL EIRENE_PLASMA
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer plasma ',tpb2-tpb1
!pb      tpb1 = tpb2
C
C  MULTIPLY PLASMA PARAMETERS, IF NBLCKS.GT.1
C
        IF (NBLCKS.GT.1) CALL EIRENE_MULTIP
C
C   INCLUDE INFORMATION PROVIDED BY INPUT BLOCK 8: ADDITIONAL
C   DATA FOR SPECIFIC ZONES
C
        IF (NZADD.GT.0) THEN
          DO WHILE (ASSOCIATED(TEMPLIST))
            TEIN(TEMPLIST%IN) = TEMPLIST%TE
            IPLSTI = MPLSTI(TEMPLIST%IDION)
            TIIN(IPLSTI,TEMPLIST%IN) = TEMPLIST%TI
            TEMPCUR => TEMPLIST
            TEMPLIST => TEMPLIST%NEXT
            DEALLOCATE(TEMPCUR)
          ENDDO
 
          DO WHILE (ASSOCIATED(DENLIST))
            DIIN(DENLIST%IDION,DENLIST%IN) = DENLIST%DI
            DENCUR => DENLIST
            DENLIST => DENLIST%NEXT
            DEALLOCATE(DENCUR)
          ENDDO
 
          DO WHILE (ASSOCIATED(VELLIST))
            IPLS = VELLIST%IDION
            IPLSTI = MPLSTI(IPLS)
            IPLSV = MPLSV(IPLS)
            J = VELLIST%IN
            VXIN(IPLSV,J) = VELLIST%VX
            VYIN(IPLSV,J) = VELLIST%VY
            VZIN(IPLSV,J) = VELLIST%VZ
            IF (VELLIST%IZ .EQ. 1) THEN
              VXIN(IPLSV,J)=CVEL2A*VXIN(IPLSV,J)*
     .                      SQRT((TEIN(J)+TIIN(IPLSTI,J))/RMASSP(IPLS))
              VYIN(IPLSV,J)=CVEL2A*VYIN(IPLSV,J)*
     .                      SQRT((TEIN(J)+TIIN(IPLSTI,J))/RMASSP(IPLS))
              VZIN(IPLSV,J)=CVEL2A*VZIN(IPLSV,J)*
     .                      SQRT((TEIN(J)+TIIN(IPLSTI,J))/RMASSP(IPLS))
            ENDIF
            VELCUR => VELLIST
            VELLIST => VELLIST%NEXT
            DEALLOCATE(VELCUR)
          ENDDO
        ENDIF
C
C  MODIFY SOME PLASMA DATA, USER SUPPLIED ROUTINE
C
        CALL EIRENE_PLAUSR
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer plausr ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
C  COMPUTE SOME 'DERIVED' PLASMA DATA PROFILES FROM THE INPUT PROFILES
C
        CALL EIRENE_PLASMA_DERIV(0)
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer plasma_deriv ',tpb2-tpb1
!pb      tpb1 = tpb2
C
C  SET ATOMIC DATA TABLES
C
        CALL EIRENE_SETAMD(1)
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer setamd ',tpb2-tpb1
!pb      tpb1 = tpb2
C
        IF (NFILEL.EQ.1) CALL EIRENE_WRPLAM(TRCFLE,0)
        IF (NFILEL.EQ.6) CALL EIRENE_WRPLAM_XDR(TRCFLE,0)
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time fuer wrplam ',tpb2-tpb1
!pb      tpb1 = tpb2
C
      ELSEIF (NFILEL.EQ.2.OR.NFILEL.EQ.3.OR.NFILEL.EQ.4.OR.
     .        NFILEL.EQ.7.OR.NFILEL.EQ.8.OR.NFILEL.EQ.9) THEN
C
C  READ PLASMA DATA, ATOMIC DATA, SOURCE DATA FROM FT13
C
        NLSRON_SAVE = NLSRON
 
        IF ((NFILEL == 2) .OR. (NFILEL == 3)) THEN
          CALL EIRENE_RPLAM(TRCFLE,0)
        ELSEIF ((NFILEL == 7) .OR. (NFILEL == 8)) THEN
          CALL EIRENE_RPLAM_XDR(TRCFLE,0)
        ELSEIF (NFILEL == 4) THEN
          CALL EIRENE_RPLAM(TRCFLE,NFILEL)
        ELSEIF (NFILEL == 9) THEN
          CALL EIRENE_RPLAM_XDR(TRCFLE,NFILEL)
        END IF
        CALL EIRENE_XSECTPH
 
        IF (IITER > 1) NLSRON = NLSRON_SAVE
C
      ENDIF
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time nach plasma definition ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
C  SETUP TABLE OF CONTRIBUTIONS OF MONTE-CARLO PARTICLES TO BACKGROUND SPECIES
C
      IADTYP(0:4) = (/ 0, NSPH, NSPA, NSPAM, NSPAMI /)
 
      DO IPLS = 1, NPLSI
        IF ((LEN_TRIM(CDENMODEL(IPLS)) > 0) .AND.
     .      (INDEX(CDENMODEL(IPLS),'CONSTANT') == 0)) THEN
          DO IRE = 1, TDMPAR(IPLS)%TDM%NRE
            ITYP = TDMPAR(IPLS)%TDM%ITP(IRE)
            ISPZ = IADTYP(ITYP) + TDMPAR(IPLS)%TDM%ISP(IRE)
            ISPZ_BACK(ISPZ,IPLS) = 1
          END DO
        END IF
      END DO
 
      CALL EIRENE_LEER(2)
      WRITE (IUNOUT,*) ' LIST OF CONTRIBUTIONS TO BACKGROUND SPECIES '
      DO ISPZ = 1, NSPZ
        DO IPLS = 1, NPLSI
          IF (ISPZ_BACK(ISPZ,IPLS) > 0)
     .      WRITE (IUNOUT,*) TEXTS(ISPZ), ' CONTRIBUTES TO ',
     .                       TEXTS(NSPAMI+IPLS)
        END DO
      END DO
C
C  AT THIS POINT THE BACKGROUND MEDIUM DATA ARE ALL SET.
C
C  COMPUTE SOURCE DATA (OVERRULE SOME OF INPUT BLOCK 7)
      IF ((NMODE.NE.0.AND.IITER.LE.1) .OR. (IITER > NITER))  THEN
        DO ISTRA=1,NSTRAI
          IF (INDSRC(ISTRA).GE.0) CALL EIRENE_IF2COP(ISTRA)
        ENDDO
      ENDIF
C
C
      IF (TRCSUR) THEN
C
        CALL EIRENE_LEER(2)
        WRITE (iunout,*) 'COEFFICIENTS FOR ADDITIONAL SURFACES'
        WRITE (iunout,*)
     .    'THIS IS AFTER GEOUSR, SETEQ AND SETFIT ARE CALLED'
        DO 7701 J=1,NLIMI
          CALL EIRENE_LEER(2)
          WRITE (iunout,*) TXTSFL(J)
          CALL EIRENE_LEER(1)
          IF (IGJUM0(J) == 1) THEN
            WRITE (iunout,*) 'THIS SURFACE IS NOT DEFINED'
          ELSE
            WRITE (iunout,*) 'A0       ',A0LM(J)
            WRITE (iunout,*) 'A1,A2,A3 ',A1LM(J),A2LM(J),A3LM(J)
            WRITE (iunout,*) 'A4,A5,A6 ',A4LM(J),A5LM(J),A6LM(J)
            WRITE (iunout,*) 'A7,A8,A9 ',A7LM(J),A8LM(J),A9LM(J)
            WRITE (iunout,*) 'JUMLIM ',JUMLIM(J)
            WRITE (iunout,*) 'ISWICH(1),ISWICH(2),ISWICH(3),ISWICH(4),',
     .                  'ISWICH(5),ISWICH(6)'
            WRITE (iunout,*)  ISWICH(1,J),ISWICH(2,J),ISWICH(3,J),
     .                   ISWICH(4,J),ISWICH(5,J),ISWICH(6,J)
          ENDIF
7701    CONTINUE
        CALL EIRENE_LEER(2)
        CALL EIRENE_MASIR2('IGJUM0 ',IGJUM0,1,1,1,1,NLIMPS)
        CALL EIRENE_LEER(1)
        IF (NLIMPB >= NLIMPS) THEN
          CALL EIRENE_MASIR2('IGJUM1 ',IGJUM1,0,NLIMPS,1,NLIMPS,NLIMPS)
        ELSE
          CALL
     .  EIRENE_MASBR2('IGJUM1 ',IGJUM1,0,NLIMPS,1,NLIMPS,NLIMPS,NBITS)
        END IF
        CALL EIRENE_LEER(1)
        IF (NLIMPB >= NLIMPS) THEN
          CALL EIRENE_MASIR2('IGJUM2 ',IGJUM2,0,NLIMPS,1,NLIMPS,NLIMPS)
        ELSE
          CALL
     .  EIRENE_MASBR2('IGJUM2 ',IGJUM2,0,NLIMPS,1,NLIMPS,NLIMPS,NBITS)
        END IF
        CALL EIRENE_LEER(1)
        NSOPT=MIN(NSBOX,NOPTIM)
        IF (NLIMPB >= NLIMPS) THEN
          CALL EIRENE_MASIR2('IGJUM3 ',IGJUM3,0,NOPTIM,1,NSOPT,NLIMPS)
        ELSE
          CALL
     .  EIRENE_MASBR2('IGJUM3 ',IGJUM3,0,NOPTIM,1,NSOPT,NLIMPS,NBITS)
        END IF
        CALL EIRENE_LEER(1)
        DO 7702 J=1,NSOPT
          CALL EIRENE_MASJ3
     .  ('J,NLIMII,NLIMIE          ',J,NLIMII(J),NLIMIE(J))
7702    CONTINUE
C
      ENDIF
 
      CALL EIRENE_DEALLOC_BCKGRND
C
      IF (NPHOTI > 0) CALL EIRENE_PH_INIT(3)
 
!  allocate and initialize storage for trajectories
      IF (.NOT.ALLOCATED(TRAJ)) THEN
        ALLOCATE (TRAJ(NCHORI+NTRJ))
 
        DO ITRJ = 1, NCHORI+NTRJ
          ALLOCATE(TRAJ(ITRJ)%TRJ)
          TRAJ(ITRJ)%TRJ%NCOU_CELL = 0
          NULLIFY(TRAJ(ITRJ)%TRJ%CELLS)
        END DO
      END IF
 
      IF (NCHORI > 0) THEN
        IF (ANY(NLSTCHR)) CALL EIRENE_SETUP_CHORD_SPECTRA
      END IF
 
!  determine number of background spectra
 
      NBACK_SPEC = 0
 
      DO J = 1, NADSPC
!  spectrum in geometrical cell
        IF (ESTIML(J)%PSPC%ISRFCLL == 2) THEN
          ISPZ=IADTYP(ESTIML(J)%PSPC%IPRTYP) + ESTIML(J)%PSPC%IPRSP
          NBACK_SPEC = NBACK_SPEC + COUNT(ISPZ_BACK(ISPZ,:)>0)
          LSPCCLL(ESTIML(J)%PSPC%ISPCSRF) = .TRUE.
        END IF
      END DO
 
      IF (.NOT.ALLOCATED(BACK_SPEC) .AND. (NBACK_SPEC > 0))
     .   ALLOCATE(BACK_SPEC(NBACK_SPEC))
 
!pb      TPB2=SECOND_OWN()
!pb      write (iunout,*) ' cpu-time am ende von input ',tpb2-tpb1
!pb      tpb1 = tpb2
 
C
      RETURN
C
C  ERROR EXITS
C
990   CONTINUE
      WRITE (iunout,*) 'TALLY NUMBER FOR PRINTOUT OR PLOT OF VOLUME'
      WRITE (iunout,*) 'AVERAGED TALLIES OUT OF RANGE'
      CALL EIRENE_EXIT_OWN(1)
991   CONTINUE
      WRITE (iunout,*) 'TALLY NUMBER FOR PRINTOUT OF SURFACE AVERAGED '
      WRITE (iunout,*) 'TALLIES OUT OF RANGE'
      CALL EIRENE_EXIT_OWN(1)
992   CONTINUE
      WRITE (iunout,*)
     .  'FINITE ELEMENT OPTION USED, EIRMOD_BUT GRID INDICATOR '
      WRITE (iunout,*) 'LESS THAN 6. '
      CALL EIRENE_EXIT_OWN(1)
994   CONTINUE
      WRITE (iunout,*) 'ERROR IN INPUT: NRPLG.NE.NP2ND, BUT NLPOL=TRUE'
      WRITE (iunout,*) 'NRPLG,NP2ND ',NRPLG,NP2ND
      CALL EIRENE_EXIT_OWN(1)
995   CONTINUE
      WRITE (iunout,*) 'ERROR IN INPUT: ',
     .            'WRONG UNIT NUMBER FOR OUTPUT OF TALLY SPECIFIED'
      WRITE (iunout,*) 'NTLV,NTLVF',NTLV,NTLVF
      CALL EIRENE_EXIT_OWN(1)
998   CONTINUE
      WRITE (iunout,*) 'ERROR IN INPUT BLOCK FOR ADDITIONAL DATA FOR  '
      WRITE (iunout,*) 'SPECIFIC ZONES FOUND AT ZONE NO. ',I
      CALL EIRENE_EXIT_OWN(1)
      END
