c slmod begin
c
c replaced array size of 1000 with 2000 for plot 982
c
c
c slmod end
      SUBROUTINE G1CLS0(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1011)   VERSION (A8.7)    15:NOV:88
C          ------------------------------------------------
C
C          THIS PROVIDES VECTOR-DRAWING OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   =  1, PLOT A POINT AT THE CPP,
C                   =  2, MOVE PLOT POSITION       (X,Y),
C                   =  3, DRAW POLYLINE            (X1,Y1,....XN,YN),
C                   =  4, DRAW POLYMARKLINE        (X1,Y1,....XN,YN),
C                   =  5, DRAW POLYMARKER          (X1,Y1,....XN,YN),
C                   =  6, SET SHORT-VECTOR SCALING (U,V),
C                   =  7, DRAW SHORT-VECTOR STRING (L1,M1,....LN,MN),
C                   =  8, DRAW CLOSED CONIC        (A,T),
C                   =  9, DRAW CONIC ARC           (X0,Y0,THETA,T),
C                   = 10, SET CURVE TYPE           (N),
C                   = 11, SET CURVE METHOD         (N),
C                   = 12, DRAW PARTIAL CURVE       (X1,Y1,....XN,YN),
C                   = 13, DRAW COMPLETE CURVE      (X1,Y1,....XN,YN),
C                   = 14, SET WINDOW VECTOR MODE   (N).
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL VISIBL,MRKING,COMPLT,LASTPT
      LOGICAL TYPMOD,OPEN,LHRDW1,LINSAV,OPCURV,TYPSAV,
     &        WINLIN,WNDOIN,MASKIN,CURTRA,SHIFT1
C
      COMMON /T1C2SV/ LPSAV(4)
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDCC/ SINCHR,COSCHR
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1CURV/ MCURV1,OPCURV
      COMMON /T1DENA/ OPEN
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1LVIS/ WINLIN,WNDOIN,MASKIN
      COMMON /T1MASK/ X1MSK1(10),X2MSK1(10),Y1MSK1(10),Y2MSK1(10),MSKLV1
      COMMON /T1MRKS/ MARKC1
      COMMON /T1PPAT/ XPLOTA,YPLOTA
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1PPOS/ XPLOT1,YPLOT1
      COMMON /T1SHVS/ ISHRTX,ISHRTY,CLONGX,CLONGY
      COMMON /T1TCOC/ XCCX,XCCY,YCCX,YCCY,RPICXC,RPICYC,RDEVXC,RDEVYC,
     &                CURTRA
      COMMON /T1TRST/ SHIFT1,MTRAN1,KLIPM1,INDLVL
      COMMON /T1WNDO/ X1WND1,X2WND1,Y1WND1,Y2WND1
      COMMON /T3NBYR/ NBYTR
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.14) RETURN
C
      NVECS= IABS(LENGTH)/(2*NBYTR)
      GO TO (1,5,6,7,8,10,11,12,13,14,15,16,17,19), IFUNCO
C
C          IF THE CURRENT CHANNEL IS NOT ON, NOTHING IS DONE.
C          OTHERWISE, THE FOLLOWING SECTION WILL PLOT A POINT
C          PROVIDED IT IS WITHIN THE WINDOW AND ALSO OUTSIDE
C          ALL OF THE CURRENT RECTANGULAR MASKING AREAS.
C
    1 IF (.NOT.OPEN) RETURN
C
      XTRY= XPLOTB
      YTRY= YPLOTB
      XCHAR= XPLOTB
      YCHAR= YPLOTB
      IF (KLIPM1.NE.0.OR.MTRAN1.EQ.0.OR.MTRAN1.EQ.2) GO TO 2
C
      XTRY= XCCX*(XPLOTB-RPICXC)+XCCY*(YPLOTB-RPICYC)+RDEVXC
      YTRY= YCCX*(XPLOTB-RPICXC)+YCCY*(YPLOTB-RPICYC)+RDEVYC
    2 IF (XTRY.LT.X1WND1.OR.XTRY.GT.X2WND1)   RETURN
      IF (YTRY.LT.Y1WND1.OR.YTRY.GT.Y2WND1)   RETURN
      IF (XPLOTA.LT.0.0.OR.YPLOTA.LT.0.0)     RETURN
      IF (XPLOTA.GT.DLIMX.OR.YPLOTA.GT.DLIMY) RETURN
      IF (MSKLV1.EQ.0) GO TO 3
C
      DO 100 LEVEL= 1,MSKLV1
        IF (XTRY.LT.X1MSK1(LEVEL).OR .XTRY.GT.X2MSK1(LEVEL)) GO TO 100
        IF (YTRY.GE.Y1MSK1(LEVEL).AND.YTRY.LE.Y2MSK1(LEVEL)) RETURN
  100 CONTINUE
C
    3 IXNOW= DRESX*XPLOTA
      IYNOW= DRESY*YPLOTA
      CALL G1FILB(IXNOW,IYNOW,-1,0)
      RETURN
C
C          THE FOLLOWING SECTIONS SET CONDITIONS FOR
C          POSITION, POLYLINE, POLYMARKLINE, OR POLYMARKER.
C          LOOP-200 THEN CARRIES OUT THE REQUIRED ACTIONS.
C
    5 VISIBL= .FALSE.
      MRKING= .FALSE.
      GO TO 9
C
    6 VISIBL= .TRUE.
      MRKING= .FALSE.
      GO TO 9
C
    7 VISIBL= .TRUE.
      MRKING= .TRUE.
      GO TO 9
C
    8 VISIBL= .FALSE.
      MRKING= .TRUE.
C
    9 TYPSAV= TYPMOD
      TYPMOD= .FALSE.
      IUNSAV= IUNDL1
      IUNDL1= 0
      SAVCOS= COSCHR
      COSCHR= 1.0
      SAVSIN= SINCHR
      SINCHR= 0.0
C
      DO 200 IPT= 1,NVECS
        IPAIR= IPT*2
        XPLOT1= RDATA(IPAIR-1)
        YPLOT1= RDATA(IPAIR)
        CALL G1MAPP(XPLOT1,YPLOT1,XNORM,YNORM,1)
        CALL G1LINE(XNORM,YNORM,VISIBL)
        XCHAR= XNORM
        YCHAR= YNORM
        IF (.NOT.MRKING.OR.MARKC1.LT.32) GO TO 200
C
        LPSAV(1)= MARKA1
        LPSAV(2)= MISSA1
        LPSAV(3)= MARKB1
        LPSAV(4)= MISSB1
        MARKA1= 0
        MISSA1= 0
        MARKB1= 0
        MISSB1= 0
        LINSAV= LHRDW1
        LHRDW1= .FALSE.
        IF (LINSAV) CALL G1HRDW(1)
C
        CALL G1CHAR(MARKC1)
        MARKA1= LPSAV(1)
        MISSA1= LPSAV(2)
        MARKB1= LPSAV(3)
        MISSB1= LPSAV(4)
        LHRDW1= LINSAV
        IF (LHRDW1) CALL G1HRDW(1)
  200 CONTINUE
C
      TYPMOD= TYPSAV
      IUNDL1= IUNSAV
      COSCHR= SAVCOS
      SINCHR= SAVSIN
      RETURN
C
C          THE NEXT SECTION SETS UP CONDITIONS FOR A SHORT-
C          VECTOR STRING, WHILE THE FOLLOWING ONE CONVERTS
C          THE STRING INTO LONG VECTORS AND DRAWS THEM.
C
   10 CLONGX= RDATA(1)
      CLONGY= RDATA(2)
      RETURN
C
   11 LAST= IABS(LENGTH)
      ISHRTX= 0
      ISHRTY= 0
      X1SAVE= XPLOT1
      Y1SAVE= YPLOT1
C
      DO 300 IPT= 2,LAST,2
        ISHRTX= ISHRTX+IDATA(IPT-1)-128
        ISHRTY= ISHRTY+IDATA(IPT)-128
        XPLOT1= ISHRTX*CLONGX+X1SAVE
        YPLOT1= ISHRTY*CLONGY+Y1SAVE
        CALL G1MAPP(XPLOT1,YPLOT1,XNORM,YNORM,1)
        CALL G1LINE(XNORM,YNORM,.TRUE.)
  300 CONTINUE
C
      XCHAR= XNORM
      YCHAR= YNORM
      RETURN
C
C          THE FOLLOWING SECTIONS DO CLOSED
C          AND OPEN CONIC ARCS RESPECTIVELY.
C
   12 XVEC= RDATA(1)+XPLOT1
      YVEC= 1.0
      CALL G1MAPP(XVEC,YVEC,XNORM,YNORM,1)
      XARG= XNORM-XPLOTB
      CALL G1CONC(XARG,0.0,6.28318531,RDATA(2))
      RETURN
C
   13 XVEC= RDATA(1)+XPLOT1
      YVEC= RDATA(2)+YPLOT1
      CALL G1MAPP(XVEC,YVEC,XNORM,YNORM,1)
      XARG= XNORM-XPLOTB
      YARG= YNORM-YPLOTB
      CALL G1CONC(XARG,YARG,RDATA(3),RDATA(4))
      RETURN
C
C          THIS SECTION SETS THE CURVE TYPE (OPEN OR CLOSED).
C
   14 OPCURV= .TRUE.
      IF (IDATA(1).NE.0) OPCURV= .FALSE.
      RETURN
C
C          THIS SECTION SETS THE CURVE DRAWING METHOD.
C
   15 MCURV1= IDATA(1)
      IF (MCURV1.NE.1.AND.MCURV1.NE.2) MCURV1= 1
      RETURN
C
C          THIS SECTION DRAWS COMPLETE OR INCOMPLETE CURVES.
C
   16 COMPLT= .FALSE.
      GO TO 18
C
   17 COMPLT= .TRUE.
   18 IF (NVECS.LT.1) RETURN
C
      LASTPT= .FALSE.
C
      DO 400 IPT= 1,NVECS
        IPAIR= IPT*2
        XPLOT1= RDATA(IPAIR-1)
        YPLOT1= RDATA(IPAIR)
        CALL G1MAPP(XPLOT1,YPLOT1,XNORM,YNORM,1)
        IF (IPT.EQ.NVECS.AND.COMPLT) LASTPT= .TRUE.
C
        CALL G1CRV1(XNORM,YNORM,LASTPT)
  400 CONTINUE
C
      XCHAR= XNORM
      YCHAR= YNORM
      RETURN
C
C          THIS SECTION ENABLES/DISABLES WINDOW-RELATED VECTORS.
C          WHEN ENABLING THEM, THE CURRENT TRANSFORM IS DISABLED
C          UNLESS CLIPPING TRANSFORMATION MODE 1 IS SET. WHEN
C          DISABLING THEM, THE PREVIOUS TRAN. STATE IS RESTORED.
C
   19 WINLIN= .FALSE.
      IF (IDATA(1).EQ.1) WINLIN= .TRUE.
      IF (WINLIN) GO TO 20
      IF (MTRAN1.EQ.1.OR.MTRAN1.EQ.3) CURTRA= .TRUE.
C
      WNDOIN= .TRUE.
      RETURN
C
   20 IF (KLIPM1.NE.1) CURTRA= .FALSE.
C
      WNDOIN= .FALSE.
      RETURN
      END
      SUBROUTINE G1CLS2(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1013)   VERSION (A8.8)    16:OCT:90
C          ------------------------------------------------
C
C          THIS PROVIDES CHARACTER-DRAWING OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   =  1, SET CHARACTER HARDWARE MODE (N),
C                   =  2, SELECT CHARACTER FONT       (N),
C                   =  3, SET CHARACTER MAGNIFICATION (N),
C                   =  4, SET STRING ORIENTATION      (RADIANS),
C                   =  5, SET CHARACTER ORIENTATION   (RADIANS),
C                   =  6, SET ITALIC MODE             (N),
C                   =  7, SET UNDERLINE NUMBER        (N),
C                   =  8, SET CHARACTER OBLATENESS    (X),
C                   =  9, SET MARKER CHARACTER        (N),
C                   = 10, DEFINE CHARACTER SPACE      (X1,X2,Y1,Y2),
C                   = 11, WRITE CHARACTER STRING      (STRING),
C                   = 12, MOVE CHARACTER POSITION     (I,N),
C                   = 13, SET CHARACTER WINDOW MODE   (N),
C                   = 14, SET CHARACTER MASKING MODE  (N),
C                   = 15, STACK CHARACTER DEFINITIONS (N),
C                   = 16, REDEFINE FONT-0 CHARACTER   (N,IP1,...IPK).
C                   = 17, SET JUSTIFICATION TYPE      (N)
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL LINSAV
      LOGICAL TYPMOD,KHRDW1,LHRDW1,WINLIN,WNDOIN,MASKIN,ERRON
C
      COMMON /T1C2SV/ LPSAV(4)
      COMMON /T1CANG/ STANG1,CRANG1
      COMMON /T1CANU/ STANGU,CRANGU
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDCC/ SINCHR,COSCHR
      COMMON /T1CDCS/ SINSTR,COSSTR
      COMMON /T1CDEF/ KSTRT,NDEFS,KNUM(30),KPOSN(30),KLEN(30),KSPEC(500)
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CFIN/ INDLEN(2,256), WIDCHR(256)
      COMMON /T1CFON/ KFONT1
      COMMON /T1CJUS/ JUSTYP
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CMOV/ ADDSP,ADDLN
      COMMON /T1CSPA/ X1CHR1,X2CHR1,Y1CHR1,Y2CHR1
      COMMON /T1CVIS/ KWIND1,KMASK1
      COMMON /T1HRDC/ KHRDW1
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1LVIS/ WINLIN,WNDOIN,MASKIN
      COMMON /T1MRKS/ MARKC1
      COMMON /T3CONS/ PI
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA LIMCHR /30/, LIMDEF /500/
C
C          THE FOLLOWING ARE STATEMENT FUNCTIONS TO CONVERT AN
C          ANGLE (RADIANS) INTO A QUADRANT NO., AND TO CONVERT
C          A QUADRANT NO. INTO A CARDINAL DIRECTION (RADIANS):
C
      KQUADR(STANG1)= (STANG1*2.0/PI)+0.5
      QUADR(STANG1)= 0.5*PI*KQUADR(STANG1)
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.17) RETURN
      GO TO (1,2,3,4,5,6,7,8,9,10,14,21,22,23,24,26,31), IFUNCO
C
C          THIS SETS HARDWARE/SOFTWARE CHARS.
C
    1 KHRDW1= .FALSE.
      IF (IDATA(1).EQ.1) KHRDW1= .TRUE.
C
      CALL G1HRDW(6)
      CALL G1HRDW(7)
      GO TO 11
C
C          THIS SETS THE FONT NUMBER.
C
    2 IF (KFONT1.EQ.IDATA(1)) RETURN
C
      KFONT1= IDATA(1)
      IF (KFONT1.LT.0.OR.KFONT1.GT.25) KFONT1= 1
      IF (KFONT1.GT.3.AND.KFONT1.LT.11) KFONT1= 1
      IF (KFONT1.GE.11) CALL G1CHIO(1,0)
      RETURN
C
C          THIS SETS THE CHARACTER MAGNIFICATION.
C
    3 MAGN1= IDATA(1)
      GO TO 13
C
C          THIS SETS THE NOMINAL CHAR. STRING ANGLE.
C
    4 STANG1= RDATA(1)
      GO TO 11
C
C          THIS SETS THE NOMINAL CHAR. ROTATION ANGLE.
C
    5 CRANG1= RDATA(1)
      GO TO 12
C
C          THIS SETS ITALIC MODE.
C
    6 ITAL1= IDATA(1)
      IF (ITAL1.LT.0) ITAL1= 0
      IF (ITAL1.GT.1) ITAL1= 1
C
      CALL G1HRDW(6)
      RETURN
C
C          THIS SETS THE NUMBER OF UNDERLINES.
C
    7 IUNDL1= IDATA(1)
      IF (IUNDL1.LT.0) IUNDL1= 0
      IF (IUNDL1.GT.2) IUNDL1= 2
      RETURN
C
C          THIS SETS THE CHARACTER OBLATENESS.
C
    8 OBLAT1= ABS(RDATA(1))
      CALL G1HRDW(7)
      GO TO 13
C
C          THIS SETS THE MARKER CHARACTER.
C
    9 MARKC1= IDATA(1)
      RETURN
C
C          THIS SETS THE CHARACTER SPACE. IF THE SPACE IS
C          NOT OF FINITE AREA, TYPEWRITER MODE IS DISABLED.
C
   10 X1CHR1= RDATA(1)
      X2CHR1= RDATA(2)
      Y1CHR1= RDATA(3)
      Y2CHR1= RDATA(4)
      TYPMOD= .TRUE.
      IF (ABS(X2CHR1-X1CHR1).LT.RMINI.OR.
     &    ABS(Y2CHR1-Y1CHR1).LT.RMINI) TYPMOD= .FALSE.
C
C          WHENEVER THE CHAR. SPACE OR ANGLES ARE CHANGED, THE
C          CURRENTLY-USED ANGLES ARE REDEFINED. THEY ARE THE
C          SAME AS THE NOMINAL ANGLES WHEN THE FORMAT IS FREE,
C          BUT IN TYPEWRITER MODE THESE ARE INSTEAD CONVERTED
C          TO THE NEAREST CARDINAL DIRECTIONS. WHEN HARDWARE
C          CHARACTERS ARE BEING DONE, THE CALL TO <G1HRDW>
C          SETS THE APPROPRIATE HARDWARE CHARACTER ROTATION.
C
   11 STANGU= STANG1
      IF (TYPMOD) STANGU= QUADR(STANG1)
C
      SINSTR= SIN(STANGU)
      COSSTR= COS(STANGU)
   12 CRANGU= STANG1+CRANG1
      IF (TYPMOD) CRANGU= STANGU+QUADR(CRANG1)
C
      SINCHR= SIN(CRANGU)
      COSCHR= COS(CRANGU)
      CALL G1HRDW(2)
C
C          THE CHARACTER AND LINE SPACINGS ARE THEN CALCULATED
C          USING THE FORMAT RATIOS OF 6:7 AND 10:7 RESPECTIVELY.
C          WHEN HARDWARE CHARS. ARE BEING DONE, THE CALL TO
C          <G1HRDW> SETS THE MOST SUITABLE HARDWARE CHAR. SIZE.
C          DEPENDING ON THE (RELATIVE) CHAR. ROTATION USED, THE
C          CHAR. AND LINE SPACINGS MAY HAVE TO BE INTERCHANGED.
C          THE INCREMENTS ARE ADJUSTED TO ENSURE CLOSE PACKING.
C          THE X AND Y COMPONENTS OF THE SPACINGS ARE THEN FOUND.
C
   13 ADDSP= MAGN1*8.571429E-4*OBLAT1
      CALL G1CHSP
      RETURN
C
C          THIS SECTION DRAWS A STRING OF CHARACTERS (LEAVING
C          THE CHAR. POSITION AT THE END). CHARACTERS ARE NOT
C          SUBJECT TO THE PROGRAM WINDOW OR MASK AREAS UNLESS
C          THESE OPTIONS HAVE BEEN ACTIVATED. IF A LINE PATTERN
C          HAS BEEN SET, FULL LINES ARE TEMPORARILY SUBSTITUTED.
C
   14 IF (KWIND1.EQ.0) WNDOIN= .FALSE.
      IF (KMASK1.EQ.0) MASKIN= .FALSE.
C
      LPSAV(1)= MARKA1
      LPSAV(2)= MISSA1
      LPSAV(3)= MARKB1
      LPSAV(4)= MISSB1
      MARKA1= 0
      MISSA1= 0
      MARKB1= 0
      MISSB1= 0
      LINSAV= LHRDW1
      LHRDW1= .FALSE.
      IF (LINSAV) CALL G1HRDW(1)
C
C          EACH CHAR. IS TAKEN IN TURN FROM THE (UNPACKED)
C          ARRAY [IDATA], <G1CHAR> DRAWS IT, THEN <G1MOVC>
C          INCREMENTS THE POSITION BY ONE SPACE. <RUBOUT>
C          AND ALL THE CONTROL CODES EXCEPT <BACKSPACE>
C          (CHARACTER CODES 0-7, 9-31 AND 127) ARE IGNORED.
C
      LENTH= IABS(LENGTH)
C
C          FONTS 11 - 24 ARE HIGH-QUALITY FONTS.
C
      IF (KFONT1.GE.11.AND..NOT.KHRDW1) GO TO 16
C
C          ADJUST START POSITION IF CENTRE OR RIGHT JUSTIFIED.
C
      IF (JUSTYP.EQ.1) CALL G1MOVC(4,LENTH-1)
      IF (JUSTYP.EQ.2) CALL G1MOVC(3,LENTH)
C
      DO 100 ICHAR= 1,LENTH
        NCHAR= IDATA(ICHAR)
        IF (KFONT1.EQ.0)  GO TO 15
        IF (NCHAR.EQ.127) GO TO 100
        IF (NCHAR.EQ.8)   CALL G1MOVC(3,1)
        IF (NCHAR.LT.32)  GO TO 100
C
   15   CALL G1CHAR(NCHAR)
        CALL G1MOVC(1,1)
  100 CONTINUE
C
      GO TO 20
C
C       SAVE CHARACTER WIDTH, RESTORE AFTER STRING DONE.
C
   16 SAVADS= ADDSP
      IF (JUSTYP.LE.0) GO TO 18
C
C       HANDLE CENTRE AND RIGHT JUSTIFICATION BY ADJUSTING START POSN.
C
      IF (LENTH.LT.2) GO TO 17
C
      DO 200 ICHR= 2,LENTH
        ADDSP= WIDCHR(IDATA(ICHR)+1)*SAVADS
        CALL G1CHSP
        IF (JUSTYP.EQ.1) CALL G1MOVC(4,1)
        IF (JUSTYP.EQ.2) CALL G1MOVC(3,1)
  200 CONTINUE
C
   17 IF(JUSTYP.LT.2) GO TO 18
C
      ADDSP= WIDCHR(IDATA(1)+1)*SAVADS
      CALL G1CHSP
      CALL G1MOVC(4,1)
      ADDSP= WIDCHR(IDATA(LENTH)+1)*SAVADS
      CALL G1CHSP
      CALL G1MOVC(2,1)
      ADDSP= SAVADS
      CALL G1CHSP
      CALL G1MOVC(3,1)
C
C       CHARS. ARE NOW OUTPUT ONE BY ONE, EACH FOLLOWED BY A CALL OF
C       G1MOVC TO ADVANCE THE TYPING POSITION BY A SUITABLE AMOUNT
C
   18 ADDSP= WIDCHR(IDATA(1)+1)*SAVADS
      CALL G1CHSP
      CALL G1MOVC(4,1)
C
      DO 300 ICHR= 1,LENTH
        NCHAR= IDATA(ICHR)
        IF (NCHAR.EQ.127) GO TO 300
        IF (NCHAR.NE.8) GO TO 19
        IF (ICHR.GT.1) ADDSP= PRVSP
        IF (ICHR.LE.1) ADDSP= SAVADS
C
        CALL G1CHSP
        CALL G1MOVC(3,1)
   19   IF (NCHAR.LT.32) GO TO 300
C
        ADDSP= WIDCHR(NCHAR+1)*SAVADS
C
C       PRESERVE WIDTH IN CASE FOLLOWED BY BACKSPACE.
C
        PRVSP= ADDSP
        CALL G1CHSP
        CALL G1MOVC(2,1)
        CALL G1CHAR(NCHAR)
        IF (ICHR.EQ.LENTH) GO TO 300
C
        CALL G1MOVC(2,1)
  300 CONTINUE
C
C       RESTORE INITIAL CHARACTER WIDTH
C
      ADDSP= SAVADS
      CALL G1CHSP
      CALL G1MOVC(1,1)
C
C          LASTLY, THE PREVIOUS STATE IS RESTORED.
C
   20 MARKA1= LPSAV(1)
      MISSA1= LPSAV(2)
      MARKB1= LPSAV(3)
      MISSB1= LPSAV(4)
      LHRDW1= LINSAV
      IF (LHRDW1) CALL G1HRDW(1)
C
      MASKIN= .TRUE.
      IF (.NOT.WINLIN) WNDOIN= .TRUE.
      RETURN
C
C          THIS DOES A MOVE OF THE CHARACTER-POSITION.
C
   21 CALL G1MOVC(IDATA(1),IDATA(2))
      RETURN
C
C          THIS SETS THE CHARACTER WINDOW MODE.
C
   22 KWIND1= 0
      IF (IDATA(1).NE.0) KWIND1= 1
      RETURN
C
C          THIS SETS THE CHARACTER MASKING MODE.
C
   23 KMASK1= 0
      IF (IDATA(1).NE.0) KMASK1= 1
      RETURN
C
C          THIS STACKS/UNSTACKS CHARACTER DEFINITIONS.
C
   24 IF (IDATA(1).NE.0) GO TO 25
C
C          THIS STACKS THE CURRENT DEFINITIONS.
C
      IF (NDEFS.LE.0) RETURN
C
      KSTRT= NDEFS+1
      KNUM(NDEFS)= KNUM(NDEFS)+1000
      RETURN
C
C          THIS UNSTACKS THE PREVIOUS DEFINITIONS.
C
   25 NDEFS= KSTRT-1
      IF (NDEFS.LE.0)                RETURN
C
      KNUM(NDEFS)= KNUM(NDEFS)-1000
      IF (KNUM(NDEFS)/1000.GT.0)     RETURN
C
      KSTRT= NDEFS
      LIMIT= NDEFS-1
      IF (LIMIT.LE.0)                RETURN
C
      DO 400 LOOK= 1,LIMIT
        IF (KNUM(KSTRT-1)/1000.GT.0) RETURN
C
        KSTRT= KSTRT-1
  400 CONTINUE
      RETURN
C
C          THIS REDEFINES CHARACTERS IN FONT-0. (ONLY
C          CHARACTERS NUMBERED 0 - 159 CAN BE REDEFINED).
C
C          THIS PART FINDS THE POSITION <INDCHR> IF
C          THE CHARACTER HAS ALREADY BEEN REDEFINED.
C
   26 NCHAR= IDATA(1)
      LNSPEC= IABS(LENGTH)-1
      IF (NDEFS-KSTRT.LT.0) GO TO 29
C
      INDCHR= 0
C
      DO 500 LOOK= KSTRT,NDEFS
        INDCHR= INDCHR+1
        IF (NCHAR.EQ.KNUM(LOOK)) GO TO 27
  500 CONTINUE
C
      GO TO 29
C
C          THIS PART DELETES A PREVIOUS DEFINITION
C          UNLESS THE NEW ONE HAS THE SAME LENGTH.
C
   27 IF (KLEN(INDCHR).EQ.LNSPEC) GO TO 30
      IF (INDCHR.EQ.NDEFS)        GO TO 28
C
      LIMIT1= KPOSN(INDCHR+1)+1
      LIMIT2= KPOSN(NDEFS)+KLEN(NDEFS)-1
      IOFSET= KLEN(INDCHR)
C
      DO 600 IFROM= LIMIT1,LIMIT2
        ITO= IFROM-IOFSET
        KSPEC(ITO)= KSPEC(IFROM)
  600 CONTINUE
C
      LAST= NDEFS-1
C
      DO 700 ITO= INDCHR,LAST
        KNUM(ITO)= KNUM(ITO+1)
        KLEN(ITO)= KLEN(ITO+1)
  700 CONTINUE
C
      LAST= NDEFS-2
      IF (INDCHR.GT.LAST) GO TO 28
C
      DO 800 ICHAR= INDCHR,LAST
        KPOSN(ICHAR+1)= KPOSN(ICHAR)+KLEN(ICHAR)
  800 CONTINUE
C
   28 NDEFS= NDEFS-1
C
C          THIS PART INSERTS THE NEW DEFINITION (IF IT
C          EXISTS) PROVIDED THERE IS SUFFICIENT SPACE.
C
   29 IF (LNSPEC.EQ.0) RETURN
C
      LEFT= LIMDEF
      IF (NDEFS.GT.0) LEFT= LIMDEF-(KPOSN(NDEFS)+KLEN(NDEFS))
      IF (NDEFS.GE.LIMCHR) GO TO 901
      IF (LNSPEC.GT.LEFT)  GO TO 901
C
      INDCHR= NDEFS+1
      KNUM(INDCHR)= NCHAR
      KLEN(INDCHR)= LNSPEC
      IF (INDCHR.GT.1) KPOSN(INDCHR)= KPOSN(NDEFS)+KLEN(NDEFS)
C
      NDEFS= NDEFS+1
   30 IFROM= 2
      LIMIT1= KPOSN(INDCHR)+1
      LIMIT2= LIMIT1+KLEN(INDCHR)
C
      DO 900 ITO= LIMIT1,LIMIT2
        KSPEC(ITO)= IDATA(IFROM)
        IFROM= IFROM+1
  900 CONTINUE
C
      RETURN
C
C          THIS PART ALTERS THE CURRENT JUSTIFICATION TYPE.
C          0 IS LEFT, 1 IS CENTRE, AND 2 IS RIGHT.
C
   31 JUSTYP= IDATA(1)
      RETURN
C
C          THIS WRITES OUT AN ERROR MESSAGE.
C
  901 NUMERR= 1004
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
C
      RETURN
      END
      SUBROUTINE G3FLIN(NMFILE,NMPICT,LFILEN,LPICTN,NUMPIC)
C
C          ------------------------------------------------
C          ROUTINE NO. (3003)   VERSION (A7.1B)   11:FEB:85
C          ------------------------------------------------
C
C          THIS READS GRID DATA FROM THE GIVEN GRIDFILE
C          AND CALLS THE APPROPRIATE CLASS ROUTINES TO
C          PERFORM THE REQUIRED OPERATIONS. IF A PICTURE
C          NAME OR NUMBER IS SUPPLIED, ONLY THAT ONE IS
C          DONE; OTHERWISE THE WHOLE GRIDFILE IS DONE.
C
C          (THIS VERSION IS A DUMMY ONE FOR DEVICE-MODE ONLY).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <NMFILE> THE FILE NAME.
C          <NMPICT> THE PICTURE NAME.
C          <LFILEN> THE NO. OF CHARS. IN THE FILE NAME.
C          <LPICTN> THE NO. OF CHARS. IN THE PICTURE NAME.
C          <NUMPIC> THE PICTURE NUMBER (IF > 0, THIS TAKES
C                   PRECEDENCE OVER THE PICTURE NAME).
C
C
      INTEGER NMFILE(32),NMPICT(4)
C
C
      RETURN
      END
      SUBROUTINE G3FLSV(NMFILE,NMPICT,LFILEN,LPICTN)
C
C          ------------------------------------------------
C          ROUTINE NO. (3005)   VERSION (A7.1B)   11:FEB:85
C          ------------------------------------------------
C
C          THIS TAKES THE PICTURE IN THE OUTPUT GRIDFILE
C          AND SAVES IT INTO THE GIVEN PICTURE AND GRIDFILE.
C
C          (THIS VERSION IS A DUMMY ONE FOR DEVICE MODE ONLY).
C
C
      INTEGER NMFILE(32),NMPICT(4)
C
C
      RETURN
      END
      SUBROUTINE G3GRIN(ICOMND,XLOCV,YLOCV,XLOCN,YLOCN,NREPC)
C
C          ------------------------------------------------
C          ROUTINE NO. (3004)   VERSION (A7.1A)   11:FEB:85
C          ------------------------------------------------
C
C          THIS PROVIDES GRAPHICAL INPUT FACILITIES.
C          (THIS VERSION IS FOR DEVICES WITHOUT GRAPHICAL INPUT).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICOMND> SETS THE INPUT ACTION:
C                   = 1, THE DEVICE CURSOR IS ACTIVATED,
C                   = 2, THE LOCATOR POSITIONS ARE RETURNED;
C          <XLOCV>  IS THE LOCATOR X-COORDINATE IN VECTOR SPACE;
C          <YLOCV>  IS THE LOCATOR Y-COORDINATE IN VECTOR SPACE;
C          <XLOCN>  IS THE LOCATOR X-COORDINATE IN ND-SPACE;
C          <YLOCN>  IS THE LOCATOR Y-COORDINATE IN ND-SPACE;
C          <NREPC>  IS THE (GHOST) REPLY CHARACTER NUMBER.
C
C
      LOGICAL GFOPEN,PPOPEN
C
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1PPOS/ XPLOT1,YPLOT1
      COMMON /T1REPN/ NREPLC
      COMMON /T3OUTS/ GFOPEN,PPOPEN
C
C
      IF (.NOT.PPOPEN) RETURN
      IF (ICOMND.EQ.2) GO TO 1
C
C          THE DEVICE CURSOR CANNOT BE ACTIVATED WITH THIS VERSION.
C          AN EXCLAMATION MARK IS GIVEN AS THE REPLY CHARACTER.
C
      NREPLC= 33
      RETURN
C
C          IN THIS VERSION, THE CURRENT PLOTTING POSITIONS ARE GIVEN.
C
    1 XLOCV= XPLOT1
      YLOCV= YPLOT1
      XLOCN= XPLOTB
      YLOCN= YPLOTB
      NREPC= NREPLC
C
      RETURN
      END
      SUBROUTINE G3INIT(ITYPE)
C
C          ------------------------------------------------
C          ROUTINE NO. (3002)   VERSION (A8.3B)   17:NOV:89
C          ------------------------------------------------
C
C          THIS INITIALISES GHOST STATE VARIABLES.
C          (THIS VERSION IS FOR DEVICE-MODE WORKING).
C
C
C     ******************************************************************
C     *                                                                *
C     *    NOTE: ALL GHOST DEVICE-INDEPENDENT COMMON BLOCKS ARE        *
C     *          SPECIFIED HERE. TO ENSURE THEIR INTEGRITY IT IS       *
C     *          ESSENTIAL THAT THIS ROUTINE CANNOT BE SWAPPED-OUT.    *
C     *                                                                *
C     ******************************************************************
C
C
C          <ITYPE> CONTROLS THE ACTION AS FOLLOWS:
C
C          =  1, INITIALISATION IS DONE UNCONDITIONALLY.
C          =  2, INITIALISATION IS DONE ONLY IF NOT ALREADY DONE.
C
C
      REAL    HTANGA(24,2),HTANGB(24,2)
      INTEGER IPITHA(24,2),IHATA(24),
     &        IHMKAB(24,2),IHMSAB(24,2),IHMKBB(24,2),IHMSBB(24,2),
     &        IPHASB(24,2),IPITHB(24,2),IPSFTB(24,2)
      LOGICAL DONE
      LOGICAL TYPMOD,KHRDW1,OPEN,LHRDW1,OPCURV,FULL,NEWPIC,INTRAC,
     &        SCRTCH,ERRON,GFOPEN,PPOPEN,BOUND,
     &        SHIFT0,SHIFT1,CURTRA,WINLIN,WNDOIN,MASKIN,LINSAV
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ACON/ ANGCON
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0ANOX/ KANNX,NCHRSX,NAFTPX
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0ATYP/ KTYPEX,KTYPEY
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0BANG/ B3ANG
      COMMON /T0BASP/ SIZRAT
      COMMON /T0BBAS/ IBSTYP,BSORIG,BSMAX
      COMMON /T0BKLM/ KMTHOD
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CATT/ IUNDL0,ITAL0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CFON/ KFONT0
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CNLB/ LBLCON(10,50)
      COMMON /T0CNSV/ XPOSNS(100),YPOSNS(100),NCOPTS
      COMMON /T0COMS/ NOWCOM,NOWNUM
      COMMON /T0CSIZ/ CSIZE,MRKSIZ
      COMMON /T0CSLO/ SLOPE,MRKSLP
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0CURV/ MCURV0
      COMMON /T0CVIS/ KWIND0,KMASK0
      COMMON /T0DBND/ IDRBND
      COMMON /T0DEVS/ KCHAN0(5),IRESL0
      COMMON /T0FLTY/ IFLTY0,IFLRP0
      COMMON /T0HANG/ HTANG0(255,2)
      COMMON /T0HCOL/ IHCOL0(255,2)
      COMMON /T0HLST/ IHMKA0(255,2),IHMSA0(255,2),IHMKB0(255,2),
     &                IHMSB0(255,2)
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HOFF/ ISHFT0(255,2)
      COMMON /T0HPHS/ IPHAS0(255,2)
      COMMON /T0HPIT/ IPITH0(255,2)
      COMMON /T0HPSF/ IPSFT0(255,2)
      COMMON /T0HRDC/ KHRDW0
      COMMON /T0HRDL/ LHRDW0
      COMMON /T0HTYP/ IHAT0(255)
      COMMON /T0KBAC/ KOLBA0
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0KLAB/ LABCL0(100),LENLAB
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0KMAT/ MATCL0(55,55),MTROWS,MTCOLS
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0KTAB/ REDCO0(255),GRNCO0(255),BLUCO0(255),NCOLS0
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0LPAT/ MARKA0,MISSA0,MARKB0,MISSB0
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPD/ X1MAPD,X2MAPD,Y1MAPD,Y2MAPD
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPS/ ORIMX0,ORIMY0,SCAMX0,SCAMY0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0MASK/ X1MSK0(10),X2MSK0(10),Y1MSK0(10),Y2MSK0(10),MSKLV0
      COMMON /T0MRKS/ MARKC0
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0NOTA/ NOTATA
      COMMON /T0NOTC/ NOTATC
      COMMON /T0PIAN/ ANGPIE
      COMMON /T0PILM/ MPIELB
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
      COMMON /T0SAXE/ INDAXE,XAXORG,YAXORG,XAXDEL,YAXDEL
      COMMON /T0SBAS/ IUNDRS,INDBAS,BASEHT
      COMMON /T0SCOL/ LINCUP,LINCLW,LINCBS
      COMMON /T0SIND/ ISURIN
      COMMON /T0SSCA/ SHTMIN,SHTMAX,XPTCH
      COMMON /T0SSEC/ ISECTN
      COMMON /T0SUPF/ MAGBUF(5),MAGLVL
      COMMON /T0SVEW/ IVIEWN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T1BEPT/ IXFINI,IYFINI
      COMMON /T1BFSV/ LENFLB
      COMMON /T1BUFN/ KBUFR1
      COMMON /T1BUFS/ MSYSTB(200),LIMSYS,ISYSTP
      COMMON /T1BUFU/ MUSERB(3200),LENTHB,KINDEX,KLIMIT,KAREA,LIMARE,
     &                IAREAP(16),ISTRTA(16),KAREAS(16),NAREAS(16),
     &                INEXTA(32),FULL
      COMMON /T1C2SV/ LPSAV(4)
      COMMON /T1C5SV/ LINESV(4),ITHIKS,NFILLS,LINSAV
      COMMON /T1CANG/ STANG1,CRANG1
      COMMON /T1CANU/ STANGU,CRANGU
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDCC/ SINCHR,COSCHR
      COMMON /T1CDCS/ SINSTR,COSSTR
      COMMON /T1CDEF/ KSTRT,NDEFS,KNUM(30),KPOSN(30),KLEN(30),KSPEC(500)
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CFCH/ KFNTCH
      COMMON /T1CFIN/ INDLEN(2,256),WIDCHR(256)
      COMMON /T1CFON/ KFONT1
      COMMON /T1CHAD/ KDISPI,KDISPO
      COMMON /T1CJUS/ JUSTYP
      COMMON /T1CMOC/ ADDSPX,ADDLNX,ADDSPY,ADDLNY
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CMOV/ ADDSP,ADDLN
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1CRSV/ XCVSAV(3),YCVSAV(3),INDXCV,ICVPTR,
     &                DX1CV,DY1CV,XI1CV,YI1CV,NCVPTS,CUBX1,CUBY1
      COMMON /T1CSPA/ X1CHR1,X2CHR1,Y1CHR1,Y2CHR1
      COMMON /T1CURV/ MCURV1,OPCURV
      COMMON /T1CVIS/ KWIND1,KMASK1
      COMMON /T1DENA/ OPEN
      COMMON /T1DEVS/ KCHAN1(5),IRESL1
      COMMON /T1FLBF/ IXSAVE(2000),IYSAVE(2000),ISAVSZ,INDSAV
      COMMON /T1FLSV/ BOUND
      COMMON /T1FLTY/ IFLTY1,IFLRP1
      COMMON /T1FUND/ NUMFUN,LENARG
      COMMON /T1HANG/ HTANG1(255,2)
      COMMON /T1HCOL/ IHCOL1(255,2)
      COMMON /T1HLST/ IHMKA1(255,2),IHMSA1(255,2),IHMKB1(255,2),
     &                IHMSB1(255,2)
      COMMON /T1HNUM/ IHATN1
      COMMON /T1HOFF/ ISHFT1(255,2)
      COMMON /T1HPHS/ IPHAS1(255,2)
      COMMON /T1HPIT/ IPITH1(255,2)
      COMMON /T1HPSF/ IPSFT1(255,2)
      COMMON /T1HRDC/ KHRDW1
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1HRSV/ LHDEF
      COMMON /T1HTYP/ IHAT1(255)
      COMMON /T1KBAC/ KOLBA1
      COMMON /T1KFIL/ KOLFL1
      COMMON /T1KTAB/ REDCO1(255),GRNCO1(255),BLUCO1(255),NCOLS1
      COMMON /T1LAND/ LNDSCP
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LIND/ PATREM
      COMMON /T1LOCD/ XLOCAD,YLOCAD
      COMMON /T1LOCV/ XLOCAV,YLOCAV
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1LVIS/ WINLIN,WNDOIN,MASKIN
      COMMON /T1MAPP/ X1MAP1,X2MAP1,Y1MAP1,Y2MAP1
      COMMON /T1MAPS/ ORIMX1,ORIMY1,SCAMX1,SCAMY1
      COMMON /T1MAPT/ MAPNO1
      COMMON /T1MASK/ X1MSK1(10),X2MSK1(10),Y1MSK1(10),Y2MSK1(10),MSKLV1
      COMMON /T1MRKS/ MARKC1
      COMMON /T1PNUM/ NDPICS
      COMMON /T1PPAT/ XPLOTA,YPLOTA
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1PPOS/ XPLOT1,YPLOT1
      COMMON /T1REPN/ NREPLC
      COMMON /T1SHVS/ ISHRTX,ISHRTY,CLONGX,CLONGY
      COMMON /T1SPEC/ XSPEC(4600),YSPEC(4600),ICHPTR(128),NEXTPT,NSTORE
      COMMON /T1TCOB/ XCBX,XCBY,YCBX,YCBY,RPICXB,RPICYB,RDEVXB,RDEVYB
      COMMON /T1TCOC/ XCCX,XCCY,YCCX,YCCY,RPICXC,RPICYC,RDEVXC,RDEVYC,
     &                CURTRA
      COMMON /T1TCOR/ XRVX,XRVY,YRVX,YRVY,RPICXR,RPICYR,RDEVXR,RDEVYR
      COMMON /T1TRNC/ SCALXC,SCALYC,ROTATC
      COMMON /T1TRNS/ SCALXS,SCALYS,ROTATS,RDEVXS,RDEVYS
      COMMON /T1TRST/ SHIFT1,MTRAN1,KLIPM1,INDLVL
      COMMON /T1TSPA/ X1TYPW,X2TYPW,Y1TYPW,Y2TYPW
      COMMON /T1TYPQ/ IQUAD
      COMMON /T1WNDO/ X1WND1,X2WND1,Y1WND1,Y2WND1
      COMMON /T2INFI/ INFOFI(32),INFOPI(32)
      COMMON /T2INFO/ INFOFO(32),INFOPO(32)
      COMMON /T2INLI/ LNFOFI,LNFOPI
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNA/ NAMEFO(32),NAMEPO(4)
      COMMON /T2OPNL/ LNFILN,LNPICN
      COMMON /T2PNUM/ NGPICS,LIMPIC
      COMMON /T2SAVE/ SCRTCH
      COMMON /T3CONS/ PI
      COMMON /T3DEVT/ INTRAC
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MODE/ KMODE
      COMMON /T3OUTS/ GFOPEN,PPOPEN
      COMMON /T3PICM/ NEWPIC
      COMMON /T3PLVL/ LVLPIC
      COMMON /T3SHUT/ K1ERR,K2ERR
      COMMON /T3VBUF/ VBUFFR(63),LASCOD,INDXVB
C
      SAVE DONE
C
      DATA HTANGA /0.0,1.570796,-0.785398,0.785398,
     &             0.0,0.785398,0.523599,1.047198,
     &             0.0,1.570796,-0.785398,0.785398,
     &             0.0,0.785398,0.523599,1.047198,
     &             0.0,1.570796,-0.785398,0.785398,
     &             0.0,0.785398,0.523599,1.047198,
     &             0.0,1.570796,-0.785398,0.785398,
     &             1.570796,-0.785398,-0.523599,-1.047198,
     &             0.0,1.570796,-0.785398,0.785398,
     &             1.570796,-0.785398,-0.523599,-1.047198,
     &             0.0,1.570796,-0.785398,0.785398,
     &             1.570796,-0.785398,-0.523599,-1.047198/
      DATA HTANGB /0.0,0.785398,0.0,0.785398,0.0,0.0,0.0,
     &             0.785398,0.785398,0.785398,0.0,0.785398,
     &             0.0,0.785398,0.0,0.785398,0.0,0.0,0.0,
     &             0.785398,0.785398,0.785398,0.0,0.785398,
     &             1.570796,-0.785398,1.570796,-0.785398,
     &             1.570796,1.570796,1.570796,-0.785398,
     &             -0.785398,-0.785398,1.570796,-0.785398,
     &             1.570796,-0.785398,1.570796,-0.785398,
     &             1.570796,1.570796,1.570796,-0.785398,
     &             -0.785398,-0.785398,1.570796,-0.785398/
      DATA IPITHA /10,10,10,10,10,10,10,10,20,20,20,20,
     &             20,20,20,20,5,5,5,5,5,5,5,5,
     &             10,10,10,10,10,10,10,10,20,20,20,20,
     &             20,20,20,20,5,5,5,5,5,5,5,5/
      DATA IHATA  /1,1,1,1,3,3,3,3,1,1,1,1,3,3,3,3,
     &             1,1,1,1,3,3,3,3/
      DATA IHMKAB /8,8,10,10,0,0,40,20,20,20,30,30,
     &             4,4,5,5,0,0,20,10,10,10,15,14,
     &             8,8,10,10,10,15,40,20,20,20,20,30,
     &             4,4,5,5,5,8,20,10,10,10,10,14/
      DATA IHMSAB /12,12,10,10,0,0,20,20,10,10,20,10,
     &             6,6,5,5,0,0,10,10,5,5,10,6,
     &             12,12,10,10,10,15,20,20,10,10,10,10,
     &             6,6,5,5,5,8,10,10,5,5,5,6/
      DATA IHMKBB /8,8,10,10,0,0,40,20,20,20,30,30,
     &             4,4,5,5,0,0,20,10,10,10,15,14,
     &             8,8,10,10,10,15,40,20,20,20,10,30,
     &             4,4,5,5,5,8,20,10,10,10,5,14/
      DATA IHMSBB /12,12,10,10,0,0,20,20,10,10,20,10,
     &             6,6,5,5,0,0,10,10,5,5,10,6,
     &             12,12,10,10,10,15,20,20,10,10,10,10,
     &             6,6,5,5,5,8,10,10,5,5,5,6/
      DATA IPHASB /0,0,0,0,0,0,110,70,10,50,10,20,
     &             0,0,0,0,0,0,55,35,5,25,5,10,
     &             0,0,0,0,10,15,10,10,10,10,40,20,
     &             0,0,0,0,5,8,5,5,5,5,20,10/
      DATA IPITHB /20,20,10,10,10,15,10,10,10,10,10,20,
     &             10,10,5,5,5,8,5,5,5,5,5,10,
     &             20,20,10,10,15,10,10,10,10,10,10,20,
     &             10,10,5,5,8,5,5,5,5,5,5,10/
      DATA IPSFTB /4,4,0,0,0,0,0,20,10,0,0,15,
     &             2,2,0,0,0,0,0,10,5,0,0,7,
     &             4,4,0,0,0,0,10,0,0,20,20,35,
     &             2,2,0,0,0,0,5,0,0,10,10,17/
      DATA DONE /.FALSE./, CORNRL /-0.11765/, CORNRR /1.05882/
C
C
      IF (DONE.AND.ITYPE.EQ.2) RETURN
C
C          THE MACHINE DEPENDENT VARIABLES ARE INITIALISED
C          AND THE MESSAGE CHANNELS OPENED.
C
      CALL G3SYSI(1)
C
C          THE FOLLOWING ARE PRE-PROCESSOR COMMON BLOCKS:
C          ---------------------------------------------
C
C          ANGLE CONVERSION COEFFICIENT:
C
      ANGCON= 1.7453293E-2
C
C          AXES-DRAWING VALUES:
C
      DIVLX= 0.0
      NTIKLX= 0
      NTIKHX= 0
      DIVLY= 0.0
      NTIKLY= 0
      NTIKHY= 0
      KDIRX= 0
      KDIRY= 0
      AXPOSX= 0.0
      AXPOSY= 0.0
      NSKIPX= 0
      NDECSX= 0
      NSKIPY= 0
      NDECSY= 0
      KTYPEX= 0
      KTYPEY= 0
C
C          MAPPING TYPE:
C
      MAPNUM= 1
C
C          3-D BARCHART PARAMETERS
C
      B3ANG= 45.0
      SIZRAT= 0.75
      IBSTYP= 0
      BSORIG= 0.0
      BSMAX= 0.0
      KMTHOD= 0
C
C          BARCHART AND HISTOGRAM ORIENTATION:
C
      IBRTYP= 0
C
C          OUTPUT BUFFER NUMBER:
C
      KBUFR0= 0
C
C          CHARACTER VALUES:
C
      STANG0= 0.0
      CRANG0= 0.0
      IUNDL0= 0
      ITAL0= 0
      MAGN0= 10
      OBLAT0= 1.0
      KFONT0= 1
      LLBCON= 0
      NOWCOM= 33
      NOWNUM= 35
      CSIZE= 0.0
      MRKSIZ= 0
      SLOPE= 0.0
      MRKSLP= 0
      X1CHR0= 0.0
      X2CHR0= 0.0
      Y1CHR0= 0.0
      Y2CHR0= 0.0
C
C          CURVE-DRAWING METHOD NUMBER:
C
      MCURV0= 1
C
C          CHARACTER VISIBILITY MODES:
C
      KWIND0= 0
      KMASK0= 0
      IDRBND= 1
C
C
C          CHANNEL INDICATOR/DEVICE RESOLUTION FACTOR:
C
      KCHAN0(1)= 0
      KCHAN0(2)= 0
      KCHAN0(3)= 0
      KCHAN0(4)= 0
      KCHAN0(5)= 0
      IRESL0= 1
C
C          CROSS-HATCHING VALUES:
C
      IFLTY0= 0
      IFLRP0= 0
      IHATN0= 65
C
      DO 100 ISET= 1,255
        HTANG0(ISET,1)= 0.785398
        HTANG0(ISET,2)= -0.785398
        IHCOL0(ISET,1)= 0
        IHCOL0(ISET,2)= 0
        IHMKA0(ISET,1)= 0
        IHMKA0(ISET,2)= 0
        IHMSA0(ISET,1)= 0
        IHMSA0(ISET,2)= 0
        IHMKB0(ISET,1)= 0
        IHMKB0(ISET,2)= 0
        IHMSB0(ISET,1)= 0
        IHMSB0(ISET,2)= 0
        ISHFT0(ISET,1)= 0
        ISHFT0(ISET,2)= 0
        IPHAS0(ISET,1)= 0
        IPHAS0(ISET,2)= 0
        IPITH0(ISET,1)= 10
        IPITH0(ISET,2)= 10
        IPSFT0(ISET,1)= 0
        IPSFT0(ISET,2)= 0
        IHAT0(ISET)= 3
  100 CONTINUE
C
      DO 200 ISET= 1,24
        HTANG0(ISET,1)= HTANGA(ISET,1)
        HTANG0(ISET,2)= HTANGA(ISET,2)
        IPITH0(ISET,1)= IPITHA(ISET,1)
        IPITH0(ISET,2)= IPITHA(ISET,2)
        IHAT0(ISET)= IHATA(ISET)
  200 CONTINUE
C
      DO 300 ISET= 33,56
        HTANG0(ISET,1)= HTANGB(ISET-32,1)
        HTANG0(ISET,2)= HTANGB(ISET-32,2)
        IHMKA0(ISET,1)= IHMKAB(ISET-32,1)
        IHMKA0(ISET,2)= IHMKAB(ISET-32,2)
        IHMSA0(ISET,1)= IHMSAB(ISET-32,1)
        IHMSA0(ISET,2)= IHMSAB(ISET-32,2)
        IHMKB0(ISET,1)= IHMKBB(ISET-32,1)
        IHMKB0(ISET,2)= IHMKBB(ISET-32,2)
        IHMSB0(ISET,1)= IHMSBB(ISET-32,1)
        IHMSB0(ISET,2)= IHMSBB(ISET-32,2)
        IPHAS0(ISET,1)= IPHASB(ISET-32,1)
        IPHAS0(ISET,2)= IPHASB(ISET-32,2)
        IPITH0(ISET,1)= IPITHB(ISET-32,1)
        IPITH0(ISET,2)= IPITHB(ISET-32,2)
        IPSFT0(ISET,1)= IPSFTB(ISET-32,1)
        IPSFT0(ISET,2)= IPSFTB(ISET-32,2)
  300 CONTINUE
C
C          CHARACTER/LINE HARDWARE MODES:
C
      KHRDW0= 0
      LHRDW0= 0
C
C          DEFAULT COLOUR DEFINITIONS:
C
      KOLBA0= 0
      KOLFL0= 0
      LENLAB= 0
      LENLST= 0
      MTROWS= 0
      MTCOLS= 0
      KOLSYS= 1
C
      DO 400 NCOLOR= 1,255
        REDCO0(NCOLOR)= 0.0
        GRNCO0(NCOLOR)= 0.0
        BLUCO0(NCOLOR)= 0.0
  400 CONTINUE
C
      REDCO0(2)= 1.0
      REDCO0(5)= 1.0
      REDCO0(7)= 1.0
      REDCO0(8)= 1.0
      GRNCO0(3)= 1.0
      GRNCO0(5)= 1.0
      GRNCO0(6)= 1.0
      GRNCO0(8)= 1.0
      BLUCO0(4)= 1.0
      BLUCO0(5)= 1.0
      BLUCO0(6)= 1.0
      BLUCO0(7)= 1.0
      NCOLS0= 8
C
C          LINE ATTRIBUTES/VALUES:
C
      KOLIN0= 0
      ITHIK0= 1
      MARKA0= 0
      MISSA0= 0
      MARKB0= 0
      MISSB0= 0
C
C          MAPPING VALUES:
C
      MRKMAP= 0
      MRKWIN= 0
      X1MAPV= 0.0
      X2MAPV= 1.0
      Y1MAPV= 0.0
      Y2MAPV= 1.0
      X1MAPD= 0.1
      X2MAPD= 0.95
      Y1MAPD= 0.1
      Y2MAPD= 0.95
      X1MAP0= CORNRL
      X2MAP0= CORNRR
      Y1MAP0= CORNRL
      Y2MAP0= CORNRR
      ORIMX0= X1MAP0
      ORIMY0= Y1MAP0
      SCAMX0= 0.85
      SCAMY0= 0.85
      MAPNO0= 1
C
C          MASKING VALUES:
C
      DO 500 ISET= 1,10
        X1MSK0(ISET)= 0.0
        X2MSK0(ISET)= 0.0
        Y1MSK0(ISET)= 0.0
        Y2MSK0(ISET)= 0.0
  500 CONTINUE
C
      MSKLV0= 0
C
C          MARKER CHARACTER:
C
      MARKC0= 232
C
C          FLAGS FOR INCBAR, INCHIS, MULBAR AND MULHIS.
C
      DO 600 ISET= 1,100
        INFLGS(ISET)= 1
  600 CONTINUE
C
C          ANNOTATION MODES:
C
      NOTATA= 10
      NOTATC= 62
C
C          PIECHART FIRST SECTOR ANGLE:
C
      ANGPIE= 0.0
C
C          PIECHART LABELLING METHOD:
C
      MPIELB= 1
C
C          INITIAL PLOTTING POSITION:
C
      XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
C
C          SURFACE TILT ANGLES:
C
      TLTANG= 0.61548
      CSROOT= 1.1547
      COSANG= 0.8660254
      SINANG= 0.5
C
C          SURFACE AXIS ANNOTATION PARAMETERS:
C
      INDAXE= 0
      XAXORG= 0.0
      YAXORG= 0.0
      XAXDEL= 0.0
      YAXDEL= 0.0
C
C          SURFACE BASE PARAMETERS:
C
      IUNDRS= 1
      INDBAS= 0
      BASEHT= 0.0
C
C          SURFACE COLOUR NUMBERS:
C
      LINCUP= 0
      LINCLW= 2
      LINCBS= 0
C
C          SURFACE DIRECTION INDICATOR:
C
      ISURIN= 1
C
C          SURFACE HEIGHT LIMITS AND X SCALE FACTOR:
C
      SHTMIN= 0.0
      SHTMAX= 0.0
      XPTCH= 1.0
C
C          SURFACE SECTION TYPE:
C
      ISECTN= 0
C
C          SUFFIX/SUPERFIX LEVEL:
C
      MAGLVL= 0
C
C          SURFACE VIEW DIRECTION:
C
      IVIEWN= 0
C
C          TRACE LEVEL:
C
      IPRINT= 0
C
C          TRANSFORMATION VALUES:
C
      SCALX0= 1.0
      SCALY0= 1.0
      ROTAT0= 0.0
      RPICX0= 0.0
      RPICY0= 0.0
      RDEVX0= 0.0
      RDEVY0= 0.0
      VRPICX= X1MAP0
      VRPICY= Y1MAP0
      VRDEVX= X1MAP0
      VRDEVY= Y1MAP0
      SHIFT0= .FALSE.
      MTRAN0= 1
      KLIPM0= 0
C
C          WINDOW VALUES:
C
      X1WND0= 0.0
      X2WND0= 1.0
      Y1WND0= 0.0
      Y2WND0= 1.0
C
C          THE FOLLOWING ARE DEVICE-HANDLER COMMON BLOCKS:
C          ----------------------------------------------
C
C          OUTPUT-BUFFER STATE VARIABLES:
C
      IXFINI= -1
      IYFINI= -1
      LENFLB= 0
      KBUFR1= 0
      LIMSYS= 200
      ISYSTP= 0
      LENTHB= 3200
C
      DO 700 ICLEAR= 1,16
        IAREAP(ICLEAR)= 0
        ISTRTA(ICLEAR)= 0
        KAREAS(ICLEAR)= 0
        NAREAS(ICLEAR)= 0
  700 CONTINUE
C
      DO 800 ICLEAR= 1,32
        INEXTA(ICLEAR)= 0
  800 CONTINUE
C
      FULL= .FALSE.
C
C          CHARACTER VALUES:
C
      STANG1= 0.0
      CRANG1= 0.0
      STANGU= 0.0
      CRANGU= 0.0
      IUNDL1= 0
      ITAL1= 0
      SINCHR= 0.0
      COSCHR= 1.0
      SINSTR= 0.0
      COSSTR= 1.0
      KSTRT= 1
      NDEFS= 0
      KPOSN(1)= 0
      MAGN1= 10
      OBLAT1= 1.0
      KFONT1= 1
C
C          DISPLAY I/O CHANNELS:
C
      IF (.NOT.DONE) KDISPI= -1
      IF (.NOT.DONE) KDISPO= -1
C
      ADDSP= 8.571429E-3
      ADDLN= 1.428571E-2
      ADDSPX= ADDSP
      ADDLNX= 0.0
      ADDSPY= 0.0
      ADDLNY= -ADDLN
      TYPMOD= .FALSE.
      XCHAR= 0.0
      YCHAR= 0.0
C
C          CURVE POINTER (OWN VARIABLE):
C
      ICVPTR= 3
C
C          CHARACTER WINDOW/MASK MODES:
C
      KWIND1= 0
      KMASK1= 0
C
C          DEVICE STATE:
C
      OPEN= .FALSE.
      KCHAN1(1)= 0
      KCHAN1(2)= 0
      KCHAN1(3)= 0
      KCHAN1(4)= 0
      KCHAN1(5)= 0
      IRESL1= 1
C
C          FILL AREA BUFFER SIZE (OWN VARIABLE):
C
      ISAVSZ= 2000
C
C          FILL-AREA BOUNDARY MARKER (OWN VARIABLE):
C
      BOUND= .FALSE.
C
C          CURRENT FUNCTION CODE/DATA LENGTH (OWN VARIABLES):
C
      NUMFUN= 0
      LENARG= 0
C
C          CROSS-HATCHING VALUES:
C
      IFLTY1= 0
      IFLRP1= 0
      IHATN1= 65
C
      DO 900 ISET= 1,255
        HTANG1(ISET,1)= 0.785398
        HTANG1(ISET,2)= -0.785398
        IHCOL1(ISET,1)= 0
        IHCOL1(ISET,2)= 0
        IHMKA1(ISET,1)= 0
        IHMKA1(ISET,2)= 0
        IHMSA1(ISET,1)= 0
        IHMSA1(ISET,2)= 0
        IHMKB1(ISET,1)= 0
        IHMKB1(ISET,2)= 0
        IHMSB1(ISET,1)= 0
        IHMSB1(ISET,2)= 0
        ISHFT1(ISET,1)= 0
        ISHFT1(ISET,2)= 0
        IPHAS1(ISET,1)= 0
        IPHAS1(ISET,2)= 0
        IPITH1(ISET,1)= 10
        IPITH1(ISET,2)= 10
        IPSFT1(ISET,1)= 0
        IPSFT1(ISET,2)= 0
        IHAT1(ISET)= 3
  900 CONTINUE
C
      DO 1000 ISET= 1,24
        HTANG1(ISET,1)= HTANGA(ISET,1)
        HTANG1(ISET,2)= HTANGA(ISET,2)
        IPITH1(ISET,1)= IPITHA(ISET,1)
        IPITH1(ISET,2)= IPITHA(ISET,2)
        IHAT1(ISET)= IHATA(ISET)
 1000 CONTINUE
C
      DO 1100 ISET= 33,56
        HTANG1(ISET,1)= HTANGB(ISET-32,1)
        HTANG1(ISET,2)= HTANGB(ISET-32,2)
        IHMKA1(ISET,1)= IHMKAB(ISET-32,1)
        IHMKA1(ISET,2)= IHMKAB(ISET-32,2)
        IHMSA1(ISET,1)= IHMSAB(ISET-32,1)
        IHMSA1(ISET,2)= IHMSAB(ISET-32,2)
        IHMKB1(ISET,1)= IHMKBB(ISET-32,1)
        IHMKB1(ISET,2)= IHMKBB(ISET-32,2)
        IHMSB1(ISET,1)= IHMSBB(ISET-32,1)
        IHMSB1(ISET,2)= IHMSBB(ISET-32,2)
        IPHAS1(ISET,1)= IPHASB(ISET-32,1)
        IPHAS1(ISET,2)= IPHASB(ISET-32,2)
        IPITH1(ISET,1)= IPITHB(ISET-32,1)
        IPITH1(ISET,2)= IPITHB(ISET-32,2)
        IPSFT1(ISET,1)= IPSFTB(ISET-32,1)
        IPSFT1(ISET,2)= IPSFTB(ISET-32,2)
 1100 CONTINUE
C
C          CHARACTER/LINE HARDWARE MODE:
C
      KHRDW1= .FALSE.
      LHRDW1= .FALSE.
C
C          SAVED LINE HARDWARE MODE (OWN VARIABLE):
C
      LHDEF= 1
C
C          DEFAULT COLOUR DEFINITIONS:
C
      KOLBA1= 0
C
      DO 1200 NCOLOR= 1,255
        REDCO1(NCOLOR)= 0.0
        GRNCO1(NCOLOR)= 0.0
        BLUCO1(NCOLOR)= 0.0
 1200 CONTINUE
C
      REDCO1(2)= 1.0
      REDCO1(5)= 1.0
      REDCO1(7)= 1.0
      REDCO1(8)= 1.0
      GRNCO1(3)= 1.0
      GRNCO1(5)= 1.0
      GRNCO1(6)= 1.0
      GRNCO1(8)= 1.0
      BLUCO1(4)= 1.0
      BLUCO1(5)= 1.0
      BLUCO1(6)= 1.0
      BLUCO1(7)= 1.0
C
C          LANDSCAPE FLAG
C
      LNDSCP= 0
C
C          LINE ATTRIBUTES:
C
      KOLIN1= 0
      ITHIK1= 1
      PATREM= 0.0
      MARKA1= 0
      MISSA1= 0
      MARKB1= 0
      MISSB1= 0
C
C          MAP VALUES:
C
      X1MAP1= CORNRL
      X2MAP1= CORNRR
      Y1MAP1= CORNRL
      Y2MAP1= CORNRR
      ORIMX1= X1MAP1
      ORIMY1= Y1MAP1
      SCAMX1= 0.85
      SCAMY1= 0.85
      MAPNO1= 1
C
C          MASK LEVEL:
C
      MSKLV1= 0
C
C          MARKER CHARACTER:
C
      MARKC1= 232
C
C          DEVICE PICTURE COUNT:
C
      NDPICS= 1
C
C          INITIAL PLOTTING POSITION (AFTER/BEFORE TRANSFORMATION):
C
      XPLOTA= 0.0
      YPLOTA= 0.0
      XPLOTB= 0.0
      YPLOTB= 0.0
      XPLOT1= CORNRL
      YPLOT1= CORNRL
C
C          TRANSFORMATION COEFFICIENTS:
C
      XCBX= 1.0
      XCBY= 0.0
      YCBX= 0.0
      YCBY= 1.0
      RPICXB= 0.0
      RPICYB= 0.0
      RDEVXB= 0.0
      RDEVYB= 0.0
      XCCX= 1.0
      XCCY= 0.0
      YCCX= 0.0
      YCCY= 1.0
      RPICXC= 0.0
      RPICYC= 0.0
      RDEVXC= 0.0
      RDEVYC= 0.0
      CURTRA= .TRUE.
      XRVX= 1.0
      XRVY= 0.0
      YRVX= 0.0
      YRVY= 1.0
      RPICXR= 0.0
      RPICYR= 0.0
      RDEVXR= 0.0
      RDEVYR= 0.0
      SCALXC= 1.0
      SCALYC= 1.0
      ROTATC= 0.0
      SCALXS= 1.0
      SCALYS= 1.0
      ROTATS= 0.0
      RDEVXS= 0.0
      RDEVYS= 0.0
      SHIFT1= .FALSE.
      MTRAN1= 1
      KLIPM1= 0
      WINLIN= .FALSE.
      WNDOIN= .TRUE.
      MASKIN= .TRUE.
      INDLVL= 0
C
C          WINDOW VALUES:
C
      X1WND1= 0.1
      X2WND1= 0.95
      Y1WND1= 0.1
      Y2WND1= 0.95
C
C          THE FOLLOWING ARE GRIDFILE-HANDLER COMMON BLOCKS:
C          ------------------------------------------------
C
C          (THESE VARIABLES ARE REQUIRED BY THE PRE-PROCESSOR
C           AND IN SOME CASES BY PARTS OF THE DEVICE-HANDLER).
C
      LNFOFI= 0
      LNFOPI= 0
      LNFOFO= 0
      LNFOPO= 0
C
      DO 1300 ISET= 1,32
        NAMEFO(ISET)= NAMDEF(ISET)
 1300 CONTINUE
C
      LNFILN= LENDEF
      LNPICN=  0
      NGPICS= 1
      LIMPIC= 20
      SCRTCH= .FALSE.
C
C          THE FOLLOWING ARE GLOBAL COMMON BLOCKS:
C          --------------------------------------
C
      PI= 3.141593
      INTRAC= .FALSE.
      ERRON= .TRUE.
      NUMERR= 0
      KMODE= 1
      GFOPEN= .FALSE.
      PPOPEN= .TRUE.
      NEWPIC= .TRUE.
      LVLPIC= 0
      IF (.NOT.DONE) K1ERR= 0
      IF (.NOT.DONE) K2ERR= 0
C
      LASCOD= 0
      INDXVB= 0
C
C          THE DEVICE DEPENDENT COMMON BLOCKS ARE INITIALISED.
C
      CALL G1INIT(2)
      DONE= .TRUE.
C
      RETURN
      END
      SUBROUTINE G3LINK(ICLASS,IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (3001)   VERSION (A8.8B)   10:NOV:89
C          ------------------------------------------------
C
C          THIS INTERFACES THE PRE-PROCESSOR ROUTINES TO THE
C          GRIDFILE-MANAGEMENT AND DEVICE-HANDLER ROUTINES.
C          (THIS VERSION IS FOR DEVICE-MODE WORKING).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICLASS> IS THE CLASS OF THE ACTION REQUIRED,
C          <IFUNCO> IS THE FUNCTION CODE WITHIN THE GIVEN CLASS,
C          <LENGTH> GIVES THE DATA LENGTH AND TYPE:
C                   < 0, THE DATA IS INTEGER, OR
C                   > 0, THE DATA TYPE IS REAL.
C          [IDATA]  ARE THE INTEGER VALUES (IF ANY), AND
C          [RDATA]  ARE THE REAL VALUES (IF ANY).
C
C
      REAL    RDATA(255),RARGS(4)
      INTEGER IDATA(255),IARGS(4)
      LOGICAL PICCOM
      LOGICAL NEWPIC,GFOPEN,PPOPEN,SHIFT0
C
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CATT/ IUNDL0,ITAL0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CFON/ KFONT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0CVIS/ KWIND0,KMASK0
      COMMON /T0DEVS/ KCHAN0(5),IRESL0
      COMMON /T0HRDC/ KHRDW0
      COMMON /T0HRDL/ LHRDW0
      COMMON /T0KBAC/ KOLBA0
      COMMON /T0KTAB/ REDCO0(255),GRNCO0(255),BLUCO0(255),NCOLS0
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0LPAT/ MARKA0,MISSA0,MARKB0,MISSB0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0MASK/ X1MSK0(10),X2MSK0(10),Y1MSK0(10),Y2MSK0(10),MSKLV0
      COMMON /T0MRKS/ MARKC0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3NBYR/ NBYTR
      COMMON /T3OUTS/ GFOPEN,PPOPEN
      COMMON /T3PICM/ NEWPIC
      COMMON /T3PLVL/ LVLPIC
      COMMON /T3VBUF/ VBUFFR(63),LASCOD,INDXVB

      COMMON /T1CHAD/ KDISPI,KDISPO
C
C
C          THE PICTURE INSERT LEVEL IS UPDATED HERE AND A
C          'NEW OUTPUT PICTURE' COMMAND IS NOTED WHEN RECEIVED.
C
      NPTS= LENGTH/NBYTR
      ICODE= ICLASS*32+IFUNCO
      IF (ICODE.EQ.35) LVLPIC= LVLPIC+1
      IF (ICODE.EQ.33) LVLPIC= LVLPIC-1
      IF (ICODE.EQ.36) LVLPIC= 0
C
      PICCOM= .FALSE.
      IF (ICODE.EQ.99.OR.ICODE.EQ.107) PICCOM= .TRUE.
C
C          THIS SECTION BUFFERS SUCCESSIVE DRAWING FUNCTIONS.
C          IF THE BUFFER MARKER IS CLEAR, THE NEW FUNCTION IS
C          EXAMINED. OTHERWISE, IF THE CLASS IS ZERO AND THE
C          FUNCTION CODE HAS NOT CHANGED, THE DATA IS BUFFERED.
C          IF THE CLASS OR THE FUNCTION CODE HAVE CHANGED, THE
C          BUFFER IS EMPTIED AND THE NEW FUNCTION IS PROCESSED.
C          THE BUFFER MARKER IS THEN SET TO THE FUNCTION CODE.
C          (ONLY CLASS-0 FUNCTION CODES 2 TO 5 ARE BUFFERED).
C
      IF (LASCOD.EQ.0) GO TO 1
      IF (ICLASS.EQ.0.AND.IFUNCO.EQ.LASCOD) GO TO 2
C
      INDXVB= NBYTR*INDXVB
      IF (PPOPEN) CALL G1CLS0(LASCOD,INDXVB,IDATA,VBUFFR)
C
      INDXVB= 0
      LASCOD= 0
    1 IF (ICLASS.GT.0.OR.NEWPIC)      GO TO 5
      IF (IFUNCO.LT.2.OR.IFUNCO.GT.5) GO TO 5
C
      LASCOD= IFUNCO
      INDXVB= INDXVB+NPTS
      GO TO 3
C
C          THIS PART ACTUALLY BUFFERS THE INPUT DATA. IF A
C          REPEATED 'POSITION' IS ATTEMPTED, ONLY THE MOST
C          RECENT IS KEPT BY OVERWRITING THE PREVIOUS ONE.
C          THE BUFFER IS EMPTIED EACH TIME IT BECOMES FULL.
C
    2 IF (LASCOD.GE.3.AND.LASCOD.LE.5) INDXVB= INDXVB+NPTS
    3 IF (INDXVB.LE.(255/NBYTR)) GO TO 4
C
      INDXVB= NBYTR*(INDXVB-NPTS)
      IF (PPOPEN) CALL G1CLS0(LASCOD,INDXVB,IDATA,VBUFFR)
C
      INDXVB= NPTS
C
    4 DO 100 IPT= 1,NPTS
        LOAD= INDXVB+IPT-NPTS
        VBUFFR(LOAD)= RDATA(IPT)
  100 CONTINUE
      RETURN
C
C          THIS SECTION SUPPLIES THE DEVICE-HANDLER WITH DATA
C          FOR ALL FUNCTIONS OTHER THAN THOSE BUFFERED ABOVE.
C          ONLY 'GREND' IS DONE IF DEVICE OUTPUT IS DISABLED.
C          SUCCESSIVE 'NEW-PICTURE' FUNCTIONS ARE NOT SENT ON.
C
    5 IF (.NOT.PPOPEN.AND.ICODE.NE.34) GO TO 19
      IF (NEWPIC.AND.PICCOM)           GO TO 19
C
      KLASS= ICLASS+1
      GO TO (6,7,12,13,14,15,16,17), KLASS
C
    6 CALL G1CLS0(IFUNCO,LENGTH,IDATA,RDATA)
      GO TO 19
C
C          THIS SECTION HANDLES FUNCTIONS IN CLASS-1:
C
C          THIS DEALS WITH A 'GREND' FUNCTION.
C
    7 IF (IFUNCO.NE.2) GO TO 8
C
      CALL G3SYSI(2)
      CALL G1CHIO(3,0)
      CALL G1FILB(0,0,-85,0)
      GO TO 19
C
C          THIS DEALS WITH A 'BEGIN-INSERT' FUNCTION. IF THIS
C          IS FROM PICTURE-LEVEL 0 AND A SUBPICTURE IS TO BE
C          DONE, A 'TRANSFORM-INDENT' FUNCTION IS GENERATED.
C          ANY EXISTING CHARACTER RE-DEFINITIONS ARE STACKED.
C
C
    8 IF (IFUNCO.NE.3) GO TO 9
      IF (LVLPIC.NE.1) GO TO 19
      IF (MTRAN0.GE.2) CALL G1CLS7(14,0,IDATA,RDATA)
C
      IARGS(1)= 0
      CALL G1CLS2(15,-1,IARGS,RARGS)
      GO TO 19
C
C          THIS DEALS WITH AN 'END-INSERT' FUNCTION. PRE-PROCESSOR
C          VALUES ARE RESTORED WHEN RETURNING TO PICTURE-LEVEL 0.
C          AFTER AN OVERLAY, A PRE-PROCESSOR TRANSFORM IS DONE.
C          AFTER A SUBPICTURE, A TRANSFORM UNDENT IS DONE INSTEAD.
C
    9 IF (LVLPIC.NE.0) GO TO 19
C
C          THIS PART RESTORES THE MAPPING.
C
      RARGS(1)= X1MAP0
      RARGS(2)= X2MAP0
      RARGS(3)= Y1MAP0
      RARGS(4)= Y2MAP0
      CALL G1CLS7(MAPNO0,4*NBYTR,IARGS,RARGS)
      IF (IFUNCO.NE.1) GO TO 10
C
C          THIS PART RESTORES THE WINDOW.
C
      RARGS(1)= X1WND0
      RARGS(2)= X2WND0
      RARGS(3)= Y1WND0
      RARGS(4)= Y2WND0
      CALL G1CLS7(5,4*NBYTR,IARGS,RARGS)
C
C          THIS PART RESTORES THE MASK AREAS.
C
      IARGS(1)= 0
      CALL G1CLS7(7,-1,IARGS,RARGS)
C
      DO 200 LEVEL= 1,10
        RARGS(1)= X1MSK0(LEVEL)
        RARGS(2)= X2MSK0(LEVEL)
        RARGS(3)= Y1MSK0(LEVEL)
        RARGS(4)= Y2MSK0(LEVEL)
        CALL G1CLS7(6,4*NBYTR,IARGS,RARGS)
  200 CONTINUE
C
      IARGS(1)= MSKLV0
      CALL G1CLS7(7,-1,IARGS,RARGS)
C
C          THE APPROPRIATE TRANSFORM STATE IS RESTORED.
C
      IARGS(1)= KLIPM0
      CALL G1CLS7(16,-1,IARGS,RARGS)
      IARGS(1)= MTRAN0
      CALL G1CLS7(17,-1,IARGS,RARGS)
C
C          THIS PART RESTORES THE CHARACTER ATTRIBUTES.
C          ANY STACKED CHARACTER RE-DEFINITIONS ARE RESTORED.
C
      IARGS(1)= KHRDW0
      CALL G1CLS2(1,-1,IARGS,RARGS)
      IARGS(1)= KFONT0
      CALL G1CLS2(2,-1,IARGS,RARGS)
      IARGS(1)= MAGN0
      CALL G1CLS2(3,-1,IARGS,RARGS)
      RARGS(1)= STANG0
      CALL G1CLS2(4,NBYTR,IARGS,RARGS)
      RARGS(1)= CRANG0
      CALL G1CLS2(5,NBYTR,IARGS,RARGS)
      IARGS(1)= ITAL0
      CALL G1CLS2(6,-1,IARGS,RARGS)
      IARGS(1)= IUNDL0
      CALL G1CLS2(7,-1,IARGS,RARGS)
      RARGS(1)= OBLAT0
      CALL G1CLS2(8,NBYTR,IARGS,RARGS)
      IARGS(1)= MARKC0
      CALL G1CLS2(9,-1,IARGS,RARGS)
C
C          THIS PART RESTORES THE CHARACTER WINDOW.
C
      RARGS(1)= X1CHR0
      RARGS(2)= X2CHR0
      RARGS(3)= Y1CHR0
      RARGS(4)= Y2CHR0
      CALL G1CLS2(10,4*NBYTR,IARGS,RARGS)
      IARGS(1)= KWIND0
      CALL G1CLS2(13,-1,IARGS,RARGS)
      IARGS(1)= KMASK0
      CALL G1CLS2(14,-1,IARGS,RARGS)
C
C          THIS PART RESTORES THE LINE ATTRIBUTES.
C
      IARGS(1)= ITHIK0
      CALL G1CLS3(4,-1,IARGS,RARGS)
      IARGS(1)= MARKA0
      IARGS(2)= MISSA0
      IARGS(3)= MARKB0
      IARGS(4)= MISSB0
      CALL G1CLS3(6,-4,IARGS,RARGS)
      IARGS(1)= LHRDW0
      CALL G1CLS3(7,-1,IARGS,RARGS)
      IARGS(1)= KOLIN0
      CALL G1CLS3(9,-1,IARGS,RARGS)
C
C          THIS PART RESTORES THE DEVICE RESOLUTION:
C
      IARGS(1)= IRESL0
      CALL G1CLS3(12,-1,IARGS,RARGS)
C
C          THIS PART RESTORES THE COLOUR DEFINITIONS:
C
      DO 300 NCOLTB= 1,NCOLS0
        RARGS(1)= NCOLTB
        RARGS(2)= REDCO0(NCOLTB)
        RARGS(3)= GRNCO0(NCOLTB)
        RARGS(4)= BLUCO0(NCOLTB)
        CALL G1CLS5(1,4*NBYTR,IARGS,RARGS)
  300 CONTINUE
C
      IARGS(1)= KOLBA0
      CALL G1CLS5(2,-1,IARGS,RARGS)
   10 IARGS(1)= 1
      CALL G1CLS2(15,-1,IARGS,RARGS)
      IF (MTRAN0.GE.2) GO TO 11
C
C          THIS PART IS FOR END-OF-OVERLAY.
C
      RARGS(1)= VRPICX
      RARGS(2)= VRPICY
      CALL G1CLS0(2,2*NBYTR,IARGS,RARGS)
      RARGS(1)= SCALX0
      CALL G1CLS7(8,NBYTR,IARGS,RARGS)
      RARGS(1)= SCALY0
      CALL G1CLS7(9,NBYTR,IARGS,RARGS)
      RARGS(1)= ROTAT0
      CALL G1CLS7(12,NBYTR,IARGS,RARGS)
      RARGS(1)= RDEVX0
      RARGS(2)= RDEVY0
      LENDA= 0
      IF (SHIFT0) LENDA= 2*NBYTR
C
      CALL G1CLS7(13,LENDA,IARGS,RARGS)
      RARGS(1)= XPLOT0
      RARGS(2)= YPLOT0
      CALL G1CLS0(2,2*NBYTR,IARGS,RARGS)
      GO TO 19
C
C          THIS PART IS FOR END-OF-SUBPICTURE.
C
   11 RDATA(1)= 1.0
      RDATA(2)= 1.0
      RDATA(3)= 0.0
      RDATA(4)= 0.0
      RDATA(5)= 0.0
      RDATA(6)= 0.0
      RDATA(7)= 0.0
      CALL G1CLS7(15,7*NBYTR,IDATA,RDATA)
      RARGS(1)= XPLOT0
      RARGS(2)= YPLOT0
      CALL G1CLS0(2,2*NBYTR,IARGS,RARGS)
      GO TO 19
C
C          THIS SECTION HANDLES FUNCTIONS IN CLASSES 2
C          TO 7 (BUT CLASS 6 IS NOT SUPPORTED HERE).
C
C
   12 CALL G1CLS2(IFUNCO,LENGTH,IDATA,RDATA)
      GO TO 19
C
   13 CALL G1CLS3(IFUNCO,LENGTH,IDATA,RDATA)
      GO TO 19
C
   14 CALL G1CLS4(IFUNCO,LENGTH,IDATA,RDATA)
      GO TO 19
C
   15 CALL G1CLS5(IFUNCO,LENGTH,IDATA,RDATA)
      GO TO 19
C
   16 GO TO 19
C
C          WHEN A TRANSFORM UNDENT IS BEING DONE TO PICTURE-LEVEL 1,
C          THE FUNCTION VALUES ARE REPLACED BY THE PRE-PROCESSOR ONES.
C
   17 IF (LVLPIC.NE.1.OR.IFUNCO.NE.15) GO TO 18
C
      RDATA(1)= SCALX0
      RDATA(2)= SCALY0
      RDATA(3)= ROTAT0
      RDATA(4)= RDEVX0
      RDATA(5)= RDEVY0
      RDATA(6)= RPICX0
      RDATA(7)= RPICY0
   18 CALL G1CLS7(IFUNCO,LENGTH,IDATA,RDATA)
   19 NEWPIC= PICCOM
      RETURN
      END
      SUBROUTINE G1CLS3(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1014)   VERSION (A8.7)    07:AUG:86
C          ------------------------------------------------
C
C          THIS PROVIDES PARAMETER-SETTING OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   =  1, OPEN DEVICE CHANNEL             (N),
C                   =  2, CLOSE DEVICE CHANNEL            (N),
C                   =  3, ERASE PICTURE WITH PROMPT/WAIT,
C                   =  4, SET LINE THICKNESS              (N),
C                   =  5, -NO LONGER USED-
C                   =  6, SET LINE PATTERN                (N1...N4),
C                   =  7, SET LINE HARDWARE MODE          (N),
C                   =  8, SET LINE BLINK                  (N),
C                   =  9, SET LINE COLOUR NUMBER          (N),
C                   = 10, EMPTY DEVICE BUFFERS,
C                   = 11, ERASE PICTURE WITHOUT PROMPT/WAIT,
C                   = 12, SET DEVICE RESOLUTION           (N).
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL OPEN,LHRDW1
C
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1DENA/ OPEN
      COMMON /T1DEVS/ KCHAN1(5),IRESL1
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1KDEF/ KOLLID,KOLBAD,MAXCLS
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LINT/ ELWID,NFILLI,THIKST
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1MAPP/ X1MAP1,X2MAP1,Y1MAP1,Y2MAP1
      COMMON /T1PNUM/ NDPICS
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1PPOS/ XPLOT1,YPLOT1
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.14) RETURN
      GO TO (1,2,3,4,5,6,7,8,9,10,11,13), IFUNCO
C
C          THIS OPENS THE DEVICE CHANNEL. (WITHOUT THIS
C          BEING DONE, NO GRAPHICAL OUTPUT IS POSSIBLE).
C
    1 IVALUE= IDATA(1)
      IF (IVALUE.LE.0.OR.IVALUE.GT.5) RETURN
C
      KCHAN1(IVALUE)= 1
      CALL G1FILB(0,0,-86,IVALUE)
      OPEN= .TRUE.
      RETURN
C
C          AND THIS CLOSES THE DEVICE CHANNEL.
C
    2 IVALUE= IDATA(1)
      IF (IVALUE.LE.0.OR.IVALUE.GT.5) RETURN
C
      KCHAN1(IVALUE)= 0
      CALL G1FILB(0,0,-87,IVALUE)
      OPEN= .FALSE.
C
      DO 100 ITEST= 1,5
        IF (KCHAN1(ITEST).EQ.1) OPEN= .TRUE.
  100 CONTINUE
      RETURN
C
C          THIS ERASES THE PICTURE WITH A PROMPT/WAIT.
C
    3 IF (.NOT.OPEN) RETURN
C
      KODERA= -81
      GO TO 12
C
C          THIS SETS THE LINE THICKNESS.
C
    4 ITHIK1= IDATA(1)
      NFILLI= (ITHIK1/ELWID)+0.5
      IF (ITHIK1.EQ.1.OR.NFILLI.LT.1) NFILLI= 1
C
      THIKST= (0.0005*ITHIK1)/NFILLI
      RETURN
C
C          THIS SETS THE LINE INTENSITY.
C          (IT IS NO LONGER IMPLEMENTED).
C
    5 RETURN
C
C          THIS SETS THE CURRENT LINE PATTERN, AND IN
C          THE CASE OF HARDWARE BROKEN LINES SETS THE
C          APPROPRIATE PATTERN VIA SUBROUTINE <G1HRDW>.
C
    6 MARKA1= IDATA(1)
      MISSA1= IDATA(2)
      MARKB1= IDATA(3)
      MISSB1= IDATA(4)
      RESMIN= 1000.0/AMIN1(DRESX,DRESY)
      IF (FLOAT(MARKA1).LT.RESMIN) MARKA1= 0
      IF (FLOAT(MISSA1).LT.RESMIN) MISSA1= 0
      IF (FLOAT(MARKB1).LT.RESMIN) MARKB1= 0
      IF (FLOAT(MISSB1).LT.RESMIN) MISSB1= 0
      IF (LHRDW1) CALL G1HRDW(1)
      RETURN
C
C          THIS SETS LINE HARDWARE MODE.
C
    7 LHRDW1= .FALSE.
      IF (IDATA(1).EQ.1) LHRDW1= .TRUE.
C
      CALL G1HRDW(1)
      RETURN
C
C          THIS SETS DISPLAY BLINKING.
C          (IT IS NOT IMPLEMENTED HERE).
C
    8 RETURN
C
C          THIS SETS THE LINE COLOUR NUMBER.
C
    9 KOLIN1= IDATA(1)
      IF (KOLIN1.EQ.0) KOLIN1= KOLLID
C
      CALL G1HRDW(4)
      RETURN
C
C          THIS CAUSES ALL THE INTERNAL BUFFERS TO
C          BE EMPTIED IMMEDIATELY RATHER THAN AFTER
C          THEY BECOME FULL (AS IS THE NORMAL CASE).
C
   10 CALL G1FILB(0,0,-84,0)
      RETURN
C
C          THIS ERASES THE DEVICE WITHOUT A PROMPT/WAIT.
C
   11 IF (.NOT.OPEN) RETURN
C
      KODERA= -82
   12 XPLOT1= X1MAP1
      YPLOT1= Y1MAP1
      CALL G1LINE(0.0,0.0,.FALSE.)
      XCHAR= XPLOTB
      YCHAR= YPLOTB
      NDPICS= NDPICS+1
      CALL G1FILB(0,0,KODERA,0)
      RETURN
C
C          THIS SETS THE DEVICE RESOLUTION.
C
   13 IRESL1= IDATA(1)
      CALL G1HRDW(9)
      RETURN
      END
      SUBROUTINE G1CLS4(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1015)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS PROVIDES BUFFER-CONTROL OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   = 1, SELECT DEVICE BUFFER (N),
C                   = 2, SELECT THE SYSTEM BUFFER,
C                   = 3, OUTPUT DEVICE BUFFER (N),
C                   = 4, ERASE  DEVICE BUFFER (N).
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL ENDING
      LOGICAL FULL,ERRON
C
      COMMON /T1BEPT/ IXFINI,IYFINI
      COMMON /T1BUFN/ KBUFR1
      COMMON /T1BUFS/ MSYSTB(200),LIMSYS,ISYSTP
      COMMON /T1BUFU/ MUSERB(3200),LENTHB,KINDEX,KLIMIT,KAREA,LIMARE,
     &                IAREAP(16),ISTRTA(16),KAREAS(16),NAREAS(16),
     &                INEXTA(32),FULL
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.4) RETURN
C
      IBUFFR= IDATA(1)
      IF (IBUFFR.LT.0.OR.IBUFFR.GT.16) RETURN
C
      IF (IFUNCO.EQ.3) GO TO 4
      IF (IFUNCO.EQ.4) GO TO 8
C
C          TO CLOSE THE CURRENT BUFFER, ITS STORED STATE IS UPDATED.
C          TO OPEN A GIVEN BUFFER, FIRST THE PRESENT ONE IS CLOSED,
C          THEN THE NEW BUFFER AND (RELATIVE) AREA LIMIT ARE SET.
C
      IF (IFUNCO.EQ.1) ENDING= .FALSE.
      IF (IFUNCO.EQ.2) ENDING= .TRUE.
      IF (KBUFR1.LE.0) GO TO 1
C
      KAREAS(KBUFR1)= KAREA
      IAREAP(KBUFR1)= KINDEX
      KBUFR1= 0
      IXFINI= -1
      IYFINI= -1
    1 IF (ENDING)           RETURN
      IF (IBUFFR.EQ.KBUFR1) RETURN
C
      KBUFR1= IBUFFR
      LIMARE= LENTHB/32
C
C          IF THE BUFFER IS NOT EMPTY, THE CURRENT AREA AND
C          INDEX POINTER ARE RESTORED. IF THE NEW BUFFER IS
C          EMPTY, A NEW AREA HAS TO BE FOUND FROM THE LIST
C          OF AREAS. IF THERE ARE NONE LEFT, THE FULL FLAG
C          IS SET AND AN ERROR MESSAGE IS PRINTED. IF A FREE
C          AREA IS FOUND, ITS STATE IS PROPERLY INITIALISED.
C
      IF (NAREAS(KBUFR1).LE.0) GO TO 2
C
      KAREA= KAREAS(KBUFR1)
      KINDEX= IAREAP(KBUFR1)
      KLIMIT= LIMARE*KAREA
      RETURN
C
    2 DO 100 IAREA= 1,32
        IF (INEXTA(IAREA).EQ.0) GO TO 3
  100 CONTINUE
      FULL= .TRUE.
      GO TO 901
C
    3 KAREA= IAREA
      KAREAS(KBUFR1)= KAREA
      ISTRTA(KBUFR1)= KAREA
      INEXTA(KAREA)= -1
      NAREAS(KBUFR1)= 1
      KINDEX= LIMARE*(KAREA-1)
      KLIMIT= LIMARE*KAREA
      RETURN
C
C          THIS SECTION TRANSMITS THE REQUIRED BUFFER UNLESS IT IS
C          EMPTY.   THE SYSTEM BUFFER IS EMPTIED FIRST.
C          THE FIRST AREA IS SET AND EACH IS OUTPUT IN TURN
C          ACCORDING TO THE ORDER GIVEN IN [INEXTA] UNTIL THE LAST
C          IS ENCOUNTERED (GIVEN BY [INEXTA]= -1). IN THIS CASE,
C          THE AREA MAY NOT BE COMPLETELY FULL, SO THE END LIMIT IS
C          CALCULATED FROM THE STORED INDEX-POINTER OR (IN THE CASE
C          OF THE CURRENT BUFFER) FROM THE CURRENT INDEX-POINTER.
C
    4 IF (NAREAS(IBUFFR).EQ.0) RETURN
C
      IF (ISYSTP.LE.0) GO TO 5
      CALL G1TRAN(MSYSTB,1,ISYSTP)
      ISYSTP= 0
    5 IAREA= ISTRTA(IBUFFR)
    6   ISTRTP= LIMARE*(IAREA-1)+1
        NXAREA= INEXTA(IAREA)
        IF (NXAREA.EQ.-1) GO TO 7
        IENDP= IAREA*LIMARE
        CALL G1TRAN(MUSERB,ISTRTP,IENDP)
        IAREA= NXAREA
        GO TO 6
C
    7 IENDP= IAREAP(IBUFFR)
      IF (IBUFFR.EQ.KBUFR1) IENDP= KINDEX
      IF (IENDP.LT.ISTRTP) RETURN
      CALL G1TRAN(MUSERB,ISTRTP,IENDP)
      RETURN
C
C          THIS SECTION DELETES THE GIVEN BUFFER (UNLESS IT IS
C          ALREADY EMPTY) BY FREEING ALL ITS ASSOCIATED AREAS.
C
    8 IF (NAREAS(IBUFFR).EQ.0) RETURN
C
      IAREA= ISTRTA(IBUFFR)
      NXAREA= INEXTA(IAREA)
      IAREAP(IBUFFR)= 0
C
C          IF THE BUFFER BEING CLOSED IS THE CURRENT ONE,
C          ITS STORED STATE MUST FIRST BE RE-INITIALISED,
C          SINCE IT REMAINS OPEN FOR FRESH INPUT. THE AREAS
C          ARE FREED BY ZEROING EACH ELEMENT OF THE LINKED
C          AREA LIST [INEXTA] UNTIL THE END OF THE LIST IS
C          REACHED (NAMELY WHEN A VALUE OF -1 IS FOUND).
C
      IF (IBUFFR.NE.KBUFR1) GO TO 12
C
      KAREA= IAREA
      KAREAS(KBUFR1)= KAREA
      INEXTA(KAREA)= -1
      NAREAS(KBUFR1)= 1
      KINDEX= LIMARE*(KAREA-1)
      KLIMIT= LIMARE*KAREA
      GO TO 14
C
   12 KAREAS(IBUFFR)= 0
      ISTRTA(IBUFFR)= 0
      NAREAS(IBUFFR)= 0
C
   13   INEXTA(IAREA)= 0
   14   IF (NXAREA.EQ.-1) RETURN
        IAREA= NXAREA
        NXAREA= INEXTA(IAREA)
        GO TO 13
C
  901 NUMERR= 1003
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
      RETURN
      END
      SUBROUTINE G1CLS5(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1016)   VERSION (A8.3)    03:FEB:89
C          ------------------------------------------------
C
C          THIS PROVIDES COLOUR AND AREA FILL OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   = 1, DEFINE COLOUR NUMBER          (RN,RR,RG,RB),
C                   = 2, SET THE BACKGROUND COLOUR NO. (N),
C                   = 3, SET THE AREA-FILL COLOUR NO.  (N),
C                   = 4, FILL THE CURRENT POLYGON,
C                   = 5, SET CROSS-HATCH ANGLE         (RADIANS),
C                   = 6, SET CROSS-HATCH PITCH         (N,IT),
C                   = 7, SET CROSS-HATCH OFFSET        (N,IT),
C                   = 8, SET CROSS-HATCH LINE-STYLE    (N1...N4,IT),
C                   = 9, SET CROSS-HATCH PHASE         (N,IT),
C                   =10, SET CROSS-HATCH COLOUR        (N,IT),
C                   =11, SET CROSS-HATCH TYPE          (N,IT),
C                   =12, SET THE PATTERN DEFINITION NUMBER (N),
C                   =13, SPECIFIES IF CROSS-HATCHING OR AREA FILL IS DONE (N),
C                   =14, COPY ONE PATTERN TO ANOTHER   (N1,N2),
C                   =15, SET CROSS-HATCH PATTERN STARTING POINT (N,IT),
C                   =16, SET THE SHADING OPTION FLAG   (N).
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL LINSAV,LHRDW1
C
      COMMON /T1C5SV/ LINESV(4),ITHIKS,NFILLS,LINSAV
      COMMON /T1FLTY/ IFLTY1,IFLRP1
      COMMON /T1HANG/ HTANG1(255,2)
      COMMON /T1HCOL/ IHCOL1(255,2)
      COMMON /T1HLST/ IHMKA1(255,2),IHMSA1(255,2),IHMKB1(255,2),
     &                IHMSB1(255,2)
      COMMON /T1HNUM/ IHATN1
      COMMON /T1HOFF/ ISHFT1(255,2)
      COMMON /T1HPHS/ IPHAS1(255,2)
      COMMON /T1HPIT/ IPITH1(255,2)
      COMMON /T1HPSF/ IPSFT1(255,2)
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1HTYP/ IHAT1(255)
      COMMON /T1KBAC/ KOLBA1
      COMMON /T1KDEF/ KOLLID,KOLBAD,MAXCLS
      COMMON /T1KFIL/ KOLFL1
      COMMON /T1KTAB/ REDCO1(255),GRNCO1(255),BLUCO1(255),NCOLS1
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LINT/ ELWID,NFILLI,THIKST
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.16) RETURN
      GO TO (1,2,3,5,6,7,8,9,11,12,13,14,15,16,17,18), IFUNCO
C
C          THIS PART DEFINES THE GIVEN COLOUR NUMBER OR PATTERN STYLE.
C
    1 NCOLS1= ABS(RDATA(1))+0.5
      IF (NCOLS1.LT.1.OR.NCOLS1.GT.255) RETURN
C
      REDCO1(NCOLS1)= ABS(RDATA(2))
      IF (REDCO1(NCOLS1).GT.1.0) REDCO1(NCOLS1)= 1.0
C
      GRNCO1(NCOLS1)= ABS(RDATA(3))
      IF (GRNCO1(NCOLS1).GT.1.0) GRNCO1(NCOLS1)= 1.0
C
      BLUCO1(NCOLS1)= ABS(RDATA(4))
      IF (BLUCO1(NCOLS1).GT.1.0) BLUCO1(NCOLS1)= 1.0
C
      CALL G1HRDW(8)
      IF (NCOLS1.EQ.KOLBA1) CALL G1HRDW(10)
C
      RETURN
C
C          THIS PART SETS THE BACKGROUND COLOUR NUMBER.
C
    2 KOLBA1= IDATA(1)
      IF (KOLBA1.EQ.0) KOLBA1= KOLBAD
C
      CALL G1HRDW(10)
C
      RETURN
C
C          THIS PART SETS THE FILL COLOUR NUMBER.
C
    3 KOLFL1= IDATA(1)
      LINESV(1)= MARKA1
      LINESV(2)= MISSA1
      LINESV(3)= MARKB1
      LINESV(4)= MISSB1
      MARKA1= 0
      MISSA1= 0
      MARKB1= 0
      MISSB1= 0
      ITHIKS= ITHIK1
      ITHIK1= 1
      NFILLS= NFILLI
      NFILLI= 1
      LINSAV= LHRDW1
      LHRDW1= .FALSE.
      IF (LINSAV) CALL G1HRDW(1)
      IF (IFLTY1.NE.0.OR.IFLRP1.NE.0) GO TO 4
C
      CALL G1HRDW(11)
      CALL G1FILB(0,0,-20,KOLFL1)
C
      RETURN
C
    4 CALL G1FILB(0,0,-44,-11)
      IANG1= HTANG1(KOLFL1,1)*100000.0+0.5
      IANG2= HTANG1(KOLFL1,2)*100000.0+0.5
      CALL G1FILB(0,0,IANG1,IANG2)
      CALL G1FILB(0,0,IHCOL1(KOLFL1,1),IHCOL1(KOLFL1,2))
      CALL G1FILB(0,0,IHMKA1(KOLFL1,1),IHMKA1(KOLFL1,2))
      CALL G1FILB(0,0,IHMSA1(KOLFL1,1),IHMSA1(KOLFL1,2))
      CALL G1FILB(0,0,IHMKB1(KOLFL1,1),IHMKB1(KOLFL1,2))
      CALL G1FILB(0,0,IHMSB1(KOLFL1,1),IHMSB1(KOLFL1,2))
      CALL G1FILB(0,0,ISHFT1(KOLFL1,1)*100,ISHFT1(KOLFL1,2)*100)
      CALL G1FILB(0,0,IPHAS1(KOLFL1,1),IPHAS1(KOLFL1,2))
      CALL G1FILB(0,0,IPITH1(KOLFL1,1)*100,IPITH1(KOLFL1,2)*100)
      CALL G1FILB(0,0,IPSFT1(KOLFL1,1),IPSFT1(KOLFL1,2))
      CALL G1FILB(0,0,IHAT1(KOLFL1),1)
      CALL G1FILB(0,0,-20,0)
C
      RETURN
C
C          THIS PART FILLS THE CURRENT POLYGON.
C
    5 CALL G1FILB(0,0,-18,0)
      IF (IFLTY1.EQ.0.AND.IFLRP1.EQ.0) CALL G1HRDW(12)
C
      MARKA1= LINESV(1)
      MISSA1= LINESV(2)
      MARKB1= LINESV(3)
      MISSB1= LINESV(4)
      ITHIK1= ITHIKS
      NFILLI= NFILLS
      LHRDW1= LINSAV
      IF (LHRDW1) CALL G1HRDW(1)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH ANGLE.
C
    6 ITYPE= ABS(RDATA(2))+0.5
      IF (MOD(ITYPE,2).EQ.1) HTANG1(IHATN1,1)= RDATA(1)
      IF (ITYPE/2.EQ.1)      HTANG1(IHATN1,2)= RDATA(1)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH PITCH.
C
    7 ITYPE= IDATA(2)
      IF (MOD(ITYPE,2).EQ.1) IPITH1(IHATN1,1)= IDATA(1)
      IF (ITYPE/2.EQ.1)      IPITH1(IHATN1,2)= IDATA(1)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH OFFSET.
C
    8 ITYPE= IDATA(2)
      IF (MOD(ITYPE,2).EQ.1) ISHFT1(IHATN1,1)= IDATA(1)
      IF (ITYPE/2.EQ.1)      ISHFT1(IHATN1,2)= IDATA(1)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH LINE-STYLE.
C
    9 ITYPE= IDATA(5)
      IF (MOD(ITYPE,2).NE.1) GO TO 10
C
      IHMKA1(IHATN1,1)= IDATA(1)
      IHMSA1(IHATN1,1)= IDATA(2)
      IHMKB1(IHATN1,1)= IDATA(3)
      IHMSB1(IHATN1,1)= IDATA(4)
   10 IF (ITYPE/2.NE.1) RETURN
C
      IHMKA1(IHATN1,2)= IDATA(1)
      IHMSA1(IHATN1,2)= IDATA(2)
      IHMKB1(IHATN1,2)= IDATA(3)
      IHMSB1(IHATN1,2)= IDATA(4)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH PHASE.
C
   11 ITYPE= IDATA(2)
      IF (MOD(ITYPE,2).EQ.1) IPHAS1(IHATN1,1)= IDATA(1)
      IF (ITYPE/2.EQ.1)      IPHAS1(IHATN1,2)= IDATA(1)
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH COLOUR.
C
   12 ITYPE= IDATA(2)
      IF (MOD(ITYPE,2).EQ.1)     IHCOL1(IHATN1,1)= IDATA(1)
      IF (ITYPE/2.EQ.1)          IHCOL1(IHATN1,2)= IDATA(1)
      IF (IHCOL1(IHATN1,1).EQ.0) IHCOL1(IHATN1,1)= KOLLID
      IF (IHCOL1(IHATN1,1).GT.MAXCLS) IHCOL1(IHATN1,1)= KOLLID
      IF (IHCOL1(IHATN1,2).EQ.0) IHCOL1(IHATN1,2)= KOLLID
      IF (IHCOL1(IHATN1,2).GT.MAXCLS) IHCOL1(IHATN1,2)= KOLLID
C
      RETURN
C
C          THIS PART SETS THE CROSS-HATCH TYPE.
C
   13 IHAT1(IHATN1)= IDATA(1)
C
      RETURN
C
C          THIS PART SETS THE PATTERN NUMBER.
C
   14 IHATN1= IDATA(1)
C
      RETURN
C
C           THIS PART SPECIFIES IF CROSS-HATCHING OR AREA FILL IS DONE
C
   15 IFLTY1= IDATA(1)
C
      RETURN
C
C          THIS PART COPIES ONE PATTERN TO ANOTHER.
C
   16 IPAT1= IDATA(1)
      IPAT2= IDATA(2)
C
      DO 100 LOAD= 1,2
        HTANG1(IPAT2,LOAD)= HTANG1(IPAT1,LOAD)
        IHCOL1(IPAT2,LOAD)= IHCOL1(IPAT1,LOAD)
        IHMKA1(IPAT2,LOAD)= IHMKA1(IPAT1,LOAD)
        IHMSA1(IPAT2,LOAD)= IHMSA1(IPAT1,LOAD)
        IHMKB1(IPAT2,LOAD)= IHMKB1(IPAT1,LOAD)
        IHMSB1(IPAT2,LOAD)= IHMSB1(IPAT1,LOAD)
        ISHFT1(IPAT2,LOAD)= ISHFT1(IPAT1,LOAD)
        IPHAS1(IPAT2,LOAD)= IPHAS1(IPAT1,LOAD)
        IPITH1(IPAT2,LOAD)= IPITH1(IPAT1,LOAD)
        IPSFT1(IPAT2,LOAD)= IPSFT1(IPAT1,LOAD)
  100 CONTINUE
C
      IHAT1(IPAT2)= IHAT1(IPAT1)
C
      RETURN
C
C          THIS SETS THE STARTING POINT IN THE PATTERN
C
   17 ITYPE= IDATA(2)
      IF (MOD(ITYPE,2).EQ.1) IPSFT1(IHATN1,1)= IDATA(1)
      IF (ITYPE/2.EQ.1)      IPSFT1(IHATN1,2)= IDATA(1)
C
      RETURN
C
C          THIS SETS THE SHADING OPTION FLAG.
C
   18 IFLRP1= IDATA(1)
      CALL G1HRDW(13)
C
      RETURN
      END
      SUBROUTINE G1CLS7(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1018)   VERSION (A8.8)    26:NOV:86
C          ------------------------------------------------
C
C          THIS DECODES MAPPING AND PICTURE-TRANSFORMATION FUNCTIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   =  1, DEFINE LIN.-LIN. MAP       (X1,X2,Y1,Y2),
C                   =  2, DEFINE LIN.-LOG. MAP       (X1,X2,Y1,Y2),
C                   =  3, DEFINE LOG.-LIN. MAP       (X1,X2,Y1,Y2),
C                   =  4, DEFINE LOG.-LOG. MAP       (X1,X2,Y1,Y2),
C                   =  5, DEFINE VECTOR WINDOW       (X1,X2,Y1,Y2),
C                   =  6, DEFINE NEW MASK AREA       (X1,X2,Y1,Y2),
C                   =  7, SET MASK LEVEL             (N),
C                   =  8, SET PICTURE X-SCALE        (FACTOR),
C                   =  9, SET PICTURE Y-SCALE        (FACTOR),
C                   = 10, -NO LONGER USED-
C                   = 11, -NO LONGER USED-
C                   = 12, SET PICTURE ROTATE         (ANGLE),
C                   = 13, SET DEVICE REFERENCE POINT (X,Y),
C                   = 14, DO A TRANSFORM INDENT,
C                   = 15, DO A TRANSFORM UNDENT      (C1,....C7),
C                   = 16, SET CLIP TRANSFORM MODE    (N),
C                   = 17, SET TRANSFORM RANGE        (N).
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(255)
      INTEGER IDATA(255)
      LOGICAL SHIFT1,CURTRA,ERRON
C
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1MAPP/ X1MAP1,X2MAP1,Y1MAP1,Y2MAP1
      COMMON /T1MAPS/ ORIMX1,ORIMY1,SCAMX1,SCAMY1
      COMMON /T1MAPT/ MAPNO1
      COMMON /T1MASK/ X1MSK1(10),X2MSK1(10),Y1MSK1(10),Y2MSK1(10),MSKLV1
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1PPOS/ XPLOT1,YPLOT1
      COMMON /T1TCOB/ XCBX,XCBY,YCBX,YCBY,RPICXB,RPICYB,RDEVXB,RDEVYB
      COMMON /T1TCOC/ XCCX,XCCY,YCCX,YCCY,RPICXC,RPICYC,RDEVXC,RDEVYC,
     &                CURTRA
      COMMON /T1TCOR/ XRVX,XRVY,YRVX,YRVY,RPICXR,RPICYR,RDEVXR,RDEVYR
      COMMON /T1TRNC/ SCALXC,SCALYC,ROTATC
C     COMMON /T1TRNB/ SCALXB,SCALYB,ROTATB
      COMMON /T1TRNS/ SCALXS,SCALYS,ROTATS,RDEVXS,RDEVYS
      COMMON /T1TRST/ SHIFT1,MTRAN1,KLIPM1,INDLVL
      COMMON /T1WNDO/ X1WND1,X2WND1,Y1WND1,Y2WND1
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.17)  RETURN
      IF (IFUNCO.EQ.10.OR.IFUNCO.EQ.11) RETURN
      IF (IFUNCO.GT.4) GO TO 4
C
C          THE FIRST 4 FUNCTIONS SET THE MAPPING.
C
      MAPNO1= IFUNCO
      X1MAP1= RDATA(1)
      X2MAP1= RDATA(2)
      Y1MAP1= RDATA(3)
      Y2MAP1= RDATA(4)
C
C          THE CURRENT POSITIONS ARE RESET FOR A NEW MAP.
C
      XPLOT1= X1MAP1
      YPLOT1= Y1MAP1
      CALL G1LINE(0.0,0.0,.FALSE.)
      XCHAR= XPLOTB
      YCHAR= YPLOTB
C
C          THE NEW X AND Y MAPPING FACTORS ARE CALCULATED.
C
      IF (MAPNO1.EQ.3.OR.MAPNO1.EQ.4) GO TO 1
C
      ORIMX1= X1MAP1
      SCAMX1= 0.0
      IF (ABS(X2MAP1-X1MAP1).LT.RMINI) GO TO 2
C
      SCAMX1= 1.0/(X2MAP1-X1MAP1)
      GO TO 2
C
    1 IF (ABS(SIGN(1.0,X2MAP1)-SIGN(1.0,X1MAP1)).GE.RMINI) GO TO 901
C
      AB1MAP= ABS(X1MAP1)
      AB2MAP= ABS(X2MAP1)
      IF (AB1MAP.LT.RMINI.OR.AB2MAP.LT.RMINI) GO TO 901
C
      ORIMX1= ALOG(AB1MAP)
      DEXP= ALOG(AB2MAP)-ORIMX1
      IF (ABS(DEXP).LT.RMINI) GO TO 901
C
      SCAMX1= 1.0/DEXP
    2 IF (MAPNO1.EQ.2.OR.MAPNO1.EQ.4) GO TO 3
C
      ORIMY1= Y1MAP1
      SCAMY1= 0.0
      IF (ABS(Y2MAP1-Y1MAP1).LT.RMINI) RETURN
C
      SCAMY1= 1.0/(Y2MAP1-Y1MAP1)
      RETURN
C
    3 IF (ABS(SIGN(1.0,Y2MAP1)-SIGN(1.0,Y1MAP1)).GE.RMINI) GO TO 901
C
      AB1MAP= ABS(Y1MAP1)
      AB2MAP= ABS(Y2MAP1)
      IF (AB1MAP.LT.RMINI.OR.AB2MAP.LT.RMINI) GO TO 901
C
      ORIMY1= ALOG(AB1MAP)
      DEXP= ALOG(AB2MAP)-ORIMY1
      IF (ABS(DEXP).LT.RMINI) GO TO 901
C
      SCAMY1= 1.0/DEXP
      RETURN
C
    4 IFUNC= IFUNCO-4
      GO TO (7,8,9,10,11,10,11,12,13,16,17,18,19), IFUNC
C
C          THIS PART SETS THE WINDOW AREA.
C
    7 CALL G1MAPP(RDATA(1),RDATA(3),XVAL1,YVAL1,0)
      CALL G1MAPP(RDATA(2),RDATA(4),XVAL2,YVAL2,0)
      X1WND1= AMIN1(XVAL1,XVAL2)-0.00001
      X2WND1= AMAX1(XVAL1,XVAL2)+0.00001
      Y1WND1= AMIN1(YVAL1,YVAL2)-0.00001
      Y2WND1= AMAX1(YVAL1,YVAL2)+0.00001
      RETURN
C
C          THIS PART SETS THE NEXT MASKING AREA,
C          PROVIDED THE LEVEL DOES NOT EXCEED 10.
C
    8 IF (MSKLV1.GE.10) RETURN
      MSKLV1= MSKLV1+1
      CALL G1MAPP(RDATA(1),RDATA(3),XVAL1,YVAL1,0)
      CALL G1MAPP(RDATA(2),RDATA(4),XVAL2,YVAL2,0)
      X1MSK1(MSKLV1)= AMIN1(XVAL1,XVAL2)
      X2MSK1(MSKLV1)= AMAX1(XVAL1,XVAL2)
      Y1MSK1(MSKLV1)= AMIN1(YVAL1,YVAL2)
      Y2MSK1(MSKLV1)= AMAX1(YVAL1,YVAL2)
      RETURN
C
C          THIS SECTION SETS A NEW MASKING LEVEL,
C          PROVIDED IT IS IN THE RANGE [0 TO 10].
C
    9 IF (IDATA(1).LT.0.OR.IDATA(1).GT.10) RETURN
C
      MSKLV1= IDATA(1)
      RETURN
C
C          THIS SETS X AND Y SCALING FACTORS.
C
   10 IF (ABS(RDATA(1)).GE.RMINI) SCALXC= RDATA(1)
      GO TO 14
C
   11 IF (ABS(RDATA(1)).GE.RMINI) SCALYC= RDATA(1)
      GO TO 14
C
C          THIS SETS THE ROTATION FACTOR (RADIANS).
C
   12 ROTATC= RDATA(1)
      GO TO 14
C
C          THIS SETS THE DEVICE-REFERENCE-POINT. (WHEN
C          NO DATA IS GIVEN, IT FOLLOWS THE PICTURE ONE).
C
   13 SHIFT1= .FALSE.
      IF (LENGTH.EQ.0) GO TO 14
C
      RDEVXC= RDATA(1)
      RDEVYC= RDATA(2)
      SHIFT1= .TRUE.
C
C          THIS SECTION RECALCULATES CURRENT TRANS. COEFFICIENTS.
C          THE PICTURE-REFERENCE-POINT IS AT THE CURRENT POSITION.
C
   14 RPICXC= XPLOTB
      RPICYC= YPLOTB
      IF (SHIFT1) GO TO 15
      RDEVXC= RPICXC
      RDEVYC= RPICYC
   15 COSROC= COS(ROTATC)
      SINROC= SIN(ROTATC)
      XCCX=  SCALXC*COSROC
      XCCY= -SCALYC*SINROC
      YCCX=  SCALXC*SINROC
      YCCY=  SCALYC*COSROC
C
C          THE CURRENT POSITION IS RESET TO ENSURE CORRECT PLACING.
C
      CALL G1LINE(XPLOTB,YPLOTB,.FALSE.)
C
C          THIS PART CALCULATES A NEW CURRENT REVERSE TRANSFORM
C          WHENEVER THE PROGRAM-LEVEL CURRENT TRANSFORM IS CHANGED.
C
      IF (INDLVL.NE.0) RETURN
C
      TEMPX= XCCX*XCCX+YCCX*YCCX
      TEMPY= XCCY*XCCY+YCCY*YCCY
      XRVX=  XCCX/TEMPX
      XRVY= -XCCY/TEMPY
      YRVX= -YCCX/TEMPX
      YRVY=  YCCY/TEMPY
      RPICXR= RPICXC
      RPICYR= RPICYC
      RDEVXR= RDEVXC
      RDEVYR= RDEVYC
      RETURN
C
C          THIS SECTION PERFORMS A TRANSFORMATION INDENT.
C
   16 INDLVL= INDLVL+1
      TEMPX= RDEVXC-RPICXB
      TEMPY= RDEVYC-RPICYB
      RDEVXB= RDEVXB+(XCBX*TEMPX+XCBY*TEMPY)
      RDEVYB= RDEVYB+(YCBX*TEMPX+YCBY*TEMPY)
      RPICXB= RPICXC
      RPICYB= RPICYC
      XTEMPX= XCBX*XCCX+XCBY*YCCX
      XTEMPY= XCBX*XCCY+XCBY*YCCY
      YTEMPX= YCBX*XCCX+YCBY*YCCX
      YTEMPY= YCBX*XCCY+YCBY*YCCY
      XCBX= XTEMPX
      XCBY= XTEMPY
      YCBX= YTEMPX
      YCBY= YTEMPY
      SCALXS= SCALXC
      SCALYS= SCALYC
      ROTATS= ROTATC
      RDEVXS= RDEVXC
      RDEVYS= RDEVYC
      RDEVXC= 0.0
      RDEVYC= 0.0
      RPICXC= 0.0
      RPICYC= 0.0
      XCCX= 1.0
      XCCY= 0.0
      YCCX= 0.0
      YCCY= 1.0
      SCALXC= 1.0
      SCALYC= 1.0
      ROTATC= 0.0
      SHIFT1= .FALSE.
      RETURN
C
C          THIS SECTION PERFORMS A TRANSFORMATION UNDENT.
C
   17 INDLVL= INDLVL-1
      SCALXC= SCALXS
      SCALYC= SCALYS
      ROTATC= ROTATS
      COSROC= COS(ROTATC)
      SINROC= SIN(ROTATC)
      XCCX=  SCALXC*COSROC
      XCCY= -SCALYC*SINROC
      YCCX=  SCALXC*SINROC
      YCCY=  SCALYC*COSROC
      RPICXC= RPICXB
      RPICYC= RPICYB
      RDEVXC= RDEVXS
      RDEVYC= RDEVYS
      XTEMPX= XCBX*COSROC/SCALXC-XCBY*SINROC/SCALYC
      XTEMPY= XCBY*COSROC/SCALYC+XCBX*SINROC/SCALXC
      YTEMPX= YCBX*COSROC/SCALXC-YCBY*SINROC/SCALYC
      YTEMPY= YCBY*COSROC/SCALYC+YCBX*SINROC/SCALXC
      XCBX= XTEMPX
      XCBY= XTEMPY
      YCBX= YTEMPX
      YCBY= YTEMPY
C
C          THE NEW SAVED VALUES ARE TAKEN FROM THE INPUT DATA.
C
      SCALXS= RDATA(1)
      SCALYS= RDATA(2)
      ROTATS= RDATA(3)
      RDEVXS= RDATA(4)
      RDEVYS= RDATA(5)
C
C          THE NEW BASE REFERENCE-POINTS ARE FOUND. (THE DEVICE
C          ONE IS A KNOWN POSITION WHEN GOING TO PICTURE-LEVEL 0).
C
      RPICXB= RDATA(6)
      RPICYB= RDATA(7)
      TEMPX= RDEVXC-RPICXB
      TEMPY= RDEVYC-RPICYB
      RDEVXB= RDEVXB-(XCBX*TEMPX+XCBY*TEMPY)
      RDEVYB= RDEVYB-(YCBX*TEMPX+YCBY*TEMPY)
      IF (INDLVL.GT.0) RETURN
C
      RDEVXB= 0.0
      RDEVYB= 0.0
      RETURN
C
C          THIS SETS THE CLIPPING-AREA TRANSFORMATION MODE.
C
   18 KLIPM1= IDATA(1)
      RETURN
C
C          THIS SETS THE TRANSFORMATION RANGE. THE CURRENT
C          TRANSFORMATION STATE IS SET ACCORDINGLY. THE
C          POSITION IS REAFFIRMED TO ENSURE CORRECT PLACING.
C
   19 MTRAN1= IDATA(1)
      CURTRA= .TRUE.
      IF (MTRAN1.EQ.0.OR.MTRAN1.EQ.2) CURTRA= .FALSE.
C
      CALL G1LINE(XPLOTB,YPLOTB,.FALSE.)
      RETURN
C
C          THIS SECTION IS FOR LOG.-MAPPING ERRORS.
C
  901 SCAMX1= 0.0
      SCAMY1= 0.0
      VALIM= 1.0
      IF (ABS(X2MAP1).GE.RMINI) VALIM= SIGN(VALIM,X2MAP1)
      IF (ABS(X1MAP1).GT.RMINI) VALIM= SIGN(VALIM,X1MAP1)
C
      X1MAP1= VALIM
      ORIMX1= VALIM
      VALIM= 1.0
      IF (ABS(Y2MAP1).GE.RMINI) VALIM= SIGN(VALIM,Y2MAP1)
      IF (ABS(Y1MAP1).GE.RMINI) VALIM= SIGN(VALIM,Y1MAP1)
C
      Y1MAP1= VALIM
      ORIMY1= VALIM
      NUMERR= 1001
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
C
      RETURN
      END
      SUBROUTINE G1INIT(ITYPE)
C
C          ------------------------------------------------
C          ROUTINE NO. (1001)   VERSION (A8.1APC) 20:NOV:90
C          ------------------------------------------------
C
C          THIS INITIALISES DEVICE-DEPENDENT VARIABLES.
C          (THIS VERSION IS FOR ADOBE COLOUR POSTSCRIPT).
C
C     ******************************************************************
C     *                                                                *
C     *    NOTE: ALL GHOST DEVICE-DEPENDENT COMMON BLOCKS ARE          *
C     *          SPECIFIED HERE. TO ENSURE THEIR INTEGRITY IT IS       *
C     *          ESSENTIAL THAT THIS ROUTINE CANNOT BE SWAPPED-OUT.    *
C     *                                                                *
C     ******************************************************************
C
C
C          <ITYPE> CONTROLS THE ACTION AS FOLLOWS:
C
C          =  1, INITIALISATION IS DONE UNCONDITIONALLY.
C          =  2, INITIALISATION IS DONE ONLY IF NOT ALREADY DONE.
C
C
      LOGICAL DONE
C
      COMMON /T1APAA/ IXPLOT,IYPLOT,IXMSAV,IYMSAV,LENPTH,MAXPTH
      COMMON /T1APCB/ CHIGHT,ZOBLAT,IREDPO(255),IGRNPO(255),IBLUPO(255),
     &                KOLOUR,IPAGE(17),IPGCNT
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1HCOL/ IHCOL1(255,2)
      COMMON /T1HRDM/ MAPCHR(256)
      COMMON /T1IOBF/ ICODEB(512),ISIZEB,INDXB,INITXB
      COMMON /T1KDEF/ KOLLID,KOLBAD,MAXCLS
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LINT/ ELWID,NFILLI,THIKST
C
      SAVE DONE
C
      DATA DONE /.FALSE./
C
C
      IF (ITYPE.LT.1.OR.ITYPE.GT.2) RETURN
      IF (DONE.AND.ITYPE.EQ.2)      RETURN
C
C          THE DEVICE LIMITS ARE IN ND-SPACE UNITS:
C
      DLIMX= 1.414
      DLIMY= 1.0
C
C          THE DEVICE RESOLUTIONS ARE FOR THE UNIT SQUARE:
C
      DRESX= 2329.0
      DRESY= 2329.0
C
C          [MAPCHR] GIVES THE SOFTWARE:HARDWARE CHAR. MAPPINGS:
C
      DO 100 ISETCO= 1,256
        IF (ISETCO.GT.33) GO TO 1
C
        MAPCHR(ISETCO)= 32
        GO TO 100
C
    1   IF (ISETCO.GT.127) GO TO 2
C
        MAPCHR(ISETCO)= ISETCO-1
        GO TO 100
C
    2   IF (ISETCO.NE.128) GO TO 3
C
        MAPCHR(ISETCO)= 32
        GO TO 100
C
    3   IF (ISETCO.GT.224) GO TO 4
C
        MAPCHR(ISETCO)= 35
        GO TO 100
C
    4   MAPCHR(ISETCO)= 42
  100 CONTINUE
C
      MAPCHR(143)=  34
      MAPCHR(161)=  43
      MAPCHR(162)=  42
      MAPCHR(165)=  61
      MAPCHR(168)=  60
      MAPCHR(173)=  46
      MAPCHR(176)=  39
      MAPCHR(177)=  45
      MAPCHR(179)=  47
      MAPCHR(184)=  62
      MAPCHR(206)=  40
      MAPCHR(207)=  91
      MAPCHR(208)= 123
      MAPCHR(222)=  41
      MAPCHR(223)=  93
      MAPCHR(224)= 125
      MAPCHR(233)=  43
      MAPCHR(247)=  43
C
C          THE OUTPUT BUFFER SIZE AND POINTER ARE SET. (THE
C          DECLARED SIZE OF [ICODEB] SHOULD BE LARGE ENOUGH):
C
      ISIZEB= 80
      INDXB= 1
      INITXB= 1
C
C          THE DEVICE DEFAULT LINE COLOUR IS BLACK AND
C          THE DEFAULT BACKGROUND COLOUR IS WHITE:
C
      KOLLID= 1
      KOLBAD= 5
      MAXCLS= 255
      KOLIN1= KOLLID
C
      DO 200 ISETCO= 1,255
        IHCOL1(ISETCO,1)= KOLLID
        IHCOL1(ISETCO,2)= KOLLID
  200 CONTINUE
C
C          THE DEVICE LINE WIDTH IS IN UNITS OF 0.001 IN ND-SPACE:
C
      ELWID= 0.5
      NFILLI= 1
      THIKST= 0.0005
C
C          THIS PART INITIALISES THE DEVICE COMMON BLOCKS:
C
      IXPLOT= -1
      IYPLOT= -1
      IXMSAV= 0
      IYMSAV= 0
      LENPTH= 0
      MAXPTH= 1400
      CHIGHT= (INT(DRESY)*MAGN1+500)/1000
      ZOBLAT= 1.0
C
      DO 300 ISET=1,255
        IREDPO(ISET)= 0
        IGRNPO(ISET)= 0
        IBLUPO(ISET)= 0
  300 CONTINUE
C
      IREDPO(2)= 100
      IREDPO(5)= 100
      IREDPO(7)= 100
      IREDPO(8)= 100
      IGRNPO(3)= 100
      IGRNPO(5)= 100
      IGRNPO(6)= 100
      IGRNPO(8)= 100
      IBLUPO(4)= 100
      IBLUPO(5)= 100
      IBLUPO(6)= 100
      IBLUPO(7)= 100
      KOLOUR= KOLLID
      IPAGE(1)= 37
      IPAGE(2)= 37
      IPAGE(3)= 80
      IPAGE(4)= 97
      IPAGE(5)= 103
      IPAGE(6)= 101
      IPAGE(7)= 58
      IPAGE(8)= 32
      IPAGE(9)= 70
      IPAGE(10)= 114
      IPAGE(11)= 97
      IPAGE(12)= 109
      IPAGE(13)= 101
      IPAGE(14)= 32
      IPAGE(15)= 48
      IPAGE(16)= 48
      IPAGE(17)= 49
      IPGCNT= 1
C
C          <G1HRDW> PERFORMS DEVICE INITIALISATION.
C
      CALL G1HRDW(0)
      DONE= .TRUE.
      RETURN
      END
      SUBROUTINE G1MARV(XPOSND,YPOSND,XVECT,YVECT)
C
C          ------------------------------------------------
C          ROUTINE NO. (1043)   VERSION (A8.3)    27:NOV:86
C          ------------------------------------------------
C
C          THIS MAPS THE POINT <XPOSND,YPOSND> IN DEVICE SPACE
C          ONTO THE POINT <XVECT,YVECT> IN VECTOR SPACE. (THIS
C          IS THE MIRROR-IMAGE OPERATION TO ROUTINE <G1MAPP>).
C
C
      COMMON /T1MAPS/ ORIMX1,ORIMY1,SCAMX1,SCAMY1
      COMMON /T1MAPT/ MAPNO1
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      IF (ABS(SCAMX1).LT.RMINI) GO TO 2
      IF (MAPNO1.EQ.3.OR.MAPNO1.EQ.4) GO TO 1
C
      XVECT= (XPOSND/SCAMX1)+ORIMX1
      GO TO 2
C
    1 XVECT= EXP(XPOSND/SCAMX1+ORIMX1)
    2 IF (ABS(SCAMY1).LT.RMINI) RETURN
      IF (MAPNO1.EQ.2.OR.MAPNO1.EQ.4) GO TO 3
C
      YVECT= (YPOSND/SCAMY1)+ORIMY1
      RETURN
C
    3 YVECT= EXP(YPOSND/SCAMY1+ORIMY1)
      RETURN
      END
      SUBROUTINE G1CHAR(NCHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1032)   VERSION (A8.7)    14:MAR:91
C          ------------------------------------------------
C
C          THIS DRAWS OUT THE CHARACTER NO. <NCHAR>.
C
C
      INTEGER IXPTS(30),IYPTS(30),IXUNDL(7),IYUNDL(7)
      LOGICAL DRAW,DRAWN
      LOGICAL TYPMOD,KHRDW1,OPEN,CURTRA
C
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDCC/ SINCHR,COSCHR
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CFIN/ INDLEN(2,256),WIDCHR(256)
      COMMON /T1CFON/ KFONT1
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1DENA/ OPEN
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1HRDC/ KHRDW1
      COMMON /T1HRDM/ MAPCHR(256)
      COMMON /T1LIND/ PATREM
      COMMON /T1PPAT/ XPLOTA,YPLOTA
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1SPEC/ XSPEC(4600),YSPEC(4600),ICHPTR(128),NEXTPT,NSTORE
      COMMON /T1TCOB/ XCBX,XCBY,YCBX,YCBY,RPICXB,RPICYB,RDEVXB,RDEVYB
      COMMON /T1TCOC/ XCCX,XCCY,YCCX,YCCY,RPICXC,RPICYC,RDEVXC,RDEVYC,
     &                CURTRA
      COMMON /T1TSPA/ X1TYPW,X2TYPW,Y1TYPW,Y2TYPW
C
      DATA IXUNDL /7,7,6,0,7,0,6/, IYUNDL /0,2,1,1,0,0,0/,
     &     CHRSIZ /1.428571E-4/, DOTSIZ /0.0005/
C
C
C          IF NO DEVICE CHANNEL IS ON, NOTHING CAN BE DONE.
C
C          IF TYPING MODE HAS BEEN SET, THE CHAR. IS NOT
C          DRAWN IF IT LIES OUTSIDE THE TYPEWRITER WINDOW.
C
      IF (.NOT.OPEN)                            RETURN
      IF (.NOT.TYPMOD) GO TO 1
      IF ((XCHAR-X1TYPW)*(XCHAR-X2TYPW).GT.0.0) RETURN
      IF ((YCHAR-Y1TYPW)*(YCHAR-Y2TYPW).GT.0.0) RETURN
C
C          IF HARDWARE CHARS. ARE BEING DONE, A CHECK IS MADE
C          TO ENSURE THE POSITION LIES WITHIN THE DEVICE WINDOW.
C
    1 IF (.NOT.KHRDW1) GO TO 4
C
      XCHARB= XCBX*(XCHAR-RPICXB)+XCBY*(YCHAR-RPICYB)+RDEVXB
      YCHARB= YCBX*(XCHAR-RPICXB)+YCBY*(YCHAR-RPICYB)+RDEVYB
      IF (CURTRA) GO TO 2
C
      XCHARA= XCHARB
      YCHARA= YCHARB
      GO TO 3
C
    2 XCHARA= XCCX*(XCHARB-RPICXC)+XCCY*(YCHARB-RPICYC)+RDEVXC
      YCHARA= YCCX*(XCHARB-RPICXC)+YCCY*(YCHARB-RPICYC)+RDEVYC
    3 IF (XCHARA.LT.0.0.OR.XCHARA.GT.DLIMX) RETURN
      IF (YCHARA.LT.0.0.OR.YCHARA.GT.DLIMY) RETURN
C
      IXCHAR= DRESX*XCHARA+0.5
      IYCHAR= DRESY*YCHARA+0.5
      CALL G1FILB(IXCHAR,IYCHAR,-2,MAPCHR(NCHAR+1))
      RETURN
C
    4 XSAVEB= XPLOTB
      YSAVEB= YPLOTB
      XSAVEA= XPLOTA
      YSAVEA= YPLOTA
      REMSAV= PATREM
      IF (KFONT1.GE.11) GO TO 9
C
C          FOR SOFTWARE CHARS., FIRST THE SPECIFICATION IS
C          FETCHED. IF UNDERLINE IS REQUIRED, THE NECESSARY
C          EXTRA SPECIFICATION IS APPENDED USING LOOP-100.
C
      CALL G1SPEC(NCHAR,KFONT1,IXPTS,IYPTS,LENGTH)
      IF (IUNDL1.LE.0) GO TO 5
C
      NADD= IUNDL1*3+1
C
      DO 100 IADD= 1,NADD
        IAPPND= LENGTH+IADD
        IXPTS(IAPPND)= IXUNDL(IADD)
        IYPTS(IAPPND)= IYUNDL(IADD)
  100 CONTINUE
C
      LENGTH= LENGTH+NADD
C
C          IF THE FINAL SPEC. HAS ZERO LENGTH, NOTHING IS DONE.
C
C          LOOP-200 SCANS THROUGH THE COORDINATE PAIRS,
C          DRAWING THE ELEMENTAL LINES OF THE CHARACTER.
C          SPECIAL FUNCTIONS ARE GIVEN BY <IXV>= 7, THE
C          ACTION BEING DETERMINED BY <IYV> AS FOLLOWS:
C
C          = 0, THE NEXT ELEMENTAL LINE IS NOT VISIBLE,
C          = 1, THE Y-OFFSET IS SET TO -3,
C          = 2, THE Y-OFFSET IS SET TO -2,
C          = 3, THE Y-OFFSET IS SET TO -1,
C          = 4, THE Y-OFFSET IS SET TO  0,
C          = 5, THE Y-OFFSET IS SET TO +1,
C          = 6, THE Y-OFFSET IS SET TO +2,
C          = 7, (UNDEFINED).
C
C          A LOZENGE IS DRAWN WHEN TWO SUCCESSIVE VECTORS ARE
C          NOT VISIBLE, OR IF THE LAST VECTOR IS NOT VISIBLE.
C
    5 IF (LENGTH.LE.0) RETURN
C
      IYOFF= 0
      DRAW= .FALSE.
      DRAWN= .TRUE.
C
      DO 200 IPT= 1,LENGTH
        IXV= IXPTS(IPT)
        IYV= IYPTS(IPT)
        IF (IXV.LE.6) GO TO 7
        IF (IYV.EQ.0) GO TO 6
C
        IYOFF= IYV-4
        GO TO 200
C
    6   DRAW= .FALSE.
        IF (.NOT.DRAWN) GO TO 8
        GO TO 200
C
    7   IYV= IYV+IYOFF
        X1= (IXV-3)*MAGN1*CHRSIZ
        Y1= (IYV-2)*MAGN1*CHRSIZ
        X1= (X1+Y1*ITAL1*0.25)*OBLAT1
        XNOW= XCHAR+X1*COSCHR-Y1*SINCHR
        YNOW= YCHAR+X1*SINCHR+Y1*COSCHR
        IF (.NOT.DRAW.AND.IPT.EQ.LENGTH) GO TO 8
C
        CALL G1LINE(XNOW,YNOW,DRAW)
        DRAWN= DRAW
        DRAW= .TRUE.
        GO TO 200
C
    8   CALL G1LINE(XNOW,       YNOW+DOTSIZ,.FALSE.)
        CALL G1LINE(XNOW-DOTSIZ,YNOW,       .TRUE.)
        CALL G1LINE(XNOW,       YNOW-DOTSIZ,.TRUE.)
        CALL G1LINE(XNOW+DOTSIZ,YNOW,       .TRUE.)
        CALL G1LINE(XNOW,       YNOW+DOTSIZ,.TRUE.)
  200 CONTINUE
C
      GO TO 14
C
C          FONTS 11-24 ARE HIGH-QUALITY FONTS.
C
    9 NCHAR1= NCHAR+1
      IF (NCHAR1.LE.128) GO TO 10
C
      IPOS= 1
      IF (NCHAR1.NE.NSTORE) CALL G1CHIO(2,NCHAR1)
C
      NSTORE= NCHAR1
      GO TO 12
C
   10 IF (ICHPTR(NCHAR1).NE.0) GO TO 11
C
      CALL G1CHIO(2,NCHAR1)
   11 IPOS= ICHPTR(NCHAR1)
   12 DRAW= .FALSE.
      IP= IPOS-1
C
      DO 400 IPT= 1,INDLEN(2,NCHAR1)
        IP= IP+1
        XC= XSPEC(IP)
        IF(XC.LT.-100.0) GO TO 13
C
        X1= (XC-3.0)*MAGN1*CHRSIZ*OBLAT1
        Y1= (YSPEC(IP)-2.0)*MAGN1*CHRSIZ
        XNOW= XCHAR+X1*COSCHR-Y1*SINCHR
        YNOW= YCHAR+X1*SINCHR+Y1*COSCHR
        CALL G1LINE(XNOW,YNOW,DRAW)
        DRAW= .TRUE.
        GO TO 400
C
   13   DRAW= .FALSE.
  400 CONTINUE
C
      IF (IUNDL1.LE.0) GO TO 14
C
C          UNDERLINE HIGH QUALITY CHARACTERS.
C
      XPOS= 3.0*WIDCHR(NCHAR1)
      YPOS= -3.0
      DRAW= .FALSE.
C
      DO 500 LIN= 1,IUNDL1*2
        XNOW= XCHAR+(XPOS*COSCHR*OBLAT1-YPOS*SINCHR)*MAGN1*CHRSIZ
        YNOW= YCHAR+(XPOS*SINCHR*OBLAT1+YPOS*COSCHR)*MAGN1*CHRSIZ
        CALL G1LINE(XNOW,YNOW,DRAW)
        IF (MOD(LIN,2).EQ.1) XPOS= -XPOS
        IF (LIN.EQ.2) YPOS= YPOS-1.0
C
        DRAW= .NOT.DRAW
  500 CONTINUE
C
   14 XPLOTB= XSAVEB
      YPLOTB= YSAVEB
      XPLOTA= XSAVEA
      YPLOTA= YSAVEA
      PATREM= REMSAV
C
      RETURN
      END
      SUBROUTINE G1CHSP
C
C          ------------------------------------------------
C          ROUTINE NO. (1034)   VERSION (A8.1)    21:NOV:90
C          ------------------------------------------------
C
C          THIS SUPPORTS G1CLS2 AND RESETS THE CHARACTER SPACING CONSTANTS.
C
C
      LOGICAL TYPMOD
C
      COMMON /T1CANG/ STANG1,CRANG1
      COMMON /T1CANU/ STANGU,CRANGU
      COMMON /T1CDCS/ SINSTR,COSSTR
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CMOC/ ADDSPX,ADDLNX,ADDSPY,ADDLNY
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CMOV/ ADDSP,ADDLN
      COMMON /T1CSPA/ X1CHR1,X2CHR1,Y1CHR1,Y2CHR1
      COMMON /T1TSPA/ X1TYPW,X2TYPW,Y1TYPW,Y2TYPW
      COMMON /T1TYPQ/ IQUAD
      COMMON /T3CONS/ PI
C
C
C          THE FOLLOWING IS A STATEMENT FUNCTION TO CONVERT AN
C          ANGLE (RADIANS) INTO A QUADRANT NO.
C
      KQUADR(STANG1)= (STANG1*2.0/PI)+0.5
C
      ADDLN= MAGN1*1.428571E-3
      CALL G1HRDW(3)
      SINANG= ABS(SIN(CRANGU-STANGU))
      COSANG= ABS(COS(CRANGU-STANGU))
      IF (ADDSP*SINANG.GT.ADDLN*COSANG) GO TO 1
C
      ADDSP= ADDSP/COSANG
      ADDLN= ADDLN/COSANG
      GO TO 2
C
    1 SAVE= ADDSP
      ADDSP= ADDLN/SINANG
      ADDLN= SAVE/SINANG
    2 ADDSPX=  ADDSP*COSSTR
      ADDSPY=  ADDSP*SINSTR
      ADDLNX=  ADDLN*SINSTR
      ADDLNY= -ADDLN*COSSTR
C
C          IF TYPING MODE IS IN EFFECT, THE TYPING MODE WINDOW
C          IS SET. THIS IS SMALLER THAN THE CHARACTER WINDOW IN
C          EACH DIRECTION BY THE APPROPRIATE (CHARACTER OR LINE)
C          SPACING TO AVOID PARTIAL WINDOWING OF EDGE CHARACTERS.
C
      IF (.NOT.TYPMOD) RETURN
C
      IQUAD= MOD(KQUADR(STANG1),4)+1
      IF (IQUAD.EQ.1.OR.IQUAD.EQ.3) GO TO 3
C
      SAVE= ADDSP
      ADDSP= ADDLN
      ADDLN= SAVE
    3 X1TYPW= X1CHR1+0.7*ADDSP
      X2TYPW= X2CHR1-0.7*ADDSP
      Y1TYPW= Y1CHR1+0.7*ADDLN
      Y2TYPW= Y2CHR1-0.7*ADDLN
C
      RETURN
C
      END
      SUBROUTINE G1CONC(XPOS,YPOS,THETA,ELONG)
C
C          ------------------------------------------------
C          ROUTINE NO. (1022)   VERSION (A7.7)    11:FEB:85
C          ------------------------------------------------
C
C          THIS GENERATES ELLIPTICAL ARCS CENTRED
C          ABOUT THE CURRENT PLOTTING POSITION.
C
C          THE ARGUMENTS ARE:
C
C          <XPOS>   IS THE START-POSITION X-COORDINATE,
C          <YPOS>   IS THE START-POSITION Y-COORDINATE
C                   (BOTH RELATIVE TO THE CURRENT PLOTTING POSITION),
C          <THETA>  IS THE ANGLE SUBTENDED BY THE ARC (IN RADIANS),
C          <ELONG>  IS THE RATIO OF MAJOR:MINOR AXES LENGTHS.
C
C
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1PPAT/ XPLOTA,YPLOTA
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T3CONS/ PI
C
C
C          FIRSTLY THE CURRENT POSITIONS ARE STORED.
C
      XSAVEB= XPLOTB
      YSAVEB= YPLOTB
      XSAVEA= XPLOTA
      YSAVEA= YPLOTA
      XSAVEC= XCHAR
      YSAVEC= YCHAR
C
C          THE ELLIPSE CONSTANTS ARE THEN CALCULATED,
C          AND THE REQUIRED PORTION OF THE CURVE IS DRAWN.
C
      DIST= 13.0*DRESX*SQRT(XPOS*XPOS+YPOS*YPOS*ELONG*ELONG)
      IF (DIST.LE.0.0) RETURN
C
      NPTS= MAX0(8,INT(SQRT(DIST)))
      NPTS= MIN0(500,NPTS)*(ABS(THETA)/(2.0*PI))
      IF (NPTS.LE.0) NPTS= 1
C
      DANGL= THETA/NPTS
      COSDA= COS(DANGL)
      SINDA= SIN(DANGL)
      RATIO= ABS(ELONG)
      COEFXX=  COSDA
      COEFXY= -SINDA*RATIO
      COEFYX=  SINDA/(COSDA*RATIO)
      COEFYY=  1.0/COSDA
C
      XNEW= XPOS
      YNEW= YPOS
      XARG= XNEW+XSAVEB
      YARG= YNEW+YSAVEB
      CALL G1LINE(XARG,YARG,.FALSE.)
      DO 100 IPT= 1,NPTS
        XNEW= COEFXX*XNEW+COEFXY*YNEW
        YNEW= COEFYX*XNEW+COEFYY*YNEW
        XARG= XNEW+XSAVEB
        YARG= YNEW+YSAVEB
        CALL G1LINE(XARG,YARG,.TRUE.)
  100 CONTINUE
C
C          LASTLY, THE CURRENT POSITIONS ARE RESTORED.
C
      XPLOTB= XSAVEB
      YPLOTB= YSAVEB
      XPLOTA= XSAVEA
      YPLOTA= YSAVEA
      XCHAR=  XSAVEC
      YCHAR=  YSAVEC
C
      RETURN
      END
      SUBROUTINE G1CRV1(XPOS,YPOS,LASTPT)
C
C          ------------------------------------------------
C          ROUTINE NO. (1026)   VERSION (A8.4)    03:NOV:89
C          ------------------------------------------------
C
C          THIS GENERATES A SMOOTH CURVE FROM A SET OF POINTS.
C          TWO DIFFERENT CURVE-FITTING METHODS ARE SUPPORTED.
C
C
      REAL    CDISTS(3)
      LOGICAL LASTPT
      LOGICAL OPCURV
C
      COMMON /T1CRSV/ XCVSAV(3),YCVSAV(3),INDXCV,ICVPTR,
     &                DX1CV,DY1CV,XI1CV,YI1CV,NCVPTS,CUBX1,CUBY1
      COMMON /T1CURV/ MCURV1,OPCURV
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA GPARA /13.0/, ERRZON /1.0E-5/
C
      G1END(DV,FV)= (3.0*DV-FV)*0.5
C
C
C          POINTS ARE SAVED UNTIL A TRIPLET IS OBTAINED.
C          INITIAL VALUES ARE SET AT THE START OF A CURVE.
C
      XINP= XPOS
      YINP= YPOS
      IF (ICVPTR.NE.3) GO TO 1
C
      NCVPTS= 1
      INDXCV= 0
      ICVPTR= 0
      GO TO 9
C
C          SUCCESSIVE COINCIDENT POINTS ARE IGNORED.
C          THE CHORD GRADIENTS ARE CALCULATED HERE.
C
    1 DX2CV= XI1CV-XINP
      DY2CV= YI1CV-YINP
      IF (ABS(DX2CV).LT.RMINI.AND.ABS(DY2CV).LT.RMINI) GO TO 10
C
      NCVPTS= NCVPTS+1
      IF (NCVPTS.GT.2) GO TO 2
      IF (OPCURV)      GO TO 7
      GO TO 8
C
C          THE GRADIENTS AT THE MIDDLE POINT ARE CALCULATED.
C          THE ARITHMETIC MEAN IS USED WITH THE FIRST METHOD
C          AND THE HARMONIC MEAN IS USED WITH THE SECOND ONE.
C
    2 IF (MCURV1.NE.1) GO TO 3
C
      GRADX= (DX1CV+DX2CV)*0.5
      GRADY= (DY1CV+DY2CV)*0.5
      GO TO 5
C
    3 GRADX= 0.0
      EXT= DX1CV*DX2CV
      IF (EXT.LE.0.0) GO TO 4
C
      GRADX= (EXT+EXT)/(DX1CV+DX2CV)
    4 GRADY= 0.0
      EXT= DY1CV*DY2CV
      IF (EXT.LE.0.0) GO TO 5
C
      GRADY= (EXT+EXT)/(DY1CV+DY2CV)
    5 IF (NCVPTS.GT.3) GO TO 13
C
C          AFTER 3 POINTS HAVE BEEN DONE, THE NEXT
C          PORTION OF THE CURVE IS THEN PROCESSED.
C
      IF (INDXCV.EQ.2) GO TO 6
C
C          GRADIENTS AT THE START OF THE CURVE ARE FOUND HERE.
C
      CUBX1= G1END(DX1CV,GRADX)
      CUBY1= G1END(DY1CV,GRADY)
      GO TO 13
C
    6 CUBX1= GRADX
      CUBY1= GRADY
C
C          THIS MOVES THE PEN TO THE START POSITION.
C
    7 CALL G1LINE(XI1CV,YI1CV,.FALSE.)
C
C          VARIABLES NEEDED FOR SUBSEQUENT USE ARE SAVED.
C          THE FIRST 3 POINTS ARE SAVED FOR A CLOSED CURVE.
C
    8 DX1CV= DX2CV
      DY1CV= DY2CV
    9 XI1CV= XINP
      YI1CV= YINP
      IF (OPCURV.OR.INDXCV.EQ.3) GO TO 10
C
      INDXCV= INDXCV+1
      XCVSAV(INDXCV)= XINP
      YCVSAV(INDXCV)= YINP
   10 IF (.NOT.LASTPT) RETURN
C
C          THE CURVE IS COMPLETED AFTER THE LAST POINT IS DONE.
C          IF THE CURVE IS CLOSED, THE FIRST 3 POINTS ARE USED AGAIN.
C
      IF (INDXCV.NE.3) GO TO 11
C
      ICVPTR= ICVPTR+1
      XINP= XCVSAV(ICVPTR)
      YINP= YCVSAV(ICVPTR)
      GO TO 1
C
   11 ICVPTR= 3
      IF (NCVPTS.LE.1) RETURN
      IF (NCVPTS.GE.3) GO TO 12
C
C          A CURVE WITH ONLY TWO POINTS IS A STRAIGHT LINE.
C
      IF (INDXCV.EQ.2) CALL G1LINE(XCVSAV(1),YCVSAV(1),.FALSE.)
C
      CALL G1LINE(XI1CV,YI1CV,.TRUE.)
      GO TO 26
C
C          THIS SECTION CALCULATES GRADIENTS AT THE END OF THE CURVE.
C          A CUBIC FUNCTION WITH ZERO 2ND. END-DERIVATIVES IS USED.
C
   12 GRADX= G1END(DX1CV,CUBX1)
      GRADY= G1END(DY1CV,CUBY1)
C
C          THIS SECTION DRAWS A SMOOTH CURVE BETWEEN TWO POINTS
C          USING BUTLAND'S ALGORITHM TO MINIMISE THE NUMBER OF
C          STRAIGHT SEGMENTS. THE CURVE SMOOTHNESS (AND THE NO.
C          OF SEGMENTS) INCREASES AS <GPARA> IS MADE LARGER.
C
   13 D1X= CUBX1
      D1Y= CUBY1
C
C          THE NEW CUBIC COEFFICIENTS ARE CALCULATED HERE.
C
      CUBX3= CUBX1+GRADX-DX1CV-DX1CV
      CUBX2= DX1CV-CUBX3-GRADX
      CUBX1= GRADX
      CUBY3= CUBY1+GRADY-DY1CV-DY1CV
      CUBY2= DY1CV-CUBY3-GRADY
      CUBY1= GRADY
C
C          ANY POINTS WHERE THE CURVATURE CHANGES DIRECTION IS
C          FOUND, AND THE VALUE OF <CDIST> AT THESE POINTS IS SAVED.
C
      NFITS= 1
      CUB23= 3.0*(CUBX2*CUBY3-CUBX3*CUBY2)
      CUB31= 3.0*(CUBX3*CUBY1-CUBX1*CUBY3)
      SNUM= CUBX1*CUBY2-CUBX2*CUBY1
      IF (ABS(CUB23).GE.RMINI) GO TO 14
      IF (ABS(CUB31).LT.RMINI) GO TO 17
C
      CDIST= SNUM/CUB31
      GO TO 16
C
   14 CDIST= CUB31/(CUB23+CUB23)
      TEMP2= CDIST*CDIST-SNUM/CUB23
      IF (ABS(TEMP2).LT.ERRZON) GO TO 16
      IF (TEMP2.LT.0.0)         GO TO 17
C
      TEMP2= SQRT(TEMP2)
      TEMP1= CDIST+TEMP2
      IF (TEMP1.LT.ERRZON)      GO TO 17
      IF (1.0-TEMP1.LT.ERRZON)  GO TO 15
C
      CDISTS(1)= TEMP1
      NFITS= 2
   15 CDIST= CDIST-TEMP2
   16 IF (CDIST.LT.ERRZON.OR.1.0-CDIST.LT.ERRZON) GO TO 17
C
      CDISTS(NFITS)= CDIST
      NFITS= NFITS+1
   17 CDISTS(NFITS)= 0.0
      CDIST= 1.0
C
C          THE MINIMUM NUMBER OF STRAIGHT LINE SEGMENTS
C          IS FITTED TO EACH PART OF THE CURVE IN TURN.
C
      DO 100 IFIT= 1,NFITS
        KOUNT= 0
        NDIV= 0
        IF (ABS(D1X).LT.RMINI.AND.ABS(D1Y).LT.RMINI) GO TO 24
C
        EXTRX= (3.0*CUBX3*CDISTS(IFIT)+2.0*CUBX2)*CDISTS(IFIT)+CUBX1
        EXTRY= (3.0*CUBY3*CDISTS(IFIT)+2.0*CUBY2)*CDISTS(IFIT)+CUBY1
        IF (ABS(EXTRX).LT.RMINI.AND.ABS(EXTRY).LT.RMINI) GO TO 24
C
        ALPHA= ATAN2(D1Y,D1X)
        BETA=  ATAN2(EXTRY,EXTRX)
        THETA= ALPHA-BETA
        DIMID= 0.5*(CDIST+CDISTS(IFIT))
        CUMID= DIMID*(CUB23*DIMID-CUB31)+SNUM
C
C          IF <THETA> DOES NOT HAVE THE SAME SIGN AS THE
C          CURVATURE <CUMID>, IT IS ADJUSTED BY 360 DEGREES.
C
        IF (CUMID*THETA.GE.0.0) GO TO 18
C
        ADJ= 6.283185307
        IF (CUMID.LT.0.0) ADJ= -ADJ
C
        THETA= THETA+ADJ
C
C          <NDIV> STRAIGHT-LINE ELEMENTS ARE FOUND AND DRAWN.
C
   18   NDIV= INT(ABS(THETA*GPARA)-0.5)
        IF (NDIV.LT.1) GO TO 24
C
        THETA2= THETA/(NDIV+1)
        TANI= COS(THETA2)/SIN(THETA2)
C
   19     D2X= CUBX2+CDIST*3.0*CUBX3
          D2Y= CUBY2+CDIST*3.0*CUBY3
          D1X= CUBX1+CDIST*(CUBX2+D2X)
          D1Y= CUBY1+CDIST*(CUBY2+D2Y)
          TNUM= D1X*D1X+D1Y*D1Y
          SLOP1= TANI*(D1X*D2Y-D1Y*D2X)+D1X*D2X+D1Y*D2Y
          SLOP2= 3.0*(TANI*(D1X*CUBY3-D1Y*CUBX3)+D1X*CUBX3+D1Y*CUBY3)
C
C          THE CHANGE IN <CDIST> DEPENDS ON THE CURVATURE.
C          <CDSTEP> IS NOT ALLOWED TO GO TOO CLOSE TO ZERO.
C
          IF (ABS(SLOP2).GT.ERRZON) GO TO 21
          IF (ABS(SLOP1).GT.ERRZON) GO TO 20
C
          CDSTEP= 0.01
          GO TO 22
C
   20     CDSTEP= TNUM/(SLOP1+SLOP1)
          GO TO 22
C
   21     ARG= SLOP1*SLOP1-TNUM*SLOP2
          IF (ARG.LT.ERRZON) ARG= 0.0
C
          CDSTEP= (SLOP1-SQRT(ARG))/SLOP2
   22     IF (CDSTEP.LT.ERRZON) CDSTEP= 0.001
C
          CDIST= CDIST-CDSTEP
C
C          THE NEXT LINE HAS BEEN REPLACED BY THE ONE AFTER.
C
C         IF (CDSTEP.GT.CDIST) CDIST= 0.0
          IF (CDIST.LT.ERRZON) CDIST= 0.0
C
   23     XNOW= XI1CV+CDIST*(CUBX1+CDIST*(CUBX2+CDIST*CUBX3))
          YNOW= YI1CV+CDIST*(CUBY1+CDIST*(CUBY2+CDIST*CUBY3))
          CALL G1LINE(XNOW,YNOW,.TRUE.)
          KOUNT= KOUNT+1
          IF (KOUNT.LT.NDIV) GO TO 19
          IF (KOUNT.GT.NDIV) GO TO 25
C
   24     CDIST= CDISTS(IFIT)
          GO TO 23
C
   25   D1X= EXTRX
        D1Y= EXTRY
  100 CONTINUE
C
   26 IF (ICVPTR.LT.3) GO TO 8
C
      RETURN
      END
      SUBROUTINE G1HRDW(ICODE)
C
C          ------------------------------------------------
C          ROUTINE NO. (1002)   VERSION (A8.1APC) 01:MAY:91
C          ------------------------------------------------
C
C          THIS SETS HARDWARE-IMPLEMENTED FACILITIES.
C          (THIS VERSION IS FOR ADOBE COLOUR POSTSCRIPT).
C
C
C          <ICODE> DETERMINES THE HARDWARE FUNCTION REQUIRED:
C
C                  =  0, DEVICE INITIALISATION IS DONE.
C                  =  1, BROKEN LINE TYPE IS SET.
C                  =  2, CHAR. ORIENTATION IS SET.
C                  =  3, CHARACTER SIZE IS SET.
C                  =  4, LINE COLOUR NUMBER IS SET.
C                  =  5, PORTRAIT MODE IS SET.
C                  =  6, ITALIC CHARACTERS ARE SET.
C                  =  7, CHARACTER OBLATENESS IS SET.
C                  =  8, A COLOUR TABLE ENTRY IS SET.
C                  =  .
C                  = 11, A POLYGONAL BOUNDARY IS BEGUN.
C                  = 12, A POLYGONAL AREA IS FILLED.
C                  = 13, SHADING OPTION FLAG IS RESET.
C
C
      INTEGER IDUMMY(1),IPL0(17),IPL1(29),IPL2(35),IPL3(42),IPL4(42),
     &        IPL5(53),IPL6(62),IPL7(51),IPL8(48),IPL9(51),IPLA(61),
     &        IPLB(43),IPLC(43),IPLD(55),IPLE(71),IPLF(59),IPLG(70),
     &        IPLH(61),IPLI(58),IPLJ(30),IPLK(12)
      LOGICAL KHRDW1,LHRDW1
C
      COMMON /T1APCB/ CHIGHT,ZOBLAT,IREDPO(255),IGRNPO(255),IBLUPO(255),
     &                KOLOUR,IPAGE(17),IPGCNT
      COMMON /T1CANU/ STANGU,CRANGU
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CMLN/ NMFILE(32),LNFILE,ICMND(35,2)
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1FLTY/ IFLTY1,IFLRP1
      COMMON /T1HRDC/ KHRDW1
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1KDEF/ KOLLID,KOLBAD,MAXCLS
      COMMON /T1KFIL/ KOLFL1
      COMMON /T1KTAB/ REDCO1(255),GRNCO1(255),BLUCO1(255),NCOLS1
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T3CONS/ PI
C
C          ARRAYS ARE INITIALISED TO:
C
c slmod begin
C   IPL0  %!PS-Adobe-1.0
c
C   IPL0  %!PS-GHOST80-1.0
c slmod end
C   IPL1  %%BoundingBox: 18 18 570 570
C   IPL2  /SavedState save def 50 dict begin
C   IPL3  /bd {bind def} bind def /ed {exch def} bd
C   IPL4  /ch 39 def /cw 33 def /cs 0 def /cr 0 def
C   IPL5  /gs {gsave} bd /gr {grestore} bd /C {setrgbcolor} bd
C   IPL6  /m {moveto} bd /l {lineto} bd /M {rmoveto} bd /L {rlineto} bd
C   IPL7  /T {/marked true def} bd /F {/marked false def} bd
C   IPL8  /s {currentpoint stroke T m} bd /n {newpath} bd
C   IPL9  /f {currentpoint fill T m} bd /t {setlinewidth} bd
C   IPLA  /i {0 0 0 C 1 setlinecap 1 setlinejoin 0.24 0.24 scale 75 75
C   IPLB   translate fs F} bd /S {/sv save def i} bd
C   IPLC  /FontArray [/Courier /Courier-Oblique] def
C   IPLD  /fs {FontArray cs get findfont 1 scalefont setfont} bd
C   IPLE  /sch {/ch ed} bd /scw {/cw ed} bd /scs {/cs ed fs} bd
C          /scr {/cr ed} bd
C   IPLF  /c {gs cr rotate cw ch scale -0.3 -0.16667 M show gr T} bd
C   IPLG  /p {marked {showpage} if ch cw cs cr sv restore scr scs scw
C          sch S} bd
C   IPLH  /x {p end SavedState restore} bd /P {s gs 5 t 0 0 L s gr} bd
C   IPLI  /g {currentfile token pop 2.329 mul dup 0 eq {pop} if} bd
C   IPLJ  /b {[g g g g] 0 setdash} bd S
C   IPLK  %%EndProlog
C
c slmod begin
      DATA IPL0 / 37, 33, 80, 83, 45, 65,100,111, 98,101, 45, 49,
     &            46, 48, 32, 32, 32/
c
c      DATA IPL0 / 37, 33, 80, 83, 45, 71, 72, 79, 83, 84, 56, 48,
c     &            45, 49, 46, 48, 32/
c slmod end
      DATA IPL1 / 37, 37, 66,111,117,110,100,105,110,103, 66,111,
     &           120, 58, 32, 49, 56, 32, 49, 56, 32, 53, 55, 48,
     &            32, 53, 55, 48, 32/
      DATA IPL2 / 47, 83, 97,118,101,100, 83,116, 97,116,101, 32,
     &           115, 97,118,101, 32,100,101,102, 32, 53, 48, 32,
     &           100,105, 99,116, 32, 98,101,103,105,110, 32/
      DATA IPL3 / 47, 98,100, 32,123, 98,105,110,100, 32,100,101,
     &           102,125, 32, 98,105,110,100, 32,100,101,102, 32,
     &            47,101,100, 32,123,101,120, 99,104, 32,100,101,
     &           102,125, 32, 98,100, 32/
      DATA IPL4 / 47, 99,104, 32, 51, 57, 32,100,101,102, 32, 47,
     &            99,119, 32, 51, 51, 32,100,101,102, 32, 47, 99,
     &           115, 32, 48, 32,100,101,102, 32, 47, 99,114, 32,
     &            48, 32,100,101,102, 32/
      DATA IPL5 / 47,103,115, 32,123,103,115, 97,118,101,125, 32,
     &            98,100, 32, 47,103,114, 32,123,103,114,101,115,
     &           116,111,114,101,125, 32, 98,100, 32, 47, 67, 32,
     &           123,115,101,116,114,103, 98, 99,111,108,111,114,
     &           125, 32, 98,100, 32/
      DATA IPL6 / 47,109, 32,123,109,111,118,101,116,111,125, 32,
     &            98,100, 32, 47,108, 32,123,108,105,110,101,116,
     &           111,125, 32, 98,100, 32, 47, 77, 32,123,114,109,
     &           111,118,101,116,111,125, 32, 98,100, 32, 47, 76,
     &            32,123,114,108,105,110,101,116,111,125, 32, 98,
     &           100, 32/
      DATA IPL7 / 47, 84, 32,123, 47,109, 97,114,107,101,100, 32,
     &           116,114,117,101, 32,100,101,102,125, 32, 98,100,
     &            32, 47, 70, 32,123, 47,109, 97,114,107,101,100,
     &            32,102, 97,108,115,101, 32,100,101,102,125, 32,
     &           98,100, 32/
      DATA IPL8 / 47,115, 32,123, 99,117,114,114,101,110,116,112,
     &           111,105,110,116, 32,115,116,114,111,107,101, 32,
     &            84, 32,109,125, 32, 98,100, 32, 47,110, 32,123,
     &           110,101,119,112, 97,116,104,125, 32, 98,100, 32/
      DATA IPL9 / 47,102, 32,123, 99,117,114,114,101,110,116,112,
     &           111,105,110,116, 32,102,105,108,108, 32, 84, 32,
     &           109,125, 32, 98,100, 32, 47,116, 32,123,115,101,
     &           116,108,105,110,101,119,105,100,116,104,125, 32,
     &            98,100,32/
      DATA IPLA / 47,105, 32,123, 48, 32, 48, 32, 48, 32, 67, 32,
     &            49, 32,115,101,116,108,105,110,101, 99, 97,112,
     &            32, 49, 32,115,101,116,108,105,110,101,106,111,
     &           105,110, 32, 48, 46, 50, 52, 32, 48, 46, 50, 52,
     &            32,115, 99, 97,108,101, 32, 55, 53, 32, 55, 53,
     &            32/
      DATA IPLB / 32,116,114, 97,110,115,108, 97,116,101, 32,102,
     &           115, 32, 70,125, 32, 98,100, 32, 47, 83, 32,123,
     &            47,115,118, 32,115, 97,118,101, 32,100,101,102,
     &            32,105,125, 32, 98,100, 32/
      DATA IPLC / 47, 70,111,110,116, 65,114,114, 97,121, 32, 91,
     &            47, 67,111,117,114,105,101,114, 32, 47, 67,111,
     &           117,114,105,101,114, 45, 79, 98,108,105,113,117,
     &           101, 93, 32,100,101,102, 32/
      DATA IPLD / 47,102,115, 32,123, 70,111,110,116, 65,114,114,
     &            97,121, 32, 99,115, 32,103,101,116, 32,102,105,
     &           110,100,102,111,110,116, 32, 49, 32,115, 99, 97,
     &           108,101,102,111,110,116, 32,115,101,116,102,111,
     &           110,116,125, 32, 98,100, 32/
      DATA IPLE / 47,115, 99,104, 32,123, 47, 99,104, 32,101,100,
     &           125, 32, 98,100, 32, 47,115, 99,119, 32,123, 47,
     &            99,119, 32,101,100,125, 32, 98,100, 32, 47,115,
     &            99,115, 32,123, 47, 99,115, 32,101,100, 32,102,
     &           115,125, 32, 98,100, 32, 47,115, 99,114, 32,123,
     &            47, 99,114, 32,101,100,125, 32, 98,100, 32/
      DATA IPLF / 47, 99, 32,123,103,115, 32, 99,114, 32,114,111,
     &           116, 97,116,101, 32, 99,119, 32, 99,104, 32,115,
     &            99, 97,108,101, 32, 45, 48, 46, 51, 32, 45, 48,
     &            46, 49, 54, 54, 54, 55, 32, 77, 32,115,104,111,
     &           119, 32,103,114, 32, 84,125, 32, 98,100, 32/
      DATA IPLG / 47,112, 32,123,109, 97,114,107,101,100, 32,123,
     &           115,104,111,119,112, 97,103,101,125, 32,105,102,
     &            32, 99,104, 32, 99,119, 32, 99,115, 32, 99,114,
     &            32,115,118, 32,114,101,115,116,111,114,101, 32,
     &           115, 99,114, 32,115, 99,115, 32,115, 99,119, 32,
     &           115, 99,104, 32, 83,125, 32, 98,100,32/
      DATA IPLH / 47,120, 32,123,112, 32,101,110,100, 32, 83, 97,
     &           118,101,100, 83,116, 97,116,101, 32,114,101,115,
     &           116,111,114,101,125, 32, 98,100, 32, 47, 80, 32,
     &           123,115, 32,103,115, 32, 53, 32,116, 32, 48, 32,
     &            48, 32, 76, 32,115, 32,103,114,125, 32, 98,100,
     &            32/
      DATA IPLI / 47,103, 32,123, 99,117,114,114,101,110,116,102,
     &           105,108,101, 32,116,111,107,101,110, 32,112,111,
     &           112, 32, 50, 46, 51, 50, 57, 32,109,117,108, 32,
     &           100,117,112, 32, 48, 32,101,113, 32,123,112,111,
     &           112,125, 32,105,102,125, 32, 98,100, 32/
      DATA IPLJ / 47, 98, 32,123, 91,103, 32,103, 32,103, 32,103,
     &            93, 32, 48, 32,115,101,116,100, 97,115,104,125,
     &            32, 98,100, 32, 83, 32/
      DATA IPLK / 37, 37, 69,110,100, 80,114,111,108,111,103, 32/
      DATA IDUMMY /0/
C
C
      IF (ICODE.LT.0.OR.ICODE.GT.13) RETURN
      IF (ICODE.NE.0) GO TO 1
C
C          THIS SECTION DOES DEVICE INITIALISATION.
C          THE SCREEN IS ERASED, THE DEFAULT HARDWARE CHARACTER
C          SIZE AND ROTATION AND FULL HARDWARE LINES ARE SET.
C
      CALL G1CMLN
      CALL G1DVIO(1,IDUMMY,1)
      CALL G1BUFF(IPL0,17)
      CALL G1FILB(0,0,-84,0)
      CALL G1BUFF(IPL1,29)
      CALL G1FILB(0,0,-84,0)
      CALL G1BUFF(IPL2,35)
      CALL G1BUFF(IPL3,42)
      CALL G1BUFF(IPL4,42)
      CALL G1BUFF(IPL5,53)
      CALL G1BUFF(IPL6,62)
      CALL G1BUFF(IPL7,51)
      CALL G1BUFF(IPL8,48)
      CALL G1BUFF(IPL9,51)
      CALL G1BUFF(IPLA,61)
      CALL G1BUFF(IPLB,43)
      CALL G1BUFF(IPLC,43)
      CALL G1BUFF(IPLD,55)
      CALL G1BUFF(IPLE,71)
      CALL G1BUFF(IPLF,59)
      CALL G1BUFF(IPLG,70)
      CALL G1BUFF(IPLH,61)
      CALL G1BUFF(IPLI,58)
      CALL G1BUFF(IPLJ,30)
      CALL G1FILB(0,0,-84,0)
      CALL G1BUFF(IPLK,12)
      CALL G1FILB(0,0,-84,0)
      CALL G1BUFF(IPAGE,17)
      IF (ICMND(3,1).EQ.1) GO TO 8
C
      RETURN
C
C          THIS SECTION SETS THE MOST APPROPRIATE
C          HARDWARE LINE TYPE FOR THE GIVEN ARGUMENTS.
C
    1 IF (ICODE.NE.1) GO TO 4
      IF (LHRDW1) GO TO 2
C
      LHDEF1= 0
      LHDEF2= 0
      LHDEF3= 0
      LHDEF4= 0
      GO TO 3
C
    2 LHDEF1= MARKA1
      LHDEF2= MISSA1
      LHDEF3= MARKB1
      LHDEF4= MISSB1
    3 CALL G1FILB(0,0,-42,-2)
      CALL G1FILB(0,0,LHDEF1,LHDEF2)
      CALL G1FILB(0,0,LHDEF3,LHDEF4)
      RETURN
C
C          THIS SECTION SETS HARDWARE CHAR. ROTATION.
C
    4 IF (ICODE.NE.2) GO TO 5
      IF (.NOT.KHRDW1) RETURN
C
      KHAR= CRANGU*180.0/PI+360.5
      KHAR= MOD(KHAR,360)
      CALL G1FILB(0,0,-12,KHAR)
      RETURN
C
C          THIS SECTION SETS THE CHAR. MAGN. TO THE
C          MOST APPROPRIATE VALUE FOR HARDWARE CHARS.
C
    5 IF (ICODE.NE.3) GO TO 6
      IF (.NOT.KHRDW1) RETURN
C
      KHAR= (MAGN1*INT(DRESY)+500)/1000
      CALL G1FILB(0,0,-11,KHAR)
      RETURN
C
C          THIS SECTION SETS THE LINE COLOUR NUMBER.
C
    6 IF (ICODE.NE.4) GO TO 7
      IF (KOLIN1.GT.MAXCLS) KOLIN1= KOLLID
C
      CALL G1FILB(0,0,-17,KOLIN1)
      RETURN
C
C          THIS SECTION SETS PORTRAIT MODE.
C
    7 IF (ICODE.NE.5) GO TO 9
C
    8 CALL G1FILB(0,0,-21,1)
      RETURN
C
C          THIS SECTION SETS HARDWARE ITALIC.
C
    9 IF (ICODE.NE.6) GO TO 10
      IF (.NOT.KHRDW1) RETURN
C
      CALL G1FILB(0,0,-13,ITAL1)
      RETURN
C
C          THIS SECTION SETS HARDWARE CHARACTER OBLATENESS.
C
   10 IF (ICODE.NE.7) GO TO 11
      IF (.NOT.KHRDW1) RETURN
C
      IOBLAT= OBLAT1*1000.0
      CALL G1FILB(0,0,-14,IOBLAT)
      RETURN
C
C          THIS SECTION SETS A COLOUR TABLE ENTRY.
C
   11 IF (ICODE.NE.8) GO TO 12
      IF (NCOLS1.GT.MAXCLS) RETURN
C
      IREDPO(NCOLS1)= NINT(REDCO1(NCOLS1)*100.0)
      IGRNPO(NCOLS1)= NINT(GRNCO1(NCOLS1)*100.0)
      IBLUPO(NCOLS1)= NINT(BLUCO1(NCOLS1)*100.0)
      IF (NCOLS1.NE.KOLIN1) RETURN
C
      CALL G1FILB(0,0,-17,KOLIN1)
      CALL G1FILB(0,0,-84,0)
      RETURN
C
C          THIS SECTION SETS THE DEVICE RESOLUTION.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   12 IF (ICODE.NE.9) GO TO 13
      RETURN
C
C          THIS SECTION SETS THE BACKGROUND COLOUR.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   13 IF (ICODE.NE.10) GO TO 14
      RETURN
C
C          THIS SECTION BEGINS THE FILL-AREA BOUNDARY.
C
   14 IF (ICODE.NE.11) GO TO 15
      IF (KOLFL1.GT.MAXCLS) KOLFL1= KOLLID
C
      CALL G1FILB(0,0,-17,KOLFL1)
      RETURN
C
C          THIS SECTION FILLS THE GIVEN POLYGONAL AREA.
C
   15 IF (ICODE.NE.12) GO TO 16
C
      CALL G1FILB(0,0,-17,KOLIN1)
      CALL G1FILB(0,0,-84,0)
      RETURN
C
C          THIS SECTION RESETS THE SHADING OPTION FLAG.
C
   16 IFLRP1= 0
      RETURN
      END
      SUBROUTINE G1MAPP(XVECT,YVECT,XNORM,YNORM,NERROR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1021)   VERSION (A8.3)    27:NOV:86
C          ------------------------------------------------
C
C          THIS MAPS THE POINT <XVECT,YVECT> IN VECTOR SPACE
C          ONTO THE POINT <XNORM,YNORM> IN NORM. DEVICE SPACE.
C          IF <NERROR>= 0, ANY ERROR MESSAGES ARE SUPPRESSED.
C
C
      LOGICAL ERRON
C
      COMMON /T1MAPP/ X1MAP1,X2MAP1,Y1MAP1,Y2MAP1
      COMMON /T1MAPS/ ORIMX1,ORIMY1,SCAMX1,SCAMY1
      COMMON /T1MAPT/ MAPNO1
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      IF (MAPNO1.EQ.3.OR.MAPNO1.EQ.4) GO TO 1
C
      XNORM= (XVECT-ORIMX1)*SCAMX1
      GO TO 2
C
    1 IF (ABS(SIGN(1.0,XVECT)-SIGN(1.0,X1MAP1)).GE.RMINI) GO TO 901
C
      ABSVEC= ABS(XVECT)
      IF (ABSVEC.LT.RMINI) GO TO 901
C
      XNORM= (ALOG(ABSVEC)-ORIMX1)*SCAMX1
    2 IF (MAPNO1.EQ.2.OR.MAPNO1.EQ.4) GO TO 3
C
      YNORM= (YVECT-ORIMY1)*SCAMY1
      RETURN
C
    3 IF (ABS(SIGN(1.0,YVECT)-SIGN(1.0,Y1MAP1)).GE.RMINI) GO TO 901
C
      ABSVEC= ABS(YVECT)
      IF (ABSVEC.LT.RMINI) GO TO 901
C
      YNORM= (ALOG(ABSVEC)-ORIMY1)*SCAMY1
      RETURN
C
C          AN ERROR MESSAGE OCCURS WHEN AN AXIS
C          IS CROSSED UNDER LOGARITHMIC MAPPING.
C          ONLY THE FIRST ERROR INVOKES THE MESSAGE.
C
  901 XNORM= 0.0
      YNORM= 0.0
      IF (NERROR.EQ.0)    RETURN
      IF (NUMERR.EQ.1002) RETURN
C
      NUMERR= 1002
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
      RETURN
      END
      SUBROUTINE G1MOVC(IFUNCO,IREPT)
C
C          ------------------------------------------------
C          ROUTINE NO. (1031)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS PERFORMS THE CHARACTER CONTROL FUNCTIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> DETERMINES THE ACTION:
C                   =  1, A WHOLE SPACE FORWARD IS DONE,
C                   =  2, A HALF SPACE FORWARD IS DONE,
C                   =  3, A WHOLE SPACE BACK IS DONE,
C                   =  4, A HALF SPACE BACK IS DONE,
C                   =  5, A WHOLE LINE FEED IS DONE,
C                   =  6, A HALF LINE FEED IS DONE,
C                   =  7, A WHOLE LINE BACK IS DONE,
C                   =  8, A HALF LINE BACK IS DONE,
C                   =  9, A CARRIAGE RETURN IS DONE,
C                   = 10, A NEW PAGE IS BEGUN.
C          <IREPT>  GIVES THE NO. OF TIMES THIS IS REPEATED.
C
C
      LOGICAL SPACIN,FORWRD
      LOGICAL TYPMOD
C
      COMMON /T1CMOC/ ADDSPX,ADDLNX,ADDSPY,ADDLNY
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CPOS/ XCHAR,YCHAR
      COMMON /T1TSPA/ X1TYPW,X2TYPW,Y1TYPW,Y2TYPW
      COMMON /T1TYPQ/ IQUAD
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.10) RETURN
      IF (IREPT.LT.1)                  RETURN
C
      FORWRD= .TRUE.
      GO TO (1,2,3,4,11,12,13,14,20,21), IFUNCO
C
C          THE FOLLOWING SECTIONS INITIALISE FOR FULL-SPACE
C          FORWARD, HALF-SPACE FORWARD, FULL-SPACE BACK AND
C          HALF-SPACE BACK, RESPECTIVELY. THE LOOP THEN DOES
C          THE REQUIRED ACTION <IREPT> TIMES, ALSO CHECKING
C          WHEN IN TYPING MODE TO ENSURE THAT PROPER WRAP-
C          ROUND OCCURS WHEN THE (BORDERED) CHAR. WINDOW IS
C          EXCEEDED. IF THE UPPER OR LOWER PAGE LIMITS ARE
C          ALSO EXCEEDED, A JUMP IS MADE TO LOOP-100 TO
C          ALLOW FOR THIS BEFORE CONTINUING WITH THE SPACES.
C
    1 XINCSP= ADDSPX
      YINCSP= ADDSPY
      GO TO 5
C
    2 XINCSP= 0.5*ADDSPX
      YINCSP= 0.5*ADDSPY
      GO TO 5
C
    3 XINCSP= -ADDSPX
      YINCSP= -ADDSPY
      FORWRD= .FALSE.
      GO TO 5
C
    4 XINCSP= -0.5*ADDSPX
      YINCSP= -0.5*ADDSPY
      FORWRD= .FALSE.
C
    5 IF (TYPMOD) GO TO 6
C
      XCHAR= XCHAR+IREPT*XINCSP
      YCHAR= YCHAR+IREPT*YINCSP
      RETURN
C
    6 ISTEPS= 0
    7   ISTEPS= ISTEPS+1
        IF (ISTEPS.GT.IREPT) RETURN
C
        XCHAR= XCHAR+XINCSP
        YCHAR= YCHAR+YINCSP
C
        IF ((IQUAD.EQ.1.OR.IQUAD.EQ.3).AND.
     &      ((XCHAR-X1TYPW)*(XCHAR-X2TYPW).GT.0.0)) GO TO 8
        IF ((IQUAD.EQ.2.OR.IQUAD.EQ.4).AND.
     &      ((YCHAR-Y1TYPW)*(YCHAR-Y2TYPW).GT.0.0)) GO TO 8
        GO TO 7
C
    8   IF (.NOT.FORWRD) GO TO 9
        XINCLN= ADDLNX
        YINCLN= ADDLNY
        IF (IQUAD.EQ.1) XCHAR= X1TYPW+0.0001
        IF (IQUAD.EQ.2) YCHAR= Y1TYPW+0.0001
        IF (IQUAD.EQ.3) XCHAR= X2TYPW-0.0001
        IF (IQUAD.EQ.4) YCHAR= Y2TYPW-0.0001
        GO TO 10
C
    9   XINCLN= -ADDLNX
        YINCLN= -ADDLNY
        IF (IQUAD.EQ.1) XCHAR= X2TYPW-0.0001
        IF (IQUAD.EQ.2) YCHAR= Y2TYPW-0.0001
        IF (IQUAD.EQ.3) XCHAR= X1TYPW+0.0001
        IF (IQUAD.EQ.4) YCHAR= Y1TYPW+0.0001
C
   10   IREPTL= 1
        SPACIN= .TRUE.
        GO TO 17
C
C          THE FOLLOWING SECTIONS PERFORM THE SAME FUNCTIONS FOR
C          FULL LINEFEEDS, HALF LINEFEEDS, FULL BACK LINES AND
C          HALF BACK LINES RESP., REPEATING THE ACTION EITHER
C          <IREPT> TIMES OR ONCE DEPENDING ON THE ORIGIN OF THE
C          ACTION. IF A PAGE OVERFLOW IS BEING CORRECTED AS A
C          RESULT OF A LINE OVERFLOW, CONTROL RETURNS TO LABEL-7.
C          LINE OVERFLOW CANNOT RESULT FROM A PAGE OVERFLOW, SO
C          EQUIVALENT USE OF THE PREVIOUS SECTION IS NOT NEEDED.
C
   11 XINCLN= ADDLNX
      YINCLN= ADDLNY
      GO TO 15
C
   12 XINCLN= 0.5*ADDLNX
      YINCLN= 0.5*ADDLNY
      GO TO 15
C
   13 XINCLN= -ADDLNX
      YINCLN= -ADDLNY
      FORWRD= .FALSE.
      GO TO 15
C
   14 XINCLN= -0.5*ADDLNX
      YINCLN= -0.5*ADDLNY
      FORWRD= .FALSE.
C
   15 IF (TYPMOD) GO TO 16
C
      XCHAR= XCHAR+IREPT*XINCLN
      YCHAR= YCHAR+IREPT*YINCLN
      RETURN
C
   16 IREPTL= IREPT
      SPACIN= .FALSE.
   17 DO 100 ISTEPL= 1,IREPTL
        XCHAR= XCHAR+XINCLN
        YCHAR= YCHAR+YINCLN
C
        IF ((IQUAD.EQ.2.OR.IQUAD.EQ.4).AND.
     &      ((XCHAR-X1TYPW)*(XCHAR-X2TYPW).GT.0.0)) GO TO 18
        IF ((IQUAD.EQ.1.OR.IQUAD.EQ.3).AND.
     &      ((YCHAR-Y1TYPW)*(YCHAR-Y2TYPW).GT.0.0)) GO TO 18
        GO TO 100
C
   18   IF (.NOT.FORWRD) GO TO 19
        IF (IQUAD.EQ.1) YCHAR= Y2TYPW-0.0001
        IF (IQUAD.EQ.2) XCHAR= X1TYPW+0.0001
        IF (IQUAD.EQ.3) YCHAR= Y1TYPW+0.0001
        IF (IQUAD.EQ.4) XCHAR= X2TYPW-0.0001
        GO TO 100
C
   19   IF (IQUAD.EQ.1) YCHAR= Y1TYPW+0.0001
        IF (IQUAD.EQ.2) XCHAR= X2TYPW-0.0001
        IF (IQUAD.EQ.3) YCHAR= Y2TYPW-0.0001
        IF (IQUAD.EQ.4) XCHAR= X1TYPW+0.0001
  100 CONTINUE
      IF (SPACIN) GO TO 7
      RETURN
C
C          THIS SECTION DOES A CARRIAGE RETURN (IE. RESETS
C          THE CHARACTER POSITION TO THE APPROPRIATE MARGIN)
C          PROVIDED THAT TYPING MODE IS CURRENTLY IN EFFECT.
C
   20 IF (.NOT.TYPMOD) RETURN
C
      IF (IQUAD.EQ.1) XCHAR= X1TYPW+0.0001
      IF (IQUAD.EQ.2) YCHAR= Y1TYPW+0.0001
      IF (IQUAD.EQ.3) XCHAR= X2TYPW-0.0001
      IF (IQUAD.EQ.4) YCHAR= Y2TYPW-0.0001
      RETURN
C
C          WHEN TYPING MODE IS SET, THIS SECTION WILL DO
C          A PAGE RESET BY RELOCATING THE CHAR. POSITION
C          TO THE TOP-LEFT CORNER OF THE CHARACTER SPACE.
C
   21 IF (.NOT.TYPMOD) RETURN
C
      IF (IQUAD.NE.1) GO TO 22
      XCHAR= X1TYPW+0.0001
      YCHAR= Y2TYPW-0.0001
      RETURN
C
   22 IF (IQUAD.NE.2) GO TO 23
      XCHAR= X1TYPW+0.0001
      YCHAR= Y1TYPW+0.0001
      RETURN
C
   23 IF (IQUAD.NE.3) GO TO 24
      XCHAR= X2TYPW-0.0001
      YCHAR= Y1TYPW+0.0001
      RETURN
C
   24 XCHAR= X2TYPW-0.0001
      YCHAR= Y2TYPW-0.0001
      RETURN
      END
      SUBROUTINE G1LINE(XPOS,YPOS,VISIBL)
C
C          ------------------------------------------------
C          ROUTINE NO. (1023)   VERSION (A8.3)    26:FEB:90
C          ------------------------------------------------
C
C          THIS WINDOWS, MASKS, TRANSFORMS AND DRAWS ALL VECTORS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XPOS>   IS THE NEW END-POINT X-COORDINATE,
C          <YPOS>   IS THE NEW END-POINT Y-COORDINATE,
C          <VISIBL> GIVES THE LINE TYPE:
C                   = .TRUE., A LINE IS DRAWN TO THE NEW END-POINT,
C                   = .FALSE., A MOVE IS MADE TO THE NEW END-POINT.
C
C
C          THE FOLLOWING VARIABLES ARE ALSO IMPORTED:
C
C          <CURTRA> CONTROLS THE CURRENT TRANSFORM:
C                   = .TRUE., A CURRENT TRANSFORM IS DONE,
C                   = .FALSE., A CURRENT TRANSFORM IS NOT DONE.
C          <DLIMX>  IS THE DEVICE (UPPER) X-LIMIT.
C          <DLIMY>  IS THE DEVICE (UPPER) Y-LIMIT.
C          <INDLVL> GIVES THE PICTURE INDENT LEVEL.
C          <IREPLY> GIVES THE STATUS OF A CLIPPED LINE:
C                   = 0, THE LINE HAS NOT BEEN CLIPPED,
C                   = 1, THE LINE HAS BEEN CLIPPED,
C                   = 2, THE LINE IS COMPLETELY OUTSIDE.
C          <ITHIK1> GIVES THE LINE WIDTH.
C          <KLIPM1> GIVES THE CLIPPING TRANSFORMATION MODE:
C                   = 0, THE CLIP-AREAS ARE NOT TRANSFORMED,
C                   = 1, THE CLIP-AREAS ARE TRANSFORMED.
C          <LHRDW1> GIVES THE HARDWARE LINE TYPE:
C                   = .TRUE.,  LINE PATTERNS ARE DONE BY HARDWARE,
C                   = .FALSE., LINE PATTERNS ARE DONE BY SOFTWARE.
C          <MASKIN> CONTROLS THE MASKING:
C                   = .TRUE., MASKING IS DONE,
C                   = .FALSE., MASKING IS NOT DONE.
C          <NFILLI> GIVES THE NUMBER OF THICKENING LINES REQUIRED.
C          [STRTPT] IS THE START POSITION OF A CLIPPED LINE,
C          [STOPPT] IS THE END   POSITION OF A CLIPPED LINE.
C          <THIKST> IS THE HALF-STEP SIZE FOR THICKENING LINES.
C          <WNDOIN> CONTROLS USE OF THE PROGRAM WINDOW:
C                   = .TRUE., WINDOWING IS DONE,
C                   = .FALSE., WINDOWING IS NOT DONE.
C
C
C          AND THE FOLLOWING VARIABLES ARE EXPORTED:
C
C          [POINTS] IS THE SET OF PART-LINES TO BE DRAWN,
C          <NSTRT>  IS THE FIRST ELEMENT IN THE ARRAY,
C          <NSTOP>  IS THE LAST ELEMENT IN THE ARRAY,
C          <XLIM1>  IS THE CLIP-AREA LEFT-EDGE POSITION,
C          <XLIM2>  IS THE CLIP-AREA RIGHT-EDGE POSITION,
C          <YLIM1>  IS THE CLIP-AREA LOWER-EDGE POSITION,
C          <YLIM2>  IS THE CLIP-AREA UPPER-EDGE POSITION.
C
C
      REAL    XMARK(2),YMARK(2),XSKIP(2),YSKIP(2),
     &        END1(2),END2(2),POS1(2),POS2(2)
      DOUBLE PRECISION X,Y,DXA,DYA,DXB,DYB,DISTA,TOTLEN,SEGLEN,
     &                 WIDSXA,WIDSYA,WIDSXB,WIDSYB,XFACTA,YFACTA,
     &                 XPREF1,YPREF1,XPREF2,YPREF2,XOFFA,YOFFA,
     &                 XREF,YREF,DDX,DDY,DIST,STRT,STOP
      LOGICAL FORWRD,VISIBL,SECOND,STRTED,BROKEN
      LOGICAL SHIFT1,LHRDW1,CURTRA,WINLIN,WNDOIN,MASKIN,OPEN
C
      COMMON /T1CLIN/ STRTPT(2),STOPPT(2)
      COMMON /T1CLIP/ XLIM1,XLIM2,YLIM1,YLIM2
      COMMON /T1DENA/ OPEN
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1LATT/ KOLIN1,ITHIK1
      COMMON /T1LIND/ PATREM
      COMMON /T1LINE/ POINTS(22,2),NSTRT,NSTOP
      COMMON /T1LINT/ ELWID,NFILLI,THIKST
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1LVIS/ WINLIN,WNDOIN,MASKIN
      COMMON /T1MASK/ X1MSK1(10),X2MSK1(10),Y1MSK1(10),Y2MSK1(10),MSKLV1
      COMMON /T1PPAT/ XPLOTA,YPLOTA
      COMMON /T1PPBT/ XPLOTB,YPLOTB
      COMMON /T1TCOB/ XCBX,XCBY,YCBX,YCBY,RPICXB,RPICYB,RDEVXB,RDEVYB
      COMMON /T1TCOC/ XCCX,XCCY,YCCX,YCCY,RPICXC,RPICYC,RDEVXC,RDEVYC,
     &                CURTRA
      COMMON /T1TRST/ SHIFT1,MTRAN1,KLIPM1,INDLVL
      COMMON /T1WNDO/ X1WND1,X2WND1,Y1WND1,Y2WND1
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C          THESE FUNCTIONS GIVE DIRECTED POSITION VALUES:
C
      DISTL(RARG)= DIRNOW*RARG
      DPOSN(IARG)= DIRNOW*POINTS(IARG,ICOMP)
C
C          THESE FUNCTIONS GIVE THE CURRENT AND BASE TRANSFORMS:
C
      TRANXC(X,Y)= XCCX*(X-RPICXC)+XCCY*(Y-RPICYC)+RDEVXC
      TRANYC(X,Y)= YCCX*(X-RPICXC)+YCCY*(Y-RPICYC)+RDEVYC
      TRANXB(X,Y)= XCBX*(X-RPICXB)+XCBY*(Y-RPICYB)+RDEVXB
      TRANYB(X,Y)= YCBX*(X-RPICXB)+YCBY*(Y-RPICYB)+RDEVYB
C
C
C          THIS SECTION TRANSFORMS THE NEW END-POINT.
C
      XTEMP= XPOS
      YTEMP= YPOS
      IF (.NOT.CURTRA) GO TO 1
C
      XTEMP= TRANXC(DBLE(XPOS),DBLE(YPOS))
      YTEMP= TRANYC(DBLE(XPOS),DBLE(YPOS))
    1 XNEW=  TRANXB(DBLE(XTEMP),DBLE(YTEMP))
      YNEW=  TRANYB(DBLE(XTEMP),DBLE(YTEMP))
      REMNEW= 0.0
      IF (.NOT.VISIBL) GO TO 26
      IF (ABS(XPOS-XPLOTB).LT.RMINI.AND.
     &    ABS(YPOS-YPLOTB).LT.RMINI) GO TO 27
      IF (ABS(XNEW-XPLOTA).LT.RMINI.AND.
     &    ABS(YNEW-YPLOTA).LT.RMINI) GO TO 27
C
      WIDSXB= 0.0
      WIDSYB= 0.0
      BROKEN= ((MARKA1.GT.0.OR.MARKB1.GT.0).AND..NOT.LHRDW1)
      IF (.NOT.BROKEN.AND.ITHIK1.EQ.1) GO TO 2
C
C          THIS SECTION CALCULATES THE OFFSET INCREMENTS
C          IF PATTERNED OR THICKENED LINES ARE REQUIRED.
C
      DXB= XPOS-XPLOTB
      DYB= YPOS-YPLOTB
      DXA= XNEW-XPLOTA
      DYA= YNEW-YPLOTA
      DISTA= SQRT(DXA*DXA+DYA*DYA)
      WIDSXB= -DYB*THIKST/DISTA
      WIDSYB=  DXB*THIKST/DISTA
      IF (.NOT.BROKEN) GO TO 2
C
C          THIS SECTION CALCULATES THE ADDITIONAL VALUES
C          NECESSARY WHEN PATTERNED LINES ARE BEING DRAWN.
C
      TOTLEN= DISTA+PATREM
      SEGLEN= 0.001*(MARKA1+MISSA1+MARKB1+MISSB1)
      REMNEW= DMOD(TOTLEN,SEGLEN)
      ENDOFF= SEGLEN-REMNEW-(0.001*MISSB1)
      IF (ENDOFF.LT.0) ENDOFF= ENDOFF+SEGLEN
C
      XFACTA= DXA/DISTA
      YFACTA= DYA/DISTA
      WIDSXA= -YFACTA*THIKST
      WIDSYA=  XFACTA*THIKST
      XPREF1= XPLOTA-(XFACTA*PATREM)
      YPREF1= YPLOTA-(YFACTA*PATREM)
      XPREF2= XNEW+(XFACTA*ENDOFF)
      YPREF2= YNEW+(YFACTA*ENDOFF)
      XMARK(1)= 0.001*XFACTA*MARKA1
      YMARK(1)= 0.001*YFACTA*MARKA1
      XSKIP(1)= 0.001*XFACTA*MISSA1
      YSKIP(1)= 0.001*YFACTA*MISSA1
      XMARK(2)= 0.001*XFACTA*MARKB1
      YMARK(2)= 0.001*YFACTA*MARKB1
      XSKIP(2)= 0.001*XFACTA*MISSB1
      YSKIP(2)= 0.001*YFACTA*MISSB1
      ICOMPA= 1
      DIRECA= DSIGN(1.0D0,DXA)
      IF (ABS(DXA).GE.ABS(DYA)) GO TO 2
C
      ICOMPA= 2
      DIRECA= DSIGN(1.0D0,DYA)
C
C          LINES ARE ONLY DRAWN IF THE DEVICE HAS BEEN ENABLED.
C          LOOP-100 GENERATES EACH THICKENING LINE IN TURN.
C          (THE FIRST ONE IS ALWAYS IN THE FORWARD DIRECTION).
C
    2 IF (.NOT.OPEN) GO TO 26
C
      FORWRD= .FALSE.
      NHALFS= -NFILLI-1
C
      DO 100 IFILL= 1,NFILLI
        FORWRD= .NOT.FORWRD
        NHALFS= NHALFS+2
        XOFFB= WIDSXB*NHALFS
        YOFFB= WIDSYB*NHALFS
        XSTRT= XPLOTB-XOFFB
        YSTRT= YPLOTB-YOFFB
        XSTOP= XPOS-XOFFB
        YSTOP= YPOS-YOFFB
C
C          THIS SECTION HANDLES VISIBLE PICTURE VECTORS. THE
C          OPERATION SEQUENCE FOR THE TWO VALUES OF <KLIPM1> IS:
C
C          [C-TRAN] [P-WIN] [MASK] [C-TRAN] [B-TRAN] [D-WIN]
C            (0)                     (1)      (0&1)
C
        POINTS(1,1)= XSTRT
        POINTS(1,2)= YSTRT
        POINTS(2,1)= XSTOP
        POINTS(2,2)= YSTOP
        NSTRT= 1
C
C          THIS DOES A CURRENT TRANSFORM FOR MODE 0 (IF REQUIRED).
C
        IF (KLIPM1.NE.0) GO TO 3
        IF (.NOT.CURTRA) GO TO 3
C
        POINTS(1,1)= TRANXC(DBLE(XSTRT),DBLE(YSTRT))
        POINTS(1,2)= TRANYC(DBLE(XSTRT),DBLE(YSTRT))
        POINTS(2,1)= TRANXC(DBLE(XSTOP),DBLE(YSTOP))
        POINTS(2,2)= TRANYC(DBLE(XSTOP),DBLE(YSTOP))
C
C          THIS SECTION SUBJECTS THE LINE TO THE PROGRAM WINDOW.
C          IF IT IS COMPLETELY OUTSIDE, NO MORE NEED BE DONE. IF
C          IT IS COMPLETELY INSIDE, THE END POINTS REMAIN UNCHANGED.
C          OTHERWISE, THE INTERSECTION POINTS BECOME THE END POINTS.
C
    3   IF (.NOT.WNDOIN) GO TO 4
C
        NSTOP= 0
        DX= POINTS(2,1)-POINTS(1,1)
        DY= POINTS(2,2)-POINTS(1,2)
        IF (ABS(DX).LT.RMINI.AND.ABS(DY).LT.RMINI) GO TO 16
C
        NSTOP= 2
        XLIM1= X1WND1
        XLIM2= X2WND1
        YLIM1= Y1WND1
        YLIM2= Y2WND1
        CALL G1CLIP(IREPLY)
        NSTOP= 0
        IF (IREPLY.EQ.2) GO TO 16
        IF (IREPLY.EQ.0) GO TO 4
C
        POINTS(1,1)= STRTPT(1)
        POINTS(1,2)= STRTPT(2)
        POINTS(2,1)= STOPPT(1)
        POINTS(2,2)= STOPPT(2)
C
C          THIS SECTION DOES THE MASKING IF NECESSARY. (IF THE
C          LINE IS COMPLETELY INSIDE ANY MASKING RECTANGLE, NO
C          MORE IS DONE. IF IT IS COMPLETELY OUTSIDE, NO CHANGES
C          ARE MADE TO THE LINE. IF THE LINE CROSSES A MASK AREA,
C          THE APPROPRIATE AMENDMENTS ARE MADE TO THE SEGMENTS).
C
    4   NSTOP= 2
        IF (.NOT.MASKIN) GO TO 12
C
        NSTOP= 0
        DX= POINTS(2,1)-POINTS(1,1)
        DY= POINTS(2,2)-POINTS(1,2)
        IF (ABS(DX).LT.RMINI.AND.ABS(DY).LT.RMINI) GO TO 16
C
        NSTOP= 2
        IF (MSKLV1.LE.0) GO TO 12
C
        ICOMP= 1
        IF (ABS(DX).LT.ABS(DY)) ICOMP= 2
C
        DIRNOW= SIGN(1.0,POINTS(2,ICOMP)-POINTS(1,ICOMP))
C
        DO 200 MASK= 1,MSKLV1
          XLIM1= X1MSK1(MASK)
          XLIM2= X2MSK1(MASK)
          YLIM1= Y1MSK1(MASK)
          YLIM2= Y2MSK1(MASK)
          CALL G1CLIP(IREPLY)
          IF (IREPLY.EQ.2) GO TO 200
          IF (IREPLY.EQ.0) GO TO 11
C
C          THIS LOOP FINDS WHERE THE MASK IS PLACED ON THE LINES.
C
          ENDL1= DISTL(STRTPT(ICOMP))
          ENDL2= DISTL(STOPPT(ICOMP))
          SECOND= .FALSE.
C
          DO 300 LOOK= 1,NSTOP
            IF (SECOND)               GO TO 5
            IF (DPOSN(LOOK).LT.ENDL1) GO TO 300
C
            ISTRT= LOOK-1
            SECOND= .TRUE.
    5       IF (DPOSN(LOOK).LE.ENDL2) GO TO 300
C
            ISTOP= LOOK-1
            GO TO 6
  300     CONTINUE
C
          ISTOP= NSTOP
          IF (.NOT.SECOND) GO TO 200
C
C          THIS SECTION REMOVES INVISIBLE LINES
C          AND MAKES ROOM FOR NEW ONES AS NECESSARY.
C
    6     INC1= MOD(ISTRT,2)
          INC2= MOD(ISTOP,2)
          IOFSET= ISTRT-ISTOP+INC1+INC2
          ITYPE= 2*INC1+INC2
          IF (IOFSET.EQ.0) GO TO 9
C
          NMOVES= NSTOP-ISTOP
          IF (NMOVES.LE.0) GO TO 9
          IF (IOFSET.GT.0) GO TO 7
C
          IDIREC= +1
          IFROM= ISTOP
          GO TO 8
C
    7     IDIREC= -1
          IFROM= NSTOP+1
C
    8     DO 400 MOVE= 1,NMOVES
            IFROM= IFROM+IDIREC
            ITO=   IFROM+IOFSET
            POINTS(ITO,1)= POINTS(IFROM,1)
            POINTS(ITO,2)= POINTS(IFROM,2)
  400     CONTINUE
C
          NSTOP= NSTOP+IOFSET
C
C         THIS SECTION UPDATES EDGE-POINTS WHERE REQUIRED.
C
    9     IF (ITYPE.EQ.0) GO TO 200
          IF (ITYPE.NE.1) GO TO 10
C
          POINTS(ISTRT+1,1)= STOPPT(1)
          POINTS(ISTRT+1,2)= STOPPT(2)
          GO TO 200
C
   10     POINTS(ISTRT+1,1)= STRTPT(1)
          POINTS(ISTRT+1,2)= STRTPT(2)
          IF (ITYPE.EQ.2) GO TO 200
C
          POINTS(ISTRT+2,1)= STOPPT(1)
          POINTS(ISTRT+2,2)= STOPPT(2)
  200   CONTINUE
C
   11   IF (IREPLY.EQ.0) NSTOP= 0
        IF (NSTOP.LE.0) GO TO 16
C
C          THIS DOES A CURRENT TRANSFORM FOR MODE 1 (IF REQUIRED).
C
   12   IF (KLIPM1.NE.1) GO TO 13
        IF (.NOT.CURTRA) GO TO 13
C
        DO 500 IPT= 1,NSTOP
          XTEMP= TRANXC(DBLE(POINTS(IPT,1)),DBLE(POINTS(IPT,2)))
          YTEMP= TRANYC(DBLE(POINTS(IPT,1)),DBLE(POINTS(IPT,2)))
          POINTS(IPT,1)= XTEMP
          POINTS(IPT,2)= YTEMP
  500   CONTINUE
C
C          THIS DOES A BASE TRANSFORM FOR MODES 0 AND 1
C          (BUT IS NOT DONE WHEN THE INDENT LEVEL IS 0).
C
   13   IF (INDLVL.LE.0) GO TO 14
C
        DO 600 IPT= 1,NSTOP
          XTEMP= TRANXB(DBLE(POINTS(IPT,1)),DBLE(POINTS(IPT,2)))
          YTEMP= TRANYB(DBLE(POINTS(IPT,1)),DBLE(POINTS(IPT,2)))
          POINTS(IPT,1)= XTEMP
          POINTS(IPT,2)= YTEMP
  600   CONTINUE
C
C          THIS SECTION SUBJECTS THE LINE TO THE DEVICE WINDOW.
C
   14   XLIM1= 0.0
        XLIM2= DLIMX
        YLIM1= 0.0
        YLIM2= DLIMY
        CALL G1CLIP(IREPLY)
        LIMIT= NSTOP
        IF (IREPLY.EQ.2) NSTOP= 0
        IF (IREPLY.NE.1) GO TO 16
C
        DX= POINTS(NSTOP,1)-POINTS(1,1)
        DY= POINTS(NSTOP,2)-POINTS(1,2)
        IF (ABS(DX).LT.RMINI.AND.ABS(DY).LT.RMINI) NSTOP= 0
        IF (NSTOP.EQ.0) GO TO 16
C
        ICOMP= 1
        IF (ABS(DX).LT.ABS(DY)) ICOMP= 2
C
        DIRNOW= SIGN(1.0,POINTS(NSTOP,ICOMP)-POINTS(1,ICOMP))
        ENDL1= DISTL(STRTPT(ICOMP))
        ENDL2= DISTL(STOPPT(ICOMP))
        SECOND= .FALSE.
C
        DO 700 LOOK= 1,LIMIT,2
          IF (SECOND)                 GO TO 15
          IF (DPOSN(LOOK+1).LE.ENDL1) GO TO 700
C
          NSTRT= LOOK
          SECOND= .TRUE.
          IF (DPOSN(LOOK).GE.ENDL1)   GO TO 15
C
          POINTS(NSTRT,1)= STRTPT(1)
          POINTS(NSTRT,2)= STRTPT(2)
   15     IF (DPOSN(LOOK+1).LE.ENDL2) GO TO 700
C
          NSTOP= LOOK-1
          IF (DPOSN(LOOK).GE.ENDL2)   GO TO 16
C
          NSTOP= LOOK+1
          POINTS(NSTOP,1)= STOPPT(1)
          POINTS(NSTOP,2)= STOPPT(2)
          GO TO 16
  700   CONTINUE
C
C          THIS PART DRAWS THE LINE, EITHER FULL OR PATTERNED.
C
   16   IF (NSTRT.GE.NSTOP) GO TO 100
        IF (BROKEN)         GO TO 18
C
C          THIS SECTION IS FOR FULL LINES.
C
        IF (FORWRD) GO TO 17
C
        DO 800 LINE= NSTRT,NSTOP,2
          LINE2= NSTOP-LINE+NSTRT
          IXFROM= (DRESX*POINTS(LINE2,  1))+0.5
          IYFROM= (DRESY*POINTS(LINE2,  2))+0.5
          IXTO=   (DRESX*POINTS(LINE2-1,1))+0.5
          IYTO=   (DRESY*POINTS(LINE2-1,2))+0.5
          CALL G1FILB(IXFROM,IYFROM,IXTO,IYTO)
  800   CONTINUE
        GO TO 100
C
   17   DO 900 LINE= NSTRT,NSTOP,2
          IXFROM= (DRESX*POINTS(LINE,  1))+0.5
          IYFROM= (DRESY*POINTS(LINE,  2))+0.5
          IXTO=   (DRESX*POINTS(LINE+1,1))+0.5
          IYTO=   (DRESY*POINTS(LINE+1,2))+0.5
          CALL G1FILB(IXFROM,IYFROM,IXTO,IYTO)
  900   CONTINUE
        GO TO 100
C
C          THIS SECTION IS FOR PATTERNED LINES.
C
C          THE PATTERN REFERENCE POINT AND THE
C          DIRECTION INDICATORS ARE FIRST FOUND.
C
   18   XOFFA= WIDSXA*NHALFS
        YOFFA= WIDSYA*NHALFS
        XREF= XPREF1-XOFFA
        YREF= YPREF1-YOFFA
        DIRNOW= DIRECA
        DIREC= +1.0
        IF (FORWRD) GO TO 19
C
        DIRNOW= -DIRNOW
        DIREC= -1.0
        XREF= XPREF2-XOFFA
        YREF= YPREF2-YOFFA
C
C          EACH LINE-SEGMENT IS TAKEN IN TURN (IN LOOP-1000)
C          AND ITS STARTING AND ENDING PATTERN-SEGMENTS FOUND.
C          THE PATTERN IS GENERATED BY REPEATING THE DEFINED
C          MARK/SPACE PAIRS (IN LOOP-1100) WITHIN THESE LIMITS,
C          ENSURING AT THE SAME TIME THAT THE ENTIRE SEQUENCE
C          DOES NOT EXTEND OUTSIDE THE LINE-SEGMENT END-POINTS.
C
   19   DO 1000 LINE= NSTRT,NSTOP,2
          IF (FORWRD) GO TO 21
C
          LINE2= NSTOP-LINE+NSTRT
          END1(1)= POINTS(LINE2,1)
          END1(2)= POINTS(LINE2,2)
          END2(1)= POINTS(LINE2-1,1)
          END2(2)= POINTS(LINE2-1,2)
          GO TO 22
C
   21     END1(1)= POINTS(LINE,1)
          END1(2)= POINTS(LINE,2)
          END2(1)= POINTS(LINE+1,1)
          END2(2)= POINTS(LINE+1,2)
   22     DDX= END1(1)-XREF
          DDY= END1(2)-YREF
          DIST= DSQRT(DDX*DDX+DDY*DDY)
          STRT= DINT(DIST/SEGLEN)
          DDX= END2(1)-XREF
          DDY= END2(2)-YREF
          DIST= DSQRT(DDX*DDX+DDY*DDY)
          STOP= DINT(DIST/SEGLEN+1)
          NSEGS= DINT(2.0*(STOP-STRT))
          IEND= NSEGS-1
          POS1(1)= XREF+DIREC*XFACTA*(STRT*SEGLEN)
          POS1(2)= YREF+DIREC*YFACTA*(STRT*SEGLEN)
          DEND1= DIRNOW*END1(ICOMPA)
          DEND2= DIRNOW*END2(ICOMPA)
          STRTED= .FALSE.
          KMARK= 1
          IF (FORWRD) KMARK= 2
C
          KMISS= 2
C
          DO 1100 ISEG= 1,NSEGS
            KMARK= MOD(KMARK,2)+1
            KMISS= MOD(KMISS,2)+1
            POS2(1)= POS1(1)+DIREC*XMARK(KMARK)
            POS2(2)= POS1(2)+DIREC*YMARK(KMARK)
C
C          THIS PART ENSURES THAT THE PATTERN START-POINT
C          IS NOT OUTSIDE THE LINE-SEGMENT START-POSITION.
C
            IF (STRTED) GO TO 23
            IF (DIRNOW*POS2(ICOMPA).LE.DEND1) GO TO 25
C
            STRTED= .TRUE.
            POS1(1)= END1(1)
            POS1(2)= END1(2)
C
C          THIS PART ENSURES THAT THE PATTERN END-POINT
C          IS NOT OUTSIDE THE LINE-SEGMENT END-POSITION.
C
   23       IF (ISEG.LT.IEND) GO TO 24
            IF (DIRNOW*POS1(ICOMPA).GE.DEND2) GO TO 1000
            IF (DIRNOW*POS2(ICOMPA).LE.DEND2) GO TO 24
C
            POS2(1)= END2(1)
            POS2(2)= END2(2)
C
C          THIS PART DRAWS THE VISIBLE PORTION OF THE PATTERN SEGMENT.
C
   24       IXFROM= (DRESX*POS1(1))+0.5
            IYFROM= (DRESY*POS1(2))+0.5
            IXTO=   (DRESX*POS2(1))+0.5
            IYTO=   (DRESY*POS2(2))+0.5
            CALL G1FILB(IXFROM,IYFROM,IXTO,IYTO)
C
C          THIS PART UPDATES THE PATTERN-SEGMENT START POSITION.
C          IF THE FIRST PATTERN-SEGMENT IS COMPLETELY OUTSIDE
C          THE LINE-SEGMENT, THE START-INDICATOR IS SET HERE.
C
   25       POS1(1)= POS2(1)+DIREC*XSKIP(KMISS)
            POS1(2)= POS2(2)+DIREC*YSKIP(KMISS)
            IF (STRTED) GO TO 1100
            IF (DIRNOW*POS1(ICOMPA).GE.DEND1) STRTED= .TRUE.
C
 1100     CONTINUE
 1000   CONTINUE
  100 CONTINUE
C
   26 PATREM= REMNEW
C
C          LASTLY, THE PRE- AND POST-TRANSFORM POSITIONS ARE UPDATED.
C
   27 XPLOTB= XPOS
      YPLOTB= YPOS
      XPLOTA= XNEW
      YPLOTA= YNEW
C
      RETURN
      END
      SUBROUTINE G1SPEC(ICHAR,IFONT,IXPTS,IYPTS,LENGTH)
C
C          ------------------------------------------------
C          ROUTINE NO. (1033)   VERSION (A8.2)    03:JAN:90
C          ------------------------------------------------
C
C          THIS PROVIDES THE VECTOR-STRING SPECIFICATION
C          FOR DRAWING ANY REQUIRED GHOST SOFTWARE CHARACTER.
C
C
C          THE INPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <ICHAR>  IS THE NO. OF THE REQUIRED CHARACTER,
C          <IFONT>  IS THE NO. OF THE REQUIRED FONT (0-3).
C
C          THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          [IXPTS]  ARE THE VECTOR X-COORDINATES AND
C          [IYPTS]  ARE THE VECTOR Y-COORDINATES, WHILE
C          <LENGTH> IS THE NO. OF VECTORS IN THE STRING.
C
C
C          THE CHAR. SPECIFICATIONS ARE HELD IN [ISPECS]
C          AND THE INDEX POINTERS FOR UNIQUE AND COMMON
C          CHARS. IN [INDEXS] AND [INDEXC] RESPECTIVELY.
C
      INTEGER IXPTS(30),IYPTS(30),INDEXS(2,3,128),
     &        INDEXC(2,96),ISPECS(2466),LFON1A(133),
     &        LFON1B(168),LFON1C(129),LFON1D(125),LFON1E(131),
     &        LFON1F(153),LFON1G(30),LMATHA(143),LMATHB(130),
     &        LMATHC( 88),LMARKA(176),LMARKB(104),LFON2A(173),
     &        LFON2B(126),LFON2C(12),LFON3A(209),LFON3B(190),
     &        LFON3C(207),LFON3D(39),NDXC1(96),NDXC2(96),
     &        NDXS1(96),NDXS2(96),NDXS3(96),NDXS4(96),
     &        NDXS5(96),NDXS6(96),NDXS7(96),NDXS8(96)
C
      COMMON /T1CDEF/ KSTRT,NDEFS,KNUM(30),KPOSN(30),KLEN(30),KSPEC(500)
C
      EQUIVALENCE (ISPECS(   1),LFON1A(1)), (ISPECS( 134),LFON1B(1)),
     &            (ISPECS( 302),LFON1C(1)), (ISPECS( 431),LFON1D(1)),
     &            (ISPECS( 556),LFON1E(1)), (ISPECS( 687),LFON1F(1)),
     &            (ISPECS( 840),LFON1G(1)), (ISPECS( 870),LMATHA(1)),
     &            (ISPECS(1013),LMATHB(1)), (ISPECS(1143),LMATHC(1)),
     &            (ISPECS(1231),LMARKA(1)), (ISPECS(1407),LMARKB(1)),
     &            (ISPECS(1511),LFON2A(1)), (ISPECS(1684),LFON2B(1)),
     &            (ISPECS(1810),LFON2C(1)), (ISPECS(1822),LFON3A(1)),
     &            (ISPECS(2031),LFON3B(1)), (ISPECS(2221),LFON3C(1)),
     &            (ISPECS(2428),LFON3D(1)),
     &            (INDEXS(1,1,  1),NDXS1(1)),(INDEXS(1,1, 17),NDXS2(1)),
     &            (INDEXS(1,1, 33),NDXS3(1)),(INDEXS(1,1, 49),NDXS4(1)),
     &            (INDEXS(1,1, 65),NDXS5(1)),(INDEXS(1,1, 81),NDXS6(1)),
     &            (INDEXS(1,1, 97),NDXS7(1)),(INDEXS(1,1,113),NDXS8(1)),
     &            (INDEXC(1, 1),NDXC1(1)), (INDEXC(1,49),NDXC2(1))
C
      SAVE ISPECS,LFON1A,LFON1B,LFON1C,LFON1D,LFON1E,LFON1F,LFON1G,
     &     LMATHA,LMATHB,LMATHC,LMARKA,LMARKB,LFON2A,LFON2B,LFON2C,
     &     LFON3A,LFON3B,LFON3C,LFON3D
      SAVE INDEXS,NDXS1,NDXS2,NDXS3,NDXS4,NDXS5,NDXS6,NDXS7,NDXS8
      SAVE INDEXC,NDXC1,NDXC2
C
C          DATA INITIALISATION OF CHARACTER SPECIFICATIONS:
C
C          THE FOLLOWING SPECIFY THE STANDARD PART OF FONT-1:
C
      DATA LFON1A /31,30,20,21,31,70,32,37,27,22,32,
     &             25,27,70,37,35,
     &             20,36,70,46,30,70,42,22,70,24,44,
     &             20,37,70,47,30,70,12,21,41,52,53,14,15,26,46,55,
     &             37,35,15,17,57,10,32,52,50,30,32,
     &             50,15,16,27,37,46,45,12,11,20,30,51,
     &             35,57,
     &             50,42,45,57,
     &             10,22,25,17,
     &             30,34,70,53,11,70,13,51,
     &             30,34,70,12,52,
     &             72,23,33,20,10,23,
     &             12,52,
     &             20,21,31,30,20,
     &             10,57,
     &             20,12,15,27,47,55,52,40,20,
     &             26,37,30,
     &             16,27,47,56,54,11,10,50,
     &             17,57,24,44,53,51,40,20,11/
      DATA LFON1B /37,12,52,70,44,40,
     &             10,40,51,53,44,14,17,57,
     &             13,24,44,53,51,40,20,11,13,47,
     &             17,57,56,34,22,20,
     &             24,15,16,27,47,56,55,44,53,51,40,20,11,13,24,44,
     &             20,54,56,47,27,16,14,23,43,54,
     &             21,31,30,20,21,70,22,23,33,32,22,
     &             72,23,33,20,10,23,70,24,25,35,34,24,
     &             50,12,54,
     &             11,51,70,13,53,
     &             10,52,14,
     &             16,27,47,56,55,23,22,32,70,31,30,20,21,31,
     &             42,31,22,23,34,44,41,52,54,45,25,14,11,20,40,51,
     &             10,23,37,43,70,23,43,50,
     &             14,17,47,56,55,44,53,51,40,10,14,44,
     &             51,40,20,11,16,27,47,56,
     &             10,17,47,56,51,40,10,
     &             50,10,17,57,70,14,44,
     &             10,17,57,70,14,44/
      DATA LFON1C /43,53,50,20,11,16,27,47,56,
     &             17,10,70,14,54,70,57,50,
     &             20,40,70,30,37,70,27,47,
     &             12,11,20,40,51,57,
     &             10,17,70,57,14,50,
     &             17,10,50,
     &             10,17,34,57,50,
     &             10,17,50,57,
     &             11,16,27,47,56,51,40,20,11,
     &             10,17,47,56,54,43,13,
     &             11,16,27,47,56,51,40,20,11,70,32,50,
     &             10,17,47,56,54,43,13,70,33,50,
     &             11,20,40,51,53,44,24,15,16,27,47,56,
     &             30,37,70,17,57,
     &             17,11,20,40,51,57,
     &             17,30,57,
     &             17,20,33,40,57,
     &             10,57,70,17,50,
     &             30,34,70,17,34,57/
      DATA LFON1D /17,57,10,50,
     &             50,30,37,57,
     &             17,50,
     &             10,30,37,17,
     &             15,37,55,
     &             73,10,50,
     &             17,35,
     &             13,24,44,53,50,70,51,40,20,11,22,52,
     &             13,24,44,53,51,40,20,11,70,10,17,
     &             51,40,20,11,13,24,44,53,
     &             53,44,24,13,11,20,40,51,70,50,57,
     &             12,52,53,44,24,13,11,20,40,51,
     &             30,36,47,57,70,24,54,
     &             71,11,20,40,51,57,70,56,47,27,16,14,23,43,54,
     &             10,17,70,13,24,44,53,50,
     &             30,34,70,35,
     &             73,10,20,31,35,70,36,
     &             20,27,70,54,22,50,
     &             37,31,40,50/
      DATA LFON1E /10,14,70,13,24,33,30,70,33,44,53,50,
     &             10,14,70,13,24,44,53,50,
     &             11,13,24,44,53,51,40,20,11,
     &             71,10,17,70,16,27,47,56,54,43,23,14,
     &             71,50,57,70,56,47,27,16,14,23,43,54,
     &             10,14,70,13,24,44,53,
     &             11,20,40,51,42,22,13,24,44,53,
     &             14,44,70,25,21,30,41,
     &             14,11,20,40,51,70,50,54,
     &             14,30,54,
     &             14,20,32,40,54,
     &             10,54,70,14,50,
     &             71,10,33,70,17,33,57,
     &             14,54,10,50,
     &             57,46,44,33,42,40,73,50,
     &             31,36,
     &             17,26,24,33,22,20,73,10,
     &             16,27,46,57/
C
C          THE FOLLOWING SPECIFY THE EXTENDED PART OF FONT-1:
C
      DATA LFON1F /11,16,27,47,56,51,40,20,11,70,10,57,
     &             11,13,24,44,53,51,40,20,11,70,10,54,
     &             10,24,44,70,24,37,70,57,37,30,50,
     &             13,24,33,70,30,31,20,11,22,52,53,44,33,31,40,51,
     &             10,17,70,15,26,46,55,52,41,21,12,
     &             71,10,74,17,70,13,24,44,53,51,40,20,11,
     &             50,10,70,20,26,37,47,56,70,13,43,
     &             10,16,27,47,56,55,44,14,70,44,53,51,40,20,
     &             76,25,26,36,35,25,
     &             76,17,36,57,
     &             76,16,56,
     &             76,26,16,17,27,26,70,36,37,47,46,36,
     &             76,36,57,
     &             76,16,37,56,
     &             76,26,27,70,37,36,
     &             76,16,27,46,57,
     &             25,26,36,35,25,
     &             16,35,56,
     &             15,55/
      DATA LFON1G /25,15,16,26,25,70,35,36,46,45,35,
     &             76,17,36,
     &             72,30,40,41,31,32,
     &             14,27,37,24,14,
     &             44,37,47,54,44/
C
C          THE FOLLOWING SPECIFY THE MATHEMATICAL SYMBOLS:
C
      DATA LMATHA /10,50,70,30,34,70,12,52,
     &             11,51,70,52,12,70,13,53,
     &             12,23,42,53,
     &             12,51,70,52,13,54,
     &             30,12,34,70,54,32,50,
     &             30,12,34,70,12,52,
     &             30,34,70,12,34,52,
     &             21,22,32,31,21,
     &             21,20,10,11,21,70,22,23,33,32,22,70,31,41,40,30,31,
     &             12,13,23,22,12,70,21,31,30,20,21,70,32,33,43,42,32,
     &             15,27,
     &             31,70,33,70,12,52,
     &             30,34,70,54,14,70,12,52,
     &             20,44,70,53,13,70,11,51,
     &             11,13,24,40,51,53,44,20,11,
     &             51,11,70,12,23,42,53,
     &             14,53,12,70,11,52,
     &             10,32,14,70,34,52,30,
     &             30,52,34,70,12,52/
      DATA LMATHB /30,34,70,12,30,52,
     &             26,27,37,36,26,
     &             21,20,10,11,21,70,22,12,13,23,22,70,32,33,43,42,32,
     &                                              70,31,41,40,30,31,
     &             15,27,70,37,25,
     &             30,34,
     &             10,50,70,30,34,
     &             72,11,20,31,76,36,47,56,
     &             11,22,30,75,47,57,
     &             10,50,57,17,70,24,54,
     &             51,50,10,44,17,57,56,
     &             12,42,70,51,40,20,11,13,24,44,53,
     &             10,34,50,
     &             10,14,54,50,10,
     &             21,51,70,53,23,70,34,12,30,
     &             50,20,11,13,24,54,
     &             10,13,24,44,53,50,
     &             71,12,52,53,44,24,13,11,20,40,51,
     &             20,24,70,44,40/
      DATA LMATHC /12,52,50,
     &             72,11,20,31,76,36,47,56,70,42,40,20,22,42,
     &             16,27,37,54,52,40,20,12,13,24,44,53,
     &             17,24,30,44,70,24,44,57,
     &             20,27,70,17,57,70,47,40,
     &             20,24,70,14,54,70,44,40,
     &             30,14,54,30,
     &             41,11,70,13,43,70,34,52,30,
     &             14,44,53,51,40,10,
     &             14,11,20,40,51,54,
     &             71,13,24,20,70,30,34,54,50,30/
C
C          THE FOLLOWING SPECIFY THE MARKER SYMBOLS:
C
      DATA LMARKA /10,34,50,10,
     &             10,32,34,10,50,32,70,34,50,
     &             30,12,34,52,30,
     &             30,31,70,33,34,70,12,22,70,42,52,
     &             10,21,70,43,54,70,14,23,70,41,50,
     &             32,
     &             21,43,70,34,30,70,41,23,70,12,52,
     &             10,14,54,50,10,70,30,34,70,12,52,
     &             30,34,12,52,30,12,70,34,52,
     &             20,11,13,24,44,53,51,40,20,70,30,34,70,12,52,
     &             30,31,22,70,12,22,33,70,34,33,42,70,31,42,52,
     &             10,21,23,70,14,23,43,70,54,43,41,70,21,41,50,
     &             10,34,50,10,70,32,
     &             30,14,54,30,70,32,
     &             30,32,14,30,54,32,70,14,54,
     &             10,14,54,50,10,70,32,
     &             30,12,34,52,30,70,32,
     &             20,11,13,24,44,53,51,40,20,70,32,
     &             30,31,70,32,70,33,34,70,12,22,70,42,52/
      DATA LMARKB /10,21,70,32,70,43,54,70,14,23,70,41,50,
     &             32,53,51,13,11,32,44,24,40,20,32,
     &             12,52,70,54,10,70,30,34,70,14,50,
     &             10,50,14,54,10,14,70,54,50,
     &             30,12,34,52,30,70,21,43,70,23,41,
     &             20,11,13,24,44,53,51,40,20,70,10,54,70,14,50,
     &             30,31,22,70,12,22,33,70,34,33,42,70,32,70,31,42,52,
     &             10,21,23,70,14,23,43,70,54,43,41,70,32,70,21,41,50/
C
C          THE FOLLOWING SPECIFY THE STANDARD PART OF FONT-2:
C
      DATA LFON2A /10,17,57,56,
     &             10,37,50,10,
     &             21,12,15,26,46,55,52,41,21,70,20,40,70,30,37,70,27,
     &                                                             47,
     &             10,37,50,
     &             12,15,27,47,55,52,40,20,12,70,23,25,70,24,44,70,45,
     &                                                             43,
     &             20,40,70,30,37,70,47,27,70,16,13,22,42,53,56,
     &             10,20,12,15,27,47,55,52,40,50,
     &             11,10,50,51,70,56,57,17,16,70,25,23,70,24,44,70,45,
     &                                                             43,
     &             50,43,34,24,13,11,20,30,41,54,
     &             11,16,27,47,56,55,44,14,70,44,53,51,40,20,11,72,10,
     &             72,30,32,70,16,25,32,45,56,
     &             44,24,13,11,20,40,51,53,44,16,27,47,56,
     &             72,22,13,15,26,46,55,53,42,22,70,20,74,46,
     &             72,10,56,70,16,26,40,50,
     &             34,30,40,
     &             72,12,16,70,15,26,46,55,50/
      DATA LFON2B /14,21,70,10,54,70,43,50,
     &             10,34,70,17,34,50,
     &             72,10,16,70,13,22,42,53,56,
     &             14,33,40,54,
     &             14,15,27,47,55,54,14,12,20,40,52,54,
     &             72,10,15,26,46,55,53,42,22,13,
     &             20,11,13,24,54,70,44,53,51,40,20,
     &             30,34,70,13,24,54,
     &             14,11,20,40,51,53,44,
     &             72,30,37,70,16,13,22,42,53,56,
     &             24,13,11,20,31,33,70,31,40,51,53,44,
     &             17,46,70,56,46,15,14,43,70,53,43,12,11,20,50,73,50,
     &                                                             40,
     &             17,26,46,70,57,46,22,21,30,50,73,50,40/
C
C          THE FOLLOWING SPECIFY THE EXTENDED PART OF FONT-2:
C
      DATA LFON2C /15,26,27,37,36,15,
     &             35,16,17,27,26,35/
C
C          THE FOLLOWING SPECIFY THE STANDARD PART OF FONT-3:
C
      DATA LFON3A /14,44,53,51,40,10,17,57,56,
     &             27,20,70,10,40,47,70,40,50,73,50,
     &             10,11,51,50,70,41,47,70,57,27,70,37,21,
     &             10,50,52,70,55,57,17,70,27,20,70,24,44,70,45,43,
     &             10,30,70,20,27,70,17,57,56,
     &             17,10,57,50,
     &             75,17,26,46,57,74,70,17,10,57,50,
     &             10,30,70,20,27,70,17,37,70,24,34,47,57,70,34,40,50,
     &             11,10,20,37,70,27,57,70,47,40,70,30,50,
     &             10,17,30,57,50,
     &             10,30,70,20,27,70,17,47,56,54,43,23,
     &             51,40,20,12,15,27,47,56,
     &             16,17,57,56,70,37,30,70,20,40,
     &             11,20,31,17,70,57,31,
     &             10,20,27,17,70,27,47,56,55,44,24,70,44,53,51,40,20,
     &             17,14,23,43,70,47,40,70,30,50,
     &             27,17,10,30,41,43,34,14,70,50,57,
     &             12,11,20,40,51,53,44,55,56,47,27,16,70,24,44,
     &             13,24,44,53,51,40,20,11,14,25,56/
      DATA LFON3B /10,50,73,50,74,70,40,44,70,24,20,
     &             10,11,51,50,70,21,34,70,24,54,70,44,41,
     &             11,13,24,44,53,51,40,20,11,70,25,34,45,70,34,30,73,
     &                                                    20,70,40,31,
     &             10,30,70,20,24,70,14,54,53,
     &             14,10,54,50,
     &             14,10,54,50,70,55,44,24,15,
     &             10,30,70,20,24,70,14,34,70,22,32,44,54,70,32,40,50,
     &             11,10,20,34,70,24,54,70,44,40,70,30,50,
     &             10,14,30,54,50,
     &             10,14,70,12,52,70,54,50,
     &             21,30,40,51,53,44,34,23,70,24,20,72,20,70,10,30,
     &             20,40,70,30,34,70,13,14,54,53,
     &             14,30,70,54,30,72,20,11,
     &             10,40,51,42,53,44,14,70,24,20,70,22,42,
     &             10,50,70,40,44,70,34,30,70,20,24,
     &             24,14,10,30,41,32,12,70,54,50,
     &             11,20,40,51,42,53,44,24,13,70,42,22/
C
C          THE FOLLOWING SPECIFY THE EXTENDED PART OF FONT-3:
C
      DATA LFON3C /10,24,17,70,27,47,70,37,30,70,20,40,70,50,44,24,70,
     &                                                          44,57,
     &             10,22,14,70,24,44,70,34,30,70,20,40,70,50,42,22,70,
     &                                                          42,54,
     &             14,12,21,41,70,44,40,70,30,50,
     &             10,50,70,40,47,70,37,30,70,20,27,
     &             10,50,73,50,74,70,40,47,70,37,30,70,20,27,
     &             10,50,73,50,74,70,40,44,70,34,30,70,20,24,
     &             10,40,51,53,44,24,70,20,27,70,37,17,16,
     &             10,40,51,42,22,70,20,24,70,34,14,13,
     &             10,40,51,53,44,24,70,20,27,70,37,17,
     &             10,40,51,42,22,70,20,24,70,14,34,
     &             16,27,47,55,52,40,20,11,12,70,24,54,
     &             13,24,44,53,51,40,20,11,70,22,52,
     &             10,17,70,14,24,25,37,47,55,52,40,30,22,24,
     &             10,14,70,12,22,23,34,44,53,51,40,30,21,22,
     &             10,20,34,25,26,37,57,50,70,54,34,
     &             10,20,32,23,34,54,50,70,52,32/
      DATA LFON3D /10,50,52,70,55,57,17,70,27,20,70,24,44,70,45,43,75,
     &                                              70,17,27,70,47,57,
     &             12,52,53,44,24,13,11,20,40,51,70,15,25,70,45,55/
C
C          DATA INITIALISATION OF THE UNIQUE-CHAR. INDEX:
C
      DATA NDXS1 /   0, 0,     0, 0,     0, 0,
     &               0,11,     0,11,     0,11,
     &              11, 5,    11, 5,    11, 5,
     &              16,11,    16,11,    16,11,
     &              27,16,    27,16,    27,16,
     &              43,11,    43,11,    43,11,
     &              54,12,    54,12,    54,12,
     &              66, 2,    66, 2,    66, 2,
     &              68, 4,    68, 4,    68, 4,
     &              72, 4,    72, 4,    72, 4,
     &              76, 8,    76, 8,    76, 8,
     &              84, 5,    84, 5,    84, 5,
     &              89, 6,    89, 6,    89, 6,
     &              95, 2,    95, 2,    95, 2,
     &              97, 5,    97, 5,    97, 5,
     &             102, 2,   102, 2,   102, 2/
      DATA NDXS2 / 104, 9,   104, 9,   104, 9,
     &             113, 3,   113, 3,   113, 3,
     &             116, 8,   116, 8,   116, 8,
     &             124, 9,   124, 9,   124, 9,
     &             133, 6,   133, 6,   133, 6,
     &             139, 8,   139, 8,   139, 8,
     &             147,10,   147,10,   147,10,
     &             157, 6,   157, 6,   157, 6,
     &             163,16,   163,16,   163,16,
     &             179,10,   179,10,   179,10,
     &             189,11,   189,11,   189,11,
     &             200,12,   200,12,   200,12,
     &             212, 3,   212, 3,   212, 3,
     &             215, 5,   215, 5,   215, 5,
     &             220, 3,   220, 3,   220, 3,
     &             223,14,   223,14,   223,14/
      DATA NDXS3 / 237,16,   237,16,   237,16,
     &             253, 8,   253, 8,   253, 8,
     &             261,12,   261,12,  1821, 9,
     &             273, 8,  1510, 4,  1830,11,
     &             281, 7,  1514, 4,  1841,13,
     &             288, 7,   288, 7,  1854,16,
     &             295, 6,  1518,18,  1518,18,
     &             301, 9,  1510, 4,  1870, 9,
     &             310, 8,   419, 5,   419, 5,
     &             318, 8,   318, 8,  1879, 4,
     &             326, 6,   310, 8,  1883,11,
     &             332, 6,   332, 6,  1894,17,
     &             338, 3,  1536, 3,  1911,13,
     &             341, 5,   341, 5,  1924, 5,
     &             346, 4,   346, 4,   310, 8,
     &             350, 9,   350, 9,   350, 9/
      DATA NDXS4 / 359, 7,  1179, 8,  1179, 8,
     &             366,12,  1539,18,   350, 9,
     &             378,10,   359, 7,  1929,12,
     &             388,12,  1079, 7,  1941, 8,
     &             400, 5,   400, 5,  1949,10,
     &             405, 6,   424, 6,  1959, 7,
     &             411, 3,  1557,15,  1966,17,
     &             414, 5,  1572,10,  1983,10,
     &             419, 5,  1582,18,   419, 5,
     &             424, 6,   424, 6,  1993,11,
     &             430, 4,   430, 4,  2004,15,
     &             434, 4,   434, 4,   434, 4,
     &             438, 2,   438, 2,   438, 2,
     &             440, 4,   440, 4,   440, 4,
     &             444, 3,   444, 3,   444, 3,
     &             447, 3,   447, 3,   447, 3/
      DATA NDXS5 / 450, 2,   450, 2,   450, 2,
     &             452,12,  1600,10,   452,12,
     &             464,11,  1610,17,  2019,11,
     &             475, 8,  1627, 9,  2030,11,
     &             483,11,  1636,13,  2041,13,
     &             494,10,  1086,11,   494,10,
     &             504, 7,  1649,14,  2054,21,
     &             511,15,  1627, 9,  2075, 9,
     &             526, 8,  1663, 8,   648, 5,
     &             534, 4,  1671, 3,  2084, 4,
     &             538, 7,  1674, 9,  2088, 9,
     &             545, 6,  1683, 8,  2097,17,
     &             551, 4,  1691, 6,  2114,13,
     &             555,12,  1697, 9,  2127, 5,
     &             567, 8,  1706, 4,  2132, 8,
     &             575, 9,   575, 9,   575, 9/
      DATA NDXS6 / 584,12,  1187, 8,  1187, 8,
     &             596,12,  1710,12,   575, 9,
     &             608, 7,  1722,10,  2140,16,
     &             615,10,  1732,11,   475, 8,
     &             625, 7,  1743, 6,  2156,10,
     &             632, 8,  1749, 7,  2166, 8,
     &             640, 3,  1756,10,  2174,13,
     &             643, 5,  1766,12,  2258,10,
     &             648, 5,  1778,18,   648, 5,
     &             653, 7,  1749, 7,  2198,10,
     &             660, 4,  1796,13,  2208,12,
     &             664, 8,   664, 8,   664, 8,
     &             672, 2,   672, 2,   672, 2,
     &             674, 8,   674, 8,   674, 8,
     &             682, 4,   682, 4,   682, 4,
     &               0, 0,     0, 0,     0, 0/
      DATA NDXS7 / 686,12,  1809, 6,  2220,19,
     &             698,12,  1815, 6,  2239,19,
     &             710,11,    16,11,  1983,10,
     &             721,16,    16,11,  2258,10,
     &             737,11,    16,11,  2268,11,
     &             748,13,    16,11,  2187,11,
     &             761,11,    16,11,  2279,14,
     &             772,14,    16,11,  2293,14,
     &             786, 6,    16,11,  2307,13,
     &             792, 4,    16,11,  2320,12,
     &             796, 3,    16,11,  2332,12,
     &             799,12,    16,11,  2344,11,
     &             811, 3,    16,11,  2355,12,
     &             814, 4,    16,11,  2367,11,
     &             818, 6,    16,11,  2378,14,
     &             824, 5,    16,11,  2392,14/
      DATA NDXS8 / 829, 5,    16,11,  2406,11,
     &             834, 3,    16,11,  2417,10,
     &             837, 2,    16,11,  2427,23,
     &             839,11,    16,11,  2450,16,
     &             850, 3,    16,11,    16,11,
     &             853, 6,    16,11,    16,11,
     &             859, 5,    16,11,    16,11,
     &             864, 5,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11,
     &              16,11,    16,11,    16,11/
C
C          DATA INITIALISATION OF THE COMMON-CHAR. INDEX:
C
      DATA NDXC1 /  84, 5,    76, 8,   648, 5,   869, 8,
     &             215, 5,   877, 8,   885, 4,   212, 3,
     &             889, 6,   895, 7,   902, 6,   908, 6,
     &             914, 5,   919,17,   936,17,   953, 2,
     &              95, 2,   955, 6,   102, 2,   961, 8,
     &             969, 8,   977, 9,   986, 7,   220, 3,
     &             993, 6,   999, 7,  1006, 6,  1012, 6,
     &            1018, 5,   189,11,  1023,23,  1046, 5,
     &            1051, 2,  1053, 5,  1058, 8,  1066, 6,
     &            1072, 7,  1079, 7,  1086,11,  1097, 3,
     &            1100, 5,  1105, 9,  1114, 6,  1120, 6,
     &            1126,11,    68, 4,   434, 4,   664, 8/
      DATA NDXC2 /1137, 5,  1142, 3,  1145,14,  1159,12,
     &            1171, 8,  1179, 8,  1187, 8,   640, 3,
     &            1195, 4,  1199, 9,  1208, 6,  1214, 6,
     &            1220,10,    72, 4,   440, 4,   674, 8,
     &            1230, 4,  1195, 4,  1234, 9,  1100, 5,
     &            1243, 5,   575, 9,  1248,11,  1259,11,
     &              84, 5,  1270, 1,  1271,11,  1282,11,
     &            1293, 9,  1302,15,  1317,15,  1332,15,
     &            1347, 6,  1353, 6,  1359, 9,  1368, 7,
     &            1375, 7,  1382,11,  1393,13,  1406,13,
     &             648, 5,  1419,11,  1430,11,  1441, 9,
     &            1450,11,  1461,15,  1476,17,  1493,17/
C
C
C          FOR CHAR. NUMBERS UP TO 159, THE UNIQUE-CHAR. INDEX
C          IS USED, AND THE CURRENT FONT IS ALSO REQUIRED. FOR
C          CHAR. NUMBERS ABOVE THIS, THE CHARS ARE THE SAME FOR
C          ALL FONTS, SO ONLY THE COMMON-CHAR. INDEX IS USED.
C          IF THE REQUIRED CHARACTER IS A UNIQUE ONE IN FONT-0,
C          THE REDEFINED CHAR. LIST [KNUM] IS SCANNED FIRST TO
C          SEE IF THE CHAR. HAS BEEN AMENDED. IF IT HASN'T BEEN
C          REDEFINED, THE CHARACTER IS TAKEN FROM FONT-1 INSTEAD.
C          IF IT HAS BEEN REDEFINED, THE NEW SPECIFICATION IS
C          COPIED FROM [KSPEC] VIA THE INDICES [KPOSN] AND [KLEN].
C
      NCHAR= ICHAR
      NFONT= IFONT
      IF (NFONT.LT.0.OR.NFONT.GT.3) NFONT= 1
      IF (NCHAR.GE.160)   GO TO 4
      IF (NFONT.NE.0)     GO TO 3
      IF (NDEFS.LT.KSTRT) GO TO 2
C
C          THIS SECTION DEALS WITH RE-DEFINABLE CHARACTERS.
C
      IPOSN= KSTRT
C
      DO 100 LOOK= KSTRT,NDEFS
        IF (NCHAR.EQ.KNUM(LOOK)) GO TO 1
C
        IPOSN= IPOSN+1
  100 CONTINUE
C
      IF (NCHAR.LT.32) NCHAR= 32
      GO TO 2
C
    1 LENGTH= KLEN(IPOSN)
      IF (LENGTH.EQ.0) RETURN
C
      IFROM= KPOSN(IPOSN)
C
      DO 200 ICOPY= 1,LENGTH
        IFROM= IFROM+1
        ICODE= KSPEC(IFROM)
        IXPTS(ICOPY)= ICODE/10
        IYPTS(ICOPY)= MOD(ICODE,10)
  200 CONTINUE
      RETURN
C
C          THIS SECTION DEALS WITH ALL PREDEFINED CHARACTERS.
C
    2 NFONT= 1
    3 IFROM= INDEXS(1,NFONT,NCHAR-31)
      LENGTH= INDEXS(2,NFONT,NCHAR-31)
      GO TO 5
C
    4 IFROM= INDEXC(1,NCHAR-159)
      LENGTH= INDEXC(2,NCHAR-159)
    5 IF (LENGTH.EQ.0) RETURN
C
      DO 300 ICOPY= 1,LENGTH
        IFROM= IFROM+1
        ICODE= ISPECS(IFROM)
        IXPTS(ICOPY)= ICODE/10
        IYPTS(ICOPY)= MOD(ICODE,10)
  300 CONTINUE
C
      RETURN
      END
      SUBROUTINE G1CLIP(IREPLY)
C
C          ------------------------------------------------
C          ROUTINE NO. (1024)   VERSION (A8.3)    26:NOV:86
C          ------------------------------------------------
C
C          THIS DETERMINES HOW A GIVEN LINE INTERACTS WITH A GIVEN
C          RECTANGLE. THE INTERSECTION POINTS ARE FOUND IF POSSIBLE.
C
C
C          THE VALUES IMPORTED ARE:
C
C          <XLIM1>  IS THE LEFTMOST RECTANGLE EDGE.
C          <XLIM2>  IS THE RIGHTMOST RECTANGLE EDGE.
C          <YLIM1>  IS THE LOWER RECTANGLE EDGE.
C          <YLIM2>  IS THE UPPER RECTANGLE EDGE.
C          [POINTS] GIVES THE START AND END POINTS OF THE LINE
C                   (VALUES (<NSTRT>,1&2) AND (<NSTOP>,1&2) RESP.)
C          <NSTRT>  GIVES THE INDEX OF THE START POINT OF THE LINE.
C          <NSTOP>  GIVES THE INDEX OF THE END POINT OF THE LINE.
C
C
C          THE VALUES EXPORTED ARE:
C
C          [STRTPT] IS THE POSITION OF THE 1ST. INTERSECTION,
C          [STOPPT] IS THE POSITION OF THE 2ND. INTERSECTION,
C                   (WHERE THEY EXIST). WITH ONE INTERSECTION,
C                   THE 2ND. POINT IS THE END WHICH IS INSIDE.
C
C
C          THE RETURN ARGUMENT IS:
C
C          <IREPLY> GIVES THE RESULT:
C                   = 0, THE LINE IS WHOLLY INSIDE,
C                   = 1, THE LINE INTERSECTS THE RECTANGLE
C                   = 2, THE LINE IS WHOLLY OUTSIDE.
C
C
      LOGICAL SECT1(4),SECT2(4)
C
      COMMON /T1CLIN/ STRTPT(2),STOPPT(2)
      COMMON /T1CLIP/ XLIM1,XLIM2,YLIM1,YLIM2
      COMMON /T1LINE/ POINTS(22,2),NSTRT,NSTOP
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C          THESE FUNCTIONS GIVE THE INTERSECTION POINTS OF THE
C          CURRENT LINE TO X AND Y AXES AT THE GIVEN POSITIONS:
C
      XCUT1(Y)= XEND1+(Y-YEND1)*(DIFFX/DIFFY)
      XCUT2(Y)= XEND2+(Y-YEND2)*(DIFFX/DIFFY)
      YCUT1(X)= YEND1+(X-XEND1)*(DIFFY/DIFFX)
      YCUT2(X)= YEND2+(X-XEND2)*(DIFFY/DIFFX)
      XEND1= POINTS(NSTRT,1)
      YEND1= POINTS(NSTRT,2)
      XEND2= POINTS(NSTOP,1)
      YEND2= POINTS(NSTOP,2)
      DIFFX= XEND1-XEND2
      DIFFY= YEND1-YEND2
      IREPLY= 0
C
    1   DO 100 IPOSN= 1,4
          SECT1(IPOSN)= .FALSE.
          SECT2(IPOSN)= .FALSE.
  100   CONTINUE
C
        IF (XEND1.LT.XLIM1) SECT1(1)= .TRUE.
        IF (XEND2.LT.XLIM1) SECT2(1)= .TRUE.
        IF (XEND1.GT.XLIM2) SECT1(2)= .TRUE.
        IF (XEND2.GT.XLIM2) SECT2(2)= .TRUE.
        IF (YEND1.LT.YLIM1) SECT1(3)= .TRUE.
        IF (YEND2.LT.YLIM1) SECT2(3)= .TRUE.
        IF (YEND1.GT.YLIM2) SECT1(4)= .TRUE.
        IF (YEND2.GT.YLIM2) SECT2(4)= .TRUE.
C
C          IF ALL THE TESTS ARE .FALSE., THE LINE IS INSIDE.
C
        DO 200 IPOSN= 1,4
          IF (SECT1(IPOSN)) GO TO 2
          IF (SECT2(IPOSN)) GO TO 2
  200   CONTINUE
        RETURN
C
C          IF TWO CORRESPONDING TESTS ARE .TRUE., THE
C          LINE IS COMPLETELY OUTSIDE THE CLIP RECTANGLE.
C
    2   IREPLY= 2
        NTRYS1= 0
        NTRYS2= 0
C
        DO 300 IPOSN= 1,4
          IF (SECT1(IPOSN).AND.SECT2(IPOSN)) RETURN
          IF (SECT1(IPOSN)) NTRYS1= NTRYS1+1
          IF (SECT2(IPOSN)) NTRYS2= NTRYS2+1
  300   CONTINUE
C
C          OTHERWISE, THE LINE IS TRUNCATED AT ONE OR BOTH ENDS
C          BY THE LIMIT VALUES AND THE ABOVE TESTS ARE REPEATED.
C
        IREPLY= 1
        IF (NTRYS1.EQ.0)   GO TO 6
        IF (.NOT.SECT1(1)) GO TO 3
C
        YEND1= YCUT2(XLIM1)
        XEND1= XLIM1
        GO TO 6
C
    3   IF (.NOT.SECT1(2)) GO TO 4
C
        YEND1= YCUT2(XLIM2)
        XEND1= XLIM2
        GO TO 6
C
    4   IF (.NOT.SECT1(3)) GO TO 5
C
        XEND1= XCUT2(YLIM1)
        YEND1= YLIM1
        GO TO 6
C
    5   IF (.NOT.SECT1(4)) GO TO 6
C
        XEND1= XCUT2(YLIM2)
        YEND1= YLIM2
C
C          WHEN BOTH END POINTS LIE IN CENTRE-EDGE AREAS, A DOUBLE
C          TRUNCATION IS PREVENTED TO AVOID PERPETUAL SWOPPING OF
C          THE NEW END POINTS WHEN THE LINE IS OUTSIDE THE CLIP AREA.
C
    6   IF (NTRYS2.EQ.0)                 GO TO 10
        IF (NTRYS1.EQ.1.AND.NTRYS2.EQ.1) GO TO 10
        IF (.NOT.SECT2(1)) GO TO 7
C
        YEND2= YCUT1(XLIM1)
        XEND2= XLIM1
        GO TO 10
C
    7   IF (.NOT.SECT2(2)) GO TO 8
C
        YEND2= YCUT1(XLIM2)
        XEND2= XLIM2
        GO TO 10
C
    8   IF (.NOT.SECT2(3)) GO TO 9
C
        XEND2= XCUT1(YLIM1)
        YEND2= YLIM1
        GO TO 10
C
    9   IF (.NOT.SECT2(4)) GO TO 10
C
        XEND2= XCUT1(YLIM2)
        YEND2= YLIM2
C
C          THE NEW END POINTS ARE SAVED BEFORE THE TESTS ARE REPEATED.
C          A LINE WHICH SHRINKS TO A POINT IS DECLARED TO BE OUTSIDE.
C
   10   STRTPT(1)= XEND1
        STRTPT(2)= YEND1
        STOPPT(1)= XEND2
        STOPPT(2)= YEND2
        IF (ABS(XEND2-XEND1).GE.RMINI.OR.
     &      ABS(YEND2-YEND1).GE.RMINI) GO TO 1
C
      IREPLY= 2
      RETURN
      END
      SUBROUTINE G1FILB(IX1,IY1,IX2,IY2)
C
C          ------------------------------------------------
C          ROUTINE NO. (1025)   VERSION (A8.7)    14:NOV:90
C          ------------------------------------------------
C
C          THIS ROUTINE FILLS THE CURRENT BUFFER WITH PAIRED VALUES
C          ACCORDING TO THE SUPPLIED ARGUMENTS (WHICH ARE EITHER
C          LINE START AND STOP POINTS OR FUNCTION CODES PLUS DATA).
C
C
C          IF <IX2> >= 0, THE ARGUMENTS GIVE A VECTORED LINE FROM
C          <IX1,IY1> TO <IX2,IY2>. THE END-POINT NEAREST TO THE
C          CURRENT POSITION IS FOUND, AND IF THIS IS NOT THE SAME
C          PLACE, A 'MOVE' IS INSERTED BEFORE THE LINE IS DRAWN.
C
C          IF <IX2> < 0, IT DENOTES A SPECIAL FUNCTION. IF <IY2> IS
C          NEGATIVE, IT GIVES THE LENGTH (IN PAIRS) OF SUBSEQUENT
C          FUNCTION DATA (GIVEN BY SUCCEEDING <IX2,IY2> VALUES).
C          OTHERWISE, <IY2> PROVIDES A SINGLE DATA VALUE DIRECTLY.
C          <IX2> GIVES THE FOLLOWING FUNCTIONS:
C
C          =  -1, MOVE TO <IX1,IY1> AND PLOT A POINT,
C          =  -2, MOVE TO <IX1,IY1> AND DRAW CHAR. <IY2>,
C          =  -3, ----------------------------------
C          =   .
C          =   .           -NOT YET DEFINED-
C          =   .
C          =   .    -RESERVED FOR FUTURE EXPANSION-
C          =   .
C          =   .
C          = -10, ----------------------------------
C          = -11, SET HARDWARE CHARACTER SIZE      <IY2>,
C          = -12, SET HARDWARE CHARACTER ANGLE     <IY2>,
C          = -13, SET HARDWARE CHARACTER ITALIC    <IY2>,
C          = -14, SET HARDWARE CHARACTER OBLATE    <IY2>,
C          = -15, SET HARDWARE LINE TYPE           <IY2>,
C          = -16, SET HARDWARE LINE INTENSITY      <IY2>,
C          = -17, SET COLOUR NUMBER                <IY2>,
C          = -18, FILL POLYGON                     <IY2>,
C          = -19, SET DEVICE RESOLUTION            <IY2>,
C          = -20, BEGIN FILLED-AREA BOUNDARY       <IDATA>,
C          = -21, SET PLOT ORIENTATION             <IY2>,
C          = -22, SET PEN VELOCITY                 <IY2>,
C          = -23, ----------------------------------
C          =   .
C          =   .           -NOT YET DEFINED-
C          =   .
C          =   .    -RESERVED FOR FUTURE EXPANSION-
C          =   .
C          =   .
C          = -39, ----------------------------------
C          = -40, PASS DATA DIRECTLY TO THE DEVICE <IDATA>,
C          = -41, SET A COLOUR-TABLE ENTRY         <IDATA>,
C          = -42, DEFINE HARDWARE LINE TYPE        <IDATA>,
C          = -43, SET BACKGROUND COLOUR            <IDATA>,
C          = -44, SET CROSS-HATCHING PARAMETERS    <IDATA>,
C          = -45, ----------------------------------
C          =   .
C          =   .           -NOT YET DEFINED-
C          =   .
C          =   .    -RESERVED FOR FUTURE EXPANSION-
C          =   .
C          =   .
C          = -80, ----------------------------------
C          = -81, ERASE THE DEVICE WITH PROMPT/WAIT,
C          = -82, ERASE THE DEVICE WITHOUT PROMPT/WAIT,
C          = -83, DISPLAY THE GRAPHICS CURSOR,
C          = -84, CLEAR THE SYSTEM BUFFER,
C          = -85, END GRAPHICAL OUTPUT,
C          = -86, OPEN  DEVICE CHANNEL             <IY2>,
C          = -87, CLOSE DEVICE CHANNEL             <IY2>,
C          = -88, READ LOCATOR FROM TABLET.
C
C          IN THE CASE OF SPECIAL FUNCTIONS, THE <IX2> AND <IY2>
C          VALUES ARE SIMPLY PUT IN THE BUFFER. ONLY THE SYSTEM
C          BUFFER IS USED FOR FUNCTIONS WITH <IX2> <= -80, AND IT
C          IS ALSO CLEARED WHEN ONE OF THESE FUNCTIONS IS FOUND.
C
C
      LOGICAL DONE,SYFUNC
      LOGICAL FULL,ERRON
C
      COMMON /T1BEPT/ IXFINI,IYFINI
      COMMON /T1BFSV/ LENFLB
      COMMON /T1BUFN/ KBUFR1
      COMMON /T1BUFS/ MSYSTB(200),LIMSYS,ISYSTP
      COMMON /T1BUFU/ MUSERB(3200),LENTHB,KINDEX,KLIMIT,KAREA,LIMARE,
     &                IAREAP(16),ISTRTA(16),KAREAS(16),NAREAS(16),
     &                INEXTA(32),FULL
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
C          IF THE CURRENT BUFFER IS A NON-SYSTEM ONE
C          AND THE AREAS ARE ALL USED, NOTHING IS DONE.
C
      IF (FULL.AND.KBUFR1.NE.0.AND.IX2.GT.-81) RETURN
C
      IXNEAR= IX1
      IYNEAR= IY1
      IXFAR=  IX2
      IYFAR=  IY2
      SYFUNC= .FALSE.
C
C          IF <LENFLB> HAS BEEN SET, SUCCESSIVE VALUES <IX2>
C          AND <IY2> ARE PUT IN THE BUFFER UNTIL ALL ARE DONE.
C          IF <IX2> >= 0, A DRAWN VECTOR IS REQUIRED.
C          IF <IX2> < 0, IT IS A SPECIAL FUNCTION. IF
C          <IX2> > -11, A MOVE TO <IX1,IY1> HAS TO BE DONE
C          FIRST, SO THE CURRENT POSITION HAS TO BE UPDATED.
C          WHEN ERASE ETC. ARE CALLED, THE END POSITION IS
C          RESET SO AS TO GIVE A 'MOVE' COMMAND AFTERWARDS.
C
      IF (LENFLB.GT.0) GO TO 4
C
      LENFLB= 0
      IF (IXFAR.GE.0) GO TO 2
C
      IF (IXFAR.LE.-11) GO TO 1
      IXFINI= IXNEAR
      IYFINI= IYNEAR
      GO TO 3
C
    1 IF (IYFAR.LT.0) LENFLB= -IYFAR+1
      IF (IXFAR.GT.-81) GO TO 4
C
      SYFUNC= .TRUE.
      IXFINI= -1
      IYFINI= -1
C
C          THE SYSTEM BUFFER IS RE-SELECTED BY AN 'ERASE'.
C
      IF (KBUFR1.LE.0)  GO TO 4
      IF (IXFAR.LT.-82) GO TO 4
C
      KAREAS(KBUFR1)= KAREA
      IAREAP(KBUFR1)= KINDEX
      KBUFR1= 0
      GO TO 4
C
C          A MOVE INSTRUCTION IS ENTERED IN THE BUFFER
C          IF THE START POINT IS NOT THE SAME AS THE
C          FORMER END POINT, FOLLOWED IN EITHER CASE
C          BY THE COORDINATES OF THE END POINT.
C
    2 IXTEST= IXFINI
      IYTEST= IYFINI
      IXFINI= IXFAR
      IYFINI= IYFAR
      IF (IXNEAR.EQ.IXTEST.AND.IYNEAR.EQ.IYTEST) GO TO 4
C
    3 DONE= .FALSE.
      IXVALU= IXNEAR
      IYVALU= -IYNEAR-1
      GO TO 5
C
    4 DONE= .TRUE.
        IXVALU= IXFAR
        IYVALU= IYFAR
        IF (SYFUNC) GO TO 6
C
C          THIS SECTION LOADS THE CURRENT BUFFER WITH
C          THE GIVEN VALUES. IF THE BUFFER IS THE SYSTEM
C          ONE, IT IS EMPTIED WHEN FULL, THEN REFILLED.
C          IN THE CASE OF ANY NON-SYSTEM BUFFER, WHEN
C          THE CURRENT AREA IS FULL ANOTHER IS SOUGHT
C          AND CHAINED ONTO THE AREA LIST OF THAT BUFFER.
C          IF THERE ARE NO MORE FREE AREAS, AN ERROR
C          MESSAGE IS GENERATED AND THE FLAG IS SET.
C
    5   IF (KBUFR1.NE.0) GO TO 7
    6   ISYSTP= ISYSTP+2
        MSYSTB(ISYSTP-1)= IXVALU
        MSYSTB(ISYSTP)= IYVALU
        IF (ISYSTP.LT.LIMSYS.AND..NOT.SYFUNC) GO TO 9
        CALL G1TRAN(MSYSTB,1,ISYSTP)
        ISYSTP= 0
        GO TO 9
C
    7   KINDEX= KINDEX+2
        MUSERB(KINDEX-1)= IXVALU
        MUSERB(KINDEX)= IYVALU
        IF (KINDEX.LT.KLIMIT) GO TO 9
C
        DO 100 ISERCH= 1,32
          IF (INEXTA(ISERCH).EQ.0) GO TO 8
  100   CONTINUE
C
        FULL= .TRUE.
        GO TO 901
C
    8   INEXTA(KAREA)= ISERCH
        KAREA= ISERCH
        INEXTA(KAREA)= -1
        KAREAS(KBUFR1)= KAREA
        NAREAS(KBUFR1)= NAREAS(KBUFR1)+1
        KINDEX= LIMARE*(KAREA-1)
        KLIMIT= LIMARE*KAREA
    9   IF (.NOT.DONE) GO TO 4
C
      IF (LENFLB.GT.0) LENFLB= LENFLB-1
      RETURN
C
  901 NUMERR= 1003
      IF (.NOT.ERRON) RETURN
C
      ISYSTP= ISYSTP+2
      MSYSTB(ISYSTP-1)= -84
      MSYSTB(ISYSTP)= 0
      CALL G1TRAN(MSYSTB,1,ISYSTP)
      ISYSTP= 0
      CALL G1ERMS
      RETURN
      END
      SUBROUTINE G1TRAN(INBUFR,ISTART,IEND)
C
C          ------------------------------------------------
C      ROUTINE NO. (1003)   VERSION (A8.1APC) 20:NOV:90
C          ------------------------------------------------
C
C          THIS CONVERTS PAIRS OF VALUES IN THE INPUT BUFFER
C          INTO CODES SUITABLE FOR DRIVING THE OUTPUT DEVICE.
C          (THIS VERSION IS FOR ADOBE COLOUR POSTSCRIPT).
C
C
C          THE FUNCTIONS SUPPORTED HERE (GIVEN BY
C          THE X-VALUE OF ANY PAIR) ARE AS FOLLOWS:
C
C          =  -1, PLOT (AT THE CURRENT POSITION) A POINT,
C          =  -2, DRAW (AT THE CURRENT POS.) CHAR. <IYVAL>,
C              .
C          = -11, SET HARDWARE CHARACTER SIZE      <IYVAL>,
C          = -12, SET HARDWARE CHARACTER ANGLE     <IYVAL>,
C          = -13, SET HARDWARE CHARACTER ITALIC    <IYVAL>,
C          = -14, SET HARDWARE CHARACTER OBLATE    <IYVAL>,
C              .
C          = -17, SET COLOUR NUMBER                <IYVAL>,
C          = -18, FILL POLYGON                     <IYVAL>,
C              .
C          = -20, BEGIN FILLED-AREA BOUNDARY       <IYVAL>,
C          = -21, SET PLOT ORIENTATION             <IYVAL>,
C              .
C          = -40, PASS DATA DIRECTLY TO THE DEVICE <IDATA>,
C              .
C          = -42, DEFINE HARDWARE LINE TYPE        <IDATA>,
C              .
C          = -44, SET PARAMETERS FOR CROSS HATCHING,
C              .
C          = -81, ERASE THE DEVICE WITH PROMPT/WAIT,
C          = -82, ERASE THE DEVICE WITHOUT PROMPT/WAIT,
C              .
C          = -84, CLEAR THE SYSTEM BUFFER,
C          = -85, END GRAPHICAL OUTPUT.
C
C
      INTEGER INBUFR(IEND),IDUMMY(1),ICODES(14),ITRAIL(10),IBYTE(5)
      LOGICAL BOUND
C
      COMMON /T1APAA/ IXPLOT,IYPLOT,IXMSAV,IYMSAV,LENPTH,MAXPTH
      COMMON /T1APCB/ CHIGHT,ZOBLAT,IREDPO(255),IGRNPO(255),IBLUPO(255),
     &                KOLOUR,IPAGE(17),IPGCNT
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1FLBF/ IXSAVE(2000),IYSAVE(2000),ISAVSZ,INDSAV
      COMMON /T1FLSV/ BOUND
      COMMON /T1FUND/ NUMFUN,LENARG
      COMMON /T1HTCH/ IHTCHP(11,2)
      COMMON /T1IOBF/ ICODEB(512),ISIZEB,INDXB,INITXB
      COMMON /T1LAND/ LNDSCP
C
      DATA IDUMMY /  0/, IBLANK / 32/, LPAREN / 40/, IRPARN / 41/,
     &     MINUS  / 45/, IPOINT / 46/, IZERO  / 48/,
     &     LETTRC / 67/, LETTRP / 80/, IBSLSH / 92/,
     &     LETTSB / 98/, LETTSC / 99/, LETTSF /102/, LETTSH /104/,
     &     LETTSP /112/, LETTSR /114/, LETTSS /115/, LETTSW /119/,
     &     LETTSX /120/,
     &     IHTCOL /  2/, IHTYPE / 11/, ICODES /14*32/
C
C          ARRAY IS INITIALISED TO:
C
C  ITRAIL  %%Trailer
C
      DATA ITRAIL /37,37,84,114,97,105,108,101,114,32/
C
C
C          EACH PAIR OF VALUES IS TAKEN IN TURN FROM THE
C          SUPPLIED BUFFER, THE REQUIRED ACTION IS DECODED,
C          THEN THE APPROPRIATE COMMANDS FOR THE DISPLAY ARE
C          STORED IN A LINE OUTPUT BUFFER, WHICH IS EMPTIED
C          (THE CONTENTS BEING SENT TO THE DISPLAY) WHEN FULL.
C
C          IF <LENARG> IS NON-ZERO, A FUNCTION IS STILL ACTIVE.
C          THE BUFFER PAIR IS THEN PASSED ON DIRECTLY TO THE
C          RELEVANT FUNCTION. OTHERWISE, IF <IXVAL> < 0, A
C          NEW FUNCTION IS REQUIRED, OR IF <IXVAL> > 0, A
C          VECTOR (VISIBLE OR INVISIBLE) IS REQUIRED INSTEAD.
C
      DO 100 IPAIR= ISTART,IEND,2
        IXVAL= INBUFR(IPAIR)
        IYVAL= INBUFR(IPAIR+1)
        IF (LENARG.GT.0) GO TO 42
        IF (IXVAL.LT.0)  GO TO 2
        IF (BOUND)       GO TO 35
C
C          THE FIRST PART PROVIDES VECTOR DRAWING. IF
C          <IYVAL> < 0, THE LINE IS NOT VISIBLE, AND THE
C          Y-VALUE HAS TO BE APPROPRIATELY READJUSTED.
C
        IF (IYVAL.GE.0) GO TO 1
C
        IXMSAV= IXVAL
        IYMSAV= -IYVAL-1
        GO TO 100
C
    1   CALL G1VECT(IXVAL,IYVAL,1)
        GO TO 100
C
C          THE REMAINDER OF THE ROUTINE IS FOR SPECIAL FUNCTIONS.
C          THE FUNCTION TYPE IS DETERMINED BY <IXVAL> AS FOLLOWS:
C
C          IF <IXVAL>= -1, A POINT IS PLOTTED.
C          (A ZERO LENGTH VECTOR WITH ROUNDED ENDS IS DRAWN).
C
    2   IF (IXVAL.NE.-1) GO TO 3
C
        CALL G1VECT(IXMSAV,IYMSAV,3)
        ICODES(2)= LETTRP
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
        GO TO 100
C
    3   IF (LENPTH.EQ.0) GO TO 4
C
        ICODES(2)= LETTSS
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
C
C          IF <IXVAL>= -2, A HARDWARE CHARACTER IS DRAWN
C          AFTER THE POSITION HAS BEEN SET PREVIOUSLY.
C
    4   IF (IXVAL.NE.-2) GO TO 6
C
        CALL G1VECT(IXMSAV,IYMSAV,3)
        ICODES(2)= LPAREN
        INDEX= 5
        IF (IYVAL.NE.LPAREN.AND.IYVAL.NE.IRPARN.AND.IYVAL.NE.IBSLSH)
     &      GO TO 5
C
        ICODES(3)= IBSLSH
        INDEX= 6
    5   ICODES(INDEX-2)= IYVAL
        ICODES(INDEX-1)= IRPARN
        ICODES(INDEX)= LETTSC
        CALL G1BUFF(ICODES,INDEX)
        LENPTH= 0
        GO TO 100
C
C          IF <IXVAL>= -11, HARDWARE CHARACTER SIZE IS SET.
C
    6   IF (IXVAL.NE.-11) GO TO 8
C
        CHIGHT= IYVAL
        INDEX= 1
        IVCTOR= CHIGHT*1.714285
        IFROM= 1
        GO TO 58
C
    7   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSH
        CALL G1BUFF(ICODES,INDEX)
        GO TO 12
C
C          IF <IXVAL>= -12, HARDWARE CHARACTER ROTATION IS SET.
C
    8   IF (IXVAL.NE.-12) GO TO 10
C
        INDEX= 1
        IVCTOR= IYVAL
        IF (LNDSCP.EQ.0) IVCTOR= IVCTOR+90
C
        IFROM= 2
        GO TO 58
C
    9   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSR
        CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <IXVAL>= -13, HARDWARE CHAR. ITALIC IS SET.
C
   10   IF (IXVAL.NE.-13) GO TO 11
C
        ICODES(2)= IZERO+IYVAL
        ICODES(3)= IBLANK
        ICODES(4)= LETTSS
        ICODES(5)= LETTSC
        ICODES(6)= LETTSS
        CALL G1BUFF(ICODES,6)
        GO TO 100
C
C          IF <IXVAL>= -14, HARDWARE CHAR. OBLATENESS IS SET.
C
   11   IF (IXVAL.NE.-14) GO TO 14
C
        ZOBLAT= IYVAL/1000.0
   12   INDEX= 1
        IVCTOR= ZOBLAT*CHIGHT*1.428571
        IFROM= 3
        GO TO 58
C
   13   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSW
        CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <IXVAL>= -15, A HARDWARE BROKEN LINE IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   14   IF (IXVAL.NE.-15) GO TO 15
        GO TO 100
C
C          IF <IXVAL>= -16, HARDWARE INTENSITY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   15   IF (IXVAL.NE.-16) GO TO 16
        GO TO 100
C
C          IF <IXVAL>= -17, THE COLOUR NUMBER IS SET.
C
   16   IF (IXVAL.NE.-17) GO TO 24
C
        KOLOUR= IYVAL
        IFROM= 1
   17   KOL= IREDPO(KOLOUR)
        INDEX= 4
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 18
C
        ICODES(2)= IZERO+(KOL/100)
        GO TO 19
C
   18   ICODES(2)= IPOINT
        ICODES(3)= IZERO+KOL/10
        ICODES(4)= IZERO+MOD(KOL,10)
        INDEX= 6
   19   ICODES(INDEX-1)= IBLANK
        KOL= IGRNPO(KOLOUR)
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 20
C
        ICODES(INDEX)= IZERO+(KOL/100)
        GO TO 21
C
   20   ICODES(INDEX)= IPOINT
        ICODES(INDEX+1)= IZERO+KOL/10
        ICODES(INDEX+2)= IZERO+MOD(KOL,10)
        INDEX= INDEX+2
   21   ICODES(INDEX+1)= IBLANK
        KOL= IBLUPO(KOLOUR)
        INDEX= INDEX+4
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 22
C
        ICODES(INDEX-2)= IZERO+(KOL/100)
        GO TO 23
C
   22   ICODES(INDEX-2)= IPOINT
        ICODES(INDEX-1)= IZERO+KOL/10
        ICODES(INDEX)= IZERO+MOD(KOL,10)
        INDEX= INDEX+2
   23   ICODES(INDEX-1)= IBLANK
        ICODES(INDEX)= LETTRC
        CALL G1BUFF(ICODES,INDEX)
        GO TO (100,28,30,32), IFROM
C
C          IF <IXVAL>= -18, A POLYGON FILL IS DONE.
C
   24   IF (IXVAL.NE.-18) GO TO 33
        IF (INDSAV.GT.0) GO TO 25
C
        BOUND= .FALSE.
        GO TO 100
C
C          THIS PART CLOSES THE BOUNDARY IF IT IS OPEN.
C
   25   IF (IXSAVE(1).EQ.IXSAVE(INDSAV).AND.
     &      IYSAVE(1).EQ.IYSAVE(INDSAV)) GO TO 26
C
        CALL G1DISC(IXSAVE(1),IYSAVE(1))
   26   IF (IHTCHP(IHTYPE,2).NE.0) GO TO 27
C
C          THIS SECTION IS FOR SOLID AREA FILL
C          THIS PART DEFINES THE AREA BOUNDARY.
C
        CALL G1VECT(IXSAVE(1),IYSAVE(1),3)
C
        DO 200 INDOUT= 2,INDSAV
          CALL G1VECT(IXSAVE(INDOUT),IYSAVE(INDOUT),2)
  200   CONTINUE
C
C          THIS PART FILLS THE GIVEN AREA.
C
        ICODES(2)= LETTSF
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
        GO TO 32
C
   27   IF (IHTCHP(IHTYPE,1).LE.0) GO TO 32
C
C          THIS SECTION IS FOR CROSS-HATCHING.
C
        KOLSAV= KOLOUR
        IF (MOD(IHTCHP(IHTYPE,1),2).NE.1) GO TO 29
C
        IFROM= 2
        KOLOUR= IHTCHP(IHTCOL,1)
        GO TO 17
C
   28   CALL G1SHAD(1)
   29   IF (IHTCHP(IHTYPE,1)/2.NE.1) GO TO 31
C
        IFROM= 3
        KOLOUR= IHTCHP(IHTCOL,2)
        GO TO 17
C
   30   CALL G1SHAD(2)
   31   IFROM= 4
        KOLOUR= KOLSAV
        GO TO 17
C
   32   BOUND= .FALSE.
        GO TO 100
C
C          IF <IXVAL>= -19, DEVICE RESOLUTION IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   33   IF (IXVAL.NE.-19) GO TO 34
        GO TO 100
C
C          IF <IXVAL>= -20, A FILLED AREA BOUNDARY IS BEGUN.
C
   34   IF (IXVAL.NE.-20) GO TO 38
        IF (IYVAL.GT.0) IHTCHP(IHTYPE,2)= 0
C
        BOUND= .TRUE.
        INDSAV= 0
        GO TO 100
C
   35   IF (IYVAL.GE.0) GO TO 36
C
        IYVAL= -IYVAL-1
        IF (INDSAV.EQ.0) GO TO 37
C
        CALL G1DISC(IXVAL,IYVAL)
        GO TO 100
C
C          IF THE BOUNDARY STARTS WITH A JOIN,
C          THE CURRENT POSITION IS SAVED FIRST.
C
   36   IF (INDSAV.GT.0) GO TO 37
C
        INDSAV= 1
        IXSAVE(1)= IXMSAV
        IYSAVE(1)= IYMSAV
   37   IF (INDSAV+3.GE.ISAVSZ) GO TO 100
C
        INDSAV= INDSAV+1
        IXSAVE(INDSAV)= IXVAL
        IYSAVE(INDSAV)= IYVAL
        GO TO 100
C
C          IF <IXVAL>= -21, PLOT ORIENTATION IS SET.
C
   38   IF (IXVAL.NE.-21) GO TO 39
        IF (IYVAL.EQ.LNDSCP) GO TO 100
C
C          SWAP ALL RELEVANT VALUES
C
        LNDSCP= IYVAL
        DLMTMP= DLIMX
        DLIMX= DLIMY
        DLIMY= DLMTMP
        GO TO 100
C
C          IF <IXVAL>= -22, PEN VELOCITY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   39   IF (IXVAL.NE.-22) GO TO 40
        GO TO 100
C
C          FUNCTION CODES -23 TO -39 ARE NOT YET DEFINED,
C          AND ARE RESERVED FOR FUTURE NON-ARGUMENT FUNCTIONS.
C
   40   IF (IXVAL.LE.-40) GO TO 41
        GO TO 100
C
C          FUNCTION CODES -40 TO -80 ARE ARGUMENT FUNCTIONS.
C          -<IYVAL> GIVES THE LENGTH OF THE ARGUMENT STRING.
C          <NUMFUN> STORES THE FUNCTION CODE CURRENTLY ACTIVE.
C
   41   IF (IXVAL.LT.-80) GO TO 50
C
        NUMFUN= IXVAL
        LENARG= -IYVAL
        GO TO 100
C
C          THIS SECTION DEALS WITH ARGUMENT-FUNCTIONS.
C          NOTE THAT <NUMFUN> IS USED INSTEAD OF <IXVAL>.
C
   42   LENARG= LENARG-1
C
C          IF <NUMFUN>= -40, DATA IS PASSED ON TRANSPARENTLY.
C
        IF (NUMFUN.NE.-40) GO TO 43
C
        ICODES(1)= IXVAL
        ICODES(2)= IYVAL
        CALL G1BUFF(ICODES,2)
        ICODES(1)= IBLANK
        GO TO 100
C
C          IF <NUMFUN>= -41, A COLOUR TABLE ENTRY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   43   IF (NUMFUN.NE.-41) GO TO 44
        GO TO 100
C
C          IF <NUMFUN>= -42, HARDWARE LINE TYPE IS SET.
C
   44   IF (NUMFUN.NE.-42) GO TO 48
        IF (LENARG.EQ.0) GO TO 45
C
        ICODES(2)= LETTSB
        CALL G1BUFF(ICODES,2)
   45   INDEX= 1
        IVCTOR= IXVAL
        IFROM= 4
        GO TO 58
C
   46   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYVAL
        IFROM= 5
        GO TO 58
C
   47   CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <NUMFUN>= -43, BACKGROUND COLOUR IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   48   IF (NUMFUN.NE.-43) GO TO 49
        GO TO 100
C
C          IF <NUMFUN>= -44, SET HATCHING PARAMETERS.
C
   49   IF (NUMFUN.NE.-44) GO TO 100
C
        IHATPT= 11-LENARG
        IHTCHP(IHATPT,1)= IXVAL
        IHTCHP(IHATPT,2)= IYVAL
        GO TO 100
C
C          FOR FUNCTION CODES <= -81, THE LINE BUFFER IS
C          EMPTIED IMMEDIATELY, THEN THE FUNCTION IS DONE.
C
   50   IF (INDXB.GT.INITXB) CALL G1DVIO(3,ICODEB,INDXB-1)
C
        INDXB= INITXB
C
C          IF <IXVAL>= -81, AN ERASE WITH PROMPT IS DONE.
C          (THIS IS DONE IN THE SAME WAY AS THE NEXT ERASE).
C
        IF (IXVAL.NE.-81) GO TO 51
        GO TO 52
C
C          IF <IXVAL>= -82, AN ERASE WITHOUT PROMPT IS DONE.
C
   51   IF (IXVAL.NE.-82) GO TO 53
C
   52   ICODES(2)= LETTSP
        CALL G1DVIO(3,ICODES,2)
        IPGCNT= IPGCNT+1
        IPAGE(17)= IZERO+MOD(IPGCNT,10)
        ITEMP= IPGCNT/10
        IPAGE(16)= IZERO+MOD(ITEMP,10)
        IPAGE(15)= IZERO+ITEMP/10
        CALL G1DVIO(3,IPAGE,17)
        GO TO 100
C
C          IF <IXVAL>= -83, THE CURSOR IS DISPLAYED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   53   IF (IXVAL.NE.-83) GO TO 54
        GO TO 100
C
C          IF <IXVAL>= -84, THE LINE BUFFER IS CLEARED
C          WITHOUT ANY ADDITIONAL ACTION BEING TAKEN.
C
   54   IF (IXVAL.NE.-84) GO TO 55
        GO TO 100
C
C          IF <IXVAL>= -85, GRAPHICAL OUTPUT IS ENDED.
C
   55   IF (IXVAL.NE.-85) GO TO 56
C
        CALL G1DVIO(3,ITRAIL,10)
        ICODES(2)= LETTSX
        CALL G1DVIO(3,ICODES,2)
        CALL G1DVIO(2,IDUMMY,1)
        GO TO 100
C
C          IF <IXVAL>= -86, THE REQUIRED CHANNEL IS OPENED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   56   IF (IXVAL.NE.-86) GO TO 57
        GO TO 100
C
C          IF <IXVAL>= -87, THE REQUIRED CHANNEL IS CLOSED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   57   IF (IXVAL.NE.-87) GO TO 100
        GO TO 100
C
C          THIS IS AN INTERNAL SUBROUTINE TO CALCULATE THE PLOT
C          CODES FOR A VECTOR AND PUT THEM IN THE OUTPUT BUFFER.
C
   58   IF (IVCTOR.GE.0) GO TO 59
C
        INDEX= INDEX+1
        ICODES(INDEX)= MINUS
        IVCTOR= -IVCTOR
C
C          THE APPROPRIATE FIVE BYTES ARE CALCULATED (LOW -> HIGH
C          ORDER) AND PLACED IN THE BUFFER IN HIGH -> LOW ORDER.
C
   59   DO 300 I= 1,5
          IDIVSN= IVCTOR/10
          IBYTE(I)= IVCTOR-IDIVSN*10
          INDXBT= I
          IVCTOR= IDIVSN
          IF (IDIVSN.EQ.0) GO TO 60
  300   CONTINUE
C
   60   DO 400 I= 1,INDXBT
          IPOS1= INDEX+I
          IPOS2= INDXBT-I+1
          ICODES(IPOS1)= IBYTE(IPOS2)+IZERO
  400   CONTINUE
C
        INDEX= INDEX+INDXBT
C
C          CONTROL ALWAYS RETURNS TO THE ORIGINATING SECTION
C
        GO TO (7,9,13,46,47), IFROM
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE G1DISC(IXVAL,IYVAL)
C
C          ------------------------------------------------
C          ROUTINE NO. (1027)   VERSION (A8.1)    20:APR:89
C          ------------------------------------------------
C
C          THIS ROUTINE RECONNECTS DISCONTINUOUS BOUNDARIES
C          FOR THE AREA FILLING ROUTINE.
C
C
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1FLBF/ IXSAVE(2000),IYSAVE(2000),ISAVSZ,INDSAV
      COMMON /T1WNDO/ X1WND1,X2WND1,Y1WND1,Y2WND1
C
C
C          IF A DISCONTINUITY IS FOUND ON THE BOUNDARY, THE LINE
C          IS CONTINUED IF THE PREVIOUS POINT IS ON THE SAME LINE.
C
      IXW1= NINT(DRESX*(AMAX1(X1WND1,0.0)))
      IXW2= NINT(DRESX*(AMIN1(X2WND1,DLIMX)))
      IYW1= NINT(DRESY*(AMAX1(Y1WND1,0.0)))
      IYW2= NINT(DRESY*(AMIN1(Y2WND1,DLIMY)))
      IXLAST= IXSAVE(INDSAV)
      IYLAST= IYSAVE(INDSAV)
      IF (IXVAL.NE.IXW1.AND.IXVAL.NE.IXW2.AND.
     &    IYVAL.NE.IYW1.AND.IYVAL.NE.IYW2) GO TO 4
      IF (IXLAST.NE.IXW1.AND.IXLAST.NE.IXW2.AND.
     &    IYLAST.NE.IYW1.AND.IYLAST.NE.IYW2) GO TO 4
      IF (IXVAL.EQ.IXW1.AND.IXLAST.EQ.IXW1) GO TO 4
      IF (IXVAL.EQ.IXW2.AND.IXLAST.EQ.IXW2) GO TO 4
      IF (IYVAL.EQ.IYW1.AND.IYLAST.EQ.IYW1) GO TO 4
      IF (IYVAL.EQ.IYW2.AND.IYLAST.EQ.IYW2) GO TO 4
C
C          THE POINTS ARE ON DIFFERENT BOUNDARIES. IF THE
C          BOUNDARIES ARE ADJACENT, PUT IN THE CORNER POINT.
C
      IF (IXVAL.EQ.IXW1.OR.IXVAL.EQ.IXW2) GO TO 1
      IF (IYLAST.EQ.IYW1.OR.IYLAST.EQ.IYW2) GO TO 2
      IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXLAST
      IYSAVE(INDSAV)= IYVAL
      GO TO 4
C
    1 IF (IXLAST.EQ.IXW1.OR.IXLAST.EQ.IXW2) GO TO 3
      IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXVAL
      IYSAVE(INDSAV)= IYLAST
      GO TO 4
C
C          THE POINTS ARE ON OPPOSITE BOUNDARIES.
C          PUT IN THE TWO NEAREST CORNER POINTS.
C
    2 IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXW1
      IYSAVE(INDSAV)= IYLAST
      IF (IXLAST+IXVAL.GT.IXW1+IXW2) IXSAVE(INDSAV)= IXW2
      IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXSAVE(INDSAV-1)
      IYSAVE(INDSAV)= IYVAL
      GO TO 4
C
    3 IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXLAST
      IYSAVE(INDSAV)= IYW1
      IF (IYLAST+IYVAL.GT.IYW1+IYW2) IYSAVE(INDSAV)= IYW2
      IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXVAL
      IYSAVE(INDSAV)= IYSAVE(INDSAV-1)
    4 IF (INDSAV.GE.ISAVSZ) RETURN
C
      INDSAV= INDSAV+1
      IXSAVE(INDSAV)= IXVAL
      IYSAVE(INDSAV)= IYVAL
C
      RETURN
      END
      SUBROUTINE G1SHAD(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. (1009)   VERSION (A8.1)    28:JUL:88
C          ------------------------------------------------
C
C          THIS DOES PARALLEL-LINE SHADING WITHIN A POLYGONAL BOUNDARY
C          SPECIFIED BY A SET OF VERTEX CO-ORDINATES. (THE CLOSURE
C          BOUNDARY LINE IS DEFINED BY THE FIRST AND LAST VERTICES).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IPARAM> DETERMINS WHICH SET OF PARAMETERS IS USED.
C
C
      REAL    WORK(2000,3),STYLE(4)
      LOGICAL VISIBL,DRAW,BROKEN
C
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1FLBF/ IXSAVE(2000),IYSAVE(2000),ISAVSZ,INDSAV
      COMMON /T1HTCH/ IHTCHP(11,2)
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C          THE FOLLOWING IS THE INTERPOLATION FUNCTION:
C
      CROSSX(XR1,YR1,XR2,YR2)= (YR1*(XR2-XR1)/(YR1-YR2))+XR1
C
C          THE FOLLOWING ARE THE FORWARD AND BACKWARD ROTATIONS:
C
      ROTX(X,Y)= X*COSA+Y*SINA
      ROTY(X,Y)= Y*COSA-X*SINA
      REROTX(X,Y)= X*COSA-Y*SINA
      REROTY(X,Y)= Y*COSA+X*SINA
C
C
      RESOLU= 0.001*DRESX
      PITCH= IHTCHP(9,IPARAM)*RESOLU*0.01
      SHIFT= MOD(IHTCHP(7,IPARAM),IHTCHP(9,IPARAM))*RESOLU*0.01
      ISTLEN= 0
      STLEN= 0.0
C
      DO 100 LOAD= 1,4
        STYLE(LOAD)= IHTCHP(LOAD+2,IPARAM)*RESOLU
        STLEN= STLEN+STYLE(LOAD)
        ISTLEN= ISTLEN+IHTCHP(LOAD+2,IPARAM)
  100 CONTINUE
C
      BROKEN= .FALSE.
      PHASE= 0.0
      PATSFT= 0.0
      IF (ISTLEN.EQ.0) GO TO 1
C
      BROKEN= .TRUE.
      PHASE= MOD(IHTCHP(8,IPARAM),ISTLEN)*RESOLU
      PATSFT= MOD(IHTCHP(10,IPARAM),ISTLEN)*RESOLU
    1 ANGL= IHTCHP(1,IPARAM)*0.00001
      COSA= COS(ANGL)
      SINA= SIN(ANGL)
C
C          ALL THE VERTEX CO-ORDINATES ARE ROTATIONALLY
C          TRANSFORMED ABOUT THE ORIGIN.
C
      DO 200 ISIDE= 1,INDSAV
        WORK(ISIDE,1)= ROTX(FLOAT(IXSAVE(ISIDE)),FLOAT(IYSAVE(ISIDE)))
        WORK(ISIDE,2)= ROTY(FLOAT(IXSAVE(ISIDE)),FLOAT(IYSAVE(ISIDE)))
        IF (ISIDE.NE.1) GO TO 2
C
        YMAX= WORK(ISIDE,2)
        YMIN= YMAX
    2   IF (WORK(ISIDE,2).GT.YMAX) YMAX= WORK(ISIDE,2)
        IF (WORK(ISIDE,2).LT.YMIN) YMIN= WORK(ISIDE,2)
  200 CONTINUE
C
C          LOOP-300 DOES EACH SHADE LINE IN TURN.
C          LOOP-400 SEARCHES EVERY BOUNDARY SIDE FOR
C          A CROSSOVER POINT, AND WHERE ONE EXISTS,
C          LOOP-500 SORTS IT DOWN THE ORDERED LIST OF
C          CROSSOVER-POINT YR-VALUES BY REPEATED SWAPS.
C
C          IF REL. X-POSITIONS HAVE THE SAME SIGN, THEN NO
C          CROSSOVER POINT EXISTS ON THIS BOUNDARY LINE.
C
      YMAX1= YMAX-0.000001
      LSTLIN= YMAX1/PITCH
      IF (YMAX1.LT.0.0) LSTLIN= LSTLIN-1
C
      IFSTLN= YMIN/PITCH
      IF (YMIN.LT.0.0) IFSTLN= IFSTLN-1
C
      DO 300 LINE= IFSTLN,LSTLIN
        YR= PITCH*LINE+SHIFT
        NCROSS= 0
C
        DO 400 ISIDE= 1,INDSAV-1
          IEND1= ISIDE
          IEND2= ISIDE+1
          YR1= WORK(IEND1,2)-YR
          YR2= WORK(IEND2,2)-YR
          IF (ABS(YR1).LT.RMINI) GO TO 400
          IF (YR1*YR2.GT.0.0) GO TO 400
C
C          FIND INTERSECTION POINT.
C
          XR1= WORK(IEND1,1)
          XR2= WORK(IEND2,1)
          XR= CROSSX(XR1,YR1,XR2,YR2)
          LIMIT= NCROSS
          NCROSS= NCROSS+1
          WORK(NCROSS,3)= XR
          IF (NCROSS.EQ.1) GO TO 400
C
C          SORT THE INTERSECTION POINTS.
C
          DO 500 ISORT= 1,LIMIT
            LEVEL= NCROSS-(ISORT-1)
            VALUHI= WORK(LEVEL  ,3)
            VALULO= WORK(LEVEL-1,3)
            IF (VALUHI.GE.VALULO) GO TO 400
C
            WORK(LEVEL  ,3)= VALULO
            WORK(LEVEL-1,3)= VALUHI
  500     CONTINUE
  400   CONTINUE
C
C          IF THERE ARE NO CROSSOVER POINTS, THE NEXT SHADE LINE
C          IS BEGUN; OTHERWISE, THE PRESENT LINE RUNS THROUGH ALL
C          THE CROSSOVER POINTS (IN ORDER), ALTERNATING IN VISIBILITY.
C          IF THE DISTANCE BETWEEN TWO CONSECUTIVE CROSSOVER POINTS
C          IS LESS THAN THE SET RESOLUTION, BOTH ARE IGNORED.
C
        IF (NCROSS.LE.0) GO TO 300
C
        VISIBL= .FALSE.
        IDRAW= 0
        XPOS= LINE*PHASE+PATSFT
    3   IDRAW= IDRAW+1
        IF (IDRAW.GT.NCROSS) GO TO 300
C
        XR= WORK(IDRAW,3)
        IF (IDRAW.EQ.NCROSS) GO TO 4
C
        XRNEXT= WORK(IDRAW+1,3)
        DIFRAC= (XRNEXT-XR)/RESOLU
        IF (DIFRAC.GT.1.0) GO TO 4
C
        IDRAW= IDRAW+1
        GO TO 3
C
    4   IY= REROTY(XR,YR)+0.5
        IF (VISIBL) GO TO 5
C
        XSTART= XR
        IX= REROTX(XR,YR)+0.5
        CALL G1VECT(IX,IY,3)
        GO TO 13
C
    5   IF (BROKEN) GO TO 6
C
        IX= REROTX(XR,YR)+0.5
        CALL G1VECT(IX,IY,1)
        GO TO 13
C
C          THIS SECTION DEALS WITH BROKEN LINES.
C
    6   XEND= XR
        XR= -XPOS
    7   IF (XR.LE.XSTART) GO TO 8
C
        XR= XR-STLEN
        GO TO 7
C
    8   DRAW= .TRUE.
        ISTPTR= 1
    9   XR= XR+STYLE(ISTPTR)
        IF (XR.GT.XSTART) GO TO 10
C
        ISTPTR= ISTPTR+1
        IF (ISTPTR.EQ.5) ISTPTR= 1
C
        DRAW= .NOT.DRAW
        GO TO 9
C
   10   IX= REROTX(XSTART,YR)+0.5
        IY= REROTY(XSTART,YR)+0.5
        CALL G1VECT(IX,IY,3)
        IF (XR.GT.XEND) GO TO 12
C
   11   IX= REROTX(XR,YR)+0.5
        IY= REROTY(XR,YR)+0.5
        IF (.NOT.DRAW) CALL G1VECT(IX,IY,3)
        IF (DRAW)      CALL G1VECT(IX,IY,1)
C
        ISTPTR= ISTPTR+1
        IF (ISTPTR.EQ.5) ISTPTR= 1
C
        DRAW= .NOT.DRAW
        XR= XR+STYLE(ISTPTR)
        IF (XR.LE.XEND) GO TO 11
   12   IF (.NOT.DRAW) GO TO 13
C
        IX= REROTX(XEND,YR)+0.5
        IY= REROTY(XEND,YR)+0.5
        CALL G1VECT(IX,IY,1)
   13   VISIBL= .NOT.VISIBL
        GO TO 3
C
  300 CONTINUE
C
      CALL G1VECT(IXSAVE(1),IYSAVE(1),3)
C
      RETURN
      END
      SUBROUTINE G1VECT(IXVAL,IYVAL,ITYPE)
C
C          ------------------------------------------------
C          ROUTINE NO. (1008)   VERSION (A8.1AP)  21:APR:89
C          ------------------------------------------------
C
C          THIS ROUTINE PROVIDES THE VECTOR DRAWING CAPABILITIES
C          OF A DEVICE.
C          (THIS VERSION IS FOR ADOBE POSTSCRIPT)
C
C          THE VALUES OF THE ARGUMENT ARE AS FOLLOWS:
C
C          = 1, DRAW VECTOR FROM (IXMSAV,IYMSAV) TO (IXVAL,IYVAL),
C          = 2, DRAW TO (IXVAL,IYVAL)
C          = 3, MOVE TO (IXVAL,IYVAL) IF NOT ALREADY THERE.
C
C
      INTEGER ICODES(20),IBYTE(5)
      LOGICAL MOVE,DONE,REL
C
      COMMON /T1APAA/ IXPLOT,IYPLOT,IXMSAV,IYMSAV,LENPTH,MAXPTH
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1LAND/ LNDSCP
C
      DATA IBLANK / 32/, MINUS  / 45/, IZERO  / 48/,
     &     LETTRL / 76/, LETTSL /108/, LETTSM /109/,
     &     LETTSN /110/, LETTSS /115/
C
      MOVE= .FALSE.
      DONE= .TRUE.
      IXPOS= IXVAL
      IYPOS= IYVAL
      IF (LENPTH+2.LE.MAXPTH) GO TO 1
C
      ICODES(1)= IBLANK
      ICODES(2)= LETTSS
      CALL G1BUFF(ICODES,2)
      LENPTH= 0
    1 INDEX= 0
      IF (ITYPE.EQ.2) GO TO 4
      IF (ITYPE.EQ.3) GO TO 2
      IF (IXPLOT.EQ.IXMSAV.AND.IYPLOT.EQ.IYMSAV.AND.LENPTH.GT.0) GO TO 3
C
      MOVE= .TRUE.
      DONE= .FALSE.
      IXPOS= IXMSAV
      IYPOS= IYMSAV
      GO TO 4
C
    2 MOVE= .TRUE.
    3 IF (IXPLOT.EQ.IXPOS.AND.IYPLOT.EQ.IYPOS) RETURN
C
    4 IF (LNDSCP.NE.0) GO TO 5
C
      IXPOST= INT(DLIMY*DRESY)-IYPOS
      IYPOST= IXPOS
      IDX= IYPLOT-IYPOS
      IDY= IXPOS-IXPLOT
      GO TO 6
C
    5 IXPOST= IXPOS
      IYPOST= IYPOS
      IDX= IXPOS-IXPLOT
      IDY= IYPOS-IYPLOT
C
C          CHOOSE ABSOLUTE OR RELATIVE COORDINATES.
C
    6 REL= .TRUE.
      IF (LENPTH.EQ.0.OR.IABS(IDX).GT.IXPLOT.OR.IABS(IDY).GT.IYPLOT
     &    .OR.MOVE) REL= .FALSE.
      IF (.NOT.MOVE) GO TO 8
      IF (LENPTH.EQ.0) GO TO 7
C
      INDEX= INDEX+2
      ICODES(INDEX-1)= IBLANK
      ICODES(INDEX)= LETTSS
    7 INDEX= INDEX+2
      ICODES(INDEX-1)= IBLANK
      ICODES(INDEX)= LETTSN
      LENPTH= 0
    8 INDEX= INDEX+1
      ICODES(INDEX)= IBLANK
      IVCTOR= IXPOST
      IF (REL) IVCTOR= IDX
C
      IFROM= 1
      GO TO 11
C
    9 INDEX= INDEX+1
      ICODES(INDEX)= IBLANK
      IVCTOR= IYPOST
      IF (REL) IVCTOR= IDY
C
      IFROM= 2
      GO TO 11
C
   10 INDEX= INDEX+2
      ICODES(INDEX-1)= IBLANK
      IF (MOVE)                   ICODES(INDEX)= LETTSM
      IF (.NOT.MOVE.AND.REL)      ICODES(INDEX)= LETTRL
      IF (.NOT.MOVE.AND..NOT.REL) ICODES(INDEX)= LETTSL
C
      CALL G1BUFF(ICODES,INDEX)
      IXPLOT= IXPOS
      IYPLOT= IYPOS
      IXMSAV= IXPLOT
      IYMSAV= IYPLOT
      LENPTH= LENPTH+1
      IF (DONE) RETURN
C
      MOVE= .FALSE.
      DONE= .TRUE.
      IXPOS= IXVAL
      IYPOS= IYVAL
      INDEX= 0
      GO TO 3
C
C          THIS IS AN INTERNAL SUBROUTINE TO CALCULATE THE PLOT
C          CODES FOR A VECTOR AND PUT THEM IN THE OUTPUT BUFFER.
C
   11 IF (IVCTOR.GE.0) GO TO 12
C
      INDEX= INDEX+1
      ICODES(INDEX)= MINUS
      IVCTOR= -IVCTOR
C
C          THE APPROPRIATE FIVE BYTES ARE CALCULATED (LOW -> HIGH
C          ORDER) AND PLACED IN THE BUFFER IN HIGH -> LOW ORDER.
C
   12 DO 100 I= 1,5
        IDIVSN= IVCTOR/10
        IBYTE(I)= IVCTOR-IDIVSN*10
        INDXBT= I
        IVCTOR= IDIVSN
        IF (IDIVSN.EQ.0) GO TO 13
  100 CONTINUE
C
   13 DO 200 I= 1,INDXBT
        IPOS1= INDEX+I
        IPOS2= INDXBT-I+1
        ICODES(IPOS1)= IBYTE(IPOS2)+IZERO
  200 CONTINUE
C
      INDEX= INDEX+INDXBT
C
C          CONTROL ALWAYS RETURNS TO THE ORIGINATING SECTION
C
      GO TO (9,10), IFROM
      END
      SUBROUTINE G1BUFF(IDATA,NCHRS)
C
C          ------------------------------------------------
C          ROUTINE NO. (1010)   VERSION (A8.1A)   21:JUN:88
C          ------------------------------------------------
C
C          THIS BUFFERS UP THE DATA.
C          (THIS IS THE STANDARD VERSION).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IDATA>  IS THE CHARACTER I/O STRING.
C          <NCHRS>  IS THE NUMBER OF CHARS. IN THE STRING.
C
C
      INTEGER IDATA(NCHRS)
C
      COMMON /T1IOBF/ ICODEB(512),ISIZEB,INDXB,INITXB
C
C
      IF (NCHRS.LE.0) RETURN
      IF (INDXB+NCHRS-1.LE.ISIZEB) GO TO 1
      CALL G1DVIO(3,ICODEB,INDXB-1)
      INDXB= INITXB
C
C          THIS SECTION DOES OUTPUT BUFFERING.
C
    1 DO 100 IFILL= 1,NCHRS
        ICODEB(INDXB)= IDATA(IFILL)
        INDXB= INDXB+1
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE G1DVIO(ICOMND,IDATA,NCHRS)
C
C          ------------------------------------------------
C          ROUTINE NO. (1005)   VERSION (A8.1AP)  15:NOV:90
C          ------------------------------------------------
C
C          THIS INTERFACES DEVICE I/O WITH THE SYSTEM.
C          (THIS VERSION IS FOR ADOBE POSTSCRIPT).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICOMND> SETS THE I/O OPERATION:
C                   = 1, THE I/O CHANNELS ARE OPENED,
C                   = 2, THE I/O CHANNELS ARE CLOSED,
C                   = 3, THE OUTPUT BUFFER IS WRITTEN.
C          <IDATA>  IS THE CHARACTER I/O STRING.
C          <NCHRS>  IS THE NUMBER OF CHARS. IN THE STRING.
C
      INTEGER   IDATA(NCHRS)
      LOGICAL   EXISTS
      CHARACTER PRBUFF*512
      CHARACTER NAMAPS*128,CHCMND*128
C
      COMMON /T1APSL/ LENAPS
      COMMON /T1APSN/ NAMAPS
      COMMON /T1CHAD/ KDISPI,KDISPO
      COMMON /T1CMLC/ CHCMND(10)
      COMMON /T1CMLN/ NMFILE(32),LNFILE,ICMND(35,2)
C
C
      IF (ICOMND.NE.1) GO TO 4
C
      KDISPO= 20
      IF (ICMND(26,1).EQ.1) GO TO 2
C
      INQUIRE(FILE=NAMAPS(1:LENAPS),EXIST=EXISTS)
      IF (.NOT.EXISTS) GO TO 1
C
      OPEN(UNIT=KDISPO,FILE=NAMAPS(1:LENAPS),STATUS='OLD')
      CLOSE(UNIT=KDISPO,STATUS='DELETE')
    1 OPEN(UNIT=KDISPO,FILE=NAMAPS(1:LENAPS),STATUS='NEW')
      RETURN
C
    2 INQUIRE(FILE=CHCMND(1),EXIST=EXISTS)
      IF (.NOT.EXISTS) GO TO 3
C
      OPEN(UNIT=KDISPO,FILE=CHCMND(1),STATUS='OLD')
      CLOSE(UNIT=KDISPO,STATUS='DELETE')
    3 OPEN(UNIT=KDISPO,FILE=CHCMND(1),STATUS='NEW')
      RETURN
C
    4 IF (ICOMND.NE.2) GO TO 5
C
      CLOSE(UNIT=KDISPO)
      RETURN
C
    5 IF (ICOMND.NE.3) RETURN
C
C          THIS SECTION DOES DEVICE OUTPUT
C
      DO 100 IOUT= 1,NCHRS
        CALL G4BACO(IDATA(IOUT),KCHAR)
        PRBUFF(IOUT:IOUT)= CHAR(KCHAR)
  100 CONTINUE
C
      WRITE(KDISPO,201) PRBUFF(1:NCHRS)
  201 FORMAT(A)
      RETURN
      END
      SUBROUTINE G1ERMS
C
C          ------------------------------------------------
C          ROUTINE NO. (1006)   VERSION (A8.5)    14:NOV:90
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS PRINTS OUT THE APPROPRIATE POST-PROCESSOR
C          ERROR MESSAGE AFTER THE OCCURRENCE OF A FAULT.
C
C
      LOGICAL   ERRON
      CHARACTER MESSAG(8)*36
C
      COMMON /T3CHAM/ KMESGI,KMESGO
      COMMON /T3ERRS/ ERRON,NUMERR
C
      SAVE MESSAG
      DATA MESSAG /'ATTEMPT TO SET LOG. MAP THROUGH ZERO',
     &             'ATTEMPT TO MOVE OUTSIDE LOG. SPACE  ',
     &             'WORK SPACE COMPLETELY FULL          ',
     &             'CHARACTER-DEFINITION SPACE FULL     ',
     &             'UNABLE TO OPEN CHARACTER FONT FILE  ',
     &             'UNABLE TO READ CHARACTER FONT FILE  ',
     &             'DEVICE I/O SUSPENDED                ',
     &             'ERROR READING COMMAND LINE          '/
C
C
      MSGNO= NUMERR-1000
      WRITE(KMESGO,201) '*** DEVICE-OUTPUT ERROR: ',
     &                   MESSAG(MSGNO),' ***'
  201 FORMAT(/,5X,3A)
C
      RETURN
      END
      SUBROUTINE G4BACO(NCHARI,NCHARO)
C
C          ------------------------------------------------
C          ROUTINE NO. (4001)   VERSION (A7.1D)   21:NOV:85
C          ------------------------------------------------
C
C          THIS TRANSLATES THE GIVEN CHAR. NO. <NCHARI>
C          FROM THE ASCII CHARACTER CODING INTO THE
C          EQUIVALENT CHAR. NO. <NCHARO> IN MACHINE CODE.
C
C          THIS VERSION IS FOR ASCII-CODED MACHINES.
C
C
      NCHARO= MOD(NCHARI,128)
      RETURN
      END
      SUBROUTINE G4COCO(NCHARI,NCHARO)
C
C          ------------------------------------------------
C          ROUTINE NO. (4002)   VERSION (A7.1D)   21:NOV:85
C          ------------------------------------------------
C
C          THIS TRANSLATES THE GIVEN CHAR. NO. <NCHARI>
C          FROM THE MACHINE CHARACTER CODING INTO THE
C          EQUIVALENT CHAR. NO. <NCHARO> IN ASCII CODE.
C
C          THIS VERSION IS FOR ASCII-CODED MACHINES.
C
C
      NCHARO= NCHARI
C
      RETURN
      END
      SUBROUTINE G3SYSI(ICOMND)
C
C          ------------------------------------------------
C          ROUTINE NO. (3006)   VERSION (A8.3)    05:DEC:90
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS INTERFACES GENERAL MESSAGE I/O WITH THE SYSTEM
C          AND INITIALISES MACHINE DEPENDENT VARIABLES.
C          (THIS VERSION IS FOR THE SUN WORKSTATIONS).
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <ICOMND> SETS THE I/O OPERATION:
C                   = 1, THE I/O CHANNELS ARE OPENED,
C                   = 2, THE I/O CHANNELS ARE CLOSED.
C
C
      CHARACTER APSNAM*12,CGMNAM*12,DECNAM*11,GRANAM*9,TRANAM*12,
     &          DEFNAM*11,SCRNAM*11,SPAC*1
      CHARACTER NAMAPS*128,NAMCGM*128,NAMDEC*128,NAMGRA*128,NAMTRA*128,
     &          SPACE*1
C
      COMMON /T1APSL/ LENAPS
      COMMON /T1APSN/ NAMAPS
      COMMON /T1CGML/ LENCGM
      COMMON /T1CGMN/ NAMCGM
      COMMON /T1DECL/ LENDEC
      COMMON /T1DECN/ NAMDEC
      COMMON /T1GRAL/ LENGRA
      COMMON /T1GRAN/ NAMGRA
      COMMON /T1TRAL/ LENTRA
      COMMON /T1TRAN/ NAMTRA
      COMMON /T3CHAM/ KMESGI,KMESGO
      COMMON /T3CPAK/ NGCHI
      COMMON /T3CSPA/ SPACE
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3MACR/ NMCHR
      COMMON /T3NBYR/ NBYTR
      COMMON /T3SPAC/ ISPACE(1)
C
      DATA APSNAM /'POSTSCPT.LIS'/, LNAPS /12/,
     &     CGMNAM /'CGMETAFL.LIS'/, LNCGM /12/,
     &     DECNAM /'DECODED.TXT'/,  LNDEC /11/,
     &     GRANAM /'GRAPH.LIS'/,    LNGRA /9/,
     &     TRANAM /'TRANGRID.TGD'/, LNTRA /12/,
     &     DEFNAM /'DEFAULT.GRD'/,  LNDEF /11/,
     &     SCRNAM /'SCRATCH.GRD'/,  LNSCR /11/,
     &     SPAC /' '/
C
C
      IF (ICOMND.GT.1) RETURN
C
      LENAPS= LNAPS
      NAMAPS= APSNAM
      LENCGM= LNCGM
      NAMCGM= CGMNAM
      LENDEC= LNDEC
      NAMDEC= DECNAM
      LENGRA= LNGRA
      NAMGRA= GRANAM
      LENTRA= LNTRA
      NAMTRA= TRANAM
      KMESGI= 5
      KMESGO= 6
      NGCHI= 4
      SPACE= SPAC
      LENDEF= LNDEF
      LENSCR= LNSCR
      NMCHI= 4
      NBITMC= 8
      IMAXI= 2147483647
      RMAXI= 1.0E+37
      RMINI= 1.0E-37
      LIMIT= NMCHI*32
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ICHAR(SPACE)
        IF (ISET.LE.LENDEF) NCHAR= ICHAR(DEFNAM(ISET:ISET))
C
        CALL G4PUTK(NAMDEF,ISET,NBITMC,NMCHI,NCHAR)
        NCHAR= ICHAR(SPACE)
        IF (ISET.LE.LENSCR) NCHAR= ICHAR(SCRNAM(ISET:ISET))
C
        CALL G4PUTK(NAMSCR,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      NMCHR= 4
      NBYTR= 4
C
      DO 200 ISET= 1,NMCHI
        CALL G4PUTK(ISPACE,ISET,NBITMC,NMCHI,ICHAR(SPACE))
  200 CONTINUE
C
      RETURN
      END
      SUBROUTINE G1CHIO(ICOMND,NOCHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1035)   VERSION (A8.1)    05:OCT:90
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS OPENS, READS AND CLOSES THE HERSHEY CHARACTER FILES.
C          (THIS VERSION IS FOR SUN COMPUTERS).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICOMND> SETS THE I/O OPERATION:
C                   = 1, THE HERSHEY CHARACTER FONT IS OPENED,
C                   = 2, A HERSHEY CHARACTER DEFINITION IS READ,
C                   = 3, THE HERSHEY CHARACTER FONT IS CLOSED.
C          <NOCHAR> CHARACTER NUMBER TO BE READ.
C
C
      REAL      XTEMP(200),YTEMP(200)
      LOGICAL   OPENED
      LOGICAL   ERRON
      CHARACTER FNTNAM*28
C
      COMMON /T1CFCH/ KFNTCH
      COMMON /T1CFIN/ INDLEN(2,256),WIDCHR(256)
      COMMON /T1CFON/ KFONT1
      COMMON /T1SPEC/ XSPEC(4600),YSPEC(4600),ICHPTR(128),NEXTPT,NSTORE
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA FNTNAM /'/u/local/lib/GHOST80FONT'/,
C
C          <IRECL> IS THE LENGTH OF THE DATA RECORD. THE UNITS
C          WHICH THE LENGTH IS SPECIFIED ARE MACHINE DEPENDANT.
C
C          THE UNITS ARE '4-CHARACTER WORDS' FOR THE FOLLOWING COMPUTERS:
C          VAX, MISTRAL, SILICON GRAPHICS
C          (SET IRECL TO 60).
C
C          THE UNITS ARE '2-CHARACTER WORDS' FOR THE FOLLOWING COMPUTERS:
C          PRIME (F77 AND FTN77 COMPILERS)
C          (SET IRECL TO 120).
C
C          THE UNITS ARE 'CHARACTERS' FOR THE FOLLOWING COMPUTERS:
C          APOLLO, GEC, IBMPC, IBM WS, SUN, WHITECHAPEL
C          (SET IRECL TO 240).
C
     &     IRECL /240/
C
C
      IF (ICOMND.GT.3) RETURN
C
      KFNTCH= 96
C
C           THIS SECTION OPENS A NEW CHARACTER FONT FILE, CLOSING ANY
C           PREVIOUSLY OPENED ONE. THE HEADER INFORMATION IS THEN READ,
C           AND THE CHARACTER POINTERS ARE INITIALISED.
C
      IF (ICOMND.NE.1) GO TO 1
C
      INQUIRE(KFNTCH,OPENED= OPENED)
      IF (OPENED) CLOSE(KFNTCH)
C
C           AN INTERNAL WRITE IS USED TO ADD THE FONT
C           NUMBER ONTO THE FILENAME.
C
      WRITE(FNTNAM(27:28),'(I2)') KFONT1
      OPEN(KFNTCH,FILE= FNTNAM,ACCESS= 'DIRECT',RECL= IRECL,
     &     STATUS= 'OLD',ERR= 901)
      IND= 1
C
      DO 100 IREC= 1,16
        READ(KFNTCH,REC= IREC,ERR= 902)
     &      ((INDLEN(J,K),J= 1,2),WIDCHR(K),K= IND,IND+15)
        IND= IND+16
  100 CONTINUE
C
      DO 200 ICLEAR= 1,128
        ICHPTR(ICLEAR)= 0
  200 CONTINUE
C
      NSTORE= 0
      NEXTPT= 101
C
      RETURN
C
C           THIS SECTION READS CHARACTER 'NOCHAR' INTO 'XSPEC' AND
C           'YSPEC' UPDATING THE APPROPRIATE POINTER IN 'ICHPTR'.
C
    1 IF (ICOMND.NE.2) GO TO 2
C
      LENGTH= INDLEN(2,NOCHAR)
      IF (LENGTH.EQ.0) RETURN
C
      IND= 1
      NRECS= (LENGTH-1)/30+1
C
      DO 300 IREC= INDLEN(1,NOCHAR),INDLEN(1,NOCHAR)+NRECS-1
        READ(KFNTCH,REC= IREC,ERR= 902)
     &      (XTEMP(I),YTEMP(I),I= IND,IND+29)
        IND= IND+30
  300 CONTINUE
C
      INXTPT= NEXTPT
      IF (NOCHAR.GT.128) INXTPT= 1
C
      DO 400 ILOAD= 1,LENGTH
        XSPEC(INXTPT)= XTEMP(ILOAD)
        YSPEC(INXTPT)= YTEMP(ILOAD)
        INXTPT= INXTPT+1
  400 CONTINUE
C
      IF (NOCHAR.GT.128) RETURN
C
      ICHPTR(NOCHAR)= NEXTPT
      NEXTPT= INXTPT
      RETURN
C
    2 INQUIRE(KFNTCH,OPENED= OPENED)
      IF (.NOT.OPENED) RETURN
C
      CLOSE(KFNTCH)
      RETURN
C
C           THIS SECTION IS ENTERED IF THERE WAS AN ERROR.
C
  901 NUMERR= 1005
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
      RETURN
C
  902 NUMERR= 1006
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
      RETURN
C
      END
      SUBROUTINE G1CMLN
C
C          ------------------------------------------------
C          ROUTINE NO. (1029)   VERSION (A8.1A)   29:APR:91
C          ------------------------------------------------
C
C          THIS READS PARAMETERS OFF THE COMMAND LINE AND STORES
C          THEM, TOGETHER WITH ANY ASSOCIATED DATA, IN THE
C          COMMON BLOCK T1CMLN.
C          (THIS IS THE BERKELEY UNIX VERSION).
C
C          THE COMMAND LINE FORMAT IS AS FOLLOWS:
C
C          COMMAND [ -string[ value]][ -string[ value]]...[GRIDfile name]
C
C
C          THE FOLLOWING STRINGS AND VALUES HAVE BEEN ALLOCATED:
C
C           1) int            INTERACTIVE MODE
C           2) glan           USE LANDSCAPE MODE
C           3) gpor           USE PORTRAIT MODE
C           4) ght  <int>     HEIGHT OF GRAPHICS WINDOW
C           5) gwid <int>     WIDTH OF WINDOW
C           6) gxor <int>     X COORDINATE OF WINDOW ORIGIN
C           7) gyor <int>     Y COORDINATE OF WINDOW ORIGIN
C          25) grfl <string>  NAME OF GRIDFILE
C          26) gfil <string>  NAME OF OUTPUT FILE            (CHCMND(1))
C          27) gtit <string>  TITLE OF WINDOW                (CHCMND(2))
C
C
      INTEGER   ICMFLG(35)
      LOGICAL   ERRON
      CHARACTER PARAM(71)*128,STR(35)*4
      CHARACTER CHCMND*128
C
      COMMON /T1CMLC/ CHCMND(10)
      COMMON /T1CMLN/ NMFILE(32),LNFILE,ICMND(35,2)
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MACH/ NMCHI,NBITMC
C
      DATA IENDCH /33/
      DATA ICMFLG /0,0,0,1,1,
     &             1,1,0,0,0,
     &             0,0,0,0,0,
     &             0,0,0,0,0,
     &             0,0,0,0,1,
     &             1,1,0,0,0,
     &             0,0,0,0,0/
      DATA STR /'int ','glan','gpor','ght ','gwid',
     &          'gxor','gyor','    ','    ','    ',
     &          '    ','    ','    ','    ','    ',
     &          '    ','    ','    ','    ','    ',
     &          '    ','    ','    ','    ','grfl',
     &          'gfil','gtit','    ','    ','    ',
     &          '    ','    ','    ','    ','    '/
C
C          RESET THE COMMON BLOCK ARRAYS.
C
      DO 100 ISET= 1,32
        NMFILE(ISET)= NAMDEF(ISET)
  100 CONTINUE
C
      LNFILE= LENDEF+1
      CALL G4PUTK(NMFILE,LNFILE,NBITMC,NMCHI,IENDCH)
C
      DO 200 ISET= 1,35
        ICMND(ISET,1)= 0
        ICMND(ISET,2)= 0
  200 CONTINUE
C
C          THE NUMBER OF ARGUMENTS INCLUDING THE DATA ARE FIRST
C          FETCHED. THE ARGUMENTS ARE THEN READ.
C
      CALL GETARG(0,CHCMND(10))
      NARGS= IARGC()
      IF (NARGS.EQ.0) RETURN
      IF (NARGS.GT.71) NARGS= 71
C
      DO 300 ILOAD= 1,NARGS
        CALL GETARG(ILOAD,PARAM(ILOAD))
  300 CONTINUE
C
C          THE LINE IS THEN PARSED.
C
      KPARAM= 0
    1 KPARAM= KPARAM+1
      IF (KPARAM.GT.NARGS) RETURN
      IF (PARAM(KPARAM)(1:1).NE.'-') GO TO 7
C
      DO 400 ICH= 1,35
        IF (PARAM(KPARAM)(2:5).EQ.STR(ICH)) GO TO 2
C
  400 CONTINUE
C
      GO TO 1
C
    2 ICMND(ICH,1)= 1
      IF (ICH.EQ.1) CALL G4PUTK(NMFILE,1,NBITMC,NMCHI,IENDCH)
      IF (ICMFLG(ICH).EQ.0) GO TO 1
C
      KPARAM= KPARAM+1
      IF (KPARAM.GT.NARGS) RETURN
      IF (PARAM(KPARAM)(1:1).EQ.'-') GO TO 901
      IF (ICH.EQ.25) GO TO 6
      IF (ICH.GE.26.AND.ICH.LE.35) GO TO 5
C
C          DECODE AN INTEGER ARGUMENT.
C
      KCH= 1
      NUM= 0
    3 ICH2= ICHAR(PARAM(KPARAM)(KCH:KCH))
      IF (ICH2.LT.48.OR.ICH2.GT.57) GO TO 4
C
      NUM= NUM*10+ICH2-48
      KCH= KCH+1
      GO TO 3
C
    4 ICMND(ICH,2)= NUM
      GO TO 1
C
C          DECODE A STRING ARGUMENT.
C
    5 CHCMND(ICH-25)= PARAM(KPARAM)
C
      DO 500 ISCAN= 128,1,-1
        IF (PARAM(KPARAM)(ISCAN:ISCAN).NE.' ') GO TO 6
  500 CONTINUE
C
    6 ICMND(ICH,2)= ISCAN
      GO TO 1
C
C          FILENAME FOUND.
C
    7 LNFILE= INDEX(PARAM(KPARAM),' ')
C
      DO 600 ILOAD= 1,LNFILE-1
        ICH= ICHAR(PARAM(KPARAM)(ILOAD:ILOAD))
        CALL G4PUTK(NMFILE,ILOAD,NBITMC,NMCHI,ICH)
  600 CONTINUE
C
      CALL G4PUTK(NMFILE,LNFILE,NBITMC,NMCHI,IENDCH)
      GO TO 1
C
  901 NUMERR= 1008
      CALL G1ERMS
      STOP
      END

