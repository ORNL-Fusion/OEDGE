      SUBROUTINE G0MAPS(XRECT1,XRECT2,YRECT1,YRECT2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  25)   VERSION (A8.8)    22:JAN:87
C          ------------------------------------------------
C
C          THIS SETS THE ACTUAL MAPPING RECTANGLE USED.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XRECT1> IS THE X-AXIS LEFT LIMIT,
C          <XRECT2> IS THE X-AXIS RIGHT LIMIT,
C          <YRECT1> IS THE Y-AXIS LOWER LIMIT,
C          <YRECT2> IS THE Y-AXIS UPPER LIMIT.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0CSIZ/ CSIZE,MRKSIZ
      COMMON /T0CSLO/ SLOPE,MRKSLP
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPD/ X1MAPD,X2MAPD,Y1MAPD,Y2MAPD
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPS/ ORIMX0,ORIMY0,SCAMX0,SCAMY0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
C          THE ARGUMENTS ARE STORED AND THE MAP MARKER IS SET.
C
      X1MAPV= XRECT1
      X2MAPV= XRECT2
      Y1MAPV= YRECT1
      Y2MAPV= YRECT2
      MRKMAP= 1
C
C          IF ANY ARGUMENTS ARE THE SAME, MAPPING IS AUTOMATIC.
C          OTHERWISE, THE SCALE FACTORS AND MAPPING CONSTANTS ARE
C          CALCULATED (FIRST FOR THE X-AXIS, THEN FOR THE Y-AXIS).
C
      IF (ABS(X2MAPV-X1MAPV).LT.RMINI.OR.
     &    ABS(Y2MAPV-Y1MAPV).LT.RMINI) GO TO 5
      IF (ABS(X2MAPD-X1MAPD).LT.RMINI.OR.
     &    ABS(Y2MAPD-Y1MAPD).LT.RMINI) GO TO 5
C
      DIFF= X2MAPD-X1MAPD
      MAPNO0= MAPNUM
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
C
      X1MAP0= (X1MAPV*X2MAPD-X2MAPV*X1MAPD)/DIFF
      X2MAP0= X1MAP0+(X2MAPV-X1MAPV)/DIFF
      ORIMX0= X1MAP0
      SCAMX0= 0.0
      IF (ABS(X2MAP0-X1MAP0).LT.RMINI) GO TO 2
C
      SCAMX0= 1.0/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (ABS(SIGN(1.0,X1MAPV)-SIGN(1.0,X2MAPV)).GE.RMINI) GO TO 901
C
      EXT= (X2MAPD*ALOG(ABS(X1MAPV))-X1MAPD*ALOG(ABS(X2MAPV)))/DIFF
      X1MAP0= EXP(EXT)*SIGN(1.0,X1MAPV)
      X2MAP0= EXP(EXT+ALOG(X2MAPV/X1MAPV)/DIFF)*SIGN(1.0,X2MAPV)
      AB1MAP= ABS(X1MAP0)
      AB2MAP= ABS(X2MAP0)
      IF (AB1MAP.LT.RMINI.OR.AB2MAP.LT.RMINI) GO TO 901
C
      ORIMX0= ALOG(AB1MAP)
      DIFEXP= ALOG(AB2MAP)-ORIMX0
      IF (ABS(DIFEXP).LT.RMINI) GO TO 901
C
      SCAMX0= 1.0/DIFEXP
    2 DIFF= Y2MAPD-Y1MAPD
      MAPNO0= MAPNUM
      IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
C
      Y1MAP0= (Y1MAPV*Y2MAPD-Y2MAPV*Y1MAPD)/DIFF
      Y2MAP0= Y1MAP0+(Y2MAPV-Y1MAPV)/DIFF
      ORIMY0= Y1MAP0
      SCAMY0= 0.0
      IF (ABS(Y2MAP0-Y1MAP0).LT.RMINI) GO TO 4
C
      SCAMY0= 1.0/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (ABS(SIGN(1.0,Y1MAPV)-SIGN(1.0,Y2MAPV)).GE.RMINI) GO TO 901
C
      EXT= (Y2MAPD*ALOG(ABS(Y1MAPV))-Y1MAPD*ALOG(ABS(Y2MAPV)))/DIFF
      Y1MAP0= EXP(EXT)*SIGN(1.0,Y1MAPV)
      Y2MAP0= EXP(EXT+ALOG(Y2MAPV/Y1MAPV)/DIFF)*SIGN(1.0,Y2MAPV)
      AB1MAP= ABS(Y1MAP0)
      AB2MAP= ABS(Y2MAP0)
      IF (AB1MAP.LT.RMINI.OR.AB2MAP.LT.RMINI) GO TO 901
C
      ORIMY0= ALOG(AB1MAP)
      DIFEXP= ALOG(AB2MAP)-ORIMY0
      IF (ABS(DIFEXP).LT.RMINI) GO TO 901
C
      SCAMY0= 1.0/DIFEXP
C
C          THE ARGUMENTS ARE THEN PASSED ON AND THE
C          CURRENT PLOTTING POSITION IS RESTORED.
C
    4 XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      RDATA(1)= X1MAP0
      RDATA(2)= X2MAP0
      RDATA(3)= Y1MAP0
      RDATA(4)= Y2MAP0
      CALL G3LINK(7,MAPNO0,4*NBYTR,IDATA,RDATA)
C
C          IF <CTRSIZ> OR <CTRSLP> HAS BEEN INVOKED, IT IS
C          CALLED AGAIN NOW TO ADJUST FOR THE NEW MAPPING.
C
      IPRSAV= IPRINT
      IPRINT= 0
      IF (MRKSIZ.EQ.1) CALL CTRSIZ(CSIZE)
      IF (MRKSLP.EQ.1) CALL CTRSLP(SLOPE)
    5 IF (MRKWIN.NE.0) GO TO 6
C
      CALL WINDOW(XRECT1,XRECT2,YRECT1,YRECT2)
      MRKWIN= 0
      GO TO 7
C
    6 IF (MRKWIN.GT.0) CALL WINDOW(X1WND0,X2WND0,Y1WND0,Y2WND0)
C
    7 CALL UNLOC
      CALL SCAROT(1.0,1.0,0.0)
      IPRINT= IPRSAV
      RETURN
C
C          THIS SECTION IS FOR LOG.-MAPPING ERRORS.
C
  901 SCAMX0= 0.0
      SCAMY0= 0.0
      VALIM= 1.0
      IF (ABS(X2MAP0).GE.RMINI) VALIM= SIGN(VALIM,X2MAP0)
      IF (ABS(X1MAP0).GE.RMINI) VALIM= SIGN(VALIM,X1MAP0)
C
      X1MAP0= VALIM
      ORIMX0= VALIM
      VALIM= 1.0
      IF (ABS(Y2MAP0).GE.RMINI) VALIM= SIGN(VALIM,Y2MAP0)
      IF (ABS(Y1MAP0).GE.RMINI) VALIM= SIGN(VALIM,Y1MAP0)
C
      Y1MAP0= VALIM
      ORIMY0= Y1MAP0
C
      NUMERR= 2
      IF (ERRON) CALL G0ERMS
      GO TO 5
C
      END
      SUBROUTINE ANNOTP(IDIRX,IDIRY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 239)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE POSITION OF AXIS ANNOTATION.
C
C
C          THE ARGUMENTS ARE:
C
C          <IDIRX>  DETERMINES THE POSITION OF THE X-AXIS ANNOTATION:
C                   = 0, IT IS BELOW THE X-AXIS (IE. NORMAL),
C                   = 1, IT IS ABOVE THE X-AXIS;
C          <IDIRY>  DETERMINES THE POSITION OF THE Y-AXIS ANNOTATION:
C                   = 0, IT IS LEFT OF THE Y-AXIS (IE. NORMAL),
C                   = 1, IT IS RIGHT OF THE Y-AXIS.
C
C
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= IDIRX
      ITRAC2= IDIRY
      IF (IPRINT.EQ.1) CALL G0MESG(155,6)
C
      KDIRX= IDIRX
      KDIRY= IDIRY
C
      RETURN
      END
      SUBROUTINE ARC(XSTART,YSTART,ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 102)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS THE ARC OF A CIRCLE WHICH IS
C          CENTRED ON THE CURRENT PLOTTING POSITION.
C
C
C          <XSTART> IS THE STARTING X-COORDINATE,
C          <YSTART> IS THE STARTING Y-COORDINATE,
C          <ANGLE>  IS THE ARC ANGLE ANTI-CLOCKWISE
C                   FROM THE STARTING POSITION.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA(4) /1.0/, IDATA /0/
C
C
      RTRAC1= XSTART
      RTRAC2= YSTART
      RTRAC3= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(44,3)
C
      RDATA(1)= XSTART-XPLOT0
      RDATA(2)= YSTART-YPLOT0
      RDATA(3)= ANGLE*ANGCON
      CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE ARCELL(XSTART,YSTART,ANGLE,ECCEN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 103)   VERSION (A8.6)    20:JUN:86
C          ------------------------------------------------
C
C          THIS DRAWS THE ARC OF AN ELLIPSE WHICH IS
C          CENTRED ON THE CURRENT PLOTTING POSITION.
C
C
C          <XSTART> IS THE STARTING X-COORDINATE,
C          <YSTART> IS THE STARTING Y-COORDINATE,
C          <ANGLE>  IS THE ARC ANGLE ANTI-CLOCKWISE
C                   FROM THE STARTING POSITION,
C          <ECCEN>  IS THE ECCENTRICITY OF THE ELLIPSE.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3CONS/ PI
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      RTRAC1= XSTART
      RTRAC2= YSTART
      RTRAC3= ANGLE
      RTRAC4= ECCEN
      IF (IPRINT.EQ.1) CALL G0MESG(45,4)
C
      RDATA(1)= XSTART-XPLOT0
      RDATA(2)= YSTART-YPLOT0
      RDATA(4)= ABS(ECCEN)
C
C          CALCULATE THE TRUE ROTATION ANGLE ALLOWING FOR
C          DIFFERENT SCALING ON THE X AND Y AXES.
C
      YCOORD= RDATA(2)*(X2MAP0-X1MAP0)/(Y2MAP0-Y1MAP0)
      ANG= ANGLE*ANGCON
      SINANG= SIN(ANG)
      COSANG= COS(ANG)
      ANUM= RDATA(4)*SINANG*(RDATA(1)*RDATA(1)+YCOORD*YCOORD)
      DENOM= COSANG*(RDATA(1)*RDATA(1)+
     &       YCOORD*YCOORD*RDATA(4)*RDATA(4))+
     &       SINANG*RDATA(1)*YCOORD*(RDATA(4)*RDATA(4)-1)
      RDATA(3)= ATAN2(ANUM,DENOM)
      IF ((RDATA(3)*ANG).LT.0.0)
     &     RDATA(3)= RDATA(3)+PI*SIGN(1.0,ANG)
    1   IF (ABS(RDATA(3)-ANG).LT.PI*0.5) GO TO 2
        RDATA(3)= RDATA(3)+PI*SIGN(1.0,ANG)
       GO TO 1
C
    2 CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE AXES
C
C          ------------------------------------------------
C          ROUTINE NO. ( 192)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(70,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(-1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVS(-2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXESSI(DIX,DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 195)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          WITH INTERVALS SET BY <DIX> AND <DIY>.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      RTRAC2= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(73,2)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(-1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVS(-2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXEXL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 198)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(76,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXYSAV= AXPOSY
      IF (ABS(AXPOSY).LT.RMINI) AXPOSY= X1WND0
C
      CALL G0DIVL(-1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVS(-2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSY= AXYSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXEXLI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 201)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          WITH THE Y-INTERVAL SET BY <DIY>.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(77,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
      IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXYSAV= AXPOSY
      IF (ABS(AXPOSY).LT.RMINI) AXPOSY= X1WND0
C
      CALL G0DIVL(-1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVS(-2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSY= AXYSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXEXYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 200)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(80,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      IF (ABS(AXPOSX).LT.RMINI) AXPOSX= Y1WND0
      AXYSAV= AXPOSY
      IF (ABS(AXPOSY).LT.RMINI) AXPOSY= X1WND0
C
      CALL G0DIVL(-1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVL(-2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXEYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 199)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(78,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      IF (ABS(AXPOSX).LT.RMINI) AXPOSX= Y1WND0
C
      CALL G0DIVS(-1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVL(-2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXEYLI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 202)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION,
C          WITH THE X-INTERVAL SET BY <DIX>.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(79,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
      IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      IF (ABS(AXPOSX).LT.RMINI) AXPOSX= Y1WND0
C
      CALL G0DIVS(-1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVL(-2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE AXNOTA(NOTAT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 191)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS ENABLES AND DISABLES SUBSEQUENT AXES ANNOTATION.
C
C
C          <NOTAT>  SETS ANNOTATION CONTROL:
C                   IF ZERO, NO ANNOTATION IS DONE, OR
C                   IF NON-ZERO, ANNOTATION IS DONE.
C
C
      COMMON /T0NOTA/ NOTATA
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= NOTAT
      IF (IPRINT.EQ.1) CALL G0MESG(69,5)
C
      NOTATA= 0
      IF (NOTAT.NE.0) NOTATA= 10
C
      RETURN
      END
      SUBROUTINE AXORIG(ORIGX,ORIGY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 240)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE POSITION OF THE AXIS ORIGIN.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ORIGX>  IS THE X-COORDINATE OF THE AXIS ORIGIN,
C          <ORIGY>  IS THE Y-COORDINATE OF THE AXIS ORIGIN.
C
C
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= ORIGX
      RTRAC2= ORIGY
      IF (IPRINT.EQ.1) CALL G0MESG(156,2)
C
      AXPOSX= ORIGY
      AXPOSY= ORIGX
C
      RETURN
      END
      SUBROUTINE BACCOL(NCOLOR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  69)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT BACKGROUND COLOUR.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <NCOLOR> IS THE REQUIRED COLOUR NUMBER.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0KBAC/ KOLBA0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NCOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(138,5)
C
      IF (NCOLOR.LT.0.OR.NCOLOR.GT.255) RETURN
      KOLBA0= NCOLOR
      IDATA(1)= KOLBA0
      CALL G3LINK(5,2,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE BAR3D(VALUES,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY)
C
C          ------------------------------------------------
C          ROUTINE NO. (  41)   VERSION (A8.1)    27:OCT:88
C          ------------------------------------------------
C
C          THIS ROUTINE DRAWS A THREE DIMENSIONAL BARCHART OF
C          SUPPLIED DATA.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [VALUES] ARE THE VALUES TO BE GRAPHED,
C          <ISTRTX> IS THE FIRST X VALUE TO BE USED,
C          <ISTOPX> IS THE LAST X VALUE TO BE USED,
C          <NPTSX>  IS THE MAXIMUM SIZE OF VALUES IN X,
C          <ISTRTY> IS THE FIRST Y VALUE TO BE USED,
C          <ISTOPY> IS THE LAST Y VALUE TO BE  USED,
C          <NPTSY>  IS THE MAXIMUM SIZE OF VALUES IN Y.
C
      REAL    VALUES(NPTSX,NPTSY),ARG(2),RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0BANG/ B3ANG
      COMMON /T0BASP/ SIZRAT
      COMMON /T0BBAS/ IBSTYP,BSORIG,BSMAX
      COMMON /T0BKLM/ KMTHOD
      COMMON /T0CHLN/ XEALIN(22),YEALIN(22),XCHLIN(6),YCHLIN(6),NUMLNS
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0KMAT/ MATCL0(55,55),MTROWS,MTCOLS
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA ARG  /0.0,1.0/
C
C          FIRST FIND SUITABLE MAPPING, SAVING CURRENT
C          MAP AND WINDOW VALUES.
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(171,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      XLEN= ILENX+SIZRAT
      YLEN= ILENY+SIZRAT
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.0.OR.ILENY.LT.0)           GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
C
      NUMSAV= MAPNUM
      IPRSAV= IPRINT
      IPRINT= 0
      CALL G0AUTO(ARG,ARG,1,2,1,2,1)
      XPSAV= XPLOT0
      YPSAV= YPLOT0
      X1MSAV= X1MAPV
      X2MSAV= X2MAPV
      Y1MSAV= Y1MAPV
      Y2MSAV= Y2MAPV
      X1WSAV= X1WND0
      X2WSAV= X2WND0
      Y1WSAV= Y1WND0
      Y2WSAV= Y2WND0
      MRKSAV= MRKWIN
      DIFF= X2WND0-X1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      XM1= (X1MAPV-X1WND0)/DIFF
      XM2= (X2MAPV-X1WND0)/DIFF
      DIFF= Y2WND0-Y1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      YM1= (Y1MAPV-Y1WND0)/DIFF
      YM2= (Y2MAPV-Y1WND0)/DIFF
      CALL MAP(XM1,XM2,YM1,YM2)
      CALL WINDOW(-0.5,1.5,-0.5,1.5)
C
C          CALCULATE SUITABLE BAR WIDTH.
C
      ANGLE= ATAN(SIN(B3ANG)*(Y2MAP0-Y1MAP0)/
     &           (COS(B3ANG)*(X2MAP0-X1MAP0)))
      SBRANG= SIN(ANGLE)
      CBRANG= COS(ANGLE)
      COSASQ= CBRANG*CBRANG
      COSINA= CBRANG*SBRANG
      SIZE= 1.0/(XLEN+COSASQ*YLEN)
      BRSIZE= SIZE*SIZRAT
      XSTRT= SIZE*XLEN
      YSPOSN= COSINA*BRSIZE
C
C          CALCULATE SUITABLE SCALE FOR BAR HEIGHT.
C
      VALMAX= RMINI
      SCALE= RMAXI
      CRSCA= RMAXI
      IBRFLG= 0
      IF (IBSTYP.EQ.0) BSORIG= VALUES(ISTRTX,ISTRTY)
C
      DO 100 ICURY= ISTRTY,ISTOPY
C
        DO 100 ICURX= ISTRTX,ISTOPX
          IF (IBSTYP.NE.0.AND.VALUES(ICURX,ICURY).GT.BSORIG) IBRFLG= 1
          IF (IBSTYP.EQ.0.AND.VALUES(ICURX,ICURY).LT.BSORIG)
     &                                      BSORIG= VALUES(ICURX,ICURY)
  100 CONTINUE
C
      DO 200 ICRYBR= ISTRTY,ISTOPY
        VLINHI= VALUES(ISTRTX,ICRYBR)
C
        DO 300 ICRXBR= ISTRTX,ISTOPX
          IF (VALUES(ICRXBR,ICRYBR).GT.VLINHI)
     &                                    VLINHI= VALUES(ICRXBR,ICRYBR)
  300   CONTINUE
C
        IF (IBSTYP.NE.0.AND.VLINHI.GT.BSMAX) VLINHI= BSMAX
        IF (VALMAX.LT.VLINHI) VALMAX= VLINHI
        IF (VLINHI.GT.BSORIG) CRSCA= (1.0-YSPOSN)/(VLINHI-BSORIG)
        IF (CRSCA.LT.SCALE) SCALE= CRSCA
C
        YSPOSN= YSPOSN+COSINA*SIZE
  200 CONTINUE
C
      IF (IBRFLG.EQ.0.AND.IBSTYP.NE.0) SCALE= 0.0
C
C          PLOT ONE BAR AT A TIME, STARTING IN BOTTOM RIGHT.
C
      XPOSN= XSTRT
      YPOSN= 0.0
      CXOFFS= COSASQ*BRSIZE
      CYOFFS= COSINA*BRSIZE
C
      DO 400 ICRYBR= ISTRTY,ISTOPY
C
        DO 500 ICRXBR= ISTOPX,ISTRTX,-1
          CZOFFS= SCALE*(AMIN1(VALMAX,VALUES(ICRXBR,ICRYBR))-BSORIG)
          IF (VALUES(ICRXBR,ICRYBR).LT.BSORIG) CZOFFS= 0.0
C
C          DEAL WITH EACH OF THE THREE PARTS TO A BAR
C          ONE AT A TIME.
C
          DO 600 IWHSUR= 1,3
            IF (IWHSUR.NE.1) GO TO 2
C
C          SIDE OF BAR.
C
            XEALIN(1)= XPOSN
            YEALIN(1)= YPOSN
            XEALIN(2)= XPOSN+CXOFFS
            YEALIN(2)= YPOSN+CYOFFS
            XEALIN(3)= XPOSN+CXOFFS
            YEALIN(3)= YPOSN+CYOFFS+CZOFFS
            XEALIN(4)= XPOSN
            YEALIN(4)= YPOSN+CZOFFS
            XSMLST= XPOSN
            XLRGST= XPOSN+CXOFFS
            YSMLST= YPOSN
            YLRGST= YPOSN+CYOFFS+CZOFFS
            GO TO 4
C
    2       IF (IWHSUR.NE.2) GO TO 3
C
C          TOP OF BAR.
C
            XEALIN(1)= XPOSN
            YEALIN(1)= YPOSN+CZOFFS
            XEALIN(2)= XPOSN+CXOFFS
            YEALIN(2)= YPOSN+CYOFFS+CZOFFS
            XEALIN(3)= XPOSN-BRSIZE+CXOFFS
            YEALIN(3)= YPOSN+CYOFFS+CZOFFS
            XEALIN(4)= XPOSN-BRSIZE
            YEALIN(4)= YPOSN+CZOFFS
            XSMLST= XPOSN-BRSIZE
            YSMLST= YPOSN+CZOFFS
            GO TO 4
C
C          FRONT OF BAR.
C
    3       XEALIN(1)= XPOSN
            YEALIN(1)= YPOSN
            XEALIN(2)= XPOSN
            YEALIN(2)= YPOSN+CZOFFS
            XEALIN(3)= XPOSN-BRSIZE
            YEALIN(3)= YPOSN+CZOFFS
            XEALIN(4)= XPOSN-BRSIZE
            YEALIN(4)= YPOSN
            XLRGST= XPOSN
            YSMLST= YPOSN
            YLRGST= YPOSN+CZOFFS
    4       IF (ABS(XLRGST-XSMLST).LT.RMINI.OR.
     &          ABS(YLRGST-YSMLST).LT.RMINI) GO TO 600
C
            CHXPOS= XSTRT
            CHYPOS= 0.0
            NUMLNS= 4
C
C          CHECK FOR ANY BAR ALREADY PLOTTED OVERLAPPING
C          WITH CURRENT BAR.
C
            DO 700 ICHYBR= ISTRTY,ICRYBR
C
              DO 800 ICHXBR= ISTOPX,ISTRTX,-1
C
                IF (ICHYBR.GE.ICRYBR.AND.ICHXBR.LE.ICRXBR) GO TO 800
                IF (CHXPOS-BRSIZE.GE.XLRGST) GO TO 5
                IF (CHXPOS+CXOFFS.LE.XSMLST) GO TO 800
C
                CHZOFS= SCALE*(AMIN1(VALMAX,VALUES(ICHXBR,ICHYBR))
     &                  -BSORIG)
                IF (VALUES(ICHXBR,ICHYBR).LT.BSORIG) CHZOFS= 0.0
                IF (CHYPOS+CHZOFS+CYOFFS.LE.YSMLST) GO TO 5
C
                XCHLIN(1)= CHXPOS
                YCHLIN(1)= CHYPOS
                XCHLIN(2)= CHXPOS+CXOFFS
                YCHLIN(2)= CHYPOS+CYOFFS
                XCHLIN(3)= CHXPOS+CXOFFS
                YCHLIN(3)= CHYPOS+CYOFFS+CHZOFS
                XCHLIN(4)= CHXPOS-BRSIZE+CXOFFS
                YCHLIN(4)= CHYPOS+CYOFFS+CHZOFS
                XCHLIN(5)= CHXPOS-BRSIZE
                YCHLIN(5)= CHYPOS+CHZOFS
                XCHLIN(6)= CHXPOS-BRSIZE
                YCHLIN(6)= CHYPOS
                CALL G0OLAP
    5           CHXPOS= CHXPOS-SIZE
  800         CONTINUE
C
              CHYPOS= CHYPOS+COSINA*SIZE
              CHXPOS= XSTRT+FLOAT(ICHYBR-ISTRTY+1)*COSASQ*SIZE
  700       CONTINUE
C
C          IF SURFACE IS HIDDEN THERE IS NO NEED TO DRAW IT.
C
            IF (NUMLNS.EQ.0) GO TO 600
C
C          IF COLOURING NECESARY CHOOSE CURRENT COLOUR
C          ACCORDING TO DESIRED METHOD.
C
            IF (KMTHOD.EQ.0) GO TO 10
            IF (KMTHOD.NE.1) GO TO 6
C
C          COLOUR FILL METHOD 1
C
            KOLINX= MOD(ICRXBR,LENLST)
            IF (KOLINX.EQ.0) KOLINX= LENLST
C
            KOLLOR= LSTCL0(KOLINX)
            GO TO 9
C
    6       IF (KMTHOD.NE.2) GO TO 7
C
C          COLOUR FILL METHOD 2
C
            KOLINY= MOD(ICRYBR,LENLST)
            IF (KOLINY.EQ.0) KOLINY= LENLST
C
            KOLLOR= LSTCL0(KOLINY)
            GO TO 9
C
    7       IF (KMTHOD.NE.3) GO TO 8
C
C          COLOUR FILL METHOD 3
C
            IND= MOD(IWHSUR,3)+1
            KOLLOR= LSTCL0(IND)
            GO TO 9
C
C          COLOUR FILL METHOD 4
C
    8       KOLINX= MOD(ICRXBR,MTROWS)
            IF (KOLINX.EQ.0) KOLINX= MTROWS
C
            KOLINY= MOD(ICRYBR,MTCOLS)
            IF (KOLINY.EQ.0) KOLINY= MTCOLS
C
            KOLLOR= MATCL0(KOLINX,KOLINY)
C
C          ALL METHODS
C
    9       IF (KOLLOR.EQ.0) GO TO 10
C
            IDATA(1)= 0
            IF (KOLLOR.LT.0) IDATA(1)= 1
C
            CALL G3LINK(5,13,-1,IDATA,RDATA)
            IDATA(1)= IABS(KOLLOR)
            CALL G3LINK(5,3,-1,IDATA,RDATA)
            CALL POSITN(XEALIN(NUMLNS),YEALIN(NUMLNS))
C
            DO 900 I= 1,NUMLNS
              CALL JOIN(XEALIN(I),YEALIN(I))
  900       CONTINUE
C
            CALL G3LINK(5,4,0,IDATA,RDATA)
            IF (IDRBND.EQ.0) GO TO 600
C
C          DRAW LINES IN CURRENT BAR SEGMENT.
C
   10       CALL POSITN(XEALIN(NUMLNS),YEALIN(NUMLNS))
C
            DO 1000 I= 1,NUMLNS
              CALL JOIN(XEALIN(I),YEALIN(I))
 1000       CONTINUE
C
  600     CONTINUE
C
          XPOSN= XPOSN-SIZE
  500   CONTINUE
C
        YPOSN= YPOSN+COSINA*SIZE
        XPOSN= XSTRT+FLOAT(ICRYBR-ISTRTY+1)*COSASQ*SIZE
  400 CONTINUE
C
C          THE ENTRY STATE IS RESTORED BEFORE RETURNING
C
      CALL WINFOL
      MAPNUM= NUMSAV
      CALL G0MAPS(X1MSAV,X2MSAV,Y1MSAV,Y2MSAV)
      IF (MRKSAV.NE.0) CALL WINDOW(X1WSAV,X2WSAV,Y1WSAV,Y2WSAV)
C
      CALL POSITN(XPSAV,YPSAV)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 9
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE BARCHT(BASPOS,BARWID,BARPOS,VALUES,ISTART,ISTOP)
C
C          ------------------------------------------------
C          ROUTINE NO. (  85)   VERSION (A8.3)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A BAR CHART OF A GIVEN SET OF VALUES,
C                  WITH HORIZONTAL OR VERTICAL BARS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <BASPOS> IS THE BASELINE ORIGIN OF THE GRAPH,
C          <BARWID> IS THE THICKNESS OF THE BARS,
C          [BARPOS] ARE THE POSITIONS OF THE BARS,
C          [VALUES] ARE THE VALUES TO BE GRAPHED,
C          <ISTART> IS THE LOWER BOUNDARY, AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAYS.
C
C
      REAL    BAUTO(2),VAUTO(2),BARPOS(ISTOP),VALUES(ISTOP),RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(133,1)
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
      IF (ISTOP.LT.ISTART) RETURN
C
      BAUTO(1)= BARPOS(ISTART)-BARWID*0.5
      BAUTO(2)= BARPOS(ISTOP)+BARWID*0.5
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 INDEX= ISTART,ISTOP
        VAL=VALUES(INDEX)
        IF (VAL.LT.VAUTO(1)) VAUTO(1)= VAL
        IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI) RETURN
      IF (ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 4
C
      KOLIND= 1
C
      DO 200 IBAR= ISTART,ISTOP
        IF (LSTCL0(KOLIND).EQ.0) GO TO 3
C
        IDATA(1)= 0
        IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
        CALL G3LINK(5,13,-1,IDATA,RDATA)
        IDATA(1)= IABS(LSTCL0(KOLIND))
        CALL G3LINK(5,3,-1,IDATA,RDATA)
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
        IF (IBRTYP.NE.0) GO TO 1
C
        CALL POSITN(BRPOS,BASPOS)
        CALL JOIN(BRPOS,VALUES(IBAR))
        CALL JOIN(BRPOS1,VALUES(IBAR))
        CALL JOIN(BRPOS1,BASPOS)
        CALL JOIN(BRPOS,BASPOS)
        GO TO 2
C
    1   CALL POSITN(BASPOS,BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS1)
        CALL JOIN(BASPOS,BRPOS1)
        CALL JOIN(BASPOS,BRPOS)
    2   CALL G3LINK(5,4,0,IDATA,RDATA)
    3   KOLIND= KOLIND+1
        IF (KOLIND.GT.LENLST) KOLIND= 1
  200 CONTINUE
C
      IF (IDRBND.EQ.0) GO TO 6
C
    4 DO 300 IBAR= ISTART,ISTOP
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
        IF (IBRTYP.NE.0) GO TO 5
C
        CALL POSITN(BRPOS,BASPOS)
        CALL JOIN(BRPOS,VALUES(IBAR))
        CALL JOIN(BRPOS1,VALUES(IBAR))
        CALL JOIN(BRPOS1,BASPOS)
        GO TO 300
C
    5   CALL POSITN(BASPOS,BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS1)
        CALL JOIN(BASPOS,BRPOS1)
  300 CONTINUE
C
      IF (IBRTYP.EQ.0) CALL JOIN(BAUTO(1),BASPOS)
      IF (IBRTYP.NE.0) CALL JOIN(BASPOS,BAUTO(1))
C
    6 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE BARFLG(IFLAGS,NOFLGS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 109)   VERSION (A8.1)    06:MAY:86
C          ------------------------------------------------
C
C          THIS SPECIFIES THE VALUES TO BE DRAWN
C          BY INCBAR, INCHIS, MULBAR AND MULHIS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [IFLAGS] ARE THE FLAGS TO VALUES TO BE GRAPHED,
C                   NON-ZERO TO INCLUDE.
C          <NOFLGS> IS THE SIZE OF THE ARRAY.
C
C
      INTEGER IFLAGS(NOFLGS)
C
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(166,0)
C
      DO 100 ISAVE= 1,100
        IF (ISAVE.LE.NOFLGS) INFLGS(ISAVE)= IFLAGS(ISAVE)
        IF (ISAVE.GT.NOFLGS) INFLGS(ISAVE)= 1
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE BARTYP(KIND)
C
C          --------------------------------------------------
C          ROUTINE NO. (  89)    VERSION (A8.1)     10:DEC:85
C          --------------------------------------------------
C
C          THIS SELECTS HORIZONTAL OR VERTICAL BARS FOR BARCHARTS
C          AND HISTOGRAMS.
C
C
C          <KIND> = ZERO     FOR VERTICAL   BARS.
C          <KIND> = NON-ZERO FOR HORIZONTAL BARS.
C
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= KIND
      IF (IPRINT.EQ.1) CALL G0MESG(159,5)
C
      IBRTYP= KIND
      IF (IBRTYP.NE.0) IBRTYP= 1
C
      RETURN
      END
      SUBROUTINE BORDER
C
C          ------------------------------------------------
C          ROUTINE NO. (  78)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A BORDER AROUND THE CURRENT WINDOW AREA.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(30,0)
C
C          THE CURRENT PLOTTING POSITION IS SAVED, WINDOW-RELATED
C          VECTORS ARE SET, THE BORDER IS DRAWN, THE CURRENT
C          POSITION IS RESTORED, AND NORMAL VECTORS RE-ENABLED.
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL POSITN(X1WND0,Y1WND0)
      CALL   JOIN(X1WND0,Y2WND0)
      CALL   JOIN(X2WND0,Y2WND0)
      CALL   JOIN(X2WND0,Y1WND0)
      CALL   JOIN(X1WND0,Y1WND0)
C
      CALL POSITN(XHERE,YHERE)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE BR3ANG(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  43)   VERSION (A8.1)    30:SEP:86
C          ------------------------------------------------
C
C          THIS SPECIFIES THE VIEW ANGLE FOR THE ROUTINE BAR3D
C
C          THE PARAMETER IS :
C
C          <ANGLE> IS THE ANGLE THE BARS MAKE WITH THE BASELINE.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0BANG/ B3ANG
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3CONS/ PI
C
C
      CALL G3INIT(2)
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(173,1)
C
      B3ANG= ANGLE*ANGCON
      IF (B3ANG.GT.PI/2.4) B3ANG= PI/2.4
      IF (B3ANG.LE.PI/12.0) B3ANG= PI/12.0
C
      RETURN
      END
      SUBROUTINE BR3BAS(IBASE,HTBASE,HTMAX)
C
C          ------------------------------------------------
C          ROUTINE NO. (  48)   VERSION (A8.1)    03:NOV:86
C          ------------------------------------------------
C
C          THIS SETS THE BASE HEIGHT FOR THE ROUTINE BAR3D
C
C          THE PARAMETERS ARE :
C
C          <IBASE>  IS A VALUE INDICATING AS FOLLOWS:
C                   0 : BASE IS MINIMUM OF DATA SET
C                   1 : BASE IS SPECIFIED AND ALL VALUES BELOW IT
C                       ARE ROUNDED UP TO IT.
C          <HTBASE> IS THE SPECIFIED BASELINE VALUE.
C          <HTMAX>  IS THE MAXIMUM BAR VALUE.
C
C
      COMMON /T0BBAS/ IBSTYP,BSORIG,BSMAX
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
      ITRAC1= IBASE
      IF (IPRINT.EQ.1) CALL G0MESG(174,5)
C
      IBSTYP= IBASE
      IF (IBSTYP.NE.0) IBSTYP= 1
      IF (IBSTYP.NE.1) RETURN
C
      BSORIG= HTBASE
      BSMAX= HTMAX
C
      RETURN
      END
      SUBROUTINE BR3COL(IMETHD)
C
C          ------------------------------------------------
C          ROUTINE NO. (  42)   VERSION (A8.1)    02:JUL:86
C          ------------------------------------------------
C
C          THIS ROUTINE SETS UP THE METHOD OF COLOURING USED
C          BY THE THREE DIMENSIONAL BARCHART ROUTINE.
C
C          THE PARAMETER IS :
C
C          <IMETHD> IS AN INTEGER REFERING TO THE METHOD OF
C                   COLOURING :
C                           0 : NO COLOURING TO BE DONE.
C                           1 : EACH X BAR DIFFERENT COLOUR.
C                           2 : EACH Y BAR DIFFERENT COLOUR.
C                           3 : EACH SURFACE OF BAR DIFFERENT
C                               COLOUR.
C                           4 : EACH BAR DIFFERENT COLOUR.
C
      COMMON /T0BKLM/ KMTHOD
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
      ITRAC1= IMETHD
      IF (IPRINT.EQ.1) CALL G0MESG(172,5)
      IF (IMETHD.LT.0.OR.IMETHD.GT.4) RETURN
C
      KMTHOD= IMETHD
C
      RETURN
      END
      SUBROUTINE BR3LBL(CLABLS,ISTRTC,ISTOPC,NCLBLS,RLABLS,ISTRTR,
     &                  ISTOPR,NRLBLS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  50)   VERSION (A8.1)    21:NOV:90
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS LABELS ON A 3-D BARCHART.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [CLABLS] CONTAINS THE LABELS FOR THE COLUMNS.
C          <ISTRTC> IS THE FIRST COLUMN LABEL TO BE USED.
C          <ISTOPC> IS THE LAST COLUMN LABEL TO BE USED.
C          <NCLBLS> IS THE NUMBER OF COLUMN LABELS.
C          [RLABLS] CONTAINS THE LABELS FOR THE ROWS.
C          <ISTRTR> IS THE FIRST ROW LABEL TO BE USED.
C          <ISTOPR> IS THE LAST ROW LABEL TO BE USED.
C          <NRLBLS> IS THE NUMBER OF ROW LABELS.
C
C
      LOGICAL   ERRON
      CHARACTER CLABLS(NCLBLS)*(*),RLABLS(NRLBLS)*(*)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0BANG/ B3ANG
      COMMON /T0BASP/ SIZRAT
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(187,0)
C
      XLEN= ISTOPC-ISTRTC+SIZRAT
      YLEN= ISTOPR-ISTRTR+SIZRAT
      IF (ISTRTC.LT.1.OR.ISTRTR.LT.1)         GO TO 901
      IF (ISTOPC.GT.NCLBLS.OR.ISTOPR.GT.NRLBLS) GO TO 901
C
      UNSAVE= ANGCON
      ANGCON= 1.0
      ANGSAV= STANG0
      NUMSAV= MAPNUM
      IPRSAV= IPRINT
      IPRINT= 0
      XPSAV= XPLOT0
      YPSAV= YPLOT0
      X1MSAV= X1MAPV
      X2MSAV= X2MAPV
      Y1MSAV= Y1MAPV
      Y2MSAV= Y2MAPV
      X1WSAV= X1WND0
      X2WSAV= X2WND0
      Y1WSAV= Y1WND0
      Y2WSAV= Y2WND0
      MRKSAV= MRKWIN
      DIFF= X2WND0-X1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      XM1= (X1MAPV-X1WND0)/DIFF
      XM2= (X2MAPV-X1WND0)/DIFF
      DIFF= Y2WND0-Y1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      YM1= (Y1MAPV-Y1WND0)/DIFF
      YM2= (Y2MAPV-Y1WND0)/DIFF
      CALL MAP(XM1,XM2,YM1,YM2)
      CALL WINDOW(-0.5,1.5,-0.5,1.5)
C
C          CALCULATE SUITABLE BAR WIDTH.
C
      ANGLE= ATAN(SIN(B3ANG)*(Y2MAP0-Y1MAP0)/
     &           (COS(B3ANG)*(X2MAP0-X1MAP0)))
      SBRANG= SIN(ANGLE)
      CBRANG= COS(ANGLE)
      COSASQ= CBRANG*CBRANG
      COSINA= CBRANG*SBRANG
      SIZE= 1.0/(XLEN+COSASQ*YLEN)
      BRSIZE= SIZE*SIZRAT
      XSTRT= SIZE*XLEN
C
C          DRAW THE X-AXIS LABELS.
C
      CALL CTRORI(0.7)
      XPOS= XSTRT
      IF (ISTOPC.LT.ISTRTC) GO TO 1
C
      DO 100 IBAR= ISTOPC,ISTRTC,-1
        CALL POSITN(XPOS,0.0)
        CALL SPACE(-2)
        CALL TCSEND(CLABLS(IBAR))
        XPOS= XPOS-SIZE
  100 CONTINUE
C
C          DRAW THE Y-AXIS LABELS.
C
    1 CALL CTRORI(0.0)
      XPOS= XSTRT+BRSIZE*COSASQ*0.25
      YPOS= BRSIZE*COSINA*0.25
      IF (ISTOPR.LT.ISTRTR) GO TO 2
C
      DO 200 IBAR= ISTRTR,ISTOPR
        CALL POSITN(XPOS,YPOS)
        CALL SPACE(3)
        CALL TYPECS(RLABLS(IBAR))
        XPOS= XPOS+SIZE*COSASQ
        YPOS= YPOS+SIZE*COSINA
  200 CONTINUE
C
C          THE ENTRY STATE IS RESTORED BEFORE RETURNING
C
    2 CALL WINFOL
      MAPNUM= NUMSAV
      CALL G0MAPS(X1MSAV,X2MSAV,Y1MSAV,Y2MSAV)
      IF (MRKSAV.NE.0) CALL WINDOW(X1WSAV,X2WSAV,Y1WSAV,Y2WSAV)
C
      CALL POSITN(XPSAV,YPSAV)
      CALL CTRORI(ANGSAV)
      ANGCON= UNSAVE
      IPRINT= IPRSAV
C
      RETURN
C
  901 NUMERR= 23
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE BR3RAT(BSRATO)
C
C          ------------------------------------------------
C          ROUTINE NO. (  49)   VERSION (A8.1)    30:SEP:86
C          ------------------------------------------------
C
C          THIS SETS THE BAR:SPACE RATIO FOR THE ROUTINE BAR3D
C
C          THE PARAMETER IS :
C
C          <BSRATO> IS THE RATIO OF THE BARSIZE AND THE SPACES
C                   BETWEEN THEM.
C
C
      COMMON /T0BASP/ SIZRAT
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
      RTRAC1= BSRATO
      IF (IPRINT.EQ.1) CALL G0MESG(175,1)
C
      SIZRAT= BSRATO
      SIZRAT= AMIN1(SIZRAT,0.99999)
      SIZRAT= AMAX1(SIZRAT,0.00001)
C
      RETURN
      END
      SUBROUTINE BROKEN(MARKA,MISSA,MARKB,MISSB)
C
C          ------------------------------------------------
C          ROUTINE NO. (  51)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE BROKEN LINE PATTERN.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <MARKA>  IS THE 1ST. LINE LENGTH,
C          <MISSA>  IS THE 1ST. SPACE LENGTH,
C          <MARKB>  IS THE 2ND. LINE LENGTH,
C          <MISSB>  IS THE 2ND. SPACE LENGTH
C                   (ALL IN UNITS OF 1/1000 OF THE UNIT SQUARE).
C
C
      REAL    RDATA(1)
      INTEGER IDATA(4)
C
      COMMON /T0LPAT/ MARKA0,MISSA0,MARKB0,MISSB0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= MARKA
      ITRAC2= MISSA
      ITRAC3= MARKB
      ITRAC4= MISSB
      IF (IPRINT.EQ.1) CALL G0MESG(22,8)
C
      MARKA0= IABS(MARKA)
      IF (MARKA0.GT.255) MARKA0= 255
      MISSA0= IABS(MISSA)
      IF (MISSA0.GT.255) MISSA0= 255
      MARKB0= IABS(MARKB)
      IF (MARKB0.GT.255) MARKB0= 255
      MISSB0= IABS(MISSB)
      IF (MISSB0.GT.255) MISSB0= 255
C
      IDATA(1)= MARKA0
      IDATA(2)= MISSA0
      IDATA(3)= MARKB0
      IDATA(4)= MISSB0
      CALL G3LINK(3,6,-4,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CDEFIN(NCHAR,KSPEC,LENDEF)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 141)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CREATES A NEW DEFINITION OF THE GIVEN FONT-0 CHAR.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <NCHAR>  IS THE CHARACTER NUMBER,
C          [KSPEC]  IS THE SET OF LINE END-COORDINATES,
C          <LENDEF> IS THE LENGTH OF THE DEFINITION
C                   (= 0, THE NEW DEFINITION IS DELETED).
C
C
      REAL    RDATA(1)
      INTEGER IDATA(255),KSPEC(LENDEF)
      LOGICAL ERRON
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NCHAR
      IF (IPRINT.EQ.1) CALL G0MESG(52,5)
C
      ICHAR= IABS(NCHAR)
      IF (ICHAR.GE.160)  GO TO 901
      LENGTH= IABS(LENDEF)+1
      IF (LENGTH.GT.255) GO TO 902
      IDATA(1)= ICHAR
C
      DO 100 ICOPY= 1,LENDEF
        IXVAL= KSPEC(ICOPY)/10
        IF (IXVAL.LT.0.OR.IXVAL.GT.7) GO TO 902
        IYVAL= KSPEC(ICOPY)-IXVAL*10
        IF (IYVAL.LT.0.OR.IYVAL.GT.7) GO TO 902
        IDATA(ICOPY+1)= KSPEC(ICOPY)
  100 CONTINUE
C
      CALL G3LINK(2,16,-LENGTH,IDATA,RDATA)
      RETURN
C
C          THIS WRITES OUT ERROR MESSAGES.
C
  901 NUMERR= 21
      GO TO 903
C
  902 NUMERR= 22
  903 IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CHANNL(NCHANL,ISWICH)
C
C          ------------------------------------------------
C          ROUTINE NO. (  16)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SWITCHES THE GIVEN CHANNEL ON OR OFF.
C
C
C          <NCHANL> GIVES THE CHANNEL NUMBER.
C          <ISWICH> IS ZERO FOR OFF AND NON-ZERO FOR ON.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0DEVS/ KCHAN0(5),IRESL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NCHANL
      ITRAC2= ISWICH
      IF (IPRINT.EQ.1) CALL G0MESG(122,6)
C
      IF (NCHANL.LE.0.OR.NCHANL.GT.5) RETURN
C
      IDATA(1)= NCHANL
      IF (ISWICH.EQ.0) GO TO 1
      KCHAN0(NCHANL)= 1
      CALL G3LINK(3,1,-1,IDATA,RDATA)
      RETURN
C
    1 KCHAN0(NCHANL)= 0
      CALL G3LINK(3,2,-1,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE CIRCLE(RADIUS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 100)   VERSION (A8.4)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A CIRCLE CENTRED ON
C          THE CURRENT PLOTTING POSITION.
C
C
C          <RADIUS> GIVES THE CIRCLE RADIUS.
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0,1.0/, IDATA /0/
C
C
      RTRAC1= RADIUS
      IF (IPRINT.EQ.1) CALL G0MESG(42,1)
C
      RDATA(1)= ABS(RADIUS)
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL G3LINK(0,8,2*NBYTR,IDATA,RDATA)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) RETURN
C
    1 CALL G3LINK(0,8,2*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CLRBUF(NBUFFR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  15)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CLEARS BUFFER NO. 'NBUFFR'.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NBUFFR
      IF (IPRINT.EQ.1) CALL G0MESG(117,5)
C
      IF (NBUFFR.LE.0.OR.NBUFFR.GT.16) GO TO 901
C
      KBUFR0= NBUFFR
      IDATA(1)= NBUFFR
      CALL G3LINK(4,4,-1,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 8
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE COLSET(ARG1,ARG2,ARG3,NCOLOR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  62)   VERSION (A7.2)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DEFINES A COLOUR (IN TERMS
C          OF THE CURRENT COLOUR SYSTEM).
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ARG1>   IS THE FIRST COLOUR PARAMETER,
C          <ARG2>   IS THE SECOND COLOUR PARAMETER,
C          <ARG3>   IS THE THIRD COLOUR PARAMETER, AND
C          <NCOLOR> IS THE ASSOCIATED COLOUR NUMBER.
C
C
      REAL    RDATA(4),SHVAL(4)
      INTEGER IDATA(1),IPNTR(6,3)
      LOGICAL ERRON
C
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0KTAB/ REDCO0(255),GRNCO0(255),BLUCO0(255),NCOLS0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3CONS/ PI
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
      DATA IPNTR /4,1,1,3,2,2,
     &            2,2,4,1,1,3,
     &            1,3,2,2,4,1/
C
C
      CALL G3INIT(2)
C
      RTRAC1= ARG1
      RTRAC2= ARG2
      RTRAC3= ARG3
      RTRAC4= NCOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(128,4)
C
      IF (NCOLOR.LT.1.OR.NCOLOR.GT.255) RETURN
      RDATA(1)= NCOLOR
      CPARA1= ARG1
      CPARA2= ARG2
      CPARA3= ARG3
      IF (CPARA2.LT.0.0) CPARA2= 0.0
      IF (CPARA2.GT.1.0) CPARA2= 1.0
      IF (CPARA3.LT.0.0) CPARA3= 0.0
      IF (CPARA3.GT.1.0) CPARA3= 1.0
      IF (KOLSYS.GE.4) GO TO 11
C
C          THIS SECTION FINDS THE HUE IN DEGREES IN THE
C          RANGE [0.0 TO 360.0] FOR THE OTHER THREE SYSTEMS.
C
      HUE= CPARA1
    1 HUE= HUE+1.0
      IF (HUE.LT.0.0) GO TO 1
C
      HUE= AMOD(HUE*360.0,360.0)
C
C          THIS SECTION CONVERTS <HSV> VALUES INTO <RGB ONES.
C
      IF (KOLSYS.NE.1) GO TO 2
C
      HUE= HUE/60.0
      ISWTCH= HUE+1.0
      SHADE= AMOD(HUE,1.0)
C
      SHVAL(1)= CPARA3
      SHVAL(2)= CPARA3*(1.0-CPARA2)
      SHVAL(3)= CPARA3*(1.0-(CPARA2*SHADE))
      SHVAL(4)= CPARA3*(1.0-(CPARA2*(1.0-SHADE)))
C
      INDEX= IPNTR(ISWTCH,1)
      RDATA(2)= SHVAL(INDEX)
      INDEX= IPNTR(ISWTCH,2)
      RDATA(3)= SHVAL(INDEX)
      INDEX= IPNTR(ISWTCH,3)
      RDATA(4)= SHVAL(INDEX)
      GO TO 12
C
C          THIS SECTION CONVERTS <HLS> VALUES INTO <RGB> ONES.
C
   2  IF (KOLSYS.NE.2) GO TO 6
C
      SHMAX= CPARA2+CPARA2*CPARA3
      IF (CPARA2.GT.0.5) SHMAX= CPARA2+CPARA3-CPARA2*CPARA3
      SHMIN= CPARA2*2.0-SHMAX
C
      DO 100 ISHADE= 1,3
        HUEDIS= HUE-(ISHADE-1)*120.0
        IF (HUEDIS.LT.0.0) HUEDIS= HUEDIS+360.0
C
        IF (HUEDIS.GE.60.0) GO TO 3
        SHVAL(ISHADE)= SHMIN+(SHMAX-SHMIN)*HUEDIS/60.0
        GO TO 100
C
    3   IF (HUEDIS.GE.180.0) GO TO 4
        SHVAL(ISHADE)= SHMAX
        GO TO 100
C
    4   IF (HUEDIS.GE.240.0) GO TO 5
        SHVAL(ISHADE)= SHMIN+(SHMAX-SHMIN)*(240.0-HUEDIS)/60.0
        GO TO 100
C
    5   SHVAL(ISHADE)= SHMIN
  100 CONTINUE
C
      GO TO 10
C
C          THIS SECTION CONVERTS <HSI> VALUES INTO <RGB> ONES.
C
    6 SHADE= CPARA2*CPARA3
      HUEANG= HUE
      IF (HUEANG.GE.120.0) HUEANG= HUEANG-120.0
      IF (HUEANG.GE.120.0) HUEANG= HUEANG-120.0
      HUEANG= HUEANG*PI/180.0
C
      DO 200 ISHADE= 1,3
        HUEDIS= HUE-(ISHADE-1)*120.0
        IF (HUEDIS.LT.0.0) HUEDIS= HUEDIS+360.0
C
        IF (HUEDIS.GE.120.0) GO TO 7
        SHVAL(ISHADE)= CPARA3-SHADE*COS(HUEANG+PI/3.0)/
     &                              COS(HUEANG-PI/3.0)
        GO TO 200
C
    7   IF (HUEDIS.GE.240.0) GO TO 8
        SHVAL(ISHADE)= CPARA3+SHADE*COS(HUEANG)/COS(HUEANG-PI/3.0)
        GO TO 200
C
    8   SHVAL(ISHADE)= CPARA3-SHADE
  200 CONTINUE
C
C          THIS SECTION CHECKS TO SEE IF ANY OF THE <RGB> VALUES
C          BECOME SATURATED WHEN USING THE <HSI> METHOD.
C
      DO 300 LOOK= 1,3
        IF (SHVAL(LOOK).GE.0.0) GO TO 9
        SHVAL(LOOK)= 0.0
        NUMERR= 34
        IF (ERRON) CALL G0ERMS
    9   IF (SHVAL(LOOK).LE.1.0) GO TO 300
        SHVAL(LOOK)= 1.0
        NUMERR= 34
        IF (ERRON) CALL G0ERMS
  300 CONTINUE
C
   10 RDATA(2)= SHVAL(1)
      RDATA(3)= SHVAL(2)
      RDATA(4)= SHVAL(3)
      GO TO 12
C
C          THIS SECTION IS FOR THE <RGB> SYSTEM. NO
C          CONVERSION NEEDS TO BE DONE IN THIS CASE.
C
   11 IF (CPARA1.LT.0.0) CPARA1= 0.0
      IF (CPARA1.GT.1.0) CPARA1= 1.0
      RDATA(2)= CPARA1
      RDATA(3)= CPARA2
      RDATA(4)= CPARA3
C
   12 IF (NCOLS0.LT.NCOLOR) NCOLS0= NCOLOR
      REDCO0(NCOLOR)= RDATA(2)
      GRNCO0(NCOLOR)= RDATA(3)
      BLUCO0(NCOLOR)= RDATA(4)
C
      CALL G3LINK(5,1,4*NBYTR,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE CONLBL(LABELS,NLABLS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 120)   VERSION (A8.1)    10:OCT:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS STORES CONTOUR LABELS
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [LABELS] CONTAINS THE LABELS TO BE WRITTEN ON THE CONTOURS.
C          <NLABLS> IS THE NUMBER OF LABELS.
C
C
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CNLB/ LBLCON(10,50)
      COMMON /T0TRAC/ IPRINT
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(176,0)
C
      LLBCON= NLABLS
      IF (LLBCON.LT.0) LLBCON= 0
      IF (LLBCON.EQ.0) RETURN
      IF (LLBCON.GT.50) LLBCON= 50
C
      LENLAB= LEN(LABELS(1))
      IF (LENLAB.GT.40) LENLAB= 40
C
      IPOS= 0
      LIMIT= NMCHI*10
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 NOLAB= 1,LLBCON
        DO 200 ISET= 1,LIMIT
          IPOS= IPOS+1
          NCHAR= ISPAC
          IF (ISET.LE.LENLAB) NCHAR= ICHAR(LABELS(NOLAB)(ISET:ISET))
C
          CALL G4PUTK(LBLCON,IPOS,NBITMC,NMCHI,NCHAR)
  200   CONTINUE
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE CONOTA(NOTAT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 120)   VERSION (A8.2)    14:OCT:86
C          ------------------------------------------------
C
C          THIS ENABLES AND DISABLES SUBSEQUENT CONTOUR ANNOTATION.
C
C
C          <NOTAT>  SETS ANNOTATION CONTROL:
C                   =  0, TO DO NO ANNOTATION
C                   =  1, TO DO FULL ANNOTATION
C                   =  2, TO ANNOTATE INTERNAL CONTOURS ONLY
C                   =  4, TO ANNOTATE LEFT HAND EDGE ONLY
C                   =  8, TO ANNOTATE RIGHT HAND EDGE ONLY
C                   = 16, TO ANNOTATE TOP EDGE ONLY
C                   = 32, TO ANNOTATE BOTTOM EDGE ONLY.
C
C
      COMMON /T0NOTC/ NOTATC
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= NOTAT
      IF (IPRINT.EQ.1) CALL G0MESG(70,5)
C
      NOTATC= NOTAT
      IF (NOTATC.LT.0.OR.NOTATC.EQ.1.OR.NOTATC.GT.62) NOTATC= 62
C
      RETURN
      END
      SUBROUTINE CONTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL,XGRIDS,YGRIDS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 123)   VERSION (A8.8)    15:MAY:87
C          ------------------------------------------------
C
C          THIS DRAWS CURVED CONTOURS ON AN IRREGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C          [XGRIDS]  ARE THE GRID X-POSITIONS.
C          [YGRIDS]  ARE THE GRID Y-POSITIONS.
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),
     &        XGRIDS(NPTSX),YGRIDS(NPTSY)
      LOGICAL OPENCO,ERRON,CURVED
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,192),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0CURV/ MCURV0
      COMMON /T0CWID/ CWIDX,CWIDY
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA NBITSW /32/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(48,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENX.GT.192)         GO TO 901
      IF (ILENY.LT.1.OR.ILENY.GT.192)         GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG, THE CURVE METHOD AND THE
C          CHARACTER MAGNIFICATION ARE SAVED, THEN TRACE IS
C          DISABLED, CURVE METHOD (1) SET AND MAGN. (6) SET.
C
      IPRSAV= IPRINT
      MTSAVE= MCURV0
      IPRINT= 0
      MCURV0= 1
      CURVED= .TRUE.
      ANGSAV= STANG0
      UNSAVE= ANGCON
      ANGCON= 1.0
      IF (LLBCON.GT.0) CALL CTRORI(0.5)
C
      CALL G0AUTO(XGRIDS,YGRIDS,ISTRTX,ISTOPX,ISTRTY,ISTOPY,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      CWIDX= (X2WND0-X1WND0)/(ISTOPX-ISTRTX)
      CWIDY= (Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
C
C          TO BEGIN WITH, SOME CONSTANTS ARE SET UP.
C
      ISTRX1= ISTRTX+1
      ISTRY1= ISTRTY+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
C          LOOP-100 DOES ALL THE CONTOURS AT EACH HEIGHT IN TURN.
C          THE BIT ARRAY <MAPBIT> IS INITIALISED FOR EACH HEIGHT,
C          ELEMENTS BEING SET TO '1' WHEN A CONTOUR LINE OF THE
C          CURRENT HEIGHT CROSSES AN EDGE IN AN UPWARDS DIRECTION
C          PROVIDED 'HIGH GROUND' LIES TO THE RIGHT OF THE LINE.
C
      DO 100 LEVELH= ISTRTL,ISTOPL
        HEIGHT= CLEVLS(LEVELH)
        LEVEL= LEVELH
C
        DO 200 ISTPTY= ISTRY1,ISTPY1
          DO 200 ISTPTX= ISTRX1,ISTOPX
            IBIT= 0
            IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &          SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)     IBIT= 1
C
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4PUTB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
  200   CONTINUE
C
C          <OPENCO> IS INITIALISED AND A SEARCH FOR OPEN
C          CONTOURS BEGINNING ON EACH EDGE IS MADE IN TURN:
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTRTY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        OPENCO= .TRUE.
        ISTPTY=  ISTRTY
C
        DO 300 ISTPTX= ISTRX1,ISTOPX
          IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,-1,0)
  300   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTOPX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTX= ISTOPX
C
        DO 400 ISTPTY= ISTRY1,ISTOPY
          IF (SURFAS(ISTPTX,ISTPTY-1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,0,-1)
  400   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTOPY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTY= ISTOPY
C
        DO 500 NEGIX= ISTRTX,ISTPX1
          ISTPTX= ISTPX1+ISTRTX-NEGIX
          IF (SURFAS(ISTPTX+1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,1,0)
  500   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTRTX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTX= ISTRTX
C
        DO 600 NEGIY= ISTRTY,ISTPY1
          ISTPTY= ISTPY1+ISTRTY-NEGIY
          IF (SURFAS(ISTPTX,ISTPTY+1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,0,1)
  600   CONTINUE
C
C          A SEARCH IS MADE FOR CLOSED CONTOURS. <OPENCO> IS
C          SET TO .FALSE. AND <MAPBIT> IS SCANNED: IF THE
C          ELEMENT (ISTPTX,ISTPTY) IS '1', A CLOSED CONTOUR
C          STARTS FROM THE LINE JOINING (ISTPTX-1,ISTPTY) TO
C          (ISTPTX,ISTPTY) AND IT IS FOLLOWED USING <G0CTIA>.
C
        OPENCO= .FALSE.
C
        DO 700 NEGIY= ISTRY1,ISTPY1
          ISTPTY= ISTOPY+ISTRTY-NEGIY
C
          DO 700 NEGIX= ISTRTX,ISTPX1
            ISTPTX= ISTOPX+ISTRTX-NEGIX
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4GETB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
            IF (IBIT.EQ.1)
     &              CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,
     &                          ISTOPY,NPTSY,XGRIDS,YGRIDS,-1,0)
  700   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      MCURV0= MTSAVE
      CALL CTRORI(ANGSAV)
      ANGCON= UNSAVE
      IPRINT= IPRSAV
      RETURN
C
 901  NUMERR= 11
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CONTIF(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL,XGRIDS,YGRIDS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 184)   VERSION (A8.1)    24:APR:91
C          ------------------------------------------------
C
C          THIS COLOURS OR HATCHES THE AREAS BETWEEN
C          STRAIGHT-ELEMENT CONTOURS ON AN IRREGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C          [XGRIDS]  ARE THE GRID X-POSITIONS.
C          [YGRIDS]  ARE THE GRID Y-POSITIONS.
C
C
C          EACH MESH ELEMENT IS DIVIDED AS FOLLOWS:
C
C               A  ------------------- B
C                  |\               /|
C                  | \             / |
C                  |  \           /  |
C                  |   \         /   |
C                  |    \       /    |
C                  |     \     /     |
C                  |      \   /      |
C                  |       \ /       |
C                  |      E /        |
C                  |       / \       |
C                  |      /   \      |
C                  |     /     \     |
C                  |    /       \    |
C                  |   /         \   |
C                  |  /           \  |
C                  | /             \ |
C                  |/               \|
C               C  -------------------  D
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),
     &        XGRIDS(NPTSX),YGRIDS(NPTSY)
      LOGICAL ERRON
      LOGICAL JOIN
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA DUM /0.0/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(28,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENY.LT.1)           GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG AND THE BOUNDARY DRAWING
C          FLAG ARE SAVED AND SET TO ZERO.
C
      IPRSAV= IPRINT
      IPRINT= 0
      CALL G0AUTO(XGRIDS,YGRIDS,ISTRTX,ISTOPX,ISTRTY,ISTOPY,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      KOUNT= 1
      NLEVEL= ISTOPL-ISTRTL+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
      DO 100 ISTPTY= ISTRTY,ISTPY1
        YA= YGRIDS(ISTPTY+1)
        YD= YGRIDS(ISTPTY)
        JOIN= .FALSE.
C
        DO 200 ISTPTX= ISTRTX,ISTPX1
          XA= XGRIDS(ISTPTX)
          XD= XGRIDS(ISTPTX+1)
          VA= SURFAS(ISTPTX,ISTPTY+1)
          VB= SURFAS(ISTPTX+1,ISTPTY+1)
          VC= SURFAS(ISTPTX,ISTPTY)
          VD= SURFAS(ISTPTX+1,ISTPTY)
C
C          TEST TO SEE IF THE RECTANGLE NEEDS JUST ONE COLOUR.
C
          VHI= AMAX1(VA,VB,VC,VD)
          VLO= AMIN1(VA,VB,VC,VD)
          CALL G0CFL4(VHI,VLO,CLEVLS,ISTRTL,ISTOPL,NINTS)
          IF (NINTS.NE.0) GO TO 2
C
C          THE RECTANGLE IS ALL THE SAME COLOUR.
C          TEST TO SEE IF IT CAN BE JOINED TO THE PREVIOUS RECTANGLE.
C
          IF (JOIN) GO TO 1
C
C          START OF NEW RECTANGLE GROUP.  FIND THE COLOUR TO USE.
C
          INDCL= 1
C
          DO 300 K= ISTRTL,ISTOPL
            IF (VLO.GT.CLEVLS(K)) INDCL= INDCL+1
  300     CONTINUE
C
          XASAV= XA
          JOIN= .TRUE.
C
C          IS THIS THE LAST RECTANGLE OF THE ROW?
C
    1     IF (ISTPTX.LT.ISTPX1) GO TO 200
C
          XA= XD
C
C          THIS IS EITHER THE LAST RECTANGLE OF THE ROW
C          OR THE RECTANGLE IS NOT ALL THE SAME COLOUR.
C
    2     IF (.NOT.JOIN) GO TO 3
C
C          IF THIS IS THE LAST RECTANGLE OF THE ROW OR A
C          RECTANGLE HAS BEEN SAVED, THEN FILL THE RECTANGLE.
C
          CALL G0CFL5(INDCL,4,XASAV,XA,XA,XASAV,DUM,YA,YA,YD,YD,DUM)
          JOIN= .FALSE.
          IF (NINTS.EQ.0) GO TO 200
C
C          EXAMINE EACH TRIANGLE IN TURN.
C
    3     VE= 0.25*(VA+VB+VC+VD)
          XE= 0.5*(XA+XD)
          YE= 0.5*(YA+YD)
          CALL G0CFL1(XA,XA,XE,YD,YA,YE,VC,VA,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XA,XD,XE,YA,YA,YE,VA,VB,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XD,XD,XE,YA,YD,YE,VB,VD,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XD,XA,XE,YD,YD,YE,VD,VC,VE,CLEVLS,ISTRTL,ISTOPL)
  200   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 41
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CONTIL(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL,XGRIDS,YGRIDS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 124)   VERSION (A8.8)    15:MAY:87
C          ------------------------------------------------
C
C          THIS DRAWS STRAIGHT-ELEMENT CONTOURS ON AN IRREGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C          [XGRIDS]  ARE THE GRID X-POSITIONS.
C          [YGRIDS]  ARE THE GRID Y-POSITIONS.
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),
     &        XGRIDS(NPTSX),YGRIDS(NPTSY)
      LOGICAL OPENCO,ERRON,CURVED
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,192),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0CWID/ CWIDX,CWIDY
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA NBITSW /32/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(48,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENX.GT.192)         GO TO 901
      IF (ILENY.LT.1.OR.ILENY.GT.192)         GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG, THE CURVE METHOD AND THE
C          CHARACTER MAGNIFICATION ARE SAVED, THEN TRACE IS
C          DISABLED, CURVE METHOD (1) SET AND MAGN. (6) SET.
C
      IPRSAV= IPRINT
      IPRINT= 0
      CURVED= .FALSE.
      ANGSAV= STANG0
      UNSAVE= ANGCON
      ANGCON= 1.0
      IF (LLBCON.GT.0) CALL CTRORI(0.5)
C
      CALL G0AUTO(XGRIDS,YGRIDS,ISTRTX,ISTOPX,ISTRTY,ISTOPY,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      CWIDX= (X2WND0-X1WND0)/(ISTOPX-ISTRTX)
      CWIDY= (Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
C
C          TO BEGIN WITH, SOME CONSTANTS ARE SET UP.
C
      ISTRX1= ISTRTX+1
      ISTRY1= ISTRTY+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
C          LOOP-100 DOES ALL THE CONTOURS AT EACH HEIGHT IN TURN.
C          THE BIT ARRAY <MAPBIT> IS INITIALISED FOR EACH HEIGHT,
C          ELEMENTS BEING SET TO '1' WHEN A CONTOUR LINE OF THE
C          CURRENT HEIGHT CROSSES AN EDGE IN AN UPWARDS DIRECTION
C          PROVIDED 'HIGH GROUND' LIES TO THE RIGHT OF THE LINE.
C
      DO 100 LEVELH= ISTRTL,ISTOPL
        HEIGHT= CLEVLS(LEVELH)
        LEVEL= LEVELH
C
        DO 200 ISTPTY= ISTRY1,ISTPY1
          DO 200 ISTPTX= ISTRX1,ISTOPX
            IBIT= 0
            IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &          SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)     IBIT= 1
C
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4PUTB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
  200   CONTINUE
C
C          <OPENCO> IS INITIALISED AND A SEARCH FOR OPEN
C          CONTOURS BEGINNING ON EACH EDGE IS MADE IN TURN:
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTRTY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        OPENCO= .TRUE.
        ISTPTY=  ISTRTY
C
        DO 300 ISTPTX= ISTRX1,ISTOPX
          IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,-1,0)
  300   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTOPX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTX= ISTOPX
C
        DO 400 ISTPTY= ISTRY1,ISTOPY
          IF (SURFAS(ISTPTX,ISTPTY-1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,0,-1)
  400   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTOPY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTY= ISTOPY
C
        DO 500 NEGIX= ISTRTX,ISTPX1
          ISTPTX= ISTPX1+ISTRTX-NEGIX
          IF (SURFAS(ISTPTX+1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,1,0)
  500   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTRTX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTIA>.
C
        ISTPTX= ISTRTX
C
        DO 600 NEGIY= ISTRTY,ISTPY1
          ISTPTY= ISTPY1+ISTRTY-NEGIY
          IF (SURFAS(ISTPTX,ISTPTY+1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,XGRIDS,YGRIDS,0,1)
  600   CONTINUE
C
C          A SEARCH IS MADE FOR CLOSED CONTOURS. <OPENCO> IS
C          SET TO .FALSE. AND <MAPBIT> IS SCANNED: IF THE
C          ELEMENT (ISTPTX,ISTPTY) IS '1', A CLOSED CONTOUR
C          STARTS FROM THE LINE JOINING (ISTPTX-1,ISTPTY) TO
C          (ISTPTX,ISTPTY) AND IT IS FOLLOWED USING <G0CTIA>.
C
        OPENCO= .FALSE.
C
        DO 700 NEGIY= ISTRY1,ISTPY1
          ISTPTY= ISTOPY+ISTRTY-NEGIY
C
          DO 700 NEGIX= ISTRTX,ISTPX1
            ISTPTX= ISTOPX+ISTRTX-NEGIX
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4GETB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
            IF (IBIT.EQ.1)
     &              CALL G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,
     &                          ISTOPY,NPTSY,XGRIDS,YGRIDS,-1,0)
  700   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      CALL CTRORI(ANGSAV)
      ANGCON= UNSAVE
      IPRINT= IPRSAV
      RETURN
C
 901  NUMERR= 11
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CONTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 121)   VERSION (A8.8)    15:MAY:87
C          ------------------------------------------------
C
C          THIS DRAWS CURVED CONTOURS ON A REGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),ARG(2)
      LOGICAL OPENCO,ERRON,CURVED
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,192),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0CURV/ MCURV0
      COMMON /T0CWID/ CWIDX,CWIDY
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA NBITSW /32/, ARG /0.0,1.0/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(48,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENX.GT.192)         GO TO 901
      IF (ILENY.LT.1.OR.ILENY.GT.192)         GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG, THE CURVE METHOD AND THE
C          CHARACTER MAGNIFICATION ARE SAVED, THEN TRACE IS
C          DISABLED, CURVE METHOD (1) SET AND MAGN. (6) SET.
C
      IPRSAV= IPRINT
      MTSAVE= MCURV0
      IPRINT= 0
      MCURV0= 1
      CURVED= .TRUE.
      ANGSAV= STANG0
      UNSAVE= ANGCON
      ANGCON= 1.0
      IF (LLBCON.GT.0) CALL CTRORI(0.5)
C
      CALL G0AUTO(ARG,ARG,1,2,1,2,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      CWIDX= (X2WND0-X1WND0)/(ISTOPX-ISTRTX)
      CWIDY= (Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
C
C          TO BEGIN WITH, SOME CONSTANTS ARE SET UP.
C
      ISTRX1= ISTRTX+1
      ISTRY1= ISTRTY+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
C          LOOP-100 DOES ALL THE CONTOURS AT EACH HEIGHT IN TURN.
C          THE BIT ARRAY <MAPBIT> IS INITIALISED FOR EACH HEIGHT,
C          ELEMENTS BEING SET TO '1' WHEN A CONTOUR LINE OF THE
C          CURRENT HEIGHT CROSSES AN EDGE IN AN UPWARDS DIRECTION
C          PROVIDED 'HIGH GROUND' LIES TO THE RIGHT OF THE LINE.
C
      DO 100 LEVELH= ISTRTL,ISTOPL
        HEIGHT= CLEVLS(LEVELH)
        LEVEL= LEVELH
C
        DO 200 ISTPTY= ISTRY1,ISTPY1
          DO 200 ISTPTX= ISTRX1,ISTOPX
            IBIT= 0
            IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &          SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)     IBIT= 1
C
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4PUTB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
  200   CONTINUE
C
C          <OPENCO> IS INITIALISED AND A SEARCH FOR OPEN
C          CONTOURS BEGINNING ON EACH EDGE IS MADE IN TURN:
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTRTY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        OPENCO= .TRUE.
        ISTPTY=  ISTRTY
C
        DO 300 ISTPTX= ISTRX1,ISTOPX
          IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,-1,0)
  300   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTOPX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTX= ISTOPX
C
        DO 400 ISTPTY= ISTRY1,ISTOPY
          IF (SURFAS(ISTPTX,ISTPTY-1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,0,-1)
  400   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTOPY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTY= ISTOPY
C
        DO 500 NEGIX= ISTRTX,ISTPX1
          ISTPTX= ISTPX1+ISTRTX-NEGIX
          IF (SURFAS(ISTPTX+1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,1,0)
  500   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTRTX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTX= ISTRTX
C
        DO 600 NEGIY= ISTRTY,ISTPY1
          ISTPTY= ISTPY1+ISTRTY-NEGIY
          IF (SURFAS(ISTPTX,ISTPTY+1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,0,1)
  600   CONTINUE
C
C          A SEARCH IS MADE FOR CLOSED CONTOURS. <OPENCO> IS
C          SET TO .FALSE. AND <MAPBIT> IS SCANNED: IF THE
C          ELEMENT (ISTPTX,ISTPTY) IS '1', A CLOSED CONTOUR
C          STARTS FROM THE LINE JOINING (ISTPTX-1,ISTPTY) TO
C          (ISTPTX,ISTPTY) AND IT IS FOLLOWED USING <G0CTRA>.
C
        OPENCO= .FALSE.
C
        DO 700 NEGIY= ISTRY1,ISTPY1
          ISTPTY= ISTOPY+ISTRTY-NEGIY
C
          DO 700 NEGIX= ISTRTX,ISTPX1
            ISTPTX= ISTOPX+ISTRTX-NEGIX
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4GETB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
            IF (IBIT.EQ.1)
     &              CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,
     &                          ISTOPY,NPTSY,-1,0)
  700   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      MCURV0= MTSAVE
      CALL CTRORI(ANGSAV)
      ANGCON= UNSAVE
      IPRINT= IPRSAV
      RETURN
C
 901  NUMERR= 11
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CONTRF(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 183)   VERSION (A8.1)    22:APR:91
C          ------------------------------------------------
C
C          THIS COLOURS OR HATCHES THE AREAS BETWEEN
C          STRAIGHT-ELEMENT CONTOURS ON A REGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C
C
C          EACH MESH ELEMENT IS DIVIDED AS FOLLOWS:
C
C               A  ------------------- B
C                  |\               /|
C                  | \             / |
C                  |  \           /  |
C                  |   \         /   |
C                  |    \       /    |
C                  |     \     /     |
C                  |      \   /      |
C                  |       \ /       |
C                  |      E /        |
C                  |       / \       |
C                  |      /   \      |
C                  |     /     \     |
C                  |    /       \    |
C                  |   /         \   |
C                  |  /           \  |
C                  | /             \ |
C                  |/               \|
C               C  -------------------  D
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),ARG(2)
      LOGICAL ERRON
      LOGICAL JOIN
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA DUM /0.0/, ARG /0.0,1.0/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(27,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENY.LT.1)           GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG AND THE BOUNDARY DRAWING
C          FLAG ARE SAVED AND SET TO ZERO.
C
      IPRSAV= IPRINT
      IPRINT= 0
      CALL G0AUTO(ARG,ARG,1,2,1,2,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      KOUNT= 1
      NLEVEL= ISTOPL-ISTRTL+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
      DO 100 ISTPTY= ISTRTY,ISTPY1
        YA= Y1WND0+(ISTPTY-ISTRTY+1)*(Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
        YD= Y1WND0+(ISTPTY-ISTRTY)*(Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
        JOIN= .FALSE.
C
        DO 200 ISTPTX= ISTRTX,ISTPX1
          XA= X1WND0+(ISTPTX-ISTRTX)*(X2WND0-X1WND0)/(ISTOPX-ISTRTX)
          XD= X1WND0+(ISTPTX-ISTRTX+1)*(X2WND0-X1WND0)/(ISTOPX-ISTRTX)
          VA= SURFAS(ISTPTX,ISTPTY+1)
          VB= SURFAS(ISTPTX+1,ISTPTY+1)
          VC= SURFAS(ISTPTX,ISTPTY)
          VD= SURFAS(ISTPTX+1,ISTPTY)
C
C          TEST TO SEE IF THE RECTANGLE NEEDS JUST ONE COLOUR.
C
          VHI= AMAX1(VA,VB,VC,VD)
          VLO= AMIN1(VA,VB,VC,VD)
          CALL G0CFL4(VHI,VLO,CLEVLS,ISTRTL,ISTOPL,NINTS)
          IF (NINTS.NE.0) GO TO 2
C
C          THE RECTANGLE IS ALL THE SAME COLOUR.
C          TEST TO SEE IF IT CAN BE JOINED TO THE PREVIOUS RECTANGLE.
C
          IF (JOIN) GO TO 1
C
C          START OF NEW RECTANGLE GROUP.  FIND THE COLOUR TO USE.
C
          INDCL= 1
C
          DO 300 K= ISTRTL,ISTOPL
            IF (VLO.GT.CLEVLS(K)) INDCL= INDCL+1
  300     CONTINUE
C
          XASAV= XA
          JOIN= .TRUE.
C
C          IS THIS THE LAST RECTANGLE OF THE ROW?
C
    1     IF (ISTPTX.LT.ISTPX1) GO TO 200
C
          XA= XD
C
C          THIS IS EITHER THE LAST RECTANGLE OF THE ROW
C          OR THE RECTANGLE IS NOT ALL THE SAME COLOUR.
C
    2     IF (.NOT.JOIN) GO TO 3
C
C          IF THIS IS THE LAST RECTANGLE OF THE ROW OR A
C          RECTANGLE HAS BEEN SAVED, THEN FILL THE RECTANGLE.
C
          CALL G0CFL5(INDCL,4,XASAV,XA,XA,XASAV,DUM,YA,YA,YD,YD,DUM)
          JOIN= .FALSE.
          IF (NINTS.EQ.0) GO TO 200
C
C          EXAMINE EACH TRIANGLE IN TURN.
C
    3     VE= 0.25*(VA+VB+VC+VD)
          XE= 0.5*(XA+XD)
          YE= 0.5*(YA+YD)
          CALL G0CFL1(XA,XA,XE,YD,YA,YE,VC,VA,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XA,XD,XE,YA,YA,YE,VA,VB,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XD,XD,XE,YA,YD,YE,VB,VD,VE,CLEVLS,ISTRTL,ISTOPL)
          CALL G0CFL1(XD,XA,XE,YD,YD,YE,VD,VC,VE,CLEVLS,ISTRTL,ISTOPL)
  200   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 40
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CONTRL(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  CLEVLS,ISTRTL,ISTOPL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 122)   VERSION (A8.8)    15:MAY:87
C          ------------------------------------------------
C
C          THIS DRAWS STRAIGHT-ELEMENT CONTOURS ON A REGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDIMG Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          [CLEVLS]  CONTAINS THE VALUES OF CONTOUR HEIGHTS,
C          <ISTRTL>  IS THE STARTING POINT, AND
C          <ISTOPL>  IS THE END POINT OF THIS ARRAY.
C
C
      REAL    SURFAS(NPTSX,NPTSY),CLEVLS(ISTOPL),ARG(2)
      LOGICAL OPENCO,ERRON,CURVED
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,192),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0CWID/ CWIDX,CWIDY
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA NBITSW /32/, ARG /0.0,1.0/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(48,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENX.GT.192)         GO TO 901
      IF (ILENY.LT.1.OR.ILENY.GT.192)         GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
      IF (ISTRTL.LT.1.OR.ISTRTL.GT.ISTOPL)    RETURN
C
C          THE ROUTE-TRACING FLAG, THE CURVE METHOD AND THE
C          CHARACTER MAGNIFICATION ARE SAVED, THEN TRACE IS
C          DISABLED, CURVE METHOD (1) SET AND MAGN. (6) SET.
C
      IPRSAV= IPRINT
      IPRINT= 0
      CURVED= .FALSE.
      ANGSAV= STANG0
      UNSAVE= ANGCON
      ANGCON= 1.0
      IF (LLBCON.GT.0) CALL CTRORI(0.5)
C
      CALL G0AUTO(ARG,ARG,1,2,1,2,1)
      XHERE= XPLOT0
      YHERE= YPLOT0
      CWIDX= (X2WND0-X1WND0)/(ISTOPX-ISTRTX)
      CWIDY= (Y2WND0-Y1WND0)/(ISTOPY-ISTRTY)
C
C          TO BEGIN WITH, SOME CONSTANTS ARE SET UP.
C
      ISTRX1= ISTRTX+1
      ISTRY1= ISTRTY+1
      ISTPX1= ISTOPX-1
      ISTPY1= ISTOPY-1
C
C          LOOP-100 DOES ALL THE CONTOURS AT EACH HEIGHT IN TURN.
C          THE BIT ARRAY <MAPBIT> IS INITIALISED FOR EACH HEIGHT,
C          ELEMENTS BEING SET TO '1' WHEN A CONTOUR LINE OF THE
C          CURRENT HEIGHT CROSSES AN EDGE IN AN UPWARDS DIRECTION
C          PROVIDED 'HIGH GROUND' LIES TO THE RIGHT OF THE LINE.
C
      DO 100 LEVELH= ISTRTL,ISTOPL
        HEIGHT= CLEVLS(LEVELH)
        LEVEL= LEVELH
C
        DO 200 ISTPTY= ISTRY1,ISTPY1
          DO 200 ISTPTX= ISTRX1,ISTOPX
            IBIT= 0
            IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &          SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)     IBIT= 1
C
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4PUTB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
  200   CONTINUE
C
C          <OPENCO> IS INITIALISED AND A SEARCH FOR OPEN
C          CONTOURS BEGINNING ON EACH EDGE IS MADE IN TURN:
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTRTY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        OPENCO= .TRUE.
        ISTPTY=  ISTRTY
C
        DO 300 ISTPTX= ISTRX1,ISTOPX
          IF (SURFAS(ISTPTX-1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,-1,0)
  300   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTOPX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTX= ISTOPX
C
        DO 400 ISTPTY= ISTRY1,ISTOPY
          IF (SURFAS(ISTPTX,ISTPTY-1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,0,-1)
  400   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTY>= <ISTOPY>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTY= ISTOPY
C
        DO 500 NEGIX= ISTRTX,ISTPX1
          ISTPTX= ISTPX1+ISTRTX-NEGIX
          IF (SURFAS(ISTPTX+1,ISTPTY).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,1,0)
  500   CONTINUE
C
C          CONTOURS BEGINNING ON THE EDGE <ISTPTX>= <ISTRTX>
C          ARE FOUND, THEN FOLLOWED AND DRAWN USING <G0CTRA>.
C
        ISTPTX= ISTRTX
C
        DO 600 NEGIY= ISTRTY,ISTPY1
          ISTPTY= ISTPY1+ISTRTY-NEGIY
          IF (SURFAS(ISTPTX,ISTPTY+1).LT.HEIGHT.AND.
     &        SURFAS(ISTPTX,  ISTPTY).GE.HEIGHT)
     &        CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,
     &                    NPTSY,0,1)
  600   CONTINUE
C
C          A SEARCH IS MADE FOR CLOSED CONTOURS. <OPENCO> IS
C          SET TO .FALSE. AND <MAPBIT> IS SCANNED: IF THE
C          ELEMENT (ISTPTX,ISTPTY) IS '1', A CLOSED CONTOUR
C          STARTS FROM THE LINE JOINING (ISTPTX-1,ISTPTY) TO
C          (ISTPTX,ISTPTY) AND IT IS FOLLOWED USING <G0CTRA>.
C
        OPENCO= .FALSE.
C
        DO 700 NEGIY= ISTRY1,ISTPY1
          ISTPTY= ISTOPY+ISTRTY-NEGIY
C
          DO 700 NEGIX= ISTRTX,ISTPX1
            ISTPTX= ISTOPX+ISTRTX-NEGIX
            IXWRD= (ISTPTX-ISTRX1)/NBITSW+1
            IXBIT= MOD((ISTPTX-ISTRX1),NBITSW)+1
            CALL G4GETB(MAPBIT(IXWRD,(ISTPTY-ISTRTY)),IXBIT,IBIT)
            IF (IBIT.EQ.1)
     &              CALL G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,
     &                          ISTOPY,NPTSY,-1,0)
  700   CONTINUE
  100 CONTINUE
C
C          THE ENTRY STATE IS ALWAYS RESTORED BEFORE ENDING.
C
      CALL POSITN(XHERE,YHERE)
      CALL CTRORI(ANGSAV)
      ANGCON= UNSAVE
      IPRINT= IPRSAV
      RETURN
C
 901  NUMERR= 11
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE COORDS(XPOS,YPOS,ICHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1042)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS INVOKES THE DISPLAY CURSOR.
C
C
C          THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <XPOS>   IS THE X-POSITION IN ND-SPACE UNITS,
C          <YPOS>   IS THE Y-POSITION IN ND-SPACE UNITS,
C          <ICHAR>  IS THE REPLY CHARACTER NO.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3MODE/ KMODE
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (KMODE.NE.2)  GO TO 1
C
C          IF DEVICE-MODE WORKING IS NOT POSSIBLE, THE
C          PRE-PROCESSOR ND-SPACE POSITION IS GIVEN.
C          THE REPLY CHARACTER IS AN EXCLAMATION MARK.
C
      CALL G0MAPP(XPLOT0,YPLOT0,XPOS,YPOS)
      ICHAR= 33
      RETURN
C
C          OTHERWISE, THE DEVICE BUFFERS ARE CLEARED,
C          THE CURSOR IS INVOKED AND THE POSITION READ.
C
    1 CALL G3LINK(3,10,0,IDATA,RDATA)
      CALL G3GRIN(1,DUMMY,DUMMY,DUMMY,DUMMY,IDUMMY)
      CALL G3GRIN(2,DUMMY,DUMMY,XPOS,YPOS,ICHAR)
C
      RETURN
      END
      SUBROUTINE CRETRN
C
C          ------------------------------------------------
C          ROUTINE NO. ( 180)   VERSION (A8.4)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DOES A CARRIAGE-RETURN IN CHARACTER SPACE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/, IDATA /9,1/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(121,0)
      IF (ABS(X2CHR0-X1CHR0).LT.RMINI.OR.
     &    ABS(Y2CHR0-Y1CHR0).LT.RMINI) GO TO 901
C
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 27
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CRLNFD
C
C          ------------------------------------------------
C          ROUTINE NO. ( 157)   VERSION (A8.4)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DOES 'CARRIAGE-RETURN, LINEFEED' IN CHARACTER SPACE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(68,0)
      IF (ABS(X2CHR0-X1CHR0).LT.RMINI.OR.
     &    ABS(Y2CHR0-Y1CHR0).LT.RMINI) GO TO 901
C
      IDATA(1)= 9
      IDATA(2)= 1
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IDATA(1)= 5
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 28
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE CTRSLP(SLOP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 145)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CHARACTER LINE SLOPE.
C
C          <SLOP>   IS THE TANGENT OF THE ANGLE TO THE HORIZONTAL.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CSLO/ SLOPE,MRKSLP
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= SLOP
      IF (IPRINT.EQ.1) CALL G0MESG(56,1)
C
      SLOPE= SLOP
      STANG0= ATAN(SLOPE*(X2MAP0-X1MAP0)/(Y2MAP0-Y1MAP0))
      RDATA(1)= STANG0
      CALL G3LINK(2,4,NBYTR,IDATA,RDATA)
      MRKSLP= 1
C
      RETURN
      END
      SUBROUTINE CURVEC(XPT,YPT,LIMLO,LIMHI)
C
C          ------------------------------------------------
C          ROUTINE NO. (  91)   VERSION (A8.6)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A CLOSED CURVE THROUGH A SET OF POINTS.
C
C
C          THE ARGUMENTS ARE:
C
C          [XPT]    ARE THE X-COORDINATES AND
C          [YPT]    ARE THE Y-COORDINATES OF THE DATA POINTS,
C          <LIMLO>  IS THE LOWER LIMIT, AND
C          <LIMHI>  IS THE UPPER LIMIT OF THE POINTS IN THE ARRAYS.
C
C
      REAL    XPT(LIMHI),YPT(LIMHI),RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(34,0)
C
C          AUTOMATIC MAPPING WILL BE DONE IF NECESSARY.
C
      CALL G0AUTO(XPT,YPT,LIMLO,LIMHI,LIMLO,LIMHI,0)
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL G0CURV(XPT,YPT,LIMLO,LIMHI,1)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) GO TO 2
C
    1 CALL G0CURV(XPT,YPT,LIMLO,LIMHI,1)
    2 XPLOT0= XPT(LIMLO)
      YPLOT0= YPT(LIMLO)
C
      RETURN
      END
      SUBROUTINE CURVEM(METHOD)
C
C          ------------------------------------------------
C          ROUTINE NO. (  93)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURVE DRAWING METHOD WHICH IS USED.
C
C
C          <METHOD> = 1 FOR A ROTATIONALLY INVARIANT CURVE.
C                   = 2 FOR A SINGLE VALUED CURVE
C                       FROM SINGLE VALUED DATA.
C
C
      LOGICAL ERRON
C
      COMMON /T0CURV/ MCURV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      CALL G3INIT(2)
C
      ITRAC1= METHOD
      IF (IPRINT.EQ.1) CALL G0MESG(36,5)
C
      IF (METHOD.LT.1.OR.METHOD.GT.2) GO TO 901
C
      MCURV0= METHOD
      RETURN
C
  901 NUMERR= 10
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE DEFPEN
C
C          ------------------------------------------------
C          ROUTINE NO. (  70)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE PEN COLOUR TO ITS DEFAULT VALUE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0TRAC/ IPRINT
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(139,0)
C
      KOLIN0= 0
      CALL G3LINK(3,9,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE DEGREE
C
C          ------------------------------------------------
C          ROUTINE NO. (  35)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT ANGLE TYPE TO DEGREES.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(19,0)
C
      ANGCON= PI/180.0
      RETURN
      END
      SUBROUTINE DEVOFF
C
C          ------------------------------------------------
C          ROUTINE NO. ( 301)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DISABLES THE OUTPUT DEVICE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL GFOPEN,PPOPEN
C
      COMMON /T3OUTS/ GFOPEN,PPOPEN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
      CALL G3LINK(3,10,0,IDATA,RDATA)
      PPOPEN= .FALSE.
C
      RETURN
      END
      SUBROUTINE DEVON
C
C          ------------------------------------------------
C          ROUTINE NO. ( 302)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS ENABLES THE OUTPUT DEVICE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL GFOPEN,PPOPEN
C
      COMMON /T3OUTS/ GFOPEN,PPOPEN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
      CALL G3LINK(3,10,0,IDATA,RDATA)
      PPOPEN= .TRUE.
C
      RETURN
      END
      SUBROUTINE ELLPSE(AXMAJR,AXMINR)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 101)   VERSION (A8.5)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS AN ELLIPSE CENTRED ON
C          THE CURRENT PLOTTING POSITION.
C
C
C          <AXMAJR>  IS 1/2 THE LENGTH OF THE MAJOR AXIS.
C          <AXMINR>  IS 1/2 THE LENGTH OF THE MINOR AXIS.
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0,0.0/, IDATA /0/
C
C
      RTRAC1= AXMAJR
      RTRAC2= AXMINR
      IF (IPRINT.EQ.1) CALL G0MESG(43,2)
C
C          CORRECTION IS MADE FOR DIFFERENT
C          SCALING ON THE X AND Y AXES.
C
      RDATA(1)= ABS(AXMAJR)
      RDATA(2)= ABS(AXMINR)
      RDATA(2)= RDATA(1)*(Y2MAP0-Y1MAP0)/(RDATA(2)*(X2MAP0-X1MAP0))
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL G3LINK(0,8,2*NBYTR,IDATA,RDATA)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) RETURN
C
    1 CALL G3LINK(0,8,2*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE ENDBUF
C
C          ------------------------------------------------
C          ROUTINE NO. (  13)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C
C          THIS RESTORES GRAPHICAL OUTPUT TO THE MAIN STREAM.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0TRAC/ IPRINT
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(115,0)
C
      KBUFR0= 0
      CALL G3LINK(4,2,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE ENQAXI(IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 258)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE CURRENT AXES PARAMETERS.
C
C
      REAL    RPARAM(8)
      INTEGER IPARAM(6)
C
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATYP/ KTYPEX,KTYPEY
C
C
      IF (KTYPEX.EQ.2) GO TO 1
      NTIKSX= NTIKHX-NTIKLX+1
      NSPECX= NSKIPX
      STRTX= DIVLX*NSKIPX*NTIKLX
      FINIX= DIVLX*NSKIPX*NTIKHX
      GO TO 2
C
    1 NTIKSX= NTIKHX
      NSPECX= NDECSX
      MANTSA= NTIKLX
      IDEC= NSKIPX
      STRTX= SIGN(1.0,DIVLX)*MANTSA*(10.0**IDEC)
      DO 100 INCR= 1,NTIKSX
        MANTSA= MANTSA+1
        IF (MANTSA.LT.10) GO TO 100
        MANTSA= 1
        IDEC= IDEC+1
  100 CONTINUE
      FINIX= SIGN(1.0,DIVLX)*MANTSA*(10.0**IDEC)
C
    2 IF (KTYPEY.EQ.2) GO TO 3
      NTIKSY= NTIKHY-NTIKLY+1
      NSPECY= NSKIPY
      STRTY= DIVLY*NSKIPY*NTIKLY
      FINIY= DIVLY*NSKIPY*NTIKHY
      GO TO 4
C
    3 NTIKSY= NTIKHY
      NSPECY= NDECSY
      MANTSA= NTIKLY
      IDEC= NSKIPY
      STRTY= SIGN(1.0,DIVLY)*MANTSA*(10.0**IDEC)
      DO 200 INCR= 1,NTIKSY
        MANTSA= MANTSA+1
        IF (MANTSA.LT.10) GO TO 200
        MANTSA= 1
        IDEC= IDEC+1
  200 CONTINUE
      FINIY= SIGN(1.0,DIVLY)*MANTSA*(10.0**IDEC)
C
    4 IPARAM(1)= KTYPEX
      IPARAM(2)= KTYPEY
      IPARAM(3)= NTIKSX
      IPARAM(4)= NTIKSY
      IPARAM(5)= NSPECX
      IPARAM(6)= NSPECY
C
      RPARAM(1)= AXPOSX
      RPARAM(2)= AXPOSY
      RPARAM(3)= STRTX
      RPARAM(4)= STRTY
      RPARAM(5)= FINIX
      RPARAM(6)= FINIY
      RPARAM(7)= DIVLX
      RPARAM(8)= DIVLY
C
      RETURN
      END
      SUBROUTINE ENQCON(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 251)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS CURRENT CONTROL PARAMETERS.
C
C
      INTEGER IPARAM(11)
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0DEVS/ KCHAN0(5),IRESL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T2PNUM/ NGPICS,LIMPIC
      COMMON /T3MODE/ KMODE
C
C
      IANGTP= 3
      IF (ANGCON.GT.0.016) IANGTP= 2
      IF (ANGCON.GT.0.020) IANGTP= 1
      IF (ANGCON.GT.1.5)   IANGTP= 4
C
      IPARAM( 1)= NGPICS
      IPARAM( 2)= LIMPIC
      IPARAM( 3)= KBUFR0
      IPARAM( 4)= IPRINT
      IPARAM( 5)= IANGTP
      IPARAM( 6)= KCHAN0(1)
      IPARAM( 7)= KCHAN0(2)
      IPARAM( 8)= KCHAN0(3)
      IPARAM( 9)= KCHAN0(4)
      IPARAM(10)= KCHAN0(5)
      IPARAM(11)= KMODE
C
      RETURN
      END
      SUBROUTINE ENQCRO(IPARAM,RPARAM,CPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. (1061)   VERSION (A7.3)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS RETURNS THE CROSS-HAIR POSITIONS AND
C          THE LAST-ENTERED REPLY CHAR. (IN TWO FORMATS).
C
C
      REAL      RPARAM(4)
      INTEGER   IPARAM(1)
      CHARACTER CPARAM(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3MODE/ KMODE
C
C
      IF (KMODE.NE.2) GO TO 1
C
C          IF DEVICE-MODE WORKING IS NOT POSSIBLE, THE
C          PRE-PROCESSOR PLOTTING POSITIONS ARE GIVEN.
C          THE REPLY CHARACTER IS AN EXCLAMATION MARK.
C
      XLOCV= XPLOT0
      YLOCV= YPLOT0
      CALL G0MAPP(XLOCV,YLOCV,XLOCD,YLOCD)
      KCHAR= 33
      GO TO 2
C
C          OTHERWISE, THE LOCATOR POSITIONS ARE READ.
C
    1 CALL G3GRIN(2,XLOCV,YLOCV,XLOCD,YLOCD,KCHAR)
C
C          THE RETURN ARGUMENT VALUES ARE THEN SET.
C
    2 IPARAM(1)= KCHAR
C
      RPARAM(1)= XLOCV
      RPARAM(2)= YLOCV
      RPARAM(3)= XLOCD
      RPARAM(4)= YLOCD
C
      CPARAM(1)= CHAR(KCHAR)
C
      RETURN
      END
      SUBROUTINE ENQERR(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 259)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE LATEST ERROR NUMBER
C          AND RESETS IT TO THE 'NO-ERROR' STATE.
C
C
      INTEGER IPARAM(1)
      LOGICAL ERRON
C
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      IPARAM(1)= NUMERR
      NUMERR= 0
C
      RETURN
      END
      SUBROUTINE ENQHAT(IHTNUM,IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 265)   VERSION (A8.1)    25:APR:91
C          ------------------------------------------------
C
C          THIS RETURNS THE HATCHING PARAMETERS
C          FOR HATCH NUMBER <IHTNUM>.
C
C
      REAL    RPARAM(2)
      INTEGER IPARAM(21)
C
      COMMON /T0FLTY/ IFLTY0,IFLRP0
      COMMON /T0HANG/ HTANG0(255,2)
      COMMON /T0HCOL/ IHCOL0(255,2)
      COMMON /T0HLST/ IHMKA0(255,2),IHMSA0(255,2),IHMKB0(255,2),
     &                IHMSB0(255,2)
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HOFF/ ISHFT0(255,2)
      COMMON /T0HPHS/ IPHAS0(255,2)
      COMMON /T0HPIT/ IPITH0(255,2)
      COMMON /T0HTYP/ IHAT0(255)
      COMMON /T0PSFT/ IPSFT0(255,2)
C
C
      RPARAM(1)=  HTANG0(IHTNUM,1)
      RPARAM(2)=  HTANG0(IHTNUM,2)
      IPARAM(1)=  IHATN0
      IPARAM(2)=  IHCOL0(IHTNUM,1)
      IPARAM(3)=  IHCOL0(IHTNUM,2)
      IPARAM(4)=  IHMKA0(IHTNUM,1)
      IPARAM(5)=  IHMSA0(IHTNUM,1)
      IPARAM(6)=  IHMKB0(IHTNUM,1)
      IPARAM(7)=  IHMSB0(IHTNUM,1)
      IPARAM(8)=  IHMKA0(IHTNUM,2)
      IPARAM(9)=  IHMSA0(IHTNUM,2)
      IPARAM(10)= IHMKB0(IHTNUM,2)
      IPARAM(11)= IHMSB0(IHTNUM,2)
      IPARAM(12)= ISHFT0(IHTNUM,1)
      IPARAM(13)= ISHFT0(IHTNUM,2)
      IPARAM(14)= IPHAS0(IHTNUM,1)
      IPARAM(15)= IPHAS0(IHTNUM,2)
      IPARAM(16)= IPITH0(IHTNUM,1)
      IPARAM(17)= IPITH0(IHTNUM,2)
      IPARAM(18)= IPSFT0(IHTNUM,1)
      IPARAM(19)= IPSFT0(IHTNUM,2)
      IPARAM(20)= IHAT0(IHTNUM)
      IPARAM(21)= IFLRP0
C
      RETURN
      END
      SUBROUTINE ENQINF(IPARAM,CPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 261)   VERSION (A8.5)    17:JUN:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS RETURNS CURRENT FILE AND PICTURE INFORMATION.
C
C
      INTEGER   IPARAM(2)
      CHARACTER CPARAM(2)*(*)
C
      COMMON /T2INFI/ INFOFI(32),INFOPI(32)
      COMMON /T2INLI/ LNFOFI,LNFOPI
      COMMON /T3MACH/ NMCHI,NBITMC
C
C
      IPARAM(1)= LNFOFI
      IPARAM(2)= LNFOPI
      LENCP= LEN(CPARAM(1))
      IF (LENCP.GT.128) LENCP= 128
C
      DO 100 MOVE= 1,LENCP
        CALL G4GETK(INFOFI,MOVE,NBITMC,NMCHI,ICHAR)
        CPARAM(1)(MOVE:MOVE)= CHAR(ICHAR)
        CALL G4GETK(INFOPI,MOVE,NBITMC,NMCHI,ICHAR)
        CPARAM(2)(MOVE:MOVE)= CHAR(ICHAR)
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE ENQIOC(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 260)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS CURRENT I/O CHANNEL NUMBERS.
C
C
      INTEGER IPARAM(4)
C
C
      COMMON /T1CHAD/ KDISPI,KDISPO
      COMMON /T3CHAM/ KMESGI,KMESGO
C
C
      IPARAM(1)= KMESGI
      IPARAM(2)= KMESGO
      IPARAM(3)= KDISPI
      IPARAM(4)= KDISPO
C
      RETURN
      END
      SUBROUTINE ENQLIN(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 255)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS CURRENT LINE-TYPE PARAMETERS.
C
C
      INTEGER IPARAM(8)
C
C
      COMMON /T0CURV/ MCURV0
      COMMON /T0HRDL/ LHRDW0
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0LPAT/ MARKA0,MISSA0,MARKB0,MISSB0
C
C
      IPARAM(1)= MCURV0
      IPARAM(2)= ITHIK0
      IPARAM(3)= KOLIN0
      IPARAM(4)= MARKA0
      IPARAM(5)= MISSA0
      IPARAM(6)= MARKB0
      IPARAM(7)= MISSB0
      IPARAM(8)= LHRDW0
C
      RETURN
      END
      SUBROUTINE ENQMAP(IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 252)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE CURRENT MAPPING PARAMETERS.
C
C
      REAL    RPARAM(12)
      INTEGER IPARAM(3)
C
C
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPD/ X1MAPD,X2MAPD,Y1MAPD,Y2MAPD
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
C
      IPARAM(1)= MAPNO0
      IPARAM(2)= MRKMAP
      IPARAM(3)= MRKWIN
C
      RPARAM( 1)= X1MAPV
      RPARAM( 2)= X2MAPV
      RPARAM( 3)= Y1MAPV
      RPARAM( 4)= Y2MAPV
      RPARAM( 5)= X1WND0
      RPARAM( 6)= X2WND0
      RPARAM( 7)= Y1WND0
      RPARAM( 8)= Y2WND0
      RPARAM( 9)= X1MAPD
      RPARAM(10)= X2MAPD
      RPARAM(11)= Y1MAPD
      RPARAM(12)= Y2MAPD
C
      RETURN
      END
      SUBROUTINE ENQMSK(IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 253)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE CURRENT MASKING PARAMETERS.
C
C
      REAL    RPARAM(40)
      INTEGER IPARAM(1)
C
C
      COMMON /T0MASK/ X1MSK0(10),X2MSK0(10),Y1MSK0(10),Y2MSK0(10),MSKLV0
C
C
      IPARAM(1)= MSKLV0
C
      DO 100 LEVEL= 1,10
        INDEXL= 4*(LEVEL-1)
        RPARAM(INDEXL+1)= X1MSK0(LEVEL)
        RPARAM(INDEXL+2)= X2MSK0(LEVEL)
        RPARAM(INDEXL+3)= Y1MSK0(LEVEL)
        RPARAM(INDEXL+4)= Y2MSK0(LEVEL)
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE ENQPOS(RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 256)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE CURRENT PLOTTING POSITION.
C
C
      REAL RPARAM(2)
C
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
C
C
      RPARAM(1)= XPLOT0
      RPARAM(2)= YPLOT0
C
      RETURN
      END
      SUBROUTINE ENQRUN(IPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 262)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS INDICATES THE AVAILABILITY OF THE
C          TWO OUTPUT STREAMS OF THE GHOST SYSTEM.
C
C
      INTEGER IPARAM(2)
C
      COMMON /T3SHUT/ K1ERR,K2ERR
C
C
      IPARAM(1)= K1ERR
      IPARAM(2)= K2ERR
C
      RETURN
      END
      SUBROUTINE ENQTRA(IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 254)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS THE CURRENT PICTURE TRANSFORMATION PARAMETERS.
C
C
      REAL    RPARAM(11)
      INTEGER IPARAM(3)
      LOGICAL SHIFT0
C
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
C
C
      IPARAM(1)= 0
      IF (SHIFT0) IPARAM(1)= 1
      IPARAM(2)= MTRAN0
      IPARAM(3)= KLIPM0
C
      RPARAM( 1)= SCALX0
      RPARAM( 2)= SCALY0
      RPARAM( 3)= ROTAT0
      RPARAM( 4)= VRPICX
      RPARAM( 5)= VRPICY
      RPARAM( 6)= VRDEVX
      RPARAM( 7)= VRDEVY
      RPARAM( 8)= RPICX0
      RPARAM( 9)= RPICY0
      RPARAM(10)= RDEVX0
      RPARAM(11)= RDEVY0
C
      RETURN
      END
      SUBROUTINE ERASE
C
C          ------------------------------------------------
C          ROUTINE NO. (  10)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CAUSES AN INSTANTANEOUS NEW PICTURE.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNL/ LNFILN,LNPICN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(118,0)
C
C          THE NEW PICTURE IS BEGUN, THE CURRENT PLOTTING POSITION IS
C          REPOSITIONED AT THE LOWER-LEFT CORNER OF THE CURRENT MAP,
C          AND THE CURRENT BUFFER NUMBER IS RESET TO THE SYSTEM ONE.
C          ANY EXISTING PICTURE NAME OR PIC. INFORMATION IS REMOVED.
C          AND THE CURRENT PLOTTING POSITION THEN RESET.
C
C
      CALL G3LINK(3,11,0,IDATA,RDATA)
C
      XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
      KBUFR0= 0
C
      LNPICN= 0
      LNFOPO= 0
C
      RETURN
      END
      SUBROUTINE ERRBAR(XPOSNS,YPOSNS,BOUND1,BOUND2,ISTART,ISTOP,
     &                  MARKNO,ICODE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  90)   VERSION (A8.1)    11:JUN:86
C          ------------------------------------------------
C
C          THIS DRAWS A SET OF VALUES WITH THIER ASSOCIATED
C          LOWER AND UPPER ERROR BOUNDS.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XPOSNS] ARE THE X-COORDINATES OF THE POINTS.
C          [YPOSNS] ARE THE Y-COORDINATES OF THE POINTS.
C          [BOUND1] ARE THE ASSOCIATED LOWER ERROR BOUNDS.
C          [BOUND2] ARE THE ASSOCIATED UPPER ERROR BOUNDS.
C          <ISTART> IS THE LOWER BOUNDARY AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAYS.
C          <MARKNO> IS THE GHOST CHARACTER NUMBER OF THE MARKER CHAR,
C                   IF ZERO PREVIOUS CHARACTER IS USED INSTEAD.
C          <ICODE>  INDICATES IF THE ERROR BOUNDS ARE TO BE JOINED
C                   AND THEIR ORIENTATION.
C
      REAL    XPOSNS(ISTOP),YPOSNS(ISTOP),BOUND1(ISTOP),
     &        BOUND2(ISTOP),XAUTO(2),YAUTO(2),RDATA(2)
      INTEGER IDATA(2)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0MRKS/ MARKC0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0,0.0/
C
C
      ITRAC1= ISTART
      ITRAC2= ISTOP
      ITRAC3= MARKNO
      IF (IPRINT.EQ.1) CALL G0MESG(171,7)
      IF (ISTOP-ISTART.LT.0) RETURN
C
C        THE CURRENT PLOTTING POSITION IS SAVED,AUTOMATIC MAPPING IS
C        DONE IF NEEDED,THE SIZE OF TICK MARKS ARE CALCULATED AS
C        THE GRAPH IS DRAWN AND THE POSITION RESTORED.
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      XAUTO(1)= XPOSNS(ISTART)
      XAUTO(2)= XPOSNS(ISTART)
      YAUTO(1)= YPOSNS(ISTART)
      YAUTO(2)= YPOSNS(ISTART)
C
      DO 100 IBRCNT= ISTART,ISTOP
        IF (XPOSNS(IBRCNT).LT.XAUTO(1)) XAUTO(1)= XPOSNS(IBRCNT)
        IF (XPOSNS(IBRCNT).GT.XAUTO(2)) XAUTO(2)= XPOSNS(IBRCNT)
        IF (YPOSNS(IBRCNT).LT.YAUTO(1)) YAUTO(1)= YPOSNS(IBRCNT)
        IF (YPOSNS(IBRCNT).GT.YAUTO(2)) YAUTO(2)= YPOSNS(IBRCNT)
  100 CONTINUE
C
      IF (ICODE.LE.0) GO TO 1
C
      DO 200 IBRCNT= ISTART,ISTOP
        BOUNDA= YPOSNS(IBRCNT)-BOUND1(IBRCNT)
        BOUNDB= YPOSNS(IBRCNT)+BOUND2(IBRCNT)
        IF (BOUNDA.LT.YAUTO(1)) YAUTO(1)= BOUNDA
        IF (BOUNDA.GT.YAUTO(2)) YAUTO(2)= BOUNDA
        IF (BOUNDB.LT.YAUTO(1)) YAUTO(1)= BOUNDB
        IF (BOUNDB.GT.YAUTO(2)) YAUTO(2)= BOUNDB
  200 CONTINUE
C
      GO TO 2
C
    1 IF (ICODE.EQ.0) GO TO 2
C
      DO 300 IBRCNT= ISTART,ISTOP
        BOUNDA= XPOSNS(IBRCNT)-BOUND1(IBRCNT)
        BOUNDB= XPOSNS(IBRCNT)+BOUND2(IBRCNT)
        IF (BOUNDA.LT.XAUTO(1)) XAUTO(1)= BOUNDA
        IF (BOUNDA.GT.XAUTO(2)) XAUTO(2)= BOUNDA
        IF (BOUNDB.LT.XAUTO(1)) XAUTO(1)= BOUNDB
        IF (BOUNDB.GT.XAUTO(2)) XAUTO(2)= BOUNDB
  300 CONTINUE
C
    2 CALL G0AUTO(XAUTO,YAUTO,1,2,1,2,0)
      KCHAR= IABS(MARKNO)
      IF (KCHAR.EQ.0.OR.KCHAR.GT.255) GO TO 3
C
      MARKC0= KCHAR
      IDATA(1)= KCHAR
      CALL G3LINK(2,9,-1,IDATA,RDATA)
    3 XAPSAV= AXPOSX
      YAPSAV= AXPOSY
C
      DO 400 IBRCNT= ISTART,ISTOP
        RDATA(1)= XPOSNS(IBRCNT)
        RDATA(2)= YPOSNS(IBRCNT)
        CALL G3LINK(0,5,2*NBYTR,IDATA,RDATA)
        IF (ICODE.LE.0) GO TO 5
C
        BOUNDA= YPOSNS(IBRCNT)-BOUND1(IBRCNT)
        BOUNDB= YPOSNS(IBRCNT)+BOUND2(IBRCNT)
        IF (ICODE.GT.1) GO TO 4
C
        CALL POSITN(XPOSNS(IBRCNT),BOUNDA)
        CALL JOIN(XPOSNS(IBRCNT),BOUNDB)
    4   KAXIS= 2
        AXPOSY= XPOSNS(IBRCNT)
        CALL G0TICK
        CALL POSITN(TKEN2A,BOUNDA)
        CALL JOIN(TKEN2B,BOUNDA)
        CALL POSITN(TKEN2A,BOUNDB)
        CALL JOIN(TKEN2B,BOUNDB)
        GO TO 400
C
    5   IF (ICODE.EQ.0) GO TO 400
C
        BOUNDA= XPOSNS(IBRCNT)-BOUND1(IBRCNT)
        BOUNDB= XPOSNS(IBRCNT)+BOUND2(IBRCNT)
        IF (ICODE.LT.-1) GO TO 6
C
        CALL POSITN(BOUNDA,YPOSNS(IBRCNT))
        CALL JOIN(BOUNDB,YPOSNS(IBRCNT))
    6   KAXIS= 1
        AXPOSX= YPOSNS(IBRCNT)
        CALL G0TICK
        CALL POSITN(BOUNDA,TKEN2A)
        CALL JOIN(BOUNDA,TKEN2B)
        CALL POSITN(BOUNDB,TKEN2A)
        CALL JOIN(BOUNDB,TKEN2B)
  400 CONTINUE
C
      AXPOSX= XAPSAV
      AXPOSY= YAPSAV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE ERRORS(ITRACE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  17)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SWITCHES ERROR MESSAGE PRINTING ON AND OFF.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ITRACE
      IF (IPRINT.EQ.1) CALL G0MESG(123,5)
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
C
      ERRON= .FALSE.
      IF (ITRACE.NE.0) ERRON= .TRUE.
      NUMERR= 0
C
      RETURN
      END
      SUBROUTINE FILCOL(NCOLOR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  67)   VERSION (A8.2)    02:JUN:87
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT AREA-FILL COLOUR.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <NCOLOR> IS THE REQUIRED COLOUR NUMBER.
C
C
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
      ITRAC1= NCOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(132,5)
      IF (IABS(NCOLOR).GT.255) RETURN
C
      KOLFL0= NCOLOR
C
      RETURN
      END
      SUBROUTINE FILEND
C
C          ------------------------------------------------
C          ROUTINE NO. ( 303)   VERSION (A7.7)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SWITCHES GRID OUTPUT FROM THE CURRENT FILE
C          BACK TO THE ORIGINAL DEFAULT OR SCRATCH GRIDFILE.
C
C
      LOGICAL   SCRTCH,INTRAC
C
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNA/ NAMEFO(32),NAMEPO(4)
      COMMON /T2OPNL/ LNFILN,LNPICN
      COMMON /T2SAVE/ SCRTCH
      COMMON /T3DEVT/ INTRAC
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
C
C
      CALL G3INIT(2)
C
      CALL G0FRAM
      IF (INTRAC) GO TO 1
C
      DO 100 ISET= 1,32
        NAMEFO(ISET)= NAMDEF(ISET)
  100 CONTINUE
C
      LNFILN= LENDEF
      RETURN
C
    1 SCRTCH= .TRUE.
      DO 200 ISET= 1,32
        NAMEFO(ISET)= NAMSCR(ISET)
  200 CONTINUE
C
      LNFILN= LENSCR
      LNFOFO= 0
      RETURN
      END
      SUBROUTINE FILINF(INFFIL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 304)   VERSION (A7.7)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS STORES INFORMATION IN A NEW FILE.
C
C
      LOGICAL   BLANK
      CHARACTER INFFIL*(*)
C
      COMMON /T2INFO/ INFOFO(32),INFOPO(32)
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
C
      LNFOFO= LEN(INFFIL)
      IF (LNFOFO.GT.128) LNFOFO= 128
C
      LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LNFOFO) NCHAR= ICHAR(INFFIL(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(INFOFO,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (BLANK) LNFOFO= 0
C
      RETURN
      END
      SUBROUTINE FILNAM(NMFILE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 305)   VERSION (A7.7)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS SETS UP A GRIDFILE OF THE GIVEN NAME.
C
C
      LOGICAL   BLANK
      LOGICAL   SCRTCH,ERRON,INTRAC
      CHARACTER NMFILE*(*)
C
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNA/ NAMEFO(32),NAMEPO(4)
      COMMON /T2OPNL/ LNFILN,LNPICN
      COMMON /T2SAVE/ SCRTCH
      COMMON /T3DEVT/ INTRAC
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G0FRAM
      IF (INTRAC) SCRTCH= .FALSE.
C
      LNFILN= LEN(NMFILE)
      IF (LNFILN.LE.128) GO TO 1
      LNFILN= 128
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    1 LNFOFO= 0
      LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LNFILN) NCHAR= ICHAR(NMFILE(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(NAMEFO,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (.NOT.BLANK) RETURN
C
      DO 200 ISET= 1,32
        NAMEFO(ISET)= NAMDEF(ISET)
  200 CONTINUE
C
      LNFILN= LENDEF
C
      RETURN
      END
      SUBROUTINE FILOFF
C
C          ------------------------------------------------
C          ROUTINE NO. ( 306)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DISABLES GRIDFILE OUTPUT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL GFOPEN,PPOPEN
C
      COMMON /T3OUTS/ GFOPEN,PPOPEN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
      CALL G3LINK(3,10,0,IDATA,RDATA)
      GFOPEN= .FALSE.
C
      RETURN
      END
      SUBROUTINE FILON
C
C          ------------------------------------------------
C          ROUTINE NO. ( 307)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS ENABLES GRIDFILE OUTPUT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL GFOPEN,PPOPEN
C
      COMMON /T3OUTS/ GFOPEN,PPOPEN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
      CALL G3LINK(3,10,0,IDATA,RDATA)
      GFOPEN= .TRUE.
C
      RETURN
      END
      SUBROUTINE FLLBND(IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. (  56)   VERSION (A8.1)    14:JUL:88
C          ------------------------------------------------
C
C          THIS SPECIFIES WHETHER THE BOUNDARY OF A FILLED
C          AREA IS TO BE DRAWN.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IENABL>  IF SET TO ZERO, NO BOUNDARY IS DRAWN.
C
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= IENABL
      IF (IPRINT.EQ.1) CALL G0MESG(26,5)
C
      IDRBND= 0
      IF (IENABL.NE.0) IDRBND= 1
      RETURN
      END
      SUBROUTINE FRAME
C
C          ------------------------------------------------
C          ROUTINE NO. (   5)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS BEGINS A NEW (UNNAMED) PICTURE.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNL/ LNFILN,LNPICN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(4,0)
C
C          THE NEW PICTURE IS BEGUN, THE CURRENT PLOTTING POSITION IS
C          REPOSITIONED AT THE LOWER-LEFT CORNER OF THE CURRENT MAP,
C          AND THE CURRENT BUFFER NUMBER IS RESET TO THE SYSTEM ONE.
C          ANY EXISTING PICTURE NAME OR PIC. INFORMATION IS REMOVED.
C
      CALL G3LINK(3,3,0,IDATA,RDATA)
C
      XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
      KBUFR0= 0
C
      LNPICN= 0
      LNFOPO= 0
C
      RETURN
      END
c slmod begin
      SUBROUTINE THICK2(NTHICK)
      COMMON /T1CHAD/ KDISPI,KDISPO

      WRITE(KDISPO,'(I3,A)') NTHICK,' t'      

      RETURN
      END
c slmod end
      SUBROUTINE FULL
C
C          ------------------------------------------------
C          ROUTINE NO. (  52)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RESETS LINE DRAWING TO CONTINUOUS FORM.
C          (IT IS EQUIVALENT TO <BROKEN> WITH NULL ARGUMENTS).
C
C
      REAL    RDATA(1)
      INTEGER IDATA(4)
C
      COMMON /T0LPAT/ MARKA0,MISSA0,MARKB0,MISSB0
      COMMON /T0TRAC/ IPRINT
C
      DATA RDATA /0.0/, IDATA /0,0,0,0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(23,0)
C
      MARKA0= 0
      MISSA0= 0
      MARKB0= 0
      MISSB0= 0
C
      CALL G3LINK(3,6,-4,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE GARGS(ITRACE)
C
C          ------------------------------------------------
C          ROUTINE NO. (   7)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE TRACE MARKER, HENCE ENABLING
C          OR DISABLING THE PRINTING OF TRACE DIAGNOSTICS.
C
C
C          <ITRACE> IS THE CONTROL VARIABLE:
C                   IF ZERO, MESSAGES ARE NOT GIVEN,
C                   IF NON-ZERO, MESSAGES ARE PRINTED.
C
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= ITRACE
      CALL G0MESG(6,5)
C
      IPRINT= 0
      IF (ITRACE.NE.0) IPRINT= 1
C
      RETURN
      END
      SUBROUTINE GKSDEV(NUMDEV)
C
C          ------------------------------------------------
C          ROUTINE NO. (  40)   VERSION (A8.1)    14:MAR:90
C          ------------------------------------------------
C
C          THIS SETS THE WORKSTATION TYPE FOR GKS.
C
      COMMON /T1DVCE/ IDEVCE
C
C
      IDEVCE= NUMDEV
C
      RETURN
      END
      SUBROUTINE GPSTOP(LIMIT)
C
C          ------------------------------------------------
C          ROUTINE NO. (   6)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C      THIS ALTERS THE FRAME LIMIT.
C
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T2PNUM/ NGPICS,LIMPIC
C
C
      CALL G3INIT(2)
C
      ITRAC1= LIMIT
      IF (IPRINT.EQ.1) CALL G0MESG(5,5)
C
      LIMPIC= LIMIT
C
      RETURN
      END
      SUBROUTINE GRAD
C
C          ------------------------------------------------
C          ROUTINE NO. (  36)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT ANGLE TYPE TO GRADS.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(20,0)
C
      ANGCON= 0.005*PI
      RETURN
      END
      SUBROUTINE GRAPHC(FUNCX,STARTX)
C
C          ------------------------------------------------
C          ROUTINE NO. (  98)   VERSION (A8.4)    04:MAR:91
C          ------------------------------------------------
C
C          THIS DRAWS THE GIVEN FUNCTION FROM THE START POINT,
C          IN BOTH DIRECTIONS, UNTIL THE CURVE LEAVES THE WINDOW.
C
C
C          <FUNCX>  IS THE FUNCTION IDENTIFIER (AND MUST BE
C                   DECLARED AS EXTERNAL IN THE CALLING PROGRAM).
C          <STARTX> IS THE START X-POSITION. IF THIS LIES OUTSIDE
C                   THE WINDOW AREA, THE CURVE WILL NOT BE DRAWN.
C
C
      REAL    CURVEX(101),CURVEY(101)
      LOGICAL SAVE
C
      EXTERNAL FUNCX
C
      COMMON /T0CURV/ MCURV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
C
      RTRAC1= STARTX
      IF (IPRINT.EQ.1) CALL G0MESG(40,1)
C
C          THE STEP SIZE, ALLOWED TOLERANCES AND THE
C          WINDOW Y-LIMITS ARE CALCULATED. THE CURRENT
C          CURVE METHOD IS SAVED AND METHOD-2 IS SET.
C
      STEPX= ABS(X2WND0-X1WND0)/499.0
      DELTAX= ABS(X2WND0-X1WND0)*0.001
      DELTAY= ABS(Y2WND0-Y1WND0)*0.001
      YMIN= AMIN1(Y1WND0,Y2WND0)
      YMAX= AMAX1(Y1WND0,Y2WND0)
      METSAV= MCURV0
      MCURV0= 2
C
C          THE OUTER LOOP DRAWS THE CURVE IN BOTH DIRECTIONS
C          FROM THE SPECIFIED START POINT. THE APPROPRIATE
C          X-LIMIT AND STEP DIRECTION ARE SET, THEN THE FIRST
C          TWO POINTS AND THE STARTING VALUE OF THE SLOPE ARE
C          FOUND. THE INNER LOOP EXTENDS THE SECOND AND THIRD
C          POINTS UNTIL THE LATTER DIFFERS FROM THE CURRENT SLOPE
C          LINE BY MORE THAN THE ALLOWED TOLERANCE, THE SLOPE
C          BETWEEN THE FIRST AND MIDDLE POINTS IS RECALCULATED,
C          THEN THE SECOND AND THIRD POINTS ARE EXTENDED ANEW
C          UNTIL THE THIRD HAS AGAIN DRIFTED OFF TOO FAR. THE
C          MIDDLE POSITION IS THEN SAVED. THIS IS REPEATED UNTIL
C          ALL OF THE CURVE WITHIN THE WINDOW HAS BEEN DONE. THE
C          SAVED SET OF POINTS IS OUTPUT WHENEVER IT IS TOO LARGE.
C
      DO 100 ISIDE= 1,2
        ENDX= AMAX1(X1WND0,X2WND0)
        IF (ISIDE.EQ.1) GO TO 1
        ENDX= AMIN1(X1WND0,X2WND0)
        STEPX= -STEPX
C
    1   X1= STARTX
        Y1= FUNCX(X1)
        X2= X1+STEPX
        Y2= FUNCX(X2)
        SLOPE= (Y2-Y1)/(X2-X1)
        IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
        NPTS= 1
        CURVEX(1)= X1
        CURVEY(1)= Y1
        SAVE= .FALSE.
    2     X3= X2+STEPX
          IF (ISIDE.EQ.1.AND.X3.GT.ENDX) GO TO 7
          IF (ISIDE.EQ.2.AND.X3.LT.ENDX) GO TO 7
          Y3= FUNCX(X3)
          IF (Y3.LT.YMIN.OR.Y3.GT.YMAX)  GO TO 7
C
    3     DISTX= ABS((Y3-Y1)/SLOPE-(X3-X1))
          DISTY= ABS(DISTX*SLOPE)
          IF (DISTX.GT.DELTAX.AND.DISTY.GT.DELTAY) GO TO 4
          X2= X3
          Y2= Y3
          GO TO 2
C
    4     IF (SAVE) GO TO 5
          SAVE= .TRUE.
          SLOPE= (Y2-Y1)/(X2-X1)
          IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
          GO TO 3
C
    5     IF (NPTS.LT.100) GO TO 6
          CALL G0CURV(CURVEX,CURVEY,1,100,0)
          NPTS= 1
          CURVEX(1)= CURVEX(100)
          CURVEY(1)= CURVEY(100)
C
    6     NPTS= NPTS+1
          CURVEX(NPTS)= X2
          CURVEY(NPTS)= Y2
          SAVE= .FALSE.
          X1= X2
          Y1= Y2
          X2= X3
          Y2= Y3
          GO TO 2
C
    7   NPTS= NPTS+1
        CURVEX(NPTS)= X3
        CURVEY(NPTS)= Y3
        CALL G0CURV(CURVEX,CURVEY,1,NPTS,0)
  100 CONTINUE
C
C          LASTLY, THE ORIGINAL CURVE METHOD IS RESTORED.
C
      MCURV0= METSAV
C
      RETURN
      END
      SUBROUTINE GRAPHF(FUNCX)
C
C          ------------------------------------------------
C          ROUTINE NO. (  96)   VERSION (A8.4)    04:MAR:91
C          ------------------------------------------------
C
C          THIS DRAWS ALL OF THE GIVEN FUNCTION
C          WHICH LIES WITHIN THE CURRENT WINDOW AREA.
C
C
C          <FUNCX>  IS THE FUNCTION IDENTIFIER (AND MUST BE
C                   DECLARED AS EXTERNAL IN THE CALLING PROGRAM).
C
C
      REAL    CURVEX(101),CURVEY(101)
      LOGICAL SAVE
C
      EXTERNAL FUNCX
C
      COMMON /T0CURV/ MCURV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(38,0)
C
C          THE STEP SIZE AND THE ALLOWED TOLERANCES ARE CALCULATED.
C          THE CURRENT CURVE METHOD IS SAVED AND METHOD-2 IS SET.
C
      STEPX= ABS(X2WND0-X1WND0)/499.0
      DELTAX= ABS(X2WND0-X1WND0)*0.001
      DELTAY= ABS(Y2WND0-Y1WND0)*0.001
      METSAV= MCURV0
      MCURV0= 2
C
C          THE FIRST TWO POINTS AND THE START SLOPE ARE FOUND.
C          THE LOOP EXTENDS THE SECOND AND THIRD POINTS UNTIL
C          THE LATTER DIFFERS FROM THE CURRENT SLOPE LINE BY
C          MORE THAN THE ALLOWED TOLERANCE, THE SLOPE BETWEEN
C          THE FIRST AND MIDDLE POINTS IS RECALCULATED, THEN
C          THE SECOND AND THIRD POINTS ARE EXTENDED ANEW UNTIL
C          THE THIRD HAS AGAIN DRIFTED OFF TOO FAR. THE MIDDLE
C          POSITION IS THEN SAVED. THIS IS REPEATED UNTIL ALL OF
C          THE CURVE WITHIN THE WINDOW HAS BEEN DONE. THE SAVED
C          SET OF POINTS IS OUTPUT WHENEVER IT BECOMES TOO LARGE.
C
      STARTX= AMIN1(X1WND0,X2WND0)
      ENDX= AMAX1(X1WND0,X2WND0)
      X1= STARTX
      Y1= FUNCX(X1)
      X2= X1+STEPX
      Y2= FUNCX(X2)
      SLOPE= (Y2-Y1)/(X2-X1)
      IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
      NPTS= 1
      CURVEX(1)= X1
      CURVEY(1)= Y1
      SAVE= .FALSE.
    1   X3= X2+STEPX
        IF (X3.GT.ENDX) GO TO 6
        Y3= FUNCX(X3)
C
    2   DISTX= ABS((Y3-Y1)/SLOPE-(X3-X1))
        DISTY= ABS(DISTX*SLOPE)
        IF (DISTX.GT.DELTAX.AND.DISTY.GT.DELTAY) GO TO 3
        X2= X3
        Y2= Y3
        GO TO 1
C
    3   IF (SAVE) GO TO 4
        SAVE= .TRUE.
        SLOPE= (Y2-Y1)/(X2-X1)
        IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
        GO TO 2
C
    4   IF (NPTS.LT.100) GO TO 5
        CALL G0CURV(CURVEX,CURVEY,1,100,0)
        NPTS= 1
        CURVEX(1)= CURVEX(100)
        CURVEY(1)= CURVEY(100)
C
    5   NPTS= NPTS+1
        CURVEX(NPTS)= X2
        CURVEY(NPTS)= Y2
        SAVE= .FALSE.
        X1= X2
        Y1= Y2
        X2= X3
        Y2= Y3
        GO TO 1
C
    6 NPTS= NPTS+1
      CURVEX(NPTS)= ENDX
      CURVEY(NPTS)= FUNCX(ENDX)
      CALL G0CURV(CURVEX,CURVEY,1,NPTS,0)
C
C          LASTLY, THE ORIGINAL CURVE METHOD IS RESTORED.
C
      MCURV0= METSAV
C
      RETURN
      END
      SUBROUTINE GRAPHX(FUNCX,XLIM1,XLIM2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  97)   VERSION (A8.4)    04:MAR:91
C          ------------------------------------------------
C
C          THIS DRAWS ALL OF THE GIVEN FUNCTION
C          WHICH LIES WITHIN THE CURRENT X LIMITS.
C
C
C          <FUNCX>  IS THE FUNCTION IDENTIFIER (AND MUST BE
C                   DECLARED AS EXTERNAL IN THE CALLING PROGRAM).
C          <XLIM1>  AND
C          <XLIM2>  ARE THE X-LIMITS.
C
C
      REAL    CURVEX(101),CURVEY(101)
      LOGICAL SAVE
C
      EXTERNAL FUNCX
C
      COMMON /T0CURV/ MCURV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
C
      RTRAC1= XLIM1
      RTRAC2= XLIM2
      IF (IPRINT.EQ.1) CALL G0MESG(39,2)
C
C          THE STEP SIZE AND THE ALLOWED TOLERANCES ARE CALCULATED.
C          THE CURRENT CURVE METHOD IS SAVED AND METHOD-2 IS SET.
C
      STEPX= ABS(X2WND0-X1WND0)/499.0
      DELTAX= ABS(X2WND0-X1WND0)*0.001
      DELTAY= ABS(Y2WND0-Y1WND0)*0.001
      METSAV= MCURV0
      MCURV0= 2
C
C          THE FIRST TWO POINTS AND THE START SLOPE ARE FOUND.
C          THE LOOP EXTENDS THE SECOND AND THIRD POINTS UNTIL
C          THE LATTER DIFFERS FROM THE CURRENT SLOPE LINE BY
C          MORE THAN THE ALLOWED TOLERANCE, THE SLOPE BETWEEN
C          THE FIRST AND MIDDLE POINTS IS RECALCULATED, THEN
C          THE SECOND AND THIRD POINTS ARE EXTENDED ANEW UNTIL
C          THE THIRD HAS AGAIN DRIFTED OFF TOO FAR. THE MIDDLE
C          POSITION IS THEN SAVED. THIS IS REPEATED UNTIL ALL OF
C          THE CURVE WITHIN THE LIMITS HAS BEEN DONE. THE SAVED
C          SET OF POINTS IS OUTPUT WHENEVER IT BECOMES TOO LARGE.
C
      STARTX= AMIN1(XLIM1,XLIM2)
      ENDX= AMAX1(XLIM1,XLIM2)
      X1= STARTX
      Y1= FUNCX(X1)
      X2= X1+STEPX
      Y2= FUNCX(X2)
      SLOPE= (Y2-Y1)/(X2-X1)
      IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
      NPTS= 1
      CURVEX(1)= X1
      CURVEY(1)= Y1
      SAVE= .FALSE.
    1   X3= X2+STEPX
        IF (X3.GT.ENDX) GO TO 6
        Y3= FUNCX(X3)
C
    2   DISTX= ABS((Y3-Y1)/SLOPE-(X3-X1))
        DISTY= ABS(DISTX*SLOPE)
        IF (DISTX.GT.DELTAX.AND.DISTY.GT.DELTAY) GO TO 3
        X2= X3
        Y2= Y3
        GO TO 1
C
    3   IF (SAVE) GO TO 4
        SAVE= .TRUE.
        SLOPE= (Y2-Y1)/(X2-X1)
        IF (ABS(SLOPE).LT.1.0E-14) SLOPE= SIGN(1.0E-14,SLOPE)
        GO TO 2
C
    4   IF (NPTS.LT.100) GO TO 5
        CALL G0CURV(CURVEX,CURVEY,1,100,0)
        NPTS= 1
        CURVEX(1)= CURVEX(100)
        CURVEY(1)= CURVEY(100)
C
    5   NPTS= NPTS+1
        CURVEX(NPTS)= X2
        CURVEY(NPTS)= Y2
        SAVE= .FALSE.
        X1= X2
        Y1= Y2
        X2= X3
        Y2= Y3
        GO TO 1
C
    6 NPTS= NPTS+1
      CURVEX(NPTS)= ENDX
      CURVEY(NPTS)= FUNCX(ENDX)
      CALL G0CURV(CURVEX,CURVEY,1,NPTS,0)
C
C          LASTLY, THE ORIGINAL CURVE METHOD IS RESTORED.
C
      MCURV0= METSAV
C
      RETURN
      END
      SUBROUTINE GRATIC
C
C          ------------------------------------------------
C          ROUTINE NO. ( 218)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(96,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,0.0)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
    1 CALL G0DIVS(2,0.0)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 2
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  200 CONTINUE
C
    2 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRATSI(DIX,DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 221)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          WITH INTERVALS SET BY <DIX> AND <DIY>.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      RTRAC2= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(99,2)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,DIX)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
    1 CALL G0DIVS(2,DIY)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 2
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  200 CONTINUE
C
    2 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRAXL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 224)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(102,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE X-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVL(1)
      IPOS= NTIKLX
      IDEC= NSKIPX
      NDECS= NDECSX
      NTICKS= NTIKHX
      IF (NTICKS.LE.37) GO TO 1
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NDECS
        XPOS= DIVLX*(10.0**(ITICK+IDEC))
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
      AXXSAV= AXPOSX
      AXPOSX= Y1WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= Y2WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= AXXSAV
      GO TO 2
C
    1 IF (NTICKS.LE.0) GO TO 2
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NTICKS
        XPOS= DIVLX*IPOS*(10.0**IDEC)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 200
C
        IPOS= 1
        IDEC= IDEC+1
  200 CONTINUE
C
    2 CALL G0DIVS(2,0.0)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 3
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 300 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  300 CONTINUE
C
    3 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRAXLI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 227)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          WITH THE Y-INTERVAL SET BY <DIY>.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(103,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE X-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVL(1)
      IPOS= NTIKLX
      IDEC= NSKIPX
      NDECS= NDECSX
      NTICKS= NTIKHX
      IF (NTICKS.LE.37) GO TO 1
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NDECS
        XPOS= DIVLX*(10.0**(ITICK+IDEC))
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
      AXXSAV= AXPOSX
      AXPOSX= Y1WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= Y2WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= AXXSAV
      GO TO 2
C
    1 IF (NTICKS.LE.0) GO TO 2
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NTICKS
        XPOS= DIVLX*IPOS*(10.0**IDEC)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 200
C
        IPOS= 1
        IDEC= IDEC+1
  200 CONTINUE
C
    2 CALL G0DIVS(2,DIY)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 3
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 300 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  300 CONTINUE
C
    3 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRAXYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 226)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LOGARITHMIC MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(106,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE X-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVL(1)
      IPOS= NTIKLX
      IDEC= NSKIPX
      NDECS= NDECSX
      NTICKS= NTIKHX
      IF (NTICKS.LE.37) GO TO 1
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NDECS
        XPOS= DIVLX*(10.0**(ITICK+IDEC))
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
      AXXSAV= AXPOSX
      AXPOSX= Y1WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= Y2WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= AXXSAV
      GO TO 2
C
    1 IF (NTICKS.LE.0) GO TO 2
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NTICKS
        XPOS= DIVLX*IPOS*(10.0**IDEC)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 200
C
        IPOS= 1
        IDEC= IDEC+1
  200 CONTINUE
C
    2 CALL G0DIVL(2)
      IPOS= NTIKLY
      IDEC= NSKIPY
      NDECS= NDECSY
      NTICKS= NTIKHY
      IF (NTICKS.LE.37) GO TO 3
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 300 ITICK= 1,NDECS
        YPOS= DIVLY*(10.0**(ITICK+IDEC))
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  300 CONTINUE
C
      AXYSAV= AXPOSY
      AXPOSY= X1WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= X2WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= AXYSAV
      GO TO 4
C
    3 IF (NTICKS.LE.0) GO TO 4
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 400 ITICK= 1,NTICKS
        YPOS= DIVLY*IPOS*(10.0**IDEC)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 400
C
        IPOS= 1
        IDEC= IDEC+1
  400 CONTINUE
C
    4 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRAYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 225)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(104,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE Y-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,0.0)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
    1 CALL G0DIVL(2)
      IPOS= NTIKLY
      IDEC= NSKIPY
      NDECS= NDECSY
      NTICKS= NTIKHY
      IF (NTICKS.LE.37) GO TO 2
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NDECS
        YPOS= DIVLY*(10.0**(ITICK+IDEC))
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  200 CONTINUE
C
      AXYSAV= AXPOSY
      AXPOSY= X1WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= X2WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= AXYSAV
      GO TO 3
C
    2 IF (NTICKS.LE.0) GO TO 3
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 300 ITICK= 1,NTICKS
        YPOS= DIVLY*IPOS*(10.0**IDEC)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 300
C
        IPOS= 1
        IDEC= IDEC+1
  300 CONTINUE
C
    3 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GRAYLI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 228)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A GRATICULE WITH NO ANNOTATION,
C          WITH THE X-INTERVAL SET BY <DIX>.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    EDGE(2)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(105,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS AND Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE Y-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,DIX)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      EDGE(1)= Y1WND0
      EDGE(2)= Y2WND0
      INDEDG= 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,EDGE(INDEDG))
        INDEDG= 3-INDEDG
        CALL JOIN(XPOS,EDGE(INDEDG))
  100 CONTINUE
C
    1 CALL G0DIVL(2)
      IPOS= NTIKLY
      IDEC= NSKIPY
      NDECS= NDECSY
      NTICKS= NTIKHY
      IF (NTICKS.LE.37) GO TO 2
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 200 ITICK= 1,NDECS
        YPOS= DIVLY*(10.0**(ITICK+IDEC))
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
  200 CONTINUE
C
      AXYSAV= AXPOSY
      AXPOSY= X1WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= X2WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= AXYSAV
      GO TO 3
C
    2 IF (NTICKS.LE.0) GO TO 3
C
      EDGE(1)= X1WND0
      EDGE(2)= X2WND0
      INDEDG= 1
C
      DO 300 ITICK= 1,NTICKS
        YPOS= DIVLY*IPOS*(10.0**IDEC)
        CALL POSITN(EDGE(INDEDG),YPOS)
        INDEDG= 3-INDEDG
        CALL JOIN(EDGE(INDEDG),YPOS)
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 300
C
        IPOS= 1
        IDEC= IDEC+1
  300 CONTINUE
C
    3 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE GREND
C
C          ------------------------------------------------
C          ROUTINE NO. (   4)   VERSION (A8.6)    28:JAN:87
C          ------------------------------------------------
C
C          THIS TERMINATES CURRENT GRAPHICAL OUTPUT.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
C
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNL/ LNFILN,LNPICN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(3,0)
C
C          THE OUTPUT STREAMS ARE CLOSED, THE PICTURE
C          NAME AND PICTURE INFORMATION ARE CLEARED,
C          AND THE CURRENT PLOTTING POSITION IS RESET.
C
      CALL G3LINK(1,2,0,IDATA,RDATA)
      LNPICN= 0
      LNFOPO= 0
      XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
C
      RETURN
      END
      SUBROUTINE HATANG(ANGLE,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 330)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE ANGLE FOR CROSS-HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ANGLE> , THE ANGLE TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0HANG/ HTANG0(255,2)
      COMMON /T0HNUM/ IHATN0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(177,1)
      IF (IENABL.EQ.0) RETURN
C
      HTANG= ANGLE*ANGCON
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) HTANG0(IHATN0,1)= HTANG
      IF (IENAB/2.EQ.1)      HTANG0(IHATN0,2)= HTANG
C
      RDATA(1)= HTANG
      RDATA(2)= IENAB
      CALL G3LINK(5,5,2*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATCOL(ICOLOR,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 331)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE LINE COLOUR FOR CROSS-HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICOLOR>, THE LINE COLOUR TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HCOL/ IHCOL0(255,2)
      COMMON /T0HNUM/ IHATN0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= ICOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(178,5)
      IF (IENABL.EQ.0) RETURN
      IF (ICOLOR.LT.0.OR.ICOLOR.GT.255) RETURN
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) IHCOL0(IHATN0,1)= ICOLOR
      IF (IENAB/2.EQ.1)      IHCOL0(IHATN0,2)= ICOLOR
C
      IDATA(1)= ICOLOR
      IDATA(2)= IENAB
      CALL G3LINK(5,10,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATDEF(NUMPAT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 332)   VERSION (A8.1)    16:OCT:90
C          ------------------------------------------------
C
C          THIS CONTROLS WHICH PATTERN NUMBER IS TO BE DEFINED.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <NUMPAT>, THE NUMBER OF THE PATTERN TO BE DEFINED.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= NUMPAT
      IF (IPRINT.EQ.1) CALL G0MESG(179,5)
C
      NUMPT= IABS(NUMPAT)
      IF (NUMPT.LT.1.OR.NUMPT.GT.255) RETURN
C
      IHATN0= NUMPT
      IDATA(1)= IHATN0
      CALL G3LINK(5,12,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATDUP(IFROM,ITO)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 338)   VERSION (A8.1)    16:JUN:87
C          ------------------------------------------------
C
C          THIS COPIES HATCHING PARAMETERS FROM ONE HATCH
C          NUMBER TO ANOTHER.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFROM>,  THE SOURCE PATTERN NUMBER.
C          <ITO>,    THE DESTINATION PATTERN NUMBER.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HANG/ HTANG0(255,2)
      COMMON /T0HCOL/ IHCOL0(255,2)
      COMMON /T0HLST/ IHMKA0(255,2),IHMSA0(255,2),IHMKB0(255,2),
     &                IHMSB0(255,2)
      COMMON /T0HOFF/ ISHFT0(255,2)
      COMMON /T0HPHS/ IPHAS0(255,2)
      COMMON /T0HPIT/ IPITH0(255,2)
      COMMON /T0HPSF/ IPSFT0(255,2)
      COMMON /T0HTYP/ IHAT0(255)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= IFROM
      ITRAC2= ITO
      IF (IPRINT.EQ.1) CALL G0MESG(185,6)
C
      IAFROM= IABS(IFROM)
      IATO= IABS(ITO)
      IF (IAFROM.LT.1.OR.IAFROM.GT.255) RETURN
      IF (IATO.LT.1.OR.IATO.GT.255)     RETURN
C
      DO 100 LOAD= 1,2
        HTANG0(IATO,LOAD)= HTANG0(IAFROM,LOAD)
        IHCOL0(IATO,LOAD)= IHCOL0(IAFROM,LOAD)
        IHMKA0(IATO,LOAD)= IHMKA0(IAFROM,LOAD)
        IHMSA0(IATO,LOAD)= IHMSA0(IAFROM,LOAD)
        IHMKB0(IATO,LOAD)= IHMKB0(IAFROM,LOAD)
        IHMSB0(IATO,LOAD)= IHMSB0(IAFROM,LOAD)
        ISHFT0(IATO,LOAD)= ISHFT0(IAFROM,LOAD)
        IPHAS0(IATO,LOAD)= IPHAS0(IAFROM,LOAD)
        IPITH0(IATO,LOAD)= IPITH0(IAFROM,LOAD)
        IPSFT0(IATO,LOAD)= IPSFT0(IAFROM,LOAD)
  100 CONTINUE
C
      IHAT0(IATO)= IHAT0(IAFROM)
      IDATA(1)= IAFROM
      IDATA(2)= IATO
      CALL G3LINK(5,14,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATLSH(IPATSH,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 339)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS CONTROLS THE POSITION IN THE PATTERN
C          THE LINE THROUGH (0,0) BEGINS WITH.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IPATSH>, THE PATTERN SHIFT TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HPSF/ IPSFT0(255,2)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= IPATSH
      IF (IPRINT.EQ.1) CALL G0MESG(186,5)
      IF (IENABL.EQ.0) RETURN
C
      IPATSF= IPATSH
      IF (IPATSF.GT.255) IPATSF= 255
      IF (IPATSF.LT.0) RETURN
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) IPSFT0(IHATN0,1)= IPATSF
      IF (IENAB/2.EQ.1)      IPSFT0(IHATN0,2)= IPATSF
C
      IDATA(1)= IPATSF
      IDATA(2)= IENAB
      CALL G3LINK(5,15,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATLST(MARKA,MISSA,MARKB,MISSB,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 333)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE BROKEN LINE PATTERN FOR CROSS HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <MARKA>  IS THE 1ST. LINE LENGTH,
C          <MISSA>  IS THE 1ST. SPACE LENGTH,
C          <MARKB>  IS THE 2ND. LINE LENGTH,
C          <MISSB>  IS THE 2ND. SPACE LENGTH
C                   (ALL IN UNITS OF 1/1000 OF THE UNIT SQUARE).
C
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(5)
C
      COMMON /T0HLST/ IHMKA0(255,2),IHMSA0(255,2),IHMKB0(255,2),
     &                IHMSB0(255,2)
      COMMON /T0HNUM/ IHATN0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= MARKA
      ITRAC2= MISSA
      ITRAC3= MARKB
      ITRAC4= MISSB
      IF (IPRINT.EQ.1) CALL G0MESG(180,8)
      IF (IENABL.EQ.0) RETURN
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
C
      IMARKA= IABS(MARKA)
      IF (IMARKA.GT.255) IMARKA= 255
C
      IMISSA= IABS(MISSA)
      IF (IMISSA.GT.255) IMISSA= 255
C
      IMARKB= IABS(MARKB)
      IF (IMARKB.GT.255) IMARKB= 255
C
      IMISSB= IABS(MISSB)
      IF (IMISSB.GT.255) IMISSB= 255
      IF (MOD(IENAB,2).NE.1) GO TO 1
C
      IHMKA0(IHATN0,1)= IMARKA
      IHMSA0(IHATN0,1)= IMISSA
      IHMKB0(IHATN0,1)= IMARKB
      IHMSB0(IHATN0,1)= IMISSB
    1 IF (IENAB/2.NE.1) GO TO 2
C
      IHMKA0(IHATN0,2)= IMARKA
      IHMSA0(IHATN0,2)= IMISSA
      IHMKB0(IHATN0,2)= IMARKB
      IHMSB0(IHATN0,2)= IMISSB
    2 IDATA(1)= IMARKA
      IDATA(2)= IMISSA
      IDATA(3)= IMARKB
      IDATA(4)= IMISSB
      IDATA(5)= IENAB
      CALL G3LINK(5,8,-5,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATOPT(ISHADE)
C
C          --------------------------------------------------
C          ROUTINE NO. ( 340)    VERSION (A8.1)     03:JUL:87
C          --------------------------------------------------
C
C          THIS SPECIFIES WHETHER SOLID FILLING SHOULD BE
C          IMPLEMENTED BY SHADING ON DEVICES THAN CANNOT
C          DO SOLID FILLING.
C
C
C          <ISHADE> = 0 TO NOT REPLACE SOLID FILLING BY SHADING.
C                   = 1 TO REPLACE SOLID FILLING BY SHADING.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0FLTY/ IFLTY0,IFLRP0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= ISHADE
      IF (IPRINT.EQ.1) CALL G0MESG(188,5)
C
      IFLRP0= ISHADE
      IF (IFLRP0.NE.0) IFLRP0= 1
C
      IDATA(1)= IFLRP0
      CALL G3LINK(5,16,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATPCH(IPITCH,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 334)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE PITCH FOR CROSS-HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IPITCH>, THE PITCH TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HPIT/ IPITH0(255,2)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= IPITCH
      IF (IPRINT.EQ.1) CALL G0MESG(181,5)
      IF (IENABL.EQ.0) RETURN
C
      IPITH= IABS(IPITCH)
      IF (IPITH.GT.255) IPITH= 255
      IF (IPITH.LT.1) IPITH= 1
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) IPITH0(IHATN0,1)= IPITH
      IF (IENAB/2.EQ.1)      IPITH0(IHATN0,2)= IPITH
C
      IDATA(1)= IPITH
      IDATA(2)= IENAB
      CALL G3LINK(5,6,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATPHS(IPHASE,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 335)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE PHASE FOR CROSS-HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IPHASE>, THE PHASE TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HPHS/ IPHAS0(255,2)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= IPHASE
      IF (IPRINT.EQ.1) CALL G0MESG(182,5)
      IF (IENABL.EQ.0) RETURN
C
      IPHAS= IPHASE
      IF (IPHAS.GT.255) IPHAS= 255
      IF (IPHAS.LT.0) RETURN
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) IPHAS0(IHATN0,1)= IPHAS
      IF (IENAB/2.EQ.1)      IPHAS0(IHATN0,2)= IPHAS
C
      IDATA(1)= IPHAS
      IDATA(2)= IENAB
      CALL G3LINK(5,9,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATSFT(ISHIFT,IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 336)   VERSION (A8.1)    09:JUL:87
C          ------------------------------------------------
C
C          THIS SETS THE DISTANCE FROM THE POINT (0,0)
C          THAT THE CONTROL LINE PASSES THROUGH.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ISHIFT>, THE SHIFT TO BE SET,
C          <IENABL>, CONTROLS WHICH PARAMETERS ARE SET:
C                =1, TO APPLY TO THE FIRST SET OF LINES,
C                =2, TO APPLY TO THE SECOND SET OF LINES,
C                =3, TO APPLY TO BOTH SETS OF LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HOFF/ ISHFT0(255,2)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= ISHIFT
      IF (IPRINT.EQ.1) CALL G0MESG(183,5)
      IF (IENABL.EQ.0) RETURN
C
      ISHFT= ISHIFT
      IF (ISHFT.GT.255) ISHFT= 255
      IF (ISHFT.LT.0) RETURN
C
      IENAB= IENABL
      IF (IENAB.LT.1.OR.IENAB.GT.3) IENAB= 3
      IF (MOD(IENAB,2).EQ.1) ISHFT0(IHATN0,1)= ISHFT
      IF (IENAB/2.EQ.1)      ISHFT0(IHATN0,2)= ISHFT
C
      IDATA(1)= ISHFT
      IDATA(2)= IENAB
      CALL G3LINK(5,7,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HATYPE(ITYPE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 337)   VERSION (A8.1)    18:NOV:86
C          ------------------------------------------------
C
C          THIS CONTROLS THE TYPE OF CROSS-HATCHING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ITYPE>, CONTROLS WHICH SET OF PARAMETERS ARE USED:
C                =1, USE THE FIRST SET OF PARAMETERS,
C                =2, USE THE SECOND SET OF PARAMETERS,
C                =3, USE BOTH SETS OF PARAMETERS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0HNUM/ IHATN0
      COMMON /T0HTYP/ IHAT0(255)
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= ITYPE
      IF (IPRINT.EQ.1) CALL G0MESG(184,5)
C
      IHAT= ITYPE
      IF (IHAT.LT.1.OR.IHAT.GT.3) IHAT= 3
C
      IHAT0(IHATN0)= IHAT
      IDATA(1)= IHAT
      CALL G3LINK(5,11,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HISTGM(XORIG,YORIG,BARWID,VALUES,ISTART,ISTOP)
C
C          ------------------------------------------------
C          ROUTINE NO. (  81)   VERSION (A8.8)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A HISTOGRAM OF A GIVEN SET OF VALUES.
C                BARS CAN BE HORIZONTAL OR VERTICAL.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XORIG>  IS THE X-ORIGIN OF THE GRAPH,
C          <YORIG>  IS THE Y-ORIGIN OF THE GRAPH,
C          <BARWID> IS THE THICKNESS OF THE BARS,
C          [VALUES] ARE THE VALUES TO BE GRAPHED,
C          <ISTART> IS THE LOWER BOUNDARY, AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAY.
C
C
      REAL    BAUTO(2),VAUTO(2),VALUES(ISTOP),RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= XORIG
      RTRAC2= YORIG
      RTRAC3= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(33,3)
C
      BORIG= XORIG
      BASPOS= YORIG
      IF (IBRTYP.EQ.0) GO TO 1
C
      BORIG= YORIG
      BASPOS= XORIG
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
    1 NUMBR= ISTOP-ISTART+1
      IF (NUMBR.LT.1) RETURN
C
      BAUTO(1)= BORIG
      BAUTO(2)= BORIG+NUMBR*BARWID
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 INDEX= ISTART,ISTOP
        VAL=VALUES(INDEX)
        IF (VAL.LT.VAUTO(1)) VAUTO(1)=VAL
        IF (VAL.GT.VAUTO(2)) VAUTO(2)=VAL
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 5
C
      BRPOS= BORIG
      KOLIND= 1
C
      DO 200 IBAR= ISTART,ISTOP
        BRPOS1= BRPOS+BARWID
        IF (LSTCL0(KOLIND).EQ.0) GO TO 4
C
        IDATA(1)= 0
        IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
        CALL G3LINK(5,13,-1,IDATA,RDATA)
        IDATA(1)= IABS(LSTCL0(KOLIND))
        CALL G3LINK(5,3,-1,IDATA,RDATA)
        IF (IBRTYP.NE.0) GO TO 2
C
        CALL POSITN(BRPOS,YORIG)
        CALL JOIN(BRPOS,VALUES(IBAR))
        CALL JOIN(BRPOS1,VALUES(IBAR))
        CALL JOIN(BRPOS1,YORIG)
        CALL JOIN(BRPOS,YORIG)
        GO TO 3
C
    2   CALL POSITN(XORIG,BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS)
        CALL JOIN(VALUES(IBAR),BRPOS1)
        CALL JOIN(XORIG,BRPOS1)
        CALL JOIN(XORIG,BRPOS)
    3   CALL G3LINK(5,4,0,IDATA,RDATA)
    4   BRPOS= BRPOS1
        KOLIND= KOLIND+1
        IF (KOLIND.GT.LENLST) KOLIND= 1
  200 CONTINUE
C
      IF (IDRBND.EQ.0) GO TO 10
C
    5 OLDVAL= -(VALUES(ISTART)-BASPOS)
      CALL POSITN(XORIG,YORIG)
      BRPOS= BORIG
C
      DO 300 IBAR= ISTART,ISTOP
        VALUE= VALUES(IBAR)-BASPOS
        IF (VALUE*OLDVAL.LT.0.0)       GO TO 6
        IF (IBRTYP.EQ.0) CALL POSITN(BRPOS,OLDVAL+BASPOS)
        IF (IBRTYP.NE.0) CALL POSITN(OLDVAL+BASPOS,BRPOS)
        IF (ABS(VALUE).GT.ABS(OLDVAL)) GO TO 6
        IF (IBRTYP.EQ.0) CALL POSITN(BRPOS,VALUE+BASPOS)
        IF (IBRTYP.NE.0) CALL POSITN(VALUE+BASPOS,BRPOS)
        GO TO 7
C
    6   IF (IBRTYP.EQ.0)  CALL JOIN(BRPOS,VALUE+BASPOS)
        IF (IBRTYP.NE.0)  CALL JOIN(VALUE+BASPOS,BRPOS)
C
    7   BRPOS= BRPOS+BARWID
        IF (IBRTYP.NE.0) GO TO 8
C
        CALL JOIN(BRPOS,VALUE+BASPOS)
        CALL JOIN(BRPOS,BASPOS)
        GO TO 9
C
    8   CALL JOIN(VALUE+BASPOS,BRPOS)
        CALL JOIN(BASPOS,BRPOS)
    9   OLDVAL= VALUE
  300 CONTINUE
C
      CALL JOIN(XORIG,YORIG)
   10 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE HLS
C
C          ------------------------------------------------
C          ROUTINE NO. (  64)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS THE <HSV> COLOUR SYSTEM. COLOUR
C          PARAMETERS ARE NOW <HUE, LIGHTNESS, SATURATION>.
C
C
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(130,0)
C
      KOLSYS= 2
C
      RETURN
      END
      SUBROUTINE HMENU(XFIRST,XLAST,YFIRST,YLAST,LABELS,
     &                NLABLS,IDRAW,ISELEC)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 324)   VERSION (A8.1)    11:AUG:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS A HORIZONTAL MENU AND RETURNS A CHOSEN ITEM.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XFIRST,YFIRST> IS THE START CORNER, AND
C          <XLAST,YLAST>   IS THE FINISH CORNER OF THE MENU AREA.
C          [LABELS]   CONTAINS THE LABELS TO BE WRITTEN
C                     IN THE MENU BOXES.
C          <NLABLS>   IS THE NUMBER OF LABELS.
C          <IDRAW>    WHEN SET TO ZERO, THE MENU IS NOT DRAWN.
C          <ISELEC>   IS THE NUMBER OF THE CHOSEN MENU ITEM.
C
C
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0TRAC/ IPRINT
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(169,0)
C
      IPRSAV= IPRINT
      IPRINT= 0
      ISELEC= 0
      IF (IDRAW.NE.0) CALL HCHTKY(XFIRST,XLAST,YFIRST,YLAST,LABELS,
     &                            NLABLS)
C
    1 CALL CURSOR(XPOS,YPOS,ICHAR)
      IF (ICHAR.EQ.33) RETURN
      IF ((XPOS-XFIRST)*(XPOS-XLAST).GT.0.0) GO TO 1
C
      XINT= (XLAST-XFIRST)/NLABLS
      SELEC= (XPOS+XINT-XFIRST)/XINT
      REM= AMOD(SELEC,1.0)
      IF (REM.LT.0.05.OR.REM.GT.0.95) GO TO 1
C
      ISELEC= SELEC
      IPRINT= IPRSAV
      RETURN
      END
      SUBROUTINE HRDCHR(ISET)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 174)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS HARDWARE OR SOFTWARE CHAR. TYPES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0HRDC/ KHRDW0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ISET
      IF (IPRINT.EQ.1) CALL G0MESG(47,5)
C
      KHRDW0= ISET
      IF (KHRDW0.NE.0) KHRDW0= 1
      IDATA(1)= KHRDW0
      CALL G3LINK(2,1,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HRDLIN(ISET)
C
C          ------------------------------------------------
C          ROUTINE NO. (  53)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS HARDWARE OR SOFTWARE LINE TYPES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0HRDL/ LHRDW0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ISET
      IF (IPRINT.EQ.1) CALL G0MESG(46,5)
C
      LHRDW0= ISET
      IF (LHRDW0.NE.0) LHRDW0= 1
      IDATA(1)= LHRDW0
      CALL G3LINK(3,7,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HSI
C
C          ------------------------------------------------
C          ROUTINE NO. (  65)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS THE <HSI> COLOUR SYSTEM. COLOUR
C          PARAMETERS ARE NOW <HUE, SATURATION, INTENSITY>.
C
C
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(131,0)
C
      KOLSYS= 3
C
      RETURN
      END
      SUBROUTINE HSV
C
C          ------------------------------------------------
C          ROUTINE NO. (  66)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS THE <HSI> COLOUR SYSTEM. COLOUR
C          PARAMETERS ARE NOW <HUE, SATURATION, VALUE>.
C
C
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(131,0)
C
      KOLSYS= 1
C
      RETURN
      END
      SUBROUTINE INCBAR(BASPOS,BARWID,BARPOS,VALSTS,ISTART,ISTOP,NOVALS,
     &                  NOSETS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 110)   VERSION (A8.1)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A MULTIPLE BAR CHART OF A GIVEN SET OF
C          VALUES,WITH HORIZONTAL OR VERTICAL BARS.
C          THIS USES INCREMENTAL VALUES.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <BASPOS>  IS THE BASELINE ORIGIN OF THE GRAPH,
C          <BARWID>  IS THE THICKNESS OF THE BARS,
C          [BARPOS]  ARE THE POSITIONS OF THE BARS,
C          [VALSTS]  ARE THE VALUES TO BE GRAPHED,
C          <ISTART>  IS THE LOWER BOUNDARY, AND
C          <ISTOP>   IS THE UPPER BOUNDARY OF THE BAR NUMBERS,
C          <NOVALS>  IS THE TOTAL NUMBER OF BARS IN THE VALUES ARRAY,
C          <NOSETS>  IS THE TOTAL NUMBER OF SETS OF BARS IN THE VALUES ARRAY.
C
C
      REAL    BAUTO(2),VAUTO(2),BARPOS(ISTOP),VALSTS(NOVALS,NOSETS)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
      RTRAC1= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(167,1)
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
      IF (ISTOP.LT.ISTART) RETURN
C
      BAUTO(1)= BARPOS(ISTART)-BARWID*0.5
      BAUTO(2)= BARPOS(ISTOP)+BARWID*0.5
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 IBRCNT= ISTART,ISTOP
        VAL= BASPOS
C
        DO 200 ISTCNT= 1,NOSETS
          IF (ISTCNT.GT.100) GO TO 1
          IF (INFLGS(ISTCNT).EQ.0) GO TO 200
C
    1     VAL= VAL+ABS(VALSTS(IBRCNT,ISTCNT))
  200   CONTINUE
C
        IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 5
C
      DO 300 IBAR= ISTART,ISTOP
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
        FROM= BASPOS
C
        DO 400 IEASET= 1,NOSETS
          IF (IEASET.GT.100) GO TO 2
          IF (INFLGS(IEASET).EQ.0) GO TO 400
C
    2     KOLIND= MOD(IEASET,LENLST)
          IF (KOLIND.EQ.0) KOLIND= LENLST
          IF (LSTCL0(KOLIND).EQ.0) GO TO 400
C
          IDATA(1)= 0
          IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
          CALL G3LINK(5,13,-1,IDATA,RDATA)
          IDATA(1)= IABS(LSTCL0(KOLIND))
          CALL G3LINK(5,3,-1,IDATA,RDATA)
          CURVAL= FROM+ABS(VALSTS(IBAR,IEASET))
          IF (IBRTYP.NE.0) GO TO 3
C
          CALL POSITN(BRPOS,FROM)
          CALL JOIN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          CALL JOIN(BRPOS1,FROM)
          CALL JOIN(BRPOS,FROM)
          GO TO 4
C
    3     CALL POSITN(FROM,BRPOS)
          CALL JOIN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
          CALL JOIN(FROM,BRPOS1)
          CALL JOIN(FROM,BRPOS)
    4     CALL G3LINK(5,4,0,IDATA,RDATA)
          FROM= CURVAL
  400   CONTINUE
  300 CONTINUE
C
      IF (IDRBND.EQ.0) GO TO 10
C
    5 DO 700 IBAR= ISTART,ISTOP
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
        CURVAL= BASPOS
C
        DO 800 ISTCNT= 1,NOSETS
C
C       DO FOR EACH VALUE
C
          IF (ISTCNT.GT.100) GO TO 6
          IF (INFLGS(ISTCNT).EQ.0) GO TO 800
C
    6     CURVAL= CURVAL+ABS(VALSTS(IBAR,ISTCNT))
          IF (IBRTYP.NE.0) GO TO 7
C
          CALL POSITN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          GO TO 800
C
    7     CALL POSITN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
  800   CONTINUE
C
        IF (IBRTYP.NE.0) GO TO 8
C
        CALL POSITN(BRPOS,BASPOS)
        CALL JOIN(BRPOS,CURVAL)
        CALL POSITN(BRPOS1,CURVAL)
        CALL JOIN(BRPOS1,BASPOS)
        GO TO 700
C
    8   CALL POSITN(BASPOS,BRPOS)
        CALL JOIN(CURVAL,BRPOS)
        CALL POSITN(CURVAL,BRPOS1)
        CALL JOIN(BASPOS,BRPOS1)
  700 CONTINUE
C
C     DRAW BASELINE
C
      IF (IBRTYP.NE.0) GO TO 9
C
      CALL POSITN(BAUTO(2),BASPOS)
      CALL JOIN(BAUTO(1),BASPOS)
      GO TO 10
C
    9 CALL POSITN(BASPOS,BAUTO(2))
      CALL JOIN(BASPOS,BAUTO(1))
   10 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE INCHIS(XORIG,YORIG,BARWID,VALSTS,ISTART,ISTOP,NOVALS,
     &                  NOSETS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 116)   VERSION (A8.1)    23:JUN:87
C          ------------------------------------------------
C
C          THIS DRAWS A SET OF HISTOGRAMS FROM GIVEN VALUES.
C          BARS CAN BE HORIZONTAL OR VERTICAL.
C          THIS USES INCREMENTAL VALUES.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XORIG>  IS THE X-ORIGIN OF THE GRAPH,
C          <YORIG>  IS THE Y-ORIGIN OF THE GRAPH,
C          <BARWID> IS THE THICKNESS OF THE BARS,
C          [VALSTS] ARE THE VALUES TO BE GRAPHED,
C          <ISTART> IS THE LOWER BOUNDARY, AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE BAR NUMBERS,
C          <NOVALS> IS THE TOTAL NUMBER OF BARS IN THE VALUES ARRAY,
C          <NOSETS> IS THE TOTAL NUMBER OF SETS OF BARS IN THE VALUES ARRAY.
C
C
      REAL    BAUTO(2),VAUTO(2),VALSTS(NOVALS,NOSETS),RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= XORIG
      RTRAC2= YORIG
      RTRAC3= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(168,3)
C
      BORIG= XORIG
      BASPOS= YORIG
      IF (IBRTYP.EQ.0) GO TO 1
C
      BORIG= YORIG
      BASPOS= XORIG
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
    1 NUMBR= ISTOP-ISTART+1
      IF (NUMBR.LT.1) RETURN
C
      BAUTO(1)= BORIG
      BAUTO(2)= BORIG+NUMBR*BARWID
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 IBRCNT= ISTART,ISTOP
        VAL= BASPOS
C
        DO 200 ISTCNT= 1,NOSETS
          IF (ISTCNT.GT.100) GO TO 2
          IF (INFLGS(ISTCNT).EQ.0) GO TO 200
C
    2     VAL= VAL+ABS(VALSTS(IBRCNT,ISTCNT))
  200   CONTINUE
C
        IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 6
C
      BRPOS= BORIG
C
      DO 300 IBAR= ISTART,ISTOP
        BRPOS1=BRPOS+BARWID
        FROM= BASPOS
C
        DO 400 IEASET= 1,NOSETS
          IF (IEASET.GT.100) GO TO 3
          IF (INFLGS(IEASET).EQ.0) GO TO 400
C
    3     KOLIND= MOD(IEASET,LENLST)
          IF (KOLIND.EQ.0) KOLIND= LENLST
          IF (LSTCL0(KOLIND).EQ.0) GO TO 400
C
          IDATA(1)= 0
          IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
          CALL G3LINK(5,13,-1,IDATA,RDATA)
          IDATA(1)= IABS(LSTCL0(KOLIND))
          CALL G3LINK(5,3,-1,IDATA,RDATA)
          CURVAL= FROM+ABS(VALSTS(IBAR,IEASET))
          IF (IBRTYP.NE.0) GO TO 4
C
          CALL POSITN(BRPOS,FROM)
          CALL JOIN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          CALL JOIN(BRPOS1,FROM)
          CALL JOIN(BRPOS,FROM)
          GO TO 5
C
    4     CALL POSITN(FROM,BRPOS)
          CALL JOIN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
          CALL JOIN(FROM,BRPOS1)
          CALL JOIN(FROM,BRPOS)
    5     CALL G3LINK(5,4,0,IDATA,RDATA)
          FROM= CURVAL
  400   CONTINUE
C
        BRPOS= BRPOS1
  300 CONTINUE
C
    6 BRPOS1= BORIG
C
      DO 700 IBAR= ISTART,ISTOP
        BRPOS=  BRPOS1
        BRPOS1= BRPOS+BARWID
        CURVAL= BASPOS
C
        DO 800 ISTCNT= 1,NOSETS
C
C       DO FOR EACH VALUE IN BAR
C
          IF (ISTCNT.GT.100) GO TO 7
          IF (INFLGS(ISTCNT).EQ.0) GO TO 800
C
    7     CURVAL= CURVAL+ABS(VALSTS(IBAR,ISTCNT))
          IF (IBRTYP.NE.0) GO TO 8
C
          CALL POSITN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          GOTO 800
C
    8     CALL POSITN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
  800   CONTINUE
C
        IF (IBRTYP.NE.0) GO TO 9
C
        CALL POSITN(BRPOS,BASPOS)
        CALL JOIN(BRPOS,CURVAL)
        CALL POSITN(BRPOS1,CURVAL)
        CALL JOIN(BRPOS1,BASPOS)
        GO TO 700
C
    9   CALL POSITN(BASPOS,BRPOS)
        CALL JOIN(CURVAL,BRPOS)
        CALL POSITN(CURVAL,BRPOS1)
        CALL JOIN(BASPOS,BRPOS1)
  700 CONTINUE
C
C     DRAW BASELINE
C
      IF (IBRTYP.EQ.0) CALL POSITN(BRPOS1,BASPOS)
      IF (IBRTYP.NE.0) CALL POSITN(BASPOS,BRPOS1)
C
      CALL JOIN(XORIG,YORIG)
      CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE INTENS(BRIGHT,NCOLOR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  60)   VERSION (A7.2)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS A COLOUR TABLE ENTRY TO AN INTENSITY LEVEL.
C
C
C          <BRIGHT>  GIVES THE INTENSITY LEVEL.
C          <NCOLOR>  IS THE COLOUR NUMBER.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0KTAB/ REDCO0(255),GRNCO0(255),BLUCO0(255),NCOLS0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= BRIGHT
      RTRAC2= NCOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(37,2)
C
      IF (NCOLOR.LT.1.OR.NCOLOR.GT.255) RETURN
      BRILL= BRIGHT
      IF (BRILL.LT.0.0) BRILL= 0.0
      IF (BRILL.GT.1.0) BRILL= 1.0
C
      IF (NCOLS0.LT.NCOLOR) NCOLS0= NCOLOR
      REDCO0(NCOLOR)= BRILL
      GRNCO0(NCOLOR)= BRILL
      BLUCO0(NCOLOR)= BRILL
C
      RDATA(1)= NCOLOR
      RDATA(2)= BRILL
      RDATA(3)= BRILL
      RDATA(4)= BRILL
      CALL G3LINK(5,1,4*NBYTR,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE IOCHNL(IMESGI,IMESGO,IDISPI,IDISPO)
C
C          ------------------------------------------------
C          ROUTINE NO. (  18)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CHANGES THE I/O CHANNEL NUMBERS.
C
C
C          <IMESGI>  IS THE MESSAGE INPUT CHANNEL NUMBER
C          <IMESGO>  IS THE MESSAGE OUTPUT CHANNEL NUMBER
C          <IDISPI>  IS THE DISPLAY INPUT CHANNEL NUMBER
C          <IDISPO>  IS THE DISPLAY OUTPUT CHANNEL NUMBER
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T1CHAD/ KDISPI,KDISPO
      COMMON /T3CHAM/ KMESGI,KMESGO
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= IMESGI
      ITRAC2= IMESGO
      ITRAC3= IDISPI
      ITRAC4= IDISPO
      IF (IPRINT.EQ.1) CALL G0MESG(124,8)
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
C
      IF (IMESGI.GT.0) KMESGI= IMESGI
      IF (IMESGO.GT.0) KMESGO= IMESGO
      IF (IDISPI.GT.0) KDISPI= IDISPI
      IF (IDISPO.GT.0) KDISPO= IDISPO
C
      RETURN
      END
      SUBROUTINE ISOSUR
C
C          ------------------------------------------------
C          ROUTINE NO. ( 138)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS AN ISOMETRIC PROJECTION
C          FOR THE ROUTINE <SURPLT>.
C
C
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(154,0)
C
      TLTANG= 0.61548
      CSROOT= 1.1547
      COSANG= 0.8660254
      SINANG= 0.5
      RETURN
      END
      SUBROUTINE LBCOLS(NCOLRS,LSTLEN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 107)   VERSION (A8.1)    12:MAR:86
C          ------------------------------------------------
C
C          THIS DEFINES THE CURRENT LABELS COLOUR LIST.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [NCOLRS] IS AN ARRAY OF COLOUR NUMBERS,
C          <LSTLEN> IS THE SIZE OF THE ARRAY.
C
C
      INTEGER NCOLRS(100)
C
      COMMON /T0KLAB/ LABCL0(100),LENLAB
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(164,0)
C
      LENLAB= LSTLEN
      IF (LENLAB.LE.0)   RETURN
      IF (LENLAB.GT.100) LENLAB= 100
C
      DO 100 ISAVE= 1,LENLAB
        LABCL0(ISAVE)= NCOLRS(ISAVE)
        IF (NCOLRS(ISAVE).LT.1.OR.NCOLRS(ISAVE).GT.255) LABCL0(ISAVE)= 0
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE LINEF(FUNCX,FUNCY,STRVAL,STEP,ENDVAL)
C
C          ------------------------------------------------
C          ROUTINE NO. (  99)   VERSION (A8.3)    04:MAR:91
C          ------------------------------------------------
C
C          THIS DRAWS A CURVE DEFINED BY THE TWO SUPPLIED FUNCTIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <FUNCX>  IS THE DEFINING X-FUNCTION, AND
C          <FUNCY>  IS THE DEFINING Y-FUNCTION
C                   OF THE (IMPLICIT) CURVE PARAMETER,
C          <STRVAL> IS THE START VALUE,
C          <STEP>   IS THE INCREMENT SIZE, AND
C          <ENDVAL> IS THE END VALUE OF THE PARAMETER.
C
C
      REAL CURVEX(100),CURVEY(100)
C
      EXTERNAL FUNCX,FUNCY
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA IARRSZ /100/
C
C
      RTRAC1= STRVAL
      RTRAC2= STEP
      RTRAC3= ENDVAL
      IF (IPRINT.EQ.1) CALL G0MESG(41,3)
      IF (ABS(ENDVAL-STRVAL).LT.RMINI.OR.
     &    ABS(STEP).LT.RMINI) RETURN
C
      VALMIN= AMIN1(STRVAL,ENDVAL)
      VALMAX= AMAX1(STRVAL,ENDVAL)
      ABSTEP= ABS(STEP)
      NTOTAL= (VALMAX-VALMIN)/ABSTEP+0.99
      NREPS= (NTOTAL-1)/(IARRSZ-1)+1
      NSTEPS= (NTOTAL-1)/NREPS+2
      NFINIS= NTOTAL-(NSTEPS-1)*(NREPS-1)
      CURVEX(NSTEPS)= FUNCX(VALMIN)
      CURVEY(NSTEPS)= FUNCY(VALMIN)
      IPOS= 0
C
      DO 100 IREP= 1,NREPS
        CURVEX(1)= CURVEX(NSTEPS)
        CURVEY(1)= CURVEY(NSTEPS)
        IF (IREP.EQ.NREPS) NSTEPS= NFINIS
C
        DO 200 ISTEP= 2,NSTEPS
          IPOS= IPOS+1
          CPARAM= VALMIN+(ABSTEP*IPOS)
          CURVEX(ISTEP)= FUNCX(CPARAM)
          CURVEY(ISTEP)= FUNCY(CPARAM)
  200   CONTINUE
C
        IF (IREP.LT.NREPS) GO TO 1
C
        NSTEPS= NSTEPS+1
        CURVEX(NSTEPS)= FUNCX(VALMAX)
        CURVEY(NSTEPS)= FUNCY(VALMAX)
    1   CALL G0CURV(CURVEX,CURVEY,1,NSTEPS,0)
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE LOCATE(XPOS,YPOS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  40)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS SUBSEQUENT PICTURE TRANSLATION.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XPOS>   IS THE NEW DEVICE REFERENCE POINT X-POSITION,
C          <YPOS>   IS THE NEW DEVICE REFERENCE POINT Y-POSITION,
C                   BOTH IN VECTOR-SPACE COORDINATES.
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= XPOS
      RTRAC2= YPOS
      IF (IPRINT.EQ.1) CALL G0MESG(141,2)
C
C      THE NEW DEVICE REFERENCE POINT IS SET.
C
      VRDEVX= XPOS
      VRDEVY= YPOS
      CALL G0MAPP(XPOS,YPOS,RDEVX0,RDEVY0)
C
      RDATA(1)= RDEVX0
      RDATA(2)= RDEVY0
      CALL G3LINK(7,13,2*NBYTR,IDATA,RDATA)
      SHIFT0= .TRUE.
C
C          THE PICTURE REFERENCE POINT IS ALSO UPDATED.
C
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      CALL G0MAPP(XPLOT0,YPLOT0,RPICX0,RPICY0)
C
      RETURN
      END
      SUBROUTINE LSTCOL(NCOLRS,LSTLEN)
C
C          ------------------------------------------------
C          ROUTINE NO. (  68)   VERSION (A8.2)    02:JUN:87
C          ------------------------------------------------
C
C          THIS DEFINES THE CURRENT COLOUR LIST.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [NCOLRS] IS AN ARRAY OF COLOUR NUMBERS,
C          <LSTLEN> IS THE SIZE OF THE ARRAY.
C
C
      INTEGER NCOLRS(100)
C
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(24,0)
C
      LENLST= LSTLEN
      IF (LENLST.LE.0)   RETURN
      IF (LENLST.GT.100) LENLST= 100
C
      DO 100 ISAVE= 1,LENLST
        LSTCL0(ISAVE)= NCOLRS(ISAVE)
        IF (IABS(NCOLRS(ISAVE)).GT.255) LSTCL0(ISAVE)= 0
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE MAPFOL
C
C          ------------------------------------------------
C          ROUTINE NO. (  38)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS REPLACES THE MAP BY THE WINDOW AREA.
C
C
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(125,0)
C
      IF (MRKMAP.EQ.0) RETURN
      CALL G0MAPS(X1WND0,X2WND0,Y1WND0,Y2WND0)
      MRKMAP= 0
C
      RETURN
      END
      SUBROUTINE MAPXL(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  22)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CALLS <G0MAPS> TO SET LOG.-X, LIN.-Y MAPPING.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(8,4)
C
      MAPNUM= 3
      CALL G0MAPS(XAREA1,XAREA2,YAREA1,YAREA2)
C
      RETURN
      END
      SUBROUTINE MAPXYL(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  24)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CALLS <G0MAPS> TO SET LOG.-X, LOG.-Y MAPPING.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(10,4)
C
      MAPNUM= 4
      CALL G0MAPS(XAREA1,XAREA2,YAREA1,YAREA2)
C
      RETURN
      END
      SUBROUTINE MAPYL(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  23)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CALLS <G0MAPS> TO SET LIN.-X, LOG.-Y MAPPING.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(9,4)
C
      MAPNUM= 2
      CALL G0MAPS(XAREA1,XAREA2,YAREA1,YAREA2)
C
      RETURN
      END
      SUBROUTINE MARKER(ICHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  84)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE POLYMARKER CHARACTER.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0MRKS/ MARKC0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ICHAR
      IF (IPRINT.EQ.1) CALL G0MESG(120,5)
C
      IF (ICHAR.LT.0.OR.ICHAR.GT.255) GO TO 901
      MARKC0= ICHAR
      IDATA(1)= ICHAR
      CALL G3LINK(2,9,-1,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 33
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE MASK(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  28)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS RECTANGULAR MASKING AREAS.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0MASK/ X1MSK0(10),X2MSK0(10),Y1MSK0(10),Y2MSK0(10),MSKLV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(13,4)
C
C          IF THE MASK LEVEL IS VALID, THE NEW VALUES ARE SET.
C
      IF (MSKLV0.GE.10) GO TO 901
C
      MSKLV0= MSKLV0+1
      X1MSK0(MSKLV0)= XAREA1
      Y1MSK0(MSKLV0)= YAREA1
      X2MSK0(MSKLV0)= XAREA2
      Y2MSK0(MSKLV0)= YAREA2
C
      RDATA(1)= XAREA1
      RDATA(2)= XAREA2
      RDATA(3)= YAREA1
      RDATA(4)= YAREA2
      CALL G3LINK(7,6,4*NBYTR,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 3
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE MATCOL(MCOLRS,NOROWS,NOCOLS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  44)   VERSION (A8.1)    04:JUN:87
C          ------------------------------------------------
C
C          THIS DEFINES THE CURRENT COLOUR FILL MATRIX.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [MCOLRS] IS A MATRIX OF COLOUR NUMBERS,
C          <NOROWS> IS THE NUMBER OF ROWS AND
C          <NOCOLS> IS THE NUMBER OF COLUMNS IN THE MATRIX.
C
C
      INTEGER MCOLRS(NOROWS,NOCOLS)
C
      COMMON /T0KMAT/ MATCL0(55,55),MTROWS,MTCOLS
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(174,0)
C
      MTROWS= NOROWS
      MTCOLS= NOCOLS
C
      IF (MTROWS.LT.0.OR.MTCOLS.LT.0) RETURN
      IF (MTROWS.GT.55) MTROWS= 55
      IF (MTCOLS.GT.55) MTCOLS= 55
C
      DO 100 INDEXC= 1,MTCOLS
        DO 100 INDEXR= 1,MTROWS
          MATCL0(INDEXR,INDEXC)= MCOLRS(INDEXR,INDEXC)
          IF (IABS(MATCL0(INDEXR,INDEXC)).GT.255)
     &             MATCL0(INDEXR,INDEXC)= 0
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE MOVE(DX,DY)
C
C          ------------------------------------------------
C          ROUTINE NO. (  74)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CHANGES THE PEN POSITION BY (DX,DY).
C
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
C
C
      X= XPLOT0+DX
      Y= YPLOT0+DY
      CALL POSITN(X,Y)
C
      RETURN
      END
      SUBROUTINE MOVEPT(DX,DY)
C
C          ------------------------------------------------
C          ROUTINE NO. (  75)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A POINT AFTER MOVING THE PEN BY (DX,DY).
C
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
C
C
      X= XPLOT0+DX
      Y= YPLOT0+DY
      CALL POINT(X,Y)
C
      RETURN
      END
      SUBROUTINE MSKCHR(IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 183)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS WHETHER CHARACTERS ARE
C          SUBJECT TO THE MASK AREAS OR NOT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CVIS/ KWIND0,KMASK0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= IENABL
      IF (IPRINT.EQ.1) CALL G0MESG(140,5)
C
      KMASK0= IENABL
      IF (KMASK0.NE.0) KMASK0= 1
      IDATA(1)= KMASK0
      CALL G3LINK(2,14,-1,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE MULBAR(BASPOS,BARWID,BARPOS,VALSTS,ISTART,ISTOP,NOVALS,
     &                  NOSETS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  95)   VERSION (A8.1)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A MULTIPLE BAR CHART OF A GIVEN SET OF
C          VALUES,WITH HORIZONTAL OR VERTICAL BARS.
C          THIS USES ABSOLUTE VALUES.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <BASPOS>  IS THE BASELINE ORIGIN OF THE GRAPH,
C          <BARWID>  IS THE THICKNESS OF THE BARS,
C          [BARPOS]  ARE THE POSITIONS OF THE BARS,
C          [VALSTS]  ARE THE VALUES TO BE GRAPHED,
C          <ISTART>  IS THE LOWER BOUNDARY, AND
C          <ISTOP>   IS THE UPPER BOUNDARY OF THE BAR NUMBERS,
C          <NOVALS>  IS THE TOTAL NUMBER OF BARS IN THE VALUES ARRAY,
C          <NOSETS>  IS THE TOTAL NUMBER OF SETS OF BARS IN THE VALUES ARRAY.
C
C
c slmod begin
      COMMON /GHOSTCOM/ iopt_ghost

      REAL CURTOP(NOVALS,NOSETS)
c slmod end
      REAL    BAUTO(2),VAUTO(2),BARPOS(ISTOP),VALSTS(NOVALS,NOSETS)
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
      RTRAC1= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(161,1)
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
      IF (ISTOP.LT.ISTART) RETURN
C
      BAUTO(1)= BARPOS(ISTART)-BARWID*0.5
      BAUTO(2)= BARPOS(ISTOP)+BARWID*0.5
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 ISTCNT= 1,NOSETS
        IF (ISTCNT.GT.100) GO TO 1
        IF (INFLGS(ISTCNT).EQ.0) GO TO 100
C
    1   DO 200 IBRCNT= ISTART,ISTOP
          VAL= VALSTS(IBRCNT,ISTCNT)
          IF (VAL.LT.VAUTO(1)) VAUTO(1)= VAL
          IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  200   CONTINUE
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 9
C
      DO 300 IBAR= ISTART,ISTOP
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
C
        DO 400 IEASET= 1,NOSETS
c slmod begin
          IF (iopt_ghost.EQ.3) THEN
            BRSHIFT=BARWID/REAL(NOSETS)
            BRPOS= BARPOS(IBAR)-BARWID*0.5+(IEASET-1)*BRSHIFT
            BRPOS1= BRPOS+BRSHIFT
          ENDIF
c slmod end
          IF (IEASET.GT.100) GO TO 2
          IF (INFLGS(IEASET).EQ.0) GO TO 400
C
    2     KOLIND= MOD(IEASET,LENLST)
          IF (KOLIND.EQ.0) KOLIND= LENLST
          IF (LSTCL0(KOLIND).EQ.0) GO TO 400
C
          IDATA(1)= 0
          IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
          CALL G3LINK(5,13,-1,IDATA,RDATA)
          IDATA(1)= IABS(LSTCL0(KOLIND))
          CALL G3LINK(5,3,-1,IDATA,RDATA)
          CURVAL= VALSTS(IBAR,IEASET)
          FROM= BASPOS
          IF (CURVAL.LT.BASPOS) GO TO 4
C
          DO 500 ISTCNT= 1,NOSETS
            IF (ISTCNT.GT.100) GO TO 3
            IF (INFLGS(ISTCNT).EQ.0) GO TO 500
C
    3       VAL= VALSTS(IBAR,ISTCNT)
            IF (VAL.LT.CURVAL.AND.VAL.GT.FROM) FROM= VAL
  500     CONTINUE
C
          GO TO 6
C
    4     DO 600 ISTCNT= 1,NOSETS
            IF (ISTCNT.GT.100) GO TO 5
            IF (INFLGS(ISTCNT).EQ.0) GO TO 600
C
    5       VAL= VALSTS(IBAR,ISTCNT)
            IF (VAL.GT.CURVAL.AND.VAL.LT.FROM) FROM= VAL
  600     CONTINUE
C
    6     IF (IBRTYP.NE.0) GO TO 7
C
c slmod begin
          IF (iopt_ghost.EQ.3) THEN
            FROM= 0.0
          ELSE
            IF (IEASET.EQ.1) THEN
              FROM= 0.0
              CURTOP(IBAR,IEASET)= CURVAL
            ELSE
              FROM= CURTOP(IBAR,IEASET-1)
              CURVAL = CURVAL + FROM
              CURTOP(IBAR,IEASET)= CURVAL              
            ENDIF
          ENDIF
c slmod end
          CALL POSITN(BRPOS,FROM)
          CALL JOIN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          CALL JOIN(BRPOS1,FROM)
          CALL JOIN(BRPOS,FROM)
          GO TO 8
C
    7     CALL POSITN(FROM,BRPOS)
          CALL JOIN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
          CALL JOIN(FROM,BRPOS1)
          CALL JOIN(FROM,BRPOS)
    8     CALL G3LINK(5,4,0,IDATA,RDATA)
  400   CONTINUE
  300 CONTINUE
C
      IF (IDRBND.EQ.0) GO TO 14
C
    9 DO 700 IBAR= ISTART,ISTOP
        RLOWST= BASPOS
        HIGST= BASPOS
        BRPOS= BARPOS(IBAR)-BARWID*0.5
        BRPOS1= BRPOS+BARWID
C
        DO 800 ISTCNT= 1,NOSETS
c slmod begin
          IF (iopt_ghost.EQ.3) THEN
            BRSHIFT= BARWID/REAL(NOSETS)
            BRPOS= BARPOS(IBAR)-BARWID*0.5+(ISTCNT-1)*BRSHIFT
            BRPOS1= BRPOS+BRSHIFT
          ENDIF
c slmod end
C
C       DO FOR EACH VALUE
C
          IF (ISTCNT.GT.100) GO TO 10
          IF (INFLGS(ISTCNT).EQ.0) GO TO 800
C
   10     CURVAL= VALSTS(IBAR,ISTCNT)
          IF (CURVAL.LT.RLOWST) RLOWST= CURVAL
          IF (CURVAL.GT.HIGST) HIGST= CURVAL
          IF (IBRTYP.NE.0) GO TO 11
C
c slmod begin
          IF (iopt_ghost.EQ.3) THEN
            CALL POSITN(BRPOS,CURVAL)
            CALL JOIN(BRPOS1,CURVAL)
            CALL JOIN(BRPOS1,0.0)
            CALL JOIN(BRPOS,0.0)
            CALL JOIN(BRPOS,CURVAL)
          ELSE
            IF (ISTCNT.EQ.1) THEN
              CALL POSITN(BRPOS,CURVAL)
              CALL JOIN(BRPOS1,CURVAL)
              CALL JOIN(BRPOS1,0.0)
              CALL JOIN(BRPOS,0.0)
              CALL JOIN(BRPOS,CURVAL)
            ELSE
              CALL POSITN(BRPOS,CURVAL+CURTOP(IBAR,ISTCNT-1))
              CALL JOIN(BRPOS1,CURVAL+CURTOP(IBAR,ISTCNT-1))
              CALL JOIN(BRPOS1,CURTOP(IBAR,ISTCNT-1))
              CALL JOIN(BRPOS,CURTOP(IBAR,ISTCNT-1))
              CALL JOIN(BRPOS,CURVAL+CURTOP(IBAR,ISTCNT-1))
            ENDIF
          ENDIF
c
c          CALL POSITN(BRPOS,CURVAL)
c          CALL JOIN(BRPOS1,CURVAL)
c slmod end
          GO TO 800
C
   11     CALL POSITN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
  800   CONTINUE
C
        IF (IBRTYP.NE.0) GO TO 12
C
c slmod begin
        IF (iopt_ghost.EQ.3) GOTO 700 
c slmod end
        CALL POSITN(BRPOS,RLOWST)
        CALL JOIN(BRPOS,HIGST)
        CALL POSITN(BRPOS1,HIGST)
        CALL JOIN(BRPOS1,RLOWST)
        GO TO 700
C
   12   CALL POSITN(RLOWST,BRPOS)
        CALL JOIN(HIGST,BRPOS)
        CALL POSITN(HIGST,BRPOS1)
        CALL JOIN(RLOWST,BRPOS1)
  700 CONTINUE
C
C     DRAW BASELINE
C
      IF (IBRTYP.NE.0) GO TO 13
C
      CALL POSITN(BAUTO(2),BASPOS)
      CALL JOIN(BAUTO(1),BASPOS)
      GO TO 14
C
   13 CALL POSITN(BASPOS,BAUTO(2))
      CALL JOIN(BASPOS,BAUTO(1))
   14 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE MULHIS(XORIG,YORIG,BARWID,VALSTS,ISTART,ISTOP,NOVALS,
     &                  NOSETS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  94)   VERSION (A8.1)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A SET OF HISTOGRAMS FROM GIVEN VALUES.
C          BARS CAN BE HORIZONTAL OR VERTICAL.
C          THIS USES ABSOLUTE VALUES.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XORIG>  IS THE X-ORIGIN OF THE GRAPH,
C          <YORIG>  IS THE Y-ORIGIN OF THE GRAPH,
C          <BARWID> IS THE THICKNESS OF THE BARS,
C          [VALSTS] ARE THE VALUES TO BE GRAPHED,
C          <ISTART> IS THE LOWER BOUNDARY, AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE BAR NUMBERS,
C          <NOVALS> IS THE TOTAL NUMBER OF BARS IN THE VALUES ARRAY,
C          <NOSETS> IS THE TOTAL NUMBER OF SETS OF BARS IN THE VALUES ARRAY.
C
C
      REAL    BAUTO(2),VAUTO(2),VALSTS(NOVALS,NOSETS),RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= XORIG
      RTRAC2= YORIG
      RTRAC3= BARWID
      IF (IPRINT.EQ.1) CALL G0MESG(160,3)
C
      BORIG= XORIG
      BASPOS= YORIG
      IF (IBRTYP.EQ.0) GO TO 1
C
      BORIG= YORIG
      BASPOS= XORIG
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
    1 NUMBR= ISTOP-ISTART+1
      IF (NUMBR.LT.1) RETURN
C
      BAUTO(1)= BORIG
      BAUTO(2)= BORIG+NUMBR*BARWID
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 ISTCNT= 1,NOSETS
        IF (ISTCNT.GT.100) GO TO 2
        IF (INFLGS(ISTCNT).EQ.0) GO TO 100
C
    2   DO 200 IBRCNT= ISTART,ISTOP
          VAL=VALSTS(IBRCNT,ISTCNT)
          IF (VAL.LT.VAUTO(1)) VAUTO(1)= VAL
          IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  200   CONTINUE
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (LENLST.LE.0) GO TO 10
C
      BRPOS= BORIG
C
      DO 300 IBAR= ISTART,ISTOP
        BRPOS1=BRPOS+BARWID
C
        DO 400 IEASET= 1,NOSETS
          IF (IEASET.GT.100) GO TO 3
          IF (INFLGS(IEASET).EQ.0) GO TO 400
C
    3     KOLIND= MOD(IEASET,LENLST)
          IF (KOLIND.EQ.0) KOLIND= LENLST
          IF (LSTCL0(KOLIND).EQ.0) GO TO 400
C
          IDATA(1)= 0
          IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
          CALL G3LINK(5,13,-1,IDATA,RDATA)
          IDATA(1)= IABS(LSTCL0(KOLIND))
          CALL G3LINK(5,3,-1,IDATA,RDATA)
          CURVAL= VALSTS(IBAR,IEASET)
          FROM= BASPOS
          IF (CURVAL.LT.BASPOS) GO TO 5
C
          DO 500 ISTCNT= 1,NOSETS
            IF (ISTCNT.GT.100) GO TO 4
            IF (INFLGS(ISTCNT).EQ.0) GO TO 500
C
    4       VAL= VALSTS(IBAR,ISTCNT)
            IF (VAL.LT.CURVAL.AND.VAL.GT.FROM) FROM= VAL
  500     CONTINUE
C
          GO TO 7
C
    5     DO 600 ISTCNT= 1,NOSETS
            IF (ISTCNT.GT.100) GO TO 6
            IF (INFLGS(ISTCNT).EQ.0) GO TO 600
C
    6       VAL= VALSTS(IBAR,ISTCNT)
            IF (VAL.GT.CURVAL.AND.VAL.LT.FROM) FROM= VAL
  600     CONTINUE
C
    7     IF (IBRTYP.NE.0) GO TO 8
C
          CALL POSITN(BRPOS,FROM)
          CALL JOIN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          CALL JOIN(BRPOS1,FROM)
          CALL JOIN(BRPOS,FROM)
          GO TO 9
C
    8     CALL POSITN(FROM,BRPOS)
          CALL JOIN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
          CALL JOIN(FROM,BRPOS1)
          CALL JOIN(FROM,BRPOS)
    9     CALL G3LINK(5,4,0,IDATA,RDATA)
  400   CONTINUE
C
        BRPOS= BRPOS1
  300 CONTINUE
C
      IF (IDRBND.EQ.0) GO TO 14
C
   10 BRPOS1= BORIG
C
      DO 700 IBAR= ISTART,ISTOP
        RLOWST= BASPOS
        HIGST= BASPOS
        BRPOS=  BRPOS1
        BRPOS1= BRPOS+BARWID
C
        DO 800 ISTCNT= 1,NOSETS
C
C       DO FOR EACH VALUE IN BAR
C
          IF (ISTCNT.GT.100) GO TO 11
          IF (INFLGS(ISTCNT).EQ.0) GO TO 800
C
   11     CURVAL= VALSTS(IBAR,ISTCNT)
          IF (CURVAL.LT.RLOWST) RLOWST= CURVAL
          IF (CURVAL.GT.HIGST) HIGST= CURVAL
          IF (IBRTYP.NE.0) GO TO 12
C
          CALL POSITN(BRPOS,CURVAL)
          CALL JOIN(BRPOS1,CURVAL)
          GOTO 800
C
   12     CALL POSITN(CURVAL,BRPOS)
          CALL JOIN(CURVAL,BRPOS1)
  800   CONTINUE
C
        IF (IBRTYP.NE.0) GO TO 13
C
        CALL POSITN(BRPOS,RLOWST)
        CALL JOIN(BRPOS,HIGST)
        CALL POSITN(BRPOS1,HIGST)
        CALL JOIN(BRPOS1,RLOWST)
        GO TO 700
C
   13   CALL POSITN(RLOWST,BRPOS)
        CALL JOIN(HIGST,BRPOS)
        CALL POSITN(HIGST,BRPOS1)
        CALL JOIN(RLOWST,BRPOS1)
  700 CONTINUE
C
C     DRAW BASELINE
C
      IF (IBRTYP.EQ.0) CALL POSITN(BRPOS1,BASPOS)
      IF (IBRTYP.NE.0) CALL POSITN(BASPOS,BRPOS1)
C
      CALL JOIN(XORIG,YORIG)
   14 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE OFFBAR(BASPOS,BARWID,BOFSET,BARPOS,VALSTS,ISTART,ISTOP,
     &                  NOVALS,NOSETS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 119)   VERSION (A8.1)    22:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A MULTIPLE BAR CHART OF A GIVEN SET OF
C          VALUES,WITH HORIZONTAL OR VERTICAL BARS WITH A
C          GIVEN OFFSET BETWEEN BARS IN THE SAME SET.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <BASPOS>  IS THE BASELINE ORIGIN OF THE GRAPH,
C          <BARWID>  IS THE THICKNESS OF THE BARS,
C          <BOFSET>  IS THE OFFSET BETWEEN BARS IN THE SAME SET,
C          [BARPOS]  ARE THE POSITIONS OF THE BARS,
C          [VALSTS]  ARE THE VALUES TO BE GRAPHED,
C          <ISTART>  IS THE LOWER BOUNDARY, AND
C          <ISTOP>   IS THE UPPER BOUNDARY OF THE BAR NUMBERS,
C          <NOVALS>  IS THE TOTAL NUMBER OF BARS IN THE VALUES ARRAY,
C          <NOSETS>  IS THE TOTAL NUMBER OF SETS OF BARS IN THE VALUES ARRAY.
C
C
      REAL    BAUTO(2),VAUTO(2),BARPOS(ISTOP),VALSTS(NOVALS,NOSETS)
      REAL    RDATA(1),POINTS(100,2)
      INTEGER IDATA(1)
      LOGICAL FILL
C
      COMMON /T0BRTY/ IBRTYP
      COMMON /T0DBND/ IDRBND
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MULF/ INFLGS(100)
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
      RTRAC1= BARWID
      RTRAC2= BOFSET
      IF (IPRINT.EQ.1) CALL G0MESG(172,2)
C
C          AUTOMATIC MAPPING IS DONE FOR THE GIVEN VALUES.
C          THE CURRENT PLOTTING POSITION IS SAVED, THE
C          HISTOGRAM IS DRAWN, THEN THE POSITION IS RESTORED.
C
      IF (ISTOP.LT.ISTART) RETURN
C
      BAUTO(1)= BARPOS(ISTART)-BARWID*0.5
      IF (BOFSET.LT.0.0) BAUTO(1)= BAUTO(1)+(NOSETS-1)*BOFSET
C
      BAUTO(2)= BARPOS(ISTOP)+BARWID*0.5
      IF (BOFSET.GT.0.0) BAUTO(2)= BAUTO(2)+(NOSETS-1)*BOFSET
C
      VAUTO(1)= BASPOS
      VAUTO(2)= BASPOS
C
      DO 100 ISTCNT= 1,NOSETS
        IF (ISTCNT.GT.100) GO TO 1
        IF (INFLGS(ISTCNT).EQ.0) GO TO 100
C
    1   DO 200 IBRCNT= ISTART,ISTOP
          VAL= VALSTS(IBRCNT,ISTCNT)
          IF (VAL.GT.VAUTO(2)) VAUTO(2)= VAL
  200   CONTINUE
  100 CONTINUE
C
      IF (ABS(BAUTO(2)-BAUTO(1)).LT.RMINI.OR.
     &    ABS(VAUTO(2)-VAUTO(1)).LT.RMINI) RETURN
      IF (IBRTYP.EQ.0) CALL G0AUTO(BAUTO,VAUTO,1,2,1,2,1)
      IF (IBRTYP.NE.0) CALL G0AUTO(VAUTO,BAUTO,1,2,1,2,1)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      ACTWID= SIGN(BARWID,BOFSET)
C
      DO 300 IBAR= ISTART,ISTOP
        BRPOS= BARPOS(IBAR)-ACTWID*0.5
        BRPOS1= BRPOS+ACTWID
        INOPTS= 1
        POINTS(1,1)= BRPOS
        POINTS(1,2)= BASPOS
C
        DO 400 IEASET= 1,NOSETS
          CURVAL= VALSTS(IBAR,IEASET)
          IF (CURVAL.LT.BASPOS) GO TO 400
          IF (IEASET.GT.100) GO TO 2
          IF (INFLGS(IEASET).EQ.0) GO TO 400
C
C        FIND OUT WHERE IT IS IN TABLE.
C
    2     IPOINT= INOPTS+1
C
          DO 500 I= 1,INOPTS
            IF (BOFSET.GE.0.AND.POINTS(I,1).LE.BRPOS) IPOINT= I
            IF (BOFSET.LT.0.AND.POINTS(I,1).GE.BRPOS) IPOINT= I
  500     CONTINUE
C
          IF (BOFSET.GT.BARWID) POINTS(INOPTS,1)= BRPOS
C
          IFROM= 0
          INOPT1= INOPTS-1
          IF (IPOINT.GT.INOPT1) GO TO 3
C
          DO 600 IJOIN= IPOINT,INOPT1
            IF (POINTS(IJOIN,2).GE.CURVAL) GO TO 600
C
            IFROM= IJOIN
            GO TO 3
  600     CONTINUE
C
    3     FILL= .FALSE.
          IF (LENLST.EQ.0) GO TO 5
C
          FILL= .TRUE.
          KOLIND= MOD(IEASET,LENLST)
          IF (KOLIND.EQ.0) KOLIND= LENLST
          IF (LSTCL0(KOLIND).EQ.0) GO TO 400
C
          IDATA(1)= 0
          IF (LSTCL0(KOLIND).LT.0) IDATA(1)= 1
C
          CALL G3LINK(5,13,-1,IDATA,RDATA)
          IDATA(1)= IABS(LSTCL0(KOLIND))
          CALL G3LINK(5,3,-1,IDATA,RDATA)
          GO TO 5
C
    4     FILL= .FALSE.
          CALL G3LINK(5,4,0,IDATA,RDATA)
          IF (IDRBND.NE.0) GO TO 5
          IF (IFROM.EQ.0) GO TO 12
          GO TO 11
C
    5     IF (IBRTYP.EQ.1) GO TO 6
C
          CALL POSITN(BRPOS1,BASPOS)
          CALL JOIN(BRPOS1,CURVAL)
          IF (IFROM.NE.0) GO TO 8
C
          CALL JOIN(POINTS(INOPTS,1),CURVAL)
          CALL JOIN(POINTS(INOPTS,1),BASPOS)
          CALL JOIN(BRPOS1,BASPOS)
          GO TO 7
C
    6     CALL POSITN(BASPOS,BRPOS1)
          CALL JOIN(CURVAL,BRPOS1)
          IF (IFROM.NE.0) GO TO 8
C
          CALL JOIN(CURVAL,POINTS(INOPTS,1))
          CALL JOIN(BASPOS,POINTS(INOPTS,1))
          CALL JOIN(BASPOS,BRPOS1)
    7     IF (FILL) GO TO 4
          GO TO 12
C
    8     POS1= BRPOS
          IF (BOFSET.GE.0.AND.POINTS(IFROM,1).GT.BRPOS)
     &                                          POS1= POINTS(IFROM,1)
          IF (BOFSET.LT.0.AND.POINTS(IFROM,1).LT.BRPOS)
     &                                          POS1= POINTS(IFROM,1)
C
          IFROM1= IFROM+1
          IF (IBRTYP.EQ.1) GO TO 9
C
          CALL JOIN(POS1,CURVAL)
          CALL JOIN(POS1,POINTS(IFROM,2))
C
          DO 700 I= IFROM1,INOPTS
            CALL JOIN(POINTS(I,1),POINTS(I-1,2))
            CALL JOIN(POINTS(I,1),POINTS(I,2))
  700     CONTINUE
C
          CALL JOIN(BRPOS1,BASPOS)
          GO TO 10
C
    9     CALL JOIN(CURVAL,POS1)
          CALL JOIN(POINTS(IFROM,2),POS1)
C
          DO 800 I= IFROM1,INOPTS
            CALL JOIN(POINTS(I-1,2),POINTS(I,1))
            CALL JOIN(POINTS(I,2),POINTS(I,1))
  800     CONTINUE
C
          CALL JOIN(BASPOS,BRPOS1)
   10     IF (FILL) GO TO 4
C
   11     POINTS(INOPTS,1)= BRPOS
   12     POINTS(INOPTS,2)= CURVAL
          POINTS(INOPTS+1,1)= BRPOS1
          POINTS(INOPTS+1,2)= BASPOS
          INOPTS= INOPTS+1
          BRPOS= BRPOS+BOFSET
          BRPOS1= BRPOS1+BOFSET
  400   CONTINUE
  300 CONTINUE
C
C        DRAW BASELINE
C
      IF (IDRBND.EQ.0) GO TO 14
      IF (IBRTYP.NE.0) GO TO 13
C
      CALL POSITN(BAUTO(2),BASPOS)
      CALL JOIN(BAUTO(1),BASPOS)
      GO TO 14
C
   13 CALL POSITN(BASPOS,BAUTO(2))
      CALL JOIN(BASPOS,BAUTO(1))
   14 CALL POSITN(XHERE,YHERE)
      RETURN
      END
      SUBROUTINE PAPER(ISWICH)
C
C          ------------------------------------------------
C          ROUTINE NO. (   2)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SWITCHES CHANNEL-1 ON AND OFF.
C
C
C          <ISWICH> IS ZERO FOR OFF AND NON-ZERO FOR ON.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0DEVS/ KCHAN0(5),IRESL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/, IDATA /1/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ISWICH
      IF (IPRINT.EQ.1) CALL G0MESG(1,5)
C
      IF (ISWICH.EQ.0) GO TO 1
      KCHAN0(1)= 1
      CALL G3LINK(3,1,-1,IDATA,RDATA)
      RETURN
C
    1 KCHAN0(1)= 0
      CALL G3LINK(3,2,-1,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE PCSEND(X,Y,PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 165)   VERSION (A7.5)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING <PHRASE> WITH THE
C          RIGHTMOST CHARACTER PLACED AT THE POSITION <X,Y>.
C
C
      CHARACTER PHRASE*(*)
C
C
      CALL POSITN(X,Y)
      CALL TCSEND(PHRASE)
C
      RETURN
      END
      SUBROUTINE PICINF(INFPIC)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 308)   VERSION (A7.6)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS STORES INFORMATION IN A NEW PICTURE.
C
C
      LOGICAL   BLANK
      CHARACTER INFPIC*(*)
C
      COMMON /T2INFO/ INFOFO(32),INFOPO(32)
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
C
      LNFOPO= LEN(INFPIC)
      IF (LNFOPO.GT.128) LNFOPO= 128
C
      LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LNFOPO) NCHAR= ICHAR(INFPIC(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(INFOPO,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (BLANK) LNFOPO= 0
C
      RETURN
      END
      SUBROUTINE PICNAM(NMPICT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 309)   VERSION (A7.7)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS SETS UP A PICTURE OF THE GIVEN NAME.
C
C
      LOGICAL   BLANK
      LOGICAL   ERRON
      CHARACTER NMPICT*(*)
C
      COMMON /T2OPNA/ NAMEFO(32),NAMEPO(4)
      COMMON /T2OPNL/ LNFILN,LNPICN
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G0FRAM
C
      LNPICN= LEN(NMPICT)
      IF (LNPICN.LE.16) GO TO 1
      LNPICN= 16
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    1 LIMIT= NMCHI*4
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LNPICN) NCHAR= ICHAR(NMPICT(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(NAMEPO,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (BLANK) LNPICN= 0
C
      RETURN
      END
      SUBROUTINE PICNOW
C
C          ------------------------------------------------
C          ROUTINE NO. (  11)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CAUSES IMMEDIATE OUTPUT OF ALL GRAPHIC BUFFERS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0TRAC/ IPRINT
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(119,0)
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE PICSAV(NMFILE,NMPICT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 310)   VERSION (A8.8)    11:AUG:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS TAKES THE PICTURE IN THE SCRATCH GRIDFILE
C          AND SAVES IT INTO THE GIVEN PICTURE AND GRIDFILE.
C
C
      REAL      RDATA(1)
      INTEGER   NEWFIL(32),NEWPIC(4),IDATA(1)
      LOGICAL   BLANK
      LOGICAL   SCRTCH,ERRON
      CHARACTER NMFILE*(*),NMPICT*(*)
C
      COMMON /T2SAVE/ SCRTCH
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
      DATA RDATA /0.0/, IDATA /0/
C
C
C          IF SCRATCH MODE IS NOT SET, THIS ROUTINE DOES NOTHING.
C          OTHERWISE, THE GIVEN NAMES ARE COPIED INTO HOLD AREAS.
C
      IF (.NOT.SCRTCH) RETURN
C
      LFILEN= LEN(NMFILE)
      IF (LFILEN.LE.128) GO TO 1
      LFILEN= 128
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    1 LPICTN= LEN(NMPICT)
      IF (LPICTN.LE.16) GO TO 2
      LPICTN= 16
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    2 LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LFILEN) NCHAR= ICHAR(NMFILE(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(NEWFIL,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (.NOT.BLANK) GO TO 3
C
      DO 200 ISET= 1,32
        NEWFIL(ISET)= NAMDEF(ISET)
  200 CONTINUE
C
      LFILEN= LENDEF
C
    3 LIMIT= NMCHI*4
      BLANK= .TRUE.
C
      DO 300 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LPICTN) NCHAR= ICHAR(NMPICT(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
        CALL G4PUTK(NEWPIC,ISET,NBITMC,NMCHI,NCHAR)
  300 CONTINUE
C
      IF (BLANK) LPICTN= 0
C
C          <G3FLSV> IS THEN USED TO SAVE THE PICTURE.
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
      CALL G3FLSV(NEWFIL,NEWPIC,LFILEN,LPICTN)
C
      RETURN
      END
      SUBROUTINE PICTUR(NMFILE,NMPICT,NUMPIC)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 311)   VERSION (A8.7)    19:MAR:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS READS THE PICTURE FROM THE GIVEN GRIDFILE
C          AND INSERTS IT INTO THE CURRENT OUTPUT PICTURE.
C
C
      INTEGER   KFILIN(32),KPICIN(4)
      LOGICAL   BLANK
      LOGICAL   ERRON
      CHARACTER NMFILE*(*),NMPICT*(*)
C
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
C
C          THE GIVEN NAMES ARE SAVED IN HOLD AREAS. IF
C          <NUMPIC> IS > 0, THE PICTURE NAME IS IGNORED.
C
      LFILEN= LEN(NMFILE)
      IF(LFILEN.LE.128) GO TO 1
C
      LFILEN= 128
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    1 LPICTN= LEN(NMPICT)
      IF (LPICTN.LE.16) GO TO 2
C
      LPICTN= 16
      NUMERR= 19
      IF (ERRON) CALL G0ERMS
C
    2 LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LFILEN) NCHAR= ICHAR(NMFILE(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
C
        CALL G4PUTK(KFILIN,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (.NOT.BLANK) GO TO 3
C
      DO 200 ISET= 1,32
        KFILIN(ISET)= NAMDEF(ISET)
  200 CONTINUE
C
      LFILEN= LENDEF
    3 NMPIC1= NUMPIC
      IF (NMPIC1.LT.0) NMPIC1= 0
      IF (NMPIC1.GT.0) LPICTN= 0
C
      LIMIT= NMCHI*4
      BLANK= .TRUE.
C
      DO 300 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LPICTN) NCHAR= ICHAR(NMPICT(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
C
        CALL G4PUTK(KPICIN,ISET,NBITMC,NMCHI,NCHAR)
  300 CONTINUE
C
      IF (BLANK) LPICTN= 0
      IF (LPICTN.EQ.0.AND.NMPIC1.LE.0) RETURN
C
C          <G3FLIN> IS THEN USED TO RETRIEVE THE PICTURE.
C
      CALL G3FLIN(KFILIN,KPICIN,LFILEN,LPICTN,NMPIC1)
C
      RETURN
      END
      SUBROUTINE PIEANG(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 108)   VERSION (A8.1)    24:NOV:86
C          ------------------------------------------------
C
C          THIS SETS THE ANGLE OF THE FIRST SECTOR OF A PIECHART.
C
C
C          <ANGLE>   IS THE FIRST SECTOR ANGLE.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0PIAN/ ANGPIE
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(165,1)
C
      ANGPIE= ANGLE*ANGCON
C
      RETURN
      END
       SUBROUTINE PIECHT(XORIG,YORIG,RADIUS,VALUES,NSECS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  86)   VERSION (A8.3)    21:MAR:86
C          ------------------------------------------------
C
C          THIS DRAWS THE PIECHART SECTOR BY SECTOR.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XORIG>  IS THE X-ORIGIN OF THE PIECHART,
C          <YORIG>  IS THE Y-ORIGIN OF THE PIECHART,
C          <RADIUS> IS THE RADIUS OF THE PIECHART,
C          [VALUES] IS AN ARRAY CONTAINING THE SIZES OF THE SECTORS
C                   IF > 0, THE SECTOR IS CENTRED
C                   IF < 0, THE SECTOR IS SHIFTED OUT,
C          <NSECS>  THE NUMBER OF SECTORS.
C
      REAL    VALUES(NSECS),XAUTO(2),YAUTO(2)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PIAN/ ANGPIE
      COMMON /T0PIE/  XCPIE,YCPIE,PIEVAL(50),NPVALS,PIERAD,PIETOT,SIZLIM
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(136,0)
C
      NPVALS= 0
      IF (NSECS.LE.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      ABSRAD= ABS(RADIUS)
      RAD= ABSRAD*1.1
      XAUTO(1)= XORIG-RAD
      XAUTO(2)= XORIG+RAD
      YSCALE= (Y2MAP0-Y1MAP0)/(X2MAP0-X1MAP0)
      YAUTO(1)= YORIG-RAD*YSCALE
      YAUTO(2)= YORIG+RAD*YSCALE
      CALL G0AUTO(XAUTO,YAUTO,1,2,1,2,1)
      XSAVE= XPLOT0
      YSAVE= YPLOT0
      CALL POSITN(XORIG,YORIG)
      XCPIE= XORIG
      YCPIE= YORIG
      NPVALS= NSECS
      PIERAD= ABSRAD
      TOTAL= 0.0
      SECMIN= ABS(VALUES(1))
C
      DO 100 IADD= 1,NSECS
        ABSVAL= ABS(VALUES(IADD))
        TOTAL= TOTAL+ABSVAL
        IF (SECMIN.GT.ABSVAL) SECMIN= ABSVAL
        IF (IADD.GT.50) GO TO 100
C
        PIEVAL(IADD)= VALUES(IADD)
  100 CONTINUE
C
      PIETOT= 2.0*PI/TOTAL
      SIZLIM= 0.72*SQRT(SECMIN/TOTAL)
C
C          FIND THE ANGLE OF EACH SECTOR THEN DRAW IT.
C          <OFFSET> IS NON-ZERO WHEN THE SECTOR IS SHIFTED-OUT.
C
      KOLSAV= KOLFL0
      KOLFL0= 0
      KOLIND= 1
      ADANGL= ANGPIE
C
      DO 200 N= 1,NSECS
        IF (LENLST.LE.0) GO TO 1
C
        KOLFL0= LSTCL0(KOLIND)
        KOLIND= KOLIND+1
        IF (KOLIND.GT.LENLST) KOLIND= 1
C
    1   ANGLE= ABS(VALUES(N))*PIETOT
        OFFSET= 0.0
        IF (VALUES(N).LT.0.0) OFFSET= 0.1
C
        RAD= ABSRAD*OFFSET
        ANGLAB= ANGLE*0.5+ADANGL
        RX= RAD*COS(ANGLAB)+XORIG
        RY= RAD*YSCALE*SIN(ANGLAB)+YORIG
        CALL POSITN(RX,RY)
        SX= ABSRAD*COS(ADANGL)+RX
        SY= ABSRAD*YSCALE*SIN(ADANGL)+RY
        CALL SECCIR(SX,SY,ANGLE/ANGCON)
        ADANGL= ADANGL+ANGLE
  200 CONTINUE
C
      CALL POSITN(XSAVE,YSAVE)
      KOLFL0= KOLSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE PIELBL(LABELS,NLABLS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  87)   VERSION (A8.3)    16:FEB:87
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS LABELS ALL THE SECTORS OF A PIECHART.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [LABELS] CONTAINS THE LABELS TO BE WRITTEN ON THE SECTORS.
C          <NLABLS> IS THE NUMBER OF LABELS.
C
C
      LOGICAL ERRON
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0KLAB/ LABCL0(100),LENLAB
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PIAN/ ANGPIE
      COMMON /T0PIE/  XCPIE,YCPIE,PIEVAL(50),NPVALS,PIERAD,PIETOT,SIZLIM
      COMMON /T0PILM/ MPIELB
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(137,0)
      IF (NLABLS.LE.0) RETURN
      IF (NPVALS.GT.50) GO TO 901
      IF (NLABLS.NE.NPVALS) GO TO 902
C
      IPRSAV= IPRINT
      IPRINT= 0
      XSAVE= XPLOT0
      YSAVE= YPLOT0
      KOLLSV= KOLIN0
      KOLLIN= 1
      ORSAVE= STANG0/ANGCON
      MAGSAV= MAGN0
      NCHRS= LEN(LABELS(1))
      YSCALE= (Y2MAP0-Y1MAP0)/(X2MAP0-X1MAP0)
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
      IF (MPIELB.GT.1) GO TO 1
C
      CALL CTRORI(0.0)
      SIZE= AMIN1(0.17,SIZLIM)*ABS(YSCALE)/SQRT(NCHRS*OBLAT0)
      CALL CTRSIZ(SIZE*PIERAD)
    1 ADANGL= ANGPIE
C
      DO 100 LCOUNT= 1,NLABLS
        ANGLE= ABS(PIEVAL(LCOUNT))*PIETOT
        ANGLAB= ANGLE*0.5+ADANGL
        ADANGL= ADANGL+ANGLE
        COSLAB= COS(ANGLAB)
        SINLAB= SIN(ANGLAB)*YSCALE
        TEST= COSLAB*(X2MAP0-X1MAP0)
        OFFSET= 0.0
        IF (PIEVAL(LCOUNT).LT.0.0) OFFSET= 0.1
C
        RAD= PIERAD*(0.85+OFFSET)
        RX= RAD*COSLAB+XCPIE
        RY= RAD*SINLAB+YCPIE
        IF (LENLAB.GT.0) CALL LINCOL(LABCL0(KOLLIN))
C
        KOLLIN= KOLLIN+1
        IF (KOLLIN.GT.LENLAB) KOLLIN= 1
C
        DO 200 ICHAR= 1,NCHRS
          NCHARS= NCHRS-ICHAR+1
          IF (LABELS(LCOUNT)(NCHARS:NCHARS).NE.' ') GO TO 2
  200   CONTINUE
C
    2   NCHARS= NCHRS-NCHARS
        CALL POSITN(RX,RY)
        IF (MPIELB.GT.1) GO TO 4
        IF (COSLAB.GE.0.0) CALL CTRORI(ANGLAB/ANGCON)
        IF (COSLAB.LT.0.0) CALL CTRORI((ANGLAB-PI)/ANGCON)
        IF (TEST.LT.0.0) GO TO 3
C
        CALL SPACE(-NCHARS+1)
        CALL TCSEND(LABELS(LCOUNT))
        GO TO 100
C
    3   CALL TYPECS(LABELS(LCOUNT))
        GO TO 100
C
    4   RX= RX+0.25*PIERAD*COSLAB
        RY= RY+0.25*PIERAD*SINLAB
        CALL JOIN(RX,RY)
        RX= RX+0.15*PIERAD*SIGN(1.0,COSLAB)
        CALL JOIN(RX,RY)
        IF (TEST.LT.0.0) GO TO 5
C
        CALL SPACE(1)
        CALL TYPECS(LABELS(LCOUNT))
        GO TO 100
C
    5   CALL SPACE(NCHARS)
        CALL TCSEND(LABELS(LCOUNT))
  100 CONTINUE
C
      CALL LINCOL(KOLLSV)
      CALL POSITN(XSAVE,YSAVE)
      CALL CTRORI(ORSAVE)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      IPRINT= IPRSAV
C
      RETURN
C
  901 NUMERR= 25
      GO TO 903
C
  902 NUMERR= 26
  903 IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE PIELBM(METHOD)
C
C          ------------------------------------------------
C          ROUTINE NO. (  88)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE PIECHART LABELLING METHOD WHICH IS USED.
C
C
C          <METHOD> = 1 FOR INTERNAL LABELLING.
C                   = 2 FOR EXTERNAL LABELLING.
C
C
      LOGICAL ERRON
C
      COMMON /T0PILM/ MPIELB
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      CALL G3INIT(2)
C
      ITRAC1= METHOD
      IF (IPRINT.EQ.1) CALL G0MESG(157,5)
C
      IF (METHOD.LT.1.OR.METHOD.GT.2) GO TO 901
C
      MPIELB= METHOD
      RETURN
C
  901 NUMERR= 24
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE PLACE(NSPACE,NLINE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 152)   VERSION (A8.4)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DOES CHARACTER MOVES FROM THE TOP-LEFT CORNER
C          BY THE AMOUNT OF <NSPACE> SPACES AND <NLINE> LINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA IDATA /10,1/, RDATA /0.0/
C
C
      ITRAC1= NSPACE
      ITRAC2= NLINE
      IF (IPRINT.EQ.1) CALL G0MESG(63,6)
      IF (ABS(X1CHR0-X2CHR0).LT.RMINI.OR.
     &    ABS(Y1CHR0-Y2CHR0).LT.RMINI) GO TO 901
C
      IPRSAV= IPRINT
      IPRINT= 0
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      CALL LINEFD(NLINE-1)
      CALL SPACE(NSPACE-1)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 29
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE PLOTCS(X,Y,PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 163)   VERSION (A7.5)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING <PHRASE> WITH THE
C          LEFTMOST CHARACTER PLACED AT THE POSITION <X,Y>.
C
C
      CHARACTER PHRASE*(*)
C
C
      CALL POSITN(X,Y)
      CALL TYPECS(PHRASE)
C
      RETURN
      END
      SUBROUTINE PLOTNE(X,Y,VALUE,NAFTDP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 173)   VERSION (A8.3)    11:FEB:87
C          ------------------------------------------------
C
C          THIS PLOTS OUT THE GIVEN VALUE IN EXPONENT FORMAT.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <X,Y>    ARE THE COORDINATES OF THE DECIMAL POINT.
C          <VALUE>  IS THE VALUE TO BE PLOTTED.
C          <NAFTDP> IS THE NO. OF DIGITS AFTER THE DECIMAL POINT.
C
C
      DOUBLE PRECISION DVALUE,VALNRM
      REAL    RDATA(1)
      INTEGER IDATA(20)
      LOGICAL ERRON
C
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA ISPACE /32/, MINUS /45/, IPOINT /46/, IZERO /48/, IELETR /69/
      DATA RDATA /0.0/
C
C
      IF (NAFTDP.LE.0) GO TO 901
C
      CALL POSITN(X,Y)
      IDATA(1)= 2
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= ISPACE
      IF (VALUE.LT.0.0) IDATA(1)= MINUS
C
      IDATA(2)= IZERO
      CALL G3LINK(2,11,-2,IDATA,RDATA)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= IPOINT
C
C          IF THE NUMBER IS ZERO, THE FIELD IS FILLED WITH ZEROES;
C          OTHERWISE, THE VALUE IS ROUNDED TO THE REQUIRED NO. OF
C          PLACES AND THE DECIMAL EXPONENT IS CALCULATED. ACCOUNT
C          IS TAKEN OF THE CASE WHERE ROUNDING BRINGS THE NUMBER
C          UP TO THE NEXT-HIGHER DECADE, AND NEGATIVE NUMBERS
C          ROUNDED TO ZERO HAVE THE MINUS SIGN SUPPRESSED.
C
C          THE MANTISSA IS CONVERTED AND STORED IN THE CHARACTER
C          STRING, FOLLOWED BY THE LETTER 'E' AND THE EXP. SIGN.
C          THE EXPONENT IS THEN CONVERTED AND STORED (TWO DIGITS
C          ARE ALWAYS DONE; A LEADING ZERO IS ADDED IF NECESSARY).
C
      DVALUE= ABS(VALUE)
      IEXP= 0
      IF (ABS(VALUE).GT.RMINI) GO TO 1
C
      DO 100 IFILL= 1,NAFTDP
        IDATA(IFILL+1)= IZERO
  100 CONTINUE
C
      GO TO 3
C
    1 IEXP= DLOG10(DVALUE)
      IF (DVALUE.GE.1.0D0) IEXP= IEXP+1
C
      VALNRM= DVALUE*(10.0D0**(NAFTDP-IEXP))
      VALNRM= VALNRM+0.5D0
      NRMVAL= VALNRM
      IF (IDINT(DLOG10(VALNRM)).LT.NAFTDP) GO TO 2
C
      IEXP= IEXP+1
      NRMVAL= NRMVAL/10
    2 IF (NRMVAL.EQ.0) IDATA(1)= ISPACE
C
      INDEX= 2
      CALL G0CONI(NRMVAL,IDATA,INDEX)
    3 NCHARS= NAFTDP+2
      IDATA(NCHARS)= IELETR
      IDATA(NCHARS+1)= ISPACE
      IF (IEXP.LT.0) IDATA(NCHARS+1)= MINUS
C
      IDATA(NCHARS+2)= IZERO
      INDEX= NCHARS+3
      IF (IABS(IEXP).GE.10) INDEX= INDEX-1
C
      CALL G0CONI(IEXP,IDATA,INDEX)
      NCHARS= INDEX-1
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 31
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE PLOTNF(X,Y,VALUE,NAFTDP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 172)   VERSION (A8.3)    11:FEB:87
C          ------------------------------------------------
C
C          THIS PLOTS OUT THE GIVEN VALUE IN REAL FORMAT.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <X,Y>    ARE THE COORDINATES OF THE DECIMAL POINT.
C          <VALUE>  IS THE VALUE TO BE PLOTTED.
C          <NAFTDP> IS THE NO. OF DIGITS AFTER THE DECIMAL POINT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(20)
      LOGICAL ERRON
C
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA ISPACE /32/, MINUS /45/, IPOINT /46/, IZERO /48/,
     &     RDATA /0.0/
C
C
C          THE ERROR EXIT IS TAKEN IF <NAFTDP> IS WRONG.
C          THE FIRST CHARACTER IS SET TO SPACE OR ZERO,
C          DEPENDING ON THE SIGN OF THE NUMBER.
C
      IF (NAFTDP.LE.0)  GO TO 901
      IF (NAFTDP.GT.17) GO TO 901
C
      CALL POSITN(X,Y)
      IDATA(1)= 2
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= ISPACE
      IF (VALUE.LT.0.0) IDATA(1)= MINUS
C
C          THE NUMBER IS LEFT-SHIFTED BY <NAFTDP> PLACES THEN
C          ROUNDED. IF THIS RESULTS IN A ZERO NUMBER, THE SIGN
C          IS SUPPRESSED. IF THE NUMBER IS GREATER THAN UNITY,
C          A DECIMAL IPOINT IS INSERTED IN THE CHARACTER STRING
C          AT THE APPROPRIATE POSITION; IF IT IS FRACTIONAL,
C          AN INITIAL ZERO, A DECIMAL POINT, THEN AS MANY
C          FOLLOWING ZEROES AS NECESSARY ARE ADDED INSTEAD.
C
      ABVAL= ABS(VALUE)
      SHIFAC= 10.0**NAFTDP
      SHIFTD= ABVAL*SHIFAC
      IF (SHIFTD.GT.FLOAT(IMAXI)) GO TO 901
C
      IVALUE= SHIFTD+0.5
      IF (IVALUE.EQ.0) IDATA(1)= ISPACE
      IF (ABVAL.LT.1.0.AND.SHIFAC-SHIFTD.GT.0.5) GO TO 1
C
      INDEX= 2
      CALL G0CONI(IVALUE,IDATA,INDEX)
      NCHARS= INDEX-NAFTDP-1
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= IPOINT
C
      DO 100 IMOVE= 1,NAFTDP
        IFROM= INDEX-NAFTDP+IMOVE-1
        IDATA(IMOVE+1)= IDATA(IFROM)
  100 CONTINUE
C
      GO TO 2
C
    1 IDATA(2)= IZERO
      CALL G3LINK(2,11,-2,IDATA,RDATA)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= IPOINT
      INDEX= 2
      CALL G0CONI(IVALUE,IDATA,INDEX)
C
      DO 200 IMOVE= 1,NAFTDP
        ITO= NAFTDP-IMOVE+2
        IFROM= INDEX-IMOVE
        IVALUE= IZERO
        IF (IFROM.GT.1) IVALUE= IDATA(IFROM)
C
        IDATA(ITO)= IVALUE
  200 CONTINUE
C
    2 CALL G3LINK(2,11,-NAFTDP-1,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 30
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE PLOTST(X,Y,PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 181)   VERSION (A7.3)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING STORED IN <PHRASE>
C          WITH THE LEFTMOST CHARACTER PLACED AT THE POSITION
C          <X,Y>. COMMAND STRINGS MAY BE EMBEDDED IN THE TEXT.
C
C
      CHARACTER PHRASE*(*)
C
      CALL POSITN(X,Y)
      CALL TYPEST(PHRASE)
C
      RETURN
      END
      SUBROUTINE PROMPT(MESSOU,MESSIN)
C
C          ------------------------------------------------
C          ROUTINE NO. (1045)   VERSION (A8.1)    19:AUG:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS ISSUES A PROMPT TO A TERMINAL AND RECEIVES A REPLY
C
C
      INTEGER   MESOUT(32),MESIN(32)
      LOGICAL   BLANK
      CHARACTER MESSOU*(*),MESSIN*(*)
C
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
C
      CALL G3INIT(2)
C
      LNMSOU= LEN(MESSOU)
      IF (LNMSOU.GT.128) LNMSOU= 128
C
      LIMIT= NMCHI*32
      BLANK= .TRUE.
      ISPAC= 0
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISPAC)
C
      DO 100 ISET= 1,LIMIT
        NCHAR= ISPAC
        IF (ISET.LE.LNMSOU) NCHAR= ICHAR(MESSIN(ISET:ISET))
        IF (NCHAR.NE.ISPAC) BLANK= .FALSE.
C
        CALL G4PUTK(MESOUT,ISET,NBITMC,NMCHI,NCHAR)
  100 CONTINUE
C
      IF (BLANK) LNMSOU= 0
C
      CALL G3MESS(MESOUT,LNMSOU,MESIN,LNMSIN)
C
      DO 200 ISET= 1,LIMIT
        CALL G4GETK(MESIN,ISET,NBITMC,NMCHI,NCHAR)
        IF (ISET.GT.LNMSIN) NCHAR= ISPAC
C
        MESSIN(ISET:ISET)= CHAR(NCHAR)
  200 CONTINUE
C
      RETURN
      END
      SUBROUTINE PSPACE(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  27)   VERSION (A8.7)    24:NOV:86
C          ------------------------------------------------
C
C          THIS SPECIFIES THE UNIT PLOTTER AREA.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      LOGICAL ERRON
C
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0MAPD/ X1MAPD,X2MAPD,Y1MAPD,Y2MAPD
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      CALL G3INIT(2)
c slmod begin
c...Adjustment for HP 660C DeskJet printer:
c      RTRAC1= XAREA1 + 0.037
c      RTRAC2= XAREA2 + 0.037
      RTRAC1= XAREA1
      RTRAC2= XAREA2
c
c      RTRAC1= XAREA1
c      RTRAC2= XAREA2
c slmod end
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(12,4)
      IF (ABS(XAREA1-XAREA2).LT.RMINI.OR.
     &    ABS(YAREA1-YAREA2).LT.RMINI) GO TO 901
C
C          THE ARGUMENTS ARE SET.
C
c slmod begin
c...Adjustment for HP 660C DeskJet printer:
c      X1MAPD= XAREA1 + 0.040
c      X2MAPD= XAREA2 + 0.040
      X1MAPD= XAREA1
      X2MAPD= XAREA2
c
c      X1MAPD= XAREA1
c      X2MAPD= XAREA2
c slmod end
      Y1MAPD= YAREA1
      Y2MAPD= YAREA2
C
      IF (MRKMAP.EQ.0.AND.MRKWIN.EQ.0) GO TO 2
C
C          IF EITHER <MAP> OR <WINDOW> HAVE BEEN CALLED BEFORE,
C          THE CALLS ARE REPEATED TO RESET THEIR CONSTANTS.
C
      IF (MRKMAP.EQ.0) GO TO 1
C
      CALL G0MAPS(X1MAPV,X2MAPV,Y1MAPV,Y2MAPV)
      RETURN
C
    1 IF (MRKWIN.EQ.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      CALL WINDOW(X1WND0,X2WND0,Y1WND0,Y2WND0)
      IPRINT= IPRSAV
      RETURN
C
C          IF BOTH <MAP> AND <WINDOW> HAVE NOT BEEN
C          CALLED BEFORE, RESET THE DEFAULT VALUES.
C
    2 CALL G0MAPS(X1MAPV,X2MAPV,Y1MAPV,Y2MAPV)
      MRKMAP= 0
      RETURN
C
  901 NUMERR= 1
      IF (ERRON) CALL G0ERMS
      RETURN
C
      END
      SUBROUTINE PTGRAF(XPOSNS,YPOSNS,ISTART,ISTOP,MKOPEN)
C
C          ------------------------------------------------
C          ROUTINE NO. (  82)   VERSION (A8.6)    14:JUL:88
C          ------------------------------------------------
C
C          THIS JOINS A SET OF POINTS WITH STRAIGHT-LINE
C          SEGMENTS AND PUTS A MARKER CHARACTER AT EACH POINT.
C
C
C          [XPOSNS] ARE THE X-COORDINATES OF THE POINTS.
C          [YPOSNS] ARE THE Y-COORDINATES OF THE POINTS.
C          <ISTART> IS THE LOWER BOUNDARY AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAY.
C          <MKOPEN> SETS THE MARKER CHAR. (IF NON-ZERO)
C                   AND ALSO DETERMINES THE CURVE TYPE:
C                   >= 0, THE CURVE IS OPEN, OR
C                   < 0, THE CURVE IS CLOSED.
C
C
      REAL    RDATA(2),XPOSNS(ISTOP),YPOSNS(ISTOP)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0MRKS/ MARKC0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0,0.0/
C
C
      ITRAC1= ISTART
      ITRAC2= ISTOP
      ITRAC3= MKOPEN
      IF (IPRINT.EQ.1) CALL G0MESG(110,7)
      IF (ISTART.GE.ISTOP) RETURN
C
C          AUTOMATIC MAPPING WILL BE DONE IF NECESSARY.
C
      CALL G0AUTO(XPOSNS,YPOSNS,ISTART,ISTOP,ISTART,ISTOP,0)
      IGRDFN= 4
      IF (MKOPEN.GE.0.OR.KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XPOSNS(ISTART),YPOSNS(ISTART))
      LOLIM= ISTART+1
C
      DO 100 IJOIN= LOLIM,ISTOP
        CALL JOIN(XPOSNS(IJOIN),YPOSNS(IJOIN))
  100 CONTINUE
C
      CALL JOIN(XPOSNS(ISTART),YPOSNS(ISTART))
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) IGRDFN= 5
C
    1 CALL POSITN(XPOSNS(ISTART),YPOSNS(ISTART))
      KCHAR= IABS(MKOPEN)
      IF (KCHAR.EQ.0.OR.KCHAR.GT.255) GO TO 2
C
      MARKC0= KCHAR
      IDATA(1)= KCHAR
      CALL G3LINK(2,9,-1,IDATA,RDATA)
C
    2 DO 200 IJOIN= ISTART,ISTOP
        RDATA(1)= XPOSNS(IJOIN)
        RDATA(2)= YPOSNS(IJOIN)
        CALL G3LINK(0,IGRDFN,2*NBYTR,IDATA,RDATA)
  200 CONTINUE
C
      IF (MKOPEN.LT.0) GO TO 3
C
      XPLOT0= XPOSNS(ISTOP)
      YPLOT0= YPOSNS(ISTOP)
C
      RETURN
C
    3 RDATA(1)= XPOSNS(ISTART)
      RDATA(2)= YPOSNS(ISTART)
      CALL G3LINK(0,IGRDFN,2*NBYTR,IDATA,RDATA)
      XPLOT0= XPOSNS(ISTART)
      YPLOT0= YPOSNS(ISTART)
C
      RETURN
      END
      SUBROUTINE PTJOIN(XPOSNS,YPOSNS,ISTART,ISTOP,IOPEN)
C
C          ------------------------------------------------
C          ROUTINE NO. (  83)   VERSION (A8.4)    14:JUL:88
C          ------------------------------------------------
C
C          THIS JOINS A SET OF POINTS WITH STRAIGHT-LINE SEGMENTS.
C
C
C          [XPOSNS] ARE THE X-COORDINATES OF THE POINTS.
C          [YPOSNS] ARE THE Y-COORDINATES OF THE POINTS.
C          <ISTART> IS THE LOWER BOUNDARY AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAY.
C          <IOPEN>  DETERMINES THE CURVE TYPE:
C                   >= 0, THE CURVE IS OPEN, OR
C                   < 0, IT IS CLOSED.
C
C
      REAL    RDATA(1),XPOSNS(ISTOP),YPOSNS(ISTOP)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      ITRAC1= ISTART
      ITRAC2= ISTOP
      ITRAC3= IOPEN
      IF (IPRINT.EQ.1) CALL G0MESG(109,7)
      IF (ISTART.GE.ISTOP) RETURN
C
C          AUTOMATIC MAPPING WILL BE DONE IF NECESSARY.
C
      CALL G0AUTO(XPOSNS,YPOSNS,ISTART,ISTOP,ISTART,ISTOP,0)
      IF (IOPEN.GE.0.OR.KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XPOSNS(ISTART),YPOSNS(ISTART))
      LOLIM= ISTART+1
C
      DO 100 IJOIN= LOLIM,ISTOP
        CALL JOIN(XPOSNS(IJOIN),YPOSNS(IJOIN))
  100 CONTINUE
C
      CALL JOIN(XPOSNS(ISTART),YPOSNS(ISTART))
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) RETURN
C
    1 CALL POSITN(XPOSNS(ISTART),YPOSNS(ISTART))
      LOLIM= ISTART+1
C
      DO 200 IJOIN= LOLIM,ISTOP
        CALL JOIN(XPOSNS(IJOIN),YPOSNS(IJOIN))
  200 CONTINUE
C
      IF (IOPEN.LT.0) CALL JOIN(XPOSNS(ISTART),YPOSNS(ISTART))
C
      RETURN
      END
      SUBROUTINE PTPLOT(XPOSNS,YPOSNS,ISTART,ISTOP,MARKNO)
C
C          ------------------------------------------------
C          ROUTINE NO. (  80)   VERSION (A8.6)    05:JUN:87
C          ------------------------------------------------
C
C          THIS PUTS A MARKER CHARACTER AT EACH POINT.
C
C
C          [XPOSNS] ARE THE X-COORDINATES OF THE POINTS.
C          [YPOSNS] ARE THE Y-COORDINATES OF THE POINTS.
C          <ISTART> IS THE LOWER BOUNDARY AND
C          <ISTOP>  IS THE UPPER BOUNDARY OF THE ARRAY.
C          <MARKNO> GIVES THE MARKER CHAR. IN SET 0;
C                   HOWEVER, IF THE NUMBER IS ZERO, THE
C                   PREVIOUS MARKER IS USED INSTEAD.
C
C
      REAL    RDATA(2),XPOSNS(ISTOP),YPOSNS(ISTOP)
      INTEGER IDATA(1)
C
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0MRKS/ MARKC0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0,0.0/
C
C
      ITRAC1= ISTART
      ITRAC2= ISTOP
      ITRAC3= MARKNO
      IF (IPRINT.EQ.1) CALL G0MESG(32,7)
      IF (ISTART.GT.ISTOP) RETURN
C
C          AUTOMATIC MAPPING WILL BE DONE IF NECESSARY.
C
      CALL G0AUTO(XPOSNS,YPOSNS,ISTART,ISTOP,ISTART,ISTOP,0)
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XPOSNS(ISTART),YPOSNS(ISTART))
      LOLIM= ISTART+1
C
      DO 100 IJOIN= LOLIM,ISTOP
        CALL JOIN(XPOSNS(IJOIN),YPOSNS(IJOIN))
  100 CONTINUE
C
      CALL JOIN(XPOSNS(ISTART),YPOSNS(ISTART))
      CALL G3LINK(5,4,0,IDATA,RDATA)
    1 KCHAR= IABS(MARKNO)
      IF (KCHAR.EQ.0.OR.KCHAR.GT.255) GO TO 2
C
      MARKC0= KCHAR
      IDATA(1)= KCHAR
      CALL G3LINK(2,9,-1,IDATA,RDATA)
C
    2 DO 200 JUMP= ISTART,ISTOP
        RDATA(1)= XPOSNS(JUMP)
        RDATA(2)= YPOSNS(JUMP)
        CALL G3LINK(0,5,2*NBYTR,IDATA,RDATA)
  200 CONTINUE
C
      XPLOT0= XPOSNS(ISTOP)
      YPLOT0= YPOSNS(ISTOP)
C
      RETURN
      END
      SUBROUTINE QADRNT
C
C          ------------------------------------------------
C          ROUTINE NO. (  37)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT ANGLE TYPE TO QUADRANTS.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(21,0)
C
      ANGCON= 0.5*PI
      RETURN
      END
      SUBROUTINE RADIAN
C
C          ------------------------------------------------
C          ROUTINE NO. (  34)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT ANGLE TYPE TO RADIANS.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(18,0)
C
      ANGCON= 1.0
      RETURN
      END
      SUBROUTINE REGRID(XPOSNS,YPOSNS,ZPOSNS,NPNTS,XLEFT,XRIGHT,
     &                  YLOWER,YUPPER,SURFAS,NPTSX,NPTSY,INTERP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 128)   VERSION (A8.2)    04:MAR:91
C          ------------------------------------------------
C
C          THIS ESTIMATES THE SURFACE HEIGHTS ON A REGULAR GRID,
C          GIVEN HEIGHTS OF THE SURFACE AT RANDOM COPLANAR POINTS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XPOSNS] THE SET OF X-COORDINATES,
C          [YPOSNS] THE SET OF Y-COORDINATES,
C          [ZPOSNS] THE SET OF Z-COORDINATES,
C                   (ALL OF THESE MUST HAVE AT LEAST <NPNTS> ELEMENTS)
C          <NPNTS>  THE NUMBER OF SURFACE POINTS (THIS MUST BE > 5),
C          <XLEFT>  THE LEFT-HAND EDGE OF THE GRID RECTANGLE,
C          <XRIGHT> THE RIGHT-HAND EDGE OF THE GRID RECTANGLE,
C          <YLOWER> THE LOWER EDGE OF THE GRID RECTANGLE,
C          <YUPPER> THE UPPER EDGE OF THE GRID RECTANGLE,
C          [SURFAS] AN OUTPUT ARRAY OF SIZE <NPTSX> BY <NPTSY>,
C                   WHICH (IF THE ROUTINE IS SUCCESSFUL) CONTAINS
C                   THE ESTIMATED SURFACE HEIGHTS FOR THE GRID.
C                   THE ELEMENT (1,1) CONTAINS THE HEIGHT AT
C                   (<XLEFT>,<YLOWER>) AND THE ELEMENT (<NPTSX>,<NPTSY>)
C                   CONTAINS THE HEIGHT AT (<XRIGHT>,<YUPPER>).
C          <NPTSX>  THE NO. OF GRID INTERVALS IN THE X-DIRECTION,
C          <NPTSY>  THE NO. OF GRID INTERVALS IN THE Y-DIRECTION,
C          <INTERP> IS AN INTERPOLATION ROUTINE WHICH ESTIMATES THE
C                   HEIGHT AT A GIVEN GRID POINT. TWO VERSIONS ARE
C                   SUPPLIED WITH GHOST-80, INTRP1 AND INTRP2. THOSE
C                   WHO WISH TO PROVIDE THEIR OWN VERSION SHOULD REFER
C                   TO THE SPECIFICATION GIVEN AT THE START OF EITHER.
C
C
C          THE SUBROUTINE ESTIMATES SURFACE HEIGHTS ON A REGULAR GRID
C          IN THE RECTANGLE DEFINED BY THE GIVEN X AND Y RANGES. ONLY
C          POINTS WITHIN A CIRCLE OF RADIUS <RADIUS> CENTRED ON A GRID
C          POINT ARE USED IN THE ESTIMATION OF ITS SURFACE HEIGHT.
C          <RADIUS> IS INITIALLY SET SO THAT AN ESTIMATED 30 POINTS LIE
C          INSIDE THE CIRCLE. IF THE SIZE OF <RADIUS> PROVES TOO SMALL,
C          IT IS INCREASED UNTIL A RELIABLE CALCULATION CAN BE MADE.
C
C
      REAL    XPOSNS(NPNTS),YPOSNS(NPNTS),ZPOSNS(NPNTS),
     &        SURFAS(NPTSX,NPTSY)
      LOGICAL ERRON
C
      EXTERNAL INTERP
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T3CONS/ PI
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(145,0)
C
C          SOME OF THE INPUT ARGUMENTS ARE CHECKED FOR VALIDITY.
C
      IF (NPNTS.LE.5.OR.NPTSX.LT.1.OR.NPTSY.LT.1) GO TO 901
C
      X1= XPOSNS(1)
      X2= XPOSNS(1)
      Y1= YPOSNS(1)
      Y2= YPOSNS(1)
      DO 100 IPT= 2,NPNTS
        TEMPX= XPOSNS(IPT)
        TEMPY= YPOSNS(IPT)
        X1= AMIN1(X1,TEMPX)
        X2= AMAX1(X2,TEMPX)
        Y1= AMIN1(Y1,TEMPY)
        Y2= AMAX1(Y2,TEMPY)
  100 CONTINUE
C
C          THE RECTANGLE ENCLOSING ALL GRID AND DATA POINTS IS FOUND.
C
      X1= AMIN1(X1,XLEFT,XRIGHT)
      X2= AMAX1(X2,XLEFT,XRIGHT)
      Y1= AMIN1(Y1,YLOWER,YUPPER)
      Y2= AMAX1(Y2,YLOWER,YUPPER)
C
C          DATA POINTS WITHIN A RADIUS <RADIUS> OF A GRID POINT ARE
C          TO BE USED TO COMPUTE THE APPROXIMATION. THE RADIUS
C          <RADIUS> IS CALCULATED SO THAT ON AVERAGE THIRTY POINTS LIE
C          INSIDE A CIRCLE OF RADIUS <RADIUS> CENTRED ON A GRID POINT.
C
      XRANGE= X2-X1
      YRANGE= Y2-Y1
      AREA= XRANGE*YRANGE*30.0/FLOAT(NPNTS)
      STARAD= SQRT(AREA/PI)
C
C          IF A DATA POINT IS WITHIN DISTANCE <TOL> OF A GRID POINT,
C          THE SURFACE HEIGHT AT THE DATA POINT IS ACCEPTED AS THE
C          HEIGHT AT THE GRID POINT. THE VALUE OF <TOL> IS SET HERE.
C
      DIAM= SQRT(XRANGE*XRANGE+YRANGE*YRANGE)
      TOL= 0.001*DIAM
      IF (STARAD.LT.TOL) STARAD= TOL
C
C          THE FOLLOWING DOUBLE LOOP CONSTRUCTS THE REGULAR GRID.
C
      XSTEP= (XRIGHT-XLEFT)/FLOAT(NPTSX-1)
      YSTEP= (YUPPER-YLOWER)/FLOAT(NPTSY-1)
      DO 200 IGX= 1,NPTSX
        XPOS= XLEFT+FLOAT(IGX-1)*XSTEP
        DO 300 IGY= 1,NPTSY
          YPOS= YLOWER+FLOAT(IGY-1)*YSTEP
          RADIUS= STARAD
C
C          THE REMEDY FOR AN ERROR IS TO INCREASE <RADIUS>
C          UNTIL THE WHOLE AREA IS COVERED. IF THIS FAILS,
C          THE ATTEMPT IS ABANDONED AND AN ERROR EXIT TAKEN.
C
    2       CALL INTERP(XPOSNS,YPOSNS,ZPOSNS,NPNTS,XPOS,YPOS,RADIUS,TOL,
     &                  VALUE,IREPLY)
            IF (IREPLY.EQ.0) GO TO 3
C
            IF (RADIUS.GT.DIAM) GO TO 902
            RADIUS= 2.0*RADIUS
            GO TO 2
C
    3     SURFAS(IGX,IGY)= VALUE
  300   CONTINUE
  200 CONTINUE
      RETURN
C
  901 NUMERR= 35
      CALL G0ERMS
      RETURN
C
  902 NUMERR= 36
      CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE RGB
C
C          ------------------------------------------------
C          ROUTINE NO. (  63)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS THE <RGB> COLOUR SYSTEM, AND
C          COLOUR PARAMETERS ARE NOW <RED, GREEN, BLUE>.
C
C
      COMMON /T0KSYS/ KOLSYS
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
      IF (IPRINT.EQ.1) CALL G0MESG(129,0)
C
      KOLSYS= 4
C
      RETURN
      END
      SUBROUTINE ROTATE(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  32)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS SUBSEQUENT PICTURE ROTATION.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <ANGLE>  IS THE ROTATION IN THE CURRENT ANGLE UNITS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(16,1)
C
C          THE ROTATION ANGLE IS CONVERTED TO RADIANS.
C
      ROTAT0= ANGLE*ANGCON
      RDATA(1)= ROTAT0
      CALL G3LINK(7,12,NBYTR,IDATA,RDATA)
C
C          BOTH REFERENCE POINTS ARE UPDATED AS NECESSARY.
C
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      CALL G0MAPP(XPLOT0,YPLOT0,RPICX0,RPICY0)
C
      IF (SHIFT0) RETURN
C
      RDEVX0= RPICX0
      RDEVY0= RPICY0
C
      RETURN
      END
      SUBROUTINE SCALE(SCALMX,SCALMY)
C
C          ------------------------------------------------
C          ROUTINE NO. (  31)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS SUBSEQUENT PICTURE X AND Y SCALING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <SCALMX> IS THE X-DIRECTION SCALING FACTOR,
C          <SCALMY> IS THE Y-DIRECTION SCALING FACTOR.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= SCALMX
      RTRAC2= SCALMY
      IF (IPRINT.EQ.1) CALL G0MESG(15,2)
C
      SCALX0=   SCALMX
      RDATA(1)= SCALMX
      CALL G3LINK(7,8,NBYTR,IDATA,RDATA)
      SCALY0=   SCALMY
      RDATA(1)= SCALMY
      CALL G3LINK(7,9,NBYTR,IDATA,RDATA)
C
C          BOTH REFERENCE POINTS ARE UPDATED AS NECESSARY.
C
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      CALL G0MAPP(XPLOT0,YPLOT0,RPICX0,RPICY0)
C
      IF (SHIFT0) RETURN
C
      RDEVX0= RPICX0
      RDEVY0= RPICY0
C
      RETURN
      END
      SUBROUTINE SCALES
C
C          ------------------------------------------------
C          ROUTINE NO. ( 205)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(83,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVS(2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLAX(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCALSI(DIX,DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 208)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          WITH INTERVALS SET BY <DIX> AND <DIY>.
C
C
C          [X-LINEAR, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      RTRAC2= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(86,2)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVS(2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLAX(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCAROT(XSCAL,YSCAL,ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  33)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CAUSES SCALING AND ROTATION
C          OF SUBSEQUENT GRAPHICAL OUTPUT.
C
C
C          <XSCAL>, <YSCAL> ARE THE AXES SCALING FACTORS,
C          <ANGLE> IS THE ROTATION IN THE CURRENT UNITS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T3NBYR/ NBYTR
C
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= XSCAL
      RTRAC2= YSCAL
      RTRAC3= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(17,3)
C
C          THE ROTATION ANGLE IS CONVERTED TO RADIANS.
C
      X0SCAL= XSCAL
      Y0SCAL= YSCAL
      ROTAT0= ANGLE*ANGCON
C
      RDATA(1)= X0SCAL
      CALL G3LINK(7, 8,NBYTR,IDATA,RDATA)
      RDATA(1)= Y0SCAL
      CALL G3LINK(7, 9,NBYTR,IDATA,RDATA)
      RDATA(1)= ROTAT0
      CALL G3LINK(7,12,NBYTR,IDATA,RDATA)
C
C          BOTH REFERENCE POINTS ARE UPDATED AS NECESSARY.
C
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      CALL G0MAPP(XPLOT0,YPLOT0,RPICX0,RPICY0)
C
      IF (SHIFT0) RETURN
C
      RDEVX0= RPICX0
      RDEVY0= RPICY0
C
      RETURN
      END
      SUBROUTINE SCAXL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 211)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(89,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVL(1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVS(2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLXL(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCAXLI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 214)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          WITH THE Y-INTERVAL SET BY <DIY>.
C
C
C          [X-LOGARITHMIC, Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(90,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
      IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVL(1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVS(2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLXL(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCAXYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 213)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(93,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVL(1)
      CALL G0TICK
      CALL G0PLXL(1)
      CALL G0DIVL(2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLXL(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLYL(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCAYL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 212)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(91,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVL(2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLAX(0)
      KAXIS=2
      CALL G0TICK
      CALL G0PLYL(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SCAYLI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 215)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AXES WITH (OPTIONAL) ANNOTATION ON THE
C          BOTTOM AND LEFT WINDOW EDGES, AND CORRESPONDING
C          TICK MARKS (ONLY) ON THE TOP AND RIGHT WINDOW EDGES,
C          WITH THE X-INTERVAL SET BY <DIX>.
C
C
C          [X-LINEAR, Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(92,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
      IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
      CALL G0DIVL(2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      KAXIS= 1
      CALL G0TICK
      CALL G0PLAX(0)
      KAXIS= 2
      CALL G0TICK
      CALL G0PLYL(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE SECELL(XSTART,YSTART,ANGLE,ECCEN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 106)   VERSION (A8.3)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A SECTOR OF AN ELLIPSE WHICH IS
C          CENTRED ON THE CURRENT PLOTTING POSITION.
C
C
C          <XSTART> IS THE STARTING X-COORDINATE,
C          <YSTART> IS THE STARTING Y-COORDINATE,
C          <ANGLE>  IS THE ARC ANGLE ANTI-CLOCKWISE
C                   FROM THE STARTING POSITION,
C          <ECCEN>  IS THE ECCENTRICITY OF THE ELLIPSE.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3CONS/ PI
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      RTRAC1= XSTART
      RTRAC2= YSTART
      RTRAC3= ANGLE
      RTRAC4= ECCEN
      IF (IPRINT.EQ.1) CALL G0MESG(135,4)
C
      RDATA(1)= XSTART-XPLOT0
      RDATA(2)= YSTART-YPLOT0
      RDATA(4)= ABS(ECCEN)
C
C          CALCULATE THE TRUE ROTATION ANGLE ALLOWING FOR
C          DIFFERENT SCALING ON THE X AND Y AXES.
C
      YSCALE= (X2MAP0-X1MAP0)/(Y2MAP0-Y1MAP0)
      YCOORD= RDATA(2)*YSCALE
      ANG= ANGLE*ANGCON
      SINANG= SIN(ANG)
      COSANG= COS(ANG)
      ANUM= RDATA(4)*SINANG*(RDATA(1)*RDATA(1)+YCOORD*YCOORD)
      DENOM= COSANG*(RDATA(1)*RDATA(1)+
     &       YCOORD*YCOORD*RDATA(4)*RDATA(4))+
     &       SINANG*RDATA(1)*YCOORD*(RDATA(4)*RDATA(4)-1)
      RDATA(3)= ATAN2(ANUM,DENOM)
      IF ((RDATA(3)*ANG).LT.0.0)
     &     RDATA(3)= RDATA(3)+PI*SIGN(1.0,ANG)
    1   IF (ABS(RDATA(3)-ANG).LT.PI*0.5) GO TO 2
        RDATA(3)= RDATA(3)+PI*SIGN(1.0,ANG)
       GO TO 1
C
    2 XC= XPLOT0
      YC= YPLOT0
      YSCALE= YSCALE*RDATA(4)
      XE= XPLOT0+(XSTART-XPLOT0)*COS(RDATA(3))
     &    -(YSTART-YPLOT0)*SIN(RDATA(3))*YSCALE
      YE= YPLOT0+(XSTART-XPLOT0)*SIN(RDATA(3))/YSCALE
     &    +(YSTART-YPLOT0)*COS(RDATA(3))
      IF (KOLFL0.EQ.0) GO TO 3
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XC,YC)
      CALL JOIN(XSTART,YSTART)
      CALL POSITN(XC,YC)
      CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
      CALL POSITN(XE,YE)
      CALL JOIN(XC,YC)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) RETURN
C
    3 CALL POSITN(XC,YC)
      CALL JOIN(XSTART,YSTART)
      CALL POSITN(XC,YC)
      CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
      CALL POSITN(XE,YE)
      CALL JOIN(XC,YC)
C
      RETURN
      END
      SUBROUTINE SELBUF(NBUFFR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  12)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SELECTS BUFFER NO. 'NBUFFR'.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NBUFFR
      IF (IPRINT.EQ.1) CALL G0MESG(114,5)
      IF (NBUFFR.LE.0.OR.NBUFFR.GT.16) GO TO 901
C
      KBUFR0= NBUFFR
      IDATA(1)= NBUFFR
      CALL G3LINK(4,1,-1,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 6
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE SURANG(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 137)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SPECIFIES THE VERTICAL ANGLE OF VIEW
C          FOR THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ANGLE>  THE VERTICAL VIEW ANGLE IN UNITS
C                   OF THE CURRENTLY-SET ANGLE TYPE.
C
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3CONS/ PI
C
      DATA ROOTWO /1.414214/
C
C
      CALL G3INIT(2)
C
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(152,1)
C
      TLTANG= ANGLE*ANGCON
      PIBY2= PI*0.5
      IF (TLTANG.GT.PIBY2) TLTANG= PIBY2
      IF (TLTANG.LT.-PIBY2) TLTANG= -PIBY2
C
      CSROOT= COS(TLTANG)*ROOTWO
      SANGLE= ATAN(SIN(TLTANG))
      COSANG= COS(SANGLE)
      SINANG= SIN(SANGLE)
      RETURN
      END
      SUBROUTINE SURAXE(IAXIND,XORIGN,YORIGN,XDELTA,YDELTA)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 115)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS DETAILS OF THE AXIS ANNOTATION
C          FOR THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C
C          <IAXIND>  IS THE AXIS ANNOTATION METHOD NUMBER.
C          <XORIGN>  AND
C          <YORIGN>  SPECIFY THE COORDINATES OF THE ORIGIN
C                    OF THE SURFACE ARRAY FOR METHODS 2 AND 3.
C          <XDELTA>  AND
C          <YDELTA>  SPECIFY THE STEP SIZES FOR THE SURFACE
C                    ARRAY FOR METHODS 2 AND 3.
C
      LOGICAL ERRON
C
      COMMON /T0SAXE/ INDAXE,XAXORG,YAXORG,XAXDEL,YAXDEL
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      CALL G3INIT(2)
C
      ITRAC1= IAXIND
      IF (IPRINT.EQ.1) CALL G0MESG(158,5)
C
      IF (IAXIND.LT.0.OR.IAXIND.GT.3) GO TO 901
C
      INDAXE= IAXIND
      IF (INDAXE.EQ.0) RETURN
C
      XAXORG= XORIGN
      YAXORG= YORIGN
      XAXDEL= XDELTA
      YAXDEL= YDELTA
      RETURN
C
  901 NUMERR= 39
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE SURBAS(IUNDR,IBASE,HTBASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 133)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS DETAILS OF THE BASE OF THE FIGURE
C          DRAWN BY THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IUNDR>  IF SET TO ZERO, AN UNDERSIDE IS NOT DRAWN.
C          <IBASE>  MAY BE SET TO 0, 1, OR 2.
C                   = 0  NO BASE.
C                   = 1  DRAW BASE AT HEIGHT SHMIN.
C                   = 2  DRAW BASE AT HEIGHT MIN(HTBASE,SHMIN).
C                        (THIS IS THE ONLY CASE IN WHICH HTBASE IS USED.)
C          <HTBASE>  USED WHEN IBASE= 2 AS DESCRIBED ABOVE.
C
C
      LOGICAL ERRON
C
      COMMON /T0SBAS/ IUNDRS,INDBAS,BASEHT
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
      CALL G3INIT(2)
C
      ITRAC1= IUNDR
      ITRAC2= IBASE
      IF (IPRINT.EQ.1) CALL G0MESG(148,6)
C
      IUNDRS= 0
      IF (IUNDR.NE.0) IUNDRS= 1
C
      IF (IBASE.LT.0.OR.IBASE.GT.2) GO TO 901
C
      INDBAS= IBASE
      IF (IBASE.EQ.2) BASEHT= HTBASE
      RETURN
C
  901 NUMERR= 38
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE SURCOL(NTOPCL,NUNDCL,NBASCL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 139)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE TOPSIDE, UNDERSIDE AND BASE COLOURS
C          FOR THE SURFACE DRAWING ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <NTOPCL>  IS THE COLOUR OF THE TOPSIDE.
C          <NUNDCL>  IS THE COLOUR OF THE UNDERSIDE.
C          <NBASCL>  IS THE COLOUR OF THE BASE.
C
C
      COMMON /T0SCOL/ LINCUP,LINCLW,LINCBS
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= NTOPCL
      ITRAC2= NUNDCL
      ITRAC3= NBASCL
      IF (IPRINT.EQ.1) CALL G0MESG(153,7)
C
      IF (NTOPCL.LT.0.OR.NTOPCL.GT.255) GO TO 1
      LINCUP= NTOPCL
    1 IF (NUNDCL.LT.0.OR.NUNDCL.GT.255) GO TO 2
      LINCLW= NUNDCL
    2 IF (NBASCL.LT.0.OR.NBASCL.GT.255) RETURN
      LINCBS= NBASCL
      RETURN
      END
      SUBROUTINE SURDIR(IVIEW)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 132)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE VIEW DIRECTION FOR THE
C          SURFACE DRAWING ROUTINE <SURPLT>.
C
C
C          THE ARGUMENT MAY TAKE THE FOLLOWING VALUES:
C
C          =0 => VIEW FROM +X,+Y,+Z OCTANT,
C          =1 => VIEW FROM +X,-Y,+Z OCTANT,
C          =2 => VIEW FROM -X,-Y,+Z OCTANT,
C          =3 => VIEW FROM -X,+Y,+Z OCTANT.
C
C
      COMMON /T0SVEW/ IVIEWN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= IVIEW
      IF (IPRINT.EQ.1) CALL G0MESG(147,5)
C
      IF (IVIEW.LT.0.OR.IVIEW.GT.3) RETURN
      IVIEWN= IVIEW
      RETURN
      END
      SUBROUTINE SURIND(IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 136)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SPECIFIES WHETHER AN AXIS DIRECTION INDICATOR
C          IS TO BE DRAWN BY THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IENABL>  IF SET TO ZERO, NO AXIS DIRECTION
C                    INDICATOR IS PLOTTED.
C
C
      COMMON /T0SIND/ ISURIN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= IENABL
      IF (IPRINT.EQ.1) CALL G0MESG(151,5)
C
      ISURIN= 0
      IF (IENABL.NE.0) ISURIN= 1
      RETURN
      END
      SUBROUTINE SURPLT(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 131)   VERSION (A8.2)    24:NOV:86
C          ------------------------------------------------
C
C          THIS PLOTS A SURFACE PROJECTION OF THE REGULAR
C          RECTANGULAR GRID OF SPOT HEIGHTS IN SURFAS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES.
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDING Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C
C
      REAL    SURFAS(NPTSX,NPTSY),ARG(2)
      LOGICAL ERRON
      LOGICAL XSECT
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
      COMMON /T0SBAS/ IUNDRS,INDBAS,BASEHT
      COMMON /T0SCOM/ XLEN,YLEN,SCALE,XSHIFT,YSHIFT,SURMIN,SURMAX
      COMMON /T0SDEL/ DELTXY,DELTAU,DELTAV
      COMMON /T0SIND/ ISURIN
      COMMON /T0SSCA/ SHTMIN,SHTMAX,XPTCH
      COMMON /T0SSEC/ ISECTN
      COMMON /T0SVEW/ IVIEWN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA LETTRX /88/, LETTRY /89/, LETTRZ /90/, ICIRCL /229/,
     &     ARG /0.0,1.0/
C
C
      ITRAC1= ISTRTX
      ITRAC2= ISTOPX
      ITRAC3= ISTRTY
      ITRAC4= ISTOPY
      IF (IPRINT.EQ.1) CALL G0MESG(146,8)
C
      ILENX= ISTOPX-ISTRTX
      ILENY= ISTOPY-ISTRTY
      XLEN= ILENX
      YLEN= ILENY
      IF (ISTRTX.LT.1.OR.ISTRTY.LT.1)         GO TO 901
      IF (ILENX.LT.1.OR.ILENX.GT.192)         GO TO 901
      IF (ILENY.LT.1.OR.ILENY.GT.192)         GO TO 901
      IF (ISTOPX.GT.NPTSX.OR.ISTOPY.GT.NPTSY) GO TO 901
C
      LINSAV= KOLIN0
      NUMSAV= MAPNUM
      MAGSAV= MAGN0
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
      IPRSAV= IPRINT
      IPRINT=0
      CALL G0AUTO(ARG,ARG,1,2,1,2,1)
C
C          THE NEXT SECTION SCANS SURFAS FOR MINIMUM AND
C          MAXIMUM HEIGHTS IF THESE HAVE NOT BEEN SPECIFIED.
C
      SURMIN= SHTMIN
      SURMAX= SHTMAX
      IF (ABS(SHTMAX-SHTMIN).GT.RMINI) GO TO 1
C
      SURMAX= SURFAS(ISTRTX,ISTRTY)
      SURMIN= SURMAX
C
      DO 100 J= ISTRTY,ISTOPY
        DO 100 I= ISTRTX,ISTOPX
          HT= SURFAS(I,J)
          IF (HT.GT.SURMAX) SURMAX= HT
          IF (HT.LT.SURMIN) SURMIN= HT
  100 CONTINUE
C
    1 IF (INDBAS.EQ.2) SURMIN= AMIN1(BASEHT,SURMIN)
C
      XPSAV= XPLOT0
      YPSAV= YPLOT0
      X1MSAV= X1MAPV
      X2MSAV= X2MAPV
      Y1MSAV= Y1MAPV
      Y2MSAV= Y2MAPV
      X1WSAV= X1WND0
      X2WSAV= X2WND0
      Y1WSAV= Y1WND0
      Y2WSAV= Y2WND0
      MRKSAV= MRKWIN
      DIFF= X2WND0-X1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      XM1= (X1MAPV-X1WND0)/DIFF
      XM2= (X2MAPV-X1WND0)/DIFF
      DIFF= Y2WND0-Y1WND0
      IF (ABS(DIFF).LT.RMINI) RETURN
C
      YM1= (Y1MAPV-Y1WND0)/DIFF
      YM2= (Y2MAPV-Y1WND0)/DIFF
      CALL MAP(XM1,XM2,YM1,YM2)
      CALL WINDOW(-0.5,1.5,-0.5,1.5)
      CALL CTRSIZ(0.01)
C
C          CALCULATE SCALE FACTOR FOR THE MAPPING.
C
      XPSUR= XPTCH*(SURMAX-SURMIN)*1.2
      IF (XPSUR.LT.RMINI) XPSUR= 1.0
C
      FACT= XPSUR*(XLEN+YLEN)/XLEN
      XSCALE= FACT*COSANG
      YSCALE= FACT*ABS(SINANG)+(SURMAX-SURMIN)*CSROOT*COSANG
      IF (XSCALE.GE.YSCALE) SCALE= 1.0/XSCALE
      IF (YSCALE.GE.XSCALE) SCALE= 1.0/YSCALE
C
      DELTXY= SCALE*XPSUR/XLEN
      DELTAU= DELTXY*COSANG
      DELTAV= DELTXY*SINANG
      XSHIFT= DELTAU*YLEN
      IF (IVIEWN.EQ.0.OR.IVIEWN.EQ.2) GO TO 2
C
      XSHIFT= DELTAU*XLEN
      DELTAU= -DELTAU
    2 YSHIFT= -SCALE*SURMIN*CSROOT*COSANG
      IF (TLTANG.LT.0.0) YSHIFT= SCALE*(YSCALE-SURMAX*CSROOT*COSANG)
C
      XSECT= ISECTN.GE.0
C
C          CALL PROJECTION ROUTINE.  THIS WILL GENERATE SECTIONING LINES
C          IN ONE DIRECTION PER CALL.
C
    3 CALL G0SUR1(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &            XSECT)
      IF (ISECTN.NE.0.OR..NOT.XSECT) GO TO 4
C
      XSECT= .FALSE.
      GO TO 3
C
C          THE DIRECTION INDICATORS ARE DRAWN IF REQUIRED.
C
    4 CALL LINCOL(LINSAV)
      IF (ISURIN.EQ.0) GO TO 9
C
      XTRAN= 0.03*COSANG
      YTRAN= 0.03*SINANG
      CALL POSITN(0.95+XTRAN,0.03+YTRAN)
      CALL TYPENI(MOD(IVIEWN+3,4))
      CALL JOIN(0.95,0.03)
      CALL LINEFD(ISIGN(1,INT(SINANG*1000.0)))
      CALL SPACE(-1)
      CALL TYPENI(IVIEWN)
      CALL LINE(-XTRAN,YTRAN)
      CALL SPACE(-2)
      CALL TYPENI(MOD(IVIEWN+1,4))
      CALL POSITN(0.05,0.03)
      CALL TYPENC(ICIRCL)
      CALL JOIN(0.05,0.06)
      CALL PLOTNC(0.05,0.07,LETTRZ)
      IRN= IVIEWN+1
      GO TO (5,6,7,8), IRN
C
    5 CALL POSITN(0.05+XTRAN,0.03+YTRAN)
      CALL SPACE(1)
      CALL TYPENC(LETTRX)
      CALL JOIN(0.05,0.03)
      CALL LINE(-XTRAN,YTRAN)
      CALL SPACE(-1)
      CALL TYPENC(LETTRY)
      GO TO 9
C
    6 CALL POSITN(0.05-XTRAN,0.03+YTRAN)
      CALL SPACE(-1)
      CALL TYPENC(LETTRX)
      CALL JOIN(0.05,0.03)
      CALL LINE(-XTRAN,-YTRAN)
      CALL SPACE(-1)
      CALL TYPENC(LETTRY)
      GO TO 9
C
    7 CALL POSITN(0.05-XTRAN,0.03-YTRAN)
      CALL SPACE(-1)
      CALL TYPENC(LETTRX)
      CALL JOIN(0.05,0.03)
      CALL LINE(XTRAN,-YTRAN)
      CALL SPACE(1)
      CALL TYPENC(LETTRY)
      GO TO 9
C
    8 CALL POSITN(0.05+XTRAN,0.03-YTRAN)
      CALL SPACE(1)
      CALL TYPENC(LETTRX)
      CALL JOIN(0.05,0.03)
      CALL LINE(XTRAN,YTRAN)
      CALL SPACE(1)
      CALL TYPENC(LETTRY)
C
C          THE ENTRY STATE IS RESTORED BEFORE ENDING
C
    9 CALL WINFOL
      MAPNUM= NUMSAV
      CALL G0MAPS(X1MSAV,X2MSAV,Y1MSAV,Y2MSAV)
      IF (MRKSAV.NE.0) CALL WINDOW(X1WSAV,X2WSAV,Y1WSAV,Y2WSAV)
C
      CALL POSITN(XPSAV,YPSAV)
      CALL CTRMAG(MAGSAV)
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR=37
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE SURSCA(HTMIN,HTMAX,XYPTCH)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 135)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE SCALING ATTRIBUTES OF THE FIGURE
C          DRAWN BY THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <HTMIN>  SPECIFIES THE MINIMUM HEIGHT WHICH SHOULD BE DEPICTED
C                   IN THE FIGURE. IF ANY HEIGHTS LESS THAN THIS VALUE OCCUR
C                   IN THE SURFACE HEIGHT ARRAY PASSED TO SURPLT, THEN THEY
C                   WILL BE TAKEN AS BEING EQUAL TO HTMIN.
C          <HTMAX>  SPECIFIES THE MAXIMUM HEIGHT WHICH SHOULD BE DEPICTED.
C                   IT IS USED IN A SIMILAR FASHION TO <HTMIN>.
C          <XYPTCH> SPECIFIES A FACTOR WHICH DETERMINES THE DRAWN SIZE OF
C                   THE XMESH PITCH IN TERMS OF THE VERTICAL EXTENT OF THE
C                   SURFACE.  BY DEFAULT, A VALUE OF ONE IS USED.  VALUES
C                   LESS THAN 0.1 IMPLY NO CHANGE IN <XYPTCH> IS REQUIRED.
C
C
      COMMON /T0SSCA/ SHTMIN,SHTMAX,XPTCH
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= HTMIN
      RTRAC2= HTMAX
      RTRAC3= XYPTCH
      IF (IPRINT.EQ.1) CALL G0MESG(150,3)
C
      SHTMIN= AMIN1(HTMIN,HTMAX)
      SHTMAX= AMAX1(HTMIN,HTMAX)
C
      IF (XYPTCH.LT.0.1) RETURN
C
      XPTCH= XYPTCH
      RETURN
      END
      SUBROUTINE SURSEC(ISECT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 134)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE SECTIONING STYLE OF THE FIGURE
C          DRAWN BY THE ROUTINE <SURPLT>.
C
C
C          THE ARGUMENT MAY TAKE THE FOLLOWING VALUES:
C
C          = +VE,  SECTIONING LINES PARALLEL TO THE X AXIS ONLY,
C          = ZERO, SECTIONING LINES PARALLEL TO BOTH AXES,
C          = -VE,  SECTIONING LINES PARALLEL TO THE Y AXIS ONLY,
C
C
      COMMON /T0SSEC/ ISECTN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
C
      CALL G3INIT(2)
C
      ITRAC1= ISECT
      IF (IPRINT.EQ.1) CALL G0MESG(149,5)
C
      ISECTN= ISECT
      IF (ISECTN.NE.0) ISECTN= ISIGN(1,ISECTN)
      RETURN
      END
      SUBROUTINE SWICHR(KOMCHR,NUMCHR)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 182)   VERSION (A7.2)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DEFINES THE COMMAND-STRING SWITCH (<KOMCHR>) AND
C          CHARACTER-NUMBER IDENTIFIER (<NUMCHR>) CHARACTERS. IF
C          THE GIVEN VALUE IS < 0, THE OLD VALUE IS NOT CHANGED.
C
C
      COMMON /T0COMS/ NOWCOM,NOWNUM
C
C
      IF (KOMCHR.GT.0) NOWCOM= KOMCHR
      IF (NUMCHR.GT.0) NOWNUM= NUMCHR
C
      RETURN
      END
      SUBROUTINE TABLET(XPOS,YPOS,ICHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1046)   VERSION (A8.1)    08:FEB:90
C          ------------------------------------------------
C
C          THIS READS A LOCATOR FROM A TABLET.
C
C
C          THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <XPOS>   IS THE X-POSITION IN ND-SPACE UNITS,
C          <YPOS>   IS THE Y-POSITION IN ND-SPACE UNITS,
C          <ICHAR>  IS THE REPLY CHARACTER NO.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3MODE/ KMODE
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (KMODE.NE.2)  GO TO 1
C
C          IF DEVICE-MODE WORKING IS NOT POSSIBLE, THE
C          PRE-PROCESSOR ND-SPACE POSITION IS GIVEN.
C          THE REPLY CHARACTER IS AN EXCLAMATION MARK.
C
      CALL G0MAPP(XPLOT0,YPLOT0,XPOS,YPOS)
      ICHAR= 33
      RETURN
C
C          OTHERWISE, THE DEVICE BUFFERS ARE CLEARED
C          AND THE LOCATE POSITION READ FROM THE TABLET.
C
    1 CALL G3LINK(3,10,0,IDATA,RDATA)
      CALL G3GRIN(3,DUMMY,DUMMY,DUMMY,DUMMY,IDUMMY)
      CALL G3GRIN(2,DUMMY,DUMMY,XPOS,YPOS,ICHAR)
C
      RETURN
      END
      SUBROUTINE TCLIPA(IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. (  43)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS ENABLES/DISABLES TRANSFORMATION OF THE CLIPPING AREAS.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <IENABL> DETERMINES THE ACTION:
C                   = 0, WINDOW AND MASK ARE NOT TRANSFORMED,
C                   = 1, WINDOW AND MASK ARE TRANSFORMED IN
C                        THE SAME WAY AS THE CURRENT PICTURE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= IENABL
      IF (IPRINT.EQ.1) CALL G0MESG(144,5)
C
      KLIPM0= IABS(IENABL)
      IF (KLIPM0.GT.1) KLIPM0= 0
      IDATA(1)= KLIPM0
      CALL G3LINK(7,16,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE THICK(NLINES)
C
C          ------------------------------------------------
C          ROUTINE NO. (  55)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE SUBSEQUENT LINE THICKNESS.
C
C          THE THICKNESS IS IN BASIC LINE WIDTHS; THERE
C          ARE <NLINES>-1 ON EITHER SIDE OF THE CENTRAL LINE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NLINES
      IF (IPRINT.EQ.1) CALL G0MESG(25,5)
C
      ITHIK0= IABS(NLINES)
      IF (ITHIK0.GT.255) ITHIK0= 255
      IDATA(1)= ITHIK0
      CALL G3LINK(3,4,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE TPICT(MODE)
C
C          ------------------------------------------------
C          ROUTINE NO. (  42)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE PICTURE SCOPE OF TRANSFORMATIONS.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <MODE>   GIVES THE TRANSFORM RANGE, WHICH IS:
C                   = 0, NEITHER CURRENT NOR RETRIEVED PICTURES,
C                   = 1, CURRENT PICTURES ONLY,
C                   = 2, RETRIEVED PICTURES ONLY,
C                   = 3, BOTH CURRENT AND RETRIEVED PICTURES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= MODE
      IF (IPRINT.EQ.1) CALL G0MESG(143,5)
C
      MTRAN0= MODE
      IF (MTRAN0.LT.0) MTRAN0= 0
      IF (MTRAN0.GT.3) MTRAN0= 3
      IDATA(1)= MTRAN0
      CALL G3LINK(7,17,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE UNLBUF(NBUFFR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  14)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS UNLOADS BUFFER NO. 'NBUFFR'.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NBUFFR
      IF (IPRINT.EQ.1) CALL G0MESG(116,5)
C
      IF (NBUFFR.LE.0.OR.NBUFFR.GT.16) GO TO 901
C
      KBUFR0= NBUFFR
      IDATA(1)= NBUFFR
      CALL G3LINK(4,3,-1,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 7
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE UNLOC
C
C          ------------------------------------------------
C          ROUTINE NO. (  41)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS MAKES THE TWO REFERENCE POINTS UNIFY INTO ONE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL SHIFT0
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAN/ SCALX0,SCALY0,ROTAT0,RPICX0,RPICY0,RDEVX0,RDEVY0,
     &                VRPICX,VRPICY,VRDEVX,VRDEVY
      COMMON /T0TRST/ SHIFT0,MTRAN0,KLIPM0
C
      DATA IDATA /0/, RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(142,0)
C
C          THE REFERENCE POINTS ARE RECOMBINED, THEN
C          THE PRE-PROCESSOR REFERENCE POINTS ARE UPDATED.
C
      CALL G3LINK(7,13,0,IDATA,RDATA)
C
      VRPICX= XPLOT0
      VRPICY= YPLOT0
      VRDEVX= XPLOT0
      VRDEVY= YPLOT0
C
      CALL G0MAPP(XPLOT0,YPLOT0,RPICX0,RPICY0)
      RDEVX0= RPICX0
      RDEVY0= RPICY0
      SHIFT0= .FALSE.
C
      RETURN
      END
      SUBROUTINE UNMASK(LEVEL)
C
C          ------------------------------------------------
C          ROUTINE NO. (  29)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT LEVEL OF MASKING.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
      LOGICAL ERRON
C
      COMMON /T0MASK/ X1MSK0(10),X2MSK0(10),Y1MSK0(10),Y2MSK0(10),MSKLV0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      ITRAC1= LEVEL
      IF (IPRINT.EQ.1) CALL G0MESG(14,5)
C
      IF (LEVEL.LT.0.OR.LEVEL.GT.10) GO TO 901
C
      IDATA(1)= LEVEL
      CALL G3LINK(7,7,-1,IDATA,RDATA)
      MSKLV0= LEVEL
      RETURN
C
  901 NUMERR= 4
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE VMENU(XFIRST,XLAST,YFIRST,YLAST,LABELS,
     &                NLABLS,IDRAW,ISELEC)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 323)   VERSION (A8.1)    16:AUG:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS A VERTICAL MENU AND RETURNS A CHOSEN ITEM.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XFIRST,YFIRST> IS THE START CORNER, AND
C          <XLAST,YLAST>   IS THE FINISH CORNER OF THE MENU AREA.
C          [LABELS]   CONTAINS THE LABELS TO BE WRITTEN
C                     IN THE MENU BOXES.
C          <NLABLS>   IS THE NUMBER OF LABELS.
C          <IDRAW>    WHEN SET TO ZERO, THE MENU IS NOT DRAWN.
C          <ISELEC>   IS THE NUMBER OF THE CHOSEN MENU ITEM.
C
C
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0TRAC/ IPRINT
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(162,0)
C
      IPRSAV= IPRINT
      IPRINT= 0
      ISELEC= 0
      IF (IDRAW.NE.0) CALL VCHTKY(XFIRST,XLAST,YFIRST,YLAST,LABELS,
     &                            NLABLS)
C
    1 CALL CURSOR(XPOS,YPOS,ICHAR)
      IF (ICHAR.EQ.33) RETURN
      IF ((YPOS-YFIRST)*(YPOS-YLAST).GT.0.0) GO TO 1
C
      YINT= (YLAST-YFIRST)/NLABLS
      SELEC= (YPOS+YINT-YFIRST)/YINT
      REM= AMOD(SELEC,1.0)
      IF (REM.LT.0.05.OR.REM.GT.0.95) GO TO 1
C
      ISELEC= SELEC
      IPRINT= IPRSAV
      RETURN
      END
      SUBROUTINE WINCHR(IENABL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 178)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS WHETHER CHARACTERS ARE
C          SUBJECT TO THE VECTOR WINDOW OR NOT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CVIS/ KWIND0,KMASK0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= IENABL
      IF (IPRINT.EQ.1) CALL G0MESG(127,5)
C
      KWIND0= IENABL
      IF (KWIND0.NE.0) KWIND0= 1
      IDATA(1)= KWIND0
      CALL G3LINK(2,13,-1,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE XAXIS
C
C          ------------------------------------------------
C          ROUTINE NO. ( 193)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(71,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE XAXISI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 196)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION,
C          WITH INTERVAL SET BY <DIX>.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(74,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE XAXISL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 203)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(81,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXYSAV= AXPOSY
      IF (ABS(AXPOSY).LT.RMINI) AXPOSY= X1WND0
C
      CALL G0DIVL(1)
      CALL G0TICK
      CALL G0PLXL(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSY= AXYSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE XGRAT
C
C          ------------------------------------------------
C          ROUTINE NO. ( 219)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS AN X-GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(97,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X2WND0-X1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,0.0)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,Y1WND0)
        CALL JOIN(XPOS,Y2WND0)
  100 CONTINUE
C
    1 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE XGRATI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 222)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS AN X-GRATICULE WITH NO ANNOTATION,
C          WITH THE AXIS INTERVAL SET BY <DIX>.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(100,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X2WND0-X1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(1,DIX)
      NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) GO TO 1
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKLX+ITICK-1)
        CALL POSITN(XPOS,Y1WND0)
        CALL JOIN(XPOS,Y2WND0)
  100 CONTINUE
C
    1 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE XGRATL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 229)   VERSION (A8.6)    17:JUN:88
C          ------------------------------------------------
C
C          THIS DRAWS AN X-GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(107,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(X2WND0-X1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE X-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVL(1)
      IPOS= NTIKLX
      IDEC= NSKIPX
      NDECS= NDECSX
      NTICKS= NTIKHX
      IF (NTICKS.LE.37) GO TO 1
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      DO 100 ITICK= 1,NDECS
        XPOS= DIVLX*(10.0**(ITICK+IDEC))
        CALL POSITN(XPOS,Y1WND0)
        CALL JOIN(XPOS,Y2WND0)
  100 CONTINUE
C
      AXXSAV= AXPOSX
      AXPOSX= Y1WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= Y2WND0
      CALL G0TICK
      CALL G0PLXL(0)
      AXPOSX= AXXSAV
      GO TO 2
C
    1 IF (NTICKS.LE.0) GO TO 2
C
      DO 200 ITICK= 1,NTICKS
        XPOS= DIVLX*IPOS*(10.0**IDEC)
        CALL POSITN(XPOS,Y1WND0)
        CALL JOIN(XPOS,Y2WND0)
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 200
C
        IPOS= 1
        IDEC= IDEC+1
  200 CONTINUE
C
    2 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END

      SUBROUTINE XSCALE
C
C          ------------------------------------------------
C          ROUTINE NO. ( 206)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE BOTTOM WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE TOP WINDOW EDGE, SETTING THE
C          MARKING INTERVALS AUTOMATICALLY.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
c slmod begin
      COMMON /T0AARG/ KAXIS
      COMMON /GHOSTCOM/ iopt_ghost
c slmod end
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(84,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
c slmod begin
c...dev
      IF (iopt_ghost.EQ.0) CALL CTRMAG(MAG)
      IF (iopt_ghost.EQ.2) KAXIS= -1
c
c      CALL CTRMAG(MAG)
c slmod end
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,0.0)
      CALL G0TICK
      CALL G0PLAX(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
c slmod begin
c...  No tick marks at the top of the x-axis:
c      CALL G0TICK
c      CALL G0PLAX(0)
c slmod end
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE XSCALI(DIX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 209)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE BOTTOM WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE TOP WINDOW EDGE, WITH THE
C          MARKING INTERVALS SET BY <DIX>.
C
C
C          [X-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIX
      IF (IPRINT.EQ.1) CALL G0MESG(87,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(1,DIX)
      CALL G0TICK
      CALL G0PLAX(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      CALL G0TICK
      CALL G0PLAX(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE XSCALL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 216)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN X-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE BOTTOM WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE TOP WINDOW EDGE, SETTING THE
C          MARKING INTERVALS AUTOMATICALLY.
C
C
C          [X-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(94,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVL(1)
      CALL G0TICK
      CALL G0PLXL(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      CALL G0TICK
      CALL G0PLXL(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YAXIS
C
C          ------------------------------------------------
C          ROUTINE NO. ( 194)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXES INTERVALS AUTOMATICALLY.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
c slmod begin
      COMMON /GHOSTCOM/ iopt_ghost
c slmod end
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(72,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
c slmod begin
      IF (iopt_ghost.EQ.0) CALL CTRMAG(MAG)
c
c      CALL CTRMAG(MAG)
c slmod end
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YAXISI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 197)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION,
C          WITH INTERVAL SET BY <DIY>.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(75,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      CALL G0DIVS(2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YAXISL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 204)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(82,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      IF (ABS(AXPOSX).LT.RMINI) AXPOSX= Y1WND0
C
      CALL G0DIVL(2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YGRAT
C
C          ------------------------------------------------
C          ROUTINE NO. ( 220)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A Y-GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(98,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(Y2WND0-Y1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE Y-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(2,0.0)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 1
C
      DO 100 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(X1WND0,YPOS)
        CALL JOIN(X2WND0,YPOS)
  100 CONTINUE
C
    1 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE YGRATI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 223)   VERSION (A8.6)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A Y-GRATICULE WITH NO ANNOTATION,
C          WITH THE AXIS INTERVAL SET BY <DIY>.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(101,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(Y2WND0-Y1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE Y-AXIS GRATICULE LINES ARE DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVS(2,DIY)
      NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) GO TO 1
C
      DO 100 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKLY+ITICK-1)
        CALL POSITN(X1WND0,YPOS)
        CALL JOIN(X2WND0,YPOS)
  100 CONTINUE
C
    1 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE YGRATL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 230)   VERSION (A8.6)    17:JUN:88
C          ------------------------------------------------
C
C          THIS DRAWS A Y-GRATICULE WITH NO ANNOTATION,
C          SETTING THE AXIS INTERVALS AUTOMATICALLY.
C
C
C          [Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(108,0)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS DONE.
C          THE ANNOTATION MARKER IS SAVED AND THEN SET = 0
C          SO THAT ANNOTATION IS NOT DONE WITH A GRATICULE.
C          THE CURRENT PLOTTING POSITION IS THEN SAVED.
C
      IF (ABS(Y2WND0-Y1WND0).LT.RMINI) RETURN
C
      NTATSV= NOTATA
      NOTATA= 0
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE Y-AXIS GRATICULE LINES ARE DRAWN.
C          IF THERE ARE MORE THAN 37 SUB-INTERVALS IN THE Y-AXIS,
C          THESE ARE DRAWN AS EDGE TICKS; OTHERWISE THEY ARE DONE
C          AS FULL GRATICULE LINES (JUST AS THE DECADE INTERVALS).
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
      CALL G0DIVL(2)
      IPOS= NTIKLY
      IDEC= NSKIPY
      NDECS= NDECSY
      NTICKS= NTIKHY
      IF (NTICKS.LE.37) GO TO 1
      IF (IPOS.EQ.1) IDEC= IDEC-1
C
      DO 100 ITICK= 1,NDECS
        YPOS= DIVLY*(10.0**(ITICK+IDEC))
        CALL POSITN(X1WND0,YPOS)
        CALL JOIN(X2WND0,YPOS)
  100 CONTINUE
C
      AXYSAV= AXPOSY
      AXPOSY= X1WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= X2WND0
      CALL G0TICK
      CALL G0PLYL(0)
      AXPOSY= AXYSAV
      GO TO 2
C
    1 IF (NTICKS.LE.0) GO TO 2
C
      DO 200 ITICK= 1,NTICKS
        YPOS= DIVLY*IPOS*(10.0**IDEC)
        CALL POSITN(X1WND0,YPOS)
        CALL JOIN(X2WND0,YPOS)
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 200
C
        IPOS= 1
        IDEC= IDEC+1
  200 CONTINUE
C
    2 IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          THE ANNOTATION MARKER AND THE CURRENT
C          PLOTTING POSITION ARE THEN RESTORED.
C
      NOTATA= NTATSV
      CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE YSCALE
C
C          ------------------------------------------------
C          ROUTINE NO. ( 207)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE LEFT WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE RIGHT WINDOW EDGE, SETTING THE
C          MARKING INTERVALS AUTOMATICALLY.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
c slmod begin
      COMMON /GHOSTCOM/ iopt_ghost
c slmod end
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(85,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
c slmod begin
      IF (iopt_ghost.EQ.0) CALL CTRMAG(MAG)
c
c      CALL CTRMAG(MAG)
c slmod end
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(2,0.0)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YSCALI(DIY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 210)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE LEFT WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE RIGHT WINDOW EDGE, WITH THE
C          MARKING INTERVALS SET BY <DIY>.
C
C
C          [Y-LINEAR MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      RTRAC1= DIY
      IF (IPRINT.EQ.1) CALL G0MESG(88,1)
C
C          IF THE WINDOW AREA IS WRONG, NOTHING MORE IS
C          DONE. OTHERWISE, THE CURRENT C-SPACE ARGUMENTS
C          ARE SAVED AND C-SPACE IS SWITCHED OFF, THEN
C          THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVS(2,DIY)
      CALL G0TICK
      CALL G0PLAY(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      CALL G0TICK
      CALL G0PLAY(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHAR.-SPACE
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE YSCALL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 217)   VERSION (A7.6)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS A Y-AXIS WITH (OPTIONAL) ANNOTATION
C          ON THE LEFT WINDOW EDGE, AND CORRESPONDING TICK
C          MARKS (ONLY) ON THE RIGHT WINDOW EDGE, SETTING
C          THE MARKING INTERVALS AUTOMATICALLY.
C
C
C          [Y-LOGARITHMIC MARKING].
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0NOTA/ NOTATA
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(95,0)
C
C          IF THE WINDOW AREA OR THE X-MAPPING IS WRONG,
C          NOTHING MORE IS DONE. OTHERWISE, THE CURRENT
C          CHAR. MAGNIFICATION IS SAVED AND A SUITABLE
C          NEW ONE CALCULATED, THE CURRENT CHAR.-SPACE
C          ARGUMENTS ARE KEPT AND C-SPACE IS SWITCHED OFF,
C          THEN THE CURRENT PLOTTING POSITION IS STORED.
C
      IF (ABS(X1WND0-X2WND0).LT.RMINI.OR.
     &    ABS(Y1WND0-Y2WND0).LT.RMINI) RETURN
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
      IF (ABS(X1MAP0-X2MAP0).LT.RMINI) RETURN
      FRCWDX= (X2WND0-X1WND0)/(X2MAP0-X1MAP0)
      GO TO 2
C
    1 IF (SIGN(1.0,X1WND0)*SIGN(1.0,X2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,X1MAP0)*SIGN(1.0,X2MAP0).LE.0.0) RETURN
      FRCWDX= ALOG10(X2WND0/X1WND0)/ALOG10(X2MAP0/X1MAP0)
C
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
      IF (ABS(Y1MAP0-Y2MAP0).LT.RMINI) RETURN
      FRCWDY= (Y2WND0-Y1WND0)/(Y2MAP0-Y1MAP0)
      GO TO 4
C
    3 IF (SIGN(1.0,Y1WND0)*SIGN(1.0,Y2WND0).LE.0.0) RETURN
      IF (SIGN(1.0,Y1MAP0)*SIGN(1.0,Y2MAP0).LE.0.0) RETURN
      FRCWDY= ALOG10(Y2WND0/Y1WND0)/ALOG10(Y2MAP0/Y1MAP0)
C
    4 IPRSAV= IPRINT
      IPRINT= 0
      MAGSAV= MAGN0
      MAG= MIN1(12.5*ABS(FRCWDX),45.0*ABS(FRCWDY))
      IF (MAG.LE.0)   MAG= 1
      IF (MAG.GT.100) MAG= 100
      CALL CTRMAG(MAG)
C
      XCSAV1= X1CHR0
      XCSAV2= X2CHR0
      YCSAV1= Y1CHR0
      YCSAV2= Y2CHR0
      CALL CSPACE(0.0,0.0,0.0,0.0)
C
      STANSV= STANG0
      CRANSV= CRANG0
      OBLSAV= OBLAT0
      CALL CTRANG(0.0)
      CALL CTRORI(0.0)
      CALL CTROBL(1.0)
C
      XHERE= XPLOT0
      YHERE= YPLOT0
C
C          THE TICK MARK POSITIONS AND END POINTS
C          ARE CALCULATED, THEN THE AXIS IS DRAWN.
C
      IDATA(1)= 1
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
      AXXSAV= AXPOSX
      AXYSAV= AXPOSY
      AXPOSX= Y1WND0
      AXPOSY= X1WND0
C
      CALL G0DIVL(2)
      CALL G0TICK
      CALL G0PLYL(1)
C
      NTATSV= NOTATA
      NOTATA= 0
      AXPOSX= Y2WND0
      AXPOSY= X2WND0
C
      CALL G0TICK
      CALL G0PLYL(0)
C
      IDATA(1)= 0
      CALL G3LINK(0,14,-1,IDATA,RDATA)
C
C          FINALLY, THE PREVIOUS CHARACTER ATTRIBUTES
C          AND PLOTTING POSITION ARE RESTORED.
C
      CALL CTRANG(CRANSV/ANGCON)
      CALL CTRORI(STANSV/ANGCON)
      CALL CTROBL(OBLSAV)
      CALL CTRMAG(MAGSAV)
      CALL CSPACE(XCSAV1,XCSAV2,YCSAV1,YCSAV2)
      CALL POSITN(XHERE,YHERE)
      AXPOSX= AXXSAV
      AXPOSY= AXYSAV
      NOTATA= NTATSV
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE CSPACE(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 151)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT CHARACTER SPACE SIZE.
C
C
C          <XAREA1,YAREA1>  IS THE LOWER-LEFT CORNER, AND
C          <XAREA2,YAREA2>  IS THE UPPER-RIGHT CORNER.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(62,4)
C
      X1CHR0= XAREA1
      X2CHR0= XAREA2
      Y1CHR0= YAREA1
      Y2CHR0= YAREA2
C
      RDATA(1)= XAREA1
      RDATA(2)= XAREA2
      RDATA(3)= YAREA1
      RDATA(4)= YAREA2
      CALL G3LINK(2,10,4*NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CTRANG(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 179)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CHARACTER ANGLE RELATIVE TO ITS STRING.
C
C
C          <ANGLE>  IS THE ANGLE FROM THE HORIZONTAL IN
C                   UNITS OF THE CURRENTLY-SET ANGLE TYPE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(113,1)
C
      CRANG0= ANGLE*ANGCON
      RDATA(1)= CRANG0
      CALL G3LINK(2,5,NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CTRORI(ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 144)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CHARACTER STRING ANGLE.
C
C
C          <ANGLE>  IS THE ANGLE FROM THE HORIZONTAL IN
C                   UNITS OF THE CURRENTLY-SET ANGLE TYPE.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CSLO/ SLOPE,MRKSLP
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(55,1)
C
      MRKSLP= 0
      STANG0= ANGLE*ANGCON
      RDATA(1)= STANG0
      CALL G3LINK(2,4,NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CURSOR(XPOS,YPOS,ICHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. (1041)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS INVOKES THE DISPLAY CURSOR.
C
C
C          THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <XPOS>   IS THE X-POSITION IN VECTOR SPACE UNITS,
C          <YPOS>   IS THE Y-POSITION IN VECTOR SPACE UNITS,
C          <ICHAR>  IS THE REPLY CHARACTER NO.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3MODE/ KMODE
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      IF (KMODE.NE.2)  GO TO 1
C
C          IF DEVICE-MODE WORKING IS NOT POSSIBLE, THE
C          PRE-PROCESSOR ND-SPACE POSITION IS RETURNED.
C          THE REPLY CHARACTER IS AN EXCLAMATION MARK.
C
      XPOS= XPLOT0
      YPOS= YPLOT0
      ICHAR= 33
      RETURN
C
C          OTHERWISE, THE DEVICE BUFFERS ARE CLEARED,
C          THE CURSOR IS INVOKED AND THE POSITION READ.
C
    1 CALL G3LINK(3,10,0,IDATA,RDATA)
      CALL G3GRIN(1,DUMMY,DUMMY,DUMMY,DUMMY,IDUMMY)
      CALL G3GRIN(2,XPOS,YPOS,DUMMY,DUMMY,ICHAR)
C
      RETURN
      END
      SUBROUTINE HCHTKY(XFIRST,XLAST,YFIRST,YLAST,LABELS,NLABLS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 118)   VERSION (A8.1)    25:JUN:87
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS A CHART KEY HORIZONTALLY.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XFIRST,YFIRST> IS THE START CORNER, AND
C          <XLAST,YLAST>   IS THE FINISH CORNER OF THE KEY AREA.
C          [LABELS]   CONTAINS THE LABELS TO BE WRITTEN
C                     IN THE MENU BOXES.
C          <NLABLS>   IS THE NUMBER OF LABELS.
C
C
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0KLAB/ LABCL0(100),LENLAB
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(170,0)
      IF (NLABLS.LE.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XSAVE= XPLOT0
      YSAVE= YPLOT0
      KOLSAV= KOLFL0
      KOLLSV= KOLIN0
      MAGSAV= MAGN0
      KOLIND= 1
      KOLLIN= 1
      NCHARS= LEN(LABELS(1))
      XINT= (XLAST-XFIRST)/NLABLS
      XSTART= XFIRST
      XEND= XFIRST+XINT
      XSIZE= ABS(XINT*(Y2MAP0-Y1MAP0)*1.167/
     &          ((NCHARS+1)*OBLAT0*(X2MAP0-X1MAP0)))
      YSIZE= ABS(YLAST-YFIRST)*0.65
      SIZE= AMIN1(XSIZE,YSIZE)
      YCEN= (YLAST+YFIRST)*0.5-SIZE*0.2143
      CALL CTRSIZ(SIZE)
C
      DO 100 NBOX= 1,NLABLS
        IF (LENLST.LE.0) GO TO 1
C
        KOLFL0= LSTCL0(KOLIND)
        KOLIND= KOLIND+1
        IF(KOLIND.GT.LENLST) KOLIND= 1
C
    1   CALL BOX(XSTART,XEND,YLAST,YFIRST)
        IF (LENLAB.GT.0) CALL LINCOL(LABCL0(KOLLIN))
C
        KOLLIN= KOLLIN+1
        IF (KOLLIN.GT.LENLAB) KOLLIN= 1
C
        XCEN= XSTART+XINT*0.5
        CALL PCSCEN(XCEN,YCEN,LABELS(NBOX))
        CALL LINCOL(KOLLSV)
        XSTART= XEND
        XEND= XEND+XINT
  100 CONTINUE
C
      KOLFL0= KOLSAV
      CALL CTRMAG(MAGSAV)
      CALL POSITN(XSAVE,YSAVE)
      IPRINT= IPRSAV
      RETURN
      END
      SUBROUTINE INTRP1(XPOSNS,YPOSNS,ZPOSNS,NPNTS,XPOS,YPOS,
     &                  RADIUS,TOL,VALUE,IREPLY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 129)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS ESTIMATES THE HEIGHT AT A GIVEN POINT OF A SURFACE
C          DEFINED BY A SET OF HEIGHTS AT ARBITRARY X-Y POSITIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XPOSNS] THE SET OF SURFACE POINT X-COORDINATES,
C          [YPOSNS] THE SET OF SURFACE POINT Y-COORDINATES,
C          [ZPOSNS] THE SET OF SURFACE POINT Z-COORDINATES,
C          <NPNTS>  THE NUMBER OF DATA POINTS PROVIDED (AND THE
C                   MIN. SIZE OF EACH OF THE PRECEDING ARRAYS),
C          <XPOS>   THE INTERPOLATION POINT X-COORDINATE,
C          <YPOS>   THE INTERPOLATION POINT Y-COORDINATE,
C          <RADIUS> THE RADIUS OF ACCEPTANCE OF DATA POINTS,
C          <TOL>    THE CAPTURE RADIUS OF A SINGLE DATA POINT,
C          <VALUE>  THE (RETURNED) ESTIMATED HEIGHT VALUE,
C          <IREPLY> THE (RETURNED) REPLY CODE:
C                   = 0, THE INTERPOLATION VALUE IS VALID,
C                   = 1, THE INTERPOLATION WAS UNSUCCESSFUL.
C
C
C          THE SURFACE IS APPROXIMATED BY A SECOND-DEGREE POLYNOMIAL
C
C          P(U,V)= C1*(U*U+V*V) + C2*U + C3*V + C4
C
C          WHERE U= X-XPOS, V= Y-YPOS. THE REQUIRED SURFACE HEIGHT AT
C          (XPOS,YPOS) IS THEN GIVEN BY THE VALUE OF THE POLYNOMIAL
C          AT THAT POINT, NAMELY C4. THE COEFFICIENTS C1..C4 ARE
C          FOUND BY A DISTANCE-WEIGHTED LEAST-SQUARES FIT TO ALL
C          DATA POINTS WITHIN A GIVEN RADIUS OF (XPOS,YPOS). THE
C          LEAST-SQUARES CALCULATION IS ACHIEVED BY MEANS OF A QR-
C          FACTORISATION OF THE DATA MATRIX USING FAST GIVENS-
C          TRANSFORMATIONS. WITH THIS METHOD EACH ROW OF THE DATA
C          MATRIX IS CREATED AND TRANSFORMED IN TURN; THERE IS NO
C          NEED TO STORE THE FULL MATRIX. IF THE POSITION (XPOS,YPOS)
C          IS WITHIN A CAPTURE RADIUS OF ONE OF THE DATA POINTS,
C          THE HEIGHT VALUE OF THAT DATA POINT IS USED DIRECTLY.
C
C          REFERENCES:
C
C          K.J. FALCONER 'A GENERAL PURPOSE ALGORITHM FOR CONTOURING
C          OVER SCATTERED DATA POINTS' NPL REPORT DNAC6 (1971).
C
C          D.H. MCLAIN 'DRAWING CONTOURS FROM ARBITRARY DATA POINTS'
C          COMPUTER JOURNAL, VOL. 17, PAGE 318 (1974).
C
C          J.H. WILKINSON 'NUMERICAL LINEAR ALGEBRA',
C          IN 'STATE OF THE ART IN NUMERICAL ANALYSIS'
C          EDITOR D.A.H. JACOBS, ACADEMIC PRESS (1977).
C
C
      REAL    XPOSNS(NPNTS),YPOSNS(NPNTS),ZPOSNS(NPNTS),RSCALE(4),
     &        TRIANG(14),WORK(5)
C
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
C          <CRMIN> IS A MACHINE-DEPENDENT CONSTANT WHICH IS SET
C          TO 100 TIMES THE SMALLEST REPRESENTABLE REAL NUMBER.
C
      CRMIN= 100.0*RMINI
C
C          THE VARIABLE <NUSED> COUNTS THE NUMBER OF DATA
C          POINTS INCLUDED IN THE LEAST-SQUARES CALCULATION.
C
      NUSED= 0
      RADSQ= RADIUS*RADIUS
      TOLSQ= TOL*TOL
C
C          THE MAJOR LOOP BEGINS HERE. EACH DATA POINT IS EXAMINED
C          IN TURN AND IF ITS POSITION IS LESS THAN <RADIUS> FROM THE
C          INTERPOLATION POINT, IT IS INCLUDED IN THE CALCULATION.
C          THE CORRESPONDING ROW OF THE DATA MATRIX IS FORMED IN
C          [WORK], AND THEN TRANSFORMED USING A SEQUENCE OF
C          GIVENS-ROTATIONS. THE FACTOR 'Q' OF THE QR-TRANSFORMATION
C          IS NOT STORED, BUT THE UPPER TRIANGULAR MATRIX 'R' IS
C          BUILT UP IN THE ONE-DIMENSIONAL ARRAY [TRIANG]. THE SCALE
C          FACTORS FOR THE ROWS OF [TRIANG] ARE STORED IN [RSCALE].
C
      DO 100 ISCAN= 1,NPNTS
        XDIFF= XPOSNS(ISCAN)-XPOS
        YDIFF= YPOSNS(ISCAN)-YPOS
        DISTSQ= XDIFF*XDIFF+YDIFF*YDIFF
        IF (DISTSQ.GE.RADSQ) GO TO 100
C
C          IF THE DATA POINT IS LESS THAN <TOL> FROM (<XPOS>,<YPOS>),
C          THE CORRESPONDING HEIGHT VALUE IS RETURNED DIRECTLY.
C
        IF (DISTSQ.GT.TOLSQ) GO TO 1
        VALUE= ZPOSNS(ISCAN)
        IREPLY= 0
        RETURN
C
C          THE WEIGHT FACTOR <WEIGHT> ASSOCIATED WITH THE POINT IS
C          SET. IF IT IS VERY SMALL, THE POINT IS NOT INCLUDED.
C
    1   DIST= SQRT(DISTSQ)
        WEIGHT= (RADIUS-DIST)*(RADIUS-DIST)/DISTSQ
        IF (WEIGHT.LE.CRMIN) GO TO 100
C
        NUSED= NUSED+1
        WORK(1)= XDIFF*XDIFF+YDIFF*YDIFF
        WORK(2)= XDIFF
        WORK(3)= YDIFF
        WORK(4)= 1.0
        WORK(5)= ZPOSNS(ISCAN)
        KPIVOT= 1
C
C          THE FIRST ROW IS COPIED DIRECTLY TO [TRIANG]. OTHER
C          ROWS ARE TRANSFORMED USING GIVENS-ROTATIONS TO DELETE
C          ELEMENTS: THE GIVENS-TRANSFORMATION USES ROW <KROW> OF
C          THE R-MATRIX AND THE NEW ROW TO ANNIHILATE THE <KROW>-TH
C          ELEMENT OF THE NEW ROW. THE PIVOT VALUE IS STORED IN THE
C          ELEMENT <KPIVOT> OF [TRIANG] AND THE REMAINDER OF THE
C          <KROW>-TH ROW IN THE NEXT (5-<KROW>) ELEMENTS. A CHECK
C          IS FIRST MADE TO SEE IF ANY TRANSFORMATION IS NEEDED.
C
        IF (NUSED.EQ.1) GO TO 5
C
        KLIM= MIN0(NUSED-1,4)
        DO 200 KROW= 1,KLIM
          IF (ABS(WORK(KROW)).LT.CRMIN) GO TO 4
          KROWP1= KROW+1
C
C          TWO FORMS OF THE GIVENS-ROTATION ARE POSSIBLE (SEE 3RD.
C          REFERENCE ABOVE). A CHOICE IS MADE BETWEEN THE TWO
C          FORMS (TYPE-A AND TYPE-B) TO AVOID POSSIBILITIES OF
C          DIVISION BY ZERO AND UNDERFLOW. THE INITIAL SELECTION
C          IS MADE ON COMPARISON OF WORK(KROW) AND TRIANG(KPIVOT).
C
          IF (ABS(TRIANG(KPIVOT)).LE.ABS(WORK(KROW))) GO TO 3
C
C          THIS SECTION IS FOR TRANSFORMATION TYPE-A. IF
C          <SCALA3> < 2.0 THIS ONE IS USED. OTHERWISE THE
C          TYPE-B TRANSFORMATION BELOW IS USED INSTEAD.
C
    2     SCALA1= WORK(KROW)/TRIANG(KPIVOT)
          SCALA2= SCALA1*WEIGHT/RSCALE(KROW)
          SCALA3= SCALA1*SCALA2+1.0
C
          IF (SCALA3.GT.2.0) GO TO 3
C
C          <WEIGHT>, [RSCALE], THE PIVOT VALUE AND ROWS ARE REVISED.
C
          RSCALE(KROW)= RSCALE(KROW)/SCALA3
          WEIGHT= WEIGHT/SCALA3
C
          TRIANG(KPIVOT)= TRIANG(KPIVOT)+SCALA2*WORK(KROW)
C
          IEXT= KPIVOT
          DO 300 IREV= KROWP1,5
            IEXT= IEXT+1
            RNEW= TRIANG(IEXT)+SCALA2*WORK(IREV)
            WORK(IREV)= -SCALA1*TRIANG(IEXT)+WORK(IREV)
            TRIANG(IEXT)= RNEW
  300     CONTINUE
          GO TO 4
C
C          THIS SECTION IS FOR TRANSFORMATION TYPE-B. IF
C          <SCALB3> > 2.0 THIS ONE IS USED. OTHERWISE THE
C          TYPE-A TRANSFORMATION ABOVE IS USED INSTEAD.
C
    3     SCALB1= TRIANG(KPIVOT)/WORK(KROW)
          SCALB2= SCALB1*RSCALE(KROW)/WEIGHT
          SCALB3= 1.0+SCALB1*SCALB2
C
          IF (SCALB3.GT.2.0) GO TO 2
C
C          <WEIGHT>, [RSCALE], THE PIVOT VALUE AND ROWS ARE REVISED.
C
          VK= WEIGHT/SCALB3
          WEIGHT= RSCALE(KROW)/SCALB3
          RSCALE(KROW)= VK
C
          TRIANG(KPIVOT)= SCALB2*TRIANG(KPIVOT)+WORK(KROW)
C
          IEXT= KPIVOT
          DO 400 IREV= KROWP1,5
            IEXT= IEXT+1
            RNEW= SCALB2*TRIANG(IEXT)+WORK(IREV)
            WORK(IREV)= TRIANG(IEXT)-SCALB1*WORK(IREV)
            TRIANG(IEXT)= RNEW
  400     CONTINUE
C
C          THE POSITION OF THE PIVOT ELEMENT IS THEN UPDATED.
C
    4     KPIVOT= KPIVOT-KROW+6
  200   CONTINUE
        IF (NUSED.GT.4) GO TO 100
C
C          THIS COMPLETES THE SEQUENCE OF GIVENS-TRANSFORMATIONS. IF
C          THE R-MATRIX IS NOT COMPLETE, THE NEW ROW [WORK] IS ADDED.
C          <KPIVOT> IS THE START POSITION IN [TRIANG] OF THE NEW ROW.
C
    5   IEXT= KPIVOT
        DO 500 KOPY= NUSED,5
          TRIANG(IEXT)= WORK(KOPY)
          IEXT= IEXT+1
  500   CONTINUE
        RSCALE(NUSED)= WEIGHT
C
  100 CONTINUE
C
C          <IREPLY> IS SET TO 1 IF LESS THAN 4 DATA POINTS
C          WERE USED OR IF THE DATA POINTS ARE SUCH THAT
C          THE MATRIX OF EQUATIONS IS SINGULAR (EG. IF THE
C          POINTS ALL LIE ALONG ONE OR TWO STRAIGHT LINES).
C
      IREPLY= 1
      IF (NUSED.LT.4)               RETURN
      IF (ABS(TRIANG(13)).LT.CRMIN) RETURN
C
C          SOLUTION OF THE EQUATIONS YIELDS THE C-COEFFICIENTS.
C          THE RETURNED VALUE IS SET TO THAT OF COEFFICIENT C4.
C
      IREPLY= 0
      VALUE= TRIANG(14)/TRIANG(13)
C
      RETURN
      END
      SUBROUTINE INTRP2(XPOSNS,YPOSNS,ZPOSNS,NPNTS,XPOS,YPOS,
     &                  RADIUS,TOL,VALUE,IREPLY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 130)   VERSION (A8.2)    24:NOV:86
C          ------------------------------------------------
C
C          THIS ESTIMATES THE HEIGHT AT A GIVEN POINT OF A SURFACE
C          DEFINED BY A SET OF HEIGHTS AT ARBITRARY X-Y POSITIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XPOSNS] THE SET OF SURFACE POINT X-COORDINATES,
C          [YPOSNS] THE SET OF SURFACE POINT Y-COORDINATES,
C          [ZPOSNS] THE SET OF SURFACE POINT Z-COORDINATES,
C          <NPNTS>  THE NUMBER OF DATA POINTS PROVIDED (AND THE
C                   MIN. SIZE OF EACH OF THE PRECEDING ARRAYS),
C          <XPOS>   THE INTERPOLATION POINT X-COORDINATE,
C          <YPOS>   THE INTERPOLATION POINT Y-COORDINATE,
C          <RADIUS> THE RADIUS OF ACCEPTANCE OF DATA POINTS,
C          <TOL>    THE CAPTURE RADIUS OF A SINGLE DATA POINT,
C          <VALUE>  THE (RETURNED) ESTIMATED HEIGHT VALUE,
C          <IREPLY> THE (RETURNED) REPLY CODE:
C                   = 0, THE INTERPOLATION VALUE IS VALID,
C                   = 1, THE INTERPOLATION WAS UNSUCCESSFUL.
C
C
C          THE HEIGHT VALUE IS INTERPOLATED USING A MEAN WEIGHTED
C          INVERSELY AS THE FOURTH POWER OF THE DISTANCE, USING
C          ONLY THOSE DATA POINTS WHOSE POSITION IS WITHIN THE
C          ACCEPTANCE RADIUS OF THE INTERPOLATION POINT. HOWEVER,
C          IF A DATA POINT IS FOUND WHICH IS WITHIN THE CAPTURE
C          RADIUS OF THE INTERPOLATION POINT, THAT HEIGHT IS USED
C          AS THE SURFACE VALUE AND NO INTERPOLATION IS ATTEMPTED.
C
C
      REAL    XPOSNS(NPNTS),YPOSNS(NPNTS),ZPOSNS(NPNTS)
C
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      SUMWTS= 0.0
      SUMHTS= 0.0
      TOLSQ= TOL*TOL
      RADSQ= RADIUS*RADIUS
C
      DO 100 ISCAN= 1,NPNTS
        XDIFF= XPOSNS(ISCAN)-XPOS
        YDIFF= YPOSNS(ISCAN)-YPOS
        DISTSQ= XDIFF*XDIFF+YDIFF*YDIFF
        IF (DISTSQ.GT.RADSQ) GO TO 100
C
        IF (DISTSQ.GT.TOLSQ) GO TO 1
        IREPLY= 0
        VALUE= ZPOSNS(ISCAN)
        RETURN
C
    1   WEIGHT= 1.0/(DISTSQ*DISTSQ)
        SUMWTS= SUMWTS+WEIGHT
        SUMHTS= SUMHTS+ZPOSNS(ISCAN)*WEIGHT
  100 CONTINUE
C
      IREPLY= 1
      IF (ABS(SUMWTS).LT.RMINI) RETURN
C
      IREPLY= 0
      VALUE= SUMHTS/SUMWTS
C
      RETURN
      END
      SUBROUTINE LINE(DX,DY)
C
C          ------------------------------------------------
C          ROUTINE NO. (  76)   VERSION (A8.4)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS AN INCREMENTAL LINE OF LENGTH (DX,DY).
C
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      IF (ABS(DX).LT.RMINI.AND.ABS(DY).LT.RMINI) RETURN
C
      X= XPLOT0+DX
      Y= YPLOT0+DY
      CALL JOIN(X,Y)
C
      RETURN
      END
      SUBROUTINE MAP(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  21)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CALLS <G0MAPS> TO SET LIN.-X, LIN.-Y MAPPING.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
C
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(7,4)
C
      MAPNUM= 1
      CALL G0MAPS(XAREA1,XAREA2,YAREA1,YAREA2)
C
      RETURN
      END
      SUBROUTINE PLOTNC(X,Y,ICHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 162)   VERSION (A7.2)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS CHARACTER NO. <ICHAR> AT POSITION <X,Y>.
C
C
      CALL POSITN(X,Y)
      CALL TYPENC(ICHAR)
      CALL SPACE(-1)
C
      RETURN
      END
      SUBROUTINE POINT(X,Y)
C
C          ------------------------------------------------
C          ROUTINE NO. (  72)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS MOVES THE PEN TO (X,Y) THEN MAKES A POINT.
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL POSITN(X,Y)
      CALL G3LINK(0,1,0,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE SECCIR(XSTART,YSTART,ANGLE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 105)   VERSION (A8.3)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS A SECTOR OF A CIRCLE WHICH IS
C          CENTRED ON THE CURRENT PLOTTING POSITION.
C
C
C          <XSTART> IS THE STARTING X-COORDINATE,
C          <YSTART> IS THE STARTING Y-COORDINATE,
C          <ANGLE>  IS THE ARC ANGLE ANTI-CLOCKWISE
C                   FROM THE STARTING POSITION.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0ACON/ ANGCON
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA(4) /1.0/, IDATA /0/
C
C
      RTRAC1= XSTART
      RTRAC2= YSTART
      RTRAC3= ANGLE
      IF (IPRINT.EQ.1) CALL G0MESG(134,3)
C
      RDATA(1)= XSTART-XPLOT0
      RDATA(2)= YSTART-YPLOT0
      ANG= ANGLE*ANGCON
      RDATA(3)= ANG
C
      XC= XPLOT0
      YC= YPLOT0
C
C          CORRECTION IS MADE FOR DIFFERENT
C          SCALING ON THE X AND Y AXES.
C
      YSCALE= (X2MAP0-X1MAP0)/(Y2MAP0-Y1MAP0)
      XE= XPLOT0+(XSTART-XPLOT0)*COS(ANG)
     &    -(YSTART-YPLOT0)*SIN(ANG)*YSCALE
      YE= YPLOT0+(XSTART-XPLOT0)*SIN(ANG)/YSCALE
     &    +(YSTART-YPLOT0)*COS(ANG)
C
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XC,YC)
      CALL JOIN(XSTART,YSTART)
      CALL POSITN(XC,YC)
      CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
      CALL POSITN(XE,YE)
      CALL JOIN(XC,YC)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) RETURN
C
    1 CALL POSITN(XC,YC)
      CALL JOIN(XSTART,YSTART)
      CALL POSITN(XC,YC)
      CALL G3LINK(0,9,4*NBYTR,IDATA,RDATA)
      CALL POSITN(XE,YE)
      CALL JOIN(XC,YC)
C
      RETURN
      END
      SUBROUTINE TYPEST(PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 170)   VERSION (A8.5)    12:SEP:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING STORED IN <PHRASE>
C          WITH THE LEFTMOST CHARACTER PLACED AT THE CURRENT
C          CHAR. POSITION. TEXT MAY ALSO BE IN NUMBERED-CHARACTER
C          FORM, AND COMMAND STRINGS MAY BE EMBEDDED IN THE TEXT.
C
C          THIS VERSION IS SUITABLE FOR ANY TYPE OF CHAR. CODING.
C
C
      REAL      RARG(9),RDATA(1)
      INTEGER   ICODE(2,12),IDATA(255),IARG(10),ICOMND(2)
      LOGICAL   ERRON
      LOGICAL   SHOW,CHANGD,END,UPPER,LOWER,NUMBRD
      CHARACTER PHRASE*(*)
C
      COMMON /T0COMS/ NOWCOM,NOWNUM
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3MACR/ NMCHR
C
C          THE COMMANDS HELD IN [ICODE] ARE:
C
C          BC, FO, IT, LC, MA, NO,
C          OB, RE, SF, SP, UC, UL.
C
      DATA ICODE /66,67, 70,79, 73,84, 76,67, 77,65, 78,79,
     &            79,66, 82,69, 83,70, 83,80, 85,67, 85,76/,
     &     RDATA /0.0/
C
C
      LOWER= .FALSE.
      UPPER= .FALSE.
      NUMBRD= .FALSE.
      END= .FALSE.
      CHANGD= .FALSE.
      SHOW= .FALSE.
C
      NCHRS= LEN(PHRASE)
      IF (NCHRS.GE.255) GO TO 901
C
C          THE MACHINE CHARACTERS ARE COPIED AND
C          CONVERTED INTO UNPACKED GHOST CHARACTERS.
C
    1 DO 100 KCHAR= 1,NCHRS
        NCHAR= ICHAR(PHRASE(KCHAR:KCHAR))
        CALL G4COCO(NCHAR,IDATA(KCHAR))
  100 CONTINUE
C
C          THIS SECTION OUTPUTS CHARACTERS UNTIL A CONTROL SEQUENCE
C          OR THE END OF THE STRING IS FOUND. IT DETECTS NUMBERED-
C          CHARACTER SEQUENCES AND TRANSLATES CHARACTERS AS NECESSARY.
C
      IHERE= 0
      LIMIT= 0
    2   IHERE= IHERE+1
        IF (IHERE.GT.NCHRS) GO TO 18
C
        KCHAR= IDATA(IHERE)
C
C          IF AN ERROR CONDITION EXISTS THE REMAINING TEXT IS PRINTED.
C
        IF (SHOW) GO TO 9
C
C          A SINGLE COMMAND SWITCH-CHARACTER SETS COMMAND MODE;
C          A PAIR IS TREATED AS A SINGLE PRINTING CHARACTER.
C
        IF (KCHAR.NE.NOWCOM) GO TO 3
C
        IHERE= IHERE+1
        KCHAR= IDATA(IHERE)
        IF (KCHAR.EQ.NOWCOM) GO TO 9
        GO TO 10
C
C          IF A SWITCH-CHARACTER FOR NUMBERED-CHARACTER MODE IS FOUND,
C          IF NUMBERED-CHARACTER MODE IS SET, THIS IS DISABLED. IF IT
C          IS NOT SET, THE NEXT CHARACTER IS EXAMINED TO SEE IF THERE
C          IS A PAIR, WHICH IS TREATED AS A SINGLE PRINTING CHARACTER.
C          IF THE END OF THE STRING IS ENCOUNTERED, NO MORE IS DONE.
C
    3   IF (KCHAR.NE.NOWNUM) GO TO 5
        IF (NUMBRD) GO TO 4
C
        IHERE= IHERE+1
        IF (IHERE.GT.NCHRS) GO TO 18
C
        KCHAR= IDATA(IHERE)
        IF (KCHAR.EQ.NOWNUM) GO TO 5
C
        IHERE= IHERE-1
   4    NUMBRD= .NOT.NUMBRD
        GO TO 2
C
C          IN NUMBERED-CHARACTER MODE, DIGIT STRINGS ARE CONVERTED,
C          BUT ANY SEPARATORS (EXCLUDING CHARACTERS) ARE IGNORED.
C          AN ERROR EXISTS IF THE DIGIT VALUE IS GREATER THAN 255.
C
    5   IF (SHOW)        GO TO 9
        IF (.NOT.NUMBRD) GO TO 7
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,-2,IPOSS)
        IF (IPOSS.LE.0) IPOSS= NCHRS+1
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+2,IPOSN)
        IF (IPOSN.LE.0) IPOSN= NCHRS+1
        IF (IPOSS.LT.IPOSN) GO TO 6
C
        CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
        IF (IVALUE.LT.0) IVALUE= IVALUE+1
        IF (IVALUE.GT.255) GO TO 902
C
        KCHAR= MOD(IABS(IVALUE),256)
        IHERE= IPOSN-1
        IF (IHERE.LT.0) IHERE= NCHRS
        GO TO 9
C
    6   CALL G4NEXC(IDATA,IPOSS,IPOSS,NCHRS,+3,IPOSN)
        IF (IPOSN.NE.0) GO TO 902
        GO TO 2
C
C          IF (UPPER -> LOWER) OR (LOWER -> UPPER) CASE CONVERSION
C          IS SET, THE CHARACTER CODE IS ADJUSTED BEFORE COPYING.
C
    7   IF (.NOT.LOWER)   GO TO 8
        IF (KCHAR.LT. 65) GO TO 9
        IF (KCHAR.GT. 90) GO TO 9
C
        KCHAR= KCHAR+32
        GO TO 9
C
    8   IF (.NOT.UPPER)   GO TO 9
        IF (KCHAR.LT. 97) GO TO 9
        IF (KCHAR.GT.122) GO TO 9
C
        KCHAR= KCHAR-32
    9   LIMIT= LIMIT+1
        IDATA(LIMIT)= KCHAR
        GO TO 2
C
C          THIS SECTION IS ENTERED WHEN A SINGLE SWITCH-CHARACTER IS
C          ENCOUNTERED IN NORMAL MODE. THE INPUT CHARS. ARE DECODED
C          AS COMMANDS UNTIL ANOTHER SINGLE SWITCH-CHARACTER IS FOUND.
C
C          WHEN COMMAND MODE IS FIRST ENTERED, THE CHARACTER BUFFER
C          IS WRITTEN, AND ALL THE CHARACTER CONDITIONS ARE FOUND
C          VIA <ENQCHR> AND STORED. <CHANGD> IS SET TO ENSURE THAT
C          THESE CONDITIONS ARE CORRECTLY RESET AT SUBROUTINE EXIT.
C
   10   IF (LIMIT.LE.0) GO TO 11
C
        CALL G3LINK(2,11,-LIMIT,IDATA,RDATA)
        LIMIT= 0
   11   IF (CHANGD) GO TO 12
C
        CHANGD= .TRUE.
        CALL ENQCHR(IARG,RARG)
        MLEVEL= 0
C
C          IF END-OF-BUFFER IS ENCOUNTERED DURING COMMAND MODE,
C          INITIAL CONDITIONS ARE RESET AND THE SUBROUTINE ENDS.
C          IF A SWITCH CHARACTER IS FOUND, NORMAL MODE IS RESET.
C          AN ERROR EXISTS IF IT IS A NUMBERED-CHARACTER SWITCH.
C
C          THE FIRST CALL TO <G4NEXC> FINDS THE POSITION OF THE
C          FIRST SUBSEQUENT SEPARATOR CHARACTER, AND THE SECOND
C          CALL GETS THE POSITION OF THE NEXT NON-SEPARATOR. IF
C          THERE ARE MULTIPLE SEPARATORS, THEY ARE ALL CHECKED.
C
   12   IF (IHERE.GT.NCHRS) GO TO 18
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+1,IPOSS)
        IF (IPOSS.LE.0) IPOSS= NCHRS+1
        GO TO 14
C
   13   IF (IHERE.GT.NCHRS) GO TO 18
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+1,IPOSS)
        IF (IPOSS.NE.IPOSN) GO TO 902
C
   14   CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,-1,IPOSN)
   15     IF (IPOSS.GE.IPOSN.AND.IPOSN.GT.0) GO TO 17
          IF (IDATA(IPOSS).EQ.NOWNUM)        GO TO 902
          IF (IDATA(IPOSS).EQ.NOWCOM)        GO TO 16
          IF (IPOSS.GE.NCHRS)                GO TO 18
          IPOSS= IPOSS+1
          GO TO 15
C
   16   IHERE= IPOSS
        GO TO 2
C
C          IF THERE REMAINS ONLY ONE COMMAND LETTER IN THE
C          CHAR. BUFFER, AN ERROR IS SIGNALLED; OTHERWISE
C          A COMMAND PAIR IS MADE BY ADDING THE NEXT LETTER.
C
   17 IF (IPOSN.GE.NCHRS) GO TO 902
C
      KCHAR= IDATA(IPOSN)
      IF (KCHAR.GE.97.AND.KCHAR.LE.122) KCHAR= KCHAR-32
C
      ICOMND(1)= KCHAR
      IPOSN= IPOSN+1
      KCHAR= IDATA(IPOSN)
      IF (KCHAR.GE.97.AND.KCHAR.LE.122) KCHAR= KCHAR-32
C
      ICOMND(2)= KCHAR
      IPOSN= IPOSN+1
C
C          THE FOLLOWING SECTION THEN SELECTS THE OPERATION (IF
C          IT EXISTS), DECODES ANY ARGUMENTS, THEN PERFORMS IT.
C
      DO 200 ITEST= 1,12
        IF (ICOMND(1).EQ.ICODE(1,ITEST).AND.
     &      ICOMND(2).EQ.ICODE(2,ITEST))
     &            GO TO (1001,1002,1003,1004,1005,1006,
     &                   1007,1008,1009,1010,1011,1012), ITEST
  200 CONTINUE
      GO TO 902
C
C          THIS SECTION IS ENTERED AT THE END TO ENSURE
C          THAT THE BUFFER HAS BEEN COMPLETELY EMPTIED.
C
   18 END= .TRUE.
      IF (LIMIT.GT.0) CALL G3LINK(2,11,-LIMIT,IDATA,RDATA)
      GO TO 1008
C
C
C          THE COMMANDS ARE AS FOLLOWS:
C
C          1) ALLOW BOTH UPPER AND LOWER CASE (BC).
C
 1001 LOWER= .FALSE.
      UPPER= .FALSE.
      GO TO 20
C
C          2) SET CHARACTER  FONT n (FOn).
C
 1002 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      IVALUE= IABS(IVALUE)
      CALL CTRFNT(IVALUE)
      GO TO 20
C
C          3) SET/REMOVE ITALIC (ITn).
C
 1003 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
      IF (IVALUE.NE.0) IVALUE= 1
C
      CALL ITALIC(IVALUE)
      GO TO 20
C
C          4) CONVERT TO LOWER CASE (LC).
C
 1004 LOWER= .TRUE.
      UPPER= .FALSE.
      GO TO 20
C
C          5) SET CHARACTER MAGNIFICATION n (MAn).
C
 1005 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      IVALUE= IABS(IVALUE)
      CALL CTRMAG(IVALUE)
      GO TO 20
C
C          6) SET 'NORMAL' CHARACTERS (NO).
C
 1006 CALL NORMAL
      MLEVEL= MLEVEL-1
      GO TO 20
C
C          7) SET CHARACTER OBLATENESS r (OBr).
C
 1007 CALL G4NEXR(IDATA,IHERE,NCHRS,NCHRS,RVALUE,LENGTH,IPOSN)
      IF (LENGTH.LE.0) GO TO 902
C
      RVALUE= ABS(RVALUE)
      CALL CTROBL(RVALUE)
      GO TO 20
C
C          8) RESET ORIGINAL CONDITIONS (RE).
C
C          (THIS IS ALWAYS ENTERED AT SUBROUTINE CLOSE).
C
 1008 IF (.NOT.CHANGD) GO TO 19
C
      UPPER= .FALSE.
      LOWER= .FALSE.
      CALL CTRFNT(IARG(1))
      IF (IARG(3).EQ.0) CALL CTRMAG(IARG(2))
      IF (IARG(3).NE.0) CALL CTRSIZ(RARG(5))
C
      CALL ITALIC(IARG(4))
      CALL UNDLIN(IARG(5))
      CALL CTROBL(RARG(6))
      IF (MLEVEL.LE.0) GO TO 19
C
      DO 300 LEVEL= 1,MLEVEL
        CALL NORMAL
  300 CONTINUE
C
      MLEVEL= 0
   19 IF (END) RETURN
      GO TO 20
C
C          9) SET SUFFIX CHARACTERS (SF).
C
 1009 CALL SUFFIX
      MLEVEL= MLEVEL+1
      GO TO 20
C
C          10) SET SUPERFIX CHARACTERS (SP).
C
 1010 CALL SUPFIX
      MLEVEL= MLEVEL+1
      GO TO 20
C
C          11) CONVERT TO UPPER CASE (UC).
C
 1011 UPPER= .TRUE.
      LOWER= .FALSE.
      GO TO 20
C
C          12) SET n UNDERLINES (ULn).
C
 1012 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      IVALUE= IABS(IVALUE)
      IF (IVALUE.GT.2) IVALUE= 2
C
      CALL UNDLIN(IVALUE)
C
C          THIS SECTION UPDATES THE READ POSITION
C          DURING THE PROCESSING OF COMMAND-STRINGS.
C
   20 IF (IPOSN.LE.0) IPOSN= NCHRS+1
C
      IHERE= IPOSN
      GO TO 13
C
C          THE FOLLOWING ARE THE ERROR SECTIONS:
C
  901 NUMERR= 18
      IF (ERRON) CALL G0ERMS
C
      NCHRS= 255
      GO TO 1
C
  902 NUMERR= 20
      IF (ERRON) CALL G0ERMS
C
      KCHAR= IDATA(IHERE)
      SHOW= .TRUE.
      GO TO 9
C
      END
      SUBROUTINE VCHTKY(XFIRST,XLAST,YFIRST,YLAST,LABELS,NLABLS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 117)   VERSION (A8.1)    25:JUN:87
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS A CHART KEY VERTICALLY.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XFIRST,YFIRST> IS THE START CORNER, AND
C          <XLAST,YLAST>   IS THE FINISH CORNER OF THE KEY AREA.
C          [LABELS]   CONTAINS THE LABELS TO BE WRITTEN
C                     IN THE MENU BOXES.
C          <NLABLS>   IS THE NUMBER OF LABELS.
C
C
      CHARACTER LABELS(NLABLS)*(*)
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0KLAB/ LABCL0(100),LENLAB
      COMMON /T0KLST/ LSTCL0(100),LENLST
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(163,0)
      IF (NLABLS.LE.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      XSAVE= XPLOT0
      YSAVE= YPLOT0
      KOLSAV= KOLFL0
      KOLLSV= KOLIN0
      MAGSAV= MAGN0
      KOLIND= 1
      KOLLIN= 1
      NCHARS= LEN(LABELS(1))
      YINT= (YLAST-YFIRST)/NLABLS
      YSTART= YFIRST
      YEND= YFIRST+YINT
      YSIZE= ABS(YINT)*0.65
      XSIZE= ABS((XLAST-XFIRST)*(Y2MAP0-Y1MAP0)*1.167/
     &          ((NCHARS+1)*OBLAT0*(X2MAP0-X1MAP0)))
      SIZE= AMIN1(XSIZE,YSIZE)
      XCEN= (XFIRST+XLAST)*0.5
      CALL CTRSIZ(SIZE)
C
      DO 100 NBOX= 1,NLABLS
        IF (LENLST.LE.0) GO TO 1
C
        KOLFL0= LSTCL0(KOLIND)
        KOLIND= KOLIND+1
        IF(KOLIND.GT.LENLST) KOLIND= 1
C
    1   CALL BOX(XFIRST,XLAST,YEND,YSTART)
        IF (LENLAB.GT.0) CALL LINCOL(LABCL0(KOLLIN))
C
        KOLLIN= KOLLIN+1
        IF (KOLLIN.GT.LENLAB) KOLLIN= 1
C
        YCEN= (YSTART+YEND)*0.5-SIZE*0.2143
        CALL PCSCEN(XCEN,YCEN,LABELS(NBOX))
        CALL LINCOL(KOLLSV)
        YSTART= YEND
        YEND= YEND+YINT
  100 CONTINUE
C
      KOLFL0= KOLSAV
      CALL CTRMAG(MAGSAV)
      CALL POSITN(XSAVE,YSAVE)
      IPRINT= IPRSAV
      RETURN
      END
      SUBROUTINE WINFOL
C
C          ------------------------------------------------
C          ROUTINE NO. (  39)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS REPLACES THE WINDOW BY THE MAP AREA.
C
C
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0TRAC/ IPRINT
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(126,0)
C
      IF (MRKWIN.EQ.0) RETURN
      CALL WINDOW(X1MAPV,X2MAPV,Y1MAPV,Y2MAPV)
      MRKWIN= 0
C
      RETURN
      END
      SUBROUTINE G0CFL1(XA,XB,XC,YA,YB,YC,VA,VB,VC,CLEVLS,ISTRTL,ISTOPL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 185)   VERSION (A8.1)    24:APR:91
C          ------------------------------------------------
C
      REAL CLEVLS(ISTOPL)
C
      DATA DUM /0.0/
C
C
      CALL G0CFL4(VA,VB,CLEVLS,ISTRTL,ISTOPL,NAB)
      CALL G0CFL4(VB,VC,CLEVLS,ISTRTL,ISTOPL,NBC)
      CALL G0CFL4(VC,VA,CLEVLS,ISTRTL,ISTOPL,NCA)
      IF (NAB.NE.0.OR.NBC.NE.0.OR.NCA.NE.0) GO TO 1
C
C          SECTION 1: WHERE NO CONTOUR CROSSES THE TRIANGLE
C
C          FIND THE COLOUR TO USE
C
      INDCL= 1
      VLO= AMIN1(VA,VB,VC)
C
      DO 100 I= ISTRTL,ISTOPL
        IF (VLO.GT.CLEVLS(I)) INDCL= INDCL+1
  100 CONTINUE
C
C          FILL THE TRIANGLE
C
      CALL G0CFL5(INDCL,3,XA,XB,XC,DUM,DUM,YA,YB,YC,DUM,DUM)
      RETURN
C
C          SECTION 2: WHERE CONTOUR LINES CROSS TWO SIDES OF THE TRIANGLE
C
    1 IF (NBC.EQ.0) GO TO 2
      IF (NCA.EQ.0) GO TO 3
      IF (NAB.EQ.0) GO TO 4
      GO TO 5
C
    2 NQUADS= MAX0(NCA,NAB)
      CALL G0CFL2(XB,XC,XA,YB,YC,YA,VB,VC,VA,
     &            CLEVLS,ISTRTL,ISTOPL,NQUADS)
      RETURN
C
    3 NQUADS= MAX0(NAB,NBC)
      CALL G0CFL2(XC,XA,XB,YC,YA,YB,VC,VA,VB,
     &            CLEVLS,ISTRTL,ISTOPL,NQUADS)
      RETURN
C
    4 NQUADS= MAX0(NBC,NCA)
      CALL G0CFL2(XA,XB,XC,YA,YB,YC,VA,VB,VC,
     &            CLEVLS,ISTRTL,ISTOPL,NQUADS)
      RETURN
C
C          SECTION 3: WHERE CONTOUR LINES CROSS ALL THREE SIDES OF A TRIANGLE
C
    5 NNAB= NAB-1
      NNBC= NBC-1
      NNCA= NCA-1
      IF (VA.GT.VC.AND.VC.GT.VB) GO TO 6
      IF (VB.GT.VA.AND.VA.GT.VC) GO TO 7
      IF (VC.GT.VB.AND.VB.GT.VA) GO TO 8
      IF (VB.GT.VC.AND.VC.GT.VA) GO TO 9
      IF (VC.GT.VA.AND.VA.GT.VB) GO TO 10
      IF (VA.GT.VB.AND.VB.GT.VC) GO TO 11
      RETURN
C
    6 IF (NBC+NCA.NE.NAB) NNCA= NNCA+1
      CALL G0CFL3(XA,XB,XC,YA,YB,YC,VA,VB,VC,CLEVLS,ISTRTL,ISTOPL,
     &            NNBC,NNCA)
      RETURN
C
    7 IF (NCA+NAB.NE.NBC) NNAB= NNAB+1
      CALL G0CFL3(XB,XC,XA,YB,YC,YA,VB,VC,VA,CLEVLS,ISTRTL,ISTOPL,
     &            NNCA,NNAB)
      RETURN
C
    8 IF (NAB+NBC.NE.NCA) NNBC= NNBC+1
      CALL G0CFL3(XC,XA,XB,YC,YA,YB,VC,VA,VB,CLEVLS,ISTRTL,ISTOPL,
     &            NNAB,NNBC)
      RETURN
C
    9 IF (NBC+NCA.NE.NAB) NNBC= NNBC+1
      CALL G0CFL3(XB,XA,XC,YB,YA,YC,VB,VA,VC,CLEVLS,ISTRTL,ISTOPL,
     &            NNCA,NNBC)
      RETURN
C
   10 IF (NCA+NAB.LT.NBC) NNCA= NNCA+1
      CALL G0CFL3(XC,XB,XA,YC,YB,YA,VC,VB,VA,CLEVLS,ISTRTL,ISTOPL,
     &            NNAB,NNCA)
      RETURN
C
   11 IF (NAB+NBC.LT.NCA) NNAB= NNAB+1
      CALL G0CFL3(XA,XC,XB,YA,YC,YB,VA,VC,VB,CLEVLS,ISTRTL,ISTOPL,
     &            NNBC,NNAB)
      RETURN
      END
      SUBROUTINE G0CTIA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  XGRIDS,YGRIDS,IXDIRO,IYDIRO)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 126)   VERSION (A8.3)    20:OCT:86
C          ------------------------------------------------
C
C          THIS DRAWS CONTOURS OF A GIVEN LEVEL ON A 'TARTAN' GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS] IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX> IS THE LOWER X-EXTENT,
C          <ISTOPX> IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY> AND
C          <ISTOPY> ARE THE CORRESPONDING Y-BOUNDS.
C          <NPTSX>  IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>  IS THE ACTUAL ARRAY Y-EXTENT.
C          [XGRIDS] ARE THE GRID X-POSITIONS.
C          [YGRIDS] ARE THE GRID Y-POSITIONS.
C          <IXDIRO> IS THE INITIAL ENTRY-EDGE X-DIRECTION,
C          <IYDIRO> IS THE INITIAL ENTRY-EDGE Y-DIRECTION.
C
C
C          EACH MESH ELEMENT IS DIVIDED AS FOLLOWS:
C
C               A  ------------------- B
C                  |\               /|
C                  | \             / |
C                  |  \           /  |
C                  |   \         /   |
C                  |    \       /    |
C                  |     \     /     |
C                  |      \   /      |
C                  |       \ /       |
C                  |      E /        |
C                  |       / \       |
C                  |      /   \      |
C                  |     /     \     |
C                  |    /       \    |
C                  |   /         \   |
C                  |  /           \  |
C                  | /             \ |
C                  |/               \|
C               C  ------------------- D
C
C          THE CONTOUR LINE IS ALWAYS TAKEN AS ENTERING ACROSS
C          THE EDGE 'A-B', AND THE 'A-B' ORIENTATION IS ADJUSTED
C          ACCORDINGLY. THE POSSIBLE (QUADRANT) ORIENTATIONS ARE:
C
C          (AS ABOVE);    <IXDIR>= +1, <IYDIR>=  0,
C          (CLOCKWISE 1); <IXDIR>=  0, <IYDIR>= -1,
C          (CLOCKWISE 2); <IXDIR>= -1, <IYDIR>=  0,
C          (CLOCKWISE 3); <IXDIR>=  0, <IYDIR>= +1.
C
C
      REAL    SURFAS(NPTSX,NPTSY),XGRIDS(NPTSX),YGRIDS(NPTSY)
      LOGICAL OPENCO,FRSTPT,LASTPT,CURVED
      LOGICAL LEFT
C
      COMMON /T0CEND/ FRSTPT,LASTPT
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,2048),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
C
      DATA NBITSW /32/
C
C
      IX= ISTPTX
      IY= ISTPTY
      IXDIR= IXDIRO
      IYDIR= IYDIRO
      FRSTPT= .TRUE.
      LASTPT= .FALSE.
      VALA= SURFAS(IX,IY)
      IXNEW= IX+IXDIR
      IYNEW= IY+IYDIR
      VALB= SURFAS(IXNEW,IYNEW)
C
C          THE CONTOUR ALWAYS ENTERS THE ELEMENT VIA 'A-B'.
C          THE POINT WHERE THE CONTOUR CROSSES THE EDGE IS
C          DETERMINED USING INVERSE LINEAR INTERPOLATION.
C
    1 OFFSET= (VALA-HEIGHT)/(VALA-VALB)
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR)
      CALL G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,X,Y,GPOSX,GPOSY)
C
C          THIS SECTION FINDS THE END OF A CLOSED CONTOUR LINE.
C          THIS OCCURS WHEN IT IS CROSSING AN EDGE UPWARDS AND
C          THE CORRESPONDING ENTRY IN THE BIT-MAP [MAPBIT] IS
C          ZERO. IN THIS CASE <LASTPT> IS MADE 'TRUE' AND THE
C          LINE IS COMPLETED. OTHERWISE THE BIT-MAP IS UPDATED.
C
      IF (OPENCO)      GO TO 2
      IF (FRSTPT)      GO TO 4
      IF (IXDIR.NE.-1) GO TO 6
C
      IXWRD= (IX-ISTRTX-1)/NBITSW+1
      IXBIT= MOD((IX-ISTRTX-1),NBITSW)+1
      CALL G4GETB(MAPBIT(IXWRD,(IY-ISTRTY)),IXBIT,IBIT)
      IF (IBIT.NE.0) GO TO 5
      LASTPT= .TRUE.
      GO TO 6
C
C          THIS SECTION FINDS THE END OF AN OPEN CONTOUR LINE.
C          THIS OCCURS WHEN IT ARRIVES AT AN X OR Y EDGE. IF
C          AN EDGE IS FOUND, <LASTPT> IS MADE 'TRUE' AND THE
C          LINE IS COMPLETED. OTHERWISE THE BIT-MAP IS UPDATED.
C          <INOTAT> INDICATES THE DIRECTION THE CONTOUR IS
C          ENTERING THE MESH ELEMENT AND TAKES THE FOLLOWING VALUES:
C          1  FROM THE LEFT,  2  FROM THE RIGHT,
C          3  FROM THE TOP,   4  FROM THE BOTTOM.
C
    2 INOTAT= IABS(IXDIR)*(7-IXDIR)/2+IABS(IYDIR)*(3-IYDIR)/2
      IF (FRSTPT) GO TO 6
      IF (IYDIR.EQ.0) GO TO 3
      IF (IX.EQ.ISTRTX.OR.IX.EQ.ISTOPX) LASTPT= .TRUE.
      GO TO 6
    3 IF (IY.EQ.ISTRTY.OR.IY.EQ.ISTOPY) LASTPT= .TRUE.
      IF (LASTPT.OR.IXDIR.NE.-1) GO TO 6
C
C          THIS SECTION UPDATES THE BIT-MAP HELD IN [MAPBIT]
C          WHENEVER THE CONTOUR LINE CROSSES AN EDGE UPWARDS.
C
    4 IXWRD= (IX-ISTRTX-1)/NBITSW+1
      IXBIT= MOD((IX-ISTRTX-1),NBITSW)+1
    5 CALL G4PUTB(MAPBIT(IXWRD,(IY-ISTRTY)),IXBIT,0)
C
C          THE CONTOUR LINE IS UPDATED, AND A NEW ELEMENT IS
C          BEGUN IF THE CONTOUR LINE HAS NOT REACHED ITS END.
C          <FRSTPT> IS MADE 'FALSE', THE HEIGHTS AT 'C' AND
C          'D' ARE FOUND, AND THE HEIGHT AT 'E' IS CALCULATED
C          AS THE AVERAGE OF THOSE AT 'A', 'B', 'C' AND 'D'.
C          THE VALUE OF <INOTAT> IS REVERSED FOR THE LAST POINT.
C
    6 INMOD= MOD(INOTAT,2)
      IF (LASTPT.AND.INMOD.EQ.0) INOTAT= INOTAT-1
      IF (LASTPT.AND.INMOD.EQ.1) INOTAT= INOTAT+1
      IF (.NOT.OPENCO) INOTAT= 0
C
      CALL G0CPLT(GPOSX,GPOSY,INOTAT)
      IF (LASTPT) RETURN
C
      FRSTPT= .FALSE.
      INDX1= IX+IYDIR
      INDX2= INDX1+IXDIR
      INDY1= IY-IXDIR
      INDY2= INDY1+IYDIR
      VALC= SURFAS(INDX1,INDY1)
      VALD= SURFAS(INDX2,INDY2)
      VALE= 0.25*(VALA+VALB+VALC+VALD)
C
C          THE CONTOUR MUST CROSS EITHER 'A-E' OR 'B-E':
C
      IF (VALE.GE.HEIGHT) GO TO 8
C
C          THE CONTOUR CROSSES 'A-E' SO <LEFT> IS MADE 'TRUE'.
C          THE POINT WHERE THE CONTOUR CROSSES THE LINE IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE DRAWN.
C
      LEFT= .TRUE.
      OFFSET= 0.5*(VALA-HEIGHT)/(VALA-VALE)
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR+IYDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR-IXDIR)
      CALL G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,X,Y,GPOSX,GPOSY)
      CALL G0CPLT(GPOSX,GPOSY,0)
C
C          THE CONTOUR LINE THEN CROSSES 'C-E' OR EXITS VIA 'A-C'.
C
      IF (VALC.LT.HEIGHT) GO TO 10
C
C          THE CONTOUR CROSSES 'C-E'. THE INTERSECTION POINT IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE IS DRAWN.
C
    7 OFFSET= 0.5*(VALC-HEIGHT)/(VALC-VALE)
      X= FLOAT(INDX1)-OFFSET*FLOAT(IYDIR-IXDIR)
      Y= FLOAT(INDY1)+OFFSET*FLOAT(IXDIR+IYDIR)
      CALL G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,X,Y,GPOSX,GPOSY)
      CALL G0CPLT(GPOSX,GPOSY,0)
C
C          IF <LEFT> IS 'TRUE', THE CONTOUR LINE CAN EITHER EXIT
C          VIA THE EDGE 'C-D' OR CROSS THE LINE 'D-E'. IF <LEFT>
C          IS 'FALSE', THE CONTOUR LINE PASSES INTO TRIANGLE 'A-C-E'
C          AND THEN MUST EXIT FROM THE ELEMENT VIA THE EDGE 'A-C'.
C
      IF (.NOT.LEFT) GO TO 10
      IF (VALD.LT.HEIGHT) GO TO 11
      GO TO 9
C
C         THE CONTOUR CROSSES 'B-E' SO <LEFT> IS MADE 'FALSE'.
C         THE POINT WHERE THE CONTOUR CROSSES THE LINE IS FOUND
C         USING INVERSE LINEAR INTERPOLATION AND THE LINE DRAWN.
C
    8 LEFT= .FALSE.
      OFFSET= 0.5*(1.0+(VALE-HEIGHT)/(VALE-VALB))
      X= FLOAT(INDX1)-OFFSET*FLOAT(IYDIR-IXDIR)
      Y= FLOAT(INDY1)+OFFSET*FLOAT(IXDIR+IYDIR)
      CALL G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,X,Y,GPOSX,GPOSY)
      CALL G0CPLT(GPOSX,GPOSY,0)
C
C          THE CONTOUR LINE THEN CROSSES 'D-E' OR EXITS VIA 'B-D'.
C
      IF (VALD.GE.HEIGHT) GO TO 12
C
C          THE CONTOUR CROSSES 'D-E'. THE INTERSECTION POINT IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE IS DRAWN.
C
    9 OFFSET= 0.5*(1.0+(VALE-HEIGHT)/(VALE-VALD))
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR+IYDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR-IXDIR)
      CALL G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,X,Y,GPOSX,GPOSY)
      CALL G0CPLT(GPOSX,GPOSY,0)
C
C          IF <LEFT> IS 'FALSE', THE CONTOUR LINE CAN EITHER EXIT
C          VIA THE EDGE 'C-D' OR CROSS THE LINE 'C-E'. IF <LEFT>
C          IS 'TRUE', THE CONTOUR LINE PASSES INTO TRIANGLE 'B-D-E'
C          AND THEN MUST EXIT FROM THE ELEMENT VIA THE EDGE 'B-D'.
C
      IF (LEFT)      GO TO 12
      IF (VALC.LT.HEIGHT) GO TO 7
      GO TO 11
C
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'A-C'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   10 VALB= VALC
      ITEMP= IXDIR
      IXDIR= IYDIR
      IYDIR= -ITEMP
      GO TO 1
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'C-D'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   11 VALA= VALC
      VALB= VALD
      IX= INDX1
      IY= INDY1
      GO TO 1
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'B-D'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   12 VALA= VALD
      IX= INDX2
      IY= INDY2
      ITEMP= IYDIR
      IYDIR= IXDIR
      IXDIR= -ITEMP
      GO TO 1
C
      END
      SUBROUTINE G0CTRA(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  IXDIRO,IYDIRO)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 125)   VERSION (A8.3)    15:OCT:86
C          ------------------------------------------------
C
C          THIS DRAWS CONTOURS OF A GIVEN LEVEL ON A REGULAR GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [SURFAS] IS THE ARRAY OF SURFACE HEIGHT VALUES,
C          <ISTRTX> IS THE LOWER X-EXTENT,
C          <ISTOPX> IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY> AND
C          <ISTOPY> ARE THE CORRESPONDING Y-BOUNDS.
C          <NPTSX>  IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>  IS THE ACTUAL ARRAY Y-EXTENT.
C          <IXDIRO> IS THE INITIAL ENTRY-EDGE X-DIRECTION,
C          <IYDIRO> IS THE INITIAL ENTRY-EDGE Y-DIRECTION.
C
C
C          EACH MESH ELEMENT IS DIVIDED AS FOLLOWS:
C
C               A  ------------------- B
C                  |\               /|
C                  | \             / |
C                  |  \           /  |
C                  |   \         /   |
C                  |    \       /    |
C                  |     \     /     |
C                  |      \   /      |
C                  |       \ /       |
C                  |      E /        |
C                  |       / \       |
C                  |      /   \      |
C                  |     /     \     |
C                  |    /       \    |
C                  |   /         \   |
C                  |  /           \  |
C                  | /             \ |
C                  |/               \|
C               C  ------------------- D
C
C          THE CONTOUR LINE IS ALWAYS TAKEN AS ENTERING ACROSS
C          THE EDGE 'A-B', AND THE 'A-B' ORIENTATION IS ADJUSTED
C          ACCORDINGLY. THE POSSIBLE (QUADRANT) ORIENTATIONS ARE:
C
C          (AS ABOVE);    <IXDIR>= +1, <IYDIR>=  0,
C          (CLOCKWISE 1); <IXDIR>=  0, <IYDIR>= -1,
C          (CLOCKWISE 2); <IXDIR>= -1, <IYDIR>=  0,
C          (CLOCKWISE 3); <IXDIR>=  0, <IYDIR>= +1.
C
C
      REAL    SURFAS(NPTSX,NPTSY)
      LOGICAL OPENCO,FRSTPT,LASTPT,CURVED
      LOGICAL LEFT
C
      COMMON /T0CEND/ FRSTPT,LASTPT
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CMAP/ MAPBIT(6,2048),ISTPTX,ISTPTY
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0CWID/ CWIDX,CWIDY
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
      DATA NBITSW /32/
C
C          THE FOLLOWING FUNCTIONS GIVE THE ACTUAL POSITIONS:
C
      GPOSX(X)= X1WND0+(X-ISTRTX)*CWIDX
      GPOSY(Y)= Y1WND0+(Y-ISTRTY)*CWIDY
C
C
      IX= ISTPTX
      IY= ISTPTY
      IXDIR= IXDIRO
      IYDIR= IYDIRO
      FRSTPT= .TRUE.
      LASTPT= .FALSE.
      VALA= SURFAS(IX,IY)
      IXNEW= IX+IXDIR
      IYNEW= IY+IYDIR
      VALB= SURFAS(IXNEW,IYNEW)
C
C          THE CONTOUR ALWAYS ENTERS THE ELEMENT VIA 'A-B'.
C          THE POINT WHERE THE CONTOUR CROSSES THE EDGE IS
C          DETERMINED USING INVERSE LINEAR INTERPOLATION.
C
    1 OFFSET= (VALA-HEIGHT)/(VALA-VALB)
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR)
C
C          THIS SECTION FINDS THE END OF A CLOSED CONTOUR LINE.
C          THIS OCCURS WHEN IT IS CROSSING AN EDGE UPWARDS AND
C          THE CORRESPONDING ENTRY IN THE BIT-MAP [MAPBIT] IS
C          ZERO. IN THIS CASE <LASTPT> IS MADE 'TRUE' AND THE
C          LINE IS COMPLETED. OTHERWISE THE BIT-MAP IS UPDATED.
C
      IF (OPENCO)      GO TO 2
      IF (FRSTPT)      GO TO 4
      IF (IXDIR.NE.-1) GO TO 6
C
      IXWRD= (IX-ISTRTX-1)/NBITSW+1
      IXBIT= MOD((IX-ISTRTX-1),NBITSW)+1
      CALL G4GETB(MAPBIT(IXWRD,(IY-ISTRTY)),IXBIT,IBIT)
      IF (IBIT.NE.0) GO TO 5
      LASTPT= .TRUE.
      GO TO 6
C
C          THIS SECTION FINDS THE END OF AN OPEN CONTOUR LINE.
C          THIS OCCURS WHEN IT ARRIVES AT AN X OR Y EDGE. IF
C          AN EDGE IS FOUND, <LASTPT> IS MADE 'TRUE' AND THE
C          LINE IS COMPLETED. OTHERWISE THE BIT-MAP IS UPDATED.
C          <INOTAT> INDICATES THE DIRECTION THE CONTOUR IS
C          ENTERING THE MESH ELEMENT AND TAKES THE FOLLOWING VALUES:
C          1  FROM THE LEFT,  2  FROM THE RIGHT,
C          3  FROM THE TOP,   4  FROM THE BOTTOM.
C
    2 INOTAT= IABS(IXDIR)*(7-IXDIR)/2+IABS(IYDIR)*(3-IYDIR)/2
      IF (FRSTPT) GO TO 6
      IF (IYDIR.EQ.0) GO TO 3
      IF (IX.EQ.ISTRTX.OR.IX.EQ.ISTOPX) LASTPT= .TRUE.
      GO TO 6
    3 IF (IY.EQ.ISTRTY.OR.IY.EQ.ISTOPY) LASTPT= .TRUE.
      IF (LASTPT.OR.IXDIR.NE.-1) GO TO 6
C
C          THIS SECTION UPDATES THE BIT-MAP HELD IN [MAPBIT]
C          WHENEVER THE CONTOUR LINE CROSSES AN EDGE UPWARDS.
C
    4 IXWRD= (IX-ISTRTX-1)/NBITSW+1
      IXBIT= MOD((IX-ISTRTX-1),NBITSW)+1
    5 CALL G4PUTB(MAPBIT(IXWRD,(IY-ISTRTY)),IXBIT,0)
C
C          THE CONTOUR LINE IS UPDATED, AND A NEW ELEMENT IS
C          BEGUN IF THE CONTOUR LINE HAS NOT REACHED ITS END.
C          <FRSTPT> IS MADE 'FALSE', THE HEIGHTS AT 'C' AND
C          'D' ARE FOUND, AND THE HEIGHT AT 'E' IS CALCULATED
C          AS THE AVERAGE OF THOSE AT 'A', 'B', 'C' AND 'D'.
C          THE VALUE OF <INOTAT> IS REVERSED FOR THE LAST POINT.
C
    6 INMOD= MOD(INOTAT,2)
      IF (LASTPT.AND.INMOD.EQ.0) INOTAT= INOTAT-1
      IF (LASTPT.AND.INMOD.EQ.1) INOTAT= INOTAT+1
      IF (.NOT.OPENCO) INOTAT= 0
C
      CALL G0CPLT(GPOSX(X),GPOSY(Y),INOTAT)
      IF (LASTPT) RETURN
C
      FRSTPT= .FALSE.
      INDX1= IX+IYDIR
      INDX2= INDX1+IXDIR
      INDY1= IY-IXDIR
      INDY2= INDY1+IYDIR
      VALC= SURFAS(INDX1,INDY1)
      VALD= SURFAS(INDX2,INDY2)
      VALE= 0.25*(VALA+VALB+VALC+VALD)
C
C          THE CONTOUR MUST CROSS EITHER 'A-E' OR 'B-E':
C
      IF (VALE.GE.HEIGHT) GO TO 8
C
C          THE CONTOUR CROSSES 'A-E' SO <LEFT> IS MADE 'TRUE'.
C          THE POINT WHERE THE CONTOUR CROSSES THE LINE IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE DRAWN.
C
      LEFT= .TRUE.
      OFFSET= 0.5*(VALA-HEIGHT)/(VALA-VALE)
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR+IYDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR-IXDIR)
      CALL G0CPLT(GPOSX(X),GPOSY(Y),0)
C
C          THE CONTOUR LINE THEN CROSSES 'C-E' OR EXITS VIA 'A-C'.
C
      IF (VALC.LT.HEIGHT) GO TO 10
C
C          THE CONTOUR CROSSES 'C-E'. THE INTERSECTION POINT IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE IS DRAWN.
C
    7 OFFSET= 0.5*(VALC-HEIGHT)/(VALC-VALE)
      X= FLOAT(INDX1)-OFFSET*FLOAT(IYDIR-IXDIR)
      Y= FLOAT(INDY1)+OFFSET*FLOAT(IXDIR+IYDIR)
      CALL G0CPLT(GPOSX(X),GPOSY(Y),0)
C
C          IF <LEFT> IS 'TRUE', THE CONTOUR LINE CAN EITHER EXIT
C          VIA THE EDGE 'C-D' OR CROSS THE LINE 'D-E'. IF <LEFT>
C          IS 'FALSE', THE CONTOUR LINE PASSES INTO TRIANGLE 'A-C-E'
C          AND THEN MUST EXIT FROM THE ELEMENT VIA THE EDGE 'A-C'.
C
      IF (.NOT.LEFT) GO TO 10
      IF (VALD.LT.HEIGHT) GO TO 11
      GO TO 9
C
C         THE CONTOUR CROSSES 'B-E' SO <LEFT> IS MADE 'FALSE'.
C         THE POINT WHERE THE CONTOUR CROSSES THE LINE IS FOUND
C         USING INVERSE LINEAR INTERPOLATION AND THE LINE DRAWN.
C
    8 LEFT= .FALSE.
      OFFSET= 0.5*(1.0+(VALE-HEIGHT)/(VALE-VALB))
      X= FLOAT(INDX1)-OFFSET*FLOAT(IYDIR-IXDIR)
      Y= FLOAT(INDY1)+OFFSET*FLOAT(IXDIR+IYDIR)
      CALL G0CPLT(GPOSX(X),GPOSY(Y),0)
C
C          THE CONTOUR LINE THEN CROSSES 'D-E' OR EXITS VIA 'B-D'.
C
      IF (VALD.GE.HEIGHT) GO TO 12
C
C          THE CONTOUR CROSSES 'D-E'. THE INTERSECTION POINT IS FOUND
C          USING INVERSE LINEAR INTERPOLATION AND THE LINE IS DRAWN.
C
    9 OFFSET= 0.5*(1.0+(VALE-HEIGHT)/(VALE-VALD))
      X= FLOAT(IX)+OFFSET*FLOAT(IXDIR+IYDIR)
      Y= FLOAT(IY)+OFFSET*FLOAT(IYDIR-IXDIR)
      CALL G0CPLT(GPOSX(X),GPOSY(Y),0)
C
C          IF <LEFT> IS 'FALSE', THE CONTOUR LINE CAN EITHER EXIT
C          VIA THE EDGE 'C-D' OR CROSS THE LINE 'C-E'. IF <LEFT>
C          IS 'TRUE', THE CONTOUR LINE PASSES INTO TRIANGLE 'B-D-E'
C          AND THEN MUST EXIT FROM THE ELEMENT VIA THE EDGE 'B-D'.
C
      IF (LEFT)      GO TO 12
      IF (VALC.LT.HEIGHT) GO TO 7
      GO TO 11
C
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'A-C'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   10 VALB= VALC
      ITEMP= IXDIR
      IXDIR= IYDIR
      IYDIR= -ITEMP
      GO TO 1
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'C-D'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   11 VALA= VALC
      VALB= VALD
      IX= INDX1
      IY= INDY1
      GO TO 1
C
C          THE CONTOUR LINE EXITS VIA THE EDGE 'B-D'.
C          VALUES ARE UPDATED AND THE CONTOUR CONTINUED.
C
   12 VALA= VALD
      IX= INDX2
      IY= INDY2
      ITEMP= IYDIR
      IYDIR= IXDIR
      IXDIR= -ITEMP
      GO TO 1
C
      END
      SUBROUTINE G0DIVL(IAXIS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 236)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS FINDS THE POSITIONS OF THE INTERVALS ON THE GIVEN AXIS
C          (FOR LOG. SCALING) WHICH LIE WITHIN THE CURRENT WINDOW AREA.
C
C
C          <IAXIS>  GIVES THE REQUIRED AXIS BY ITS MODULUS:
C                   = 1, THE X-AXIS IS TAKEN, OR
C                   = 2, THE Y-AXIS IS TAKEN.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <X1WND0>    THE COORDINATES
C          <X2WND0>    OF
C          <Y1WND0>    THE
C          <Y2WND0>    WINDOW RECTANGLE.
C
C          <AXPOSX> THE POSITION OF THE X-AXIS ALONG Y.
C          <AXPOSY> THE POSITION OF THE Y-AXIS ALONG X.
C          <NOTATE> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOT. FORMAT MUST BE CALCULATED.
C
C
C          THE FOLLOWING ARGUMENTS ARE RETURNED THROUGH COMMON:
C          (ONLY THE ARGS. RELEVANT TO THE GIVEN AXIS ARE CHANGED):
C
C          <KTYPEX> IS THE X-AXIS TYPE (= 2 FOR LOG. AXIS).
C          <KTYPEY> IS THE Y-AXIS TYPE (= 2 FOR LOG. AXIS).
C          <DIVLX>  GIVES THE X-AXIS SIGN.
C          <DIVLY>  GIVES THE Y-AXIS SIGN.
C          <NSKIPX> IS THE X-AXIS START-POINT EXPONENT.
C          <NSKIPY> IS THE Y-AXIS START-POINT EXPONENT.
C          <NTIKLX> IS THE X-AXIS START-POINT MANTISSA.
C          <NTIKLY> IS THE Y-AXIS START-POINT MANTISSA.
C          <NTIKHX> IS THE NO. OF X-AXIS TICK MARKS.
C          <NTIKHY> IS THE NO. OF Y-AXIS TICK MARKS.
C          <NDECSX> IS THE NO. OF DECADE MARKS ON THE X-AXIS.
C          <NDECSY> IS THE NO. OF DECADE MARKS ON THE Y-AXIS.
C          <NCHRSX> IS THE NO. OF CHARS. IN X-AXIS ANNOTATION.
C          <NCHRSY> IS THE NO. OF CHARS. IN Y-AXIS ANNOTATION.
C          <KAXIS>  IS SET BY <IAXIS> FOR SUBSEQUENT USE.
C
C
      LOGICAL ERRON
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOX/ KANNX,NCHRSX,NAFTPX
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATYP/ KTYPEX,KTYPEY
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
C
C
C          THE AXIS TYPE IS SET, THE SIGN OF THE AXIS REGION IS
C          FOUND, AND THE END POINTS ARE APPROPRIATELY SET.
C
      KAXIS= IAXIS
C
      ENDMIN= AMIN1(X1WND0,X2WND0)
      ENDMAX= AMAX1(X1WND0,X2WND0)
      IF (IABS(KAXIS).EQ.1) GO TO 1
      ENDMIN= AMIN1(Y1WND0,Y2WND0)
      ENDMAX= AMAX1(Y1WND0,Y2WND0)
C
    1 AXSIGN= +1.0
      IF (ENDMIN.GT.0.0) GO TO 2
      AXSIGN= -1.0
      SWOP=   ABS(ENDMIN)
      ENDMIN= ABS(ENDMAX)
      ENDMAX= SWOP
C
C          THE START-POINT EXPONENT AND MANTISSA ARE FOUND.
C          THE SECOND SECTION ALLOWS FOR ROUNDING ERRORS.
C
    2 EXP= ALOG10(ENDMIN)
      IF (EXP.LT.0.0) EXP= EXP-1.0
      IDEC1= EXP
      TIKPT= ENDMIN*(10.0**(-IDEC1))
      ITIK1= TIKPT+0.99999
C
      IF (ITIK1.LT.10) GO TO 3
      ITIK1= 1
      IDEC1= IDEC1+1
      GO TO 4
    3 IF (ITIK1.GE.1) GO TO 4
      ITIK1= 9
      IDEC1= IDEC1-1
C
C          THE SAME IS THEN DONE FOR THE END-POINT VALUES.
C
    4 EXP= ALOG10(ENDMAX)
      IF (EXP.LT.0.0) EXP= EXP-1.0
      IDEC2= EXP
      TIKPT= ENDMAX*(10.0**(-IDEC2))
      ITIK2= TIKPT+0.00001
C
      IF (ITIK2.LT.10) GO TO 5
      ITIK2= 1
      IDEC2= IDEC2+1
      GO TO 6
    5 IF (ITIK2.GE.1) GO TO 6
      ITIK2= 9
      IDEC2= IDEC2-1
C
C          THE NO. OF TICK AND DECADE MARKS CAN THEN BE CALCULATED.
C
    6 NDECS= IDEC2-IDEC1
      IF (NDECS.GT.20) GO TO 901
      NTICKS= 9*NDECS+(ITIK2-ITIK1)+1
      IF (ITIK1.EQ.1) NDECS= NDECS+1
C
C          THE NO. OF CHARS. IN THE ANNOTATION FORMAT IS FOUND
C          WHEN THE VALUES WILL BE PRINTED IN NON-EXPONENT FORM.
C
      NCHARS= 2
      IF (NTICKS.GT.10)   GO TO 7
      NCHARS= IDEC2+2
      IF (IDEC1.GE.0)     GO TO 7
      NCHARS= 3-IDEC1
      IF (IDEC1.EQ.IDEC2) GO TO 7
      NCHARS= NCHARS+1
C
C          ONCE THE VALUES HAVE BEEN FOUND, THEY ARE PLACED
C          INTO THE APPROPRIATE VARIABLES IN THE COMMON BLOCK.
C
    7 IF (IABS(KAXIS).EQ.2) GO TO 8
      KTYPEX= 2
      NTIKLX= ITIK1
      NSKIPX= IDEC1
      NTIKHX= NTICKS
      NDECSX= NDECS
      DIVLX= AXSIGN
      NCHRSX= NCHARS
      RETURN
C
    8 KTYPEY= 2
      NTIKLY= ITIK1
      NSKIPY= IDEC1
      NTIKHY= NTICKS
      NDECSY= NDECS
      DIVLY= AXSIGN
      NCHRSY= NCHARS
      RETURN
C
C          IF MORE THAN 20 CYCLES IS NECESSARY, AN ERROR
C          MESSAGE IS PRINTED AND THE MARKING IS SUPPRESSED.
C
  901 NUMERR= 32
      IF (ERRON) CALL G0ERMS
      IF (IABS(KAXIS).EQ.1) NTIKHX= 0
      IF (IABS(KAXIS).EQ.2) NTIKHY= 0
      RETURN
      END
      SUBROUTINE G0FRAM
C
C          ------------------------------------------------
C          ROUTINE NO. (  19)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS VERSION HAS THE SAME EFFECT AS <FRAME>.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
C
      COMMON /T0BUFN/ KBUFR0
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T2INLO/ LNFOFO,LNFOPO
      COMMON /T2OPNL/ LNFILN,LNPICN
C
      DATA RDATA /0.0/, IDATA /0/
C
C
      CALL G3INIT(2)
C
      IF (IPRINT.EQ.1) CALL G0MESG(4,0)
C
C          THE NEW PICTURE IS BEGUN, THE CURRENT PLOTTING POSITION IS
C          REPOSITIONED AT THE LOWER-LEFT CORNER OF THE CURRENT MAP,
C          AND THE CURRENT BUFFER NUMBER IS RESET TO THE SYSTEM ONE.
C          ANY EXISTING PICTURE NAME OR PIC. INFORMATION IS REMOVED.
C
      CALL G3LINK(3,3,0,IDATA,RDATA)
C
      XPLOT0= X1MAP0
      YPLOT0= Y1MAP0
      KBUFR0= 0
C
      LNPICN= 0
      LNFOPO= 0
C
      RETURN
      END
      SUBROUTINE G0MAPP(XVECT,YVECT,XNORM,YNORM)
C
C          ------------------------------------------------
C          ROUTINE NO. (  45)   VERSION (A8.2)    25:NOV:86
C          ------------------------------------------------
C
C          THIS MAPS THE POINT <XVECT,YVECT> IN VECTOR SPACE
C          ONTO THE POINT <XNORM,YNORM> IN NORM. DEVICE SPACE.
C
C
      LOGICAL ERRON
C
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0MAPS/ ORIMX0,ORIMY0,SCAMX0,SCAMY0
      COMMON /T0MAPT/ MAPNO0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 1
C
      XNORM= (XVECT-ORIMX0)*SCAMX0
      GO TO 2
C
    1 IF (ABS(SIGN(1.0,XVECT)-SIGN(1.0,X1MAP0)).GE.RMINI) GO TO 901
C
      ABSVEC= ABS(XVECT)
      IF (ABSVEC.LT.RMINI) GO TO 901
C
      XNORM= (ALOG(ABSVEC)-ORIMX0)*SCAMX0
    2 IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 3
C
      YNORM= (YVECT-ORIMY0)*SCAMY0
      RETURN
C
    3 IF (ABS(SIGN(1.0,YVECT)-SIGN(1.0,Y1MAP0)).GE.RMINI) GO TO 901
C
      ABSVEC= ABS(YVECT)
      IF (ABSVEC.LT.RMINI) GO TO 901
C
      YNORM= (ALOG(ABSVEC)-ORIMY0)*SCAMY0
      RETURN
C
C          AN ERROR MESSAGE OCCURS WHEN AN AXIS
C          IS CROSSED UNDER LOGARITHMIC MAPPING.
C
  901 XNORM= 0.0
      YNORM= 0.0
      NUMERR= 2
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE G0OLAP
C
C          ------------------------------------------------
C          ROUTINE NO. (  45)   VERSION (A8.1)    25:NOV:86
C          ------------------------------------------------
C
C          THIS ROUTINE FINDS AND DISPOSES OF ANY OVERLAP
C          BETWEEN TWO BARS IN A THREE DIMENSIONAL BARCHART.
C
C          THE VALUES USED ARE :
C
C          [XEALIN] ARRAYS CONTAINING COORDINATES OF
C          [YEALIN] POINTS ON THE HIDDEN BAR.
C          [XCHLIN] ARRAYS CONTAINING COORDINATES OF
C          [YCHLIN] POINTS ON THE FRONT BAR.
C          [NUMLNS] THE NUMBER OF POINTS IN XCHLIN,YCHLIN.
C
      REAL    XINTS(22),YINTS(22),XEANEW(22),YEANEW(22)
      INTEGER INDICS(22),INTERS(22,2)
C
      COMMON /T0CHLN/ XEALIN(22),YEALIN(22),XCHLIN(6),YCHLIN(6),NUMLNS
      COMMON /T0INTS/ XLINE1(2),YLINE1(2),XLINE2(2),YLINE2(2)
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
C          FIND LOCATION OF POINTS ON HIDDEN BAR IN RELATION
C          TO THE LINES IN THE FRONT BAR.  IF NONE LIE WITHIN
C          THEN RETURN UNCHANGED.  IF ALL LIE ON OR WITHIN BAR
C          RETURN SETING NUMBER OF POINTS TO ZERO.
C
      IF (NUMLNS.EQ.0) RETURN
C
      KNTINS= 0
      KNTON= 0
C
      DO 100 LINNUM= 1,NUMLNS
        CALL G0INSD(XEALIN(LINNUM),YEALIN(LINNUM),INDIC)
        INDICS(LINNUM)= INDIC
        IF (INDIC.EQ.0) KNTINS= KNTINS+1
        IF (INDIC.EQ.2) KNTON= KNTON+1
  100 CONTINUE
C
      IF (KNTINS+KNTON.EQ.0) RETURN
      IF (KNTINS+KNTON.LT.NUMLNS) GO TO 1
C
      NUMLNS= 0
      RETURN
C
C          CALCULATE THE INTERSECTIONS OF LINES IN THE
C          HIDDEN BAR WITH THE FRONT BAR.
C
    1 NOINTS= 0
C
      DO 200 LINNUM= 1,NUMLNS
        LINEXT= MOD(LINNUM,NUMLNS)+1
        IF (INDICS(LINNUM).NE.1.AND.INDICS(LINEXT).NE.1) GO TO 200
C
        DO 300 IPNT= 1,6
          NXTPNT= MOD(IPNT,6)+1
          XLINE1(1)= XEALIN(LINNUM)
          YLINE1(1)= YEALIN(LINNUM)
          XLINE1(2)= XEALIN(LINEXT)
          YLINE1(2)= YEALIN(LINEXT)
          XLINE2(1)= XCHLIN(IPNT)
          YLINE2(1)= YCHLIN(IPNT)
          XLINE2(2)= XCHLIN(NXTPNT)
          YLINE2(2)= YCHLIN(NXTPNT)
          CALL G0INTR(ICODE,XINT,YINT)
C
C          NO INTERSECT ?
C
          IF (ICODE.EQ.0) GO TO 300
C
          NOINTS= NOINTS+1
          INTERS(NOINTS,1)= LINNUM
          INTERS(NOINTS,2)= IPNT
          XINTS(NOINTS)= XINT
          YINTS(NOINTS)= YINT
 300    CONTINUE
 200  CONTINUE
C
C          DISPOSE OF ONE OF DOUBLE INTERSECTIONS WHICH OCCUR
C          AT THE JOINING OF TWO LINES IN THE FRONT BAR.
C
      I= 0
    2 I= I+1
      IF (I.GT.NOINTS) GO TO 3
      IF (ABS(XINTS(I)-XINTS(MOD(I,NOINTS)+1)).GE.RMINI) GO TO 2
      IF (ABS(YINTS(I)-YINTS(MOD(I,NOINTS)+1)).GE.RMINI) GO TO 2
C
      NOINTS= NOINTS-1
C
      DO 400 J= I,NOINTS
        XINTS(J)= XINTS(J+1)
        YINTS(J)= YINTS(J+1)
        INTERS(J,1)= INTERS(J+1,1)
        INTERS(J,2)= INTERS(J+1,2)
  400 CONTINUE
C
      GO TO 2
C
C          CREATE NEW BAR USING INTERSECTIONS.
C
    3 INEWLI= 0
      ICINTP= 1
C
      DO 500 ICL= 1,NUMLNS
C
C          DOES CURRENT LINE INTERSECT ?
C
        IF (ICINTP.GT.NOINTS.OR.INTERS(ICINTP,1).NE.ICL) GO TO 12
C
C          IF SO LOCATE NEXT VALID INTERSECT.
C
        INCINP= MOD(ICINTP,NOINTS)+1
C
C          ARE CURRENT AND NEXT INTERSECT BOTH WITH SAME LINE
C          IN FRONT BAR.
C
        IF (INTERS(ICINTP,1).EQ.INTERS(INCINP,1)) GO TO 6
C
C          IF NOT ARE ALL POINTS BETWEEN HIDDEN ?
C
        IPNT= INTERS(ICINTP,1)
    4   IPNT= IPNT+1
        IF (IPNT.GT.NUMLNS) IPNT= 1
        IF (IPNT.EQ.INTERS(INCINP,1)) GO TO 6
        IF (INDICS(IPNT).EQ.1) GO TO 5
        GO TO 4
C
C          IF NOT THIS SIDE OF BAR OUTSIDE.
C
    5   ICINTP= INCINP
        GO TO 500
C
C          IF CURRENT POINT LIES OUTWITH FRONT BAR PUT IT IN
C          NEW BAR.
C
    6   IF (INDICS(INTERS(ICINTP,1)).EQ.0) GO TO 7
C
        INEWLI= INEWLI+1
        XEANEW(INEWLI)= XEALIN(ICL)
        YEANEW(INEWLI)= YEALIN(ICL)
C
C          PUT INTERSECT IN NEW BAR
C
    7   INEWLI= INEWLI+1
        XEANEW(INEWLI)= XINTS(ICINTP)
        YEANEW(INEWLI)= YINTS(ICINTP)
C
C          IF ANY POINTS FROM FRONT BAR BETWEEN INTERSECTS
C          PUT THEM IN NEW BAR.
C
        IF (INTERS(ICINTP,2).EQ.INTERS(INCINP,2)) GO TO 10
C
        INSTRT= INTERS(ICINTP,2)
        INSEND= INTERS(INCINP,2)
        ITO= INSEND-INSTRT
        IF (ITO.LT.0) ITO= 6-INSTRT+INSEND
        IF (ITO.GT.3) GO TO 9
C
    8   INSTRT= INSTRT+1
        IF (INSTRT.EQ.INSEND+1) GO TO 10
        IF (INSTRT.GT.6) INSTRT= 1
C
        INEWLI= INEWLI+1
        XEANEW(INEWLI)= XCHLIN(INSTRT)
        YEANEW(INEWLI)= YCHLIN(INSTRT)
        GO TO 8
C
    9   INEWLI= INEWLI+1
        XEANEW(INEWLI)= XCHLIN(INSTRT)
        YEANEW(INEWLI)= YCHLIN(INSTRT)
        INSTRT= INSTRT-1
        IF (INSTRT.EQ.INSEND) GO TO 10
        IF (INSTRT.GT.6) INSTRT= 1
        GO TO 9
C
C          PUT INTERSECT OF NEXT LINE IN NEW BAR
C
   10   INEWLI= INEWLI+1
        XEANEW(INEWLI)= XINTS(INCINP)
        YEANEW(INEWLI)= YINTS(INCINP)
C
C          IF NEXT POINT LIES OUTWITH BAR PUT IT
C          IN NEW BAR.
C
        IF (INDICS(INTERS(INCINP,1)).EQ.0) GO TO 11
C
        INEWLI= INEWLI+1
        XEANEW(INEWLI)= XEALIN(INTERS(INCINP,1))
        YEANEW(INEWLI)= YEALIN(INTERS(INCINP,1))
   11   ICINTP= ICINTP+2
        GO TO 500
C
C          IF CURRENT POINT LIES OUTWITH FRONT BAR PUT IT IN
C          NEW BAR.
C
   12   IF (INDICS(ICL).EQ.0) GO TO 500
        IF (INDICS(ICL).EQ.2.AND.(INDICS(MOD(ICL,NUMLNS)+1).EQ.0.OR.
     &                          INDICS(MOD(ICL,NUMLNS)+1).EQ.2)) GO TO 500
C
        INEWLI= INEWLI+1
        XEANEW(INEWLI)= XEALIN(ICL)
        YEANEW(INEWLI)= YEALIN(ICL)
  500 CONTINUE
C
C          STORE NEW BAR IN XEALIN,YEALIN BEFORE RETURNING.
C
      ICNT= 0
C
      DO 600 I= 1,INEWLI
C
C          IF A POINT WILL LIE ON TOP OF NEXT POINT
C          MISS IT OUT.
C
        IF (ABS(XEANEW(I)-XEANEW(MOD(I,INEWLI)+1)).LT.RMINI.AND.
     &      ABS(YEANEW(I)-YEANEW(MOD(I,INEWLI)+1)).LT.RMINI) GO TO 600
C
        ICNT= ICNT+1
        XEALIN(ICNT)= XEANEW(I)
        YEALIN(ICNT)= YEANEW(I)
  600 CONTINUE
C
      NUMLNS= ICNT
      RETURN
      END
      SUBROUTINE G0PLAX(LINE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 233)   VERSION (A8.7)    11:JAN:88
C          ------------------------------------------------
C
C          THIS DRAWS TICK MARKS AND (OPTIONALLY) AN AXIS LINE,
C          WITH LINEAR MARKINGS ALONG THE X-DIRECTION.
C
C          <LINE>   CONTROLS WHETHER THE AXIS LINE IS DRAWN:
C                   IF ZERO, ONLY TICK MARKS ARE DRAWN,
C                   OTHERWISE, THE AXIS LINE IS ALSO DONE.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <NOTATA> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOTATION IS DONE.
C          <AXPOSX> THE POSITION OF THE X-AXIS ALONG Y.
C          <DIVLX>  IS THE X-AXIS SUB-INTERVAL SIZE.
C          <NSKIPX> IS THE NO. OF SUB-INTERVALS PER MAJOR INTERVAL IN X.
C          <NTIKLX> IS THE MARKING START-POINT FOR THE X-AXIS.
C          <NTIKHX> IS THE MARKING END-  POINT FOR THE X-AXIS.
C          <NDECSX> IS THE X-AXIS ANNOTATION BASIS-EXPONENT.
C          <NCHRSX> IS THE NO. OF CHARS. IN X-AXIS ANNOTATION.
C          <NAFTPX> IS THE NO. OF CHARS. AFTER THE DEC. PT. IN X.
C          <KANNX>  GIVES THE X-AXIS ANNOTATION TYPE, AS FOLLOWS:
C                   = 1, IT IS INTEGER
C                   = 2, IT IS REAL,
C                   = 3, IT IS INTEGER WITH MULT. FACTOR.
C                   = 4, IT IS REAL    WITH MULT. FACTOR.
C          <KAXIS>  INDICATES WHETHER ANNOTATION MAY BE SUPPRESSED:
C                   > 0, NO, OR
C                   < 0, YES, IF IT INTERFERES WITH THE OTHER AXIS.
C          <TKEN1A> AND
C          <TKEN1B> ARE THE END-POINTS OF THE 5/1000TH.-SIZE TICK MARK.
C          <TKEN2A> AND
C          <TKEN2B> ARE THE END-POINTS OF THE 8/1000TH.-SIZE TICK MARK.
C
C
      REAL    RDATA(1)
      INTEGER IDECFC(3)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0ANOX/ KANNX,NCHRSX,NAFTPX
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0NOTA/ NOTATA
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
c slmod begin
      COMMON /GHOSTCOM/ iopt_ghost
c slmod end
C
      DATA RDATA /0.0/, IDECFC /120,49,48/
C
C
C          THE AXIS LINE IS DRAWN HERE, IF REQUIRED.
C
      IF (LINE.EQ.0) GO TO 1
C
      CALL POSITN(X1WND0,AXPOSX)
      CALL   JOIN(X2WND0,AXPOSX)
C
C          THE NO. OF TICK MARKS IS CALCULATED, AND IF NONE EXIST,
C          NO MORE NEED BE DONE. OTHERWISE, THE CURRENT FONT NO.
C          IS SAVED, THE SCALING FACTOR IS CALCULATED, AND THE
C          INITIAL SUB-INTERVAL COUNT IS SET UP. LOOP-100 THEN
C          DRAWS EACH TICK MARK (OF THE APPROPRIATE SIZE) IN TURN,
C          ALSO ANNOTATING THE MAJOR INTERVALS AS REQUIRED.
C
    1 NTICKS= NTIKHX-NTIKLX+1
      IF (NTICKS.LE.0) RETURN
      IF (NOTATA.NE.0) FACTOR= 10.0**(-NDECSX)
C
      IMISS= NTIKHX/NSKIPX
      IMISS= IMISS*NSKIPX-NTIKHX-1
      IF (NTIKHX.GE.0) IMISS= IMISS+NSKIPX
      IF (IMISS.LT.0) IMISS= NSKIPX
C
      DO 100 ITICK= 1,NTICKS
        XPOS= DIVLX*(NTIKHX-ITICK+1)
        TKENDA= TKEN1A
        TKENDB= TKEN1B
        IMISS= IMISS+1
        IF (IMISS.LT.NSKIPX) GO TO 2
C
        IMISS= 0
        TKENDA= TKEN2A
        TKENDB= TKEN2B
C
C          THE APPROPRIATE-SIZE TICK MARK IS DRAWN. IF ANNOTATION
C          IS NOT REQUIRED, OR IF THIS POSITION IS NOT ON A MAJOR
C          INTERVAL, LOOP-100 CONTINUES WITH THE NEXT TICK MARK.
C
c slmod begin
    2   IF (LINE.EQ.1) THEN
          CALL POSITN(XPOS,0.5*(TKENDA+TKENDB))
          CALL   JOIN(XPOS,TKENDB)
        ELSE
          CALL POSITN(XPOS,0.5*(TKENDA+TKENDB))
          CALL   JOIN(XPOS,TKENDA)
        ENDIF
c
c        CALL POSITN(XPOS,TKENDA)
c        CALL   JOIN(XPOS,TKENDB)
c slmod end
        IF (NOTATA.EQ.0) GO TO 100
        IF (IMISS.NE.0)  GO TO 100
C
C          THIS SECTION SUPPRESSES ANNOTATION (IF REQUIRED)
C          WHEN THE X-AXIS IS WITHIN THE WINDOW AREA AND THE
C          CURRENT TICK POSITION IS TOO CLOSE TO THE Y-AXIS.
C
c slmod begin
        IF (IOPT_GHOST.EQ.2) GOTO 100
c slmod end
        IF (KAXIS.GT.0) GO TO 3
        IF (ABS(AXPOSX-Y1WND0).LT.RMINI.AND.KDIRY.LE.0) GO TO 3
        IF (ABS(AXPOSX-Y2WND0).LT.RMINI.AND.KDIRY.GE.1) GO TO 3
C
        XDIFF= ABS(XPOS-AXPOSY)
        IF (XDIFF.GT.0.25*DIVLX) GO TO 3
        IF (XDIFF.LT.0.05*ABS(X2WND0-X1WND0)) GO TO 100
C
C          WHEN ANNOTATION IS TO BE DONE, THE POSITION IS SET,
C          THE APPROPRIATE FORMAT SELECTED, AND THE VALUE PRINTED.
C
c slmod begin
    3   CALL POSITN(XPOS,AXPOSX+0.005)
c
c    3   CALL POSITN(XPOS,AXPOSX)
c slmod end
        IF (KDIRX.LE.0) CALL LINEFD(2)
        IF (KDIRX.GE.1) CALL HLINFD(-3)
C
        CALL SPACE(-NCHRSX/2)
        VALUE= XPOS
        IF (KANNX.GT.2) VALUE= FACTOR*VALUE
        IF (KANNX.EQ.2.OR.KANNX.EQ.4) GO TO 4
C
        IVALUE= VALUE+SIGN(0.5,VALUE)
        CALL TYPENI(IVALUE)
        GO TO 100
C
    4   CALL TYPENF(VALUE,NAFTPX)
  100 CONTINUE
C
C          IF THE FORMAT REQUIRES A MULTIPLYING FACTOR,
C          ITS POSITION IS SET AND ITS VALUE PRINTED.
C
      IF (NOTATA.EQ.0) RETURN
      IF (KANNX.LT.3) RETURN
      IF (SIGN(1.0,(X1WND0-AXPOSY))*SIGN(1.0,(X2WND0-AXPOSY)).GE.0.0)
     &    GO TO 5
C
      START= AXPOSY
      WIDE= X2WND0
      IF (ABS(X2WND0).LT.ABS(0.9*X1WND0)) WIDE= X1WND0
      GO TO 6
C
    5 START= X1WND0
      WIDE= X2WND0-X1WND0
    6 MULTPT= (0.6667*WIDE+START)/DIVLX
      XPOS= MULTPT*DIVLX
      CALL POSITN(XPOS,AXPOSX)
      IF (KDIRX.LE.0) CALL HLINFD(7)
      IF (KDIRX.GE.1) CALL LINEFD(-3)
C
      CALL G3LINK(2,11,-3,IDECFC,RDATA)
      CALL SUPFIX
      IF (NDECSX.GE.0) CALL SPACE(-1)
C
      CALL TYPENI(NDECSX)
      CALL NORMAL
      RETURN
      END
      SUBROUTINE G0PLAY(LINE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 234)   VERSION (A8.7)    11:JAN:88
C          ------------------------------------------------
C
C          THIS DRAWS TICK MARKS AND (OPTIONALLY) AN AXIS LINE,
C          WITH LINEAR MARKINGS ALONG THE Y-DIRECTION.
C
C          <LINE>   CONTROLS WHETHER THE AXIS LINE IS DRAWN:
C                   IF ZERO, ONLY TICK MARKS ARE DRAWN,
C                   OTHERWISE, THE AXIS LINE IS ALSO DONE.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <NOTATA> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOTATION IS DONE.
C          <AXPOSY> THE POSITION OF THE Y-AXIS ALONG X.
C          <DIVLY>  IS THE Y-AXIS SUB-INTERVAL SIZE.
C          <NSKIPY> IS THE NO. OF SUB-INTERVALS PER MAJOR INTERVAL IN Y.
C          <NTIKLY> IS THE MARKING START-POINT FOR THE Y-AXIS.
C          <NTIKHY> IS THE MARKING END-  POINT FOR THE Y-AXIS.
C          <NDECSY> IS THE Y-AXIS ANNOTATION BASIS-EXPONENT.
C          <NCHRSY> IS THE NO. OF CHARS. IN Y-AXIS ANNOTATION.
C          <NAFTPY> IS THE NO. OF CHARS. AFTER THE DEC. PT. IN Y.
C          <KANNY>  GIVES THE Y-AXIS ANNOTATION TYPE, AS FOLLOWS:
C                   = 1, IT IS INTEGER
C                   = 2, IT IS REAL,
C                   = 3, IT IS INTEGER WITH MULT. FACTOR.
C                   = 4, IT IS REAL    WITH MULT. FACTOR.
C          <KAXIS>  INDICATES WHETHER ANNOTATION MAY BE SUPPRESSED:
C                   > 0, NO, OR
C                   < 0, YES, IF IT INTERFERES WITH THE OTHER AXIS.
C          <TKEN1A> AND
C          <TKEN1B> ARE THE END-POINTS OF THE 5/1000TH.-SIZE TICK MARK.
C          <TKEN2A> AND
C          <TKEN2B> ARE THE END-POINTS OF THE 8/1000TH.-SIZE TICK MARK.
C
C
      REAL    RDATA(1)
      INTEGER IDECFC(3)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0NOTA/ NOTATA
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/, IDECFC /120,49,48/
C
C
C          THE AXIS LINE IS DRAWN HERE, IF REQUIRED.
C
      IF (LINE.EQ.0) GO TO 1
C
      CALL POSITN(AXPOSY,Y1WND0)
      CALL   JOIN(AXPOSY,Y2WND0)
C
C          THE NO. OF TICK MARKS IS CALCULATED, AND IF NONE EXIST,
C          NO MORE NEED BE DONE. OTHERWISE, THE CURRENT FONT NO.
C          IS SAVED, THE SCALING FACTOR IS CALCULATED, AND THE
C          INITIAL SUB-INTERVAL COUNT IS SET UP. LOOP-100 THEN
C          DRAWS EACH TICK MARK (OF THE APPROPRIATE SIZE) IN TURN,
C          ALSO ANNOTATING THE MAJOR INTERVALS AS REQUIRED.
C
    1 NTICKS= NTIKHY-NTIKLY+1
      IF (NTICKS.LE.0) RETURN
      IF (NOTATA.NE.0) FACTOR= 10.0**(-NDECSY)
C
      IMISS= NTIKHY/NSKIPY
      IMISS= IMISS*NSKIPY-NTIKHY-1
      IF (NTIKHY.GE.0) IMISS= IMISS+NSKIPY
      IF (IMISS.LT.0) IMISS= NSKIPY
C
      DO 100 ITICK= 1,NTICKS
        YPOS= DIVLY*(NTIKHY-ITICK+1)
        TKENDA= TKEN1A
        TKENDB= TKEN1B
        IMISS= IMISS+1
        IF (IMISS.LT.NSKIPY) GO TO 2
C
        IMISS= 0
        TKENDA= TKEN2A
        TKENDB= TKEN2B
C
C          THE APPROPRIATE-SIZE TICK MARK IS DRAWN. IF ANNOTATION
C          IS NOT REQUIRED, OR IF THIS POSITION IS NOT ON A MAJOR
C          INTERVAL, LOOP-100 CONTINUES WITH THE NEXT TICK MARK.
C
c slmod begin
    2   IF (LINE.EQ.1) THEN
          CALL POSITN(0.5*(TKENDA+TKENDB),YPOS)
          CALL   JOIN(TKENDB,YPOS)
        ELSE
          CALL POSITN(0.5*(TKENDA+TKENDB),YPOS)
          CALL   JOIN(TKENDA,YPOS)
        ENDIF
c
c    2   CALL POSITN(TKENDA,YPOS)
c        CALL   JOIN(TKENDB,YPOS)
c slmod end
        IF (NOTATA.EQ.0) GO TO 100
        IF (IMISS.NE.0)  GO TO 100
C
C          THIS SECTION SUPPRESSES ANNOTATION (IF REQUIRED)
C          WHEN THE Y-AXIS IS WITHIN THE WINDOW AREA AND THE
C          CURRENT TICK POSITION IS TOO CLOSE TO THE X-AXIS.
C
c slmod begin
c...    This is just a duplicate of the line down a ways, but it
c       stops the labels from being printed if they are too close
c       to the x-axis *or* the top of the graph:
        YDIFF= ABS(YPOS-AXPOSX)
        IF (YDIFF.LT.0.05*ABS(Y2WND0-Y1WND0).OR.
     .      YDIFF.GT.0.95*ABS(Y2WND0-Y1WND0)) GO TO 100
c slmod end
        IF (KAXIS.GT.0) GO TO 3
        IF (ABS(AXPOSY-X1WND0).LT.RMINI.AND.KDIRX.LE.0) GO TO 3
        IF (ABS(AXPOSY-X2WND0).LT.RMINI.AND.KDIRX.LE.0) GO TO 3
C
        YDIFF= ABS(YPOS-AXPOSX)
        IF (YDIFF.GT.0.25*DIVLY) GO TO 3
        IF (YDIFF.LT.0.05*ABS(Y2WND0-Y1WND0)) GO TO 100
C
C          WHEN ANNOTATION IS TO BE DONE, THE POSITION IS SET,
C          THE APPROPRIATE FORMAT SELECTED, AND THE VALUE PRINTED.
C
    3   CALL POSITN(AXPOSY,YPOS)
        IF (KDIRY.LE.0)  CALL SPACE(-NCHRSY-1)
        IF (KDIRY.GE.1)  CALL SPACE(2)
C
        VALUE= YPOS
        IF (KANNY.GT.2) VALUE= FACTOR*VALUE
        IF (KANNY.EQ.2.OR.KANNY.EQ.4) GO TO 4
C
        IVALUE= VALUE+SIGN(0.5,VALUE)
        IF (INT(ALOG10(FLOAT(IABS(IVALUE))+0.1)).LT.NCHRSY-2
     &      .AND.IVALUE.NE.0) CALL SPACE(1)
        IF (IVALUE.EQ.0) CALL SPACE(NCHRSY-2)
C
        CALL TYPENI(IVALUE)
        GO TO 100
C
    4   CALL TYPENF(VALUE,NAFTPY)
  100 CONTINUE
C
C          IF THE FORMAT REQUIRES A MULTIPLYING FACTOR,
C          ITS POSITION IS SET AND ITS VALUE PRINTED.
C
      IF (NOTATA.EQ.0) RETURN
      IF (KANNY.LT.3) RETURN
      IF (SIGN(1.0,(Y1WND0-AXPOSX))*SIGN(1.0,(Y2WND0-AXPOSX)).GE.0.0)
     &    GO TO 5
C
      START= AXPOSX
      WIDE= Y2WND0
      IF (ABS(Y2WND0).LT.ABS(0.9*Y1WND0)) WIDE= Y1WND0
      GO TO 6
C
    5 START= Y1WND0
      WIDE= Y2WND0-Y1WND0
    6 MULTPT= (0.6667*WIDE+START)/DIVLY
      YPOS= MULTPT*DIVLY
      CALL POSITN(AXPOSY,YPOS)
      IF (KDIRY.LE.0) CALL SPACE(-NCHRSY-5)
      IF (KDIRY.GE.1) CALL SPACE(NCHRSY+3)
C
      CALL G3LINK(2,11,-3,IDECFC,RDATA)
      CALL SUPFIX
      IF (NDECSY.GE.0) CALL SPACE(-1)
C
      CALL TYPENI(NDECSY)
      CALL NORMAL
      RETURN
      END
      SUBROUTINE G0PLXL(LINE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 237)   VERSION (A8.7)    11:JAN:88
C          ------------------------------------------------
C
C          THIS DRAWS TICK MARKS AND (OPTIONALLY) AN AXIS LINE,
C          WITH LOGARITHMIC MARKINGS ALONG THE X-DIRECTION.
C
C          <LINE>   CONTROLS WHETHER THE AXIS LINE IS DRAWN:
C                   IF ZERO, ONLY TICK MARKS ARE DRAWN,
C                   OTHERWISE, THE AXIS LINE IS ALSO DONE.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <NOTATA> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOTATION IS DONE.
C          <AXPOSX> THE POSITION OF THE X-AXIS ALONG Y.
C          <DIVLX>  GIVES THE X-AXIS SIGN.
C          <NSKIPX> IS THE X-AXIS START-POINT EXPONENT.
C          <NTIKLX> IS THE X-AXIS START-POINT MANTISSA.
C          <NTIKHX> IS THE NO. OF X-AXIS TICK MARKS.
C          <NDECSX> IS THE NO. OF DECADE MARKS ON THE X-AXIS.
C          <NCHRSX> IS THE NO. OF CHARS. IN X-AXIS ANNOTATION.
C          <KAXIS>  INDICATES WHETHER ANNOTATION MAY BE SUPPRESSED:
C                   > 0, NO, OR
C                   < 0, YES, IF IT INTERFERES WITH THE OTHER AXIS.
C          <TKEN1A> AND
C          <TKEN1B> ARE THE END-POINTS OF THE 5/1000TH.-SIZE TICK MARK.
C          <TKEN2A> AND
C          <TKEN2B> ARE THE END-POINTS OF THE 8/1000TH.-SIZE TICK MARK.
C
C
      REAL    RDATA(1)
      INTEGER IDECFC(3)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0ANOX/ KANNX,NCHRSX,NAFTPX
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0NOTA/ NOTATA
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/, IDECFC /120,49,48/
C
C
C          THIS PART DRAWS THE AXIS, IF REQUIRED.
C
      IF (LINE.EQ.0) GO TO 1
C
      CALL POSITN(X1WND0,AXPOSX)
      CALL   JOIN(X2WND0,AXPOSX)
C
C          IF THERE ARE NO TICK MARKS, NO MORE NEED BE DONE.
C          OTHERWISE, THE CURRENT FONT IS SAVED, THE START POINT
C          IS FOUND, THEN LOOP-100 DRAWS EACH TICK MARK (OF THE
C          APPROPRIATE SIZE) IN TURN, ANNOTATING IT AS REQUIRED.
C
    1 IF (NTIKHX.LE.0) RETURN
C
      IPOS= NTIKLX-1
      IDEC= NSKIPX
      MULTPT= 3
      IF (IPOS.GT.2.AND.IPOS.LT.8) MULTPT= IPOS+1
C
      DO 100 ITICK= 1,NTIKHX
        TKENDA= TKEN1A
        TKENDB= TKEN1B
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 2
C
        IPOS= 1
        IDEC= IDEC+1
        TKENDA= TKEN2A
        TKENDB= TKEN2B
C
C          THE APPROPRIATE-SIZE TICK MARK IS DRAWN. IF ANNOTATION
C          IS NOT REQUIRED, OR IF THIS POSITION IS NOT ON A DECADE
C          INTERVAL WHEN THERE ARE A LARGE NUMBER OF LOG. CYCLES
C          PRESENT, LOOP-100 CONTINUES WITH THE NEXT TICK MARK.
C
    2   XPOS= DIVLX*IPOS*(10.0**IDEC)
        CALL POSITN(XPOS,TKENDA)
        CALL   JOIN(XPOS,TKENDB)
        IF (NOTATA.EQ.0) GO TO 100
C
C          THIS SECTION SUPPRESSES ANNOTATION WHEN THIS
C          COINCIDES WITH THE OTHER AXIS, IF REQUIRED.
C
        IF (KAXIS.GT.0) GO TO 3
        IF (ABS(AXPOSX-Y1WND0).LT.RMINI.AND.KDIRY.LE.0) GO TO 3
        IF (ABS(AXPOSX-Y2WND0).LT.RMINI.AND.KDIRY.GE.1) GO TO 3
C
        XDIFF= ALOG (XPOS/AXPOSY)
        IF (ABS(XDIFF).LT.0.04*ALOG(X2WND0/X1WND0)) GO TO 6
C
C          WHEN ANNOTATION IS TO BE DONE, THE POSITION IS SET,
C          THE APPROPRIATE FORMAT SELECTED, AND THE VALUE PRINTED.
C          IF THERE ARE MORE THAN 10 TICK MARKS, INTEGER+EXPONENT
C          FORMAT IS USED; OTHERWISE NORMAL REAL OR INTEGER FORMAT
C          IS USED, PROVIDED THE VALUES ARE NOT TOO LARGE OR SMALL.
C
    3   CALL POSITN(XPOS,AXPOSX)
        IF (KDIRX.LE.0) CALL LINEFD (2)
        IF (KDIRX.GE.1) CALL HLINFD(-3)
        IF (NTIKHX.GT.10)                GO TO 5
        IF (NSKIPX.LT.-2.OR.NSKIPX.GT.3) GO TO 5
C
C          THESE SECTIONS PROVIDE NORMAL FORMAT (INTEGER OR REAL).
C
        IF (NSKIPX.LT.0) GO TO 4
C
        CALL SPACE(-1)
        IVALUE= IPOS*(10**IDEC)
        IF (DIVLX.LT.0.0) IVALUE= -IVALUE
C
        CALL TYPENI(IVALUE)
        GO TO 100
C
    4   CALL HSPACE(2-NCHRSX)
        CALL TYPENF(XPOS,-NSKIPX)
        GO TO 100
C
C          THESE SECTIONS PROVIDE INTEGER+EXPONENT FORMAT.
C
    5   CALL SPACE(-1)
        IVALUE= IPOS
        IF (DIVLX.LT.0.0) IVALUE= -IVALUE
        IF (NTIKHX.LE.55.OR.IPOS.EQ.1) CALL TYPENI(IVALUE)
C
C          THIS PART WRITES THE DECADE MULTIPLYING FACTORS.
C
        IF (IPOS.NE.MULTPT) GO TO 100
C
        MULTPT= 3
        IF (ABS(X1WND0).GT.ABS(X2WND0)) CALL SPACE(-4)
        IF (KDIRX.LE.0) CALL HLINFD(3)
        IF (KDIRX.GE.1) CALL HLINFD(-3)
C
        CALL G3LINK(2,11,-3,IDECFC,RDATA)
        CALL SUPFIX
        IF (IDEC.GE.0) CALL SPACE(-1)
C
        CALL TYPENI(IDEC)
        CALL NORMAL
    6   IF (IPOS.EQ.MULTPT) MULTPT= 3
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE G0PLYL(LINE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 238)   VERSION (A8.7)    11:JAN:88
C          ------------------------------------------------
C
C          THIS DRAWS TICK MARKS AND (OPTIONALLY) AN AXIS LINE,
C          WITH LOGARITHMIC MARKINGS ALONG THE Y-DIRECTION.
C
C          <LINE>   CONTROLS WHETHER THE AXIS LINE IS DRAWN:
C                   IF ZERO, ONLY TICK MARKS ARE DRAWN,
C                   OTHERWISE, THE AXIS LINE IS ALSO DONE.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <NOTATA> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOTATION IS DONE.
C          <AXPOSY> THE POSITION OF THE Y-AXIS ALONG X.
C          <DIVLY>  GIVES THE Y-AXIS SIGN.
C          <NSKIPY> IS THE Y-AXIS START-POINT EXPONENT.
C          <NTIKLY> IS THE Y-AXIS START-POINT MANTISSA.
C          <NTIKHY> IS THE NO. OF Y-AXIS TICK MARKS.
C          <NDECSY> IS THE NO. OF DECADE MARKS ON THE Y-AXIS.
C          <NCHRSY> IS THE NO. OF CHARS. IN Y-AXIS ANNOTATION.
C          <KAXIS>  INDICATES WHETHER ANNOTATION MAY BE SUPPRESSED:
C                   > 0, NO, OR
C                   < 0, YES, IF IT INTERFERES WITH THE OTHER AXIS.
C          <TKEN1A> AND
C          <TKEN1B> ARE THE END-POINTS OF THE 5/1000TH.-SIZE TICK MARK.
C          <TKEN2A> AND
C          <TKEN2B> ARE THE END-POINTS OF THE 8/1000TH.-SIZE TICK MARK.
C
C
      REAL    RDATA(1)
      INTEGER IDECFC(3)
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOD/ KDIRX,KDIRY
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0NOTA/ NOTATA
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA RDATA /0.0/, IDECFC /120,49,48/
C
C
C          THIS PART DRAWS THE AXIS, IF REQUIRED.
C
      IF (LINE.EQ.0) GO TO 1
C
      CALL POSITN(AXPOSY,Y1WND0)
      CALL   JOIN(AXPOSY,Y2WND0)
C
C          IF THERE ARE NO TICK MARKS, NO MORE NEED BE DONE.
C          OTHERWISE, THE CURRENT FONT IS SAVED, THE START POINT
C          IS FOUND, THEN LOOP-100 DRAWS EACH TICK MARK (OF THE
C          APPROPRIATE SIZE) IN TURN, ANNOTATING IT AS REQUIRED.
C
    1 IF (NTIKHY.LE.0) RETURN
C
      IPOS= NTIKLY-1
      IDEC= NSKIPY
      MULTPT= 3
      IF (IPOS.GT.2.AND.IPOS.LT.8) MULTPT= IPOS+1
C
      DO 100 ITICK= 1,NTIKHY
        TKENDA= TKEN1A
        TKENDB= TKEN1B
        IPOS= IPOS+1
        IF (IPOS.LT.10) GO TO 2
C
        IPOS= 1
        IDEC= IDEC+1
        TKENDA= TKEN2A
        TKENDB= TKEN2B
C
C          THE APPROPRIATE-SIZE TICK MARK IS DRAWN. IF ANNOTATION
C          IS NOT REQUIRED, OR IF THIS POSITION IS NOT ON A DECADE
C          INTERVAL WHEN THERE ARE A LARGE NUMBER OF LOG. CYCLES
C          PRESENT, LOOP-100 CONTINUES WITH THE NEXT TICK MARK.
C
    2   YPOS= DIVLY*IPOS*(10.0**(IDEC))
        CALL POSITN(TKENDA,YPOS)
        CALL   JOIN(TKENDB,YPOS)
        IF (NOTATA.EQ.0) GO TO 100
C
C          THIS SECTION SUPPRESSES ANNOTATION WHEN THIS
C          COINCIDES WITH THE OTHER AXIS, IF REQUIRED.
C
        IF (KAXIS.GT.0) GO TO 3
        IF (ABS(AXPOSY-X1WND0).LT.RMINI.AND.KDIRX.LE.0) GO TO 3
        IF (ABS(AXPOSY-X2WND0).LT.RMINI.AND.KDIRX.GE.1) GO TO 3
C
        YDIFF= ALOG(YPOS/AXPOSX)
        IF (ABS(YDIFF).LT.0.04*ALOG(Y2WND0/Y1WND0)) GO TO 6
C
C          WHEN ANNOTATION IS TO BE DONE, THE POSITION IS SET,
C          THE APPROPRIATE FORMAT SELECTED, AND THE VALUE PRINTED.
C          IF THERE ARE MORE THAN 10 TICK MARKS, INTEGER+EXPONENT
C          FORMAT IS USED; OTHERWISE NORMAL REAL OR INTEGER FORMAT
C          IS USED, PROVIDED THE VALUES ARE NOT TOO LARGE OR SMALL.
C
    3   CALL POSITN(AXPOSY,YPOS)
        IF (NTIKHY.GT.10) GO TO 5
        IF (NSKIPY.LT.-2.OR.NSKIPY.GT.3) GO TO 5
C
C          THESE SECTIONS PROVIDE NORMAL FORMAT (INTEGER OR REAL).
C
        IF (NSKIPY.LT.0) GO TO 4
        IF (KDIRY.LE.0) CALL SPACE(-NCHRSY-1)
        IF (KDIRY.GE.1) CALL SPACE(2)
C
        IVALUE= IPOS*(10**IDEC)
        IF (DIVLY.LT.0.0) IVALUE= -IVALUE
C
        CALL TYPENI(IVALUE)
        GO TO 100
C
    4   IF (KDIRY.LE.0) CALL SPACE(-NCHRSY)
        IF (KDIRY.GE.1) CALL SPACE(1)
C
        CALL TYPENF(YPOS,-NSKIPY)
        GO TO 100
C
C          THESE SECTIONS PROVIDE INTEGER-EXPONENT FORM.
C
    5   IF (KDIRY.LE.0) CALL SPACE(-3)
        IF (KDIRY.GE.1) CALL SPACE(1)
C
        IVALUE= IPOS
        IF (DIVLY.LT.0.0) IVALUE= -IVALUE
        IF (NTIKHY.LE.37.OR.IPOS.EQ.1) CALL TYPENI(IVALUE)

C
C          THIS PART PROVIDES THE DECADE MULTIPLYING FACTOR.
C
        IF (IPOS.NE.MULTPT) GO TO 100
C
        MULTPT= 3
        IF (KDIRY.LE.0) CALL SPACE(-6)
        IF (KDIRY.GE.1) CALL SPACE(1)
C
        CALL G3LINK(2,11,-3,IDECFC,RDATA)
        CALL SUPFIX
        IF (IDEC.GE.0) CALL SPACE(-1)
C
        CALL TYPENI(IDEC)
        CALL NORMAL
        GO TO 100
C
    6   IF (MULTPT.EQ.IPOS) MULTPT= 3
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE G0SUR1(SURFAS,ISTRTX,ISTOPX,NPTSX,ISTRTY,ISTOPY,NPTSY,
     &                  XSECT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 140)   VERSION (A8.2)    19:AUG:88
C          ------------------------------------------------
C
C          THIS IS USED TO PRODUCE AN ISOMETRIC PROJECTION
C          OF A SURFACE Z= Z(X,Y) WHERE Z IS GIVEN AT POINTS ON
C          A REGULAR MESH OF SQUARES. SECTIONS ARE DRAWN
C          THROUGH THE SURFACE PARALLEL TO EITHER THE X OR Y AXES.
C
C
C          [SURFAS]  IS THE ARRAY OF SURFACE HEIGHT VALUES.
C          <ISTRTX>  IS THE LOWER X-EXTENT,
C          <ISTOPX>  IS THE UPPER X-EXTENT, WHILE
C          <ISTRTY>  AND
C          <ISTOPY>  ARE THE CORRESPONDING Y-BOUNDS.
C          <NPTSX>   IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>   IS THE ACTUAL ARRAY Y-EXTENT.
C          <XSECT>   SETS THE DIRECTION OF THE SECTIONS:
C                    = .TRUE., IN THE X-DIRECTION,
C                    = .FALSE., IN THE Y-DIRECTION;
C
C
C          THE VISIBILITY OF EACH POINT ALONG A SECTION IS EXAMINED BY
C          COMPARING POINTS ON THE SECTION WITH THOSE ON A VISIBLE
C          PROFILE. VISIBLE POINTS ARE JOINED BY STRAIGHT LINES AND THE
C          CO-ORDINATES OF THE POINT WHERE A LINE BECOMES HIDDEN ARE
C          CALCULATED USING LINEAR INTERPOLATION IN THE PLANE OF
C          PROJECTION. REFERENCE: NPL REPORT NAC 75, C. HALL, 1977.
C
C          THIS IS AN IMPROVED VERSION OF THE ALGORITHM DESCRIBED
C          IN THE ABOVE REPORT.
C
C
      REAL    SURFAS(NPTSX,NPTSY),U(192),V(192),PROFUP(192),
     &        PROFLW(192),TMPROF(192),RDATA(1)
      INTEGER ITYPE1(8),ITYPE2(8),ITYPE3(8),ITYPE4(8)
      LOGICAL INVIS,LOWER,UINVIS,LINVIS,BASE,XSECT,AXMARK
C
      COMMON /T0CMAP/ MAPBIT(6,192),ISTPTX,ISTPTY
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
      COMMON /T0SAXE/ INDAXE,XAXORG,YAXORG,XAXDEL,YAXDEL
      COMMON /T0SBAS/ IUNDRS,INDBAS,BASEHT
      COMMON /T0SCOL/ LINCUP,LINCLW,LINCBS
      COMMON /T0SCOM/ XLEN,YLEN,SCALE,XSHIFT,YSHIFT,SURMIN,SURMAX
      COMMON /T0SDEL/ DELTXY,DELTAU,DELTAV
      COMMON /T0SINS/ XINSEC,YINSEC
      COMMON /T0SSEC/ ISECTN
      COMMON /T0SVEW/ IVIEWN
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
      EQUIVALENCE (U     (1),MAPBIT(1,  1)),(V     (1),MAPBIT(1, 33)),
     &            (PROFUP(1),MAPBIT(1, 65)),(PROFLW(1),MAPBIT(1, 97)),
     &            (TMPROF(1),MAPBIT(1,129))
C
      DATA ITYPE1 /88,79,82,73,71,78,32,61/,
     &     ITYPE2 /89,79,82,73,71,78,32,61/,
     &     ITYPE3 /88,68,69,76,84,65,32,61/,
     &     ITYPE4 /89,68,69,76,84,65,32,61/
C
C
C          SET CONSTANTS. IF <XSECT>= .TRUE., SECTIONS ARE DRAWN
C          PARALLEL TO THE X-AXIS; OTHERWISE SECTIONS ARE DRAWN
C          PARALLEL TO THE Y-AXIS.
C
      IDIR= -1
      IRN= IVIEWN+1
      TPCORN= 0.0
      NUMCOL= -1
      AXMARK= (INDAXE.NE.0)
      IF (SINANG.LT.0.0) AXMARK= .FALSE.
      IDIVSR= (ISTOPX+ISTOPY-ISTRTX-ISTRTY)/30+1
      BASE= (INDBAS.NE.0)
      IF (SINANG.LT.0.0) BASE= .FALSE.
C
      ISTRTA= ISTRTX
      ISTOPA= ISTOPX
      ISTRTB= ISTRTY
      ISTOPB= ISTOPY
      IF (XSECT) GO TO 1
C
      ISTRTA= ISTRTY
      ISTOPA= ISTOPY
      ISTRTB= ISTRTX
      ISTOPB= ISTOPX
      DELTAU= -DELTAU
C
C
C          THE SURFACE IS SCANNED IN SECTIONS DETERMINED BY <XSECT>
C          STARTING WITH THE SECTION NEAREST THE VIEWER.
C
    1 DO 100 JJ= ISTRTB,ISTOPB
        IBELMT= ISTRTB+ISTOPB-JJ
        Y= DELTXY*FLOAT(JJ-ISTRTB)
C
C          SCAN ALONG SECTION SETTING PROJECTED CO-ORDINATES <U>,<V>.
C          SELECT THE APPROPRIATE ELEMENT <IXELMT>,<IYELMT> FROM THE ARRAY
C          <SURFAS> DEPENDING UPON THE ROTATION AND DIRECTION OF SCAN.
C
C          THE TRANSFORMATION EQUATIONS ARE:
C          XTRAN= X*COS(45)-Y*SIN(45)
C          YTRAN= (X*SIN(45)+Y*COS(45))*SIN(TLTANG)+SCALE*Z*COS(TLTANG)
C          WHERE <SCALE> IS A VERTICAL SCALE FACTOR.
C
C          IN THE CASE WHERE Y= 0, Z= 0, LET THE TRANSFORMED
C          X-AXIS MAKE AN ANGLE <SANGLE> WITH THE HORIZONTAL.
C          THEN TAN(SANGLE)= YTRAN/XTRAN= SIN(TLTANG).
C
C          THE TRANSFORMATION EQUATIONS MAY THEN BE SCALED TO
C          U= XTRAN*SQRT(2)*COS(SANGLE)+XSHIFT
C           = (X-Y)*COS(SANGLE)+XSHIFT
C          V= YTRAN*SQRT(2)*COS(SANGLE)+YSHIFT
C           = (X+Y)*SIN(SANGLE)+SCALE*Z*COS(TLTANG)*SQRT(2)*COS(SANGLE)+YSHIFT
C
C          IN THE ISOMETRIC CASE SANGLE= 30.0 AND TLTANG= 35.2644 DEGREES,
C          COS(SANGLE)= 0.8660254, SIN(SANGLE)= 0.5, COS(TLTANG)= 0.8164966,
C          SO THE TRANSFORMATION EQUATIONS REDUCE TO
C          U= (X-Y)*0.8660254+XSHIFT
C          V= (X+Y)*0.5+SCALE*Z+YSHIFT
C
        DO 200 II= ISTRTA,ISTOPA
          IAELMT= ISTRTA+ISTOPA-II
          X= DELTXY*FLOAT(II-ISTRTA)
          INDEX= II-ISTRTA+1
          UPOS= (X-Y)*COSANG+XSHIFT
          UNEG= (Y-X)*COSANG+XSHIFT
          IF (.NOT.XSECT) GO TO 6
C
          GO TO (2,3,4,5), IRN
C
    2     IXELMT= II
          IYELMT= JJ
          U(INDEX)= UPOS
          GO TO 11
C
    3     IXELMT= II
          IYELMT= IBELMT
          U(INDEX)= UNEG
          GO TO 11
C
    4     IXELMT= IAELMT
          IYELMT= IBELMT
          U(INDEX)= UPOS
          GO TO 11
C
    5     IXELMT= IAELMT
          IYELMT= JJ
          U(INDEX)= UNEG
          GO TO 11
C
    6     GO TO (7,8,9,10), IRN
C
    7     IXELMT= JJ
          IYELMT= II
          U(INDEX)= UNEG
          GO TO 11
C
    8     IXELMT= JJ
          IYELMT= IAELMT
          U(INDEX)= UPOS
          GO TO 11
C
    9     IXELMT= IBELMT
          IYELMT= IAELMT
          U(INDEX)= UNEG
          GO TO 11
C
   10     IXELMT= IBELMT
          IYELMT= II
          U(INDEX)= UPOS
C
   11     V(INDEX)= (X+Y)*SINANG+SCALE*(AMAX1(AMIN1(
     &    SURFAS(IXELMT,IYELMT),SURMAX),SURMIN)*CSROOT*COSANG)+YSHIFT
          IF ((ISTOPA-II).NE.(ISTOPB-JJ)) GO TO 200
          IF (TPCORN.LT.V(INDEX)) TPCORN= V(INDEX)
C
  200   CONTINUE
C
C          THIS SECTION SETS UP THE ANNOTATION PARAMETERS.
C
        IF (.NOT.AXMARK) GO TO 22
        IF (.NOT.XSECT) GO TO 16
C
        GO TO (12,13,14,15), IRN
C
   12   XAXDIS= -COSANG
        INANOT= JJ
        GO TO 21
C
   13   XAXDIS= COSANG
        INANOT= IBELMT
        GO TO 21
C
   14   XAXDIS= -COSANG
        INANOT= IBELMT
        GO TO 21
C
   15   XAXDIS= COSANG
        INANOT= JJ
        GO TO 21
C
   16   GO TO (17,18,19,20), IRN
C
   17   XAXDIS= COSANG
        INANOT= JJ
        GO TO 21
C
   18   XAXDIS= -COSANG
        INANOT= JJ
        GO TO 21
C
   19   XAXDIS= COSANG
        INANOT= IBELMT
        GO TO 21
C
   20   XAXDIS= -COSANG
        INANOT= IBELMT
   21   XHEAD= U(1)
        YHEAD= DELTAV*FLOAT(JJ-ISTRTB)
        XTAIL= XHEAD+0.02*XAXDIS
        YTAIL= YHEAD-0.02*SINANG
C
C          THIS IS THE INITIALISATION SECTION.
C
   22   LOWER= .FALSE.
        IENDA= ISTOPA-ISTRTA+1
C
C          TEST FOR FIRST SECTION. IF NOT FIRST SECTION THEN TEST THE
C          VISIBILITY OF ALL POINTS ALONG THE SECTION BY COMPARING WITH
C          POINTS ON THE VISIBLE UPPER PROFILE <PROFUP>. THE UPDATED VISIBLE
C          PROFILE IS SAVED IN <TMPROF> UNTIL THE SCAN HAS BEEN COMPLETED.
C          THE CO-ORDINATES <XINSEC>,<YINSEC> ARE CALCULATED WHEN THE
C          SECTION BECOMES HIDDEN AND ARE STORED IN COMMON BLOCK <T0SINS>.
C          AS THE VALUES OF THE COORDINATES OF ALL POINTS LIE BETWEEN
C          0.0 AND 1.0, THE SIGN OF THE VALUES STORED IN <PROFUP> AND
C          <PROFLW> IS USED AS A FURTHER CONTROL ON VISIBILTY.
C
        IF (JJ.NE.ISTRTB) GO TO 27
C
C          FIRST SECTION DRAWN IN FULL. SET UPPER AND LOWER VISIBLE
C          PROFILES EQUAL TO THE INITIAL SECTION. DRAW VERTICAL LINES
C          FOR TOP SIDE SECTION IF <BASE>= .TRUE.. STORE VISIBILITY
C          AND CO-ORDINATES OF SECTION END IN ORDER TO JOIN EDGES
C          OF SECTION WHEN <ISECTN> IS NOT ZERO.
C
C          DRAW VERTICAL LINES OF BASE THROUGH FRONT SECTION IF
C          <ISECTN> IS NOT ZERO.
C
        IF (.NOT.BASE.OR.ISECTN.EQ.0) GO TO 24
C
        CALL LINCOL(LINCBS)
        NUMCOL= LINCBS
C
        DO 300 KK= 2,IENDA
          IF (AXMARK.AND.KK.EQ.2) GO TO 300
C
          K= IENDA-KK+2
          IMOD= MOD(K,2)
          IF (IMOD.LE.0) GO TO 23
C
          CALL POSITN(U(K),DELTAV*FLOAT(K-1))
          CALL JOIN(U(K),V(K))
          GO TO 300
C
   23     CALL POSITN(U(K),V(K))
          CALL JOIN(U(K),DELTAV*FLOAT(K-1))
  300   CONTINUE
C
C          LABEL THE AXIS IF REQUIRED.
C
   24   IF (.NOT.AXMARK.OR.INDAXE.GT.2) GO TO 25
        IF (MOD(INANOT,IDIVSR).NE.0) GO TO 25
        IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        CALL POSITN(XHEAD,YHEAD)
        CALL JOIN(XTAIL,YTAIL)
        IF (XAXDIS.GE.0.0) CALL TYPENI(INANOT)
        IF (XAXDIS.LT.0.0) CALL PLOTNI(XTAIL,YTAIL,INANOT)
   25   IF (.NOT.BASE.AND..NOT.AXMARK) GO TO 26
        IF (ISECTN.EQ.0.AND.XSECT) GO TO 26
C
C          DRAW CORNER VERTICAL OF BASE.
C
        LCOL= LINCUP
        IF (.NOT.AXMARK) LCOL= LINCBS
        IF (LCOL.NE.NUMCOL) CALL LINCOL(LCOL)
C
        NUMCOL= LCOL
        CALL POSITN(U(1),0.0)
        CALL JOIN(U(1),V(1))
C
C          DRAW INITIAL SECTION AND INITIALISE UPPER AND LOWER VISIBLE
C          PROFILES <PROFUP> AND <PROFLW> RESPECTIVELY.
C
   26   IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        CALL POSITN(U(1),V(1))
C
        DO 400 K= 2,IENDA
          CALL JOIN(U(K),V(K))
          PROFUP(K)= V(K-1)
          PROFLW(K)= PROFUP(K)
  400   CONTINUE
C
C          STORE END POINTS OF PROFILE.
C
        TMPROF(IENDA)= V(IENDA)
        PROFU1= TMPROF(IENDA)
        PROFL1= PROFU1
C
C          STORE VISIBILITY AND CO-ORDINATES OF SECTION END.
C
        UINVIS= .FALSE.
        LINVIS= .FALSE.
        GO TO 53
C
C          THE FOLLOWING DESCRIPTION OF THE ALGORITHM IS FOR THE CASE
C          WHERE SECTIONS ARE DRAWN PARALLEL TO THE X-AXIS, DIRECTIONS
C          ARE REVERSED FOR SECTIONS PARALLEL TO THE Y-AXIS.
C
C          SECTIONS ARE DRAWN IN ALTERNATE DIRECTIONS IN ORDER TO
C          OPTIMIZE PEN MOVEMENTS. THE VARIABLE <IDIR> IS SET EQUAL
C          TO 1 OR -1 DEPENDING UPON WHETHER THE SECTION IS DRAWN
C          FROM FRONT TO BACK OR BACK TO FRONT RESPECTIVELY. THE
C          FIRST POINT OF A SECTION IS ALWAYS VISIBLE AS A POINT ON
C          BOTH THE UPPER AND LOWER PROFILES AND IS SAVED IN BOTH.
C
   27   TMPROF(1)= V(1)
        PROFUP(1)= V(1)
        IF (IDIR.EQ.1) GO TO 29
C
C          DRAWING BACK TO FRONT: TEST VISIBILITY OF END POINT, JOIN
C          SECTION END WITH THE END OF THE PREVIOUS SECTION, UP-UPDATE
C          CO-ORDINATES AND STATE OF SECTION END. NOTE THAT THESE ENDS
C          ARE NOT ALWAYS VISIBLE AS THEY CAN FORM THE BACK EDGE.
C          <G0SUR3> IS USED TO FIND THE VISIBLE PART OF THIS EDGE.
C          THIS IS NOT THE CASE FOR THE FRONT EDGE WHICH IS ALWAYS
C          VISIBLE. THE EDGES ARE NOT DRAWN FOR ZERO <ISECTN> SINCE
C          IT IS AUTOMATICALLY FORMED BY SECTIONS IN THE ORTHOGONAL
C          DIRECTION.
C
        IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        INVIS= (V(IENDA).LT.ABS(PROFUP(IENDA)))
        IF (ISECTN.NE.0) CALL G0SUR3(ABS(PROFUP(IENDA)),PROFU1,V(IENDA),
     &                               VEND1,UEND1,INVIS,UINVIS)
C
        UINVIS= INVIS
        IF (.NOT.INVIS) GO TO 28
C
        TMPROF(IENDA)= -ABS(PROFUP(IENDA))
C
C          TEST FOR POINT ON LOWER PROFILE.
C
        IF (V(IENDA).LT.ABS(PROFLW(IENDA))) LOWER= .TRUE.
        GO TO 33
C
   28   TMPROF(IENDA)= V(IENDA)
        CALL POSITN(U(IENDA),V(IENDA))
        GO TO 33
C
C          DRAWING FRONT TO BACK, LABEL THE AXIS IF REQUIRED.
C
   29   IF (.NOT.AXMARK.OR.INDAXE.GT.2) GO TO 30
        IF (MOD(INANOT,IDIVSR).NE.0) GO TO 30
        IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        CALL POSITN(XHEAD,YHEAD)
        CALL JOIN(XTAIL,YTAIL)
        IF (XAXDIS.GE.0.0) CALL TYPENI(INANOT)
        IF (XAXDIS.LT.0.0) CALL PLOTNI(XTAIL,YTAIL,INANOT)
C
C          DRAW VERTICAL LINE FOR BASE AND FRONT EDGE
C          BETWEEN SECTION ENDS WHICH ARE ALWAYS VISIBLE.
C
   30   IF (.NOT.BASE) GO TO 31
        IF (AXMARK.AND.JJ.EQ.ISTOPB) GO TO 31
        IF (LINCBS.NE.NUMCOL) CALL LINCOL(LINCBS)
C
        NUMCOL= LINCBS
        CALL POSITN(U(1),DELTAV*FLOAT(JJ-ISTRTB))
        CALL JOIN(U(1),V(1))
   31   IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        IF (ISECTN.EQ.0) GO TO 32
C
        CALL POSITN(U(2),ABS(PROFUP(2)))
        CALL JOIN(U(1),V(1))
C
C          TEST VISIBILITY OF SECOND POINT ON SECTION, MOVE TO FIRST
C          POINT IF VISIBLE.
C
   32   INVIS= (V(2).LT.ABS(PROFUP(2)))
        IF (.NOT.INVIS) CALL POSITN(U(1),V(1))
C
C          SCAN ALONG SECTION STARTING AT SECOND POINT FROM END TESTING
C          THE VISIBILITY OF EACH POINT AGAINST THE VISIBLE PROFILE.
C          WHEN A LINE CHANGES FROM BEING VISIBLE TO HIDDEN OR
C          VICE-VERSA. NOTE IS TAKEN OF WHETHER SECTIONS ARE TO BE DRAWN
C          IN THE ORTHOGONAL DIRECTION. IF THIS IS THE CASE, CERTAIN
C          LINES ARE OMITTED AS THEY ARE HIDDEN BY THE ORTHOGONAL LINES.
C
   33   DO 500 KK= 2,IENDA
          K= KK
          IF (IDIR.EQ.-1) K= IENDA+1-KK
          IF ((V(K).LT.ABS(PROFUP(K)).AND.INVIS)) GO TO 40
          IF ((V(K).GE.ABS(PROFUP(K)).AND..NOT.INVIS)) GO TO 41
C
C          PART OF THE LINE BETWEEN <K-1> AND <K> IS HIDDEN. THE
C          COORDINATES <XINSEC>,<YINSEC> WHERE THE LINE BECOMES
C          HIDDEN ARE CALCULATED USING LINEAR INTERPOLATION.
C
          IF (IDIR.EQ.-1) GO TO 34
          CALL G0SUR2(ABS(PROFUP(K-1)),ABS(PROFUP(K)),V(K-1),V(K),U(K))
          GO TO 35
C
   34     CALL G0SUR2(ABS(PROFUP(K)),ABS(PROFUP(K+1)),V(K),V(K+1),
     &                U(K+1))
   35     IF (.NOT.INVIS) GO TO 38
C
C          LINE VISIBLE BETWEEN <XINSEC>,<YINSEC> AND POINT <K> WHICH
C          NOW BECOMES A POINT ON THE UPPER VISIBLE PROFILE.
C
          IF (IDIR.EQ.-1.AND.ISECTN.EQ.0.AND.
     &        PROFUP(K+1).GT.0.0) GO TO 36
C
          CALL POSITN(XINSEC,YINSEC)
          CALL JOIN(U(K),V(K))
          GO TO 37
C
   36     CALL POSITN(U(K),V(K))
   37     INVIS= .FALSE.
          TMPROF(K)= V(K)
          GO TO 500
C
C          LINE IS HIDDEN BETWEEN <XINSEC>,<YINSEC> AND POINT <K>.
C
   38     IF (IDIR.EQ.1.AND.ISECTN.EQ.0.AND.
     &        PROFUP(K).GT.0.0) GO TO 39
C
          CALL JOIN(XINSEC,YINSEC)
   39     INVIS= .TRUE.
C
C          THE LINE BETWEEN <K-1> OR <K+1> AND <K> IS COMPLETELY HIDDEN.
C
   40     TMPROF(K)= -ABS(PROFUP(K))
C
C          TEST FOR POINT ON LOWER PROFILE.
C
          IF (V(K).LE.ABS(PROFLW(K))) LOWER= .TRUE.
          GO TO 500
C
C          THE LINE BETWEEN <K-1> OR <K+1> AND <K> IS COMPLETELY VISIBLE.
C
   41     CALL JOIN(U(K),V(K))
          TMPROF(K)= V(K)
  500   CONTINUE
C
        IF (IDIR.EQ.-1) GO TO 42
C
C          JOIN END OF SECTION WITH END OF PREVIOUS SECTION TO FORM
C          BACK EDGE.
C
        IF (ISECTN.NE.0) CALL G0SUR3(ABS(PROFUP(IENDA)),PROFU1,V(IENDA),
     &                               VEND1,UEND1,INVIS,UINVIS)
        UINVIS= INVIS
        GO TO 45
C
C          JOIN END SECTIONS FOR FRONT EDGE AND VERTICAL SECTION FOR
C          BASE IF REQUIRED.
C
   42   IF (ISECTN.EQ.0) GO TO 43
C
        CALL POSITN(U(2),ABS(PROFUP(2)))
        CALL JOIN(U(1), V(1))
   43   IF (.NOT.BASE) GO TO 44
        IF (AXMARK.AND.JJ.EQ.ISTOPB) GO TO 44
        IF (LINCBS.NE.NUMCOL) CALL LINCOL(LINCBS)
C
        NUMCOL= LINCBS
        CALL POSITN(U(1), V(1))
        CALL JOIN(U(1),DELTAV*FLOAT(JJ-ISTRTB))
C
C          LABEL THE AXIS IF REQUIRED.
C
   44   IF (.NOT.AXMARK.OR.INDAXE.GT.2) GO TO 45
        IF (MOD(INANOT,IDIVSR).NE.0) GO TO 45
        IF (LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
C
        NUMCOL= LINCUP
        CALL POSITN(XHEAD,YHEAD)
        CALL JOIN(XTAIL,YTAIL)
        IF (XAXDIS.GE.0.0) CALL TYPENI(INANOT)
        IF (XAXDIS.LT.0.0) CALL PLOTNI(XTAIL,YTAIL,INANOT)
C
C          REVERSE THE SCAN DIRECTION.
C
   45   IDIR= -IDIR
C
C          UPDATE THE VISIBLE PROFILE.
C
        DO 600 K= 2,IENDA
          PROFUP(K)= TMPROF(K-1)
  600   CONTINUE
C
        PROFU1= ABS(TMPROF(IENDA))
C
C          INITIALISATION FOR LOWER PROFILE <PROFLW>. IF LOWER
C          SET TRUE THEN TEST FOR VISIBILITY AS ABOVE.
C
        PROFLW(1)= V(1)
        TMPROF(1)= V(1)
        IF (IUNDRS.EQ.0) GO TO 52
        IF (.NOT.LOWER) GO TO 51
C
C          POINT OCCURS ON LOWER PROFILE AND UNDERSIDE IS
C          TO BE DRAWN.  TEST FOR VISIBILITY OF
C          SECTION END TO DETERMINE THE STATE OF THE PEN.
C
        IF (LINCLW.NE.NUMCOL) CALL LINCOL(LINCLW)
C
        NUMCOL= LINCLW
        INVIS= V(IENDA).GT.ABS(PROFLW(IENDA))
        TMPROF(IENDA)= V(IENDA)
        IF (INVIS) TMPROF(IENDA)= -ABS(PROFLW(IENDA))
        IF (ISECTN.NE.0) CALL G0SUR3(ABS(PROFLW(IENDA)),PROFL1,V(IENDA),
     &                               VEND1,UEND1,INVIS,LINVIS)
        IF (.NOT.INVIS) CALL POSITN(U(IENDA),V(IENDA))
C
C          VISIBILITY OF BACK EDGE LOWER PROFILE IS STORED IN <LINVIS>.
C
        LINVIS= INVIS
C
C          SCAN IN DIRECTION <IDIR>= -1 TESTING VISIBILITY OF ALL
C          POINTS ALONG SECTION BY COMPARING WITH POINTS ON THE VISIBLE
C          LOWER PROFILE <PROFLW>. THE UP-DATED LOWER PROFILE IS STORED IN
C          <TMPROF> UNTIL THE SCAN HAS BEEN COMPLETED. CO-ORDINATES
C          <XINSEC>,<YINSEC> ARE CALCULATED AS FOR THE UPPER PROFILE.
C
        DO 700 KK= 2,IENDA
          K= IENDA-KK+1
          IF ((V(K).GE.ABS(PROFLW(K)).AND.INVIS)) GO TO 49
          IF ((V(K).LT.ABS(PROFLW(K)).AND..NOT.INVIS)) GO TO 50
C
          CALL G0SUR2(ABS(PROFLW(K)),ABS(PROFLW(K+1)),V(K),V(K+1),
     &                U(K+1))
          IF (.NOT.INVIS) GO TO 48
          IF (ISECTN.EQ.0.AND.PROFLW(K+1).GT.0.0) GO TO 46
C
          CALL POSITN(XINSEC,YINSEC)
          CALL JOIN(U(K),V(K))
          GO TO 47
C
   46     CALL POSITN(U(K),V(K))
   47     INVIS= .FALSE.
          TMPROF(K)= V(K)
          GO TO 700
C
   48     CALL JOIN(XINSEC,YINSEC)
          INVIS= .TRUE.
          TMPROF(K)= -ABS(PROFLW(K))
          GO TO 700
C
C          THE LINE BETWEEN <K+1> AND <K> IS COMPLETELY HIDDEN.
C
   49     TMPROF(K)= -ABS(PROFLW(K))
          GO TO 700
C
C          THE LINE BETWEEN <K+1> AND <K> IS COMPLETELY VISIBLE.
C
   50     CALL JOIN(U(K),V(K))
          TMPROF(K)= V(K)
  700   CONTINUE
C
C          UP-DATE LOWER VISIBLE PROFILE TO INCLUDE NEW VISIBLE POINTS.
C
        DO 800 K= 2,IENDA
          PROFLW(K)= TMPROF(K-1)
  800   CONTINUE
C
        PROFL1= ABS(TMPROF(IENDA))
        GO TO 53
C
C          IF PREVIOUS SECTION HAD POINTS ON THE LOWER VISIBLE PROFILE
C          THEN JOIN SECTION ENDS IF PREVIOUS SECTION END VISIBLE.
C
   51   IF (.NOT.LINVIS.AND.ISECTN.NE.0.AND..NOT.BASE)
     &       CALL G0SUR3(ABS(PROFLW(IENDA)),PROFL1,V(IENDA),
     &                             VEND1,UEND1,.TRUE.,LINVIS)
C
C          LOWER PROFILE IS NOT VISIBLE OR IS NOT DRAWN.
C          UP-DATE EDGE OF LOWER PROFILE.
C
   52   LINVIS= .TRUE.
        PROFL1= ABS(PROFLW(IENDA))
C
        DO 900 KK= 2,IENDA
          K= IENDA-KK+2
          PROFLW(K)= -ABS(PROFLW(K-1))
  900   CONTINUE
C
   53   UEND1= U(IENDA)
        VEND1= V(IENDA)
  100 CONTINUE
C
C          COMPLETE PROJECTION BY DRAWING BASE LINES.
C
      IF (.NOT.BASE.AND..NOT.AXMARK)  RETURN
      IF (ISECTN.EQ.0.AND.XSECT) RETURN
      IF (AXMARK.AND.LINCUP.NE.NUMCOL) CALL LINCOL(LINCUP)
      IF (.NOT.AXMARK.AND.LINCBS.NE.NUMCOL) CALL LINCOL(LINCBS)
C
      ABDELU= ABS(DELTAU)
      IF (IVIEWN.EQ.1.OR.IVIEWN.EQ.3) GO TO 54
C
      YAXMIN= DELTAV*YLEN
      YAXMN1= DELTAV*XLEN
      XAXPS1= ABDELU*YLEN
      XAXPS2= ABDELU*XLEN
      GO TO 55
C
   54 YAXMIN= DELTAV*XLEN
      YAXMN1= DELTAV*YLEN
      XAXPS1= ABDELU*XLEN
      XAXPS2= ABDELU*YLEN
C
   55 CALL POSITN(0.0,YAXMIN)
      CALL JOIN(XAXPS1,0.0)
      CALL JOIN(XAXPS1+XAXPS2,YAXMN1)
      IF (.NOT.AXMARK) RETURN
C
      YADD= (SURMAX-SURMIN)*SCALE*CSROOT*COSANG
      CALL JOIN(XAXPS1+XAXPS2,YAXMN1+YADD)
      CALL JOIN(XAXPS2,YAXMIN+YAXMN1+YADD)
      CALL JOIN(XAXPS2,TPCORN)
      CALL POSITN(XAXPS2,YAXMIN+YAXMN1+YADD)
      CALL JOIN(0.0,YAXMIN+YADD)
      CALL JOIN(0.0,YAXMIN)
C
C          ANNOTATE THE X AND Y AXES IF REQUIRED.
C
      IF (INDAXE.NE.3) GO TO 66
C
      GO TO (56,57,58,59), IRN
C
   56 Y1WND0= YAXORG+(ISTRTY-1)*YAXDEL
      Y2WND0= YAXORG+(ISTOPY-1)*YAXDEL
      GO TO 60
C
   57 Y1WND0= XAXORG+(ISTRTX-1)*XAXDEL
      Y2WND0= XAXORG+(ISTOPX-1)*XAXDEL
      GO TO 60
C
   58 Y1WND0= YAXORG+(ISTOPY-1)*YAXDEL
      Y2WND0= YAXORG+(ISTRTY-1)*YAXDEL
      GO TO 60
C
   59 Y1WND0= XAXORG+(ISTOPX-1)*XAXDEL
      Y2WND0= XAXORG+(ISTRTX-1)*XAXDEL
   60 AXSCAL= XAXPS1*DELTXY/(ABDELU*(Y2WND0-Y1WND0))
      CALL G0SUR4(1,Y1WND0,XAXPS1,0.0,XAXPS1*0.5-0.04,
     &            YAXMIN*0.2,AXSCAL)
      GO TO (61,62,63,64), IRN
C
   61 Y1WND0= XAXORG+(ISTRTX-1)*XAXDEL
      Y2WND0= XAXORG+(ISTOPX-1)*XAXDEL
      GO TO 65
C
   62 Y1WND0= YAXORG+(ISTOPY-1)*YAXDEL
      Y2WND0= YAXORG+(ISTRTY-1)*YAXDEL
      GO TO 65
C
   63 Y1WND0= XAXORG+(ISTOPX-1)*XAXDEL
      Y2WND0= XAXORG+(ISTRTX-1)*XAXDEL
      GO TO 65
C
   64 Y1WND0= YAXORG+(ISTRTY-1)*YAXDEL
      Y2WND0= YAXORG+(ISTOPY-1)*YAXDEL
   65 AXSCAL= XAXPS2*DELTXY/(ABDELU*(Y2WND0-Y1WND0))
      CALL G0SUR4(2,Y1WND0,XAXPS1,0.0,XAXPS1+XAXPS2*0.5,
     &            YAXMN1*0.2,AXSCAL)
C
C          ANNOTATE THE VERTICAL AXIS.
C
   66 Y1WND0= SURMIN
      Y2WND0= SURMAX
      CALL G0SUR4(3,SURMIN,0.0,YAXMIN,-0.04,YAXMIN+YADD*1.1,
     &            SCALE*CSROOT)
      Y1WND0= -0.5
      Y2WND0= 1.5
      IF (INDAXE.NE.2) RETURN
C
C          ADD SCALING INFORMATION.
C
      XSANOT= 0.12
      IF (XSHIFT.LT.0.5) XSANOT= 0.725
C
      CALL POSITN(XSANOT,0.055)
      CALL G3LINK(2,11,-8,ITYPE1,RDATA)
      CALL TYPENE(XAXORG,4)
      CALL POSITN(XSANOT,0.04)
      CALL G3LINK(2,11,-8,ITYPE2,RDATA)
      CALL TYPENE(YAXORG,4)
      CALL POSITN(XSANOT,0.025)
      CALL G3LINK(2,11,-8,ITYPE3,RDATA)
      CALL TYPENE(XAXDEL,4)
      CALL POSITN(XSANOT,0.01)
      CALL G3LINK(2,11,-8,ITYPE4,RDATA)
      CALL TYPENE(YAXDEL,4)
      RETURN
      END
      SUBROUTINE G0TICK
C
C          ------------------------------------------------
C          ROUTINE NO. ( 232)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          GIVEN THE AXIS AND ITS POSITION, THIS CALCULATES THE
C          END-POSITIONS OF THE TICK MARKS SUCH THAT THEY ALWAYS
C          APPEAR TO BE 8/1000 AND 5/1000 OF THE CURRENT WINDOW SIZE,
C          NO MATTER WHICH KIND OF MAPPING IS CURRENTLY BEING USED.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <KAXIS>  GIVES THE CURRENT AXIS BY ITS MODULUS:
C                   = 1 FOR THE X-AXIS, AND
C                   = 2 FOR THE Y-AXIS.
C          <AXPOSX> IS THE POSITION OF THE X-AXIS ALONG Y.
C          <AXPOSY> IS THE POSITION OF THE Y-AXIS ALONG X.
C
C
C          THE FOLLOWING ARGUMENTS ARE RETURNED THROUGH COMMON:
C
C          <TKEN1A> AND
C          <TKEN1B> ARE THE END-POINTS OF THE 5/1000TH.-SIZE TICK MARK.
C          <TKEN2A> AND
C          <TKEN2B> ARE THE END-POINTS OF THE 8/1000TH.-SIZE TICK MARK.
C
C
c slmod begin
      COMMON /T0MAPD/ X1MAPD,X2MAPD,Y1MAPD,Y2MAPD
c slmod end
      COMMON /T0AARG/ KAXIS
      COMMON /T0APOS/ AXPOSX,AXPOSY
      COMMON /T0ATIK/ TKEN1A,TKEN1B,TKEN2A,TKEN2B
      COMMON /T0MAPT/ MAPNO0
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
C
      ENDTKX(DY,Y1WND0,Y2WND0)= AXPOSX*((Y1WND0/Y2WND0)**DY)
      ENDTKY(DX,X1WND0,X2WND0)= AXPOSY*((X1WND0/X2WND0)**DX)
C
C
      IF (IABS(KAXIS).NE.1) GO TO 2
C
C          THIS SECTION FINDS THE X-AXIS TICK MARKS
C          FOR EITHER LINEAR OR LOGARITHMIC Y-MAPPING.
C
      IF (MAPNO0.EQ.2.OR.MAPNO0.EQ.4) GO TO 1
C
c slmod begin
c...  Make the tick marks the same size even if the plot is not
c     square:
      TIKL= 0.005*(Y2WND0-Y1WND0)*(X2MAPD-X1MAPD)/(Y2MAPD-Y1MAPD)
c
c      TIKL= 0.005*(Y2WND0-Y1WND0)
c slmod end
      TKEN1A= AXPOSX+TIKL
      TKEN1B= AXPOSX-TIKL
      TKEN2A= AXPOSX+1.6*TIKL
      TKEN2B= AXPOSX-1.6*TIKL
      RETURN
C
    1 TKEN1A= ENDTKX(0.005,Y2WND0,Y1WND0)
      TKEN1B= ENDTKX(0.005,Y1WND0,Y2WND0)
      TKEN2A= ENDTKX(0.008,Y2WND0,Y1WND0)
      TKEN2B= ENDTKX(0.008,Y1WND0,Y2WND0)
      RETURN
C
C          THIS SECTION FINDS THE Y-AXIS TICK MARKS
C          FOR EITHER LINEAR OR LOGARITHMIC X-MAPPING.
C
    2 IF (MAPNO0.EQ.3.OR.MAPNO0.EQ.4) GO TO 3
C
c slmod begin
c      TIKL= MAX(0.005*(Y2WND0-Y1WND0),0.005*(X2WND0-X1WND0))
c
      TIKL= 0.005*(X2WND0-X1WND0)
c slmod end
      TKEN1A= AXPOSY+TIKL
      TKEN1B= AXPOSY-TIKL
      TKEN2A= AXPOSY+1.6*TIKL
      TKEN2B= AXPOSY-1.6*TIKL
      RETURN
C
    3 TKEN1A= ENDTKY(0.005,X2WND0,X1WND0)
      TKEN1B= ENDTKY(0.005,X1WND0,X2WND0)
      TKEN2A= ENDTKY(0.008,X2WND0,X1WND0)
      TKEN2B= ENDTKY(0.008,X1WND0,X2WND0)
      RETURN
      END
      SUBROUTINE G0VECS(XPT,YPT,NPTS)
C
C          ------------------------------------------------
C          ROUTINE NO. (  77)   VERSION (A8.5)    25:NOV:86
C          ------------------------------------------------
C
C          THIS GENERATES A SERIES OF SHORT VECTORS
C          FROM A GIVEN SET OF X AND Y COORDINATES.
C
C
C          [XPT]    ARE THE X-COORDINATES AND
C          [YPT]    ARE THE Y-COORDINATES OF THE POINTS,
C          <NPTS>   IS THE NUMBER OF POINTS GIVEN.
C
C
      REAL    RDATA(1),XPT(NPTS),YPT(NPTS),SCALE(2)
      INTEGER IDATA(1),ISHVEC(254)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3NBYR/ NBYTR
C
      DATA RDATA /0.0/, IDATA /0/
C
C
C          IF THERE ARE LESS THAN TWO POINTS, THE SUBROUTINE EXITS.
C          IF THERE ARE ONLY TWO POINTS, A STRAIGHT LINE IS DRAWN.
C
      NVECS= NPTS-1
      IF (NVECS.LE.0) RETURN
      IF (NVECS.GT.126) NVECS= 126
C
      CALL POSITN(XPT(1),YPT(1))
      IF (NVECS.EQ.1) GO TO 1
C
C          THE MAXIMUM X AND Y VECTORS ARE FOUND AND USED
C          TO CALCULATE THE SCALE FACTORS, WHICH ARE STORED.
C
      VXMAX= 0.0
      VYMAX= 0.0
C
      DO 100 ITEST= 1,NVECS
        XVEC= ABS(XPT(ITEST+1)-XPT(ITEST))
        IF (XVEC.GT.VXMAX) VXMAX= XVEC
C
        YVEC= ABS(YPT(ITEST+1)-YPT(ITEST))
        IF (YVEC.GT.VYMAX) VYMAX= YVEC
  100 CONTINUE
C
      SCALE(1)= VXMAX/127.0
      SCALE(2)= VYMAX/127.0
      IF (ABS(SCALE(1)).LT.RMINI) SCALE(1)= 1.0
      IF (ABS(SCALE(2)).LT.RMINI) SCALE(2)= 1.0
C
      CALL G3LINK(0,6,2*NBYTR,IDATA,SCALE)
C
C          THE SERIES OF SHORT VECTORS IS THEN CALCULATED,
C          (ZERO LENGTH VECTORS ARE OMITTED) AND STORED.
C
      IXOLD= 0
      IYOLD= 0
      INDEX= 1
C
      DO 200 IPT= 1,NVECS
        IXVEC= (XPT(IPT+1)-XPT(1))/SCALE(1)+0.5
        IYVEC= (YPT(IPT+1)-YPT(1))/SCALE(2)+0.5
        IF (IXVEC.EQ.IXOLD.AND.IYVEC.EQ.IYOLD) GO TO 200
C
        ISHVEC(INDEX)=   IXVEC-IXOLD+128
        ISHVEC(INDEX+1)= IYVEC-IYOLD+128
        INDEX= INDEX+2
        IXOLD= IXVEC
        IYOLD= IYVEC
  200 CONTINUE
C
      INDEX= INDEX-1
      CALL G3LINK(0,7,-INDEX,ISHVEC,RDATA)
C
C          A LINE IS THEN DRAWN TO THE FINAL POSITION.
C
      XPLOT0= XPLOT0+IXOLD*SCALE(1)
      YPLOT0= YPLOT0+IYOLD*SCALE(2)
    1 CALL JOIN(XPT(NPTS),YPT(NPTS))
C
      RETURN
      END
      SUBROUTINE BOX(XLL,XUR,YLL,YUR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  79)   VERSION (A8.4)    14:JUL:88
C          ------------------------------------------------
C
C          THIS DRAWS THE SPECIFIED RECTANGLE.
C
C
C          <XLL,YLL>  IS THE LOWER LEFT CORNER, AND
C          <XUR,YUR>  IS THE UPPER RIGHT CORNER.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0DBND/ IDRBND
      COMMON /T0KFIL/ KOLFL0
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
      DATA RDATA /0.0/
C
C
      RTRAC1= XLL
      RTRAC2= XUR
      RTRAC3= YLL
      RTRAC4= YUR
      IF (IPRINT.EQ.1) CALL G0MESG(31,4)
C
C          THE CURRENT PLOTTING POSITION IS SAVED,
C          THE BOX IS DRAWN, THEN THE POSITION IS RESET.
C
      XHERE= XPLOT0
      YHERE= YPLOT0
      IF (KOLFL0.EQ.0) GO TO 1
C
      IDATA(1)= 0
      IF (KOLFL0.LT.0) IDATA(1)= 1
C
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      IDATA(1)= IABS(KOLFL0)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XLL,YLL)
      CALL   JOIN(XUR,YLL)
      CALL   JOIN(XUR,YUR)
      CALL   JOIN(XLL,YUR)
      CALL   JOIN(XLL,YLL)
      CALL G3LINK(5,4,0,IDATA,RDATA)
      IF (IDRBND.EQ.0) GO TO 2
C
    1 CALL POSITN(XLL,YLL)
      CALL   JOIN(XUR,YLL)
      CALL   JOIN(XUR,YUR)
      CALL   JOIN(XLL,YUR)
      CALL   JOIN(XLL,YLL)
    2 CALL POSITN(XHERE,YHERE)
C
      RETURN
      END
      SUBROUTINE CTRFNT(KFONT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 175)   VERSION (A8.5)    08:MAR:89
C          ------------------------------------------------
C
C          THIS SETS THE SUBSEQUENT CHARACTER FONT NO.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CFON/ KFONT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
      ITRAC1= KFONT
      IF (IPRINT.EQ.1) CALL G0MESG(111,5)
      IF (KFONT.LT.0.OR.KFONT.GT.25) RETURN
      IF (KFONT.GT.3.AND.KFONT.LT.11) RETURN
C
      KFONT0= KFONT
      IDATA(1)= KFONT0
      CALL G3LINK(2,2,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CTROBL(OBLAT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 176)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE WIDTH OF A CHAR. RELATIVE TO ITS HEIGHT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
C
      RTRAC1= OBLAT
      IF (IPRINT.EQ.1) CALL G0MESG(112,1)
C
      OBLAT0= ABS(OBLAT)
      RDATA(1)= OBLAT0
      CALL G3LINK(2,8,NBYTR,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE CTRSIZ(SIZE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 143)   VERSION (A8.5)    18:APR:88
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT CHARACTER SIZE IN UNITS OF
C          1/1000 OF THE PLOTTER-SPACE Y-AXIS SIDE LENGTH).
C
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSIZ/ CSIZE,MRKSIZ
      COMMON /T0MAPP/ X1MAP0,X2MAP0,Y1MAP0,Y2MAP0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
C
C
      CALL G3INIT(2)
      RTRAC1= SIZE
      IF (IPRINT.EQ.1) CALL G0MESG(54,1)
C
      IPRSAV= IPRINT
      IPRINT= 0
      CSIZE= SIZE
      MAGN0= MIN1(255.0,ABS(CSIZE*1000.0/(Y2MAP0-Y1MAP0))+0.5)
      CALL CTRMAG(MAGN0)
      MRKSIZ= 1
      IPRINT= IPRSAV
C
      RETURN
      END
      SUBROUTINE ENQCHR(IPARAM,RPARAM)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 257)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS RETURNS CURRENT CHARACTER PARAMETERS.
C
C
      REAL    RPARAM(9)
      INTEGER IPARAM(10)
C
C
      COMMON /T0CANG/ STANG0,CRANG0
      COMMON /T0CATT/ IUNDL0,ITAL0
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CFON/ KFONT0
      COMMON /T0CSIZ/ CSIZE,MRKSIZ
      COMMON /T0CSLO/ SLOPE,MRKSLP
      COMMON /T0CSPA/ X1CHR0,X2CHR0,Y1CHR0,Y2CHR0
      COMMON /T0CVIS/ KWIND0,KMASK0
      COMMON /T0HRDC/ KHRDW0
      COMMON /T0MRKS/ MARKC0
C
C
      IPARAM( 1)= KFONT0
      IPARAM( 2)= MAGN0
      IPARAM( 3)= MRKSIZ
      IPARAM( 4)= ITAL0
      IPARAM( 5)= IUNDL0
      IPARAM( 6)= MRKSLP
      IPARAM( 7)= MARKC0
      IPARAM( 8)= KWIND0
      IPARAM( 9)= KMASK0
      IPARAM(10)= KHRDW0
C
      RPARAM(1)= X1CHR0
      RPARAM(2)= X2CHR0
      RPARAM(3)= Y1CHR0
      RPARAM(4)= Y2CHR0
      RPARAM(5)= CSIZE
      RPARAM(6)= OBLAT0
      RPARAM(7)= STANG0
      RPARAM(8)= CRANG0
      RPARAM(9)= SLOPE
C
      RETURN
      END
      SUBROUTINE HLINFD(NHALFS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 156)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DOES <NHALFS> HALF-SPACED LINEFEEDS
C          IN EITHER A POSITIVE OR A NEGATIVE DIRECTION.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NHALFS
      IF (IPRINT.EQ.1) CALL G0MESG(67,5)
C
      IF (NHALFS.EQ.0) RETURN
C
      IDATA(1)= 6
      IDATA(2)= NHALFS
      IF (NHALFS.GT.0) GO TO 1
C
      IDATA(1)= 8
      IDATA(2)= -NHALFS
    1 CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE HSPACE(NHALFS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 154)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DOES <NHALFS> HALF-SPACES ALONG THE CURRENT LINE
C          IN EITHER A POSITIVE OR A NEGATIVE DIRECTION.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NHALFS
      IF (IPRINT.EQ.1) CALL G0MESG(65,5)
C
      IF (NHALFS.EQ.0) RETURN
C
      IDATA(1)= 2
      IDATA(2)= NHALFS
      IF (NHALFS.GT.0) GO TO 1
C
      IDATA(1)= 4
      IDATA(2)= -NHALFS
    1 CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE ITALIC(ITAL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 146)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS CHARACTERS AS UPRIGHT OR ITALIC.
C
C
C          <ITAL>   CONTROLS THE CHARACTER STYLE:
C                   ZERO, IT IS UPRIGHT FORM, OR
C                   NON-ZERO, IT IS ITALIC FORM.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CATT/ IUNDL0,ITAL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= ITAL
      IF (IPRINT.EQ.1) CALL G0MESG(57,5)
C
      ITAL0= 0
      IF (ITAL.NE.0) ITAL0= 1
      IDATA(1)= ITAL0
      CALL G3LINK(2,6,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE LINCOL(NCOLOR)
C
C          ------------------------------------------------
C          ROUTINE NO. (  61)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT LINE COLOUR.
C
C
C          THE ARGUMENT IS AS FOLLOWS:
C
C          <NCOLOR> IS THE REQUIRED COLOUR NUMBER.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0LATT/ KOLIN0,ITHIK0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NCOLOR
      IF (IPRINT.EQ.1) CALL G0MESG(138,5)
C
      IF (NCOLOR.LT.0.OR.NCOLOR.GT.255) RETURN
      KOLIN0= NCOLOR
      IDATA(1)= KOLIN0
      CALL G3LINK(3,9,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE PCSCEN(X,Y,PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 164)   VERSION (A7.5)    11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING <PHRASE> WITH
C          THE MIDDLE CHARACTER PLACED AT THE POSITION <X,Y>.
C
C
      CHARACTER PHRASE*(*)
C
C
      CALL POSITN(X,Y)
      CALL TCSCEN(PHRASE)
C
      RETURN
      END
      SUBROUTINE SUFFIX
C
C          ------------------------------------------------
C          ROUTINE NO. ( 148)   VERSION (A8.5)    04:MAR:91
C          ------------------------------------------------
C
C          THIS SETS CONDITIONS FOR SUFFIX CHARACTER STRINGS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0SUPF/ MAGBUF(5),MAGLVL
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      ITRAC1= MAGLVL
      IF (IPRINT.EQ.1) CALL G0MESG(59,5)
C
C          THE BUFFER LEVEL IS TESTED FOR OVERFLOW:
C          IF SO, AN ERROR MESSAGE IS PRINTED;
C          OTHERWISE, THE BUFFER LEVEL IS INCREMENTED,
C          THE NEW MAGNIFICATION IS CALCULATED AND THEN SET.
C          THE SIGN OF THE MAGNIFICATION STORED IN THE BUFFER
C          INDICATES THAT THIS LEVEL WAS A SUFFIX.
C
      IF (MAGLVL.GE.5) GO TO 901
C
      IPRSAV= IPRINT
      IPRINT= 0
C
      IDATA(1)= 6
      IDATA(2)= 1
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IDATA(1)= 4
      CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      MAGLVL= MAGLVL+1
      MAGBUF(MAGLVL)= -IABS(MAGN0)
      MAG= (MAGN0*5+4)/8
      CALL CTRMAG(MAG)
      IDATA(1)= 2
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 15
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE TYPENC(NCHAR)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 158)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS CHARACTER NO. <NCHAR> AT THE CURRENT POSITION.
C
C
C          THIS VERSION IS SUITABLE FOR MACHINES WITH
C          ANY TYPE OF CHARACTER CODING, BUT DOES NOT
C          SUPPORT ANY OF THE OLD GHOST CHARACTER SETS.
C
C          CHARACTERS ARE HELD IN: [CHAR]
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      DATA RDATA(1) /0.0/
C
C
      IDATA(1)= NCHAR
      IF (NCHAR.LT.0.OR.NCHAR.GT.255) IDATA(1)= 32
C
      CALL G3LINK(2,11,-1,IDATA,RDATA)
      RETURN
      END
      SUBROUTINE TYPENE(VALUE,NAFTDP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 168)   VERSION (A8.5)    11:FEB:87
C          ------------------------------------------------
C
C          THIS DRAWS OUT THE GIVEN NUMBER <VALUE> IN EXPONENT
C          FORMAT, WITH <NAFTDP> DIGITS AFTER THE DECIMAL POINT.
C
C
      DOUBLE PRECISION DVALUE,VALNRM
      REAL    RDATA(1)
      INTEGER IDATA(20)
      LOGICAL ERRON
C
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA ISPACE /32/, MINUS /45/, IPOINT /46/, IZERO /48/, IELETR /69/
      DATA RDATA /0.0/
C
C
      IF (NAFTDP.LE.0) GO TO 901
C
      IDATA(1)= ISPACE
      IF (VALUE.LT.0.0) IDATA(1)= MINUS
C
      IDATA(2)= IZERO
      IDATA(3)= IPOINT
C
C          IF THE NUMBER IS ZERO, THE FIELD IS FILLED WITH ZEROES;
C          OTHERWISE, THE VALUE IS ROUNDED TO THE REQUIRED NO. OF
C          PLACES AND THE DECIMAL EXPONENT IS CALCULATED. ACCOUNT
C          IS TAKEN OF THE CASE WHERE ROUNDING BRINGS THE NUMBER
C          UP TO THE NEXT-HIGHER DECADE, AND NEGATIVE NUMBERS
C          ROUNDED TO ZERO HAVE THE MINUS SIGN SUPPRESSED.
C
C          THE MANTISSA IS CONVERTED AND STORED IN THE CHARACTER
C          STRING, FOLLOWED BY THE LETTER 'E' AND THE EXP. SIGN.
C          THE EXPONENT IS THEN CONVERTED AND STORED (TWO DIGITS
C          ARE ALWAYS DONE; A LEADING ZERO IS ADDED IF NECESSARY).
C
      DVALUE= ABS(VALUE)
      IEXP= 0
      IF (ABS(VALUE).GT.RMINI) GO TO 1
C
      DO 100 IFILL= 1,NAFTDP
        IDATA(IFILL+3)= IZERO
  100 CONTINUE
C
      GO TO 3
C
    1 IEXP= DLOG10(DVALUE)
      IF (DVALUE.GE.1.0D0) IEXP= IEXP+1
C
      VALNRM= DVALUE*(10.0D0**(NAFTDP-IEXP))
      VALNRM= VALNRM+0.5D0
      NRMVAL= VALNRM
      IF (IDINT(DLOG10(VALNRM)).LT.NAFTDP) GO TO 2
C
      IEXP= IEXP+1
      NRMVAL= NRMVAL/10
    2 IF (NRMVAL.EQ.0) IDATA(1)= ISPACE
C
      INDEX= 4
      CALL G0CONI(NRMVAL,IDATA,INDEX)
    3 NCHARS= NAFTDP+4
      IDATA(NCHARS)= IELETR
      IDATA(NCHARS+1)= ISPACE
      IF (IEXP.LT.0) IDATA(NCHARS+1)= MINUS
C
      IDATA(NCHARS+2)= IZERO
      INDEX= NCHARS+3
      IF (IABS(IEXP).GE.10) INDEX= INDEX-1
C
      CALL G0CONI(IEXP,IDATA,INDEX)
      NCHARS= INDEX-1
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 31
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE UNDLIN(NLINES)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 147)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS FOR CHARACTER UNDERLINING.
C
C
C          <NLINES> GIVES THE NO. OF UNDERLINES.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CATT/ IUNDL0,ITAL0
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= NLINES
      IF (IPRINT.EQ.1) CALL G0MESG(58,5)
C
      IUNDL0= NLINES
      IF (IUNDL0.LT.0) IUNDL0= 0
      IF (IUNDL0.GT.2) IUNDL0= 2
      IDATA(1)= IUNDL0
      CALL G3LINK(2,7,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE G0CFL2(XBASE1,XBASE2,XVERT,YBASE1,YBASE2,YVERT,VBASE1,
     &                  VBASE2,VERTEX,CLEVLS,ISTRTL,ISTOPL,NQUADS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 186)   VERSION (A8.1)    24:APR:91
C          ------------------------------------------------
C
      REAL CLEVLS(ISTOPL)
C
      DATA DUM /0.0/
C
C
C          SET JSIN TO  1 IF THE LOWEST AREA IS A QUADRILATERAL.
C          SET JSIN TO -1 IF THE LOWEST AREA IS A TRIANGLE.
C
      JSIN= -1
      VBASE= AMAX1(VBASE1,VBASE2)
      IF (VBASE.GT.VERTEX) GO TO 1
C
      JSIN= 1
      VBASE= AMIN1(VBASE1,VBASE2)
C
C          FIND THE FIRST CONTOUR HEIGHT.
C
    1 INDCL=1
      KOLIND= 1
C
      DO 100 I= ISTRTL,ISTOPL
        IF(VBASE.LT.CLEVLS(I)) GO TO 100
C
        INDCL= INDCL+1
        KOLIND= KOLIND+1
  100 CONTINUE
C
      INDCL= INDCL+(JSIN-1)/2
      XP1= XBASE1
      YP1= YBASE1
      XP2= XBASE2
      YP2= YBASE2
C
C          DO NQUADS QUADRILATERALS.
C
      DO 200 J= 1,NQUADS
        FACTOR= (CLEVLS(INDCL)-VERTEX)/(VERTEX-VBASE1)
        XQ1= XVERT+(XVERT-XBASE1)*FACTOR
        YQ1= YVERT+(YVERT-YBASE1)*FACTOR
        FACTOR= (CLEVLS(INDCL)-VERTEX)/(VERTEX-VBASE2)
        XQ2= XVERT+(XVERT-XBASE2)*FACTOR
        YQ2= YVERT+(YVERT-YBASE2)*FACTOR
        CALL G0CFL5(KOLIND,4,XP1,XQ1,XQ2,XP2,DUM,YP1,YQ1,YQ2,YP2,DUM)
        INDCL= INDCL+JSIN
        KOLIND= KOLIND+JSIN
        XP1= XQ1
        YP1= YQ1
        XP2= XQ2
        YP2= YQ2
  200 CONTINUE
C
C          DO FINAL TRIANGLE.
C
      CALL G0CFL5(KOLIND,3,XP1,XP2,XVERT,DUM,DUM,YP1,YP2,
     &            YVERT,DUM,DUM)
C
      RETURN
      END
      SUBROUTINE G0CFL3(X1,X2,X3,Y1,Y2,Y3,V1,V2,V3,CLEVLS,ISTRTL,
     &                  ISTOPL,NQ1,NQ2)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 187)   VERSION (A8.1)    24:APR:91
C          ------------------------------------------------
C
C          ALL THREE SIDES ARE CROSSED BY CONTOUR LINES,AND LINE '12'
C          IS CROSSED BY ALL LINES.  VERTEX 2 HAS THE LOWEST VERTEX-VALUE.
C          LINE '23' AND LINE '12' HAVE NQ1 INTERNAL QUADRILATERALS.
C          LINE '31' AND LINE '12' HAVE NQ2 INTERNAL QUADRILATERALS.
C
      REAL CLEVLS(ISTOPL)
C
      DATA DUM /0.0/
C
C
C          FIND THE COLOUR AND THE FIRST CONTOUR HEIGHT.
C
      INDCL= 1
C
      DO 100 I= ISTRTL,ISTOPL
        IF (V2.GT.CLEVLS(I)) INDCL= INDCL+1
  100 CONTINUE
C
C          DO FIRST TRIANGLE.
C
      FACTOR= (CLEVLS(INDCL)-V3)/(V3-V2)
      XP1= X3+(X3-X2)*FACTOR
      YP1= Y3+(Y3-Y2)*FACTOR
      FACTOR= (CLEVLS(INDCL)-V1)/(V1-V2)
      XP2= X1+(X1-X2)*FACTOR
      YP2= Y1+(Y1-Y2)*FACTOR
      CALL G0CFL5(INDCL,3,XP1,XP2,X2,DUM,DUM,YP1,YP2,Y2,DUM,DUM)
      INDCL= INDCL+1
C
C          DO NQ1 QUADRILATERALS.
C
      IF (NQ1.LT.1) GO TO 1
C
      DO 200 J= 1,NQ1
        FACTOR= (CLEVLS(INDCL)-V3)/(V3-V2)
        XQ1= X3+(X3-X2)*FACTOR
        YQ1= Y3+(Y3-Y2)*FACTOR
        FACTOR= (CLEVLS(INDCL)-V1)/(V1-V2)
        XQ2= X1+(X1-X2)*FACTOR
        YQ2= Y1+(Y1-Y2)*FACTOR
        CALL G0CFL5(INDCL,4,XP1,XP2,XQ2,XQ1,DUM,YP1,YP2,YQ2,YQ1,DUM)
        INDCL= INDCL+1
        XP1=XQ1
        YP1=YQ1
        XP2=XQ2
        YP2=YQ2
  200 CONTINUE
C
C          DO THE PENTAGON.
C
    1 FACTOR= (CLEVLS(INDCL)-V1)/(V1-V3)
      XQ1= X1+(X1-X3)*FACTOR
      YQ1= Y1+(Y1-Y3)*FACTOR
      FACTOR= (CLEVLS(INDCL)-V1)/(V1-V2)
      XQ2= X1+(X1-X2)*FACTOR
      YQ2= Y1+(Y1-Y2)*FACTOR
      CALL G0CFL5(INDCL,5,XP1,XP2,XQ2,XQ1,X3,YP1,YP2,YQ2,YQ1,Y3)
      INDCL= INDCL+1
      XP1=XQ1
      YP1=YQ1
      XP2=XQ2
      YP2=YQ2
C
C          DO NQ2 QUADRILATERALS.
C
      IF (NQ2.LT.1) GO TO 2
C
      DO 300 I= 1,NQ2
        FACTOR= (CLEVLS(INDCL)-V1)/(V1-V3)
        XQ1= X1+(X1-X3)*FACTOR
        YQ1= Y1+(Y1-Y3)*FACTOR
        FACTOR= (CLEVLS(INDCL)-V1)/(V1-V2)
        XQ2= X1+(X1-X2)*FACTOR
        YQ2= Y1+(Y1-Y2)*FACTOR
        CALL G0CFL5(INDCL,4,XP1,XP2,XQ2,XQ1,DUM,YP1,YP2,YQ2,YQ1,DUM)
        INDCL= INDCL+1
        XP1=XQ1
        YP1=YQ1
        XP2=XQ2
        YP2=YQ2
  300 CONTINUE
C
C          DO THE LAST TRIANGLE.
C
    2 CALL G0CFL5(INDCL,3,XP1,XP2,X1,DUM,DUM,YP1,YP2,Y1,DUM,DUM)
C
      RETURN
      END
      SUBROUTINE G0CFL4(VP,VQ,CLEVLS,ISTRTL,ISTOPL,NINTS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 188)   VERSION (A8.1)    22:APR:91
C          ------------------------------------------------
C
C          THIS FINDS THE NUMBER OF CONTOURS THAT INTERSECT A LINE.
C
C
      REAL CLEVLS(ISTOPL)
C
C
      VLO= AMIN1(VP,VQ)
      VHI= AMAX1(VP,VQ)
      NINTS= 0
C
      DO 100 I= ISTRTL,ISTOPL
        IF (VLO.LT.CLEVLS(I).AND.VHI.GT.CLEVLS(I)) NINTS= NINTS+1
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE G0CPLT(XPLOTB,YPLOTB,INOTAT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 127)   VERSION (A8.2)    19:FEB:87
C          ------------------------------------------------
C
C          THIS DRAWS STRAIGHT OR CURVED CONTOUR LINES.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <XPLOTB>  IS THE POSITION X-COORDINATE.
C          <YPLOTB>  IS THE POSITION Y-COORDINATE.
C          <INOTAT>  IS THE ANOTATION INDICATOR.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1),ICOPY(10),ITEXT(255)
      LOGICAL OPENCO,FRSTPT,LASTPT,CURVED
C
      COMMON /T0CEND/ FRSTPT,LASTPT
      COMMON /T0CLBL/ LLBCON
      COMMON /T0CLEV/ LEVEL,HEIGHT
      COMMON /T0CNLB/ LBLCON(10,50)
      COMMON /T0CNSV/ XPOSNS(100),YPOSNS(100),NCOPTS
      COMMON /T0CTYP/ OPENCO,CURVED
      COMMON /T0NOTC/ NOTATC
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3SPAC/ ISPACE(1)
C
      DATA RDATA /0.0/
C
C
c slmod begin
      COMMON /CONCON/ icon,iconcol,xcon,ycon
      INTEGER icon,iconcol
      REAL    xcon(2048),ycon(2048)

      IF (FRSTPT.AND.icon.EQ.0) THEN
        icon = 1
      ELSE
        icon = icon + 1
c        WRITE(0,*) 'ICON:',icon,xplotb,yplotb
      ENDIF
      xcon(icon) = xplotb
      ycon(icon) = yplotb

c...  THIS TURNS OFF THE LINES IN CONTOUR LINE PLOTS!
      RETURN
c slmod end
      IF (CURVED) GO TO 2
C
C          THIS SECTION IS FOR STRAIGHT LINES.
C
      IF (.NOT.FRSTPT) GO TO 1
C
      CALL POSITN(XPLOTB,YPLOTB)
      IF (NOTATC.GT.0) GO TO 5
      RETURN
C
    1 CALL JOIN(XPLOTB,YPLOTB)
      IF (LASTPT.AND.OPENCO.AND.NOTATC.GT.0) GO TO 5
      RETURN
C
C          THIS SECTION IS FOR CURVED LINES.
C
    2 IF (.NOT.FRSTPT) GO TO 3
C
      CALL POSITN(XPLOTB,YPLOTB)
      XPOSNS(1)= XPLOTB
      YPOSNS(1)= YPLOTB
      NCOPTS= 1
      IF (NOTATC.GT.0) GO TO 5
      RETURN
C
    3 IF (NCOPTS.LT.100) GO TO 4
C
      CALL CURVEO(XPOSNS,YPOSNS,1,100)
      XPOSNS(1)= XPOSNS(100)
      YPOSNS(1)= YPOSNS(100)
      NCOPTS= 1
    4 NCOPTS= NCOPTS+1
      XPOSNS(NCOPTS)= XPLOTB
      YPOSNS(NCOPTS)= YPLOTB
      IF (.NOT.LASTPT) RETURN
C
      CALL CURVEO(XPOSNS,YPOSNS,1,NCOPTS)
      IF (.NOT.OPENCO.OR.NOTATC.LE.0) RETURN
C
C          THIS SECTION WRITES THE ANNOTATION ON THE CONTOURS.
C          ANNOTATION IS ONLY DONE ON THE CURRENT CONTOUR
C          IF THE VALUE OF <NOTDEV> IS ODD.
C
C          THE VALUE OF INOTAT INDICATES THE BORDER BEING INTERSECTED.
C          IT TAKES THE FOLLOWING VALUES:
C          0  INTERNAL CONTOURS
C          1  THE LEFT EDGE,  2  THE RIGHT EDGE,
C          3  THE TOP EDGE,   4  THE BOTTOM EDGE.
C
    5 NOTDEV= NOTATC/2**(INOTAT+1)
      IF (MOD(NOTDEV,2).NE.1) RETURN
      IF (LLBCON.GT.0) GO TO 7
C
C          THIS SECTION WRITES THE CONTOUR LEVEL NUMBER.
C
      IF (INOTAT.GT.1) GO TO 6
C
      CALL PLOTNI(XPLOTB,YPLOTB,LEVEL)
      RETURN
C
    6 IF (INOTAT.EQ.3) CALL LINEFD(-1)
      IF (INOTAT.EQ.4) CALL LINEFD(1)
      IF (INOTAT.GE.3) CALL SPACE(-1)
      CALL TYPENI(LEVEL)
      RETURN
C
C          THIS SECTION WRITES LABELS ON THE CONTOURS.
C
    7 IF (LEVEL.GT.LLBCON.OR.LEVEL.GT.50) RETURN
C
      DO 100 KWORD= 1,10
        ICOPY(KWORD)= LBLCON(KWORD,LEVEL)
  100 CONTINUE
C
      LIMIT= NMCHI*10
      CALL G4GETK(ISPACE,NMCHI,NBITMC,NMCHI,ISP)
      NCHARS= 0
C
      DO 200 ICHAR= 1,LIMIT
        NOCHAR= LIMIT-ICHAR+1
        CALL G4GETK(ICOPY,NOCHAR,NBITMC,NMCHI,ICHR)
        CALL G4COCO(ICHR,ITEXT(NOCHAR))
        IF (ISP.NE.ICHR.AND.NCHARS.EQ.0) NCHARS= NOCHAR
  200 CONTINUE
C
      INOT1= INOTAT+1
      GO TO (12,12,8,9,11), INOT1
C
    8 CALL SPACE(1)
      GO TO 10
C
    9 CALL SPACE(2)
   10 CALL G3LINK(2,11,-NCHARS,ITEXT,RDATA)
C
      RETURN
C
   11 CALL SPACE(-1)
   12 IDATA(1)= 2
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      CALL G3LINK(2,11,-NCHARS,ITEXT,RDATA)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE G0GPOS(XGRIDS,YGRIDS,NPTSX,NPTSY,XIND,YIND,GPOSX,GPOSY)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 113)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          THIS FINDS THE INTERPOLATED COORDINATES ON A 'TARTAN' GRID.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XGRIDS] ARE THE GRID X-POSITIONS.
C          [YGRIDS] ARE THE GRID Y-POSITIONS.
C          <NPTSX>  IS THE ACTUAL ARRAY X-EXTENT, AND
C          <NPTSY>  IS THE ACTUAL ARRAY Y-EXTENT.
C          XIND     IS THE INTERPOLATED X INDEX, AND
C          YIND     IS THE INTERPOLATED Y INDEX.
C          GPOSX    IS THE RETURNED X POSITION, AND
C          GPOSY    IS THE RETURNED Y POSITION.
C
C
      REAL XGRIDS(NPTSX),YGRIDS(NPTSY)
C
C
      GPOSX= XGRIDS(NPTSX)
      INTX= INT(XIND)
      IF (INTX.LT.NPTSX) GPOSX= XGRIDS(INTX)+AMOD(XIND,1.0)*
     &                          (XGRIDS(INTX+1)-XGRIDS(INTX))
C
      GPOSY= YGRIDS(NPTSY)
      INTY= INT(YIND)
      IF (INTY.LT.NPTSY) GPOSY= YGRIDS(INTY)+AMOD(YIND,1.0)*
     &                          (YGRIDS(INTY+1)-YGRIDS(INTY))
C
      RETURN
      END
      SUBROUTINE G0INSD(XPOINT,YPOINT,IFLAG)
C
C          ------------------------------------------------
C          ROUTINE NO. (  46)   VERSION (A8.1)    14:MAY:87
C          ------------------------------------------------
C
C          THIS ROUTINE FINDS IF A POINT LIES OUTSIDE,
C          BEHIND OR ON GIVEN BAR FOR THE THREE DIMENSIONAL
C          BARCHART ROUTINE.
C
C          THE PARAMETERS ARE :
C
C          <XPOINT> ARE THE COORDINATES OF THE
C          <YPOINT> POINT BEING CHECKED.
C          <IFLAG>  VALUE RETURNED :
C                                0 : INSIDE,
C                                1 : OUTSIDE,
C                                2 : ON EDGE.
C
C          THE OTHER VALUES USED ARE :
C
C          [XCHLIN] ARRAYS CONTAINING THE COORDINATES
C          [YCHLIN] OF THE BAR.
C
C
      COMMON /T0CHLN/ XEALIN(22),YEALIN(22),XCHLIN(6),YCHLIN(6),NUMLNS
      COMMON /T0INTS/ XLINE1(2),YLINE1(2),XLINE2(2),YLINE2(2)
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C          DOES POINT LIE OUTSIDE BAR ?
C
      IFLAG= 1
      IF (XPOINT.GT.XCHLIN(2).OR.XPOINT.LT.XCHLIN(5).OR.
     &    YPOINT.GT.YCHLIN(3).OR.YPOINT.LT.YCHLIN(1)) RETURN
C
C          IS POINT IN SLOPING AREA OF BAR ?
C
      IF (XPOINT.LT.XCHLIN(4).AND.YPOINT.GT.YCHLIN(5)) GO TO 2
      IF (XPOINT.GT.XCHLIN(1).AND.YPOINT.LT.YCHLIN(2)) GO TO 1
C
C          DOES POINT LIE ON BAR ?
C
      IFLAG= 2
      IF (ABS(XPOINT-XCHLIN(2)).LT.RMINI) RETURN
      IF (ABS(XPOINT-XCHLIN(5)).LT.RMINI) RETURN
      IF (ABS(YPOINT-YCHLIN(1)).LT.RMINI) RETURN
      IF (ABS(YPOINT-YCHLIN(3)).LT.RMINI) RETURN
      GO TO 4
C
C          POINT IN BOTTOM RIGHT AREA.
C
    1 IDIS= 1
      GO TO 3
C
C          POINT IN TOP LEFT AREA.
C
    2 IDIS= 4
    3 XLINE1(1)= XPOINT
      YLINE1(1)= YCHLIN(IDIS)
      XLINE1(2)= XPOINT
      YLINE1(2)= YCHLIN(IDIS+1)
      XLINE2(1)= XCHLIN(IDIS)
      YLINE2(1)= YCHLIN(IDIS)
      XLINE2(2)= XCHLIN(IDIS+1)
      YLINE2(2)= YCHLIN(IDIS+1)
      CALL G0INTR(ICODE,XINT,YINT)
      IF (IDIS.EQ.1.AND.YPOINT.LT.YINT) RETURN
      IF (IDIS.EQ.4.AND.YPOINT.GT.YINT) RETURN
C
      IFLAG= 2
      IF (ABS(YPOINT-YINT).LT.RMINI) RETURN
C
C          POINT LIES INSIDE BAR.
C
    4 IFLAG= 0
      RETURN
      END
      SUBROUTINE G0SUR3(PROFK,PROFK1,VK,VK1,UK1,INVIS,SINVIS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 112)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          SUPPORT ROUTINE FOR G0SUR1 SURFACE PLOTTING ROUTINE.
C
C
      LOGICAL INVIS,SINVIS
C
      COMMON /T0SDEL/ DELTXY,DELTAU,DELTAV
      COMMON /T0SINS/ XINSEC,YINSEC
C
C
      IF ((SINVIS.AND..NOT.INVIS).OR.(.NOT.SINVIS.AND.INVIS)) GO TO 1
      IF (INVIS) RETURN
C
      CALL POSITN(UK1,VK1)
      CALL JOIN(UK1-DELTAU,VK)
      RETURN
C
    1 CALL G0SUR2(PROFK,PROFK1,VK,VK1,UK1)
      IF (INVIS) GO TO 2
C
      CALL POSITN(XINSEC,YINSEC)
      CALL JOIN(UK1-DELTAU,VK)
      RETURN
C
    2 CALL POSITN(UK1,VK1)
      CALL JOIN(XINSEC,YINSEC)
      RETURN
      END
      SUBROUTINE G0SUR4(NUMAXE,AXORG,XAX1,YAX1,XSFACT,YSFACT,AXSCAL)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 114)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          SUPPORT ROUTINE FOR G0SUR1 SURFACE PLOTTING ROUTINE.
C
      REAL    RDATA(1)
      INTEGER IDECFC(3)
C
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0SANG/ TLTANG,CSROOT,COSANG,SINANG
C
      DATA IDECFC /120,49,48/
C
C
      NOTSAV= NOTATA
      NOTATA= 10
      CALL G0DIVS(2,0.0)
      IF (NTIKHY.LT.NTIKLY) RETURN
      FACTOR= 10.0**(-NDECSY)
C
      DO 100 ITICK= NTIKLY,NTIKHY
        VALUE= DIVLY*ITICK
        GO TO (1,2,3), NUMAXE
C
    1   XPOS= (AXORG-VALUE)*AXSCAL*COSANG+XAX1
        YPOS= (VALUE-AXORG)*AXSCAL*SINANG+YAX1
        CALL POSITN(XPOS,YPOS)
        CALL JOIN(XPOS-0.02*COSANG,YPOS-0.02*SINANG)
        GO TO 4
C
    2   XPOS= (VALUE-AXORG)*AXSCAL*COSANG+XAX1
        YPOS= (VALUE-AXORG)*AXSCAL*SINANG+YAX1
        CALL POSITN(XPOS,YPOS)
        CALL JOIN(XPOS+0.02*COSANG,YPOS-0.02*SINANG)
        IF (VALUE.LT.0.0) CALL SPACE(2)
        IF (VALUE.GE.0.0) CALL SPACE(1)
        GO TO 5
C
    3   YPOS= (VALUE-AXORG)*AXSCAL*COSANG+YAX1
        CALL POSITN(0.0,YPOS)
        CALL JOIN(-0.02,YPOS)
    4   CALL SPACE(-NCHRSY-1)
    5   IF (KANNY.GT.2) VALUE= FACTOR*VALUE
        IF (KANNY.EQ.2.OR.KANNY.EQ.4) GO TO 6
C
        IVALUE= VALUE+SIGN(0.5,VALUE)
        CALL TYPENI(IVALUE)
        GO TO 100
C
    6   CALL TYPENF(VALUE,NAFTPY)
  100 CONTINUE
C
      IF (KANNY.LT.3) RETURN
C
      CALL POSITN(XSFACT,YSFACT)
      CALL G3LINK(2,11,-3,IDECFC,RDATA)
      CALL SUPFIX
      IF (NDECSY.GE.0) CALL SPACE(-1)
C
      CALL TYPENI(NDECSY)
      CALL NORMAL
      NOTATA= NOTSAV
      RETURN
      END
      SUBROUTINE CURVEO(XPT,YPT,LIMLO,LIMHI)
C
C          ------------------------------------------------
C          ROUTINE NO. (  92)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN OPEN CURVE THROUGH A SET OF POINTS.
C
C
C          THE ARGUMENTS ARE:
C
C          [XPT]    ARE THE X-COORDINATES AND
C          [YPT]    ARE THE Y-COORDINATES OF THE DATA POINTS,
C          <LIMLO>  IS THE LOWER LIMIT, AND
C          <LIMHI>  IS THE UPPER LIMIT OF THE POINTS IN THE ARRAYS.
C
C
      REAL XPT(LIMHI),YPT(LIMHI)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T0TRAC/ IPRINT
C
C
      IF (IPRINT.EQ.1) CALL G0MESG(35,0)
C
C          AUTOMATIC MAPPING WILL BE DONE IF NECESSARY.
C
      CALL G0AUTO(XPT,YPT,LIMLO,LIMHI,LIMLO,LIMHI,0)
C
      CALL G0CURV(XPT,YPT,LIMLO,LIMHI,0)
C
      XPLOT0= XPT(LIMHI)
      YPLOT0= YPT(LIMHI)
C
      RETURN
      END
      SUBROUTINE LINEFD(NFEEDS)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 155)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DOES <NFEEDS> LINE FEEDS FROM THE CURRENT LINE
C          IN EITHER A POSITIVE OR A NEGATIVE DIRECTION.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NFEEDS
      IF (IPRINT.EQ.1) CALL G0MESG(66,5)
C
      IF (NFEEDS.EQ.0) RETURN
C
      IDATA(1)= 5
      IDATA(2)= NFEEDS
      IF (NFEEDS.GT.0) GO TO 1
C
      IDATA(1)= 7
      IDATA(2)= -NFEEDS
    1 CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE NORMAL
C
C          ------------------------------------------------
C          ROUTINE NO. ( 150)   VERSION (A8.5)    04:MAR:91
C          ------------------------------------------------
C
C          THIS RESETS CHARACTER STRINGS FROM SUFFIX OR SUPERFIX.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0SUPF/ MAGBUF(5),MAGLVL
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      ITRAC1= MAGLVL
      IF (IPRINT.EQ.1) CALL G0MESG(61,5)
C
C          IF THE BUFFER LEVEL HAS BOTTOMED, AN ERROR MESSAGE
C          IS PRINTED; OTHERWISE, THE PREVIOUS MAGNIFICATION
C          IS TAKEN FROM THE BUFFER AND THE LEVEL IS DECREMENTED.
C          THE MAGN. SIGN GIVES WHETHER IT WAS SUFFIX OR SUPERFIX.
C
      IF (MAGLVL.LE.0) GO TO 901
C
      IPRSAV= IPRINT
      IPRINT= 0
C
      IDATA(1)= 4
      IDATA(2)= 1
      CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      MAG= MAGBUF(MAGLVL)
      MAGLVL= MAGLVL-1
      CALL CTRMAG(IABS(MAG))
C
      IDATA(1)= 2
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IDATA(1)= 6
      IF (MAG.LT.0) IDATA(1)= 8
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 17
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE PLOTNI(X,Y,IVALUE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 171)   VERSION (A8.6)    05:FEB:87
C          ------------------------------------------------
C
C          THIS PLOTS OUT THE GIVEN VALUE IN INTEGER FORMAT.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <X,Y>    ARE THE COORDINATES OF THE (IMPLIED) DECIMAL POINT.
C          <IVALUE> IS THE VALUE TO BE PLOTTED.
C
      REAL    RDATA(1)
      INTEGER IDATA(20)
C
      DATA ISPACE /32/, MINUS /45/, RDATA /0.0/
C
C
      CALL POSITN(X,Y)
C
C          THE FIRST CHARACTER IS SET TO ISPACE OR MINUS,
C          DEPENDING ON THE SIGN OF THE NUMBER. THE
C          ABSOLUTE VALUE IS THEN CONVERTED BY <G0CONI>
C          AND PLACED INTO <IDATA> IN UNPACKED FORM.
C
      IDATA(1)= 2
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      IDATA(1)= ISPACE
      IF (IVALUE.LT.0) IDATA(1)= MINUS
C
      INDEX= 2
      CALL G0CONI(IVALUE,IDATA,INDEX)
      NCHARS= INDEX-1
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE SUPFIX
C
C          ------------------------------------------------
C          ROUTINE NO. ( 149)   VERSION (A8.5)    04:MAR:91
C          ------------------------------------------------
C
C          THIS SETS CONDITIONS FOR SUPERFIX CHARACTER STRINGS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
      LOGICAL ERRON
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0SUPF/ MAGBUF(5),MAGLVL
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA(1) /0.0/
C
C
      ITRAC1= MAGLVL
      IF (IPRINT.EQ.1) CALL G0MESG(60,5)
C
C          THE BUFFER LEVEL IS TESTED FOR OVERFLOW:
C          IF SO, AN ERROR MESSAGE IS PRINTED;
C          OTHERWISE, THE BUFFER LEVEL IS INCREMENTED,
C          THE NEW MAGNIFICATION IS CALCULATED AND THEN SET.
C          THE SIGN OF THE MAGNIFICATION STORED IN THE BUFFER
C          INDICATES THAT THIS LEVEL WAS A SUPERFIX.
C
      IF (MAGLVL.GE.5) GO TO 901
C
      IPRSAV= IPRINT
      IPRINT= 0
C
      IDATA(1)= 8
      IDATA(2)= 1
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IDATA(1)= 4
      CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      MAGLVL= MAGLVL+1
      MAGBUF(MAGLVL)= IABS(MAGN0)
      MAG= (MAGN0*5+4)/8
      CALL CTRMAG(MAG)
      IDATA(1)= 2
      CALL G3LINK(2,12,-2,IDATA,RDATA)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 16
      IF (ERRON) CALL G0ERMS
C
      RETURN
      END
      SUBROUTINE TCSCEN(PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 160)   VERSION (A8.6)    23:JAN:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING <PHRASE> WITH THE
C          MIDDLE CHARACTER PLACED AT THE CURRENT CHAR. POSITION.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
      CHARACTER PHRASE*(*)
C
      DATA RDATA /0.0/
C
C
      IDATA(1)= 1
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      CALL TYPECS(PHRASE)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE TCSEND(PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 161)   VERSION (A8.6)    23:JAN:86
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHAR. STRING <PHRASE> WITH THE RIGHTMOST
C          CHARACTER LOCATED ONE PLACE BEFORE THE CURRENT POSITION.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
      CHARACTER PHRASE*(*)
C
      DATA RDATA /0.0/
C
C
      IDATA(1)= 2
      CALL G3LINK(2,17,-1,IDATA,RDATA)
      CALL TYPECS(PHRASE)
      IDATA(1)= 0
      CALL G3LINK(2,17,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE TYPENF(VALUE,NAFTDP)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 167)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS OUT THE NUMBER <VALUE> IN REAL FORMAT,
C          WITH <NAFTDP> DIGITS AFTER THE DECIMAL POINT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(20)
      LOGICAL ERRON
C
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA ISPACE /32/, MINUS /45/, IPOINT /46/, IZERO /48/,
     &     RDATA /0.0/
C
C
C          THE ERROR EXIT IS TAKEN IF <NAFTDP> IS WRONG.
C          THE FIRST CHARACTER IS SET TO SPACE OR ZERO,
C          DEPENDING ON THE SIGN OF THE NUMBER.
C
      IF (NAFTDP.LE.0)  GO TO 901
      IF (NAFTDP.GT.17) GO TO 901
C
      IDATA(1)= ISPACE
      IF (VALUE.LT.0.0) IDATA(1)= MINUS
C
C          THE NUMBER IS LEFT-SHIFTED BY <NAFTDP> PLACES THEN
C          ROUNDED. IF THIS RESULTS IN A ZERO NUMBER, THE SIGN
C          IS SUPPRESSED. IF THE NUMBER IS GREATER THAN UNITY,
C          A DECIMAL IPOINT IS INSERTED IN THE CHARACTER STRING
C          AT THE APPROPRIATE POSITION; IF IT IS FRACTIONAL,
C          AN INITIAL ZERO, A DECIMAL POINT, THEN AS MANY
C          FOLLOWING ZEROES AS NECESSARY ARE ADDED INSTEAD.
C
      ABVAL= ABS(VALUE)
      SHIFAC= 10.0**NAFTDP
      SHIFTD= ABVAL*SHIFAC
      IF (SHIFTD.GT.FLOAT(IMAXI)) GO TO 901
      IVALUE= SHIFTD+0.5
      IF (IVALUE.EQ.0) IDATA(1)= ISPACE
C
      IF (ABVAL.LT.1.0.AND.SHIFAC-SHIFTD.GT.0.5) GO TO 1
C
      INDEX= 2
      CALL G0CONI(IVALUE,IDATA,INDEX)
      NMOVE= INDEX
      DO 100 IMOVE= 1,NAFTDP
        NMOVE= NMOVE-1
        IDATA(NMOVE+1)= IDATA(NMOVE)
  100 CONTINUE
      IDATA(NMOVE)= IPOINT
      NCHARS= INDEX
      GO TO 2
C
    1 IDATA(2)= IZERO
      IDATA(3)= IPOINT
      INDEX= 4
      CALL G0CONI(IVALUE,IDATA,INDEX)
      DO 200 IMOVE= 1,NAFTDP
        ITO= NAFTDP-IMOVE+4
        IFROM= INDEX-IMOVE
        IVALUE= IZERO
        IF (IFROM.GT.3) IVALUE= IDATA(IFROM)
        IDATA(ITO)= IVALUE
  200 CONTINUE
      NCHARS= NAFTDP+3
C
    2 CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 30
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE G0CFL5(INDCL,NSIDES,XP,XQ,XR,XS,XT,YP,YQ,YR,YS,YT)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 189)   VERSION (A8.1)    24:APR:91
C          ------------------------------------------------
C
C          THIS FILLS THE SPECIFIED POLYGON.
C
C
C          <INDCL > IS THE CONTOUR LEVEL INDEX NUMBER.
C          <NSIDES> IS THE NUMBER OF SIDES OF THE POLYGON.
C          <XP,...> AND
C          <YP,...> ARE THE VERTICES OF THE POLYGON.
C
C
      REAL RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0KLST/ LSTCL0(100),LENLST
C
      DATA RDATA /0.0/
C
C
      IDATA(1)= 0
      CALL G3LINK(5,13,-1,IDATA,RDATA)
      KOLIND= MOD(INDCL,LENLST)
      IF (KOLIND.EQ.0) KOLIND= LENLST
C
      IDATA(1)= LSTCL0(KOLIND)
      CALL G3LINK(5,3,-1,IDATA,RDATA)
      CALL POSITN(XP,YP)
      CALL JOIN(XQ,YQ)
      CALL JOIN(XR,YR)
      IF (NSIDES.GT.3) CALL JOIN(XS,YS)
      IF (NSIDES.GT.4) CALL JOIN(XT,YT)
C
      CALL JOIN(XP,YP)
      CALL G3LINK(5,4,0,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE G0DIVS(IAXIS,DIVLEN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 231)   VERSION (A7.7)    11:FEB:85
C          ------------------------------------------------
C
C          THIS FINDS THE POSITIONS OF THE INTERVALS ON THE GIVEN AXIS
C          (FOR LIN. SCALING) WHICH LIE WITHIN THE CURRENT WINDOW AREA,
C          AND ALSO SETS THE MOST SUITABLE AXIS ANNOTATION FORMAT.
C
C
C          <IAXIS> GIVES THE REQUIRED AXIS BY ITS MODULUS:
C                   = 1, THE X-AXIS IS TAKEN, OR
C                   = 2, THE Y-AXIS IS TAKEN.
C          <DIVLEN> GIVES THE REQUIRED INTERVAL LENGTH.
C
C
C          THE FOLLOWING ARGUMENTS ARE SUPPLIED THROUGH COMMON:
C
C          <X1WND0>    THE COORDINATES
C          <X2WND0>    OF
C          <Y1WND0>    THE
C          <Y2WND0>    WINDOW RECTANGLE.
C
C          <AXPOSX> THE POSITION OF THE X-AXIS ALONG Y.
C          <AXPOSY> THE POSITION OF THE Y-AXIS ALONG X.
C          <NOTATA> IF ZERO, NO ANNOTATION IS REQUIRED,
C                   IF NON-ZERO, ANNOT. FORMAT MUST BE CALCULATED.
C
C
C          THE FOLLOWING ARGUMENTS ARE RETURNED THROUGH COMMON:
C          (ONLY THE ARGS. RELEVANT TO THE GIVEN AXIS ARE CHANGED):
C
C          <KTYPEX> IS THE X-AXIS TYPE (= 1 FOR LIN. AXIS).
C          <KTYPEY> IS THE Y-AXIS TYPE (= 1 FOR LIN. AXIS).
C          <DIVLX>  IS THE X-AXIS SUB-INTERVAL LENGTH.
C          <DIVLY>  IS THE Y-AXIS SUB-INTERVAL LENGTH.
C          <NSKIPX> IS THE NO. OF SUB-INTERVALS PER MAJOR INTERVAL IN X.
C          <NSKIPY> IS THE NO. OF SUB-INTERVALS PER MAJOR INTERVAL IN Y.
C          <NTIKLX> IS THE MARKING START-POINT FOR THE X-AXIS.
C          <NTIKLY> IS THE MARKING START-POINT FOR THE Y-AXIS.
C          <NTIKHX> IS THE MARKING END-  POINT FOR THE X-AXIS.
C          <NTIKHY> IS THE MARKING END-  POINT FOR THE Y-AXIS.
C          <NDECSX> IS THE X-AXIS ANNOTATION BASIS-EXPONENT.
C          <NDECSY> IS THE Y-AXIS ANNOTATION BASIS-EXPONENT.
C          <NCHRSX> IS THE NO. OF CHARS. IN X-AXIS ANNOTATION.
C          <NCHRSY> IS THE NO. OF CHARS. IN Y-AXIS ANNOTATION.
C          <NAFTPX> IS THE NO. OF CHARS. AFTER THE DEC. PT. IN X.
C          <NAFTPY> IS THE NO. OF CHARS. AFTER THE DEC. PT. IN Y.
C          <KANNX>  GIVES THE X-AXIS ANNOTATION TYPE, AND
C          <KANNY>  GIVES THE Y-AXIS ANNOTATION TYPE, AS FOLLOWS:
C                   = 1, IT IS INTEGER
C                   = 2, IT IS REAL,
C                   = 3, IT IS INTEGER WITH MULT. FACTOR.
C                   = 4, IT IS REAL    WITH MULT. FACTOR.
C          <KAXIS>  IS SET BY <IAXIS> FOR SUBSEQUENT USE.
C
C
      LOGICAL DONE
C
      COMMON /T0AARG/ KAXIS
      COMMON /T0ADIX/ DIVLX,NTIKLX,NTIKHX
      COMMON /T0ADIY/ DIVLY,NTIKLY,NTIKHY
      COMMON /T0ANOX/ KANNX,NCHRSX,NAFTPX
      COMMON /T0ANOY/ KANNY,NCHRSY,NAFTPY
      COMMON /T0ASKX/ NSKIPX,NDECSX
      COMMON /T0ASKY/ NSKIPY,NDECSY
      COMMON /T0ATYP/ KTYPEX,KTYPEY
      COMMON /T0NOTA/ NOTATA
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
c slmod begin
      COMMON /GHOSTCOM/ iopt_ghost
c slmod end
C
      DATA LIMSIG /5/
C
C
C          THE AXIS TYPE IS SET AND THE END POINTS ARE FOUND.
C
      KAXIS= IAXIS
C
      ENDMIN= AMIN1(X1WND0,X2WND0)
      ENDMAX= AMAX1(X1WND0,X2WND0)
      IF (IABS(KAXIS).EQ.1) GO TO 1
      ENDMIN= AMIN1(Y1WND0,Y2WND0)
      ENDMAX= AMAX1(Y1WND0,Y2WND0)
C
C          THE NO. OF STEPS IN THE WINDOW AT THE GIVEN INTERVAL SIZE
C          IS FOUND, AND IF THIS IS > 1000, THE INTERVAL LENGTH IS
C          INCREASED BY A SUITABLE FACTOR OF 10 TO GIVE < 999 STEPS.
C          A LIMIT OF 100 SUB-INTERVALS IS THEN SET, AND THE ACTUAL
C          SUB-INTERVAL LENGTH TO BE USED IS HENCE CALCULATED. IF
C          THE GIVEN STEP SIZE IS ZERO, A START INTERVAL-LENGTH OF
C          A SUITABLE POWER OF 10 IS CHOSEN TO GIVE APPROX. 15 SUB-
C          DIVISIONS, AND THE SUB-INTERVAL LIMIT IS SET ALSO AT 15.
C
    1 DIVSIZ= ABS(DIVLEN)
      IF (DIVSIZ.LE.0.0) GO TO 3
C
      STEPS= (ENDMAX-ENDMIN)/DIVSIZ
      IF (STEPS.LT.1.0E3) GO TO 2
      EXP= ALOG10(STEPS)
      IF (EXP.LT.0.0) EXP= EXP-1.0
      DIVSIZ= DIVSIZ*(10.0**(INT(EXP)-2))
    2 LIMIT= 100
      GO TO 4
C
    3 DIVSIZ= (ENDMAX-ENDMIN)/15.0
      EXP= ALOG10(DIVSIZ)
      IF (EXP.LT.0.0) EXP= EXP-1.0
      DIVSIZ= 10.0**INT(EXP)
c slmod begin
c...  15 was too large for some plots that crossed the y-axis (the
c     labels overlapped making them unreadable):
c...dev
      IF (iopt_ghost.EQ.0) THEN
        LIMIT= 10
      ELSE
        IF (iaxis.EQ.1) THEN
          LIMIT= 10
c          LIMIT= 15
        ELSE
          LIMIT= 10
        ENDIF
c        LIMIT= 5
      ENDIF
c
c      LIMIT= 15
c slmod end
C
C          THIS SECTION CALCULATES THE INITIAL EDGE POINTS,
C          ROUNDING-OFF ALWAYS IN THE CORRECT DIRECTION.
C
    4 ROUND= 0.999
      IF (ENDMIN.LT.0.0) ROUND= -0.001
      NLO= (ENDMIN/DIVSIZ)+ROUND
      ROUND= -0.999
      IF (ENDMAX.GT.0.0) ROUND= 0.001
      NHI= (ENDMAX/DIVSIZ)+ROUND
      IDIV= 1
      IDEC= 1
      DONE= .FALSE.
C
C          THIS PART INCREASES THE INTERVAL SIZE BY FACTORS OF
C          2, 5, 10, ETC. UNTIL THE GIVEN LIMIT IS SATISFIED.
C
    5   IFACT= IDIV*IDEC
        NLONOW= NLO
        IF (NLO.GT.0) NLONOW= NLONOW+IFACT-1
        NLONOW= NLONOW/IFACT
        NHINOW= NHI
        IF (NHI.LT.0) NHINOW= NHINOW-IFACT+1
        NHINOW= NHINOW/IFACT
C
        IF ((NHINOW-NLONOW).LE.LIMIT) GO TO 8
C
        IF (IDIV.NE.1) GO TO 6
        IDIV= 2
        GO TO 5
    6   IF (IDIV.NE.2) GO TO 7
        IDIV= 5
        GO TO 5
    7   IDIV= 1
        IDEC= IDEC*10
        GO TO 5
C
C          WHEN THE SUB-INTERVAL LIMIT HAS BEEN SATISFIED, THE
C          NEW VALUES ARE STORED, AND THE PROCESS IS REPEATED
C          WITH A LIMIT VALUE OF 15 TO FIND THE MAJOR INTERVALS.
C
    8   IF (DONE) GO TO 9
        DONE= .TRUE.
        NLO= NLONOW
        NHI= NHINOW
        DIVSIZ= DIVSIZ*IFACT
        IDIV= 1
        IDEC= 1
        LIMIT= 15
        GO TO 5
C
C          ONCE THE VALUES HAVE BEEN FOUND, THEY ARE PLACED
C          INTO THE APPROPRIATE VARIABLES IN THE COMMON BLOCK.
C
    9 IF (IABS(KAXIS).EQ.2) GO TO 10
      KTYPEX= 1
      DIVLX= DIVSIZ
      NTIKLX= NLO
      NTIKHX= NHI
      NSKIPX= IFACT
      GO TO 11
C
   10 KTYPEY= 1
      DIVLY= DIVSIZ
      NTIKLY= NLO
      NTIKHY= NHI
      NSKIPY= IFACT
C
C          IF <NOTATA> IS NON-ZERO AND THERE ARE TICK MARKS
C          TO ANNOTATE, THE NUMBER FORMAT IS CALCULATED BELOW:
C
   11 IF (NOTATA.EQ.0)  RETURN
      NCHARS= 1
      KANNOT= 1
      IF (NHI-NLO.LT.0) GO TO 16
C
C          FIRST THE MAJOR INTERVAL SIZE IS CALCULATED, THEN
C          THE MAXIMUM AND MINIMUM POSITION VALUES ARE FOUND.
C
      STPSIZ= DIVSIZ*IFACT
      TIKMAX= ABS((NHI/IFACT)*STPSIZ)
      TIKMIN= ABS((NLO/IFACT)*STPSIZ)
      IF (TIKMAX.GE.TIKMIN) GO TO 12
      TIKMAX= TIKMIN
      TIKMIN= ABS((NHI/IFACT)*STPSIZ)
   12 IF (TIKMIN.LT.STPSIZ)      TIKMIN= STPSIZ
      IF (NLO.GT.0.AND.NHI.LT.0) TIKMIN= STPSIZ
      IF (NLO.LT.0.AND.NHI.GT.0) TIKMIN= STPSIZ
C
C          THE EXPONENT AND NO. OF SIG. DIGITS ARE FOUND FOR
C          BOTH THE LARGEST VALUE AND THE INTERVAL, AND
C          THESE ARE COMBINED TO GIVE THE NUMBER CONSTANTS.
C          IF NUMSIG > LIMSIG, THE NUMBER IS TRUNCATED;
C          IF NUMEXP >= LIMSIG, OVERFLOW HAS OCCURRED;
C          IF NAFTDP > LIMSIG, UNDERFLOW HAS OCCURRED;
C          IF NAFTDP <= 0, THE FORMAT IS INTEGER.
C
      CALL G0SIZS(TIKMAX,LIMSIG,MAXEXP,MAXSIG)
      INTEXP= MAXEXP
      INTSIG= 0
      IF (STPSIZ.LE.TIKMAX) CALL G0SIZS(STPSIZ,LIMSIG,INTEXP,INTSIG)
      NAFTDP= INTSIG-INTEXP
      NUMEXP= MAXEXP
      NUMSIG= MAXSIG
      IF (NAFTDP.GT.MAXSIG-MAXEXP) NUMSIG= NUMEXP+NAFTDP
      IF (NUMSIG.GT.LIMSIG)        NUMSIG= LIMSIG
      NAFTDP= NUMSIG-NUMEXP-1
      IF (NAFTDP.LT.0) NAFTDP= 0
      NCHARS= NUMSIG+2
      IF (NUMEXP.GE.LIMSIG) GO TO 14
      IF (NAFTDP.GT.LIMSIG) GO TO 14
      NDECS= 0
      IF (NAFTDP.GT.0)      GO TO 13
C
C          THE FOLLOWING SECTIONS SET ANNOTATION TYPES
C          INTEGER AND REAL RESP., WITHOUT SCALING FACTOR.
C
      NCHARS= MAXEXP+2
      NAFTDP= 0
      KANNOT= 1
      GO TO 16
C
   13 IF (NUMEXP.LT.0) NCHARS= NAFTDP+3
      KANNOT= 2
      GO TO 16
C
C          THE FOLLOWING SECTIONS SET ANNOTATION TYPES
C          INTEGER AND REAL RESP., WITH A SCALING FACTOR.
C          THIS FACTOR IS GIVEN BY THE EXPONENT OF THE
C          MINIMUM (NON-ZERO) ABSOLUTE POSITION VALUE.
C
   14 CALL G0SIZS(TIKMIN,LIMSIG,MINEXP,MINSIG)
      NDECS= MINEXP
      NAFTDP= MINEXP-NUMEXP+NUMSIG-1
      IF (NAFTDP.GT.0) GO TO 15
C
      NCHARS= MAXEXP-MINEXP+2
      NAFTDP= 0
      KANNOT= 3
      GO TO 16
C
   15 KANNOT= 4
C
C          THE APPROPRIATE VALUES IN THE COMMON BLOCK
C          ARE THEN UPDATED, AND THE SUBROUTINE ENDS.
C
   16 IF (IABS(KAXIS).EQ.2) GO TO 17
      NCHRSX= NCHARS
      NAFTPX= NAFTDP
      KANNX= KANNOT
      NDECSX= NDECS
      RETURN
C
   17 NCHRSY= NCHARS
      NAFTPY= NAFTDP
      KANNY= KANNOT
      NDECSY= NDECS
C
      RETURN
      END
      SUBROUTINE G0INTR(ICODE,XINT,YINT)
C
C          ------------------------------------------------
C          ROUTINE NO. (  47)   VERSION (A8.1)    25:NOV:86
C          ------------------------------------------------
C
C          THIS ROUTINE FINDS ANY INTERSECTION BETWEEN TWO
C          LINE SEGMENTS.
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <ICODE>  IS A RETURNED VALUE INDICATING AS FOLLOWS :
C                   0 : NO INTERSECT IN LINE SEGMENTS,
C                   1 : LINES INTERSECT AT (XINT,YINT),
C          <XINT>   X COORDINATE OF INTERSECTION (IF ANY).
C          <YINT>   Y COORDINATE OF INTERSECTION (IF ANY).
C
C          THE VALUES IMPORTED ARE :
C
C          [XLINE1] ARRAY CONTAINING COORDINATES OF TWO END
C                   POINTS OF FIRST LINE.
C          [XLINE2] ARRAY CONTAINING COORDINATES OF TWO END
C                   POINTS OF SECOND LINE.
C
      COMMON /T0INTS/ XLINE1(2),YLINE1(2),XLINE2(2),YLINE2(2)
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
C          CALCULATE GRADIENTS, IF PARALLEL CHECK FOR COINCIDENCE,
C          ELSE FIND INTERSECTION AND CHECK IF INTERSECT LIES ON
C          BOTH LINE SEGMENTS.
C
      ICODE= 0
      IF (ABS(XLINE1(2)-XLINE1(1)).LT.RMINI) GO TO 1
C
      SLOPE1= (YLINE1(2)-YLINE1(1))/(XLINE1(2)-XLINE1(1))
      IF (ABS(XLINE2(2)-XLINE2(1)).LT.RMINI) GO TO 2
C
      SLOPE2= (YLINE2(2)-YLINE2(1))/(XLINE2(2)-XLINE2(1))
      IF (ABS(SLOPE1-SLOPE2).LT.RMINI) GO TO 6
      IF (ABS(YLINE1(2)-YLINE1(1)).LT.RMINI) GO TO 3
      IF (ABS(YLINE2(2)-YLINE2(1)).LT.RMINI) GO TO 4
C
      XINT= (SLOPE1*XLINE1(1)-YLINE1(1)-SLOPE2*XLINE2(1)+YLINE2(1))
     &     /(SLOPE1-SLOPE2)
      YINT= SLOPE1*(XINT-XLINE1(1))+YLINE1(1)
      GO TO 5
C
C          FIRST LINE VERTICAL
C
    1 IF (ABS(XLINE2(2)-XLINE2(1)).LT.RMINI) GO TO 7
C
      XINT= XLINE1(1)
      SLOPE2= (YLINE2(2)-YLINE2(1))/(XLINE2(2)-XLINE2(1))
      YINT= SLOPE2*(XINT-XLINE2(1))+YLINE2(1)
      GO TO 5
C
C          SECOND LINE VERTICAL
C
    2 XINT= XLINE2(1)
      YINT= SLOPE1*(XINT-XLINE1(1))+YLINE1(1)
      GO TO 5
C
C          FIRST LINE HORIZONTAL
C
    3 YINT= YLINE1(1)
      XINT= (YINT-YLINE2(1))/SLOPE2+XLINE2(1)
      GO TO 5
C
C          SECOND LINE HORIZONTAL
C
    4 YINT= YLINE2(1)
      XINT= (YINT-YLINE1(1))/SLOPE1+XLINE1(1)
    5 IF (((XINT.LE.XLINE1(1).AND.XINT.GE.XLINE1(2)).OR.
     &     (XINT.GE.XLINE1(1).AND.XINT.LE.XLINE1(2))).AND.
     &    ((XINT.LE.XLINE2(1).AND.XINT.GE.XLINE2(2)).OR.
     &     (XINT.GE.XLINE2(1).AND.XINT.LE.XLINE2(2))).AND.
     &    ((YINT.LE.YLINE1(1).AND.YINT.GE.YLINE1(2)).OR.
     &     (YINT.GE.YLINE1(1).AND.YINT.LE.YLINE1(2))).AND.
     &    ((YINT.LE.YLINE2(1).AND.YINT.GE.YLINE2(2)).OR.
     &     (YINT.GE.YLINE2(1).AND.YINT.LE.YLINE2(2)))) ICODE= 1
      RETURN
C
C          LINES PARALLEL
C
    6 YT1= SLOPE1*(XLINE2(1)-XLINE1(1))+YLINE1(1)
      YT2= SLOPE2*(XLINE1(1)-XLINE2(1))+YLINE2(1)
C
C          ARE LINES PARALLEL AND COINCIDENT ?
C
      IF (ABS(YLINE2(1)-YT1).GE.RMINI.AND.
     &    ABS(YLINE1(1)-YT2).GE.RMINI) RETURN
      IF (XLINE1(1).LT.XLINE2(1).AND.XLINE1(2).GT.XLINE2(1)) GO TO 8
      IF (XLINE1(1).GT.XLINE2(1).AND.XLINE1(2).LT.XLINE2(1)) GO TO 8
      IF (XLINE1(1).LT.XLINE2(2).AND.XLINE1(2).GT.XLINE2(2)) GO TO 9
      IF (XLINE1(1).GT.XLINE2(2).AND.XLINE1(2).LT.XLINE2(2)) GO TO 9
      RETURN
C
C          BOTH LINES VERTICAL AND COINCIDENT ?
C
    7 IF (ABS(XLINE2(1)-XLINE1(1)).GE.RMINI) RETURN
      IF (YLINE1(1).LT.YLINE2(1).AND.YLINE1(2).GT.YLINE2(1)) GO TO 8
      IF (YLINE1(1).GT.YLINE2(1).AND.YLINE1(2).LT.YLINE2(1)) GO TO 8
      IF (YLINE1(1).LT.YLINE2(2).AND.YLINE1(2).GT.YLINE2(2)) GO TO 9
      IF (YLINE1(1).GT.YLINE2(2).AND.YLINE1(2).LT.YLINE2(2)) GO TO 9
      RETURN
C
C          FIRST POINT LIES WITHIN LINE.
C
    8 XINT= XLINE2(1)
      YINT= YLINE2(1)
      GO TO 10
C
C          SECOND POINT LIES WITHIN LINE.
C
    9 XINT= XLINE2(2)
      YINT= YLINE2(2)
   10 ICODE= 1
      RETURN
      END
      SUBROUTINE G0SUR2(PROFK,PROFK1,VK,VK1,UK1)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 111)   VERSION (A7.1)    11:FEB:85
C          ------------------------------------------------
C
C          SUPPORT ROUTINE FOR G0SUR1 SURFACE PLOTTING ROUTINE.
C
C          CALCULATE THE COORDINATES (XINSEC,YINSEC) OF INTERSECTION OF
C          TWO STRAIGHT LINES JOINING ADJACENT POINTS ON THE
C          VISIBLE PROFILE PROFK,PROFK1 AND ADJACENT POINTS VK,VK1
C          BEING TESTED AGAINTS THE VISIBLE PROFILE. UK1 IS
C          THE X COORDINATE OF THE RIGHT POINT FOR XSECT SET .TRUE.
C          AND THE LEFT POINT FOR XSECT SET .FALSE..
C
C
      COMMON /T0SDEL/ DELTXY,DELTAU,DELTAV
      COMMON /T0SINS/ XINSEC,YINSEC
C
C
      DIFF= VK1-VK-PROFK1+PROFK
      XINSEC= UK1+(PROFK1-VK1)*DELTAU/DIFF
      YINSEC= (PROFK*VK1-PROFK1*VK)/DIFF
C
      RETURN
      END
      SUBROUTINE CTRMAG(MAG)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 142)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS SETS THE CURRENT CHARACTER SIZE IN PLOTTER UNITS.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(1)
C
      COMMON /T0CDIM/ MAGN0,OBLAT0
      COMMON /T0CSIZ/ CSIZE,MRKSIZ
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      CALL G3INIT(2)
C
      ITRAC1= MAG
      IF (IPRINT.EQ.1) CALL G0MESG(53,5)
C
      MAGN0= MAG
      IF (MAGN0.LT.1) MAGN0= 1
      IF (MAGN0.GT.255) MAGN0= 255
      MRKSIZ= 0
      IDATA(1)= MAGN0
      CALL G3LINK(2,3,-1,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE JOIN(X,Y)
C
C          ------------------------------------------------
C          ROUTINE NO. (  73)   VERSION (A8.5)    24:NOV:86
C          ------------------------------------------------
C
C          THIS DRAWS A LINE FROM THE CURRENT POSITION TO (X,Y).
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      IF (ABS(X-XPLOT0).LT.RMINI.AND.
     &    ABS(Y-YPLOT0).LT.RMINI) RETURN
C
      RDATA(1)= X
      RDATA(2)= Y
      CALL G3LINK(0,3,2*NBYTR,IDATA,RDATA)
      XPLOT0= X
      YPLOT0= Y
C
      RETURN
      END
      SUBROUTINE SPACE(NSPACE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 153)   VERSION (A7.3)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DOES <NSPACE> SPACES ALONG THE CURRENT LINE
C          IN EITHER A POSITIVE OR A NEGATIVE DIRECTION.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(2)
C
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
C
      DATA RDATA /0.0/
C
C
      ITRAC1= NSPACE
      IF (IPRINT.EQ.1) CALL G0MESG(64,5)
C
      IF (NSPACE.EQ.0) RETURN
C
      IDATA(1)= 1
      IDATA(2)= NSPACE
      IF (NSPACE.GT.0) GO TO 1
      IDATA(1)= 3
      IDATA(2)= -NSPACE
    1 CALL G3LINK(2,12,-2,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE TYPECS(PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 159)   VERSION (A7.5B)   11:FEB:85
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING <PHRASE> WITH THE
C          LEFTMOST CHARACTER PLACED AT THE CURRENT CHAR. POSITION.
C
C          THIS VERSION IS SUITABLE ONLY FOR ASCII CHAR. CODING.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(255)
      LOGICAL   ERRON
      CHARACTER PHRASE*(*)
C
      COMMON /T3ERRS/ ERRON,NUMERR
C
      DATA RDATA /0.0/
C
C
      NCHARS= LEN(PHRASE)
      IF (NCHARS.GT.255) GO TO 901
C
    1 DO 100 KCHAR= 1,NCHARS
        IDATA(KCHAR)= ICHAR(PHRASE(KCHAR:KCHAR))
  100 CONTINUE
C
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
      RETURN
C
  901 NUMERR= 18
      IF (ERRON) CALL G0ERMS
      NCHARS= 255
      GO TO 1
C
      END
      SUBROUTINE TYPENI(IVALUE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 166)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS OUT THE GIVEN NUMBER <IVALUE> IN INTEGER FORMAT.
C
C
      REAL    RDATA(1)
      INTEGER IDATA(20)
C
      DATA ISPACE /32/, MINUS /45/, RDATA /0.0/
C
C
C          THE FIRST CHARACTER IS SET TO ISPACE OR MINUS,
C          DEPENDING ON THE SIGN OF THE NUMBER. THE
C          ABSOLUTE VALUE IS THEN CONVERTED BY <G0CONI>
C          AND PLACED INTO <IDATA> IN UNPACKED FORM.
C
      IDATA(1)= ISPACE
      IF (IVALUE.LT.0) IDATA(1)= MINUS
      INDEX= 2
C
      CALL G0CONI(IVALUE,IDATA,INDEX)
      NCHARS= INDEX-1
C
      CALL G3LINK(2,11,-NCHARS,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE G0AUTO(XPT,YPT,MINX,MAXX,MINY,MAXY,IAREA)
C
C          ------------------------------------------------
C          ROUTINE NO. (  30)   VERSION (A8.6)    25:NOV:86
C          ------------------------------------------------
C
C          THIS PERFORMS AUTOMATIC SETTING OF MAPPING CONSTANTS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          [XPT]    IS THE MAPPING X-RANGE,
C          [YPT]    IS THE MAPPING Y-RANGE,
C          <MINX>   IS THE LOWER LIMIT OF [XPT],
C          <MAXX>   IS THE UPPER LIMIT OF [XPT],
C          <MINY>   IS THE LOWER LIMIT OF [YPT],
C          <MINY>   IS THE UPPER LIMIT [YPT]
C          <IAREA>  SETS THE TYPE OF BORDER:
C                   = 0, A 10% BORDER IS SET,
C                   = 1, THE FULL WINDOW AREA IS USED.
C
C
      REAL    XPT(MAXX),YPT(MAXY)
      LOGICAL ERRON
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0MAPA/ X1MAPV,X2MAPV,Y1MAPV,Y2MAPV
      COMMON /T0TRAC/ IPRINT
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      CALL G3INIT(2)
C
C          IF AUTOMATIC MAPPING IS NOT REQUIRED ON THE X-AXIS,
C          THE Y-AXIS IS TESTED FOR AUTOMATIC MAPPING INSTEAD.
C          THE FIRST LOOP FINDS THE EXTREME VALUES OF ARRAY [XPT].
C          IF A BORDER IS REQUIRED, THE WINDOW EXTENTS ARE AMENDED.
C
      IAUTO= 0
      IF (ABS(X2WND0-X1WND0).GE.RMINI.AND.
     &    ABS(X2MAPV-X1MAPV).GE.RMINI) GO TO 3
C
      IAUTO= 1
      X1WND0= XPT(MINX)
      X2WND0= X1WND0
C
      DO 100 ISERCH= MINX,MAXX
        IF (XPT(ISERCH).GT.X2WND0) X2WND0= XPT(ISERCH)
        IF (XPT(ISERCH).LT.X1WND0) X1WND0= XPT(ISERCH)
  100 CONTINUE
C
      IF (ABS(X2WND0-X1WND0).LT.RMINI) GO TO 901
      IF (IAREA.EQ.1) GO TO 2
      IF (MAPNUM.LT.3) GO TO 1
      IF (ABS(SIGN(1.0,X2WND0)-SIGN(1.0,X1WND0)).GE.RMINI) GO TO 901
C
      DXY= 0.1*ALOG(X2WND0/X1WND0)
      X1WND0= EXP(ALOG(ABS(X1WND0))-DXY)*SIGN(1.0,X1WND0)
      X2WND0= EXP(ALOG(ABS(X2WND0))+DXY)*SIGN(1.0,X2WND0)
      GO TO 2
C
    1 DXY= 0.1*(X2WND0-X1WND0)
      X2WND0= X2WND0+DXY
      X1WND0= X1WND0-DXY
    2 X1MAPV= X1WND0
      X2MAPV= X2WND0
C
C          IF AUTOMATIC MAPPING IS NOT REQUIRED ON
C          THE Y-AXIS, THE NEXT SECTION IS SKIPPED.
C          THE NEXT LOOP FINDS THE EXTREME VALUES OF ARRAY [YPT].
C          IF A BORDER IS REQUIRED, THE WINDOW EXTENTS ARE AMENDED.
C
    3 IF (ABS(Y2WND0-Y1WND0).GE.RMINI.AND.
     &    ABS(Y2MAPV-Y1MAPV).GE.RMINI) GO TO 6
C
      IAUTO= 1
      Y1WND0= YPT(MINY)
      Y2WND0= Y1WND0
C
      DO 200 ISERCH= MINY,MAXY
        IF (YPT(ISERCH).GT.Y2WND0) Y2WND0= YPT(ISERCH)
        IF (YPT(ISERCH).LT.Y1WND0) Y1WND0= YPT(ISERCH)
  200 CONTINUE
C
      IF (ABS(Y2WND0-Y1WND0).LT.RMINI) GO TO 901
      IF (IAREA.EQ.1) GO TO 5
      IF (MAPNUM.EQ.1.OR.MAPNUM.EQ.3) GO TO 4
      IF (ABS(SIGN(1.0,Y2WND0)-SIGN(1.0,Y1WND0)).GE.RMINI) GO TO 901
C
      DXY= 0.1*ALOG(Y2WND0/Y1WND0)
      Y1WND0= EXP(ALOG(ABS(Y1WND0))-DXY)*SIGN(1.0,Y1WND0)
      Y2WND0= EXP(ALOG(ABS(Y2WND0))+DXY)*SIGN(1.0,Y2WND0)
      GO TO 5
C
    4 DXY= 0.1*(Y2WND0-Y1WND0)
      Y2WND0= Y2WND0+DXY
      Y1WND0= Y1WND0-DXY
    5 Y1MAPV= Y1WND0
      Y2MAPV= Y2WND0
C
C          IF BOTH SECTIONS HAVE BEEN SKIPPED, AUTOMATIC MAPPING
C          IS NOT REQUIRED, AND SUBROUTINE EXITS; OTHERWISE,
C          THE NEW ARGUMENTS ARE MAPPED AND WINDOWED BEFORE EXIT.
C
    6 IF (IAUTO.EQ.0)  RETURN
      IF (MRKMAP.EQ.0) GO TO 7
C
      CALL G0MAPS(X1MAPV,X2MAPV,Y1MAPV,Y2MAPV)
    7 IF (MRKWIN.EQ.0) RETURN
C
      IPRSAV= IPRINT
      IPRINT= 0
      CALL WINDOW(X1WND0,X2WND0,Y1WND0,Y2WND0)
      IPRINT= IPRSAV
      RETURN
C
  901 NUMERR= 5
      IF (ERRON) CALL G0ERMS
      RETURN
      END
      SUBROUTINE G0CURV(XPT,YPT,LIMLO,LIMHI,IOPEN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 104)   VERSION (A7.5)    11:FEB:85
C          ------------------------------------------------
C
C          THIS DRAWS AN OPEN OR CLOSED CURVE
C          THROUGH A GIVEN SET OF DATA POINTS.
C
C
C          THE ARGUMENTS ARE:
C
C          [XPT]    ARE THE X-COORDINATES AND
C          [YPT]    ARE THE Y-COORDINATES OF THE DATA POINTS,
C          <LIMLO>  IS THE LOWER LIMIT, AND
C          <LIMHI>  IS THE UPPER LIMIT OF THE POINTS IN THE ARRAYS.
C          <IOPEN>  IS SET TO 0 FOR OPEN AND 1 FOR CLOSED CURVES.
C
C
      REAL    XPT(LIMHI),YPT(LIMHI),RDATA(256)
      INTEGER IDATA(1)
C
      COMMON /T0CURV/ MCURV0
      COMMON /T3NBYR/ NBYTR
C
C
      IF (LIMLO.GE.LIMHI) RETURN
C
      IDATA(1)= IOPEN
      CALL G3LINK(0,10,-1,IDATA,RDATA)
      IDATA(1)= MCURV0
      CALL G3LINK(0,11,-1,IDATA,RDATA)
C
      INDEX= 0
      DO 100 IPT= LIMLO,LIMHI
        INDEX= INDEX+2
        IF (INDEX.LT.255/NBYTR) GO TO 1
        INDEX= (INDEX-2)*NBYTR
        CALL G3LINK(0,12,INDEX,IDATA,RDATA)
        INDEX= 2
    1   RDATA(INDEX-1)= XPT(IPT)
        RDATA(INDEX)=   YPT(IPT)
  100 CONTINUE
      INDEX= INDEX*NBYTR
      CALL G3LINK(0,13,INDEX,IDATA,RDATA)
C
      RETURN
      END
      SUBROUTINE G0SIZS(VALUE,LIMSIG,IEXP,ISIG)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 235)   VERSION (A8.3)    25:NOV:86
C          ------------------------------------------------
C
C          THIS CONVERTS THE NUMBER INTO A NORMALISED DECIMAL
C          MANTISSA PLUS DECIMAL EXPONENT. THE MANTISSA IS THEN
C          LEFT-SHIFTED TO THE MAX. NO. OF SIGNIFICANT DIGITS
C          ALLOWED, TRUNCATED, THEN RIGHTMOST ZERO DIGITS ARE
C          REMOVED; THE NO. OF SIG. DIGITS IS HENCE FOUND.
C
C
C          THE FOLLOWING VALUES ARE RETURNED:
C
C          <IEXP>   IS THE DECIMAL EXPONENT VALUE OF THE NUMBER.
C          <ISIG>   IS THE NO. OF SIG. DIGITS IN THE ROUNDED NUMBER.
C
C
      DOUBLE PRECISION DVALUE,POWR10,ROUNDD
C
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
C
      DVALUE= ABS(VALUE)
      IEXP= 0
      ISIG= 0
      IF (DABS(DVALUE).LT.RMINI) RETURN
C
      POWR10= DLOG10(DVALUE)
      IEXP= POWR10+DSIGN(1.0D-6,POWR10)
      IF (POWR10.LT.0.0D0) IEXP= IEXP-1
C
      ROUNDD= DVALUE*(10.0D0**(LIMSIG-IEXP-1))
      IROUND= ROUNDD+0.5D0
      ISIG= LIMSIG
    1   IF (MOD(IROUND,10).GT.0) RETURN
C
        IROUND= IROUND/10
        ISIG= ISIG-1
        IF (ISIG.GT.0) GO TO 1
C
C          IF THE MANTISSA IS CLOSE TO UNITY, <ROUNDD> MAY BE
C          ROUNDED-UP TO OVER 10**LIMSIG SO THAT <ISIG> GOES
C          TO ZERO IN THE LOOP. IF THIS OCCURS, THIS SECTION
C          RESETS <ISIG> AND ALSO ADJUSTS <IEXP> IF NECESSARY.
C
      ISIG= 1
      IF (IEXP.LT.0) IEXP= IEXP+1
C
      RETURN
      END
      SUBROUTINE WINDOW(XAREA1,XAREA2,YAREA1,YAREA2)
C
C          ------------------------------------------------
C          ROUTINE NO. (  26)   VERSION (A8.7)    24:NOV:86
C          ------------------------------------------------
C
C          THIS SETS THE RECTANGLE AVAILABLE FOR PLOTTING.
C
C
C          <XAREA1,YAREA1> IS THE BOTTOM-LEFT AND
C          <XAREA2,YAREA2> IS THE TOP-RIGHT CORNER.
C
C
      REAL    RDATA(4)
      INTEGER IDATA(1)
C
      COMMON /T0AUTM/ MAPNUM
      COMMON /T0MACT/ MRKMAP,MRKWIN
      COMMON /T0TRAC/ IPRINT
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0WNDO/ X1WND0,X2WND0,Y1WND0,Y2WND0
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      CALL G3INIT(2)
      RTRAC1= XAREA1
      RTRAC2= XAREA2
      RTRAC3= YAREA1
      RTRAC4= YAREA2
      IF (IPRINT.EQ.1) CALL G0MESG(11,4)
C
C          THE WINDOW ARGUMENTS ARE SET.
C
      X1WND0= XAREA1
      X2WND0= XAREA2
      Y1WND0= YAREA1
      Y2WND0= YAREA2
C
C          IF NO MAPPING HAS YET BEEN REQUESTED,
C          A LINEAR MAP IS NOW DONE BY DEFAULT.
C
      IF (MRKMAP.NE.0) GO TO 1
C
      MAPNUM= 1
      MRKWIN= -1
      CALL G0MAPS(XAREA1,XAREA2,YAREA1,YAREA2)
      MRKMAP= 0
C
C          THE WINDOW MARKER IS SET.
C          THE ARGUMENTS ARE PASSED ON IF THEY ARE VALID,
C          THEN THE CURRENT PLOTTING POSITION IS RESET.
C
    1 MRKWIN= 1
      IF (ABS(X2WND0-X1WND0).LT.RMINI.OR.
     &    ABS(Y2WND0-Y1WND0).LT.RMINI) RETURN
C
      RDATA(1)= X1WND0
      RDATA(2)= X2WND0
      RDATA(3)= Y1WND0
      RDATA(4)= Y2WND0
      CALL G3LINK(7,5,4*NBYTR,IDATA,RDATA)
      CALL POSITN(X1WND0,Y1WND0)
C
      RETURN
      END
      SUBROUTINE G0CONI(IVALUE,ICHARS,INDEX)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 169)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS CONVERTS THE INTEGER <IVALUE> INTO A NON-PACKED
C          CHARACTER STRING HELD IN [ICHARS], BEGINNING AT THE
C          POSITION GIVEN BY <INDEX>. THIS ARGUMENT IS THEN SET
C          TO THE NEW START POSITION BEFORE THE SUBROUTINE ENDS.
C
C
      INTEGER ICHARS(20)
C
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA IZERO /48/
C
C
C          THE DIGITS ARE FOUND FROM HIGHEST TO LOWEST, WITH
C          LEADING ZEROES SUPPRESSED UNLESS THE NUMBER IS ZERO.
C
      IREM= IABS(IVALUE)
      IFACTR= 10**INT(ALOG10(FLOAT(IMAXI)))
      IPOINT= INDEX
    1   IDIGIT= IREM/IFACTR
        ICHARS(IPOINT)= IDIGIT+IZERO
        IREM= IREM-(IDIGIT*IFACTR)
        IFACTR= IFACTR/10
        IF (IDIGIT.NE.0.OR.IPOINT.NE.INDEX) IPOINT= IPOINT+1
        IF (IFACTR.GE.1) GO TO 1
C
      IF (IPOINT.EQ.INDEX) IPOINT= IPOINT+1
      INDEX= IPOINT
      RETURN
      END
      SUBROUTINE G0ERMS
C
C          ------------------------------------------------
C          ROUTINE NO. (   9)   VERSION (A8.8)    22:APR:91
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS PRINTS OUT THE APPROPRIATE PRE-PROCESSOR
C          ERROR MESSAGE AFTER THE OCCURRENCE OF A FAULT.
C
C
      REAL      RDATA(1)
      INTEGER   IDATA(1)
      LOGICAL   ERRON
      CHARACTER MESSAG(41)*48,MESGP1(20)*48,MESGP2(20)*48,
     &          MESGP3( 1)*48
C
      COMMON /T3CHAM/ KMESGI,KMESGO
      COMMON /T3ERRS/ ERRON,NUMERR
C
      EQUIVALENCE (MESGP1(1),MESSAG( 1)),(MESGP2(1),MESSAG(21)),
     &            (MESGP3(1),MESSAG(41))
C
      SAVE MESSAG
      DATA MESGP1 /'PSPACE: BOTH EXTENTS MUST HAVE NON-ZERO WIDTH   ',
     &             'GHOST:  LOG. MAPPING ATTEMPTED THROUGH ZERO     ',
     &             'MASK:   MORE THAN 10 MASK-AREAS REQUESTED       ',
     &             'UNMASK: INCORRECT MASK-AREA NUMBER              ',
     &             'GHOST:  INVALID DATA FOR AUTOMATIC MAPPING      ',
     &             'SELBUF: INCORRECT BUFFER NUMBER                 ',
     &             'UNLBUF: INCORRECT BUFFER NUMBER                 ',
     &             'CLRBUF: INCORRECT BUFFER NUMBER                 ',
     &             'BAR3D : INVALID ARRAY SIZE PARAMETERS           ',
     &             'CURVEM: INCORRECT METHOD NUMBER                 ',
     &             'CONTRA: INVALID ARRAY SIZE PARAMETERS           ',
     &             'CONTRL: INVALID ARRAY SIZE PARAMETERS           ',
     &             'CONTIA: INVALID ARRAY SIZE PARAMETERS           ',
     &             'CONTIL: INVALID ARRAY SIZE PARAMETERS           ',
     &             'SUFFIX: MORE THAN 5 SUFFIXES ATTEMPTED          ',
     &             'SUPFIX: MORE THAN 5 SUPERFIXES ATTEMPTED        ',
     &             'NORMAL: ATTEMPTED RETURN TO NONEXISTENT LEVEL   ',
     &             'GHOST:  TEXT STRING TRUNCATED                   ',
     &             'GHOST:  FILE OR PICTURE NAME TRUNCATED          ',
     &             'GHOST:  SYNTAX ERROR IN STRING COMMAND SEQUENCE '/
      DATA MESGP2 /'CDEFIN: CONSTANT CHARACTERS CANNOT BE REDEFINED ',
     &             'CDEFIN: CHARACTER DEFINITION IS INCORRECT       ',
     &             'BR3LBL: INVALID ARRAY SIZE PARAMETERS           ',
     &             'PIELBM: INCORRECT METHOD NUMBER                 ',
     &             'PIELBL: MORE THAN 50 SECTORS IN PIE CHART       ',
     &             'PIELBL: DIFFERENT NUMBER OF LABELS AND SECTORS  ',
     &             'CRETRN: TYPEWRITER MODE HAS NOT BEEN SET        ',
     &             'CRLNFD: TYPEWRITER MODE HAS NOT BEEN SET        ',
     &             'PLACE:  TYPEWRITER MODE HAS NOT BEEN SET        ',
     &             'TYPENF: INVALID NUMBER OF SIG. DIGITS REQUESTED ',
     &             'TYPENE: INVALID NUMBER OF SIG. DIGITS ATTEMPTED ',
     &             'GHOST:  MORE THAN 20 LOG.-AXIS CYCLES ATTEMPTED ',
     &             'MARKER: INCORRECT CHARACTER NUMBER              ',
     &             'COLSET: ONE OR MORE PRIMARY COLOURS SATURATED   ',
     &             'REGRID: NOT ENOUGH DATA OR GRID POINTS          ',
     &             'REGRID: FAILURE IN INTERPOLATION ROUTINE        ',
     &             'SURPLT: INVALID ARRAY SIZE PARAMETERS           ',
     &             'SURBAS: INVALID VALUE OF BASE TYPE PARAMETER    ',
     &             'SURAXE: INVALID VALUE OF AXIS ANNOTATION TYPE   ',
     &             'CONTRF: INVALID ARRAY SIZE PARAMETERS           '/
      DATA MESGP3 /'CONTIF: INVALID ARRAY SIZE PARAMETERS           '/
C
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
      WRITE(KMESGO,201) '*** ERROR IN ',MESSAG(NUMERR),' ***'
  201 FORMAT(/,5X,3A)
C
      RETURN
      END
      SUBROUTINE POSITN(X,Y)
C
C          ------------------------------------------------
C          ROUTINE NO. (  71)   VERSION (A7.4)    11:FEB:85
C          ------------------------------------------------
C
C          THIS MOVES THE PEN TO (X,Y) WITHOUT DRAWING.
C
C
      REAL    RDATA(2)
      INTEGER IDATA(1)
C
      COMMON /T0PPOS/ XPLOT0,YPLOT0
      COMMON /T3NBYR/ NBYTR
C
      DATA IDATA /0/
C
C
      RDATA(1)= X
      RDATA(2)= Y
      CALL G3LINK(0,2,2*NBYTR,IDATA,RDATA)
C
      XPLOT0= X
      YPLOT0= Y
      RETURN
      END
      SUBROUTINE G0MESG(MSGNO,IMODE)
C
C          ------------------------------------------------
C          ROUTINE NO. (   8)   VERSION (A8.7)    22:APR:91
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS PRINTS OUT TRACE INFORMATION.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <MSGNO>  IDENTIFIES THE CALLING ROUTINE, AND
C          <IMODE>  SETS THE ARGUMENT TYPE:
C                   1-4, IT IS REAL FORMAT, OR
C                   5-8, IT IS INTEGER. ITS VALUE
C                   MODULO-4 GIVES THE NO. OF ARGS.
C
C
      REAL      RDATA(1),VALUE(4)
      INTEGER   IDATA(1),NUMBER(4)
      CHARACTER OUTPUT(188)*6,DLOAD1(64)*6,DLOAD2(64)*6,DLOAD3(60)*6
C
      COMMON /T0TRAR/ RTRAC1,RTRAC2,RTRAC3,RTRAC4
      COMMON /T0TRAI/ ITRAC1,ITRAC2,ITRAC3,ITRAC4
      COMMON /T3CHAM/ KMESGI,KMESGO
C
      EQUIVALENCE (VALUE(1),RTRAC1),       (NUMBER(1),ITRAC1),
     &            (OUTPUT(1),DLOAD1(1)),   (OUTPUT(65),DLOAD2(1)),
     &            (OUTPUT(129),DLOAD3(1))
C
C
      SAVE OUTPUT,DLOAD1,DLOAD2,DLOAD3
      DATA DLOAD1 /'PAPER ','FILM  ','GREND ','FRAME ',
     &             'GPSTOP','GARGS ','MAP   ','MAPXL ',
     &             'MAPYL ','MAPXYL','WINDOW','PSPACE',
     &             'MASK  ','UNMASK','SCALE ','ROTATE',
     &             'SCAROT','RADIAN','DEGREE','GRAD  ',
     &             'QADRNT','BROKEN','FULL  ','LSTCOL',
     &             'THICK ','FLLBND','CONTRF','CONTIF',
     &             '      ','BORDER','BOX   ','PTPLOT',
     &             'HISTGM','CURVEC','CURVEO','CURVEM',
     &             'INTENS','GRAPHF','GRAPHX','GRAPHC',
     &             'LINEF ','CIRCLE','ELLPSE','ARC   ',
     &             'ARCELL','LHRDW1','KHRDW1','CONTRA',
     &             'CONTRL','CONTIA','CONTIL','CDEFIN',
     &             'CTRMAG','CTRSIZ','CTRORI','CTRSLP',
     &             'ITALIC','UNDLIN','SUFFIX','SUPFIX',
     &             'NORMAL','CSPACE','PLACE ','SPACE '/
      DATA DLOAD2 /'HSPACE','LINEFD','HLINFD','CRLNFD',
     &             'AXNOTA','AXES  ','XAXIS ','YAXIS ',
     &             'AXESSI','XAXISI','YAXISI','AXEXL ',
     &             'AXEXLI','AXEYL ','AXEYLI','AXEXYL',
     &             'XAXISL','YAXISL','SCALES','SCALMX',
     &             'SCALMY','SCALSI','XSCALI','YSCALI',
     &             'SCAXL ','SCAXLI','SCAYL ','SCAYLI',
     &             'SCAXYL','XSCALL','YSCALL','GRATIC',
     &             'XGRAT ','YGRAT ','GRATSI','XGRATI',
     &             'YGRATI','GRAXL ','GRAXLI','GRAYL ',
     &             'GRAYLI','GRAXYL','XGRATL','YGRATL',
     &             'PTJOIN','PTGRAF','CTRFNT','CTROBL',
     &             'CTRANG','SELBUF','ENDBUF','UNLBUF',
     &             'CLRBUF','ERASE ','PICNOW','MARKER',
     &             'CRETRN','CHANNL','ERRORS','IOCHNL',
     &             'MAPFOL','WINFOL','WINCHR','COLSET'/
      DATA DLOAD3 /'RGB   ','HLS   ','HSI   ','FILCOL',
     &             'BARCHT','SECCIR','SECELL','PIECHT',
     &             'PIELBL','LINCOL','DEFPEN','MSKCHR',
     &             'LOCATE','UNLOC ','TPICT ','TCLIPA',
     &             'REGRID','SURPLT','SURDIR','SURBAS',
     &             'SURSEC','SURSCA','SURIND','SURANG',
     &             'SURCOL','ISOSUR','ANNOTP','AXORIG',
     &             'PIELBM','SURAXE','BARTYP','MULHIS',
     &             'MULBAR','VMENU ','VCHTKY','LBCOLS',
     &             'PIEANG','BARFLG','INCBAR','INCHIS',
     &             'HMENU ','HCHTKY','BAR3D ','BR3COL',
     &             'BR3ANG','BR3BAS','BR3RAT','CONLBL',
     &             'HATANG','HATCOL','HATDEF','HATLST',
     &             'HATPCH','HATPHS','HATSFT','HATYPE',
     &             'HATDUP','HATLSH','BR3LBL','HATOPT'/
C
C
      CALL G3LINK(3,10,0,IDATA,RDATA)
      NARGS= IMODE
      IF (NARGS.GT.4) NARGS= NARGS-4
C
      IF (NARGS.NE.0) GO TO 1
      WRITE(KMESGO,201) OUTPUT(MSGNO)
  201 FORMAT(5X,A6)
      RETURN
C
    1 IF (IMODE.GT.4) GO TO 2
      WRITE(KMESGO,202) OUTPUT(MSGNO),(VALUE(IOUT), IOUT= 1,NARGS)
  202 FORMAT(5X,A6,4(2X,1PE13.6))
      RETURN
C
    2 WRITE(KMESGO,203) OUTPUT(MSGNO),(NUMBER(IOUT), IOUT= 1,NARGS)
  203 FORMAT(5X,A6,4(2X,I10))
      RETURN
      END
      SUBROUTINE G4NEXR(IARRAY,ISTRT,ISTOP,ISIZE,RVALUE,NDIGS,IPOSN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 279)   VERSION (A7.4)    03:JAN:86
C          ------------------------------------------------
C
C          THIS DECODES THE FIRST CONTIGUOUS SEQUENCE OF DIGITS
C          IN A GIVEN CHARACTER STRING INTO A REAL NUMBER. THE
C          FIRST POSITION AFTER THE DIGIT SEQUENCE IS ALSO FOUND.
C
C
C          THE INPUT ARGUMENTS ARE AS FOLLOWS:
C
C          [IARRAY] HOLDS THE CHARACTER STRING (GHOST CHARS.),
C          <ISTRT>  IS THE STARTING POINT OF THE STRING,
C          <ISTOP>  IS THE STOPPING POINT OF THE STRING,
C          <ISIZE>  IS THE TOTAL SIZE OF THE ARRAY.
C
C
C          AND THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <RVALUE> IS THE VALUE FOUND FROM THE STRING,
C          <NDIGS>  IS THE NUMBER OF CONSECUTIVE DIGITS FOUND,
C          <IPOSN>  IS THE NEXT POSITION AFTER THE DIGIT SEQUENCE
C                   (AND IS SET TO ZERO IF NO CHARACTERS REMAIN).
C
C
      INTEGER IARRAY(ISIZE)
C
      DATA KPOINT /46/
C
C
      RVALUE= 0.0
      IPOSN= 0
      NDIGS= 0
      IF (ISTOP.LT.ISTRT) RETURN
C
C          THE PART OF THE NUMBER BEFORE THE DECIMAL POINT IS
C          FIRST DECODED. IF THERE ARE NO MORE DIGITS BEFORE
C          THE FIRST SEPARATOR WHICH IS NOT A SPACE OR POINT,
C          THE NUMBER IS COMPLETE; OTHERWISE THE STRING OF
C          DIGITS AFTER THE POINT IS DECODED AND ADDED IN. IF
C          A POINT PRECEDES THE DIGITS, THIS PART IS IGNORED.
C
      CALL G4NEXI(IARRAY,ISTRT,ISTOP,ISIZE,IVALUE,LEN,IPOS1)
      ISIGN=1
      IF (IVALUE.GE.0) GO TO 1
C
      ISIGN= -1
      IVALUE= IVALUE+1
    1 IF (IPOS1.LE.0) RETURN
C
      IPOSN= IPOS1-LEN-1
      IF (IARRAY(IPOSN).EQ.KPOINT) GO TO 2
C
      RVALUE= IVALUE
      NDIGS= LEN
      IPOSN= IPOS1
      IF (IPOSN.GE.ISTOP) RETURN
      IF (IARRAY(IPOSN).NE.KPOINT) RETURN
C
    2 IPOSN= IPOSN+1
      CALL G4NEXC(IARRAY,IPOSN,ISTOP,ISIZE,+2,IPOS1)
      IF (IPOS1.LE.0) RETURN
C
      CALL G4NEXC(IARRAY,IPOSN,ISTOP,ISIZE,-4,IPOS2)
      IF (IPOS2.NE.IPOS1) RETURN
C
      CALL G4NEXI(IARRAY,IPOS1,ISTOP,ISIZE,IVALUE,LEN,IPOS2)
      IPOSN= IPOS2
      NDIGS= NDIGS+LEN
      RVALUE= RVALUE+ISIGN*IVALUE*(10.0**(-LEN))
C
      RETURN
      END
      SUBROUTINE G4NEXS(IARRAY,ISTRT,ISTOP,ISIZE,STRING,LENSTR,
     &                  LEN,IPOSN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 280)   VERSION (A8.4)    05:DEC:86
C          ------------------------------------------------
C
C          THIS FINDS THE NEXT STRING IN THE ARRAY OF
C          UNPACKED RIGHT-JUSTIFIED GHOST CHARACTERS
C          [IARRAY] OF SIZE <ISIZE> BETWEEN THE ELEMENTS
C          <ISTRT> AND <ISTOP>. THE STRING BEGINS WITH
C          ANY LETTER AND ENDS WITH THE FIRST SUCCEEDING
C          SPACE, AND IS PLACED IN CHARACTER FORM INTO
C          THE OUTPUT ARRAY [ISTRNG]. THE STRING LENGTH IS
C          <LENSTR> AND THE NEXT POSITION IN [IARRAY] IS <IPOSN>.
C
      INTEGER IARRAY(ISIZE)
      CHARACTER STRING*(*)
C
C
      LEN= 0
      IPOSN= 0
      IF (ISTRT.GT.ISIZE) RETURN
      IF (ISTOP.LE.0)     RETURN
      IF (ISTRT.GT.ISTOP) RETURN
C
      LIM1= ISTRT
      IF (ISTRT.LT.1) LIM1= 1
C
      LIM2= ISTOP
      IF (ISTOP.GT.ISIZE) LIM2= ISIZE
C
      CALL G4NEXC(IARRAY, LIM1,LIM2,ISIZE,+3,IPOS1)
      IF (IPOS1.LE.0) RETURN
C
      CALL G4NEXC(IARRAY,IPOS1,LIM2,ISIZE,+4,IPOS2)
      IF (IPOS2.GE.0) LIM2= IPOS2-1
C
      DO 100 ICOPY= 1,LENSTR
        STRING(ICOPY:ICOPY)= ' '
  100 CONTINUE
C
      LIM1= IPOS1
      LEN= 0
C
      DO 200 ICOPY= LIM1,LIM2
        KCHAR= MOD(IARRAY(ICOPY),128)
        CALL G4BACO(KCHAR,MCHAR)
        LEN= LEN+1
        STRING(LEN:LEN)= CHAR(MCHAR)
  200 CONTINUE
C
      IPOSN= IPOS2
C
      RETURN
      END
      SUBROUTINE G4NEXI(IARRAY,ISTRT,ISTOP,ISIZE,IVALUE,LENN,IPOSN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 278)   VERSION (A7.4)    03:JAN:86
C          ------------------------------------------------
C
C          THIS DECODES THE FIRST CONTIGUOUS SEQUENCE OF DIGITS
C          IN A GIVEN CHARACTER STRING INTO AN INTEGER. THE
C          FIRST POSITION AFTER THE DIGIT SEQUENCE IS ALSO FOUND.
C          NEGATIVE NUMBERS ARE REDUCED IN VALUE BY 1 TO
C          DIFFERENTIATE BETWEEN +0 AND -0.
C
C
C          THE INPUT ARGUMENTS ARE AS FOLLOWS:
C
C          [IARRAY] HOLDS THE CHARACTER STRING (GHOST CHARS.),
C          <ISTRT>  IS THE STARTING POINT OF THE STRING,
C          <ISTOP>  IS THE STOPPING POINT OF THE STRING,
C          <ISIZE>  IS THE TOTAL SIZE OF THE ARRAY.
C
C
C          AND THE OUTPUT ARGUMENTS ARE AS FOLLOWS:
C
C          <IVALUE> IS THE VALUE FOUND FROM THE STRING,
C          <LENN>   IS THE NUMBER OF CONSECUTIVE DIGITS FOUND,
C          <IPOSN>  IS THE NEXT POSITION AFTER THE DIGIT SEQUENCE
C                   (AND IS SET TO ZERO IF NO CHARACTERS REMAIN).
C
C
      INTEGER IARRAY(ISIZE)
      LOGICAL MINUS
C
      DATA KSPACE /32/, KPLUS /43/, KMINUS /45/, KPOINT /46/
C
C
      IVALUE= 0
      IPOSN= 0
      LENN= 0
      IF (ISTOP.LT.ISTRT) RETURN
C
      CALL G4NEXC(IARRAY,ISTRT,ISTOP,ISIZE,+2,IPOS1)
      IF (IPOS1.GT.0) GO TO 1
C
      IPOS1= ISTRT
      IPOS2= ISTOP
      GO TO 2
C
    1 CALL G4NEXC(IARRAY,IPOS1,ISTOP,ISIZE,-2,IPOS2)
      IF (IPOS2.LE.0) IPOS2= ISTOP+1
C
C          LOOP-100 DECODES THE DIGITS INTO A NUMBER;
C          NOTE THAT NO MORE THAN 9 DIGITS ARE USED.
C
      IPOSN= IPOS2
      IF (IPOSN.GT.ISIZE) IPOSN= 0
C
      LENN= IPOS2-IPOS1
      IF (LENN.GT.9) LENN= 9
C
      IPOS2= IPOS1+LENN-1
C
      DO 100 LOOK= IPOS1,IPOS2
        IDIGIT= IARRAY(LOOK)-48
        IVALUE= IVALUE*10+IDIGIT
  100 CONTINUE
C
C          THIS SECTION DETERMINES THE SIGN, IF REQUIRED.
C          SPACES AND PAIRS OF MINUS SIGNS ARE IGNORED.
C
      IF (IPOS1.LE.ISTRT) RETURN
C
      IPOS2= IPOS1-1
      CALL G4NEXC(IARRAY,ISTRT,IPOS2,ISIZE,-4,IPOS1)
      IF (IPOS1.LT.ISTRT) RETURN
C
    2 MINUS= .FALSE.
C
      DO 200 LOOK= IPOS1,IPOS2
        ICHAR= IARRAY(LOOK)
        IF (ICHAR.EQ.KMINUS) GO TO 3
        IF (ICHAR.EQ.KPLUS)  GO TO 200
        IF (ICHAR.EQ.KSPACE) GO TO 200
        IF (ICHAR.EQ.KPOINT) GO TO 4
C
        MINUS= .TRUE.
    3   MINUS= .NOT.MINUS
  200 CONTINUE
C
    4 IF (MINUS) IVALUE= -IVALUE-1
C
      RETURN
      END
      SUBROUTINE G4NEXC(IARRAY,ISTRT,ISTOP,ISIZE,ITYPE,IPOSN)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 276)   VERSION (A7.4)    03:JAN:86
C          ------------------------------------------------
C
C          THIS FINDS THE POSITION <IPOSN> OF THE FIRST CHARACTER
C          OF THE TYPE GIVEN BY <ITYPE> BETWEEN POSITIONS <ISTRT>
C          AND <ISTOP> IN THE (UNPACKED) ARRAY [IARRAY] OF LENGTH
C          <ISIZE>. IF NO OCCURRENCE IS FOUND, <IPOSN> IS SET TO 0.
C
C          <ITYPE> SETS THE FOLLOWING TYPES:
C
C                  =  1, THE FIRST     SEPARATOR CHARACTER.
C                  = -1, THE FIRST NON-SEPARATOR CHARACTER.
C                  =  2, THE FIRST     NUMERIC CHARACTER.
C                  = -2, THE FIRST NON-NUMERIC CHARACTER.
C                  =  3, THE FIRST     ALPHABETIC CHARACTER.
C                  = -3, THE FIRST NON-ALPHABETIC CHARACTER.
C                  =  4, THE FIRST     SPACE.
C                  = -4, THE FIRST NON-SPACE.
C
C
      INTEGER IARRAY(ISIZE)
C
C
      IPOSN= 0
      IF (ISTRT.GT.ISIZE) RETURN
      IF (ISTOP.LE.0)     RETURN
      IF (ISTRT.GT.ISTOP) RETURN
C
C          <KTYPE> IS SET ACCORDING TO THE CHARACTER TYPE:
C
C                  = 1, IT IS A SEPARATOR,
C                  = 2, IT IS A NUMBER, OR
C                  = 3, IT IS ALPHABETIC.
C
      LIM1= ISTRT
      IF (ISTRT.LT.1) LIM1= 1
C
      LIM2= ISTOP
      IF (ISTOP.GT.ISIZE) LIM2= ISIZE
C
      DO 100 LOOK= LIM1,LIM2
        ICHAR= IARRAY(LOOK)
        KTYPE= 1
        IF (ICHAR.GE. 48) KTYPE= 2
        IF (ICHAR.GE. 58) KTYPE= 1
        IF (ICHAR.GE. 65) KTYPE= 3
        IF (ICHAR.GE. 91) KTYPE= 1
        IF (ICHAR.GE. 97) KTYPE= 3
        IF (ICHAR.GE.123) KTYPE= 1
        IF (ICHAR.GT.128) KTYPE= 3
        IF (ITYPE.LT.0)                  GO TO 1
        IF (KTYPE.EQ.ITYPE)              GO TO 2
        IF (ITYPE.EQ. 4.AND.ICHAR.EQ.32) GO TO 2
        GO TO 100
C
    1   IF (KTYPE.NE.IABS(ITYPE))        GO TO 2
        IF (ITYPE.EQ.-4.AND.ICHAR.NE.32) GO TO 2
  100 CONTINUE
      RETURN
C
    2 IPOSN= LOOK
      RETURN
      END
c slmod begin
      SUBROUTINE G3MESS(I1,I2,I3,I4)
      INTEGER I1,I2,I3,I4
      WRITE(0,*) 'WARNING: CALLING G3MESS'
      RETURN
      END
c slmod end
