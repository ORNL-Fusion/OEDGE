!pb  22.03.07:  LEVGEO=6 --> LEVGEO=10
C
C
C*DK LININT
      SUBROUTINE LININT (IFIRST,ICHORI,C1,C2,ICHRD,IPVOT,NBC2,NAC2,PEN,
     .                   PSIG,TIMAX,ISP,NSPI,JEN,NCHNI)
C
C  THE LINE INTEGRATION IS CARRIED OUT ALONG A STRAIGHT LINE, STARTING
C  FROM P1 AND ENDING AT P2.
C
C  P1 IS FOUND AS FOLLOWS: CONSIDER THE STRAIGHT LINE C2+T*(C1-C2).
C  THE POINTS C1 ("PIVOT") AND C2 ("CHORD") ARE INPUT (INPUT BLOCK 12).
C  THE NEAREST INTERSECTION OF THIS LINE  WITH A NON-TRANSPARENT SURFACE
C  IS P1. IN ORDER TO FIND THIS P1, C2 MUST BE INSIDE THE COMPUTATIONAL
C  VOLUME (STANDARD OR ADDITIONAL MESH REGION)
C
C  P2 IS FOUND BY INTEGRATING THE TALLY FROM P1, IN THE DIRECTION
C  (C2-C1), IE. OPPOSITE TO THE DIRECTION USED ABOVE,
C  UNTIL THE NEXT INTERSECTION WITH ANY NON-TRANSPARENT
C  SURFACE (P2) IS FOUND.
c
c  ifirst=0:  first call for one particular LOS
c  ifirst=1:  same LOS as previous LOC, but different energy parameter PEN
c
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CPLOT
      USE CUPD
      USE COMSIG
      USE CGRID
      USE CGEOM
      USE CZT1
      USE CTRCEI
      USE CTETRA
      USE COMPRT
      USE CLGIN
      USE COMXS
      USE CSPEI
      USE CTRIG
      USE CTEXT
      USE CPLMSK

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: IFIRST,ICHORI, ICHRD,IPVOT,NBC2,NAC2,ISP,
     .                       NSPI, JEN, NCHNI
      REAL(DP), INTENT(IN) :: C1(3),C2(3),PEN
      REAL(DP), INTENT(OUT) :: PSIG(0:NSPZ+10)
      REAL(DP), INTENT(IN OUT) :: TIMAX
      INTEGER :: IPLOTS, IERR
      REAL(DP) :: ARGST(0:NSPZ+10,NRAD)
      REAL(DP) :: PMI,PMA,XMI,XMA
      REAL(DP) :: X0S, PHIS, Y0S, VELXS, VELYS, VELZS, Z0S, ZD1, YD1,
     .          TRACKS, ZDS, XD0, YD0, ZD0, X22, PHI22, XLI, YLI, ZLI,
     .          ZTST, SG, XPIV, X11, PHI11, ZPIV, YPIV, WINK, XD1,
     .          PPMI, PPMA
      INTEGER :: NBCKAS, NBOCKS, MRSRFS, MPSRFS, MTSRFS, NPCLLS, NACLLS,
     .           MSURFS, NTCLLS, J, JJ, ISY, JJJ, IPOLGS, IPERID_2,
     .           LEARCA, NLE, NLI, ISTS, NRCLLS, LEARC2, IPERID_1,
     .           LEARC1, ISAVE, K, I, IM, IC, NCELLT, IAT, NCH
      TYPE(CELL_INFO), POINTER :: NEW_CELL
C   ARRAYS FOR PLOTTING
      REAL(DP) :: AA(NRAD),XNTG(NRAD),VPLOT(NRAD,1) 
      REAL(DP), ALLOCATABLE :: YPLOT(:,:),
     .                         YMN2(:), YMX2(:), 
     .                         YMNLG2(:), YMXLG2(:)
      INTEGER, ALLOCATABLE :: IR1(:), IR2(:), IRS(:)
      LOGICAL, ALLOCATABLE :: LPLOT2(:), LSDVI(:)
      LOGICAL :: TRCSAV, LCNDEXP, L_SAME
      CHARACTER(72) :: TXHEAD, TXTALL(NCHENI)
      CHARACTER(24) :: TXUNIT(NCHENI), TXSPEC(NCHENI)

      SAVE

      NLTRC=TRCSIG.AND.IFIRST.EQ.0.AND.TRCHST
      NPANU=0
      SCOS=1.
      IPOLG=1
C
C  COMPUTE LINE INTEGRATED SIGNAL
C
      IF (IFIRST.GT.0) GOTO 100
      IF (PLSPEC) THEN
        IF (.NOT.ALLOCATED(YPLOT)) THEN
          NCH = 1
          IF (ANY(NCHTAL(1:NCHORI) == 1)) NCH=IABS(NCHENI)
          ALLOCATE (YPLOT(NRAD,NCH))
          ALLOCATE (YMN2(NCH))
          ALLOCATE (YMX2(NCH))
          ALLOCATE (YMNLG2(NCH))
          ALLOCATE (YMXLG2(NCH))
          ALLOCATE (IR1(NCH))
          ALLOCATE (IR2(NCH))
          ALLOCATE (IRS(NCH))
          ALLOCATE (LPLOT2(NCH))
          ALLOCATE (LSDVI(NCH))
        END IF
        YPLOT = 0._DP
        YMN2 = 1.E30_DP  
        YMX2 = -1.E30_DP  
        YMNLG2 = 1.E30_DP  
        YMXLG2 = -1.E30_DP  
        LPLOT2 = .FALSE.
        LSDVI = .FALSE.
        IR1 = 0
        IR2 = 0
        IRS = 0
        IPLOTS = 0
        L_SAME = .FALSE.
        XMA = 0._DP
C
C  NULLPUNKT AUF DEM PAPIER

        X0PL=10.
        Y0PL=3.
C  ACHSENLAENGEN
        LENX=25.
        LENY=20.
C  ACHSENUNTERTEILUNG VORGEGEBEN?
C  NEIN!
        STPSZX=0.
        STPSZY=0.
        INTNRX=0
        INTNRY=0
C  ACHSE LOGARITHMISCH?
        LOGX=.FALSE.
C     LOGY VIA INPUT
C  LOG. ACHSE MIN
        MINLY=0
C  LOG. ACHSE MAX
C     MAXLY WERDEN BERECHNET IN ANPSGL
C  ZEICHNE NETZLINIEN EIN
        GRIDX=.TRUE.
        GRIDY=.TRUE.
C  MACHE GRADE GRENZEN, X-ACHSE (Y ACHSE, NUR WENN TALZMI=TALZMA=666.)
        FITX=.TRUE.
      END IF
C
C  FIND STARTING POINT FOR LINE INTEGRATION:
C
C  INTERSECTION POINT OF LINE OF SIGHT WITH
C  NEAREST NON-TRANSPARENT STANDARD MESH SURFACE OR NON-TRANSPARENT
C  ADDITIONAL SURFACE,
C  STARTING FROM C2, SEARCHING IN THE DIRECTION C1-C2
C
      IF (NLTRA) THEN
C  IF ICHRD=0:
C  C2(1) R COORDINATES IN THE TORUS SYSTEM (INCL. R0A!)
C  C2(2) Z COORDINATES (REFERRED TO AS Y-COORDIANTE IN EIRENE)
C  C2(3) ARE TOROIDAL ANGLES IN DEGREES
C  ELSE
C  C2 IS A VECTOR GIVEN IN THE LOCAL TOROIDAL CELL IPERID=ICHRD
C
C  IPVOT, C1 SAME AS FOR ICHRD AND C2
C
C  STARTING POINT C2:
C
        IF (ICHRD.EQ.0) THEN
          X22  =C2(1)
          PHI22=C2(3)*PIA/180.D0
          IF (PHI22.LT.ZSURF(1).OR.PHI22.GT.ZSURF(NTTRA)) THEN
            CALL MASAGE ('ERROR IN LININT, WRONG INPUT FOR CHORDS ')
            CALL EXIT_OWN(1)
          ENDIF
C  FIND TOROIDAL BLOCK NUMBER OF P2
          IPERID_2=LEARCA(PHI22,ZSURF,1,NTTRA,1,'LININT 1 ')
C  FIND LOCAL CO-ORDINATES IN IPERID_2 FOR C2: X0,Z0
          CALL FZRTRI(X0,Z0,IPERID_2,X22,PHI22,IPERID_2)
          Y0=C2(2)
        ELSE
          WRITE (iunout,*) 'ERROR IN LININT, 1'
          CALL EXIT_OWN(1)
        ENDIF
C
C  PIVOT POINT C1:
        IF (IPVOT.EQ.0) THEN
          X11=C1(1)
          PHI11=C1(3)*PIA/180.D0
          IF (PHI11.LT.ZSURF(1).OR.PHI11.GT.ZSURF(NTTRA)) THEN
            CALL MASAGE ('ERROR IN LININT, WRONG INPUT FOR CHORDS ')
            CALL EXIT_OWN(1)
          ENDIF
C  FIND TOROIDAL BLOCK NUMBER OF P1
          IPERID_1=LEARCA(PHI11,ZSURF,1,NTTRA,1,'LININT 2 ')
C  FIND LOCAL CO-ORDINATES IN IPERID_2 FOR C1: X0_2,Z0_2
          CALL FZRTRI(XPIV,ZPIV,IPERID_2,X11,PHI11,IPERID_1)
          YPIV=C1(2)
C
C  DIRECTION COSINUS OF CHORD, IN IPERID_2
          VELX=X0-XPIV
          VELY=Y0-YPIV
          VELZ=Z0-ZPIV
        ELSE
          WRITE (iunout,*) 'ERROR IN LININT, 2'
          CALL EXIT_OWN(1)
        ENDIF
C
      ELSEIF (NLTRZ) THEN
C
C  C1(1) AND C2(1) X COORDINATES (CM)
C  C1(2) AND C2(2) Y COORDINATES (CM)
C  C1(3) AND C2(3) Z COORDINATES (CM)
        X0=C2(1)
        Y0=C2(2)
        Z0=C2(3)
        VELX=C2(1)-C1(1)
        VELY=C2(2)-C1(2)
        VELZ=C2(3)-C1(3)
C
      ELSEIF (NLTRT) THEN
C
C  C1(1) AND C2(1) R COORDINATES IN CYLINDRICAL CO-ORDINATES
C  C1(2) AND C2(2) Z COORDINATES IN CYLINDRICAL CO-ORDINATES
C  C1(3) AND C2(3) ARE TOROIDAL ANGLES IN DEGREES
C
C  TO BE WRITTEN
        WRITE (iunout,*) 'ERROR IN LININT, 3'
        CALL EXIT_OWN(1)
      ENDIF
C
      VEL=SQRT(VELX*VELX+VELY*VELY+VELZ*VELZ)
      VELX=-VELX/VEL
      VELY=-VELY/VEL
      VELZ=-VELZ/VEL
      VEL=1.
C
      TIME=0.
C
      ITYP=0
      IPHOT=0
      ISPZ=0
      NPANU=0
      ISAVE=0
C
C NEXT: FIND STARTING POINT FOR INTEGRATION, CELL NUMBERS
C       START SEARCH AT C2. CELL NUMBERS OF C2:
C
      NBLOCK=NBC2
      NACELL=NAC2
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
C
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      MSURF=0
      IPOLG=1
      ITIME=1
      IFPATH=1
      IUPDTE=1
      ICOL=0
C
      IF (NLTRA) THEN
        X01=X0+RMTOR
        PHI=PHI22
        IPERID=IPERID_2
      ELSEIF (NLTRZ) THEN
C  NOTHING TO BE DONE
      ELSEIF (NLTRT) THEN
C  to be written
      ENDIF
C
      NRCELL=0
      IF (NLRAD.AND.NACELL.EQ.0) THEN
          NRCELL=LEARC1 (X0,Y0,Z0,IPOLG,1,NR1STM,.FALSE.,.FALSE.,0,
     .                  'LININT      ')
      ENDIF
C
      NTCELL=1
      IF (NLTOR.AND.NACELL.EQ.0) THEN
        IF (NLTRZ) NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'LININT      ')
        IF (NLTRA) NTCELL=IPERID
      ENDIF
C
      NPCELL=1
      IF (NLPOL.AND.NACELL.EQ.0) THEN
        IF (LEVGEO.EQ.1) THEN
          NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'LININT')
        ELSEIF (LEVGEO.EQ.2) THEN
          IF (NLCRC) THEN
            WINK=MOD(ATAN2(Y0,X0)+PI2A,PI2A)
            NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'LININT')
          ELSE
            NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'LININT  ')
          ENDIF
        ELSEIF (LEVGEO.EQ.3) THEN
          NPCELL=IPOLG
        ELSE
          WRITE (iunout,*) 'ERROR EXIT FROM DIAGNO. NLPOL ',LEVGEO
        ENDIF
      ENDIF
C
      IF (TRCSIG.AND.IFIRST.EQ.0) THEN
        TRCSAV=TRCHST
        TRCHST=.TRUE.
        NPANU=ICHORI
        ISPZ=0
        CALL LEER(2)
        WRITE (iunout,*) 'INIT. POINT C2 IN LININT: '
        CALL CHCTRC(X0,Y0,Z0,0,1)
        CALL LEER(1)
        TRCHST=TRCSAV
      ENDIF
C
11    CONTINUE
      IF (NLTRA) X01=X0+RMTOR
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C  CLEAR WORK VARIABLES AND: CONTINUE FLIGHTS THROUGH TRANSPARENT
C                            SURFACES FROM THIS POINT
14    CONTINUE
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
      NJUMP=0
      DO I=1,NIMINT
        IM=IIMINT(I)
        TIMINT(IM)=0._DP
        IIMINT(I)=0
      END DO
      NIMINT = 0
      TT=1.D30
      TL=1.D30
      TS=1.D30
      ZTST=1.D30
      ZT=0.0
C
      NCOU=1
      NUPC(1)=0
      NCOUNT(1)=1
      NCOUNP(1)=1
      ISRFCL=-1
C
C TL: DISTANCE TO NEXT ADDITIONAL SURFACE
      IF (NCELL.LE.NOPTIM) THEN
        NLI=NLIMII(NCELL)
        NLE=NLIMIE(NCELL)
      ELSE
        NLI=1
        NLE=NLIMI
      ENDIF
      IF (NLI.LE.NLE) THEN
        CALL TIMEA1 (MSURF,NCELL,NLI,NLE,NTCELL,IPERID,X0,Y0,Z0,TIME,
     .               VELX,VELY,VELZ,VEL,
     .               MASURF,XLI,YLI,ZLI,SG,TL,NLTRC,LCNDEXP)
C       NLPR.....
        ZDT1=TL
        ZTST=TL
        CLPD(1)=ZDT1
        IF (MASURF.NE.0) ISRFCL=1
      ENDIF
C
C  SCAN OVER SEGMENT
C
21    CONTINUE
C
C  TS:   DISTANCE TO NEXT SURFACE OF STANDARD MESH
C  ZDT1: DISTANCE TRAVELLED IN CURRENT RADIAL CELL
C
      IF (ITIME.EQ.1) THEN
        IF (NLRAD) THEN
          CALL TIMER(TS)
C
          IF (TL.LT.TS.OR.TT.LT.TS) THEN
            MRSURF=0
            IPOLGN=0
C  COLLISION WITH ADDITIONAL SURFACE
            IF (TL.LE.TT) THEN
              ZDT1=TL-ZT
              TL=ZT+ZDT1
              ZTST=TL
              ISRFCL=1
C  COLLISION WITH TIME SURFACE
C           ELSEIF (TT.LT.TL) THEN
C             ZDT1=TT-ZT
C             TT=ZT+ZDT1
C             ZTST=TT
C             ISRFCL=2
            ENDIF
          ELSE
C  COLLISION WITH RADIAL SURFACE
            ISRFCL=0
            ZDT1=TS-ZT
            ZTST=TS
          ENDIF
        ENDIF
C
        NCOU=1
        NUPC(1)=0
        CLPD(1)=ZDT1
        NCOUNT(1)=1
        NCOUNP(1)=1
C
        IF (NLTOR.OR.NLTRA) THEN
          CALL TIMET (ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (NLPOL) THEN
          CALL TIMEP(ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (ZDT1.LE.0.) GOTO 990
      ENDIF
      IF (ZTST.GE.1.D30) GOTO 990
C
      IF (NLPOL) NPCELL=NCOUNP(NCOU)
      IF (NLTOR) NTCELL=NCOUNT(NCOU)
      ZT=ZTST
C
C  STOP TRACK ?
C
      IF (ISRFCL.EQ.1) CALL ADDCOL (XLI,YLI,ZLI,SG,*14  ,*38 )
C     IF (ISRFCL.EQ.2) CALL TIMCOL (...                          )
      IF (ISRFCL.EQ.3) CALL TORCOL (               *14 )
C
C  NO, CONTINUE TRACK
C
26    CONTINUE
C
C  NEXT CELL - CHECK FOR ESCAPE OR NON DEFAULT ACTING STANDARD SURFACE
C
      IF (LEVGEO.LE.3) THEN
C
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=NPCELL+(NTCELL-1)*NP2T3
          CALL STDCOL (ISTS,1,SG,*14,*38)
        ENDIF
        ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
        IF (NLPOL.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCY)
          NLSRFY=.TRUE.
          MSURFG=NRCELL+(NTCELL-1)*NR1P2
          CALL STDCOL (ISTS,2,SG,*14,*38)
        ENDIF
        ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
        IF (NLTOR.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCZ)
          NLSRFZ=.TRUE.
          MSURFG=NRCELL+(NPCELL-1)*NR1P2
          CALL STDCOL (ISTS,3,SG,*14,*38)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.4) THEN
        ISTS=ABS(INMTI(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=INSPAT(IPOLGN,MRSURF)
          CALL STDCOL (ISTS,1,SG,*14,*38)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.5) THEN
        ISTS=ABS(INMTIT(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          IF (NRCELL == 0) SG = -1.D0
          NLSRFX=.TRUE.
C         MSURFG= ??
          CALL STDCOL (ISTS,1,SG,*14,*38)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.10) THEN
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          CALL STDCOL (ISTS,1,SG,*14,*38)
        ENDIF
      ENDIF
C
      NRCELL=NRCELL+NINCX
      IF (NRCELL.GT.NR1STM.OR.NRCELL.LT.1) GOTO 991
      GOTO 21
C
38    CONTINUE
      IF (ILIIN(MSURF).LE.0) GOTO 14
C
C  STARTING POINT FOR INTEGRATION FOUND:  SURFACE MSURF
C
16    VELX=-VELX
      VELY=-VELY
      VELZ=-VELZ
C
C  SAVE STARTING POINT FOR FURTHER LINE INTEGRALS ALONG SAME CHORD
C
      NRCLLS=NRCELL
      IPOLGS=IPOLG
      MRSRFS=MRSURF
      MPSRFS=MPSURF
      MTSRFS=MTSURF
      NPCLLS=NPCELL
      NTCLLS=NTCELL
      MSURFS=MSURF
      NACLLS=NACELL
      NBOCKS=NBLOCK
      NBCKAS=NBLCKA
      IF (NLTRA) PHIS=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,X0+RMTOR),PI2A)
      X0S=X0
      Y0S=Y0
      Z0S=Z0
      VELXS=VELX
      VELYS=VELY
      VELZS=VELZ
C
C  INTERSECTION POINT WITH NEAREST NON-TRANSPARENT SURFACE
C  HAS NOW BEEN CALCULATED
C  TAKE THIS AS STARTING POINT FOR LINE INTEGRATION
C  THE END POINT FOR LINE INTEGRATION WILL BE FOUND DURING INTEGRATION
C  LOOP, SEE STATEMENT 380 FF, BELOW
C
100   CONTINUE
C
C  INITIALIZE *TIMER*,*TIMEP*,*TIMET*,*TIMEA* AND SIGNAL DATA
C
      MSURF=MSURFS
      IPOLG=IPOLGS
      MRSURF=MRSRFS
      MPSURF=MPSRFS
      MTSURF=MTSRFS
      NLSRFX=MRSURF.GT.0
      NLSRFY=MPSURF.GT.0
      NLSRFZ=MTSURF.GT.0
      NRCELL=NRCLLS
      NPCELL=NPCLLS
      NTCELL=NTCLLS
      NACELL=NACLLS
      NBLOCK=NBOCKS
      NBLCKA=NBCKAS
      X0=X0S
      Y0=Y0S
      Z0=Z0S
      VELX=VELXS
      VELY=VELYS
      VELZ=VELZS
      VEL=1.
      TIME=0.
      IF (NLTRA) PHI=PHIS
C
      IF (TRCSIG.AND.IFIRST.EQ.0) THEN
        TRCSAV=TRCHST
        TRCHST=.TRUE.
        NPANU=ICHORI
        ISPZ=0
        CALL LEER(2)
        WRITE (iunout,*) 'SIGNAL: STARTING POINT ON CHORD'
        CALL CHCTRC(X0,Y0,Z0,16,8)
        CALL LEER(1)
        TRCHST=TRCSAV
      ENDIF
C
C  INITIALISE LINE INTEGRATION
C
      JJJ=1
      XNTG(1)=0.
      TRACKS=0.
      IF (IFIRST >= 0) THEN
        IF (NCHTAL(ICHORI).EQ.1) THEN
          CALL SIGCX (0,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
        ELSEIF (NCHTAL(ICHORI).EQ.2) THEN
          CALL SIGHA (0,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
        ELSEIF (NCHTAL(ICHORI).EQ.3) THEN
          CALL SIGRAD(0,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
        ELSEIF (NCHTAL(ICHORI).EQ.10) THEN
          CALL SIGUSR(0,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST,XD0,YD0,ZD0,
     .                XD1,YD1,ZD1)
        ELSE
          CALL SIGTST(0,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
        ENDIF
      END IF

      IF (IFIRST < 0) THEN
        TRAJ(ICHORI)%TRJ%VX = VELX
        TRAJ(ICHORI)%TRJ%VY = VELY
        TRAJ(ICHORI)%TRJ%VZ = VELZ
      END IF
C
101   CONTINUE
      IF (NLTRA) X01=X0+RMTOR
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C  CLEAR WORK VARIABLES AND: CONTINUE FLIGHTS THROUGH TRANSPARENT
C                            SURFACES FROM THIS POINT
104   CONTINUE
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
      NJUMP=0
      DO I=1,NIMINT
        IM=IIMINT(I)
        TIMINT(IM)=0._DP
        IIMINT(I)=0
      END DO
      NIMINT = 0
      TT=1.D30
      TL=1.D30
      TS=1.D30
      ZTST=1.D30
      ZT=0.0
C
      NCOU=1
      NUPC(1)=0
      NCOUNT(1)=1
      NCOUNP(1)=1
      ISRFCL=-1
C
C TL: DISTANCE TO NEXT ADDITIONAL SURFACE
      IF (NCELL.LE.NOPTIM) THEN
        NLI=NLIMII(NCELL)
        NLE=NLIMIE(NCELL)
      ELSE
        NLI=1
        NLE=NLIMI
      ENDIF
      IF (NLI.LE.NLE) THEN
        CALL TIMEA1 (MSURF,NCELL,NLI,NLE,NTCELL,IPERID,X0,Y0,Z0,TIME,
     .               VELX,VELY,VELZ,VEL,
     .               MASURF,XLI,YLI,ZLI,SG,TL,NLTRC,LCNDEXP)
C       NLPR.....
        ZDT1=TL
        ZTST=TL
        CLPD(1)=ZDT1
        IF (MASURF.NE.0) ISRFCL=1
      ENDIF
C
C  SCAN OVER SEGMENT
C
210   CONTINUE
C
C  TS:   DISTANCE TO NEXT SURFACE OF STANDARD MESH
C  ZDT1: DISTANCE TRAVELLED IN CURRENT RADIAL CELL
C
      IF (ITIME.EQ.1) THEN
        IF (NLRAD) THEN
          CALL TIMER(TS)
C
          IF (TL.LT.TS.OR.TT.LT.TS) THEN
            MRSURF=0
            IPOLGN=0
C  COLLISION WITH ADDITIONAL SURFACE
            IF (TL.LE.TT) THEN
              ZDT1=TL-ZT
              TL=ZT+ZDT1
              ZTST=TL
              ISRFCL=1
C  COLLISION WITH TIME SURFACE
C           ELSEIF (TT.LT.TL) THEN
C             ZDT1=TT-ZT
C             TT=ZT+ZDT1
C             ZTST=TT
C             ISRFCL=2
            ENDIF
          ELSE
C  COLLISION WITH RADIAL SURFACE
            ISRFCL=0
            ZDT1=TS-ZT
            ZTST=TS
          ENDIF
        ENDIF
C
        NCOU=1
        NUPC(1)=0
        CLPD(1)=ZDT1
        NCOUNT(1)=1
        NCOUNP(1)=1
        ZDS=ZDT1
C
        IF (NLTOR.OR.NLTRA) THEN
          CALL TIMET (ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (NLPOL) THEN
          CALL TIMEP(ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (ZDT1.LE.0.) GOTO 990
      ENDIF
      IF (ZTST.GE.1.D30) GOTO 990
C

      IF (IFIRST < 0) THEN
        TRAJ(ICHORI)%TRJ%NCOU_CELL = TRAJ(ICHORI)%TRJ%NCOU_CELL + NCOU
        DO J=1,NCOU
          NCELL=NRCELL+NUPC(J)*NR1P2+NBLCKA
          NCELLT=NCLTAL(NCELL)
C         WRITE (IUNOUT,*) NCELL, NCELLT
          ALLOCATE(NEW_CELL)
          NEW_CELL%NO_CELL = NCELL
          NEW_CELL%FLIGHT = CLPD(J)
          CALL CELL_INSERT(ICHORI,NEW_CELL)
        END DO 
      END IF

      DO 250 J=1,NCOU
        JJ=J
        NCELL=NRCELL+NUPC(J)*NR1ST+NBLCKA
        XD0 = X0 + ZT*VELX
        YD0 = Y0 + ZT*VELY
        ZD0 = Z0 + ZT*VELZ
        ZT=ZT+CLPD(J)
        ZDS=CLPD(J)
        XD1 = X0 + ZT*VELX
        YD1 = Y0 + ZT*VELY
        ZD1 = Z0 + ZT*VELZ
        IF (ZDS.LT.0.) GOTO 990
        JJJ=JJJ+1
        IF (JJJ.GT.NRAD) GOTO 995
        XNTG(JJJ)=TRACKS+ZDS*0.5
        TRACKS=TRACKS+ZDS
C
        IF (IFIRST >= 0) THEN
          IF (NCHTAL(ICHORI).EQ.1) THEN
            CALL SIGCX (1,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
          ELSEIF (NCHTAL(ICHORI).EQ.2) THEN
            CALL SIGHA (1,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
          ELSEIF (NCHTAL(ICHORI).EQ.3) THEN
            CALL SIGRAD (1,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
          ELSEIF (NCHTAL(ICHORI).EQ.10) THEN
            CALL SIGUSR(1,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST,XD0,YD0,ZD0,
     .                  XD1,YD1,ZD1)
          ELSE
            CALL SIGTST(1,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
          ENDIF
        ENDIF
C
250   CONTINUE
C
C  STOP TRACK ?
C
      IF (ISRFCL.EQ.1) CALL ADDCOL (XLI,YLI,ZLI,SG,*104,*380)
C     IF (ISRFCL.EQ.2) CALL TIMCOL (...            *104,*800)
      IF (ISRFCL.EQ.3) CALL TORCOL (               *104)
C
C  NO, CONTINUE TRACK
C
C  NEXT CELL - CHECK FOR ESCAPE OR NON DEFAULT ACTING STANDARD SURFACE
C
      IF (LEVGEO.LE.3) THEN
C
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=NPCELL+(NTCELL-1)*NP2T3
          CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
        ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
        IF (NLPOL.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCY)
          NLSRFY=.TRUE.
          MSURFG=NRCELL+(NTCELL-1)*NR1P2
          CALL STDCOL (ISTS,2,SG,*104,*380)
        ENDIF
        ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
        IF (NLTOR.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCZ)
          NLSRFZ=.TRUE.
          MSURFG=NRCELL+(NPCELL-1)*NR1P2
          CALL STDCOL (ISTS,3,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.4) THEN
        ISTS=ABS(INMTI(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=INSPAT(IPOLGN,MRSURF)
          CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.5) THEN
        ISTS=ABS(INMTIT(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          IF (NRCELL == 0) SG = -1.D0
          NLSRFX=.TRUE.
C         MSURFG= ??
          CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.10) THEN
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
      ENDIF
C
      NRCELL=NRCELL+NINCX
      IF (NRCELL.GT.NR1STM.OR.NRCELL.LT.1) GOTO 991
C
      GOTO 210
C
C   CELL LOOP FINISHED
C
380   CONTINUE
      IF (ILIIN(MSURF).LE.0) GOTO 104
C
      IF (TRCSIG.AND.IFIRST.EQ.0) THEN
        TRCSAV=TRCHST
        TRCHST=.TRUE.
        NPANU=ICHORI
        ISPZ=0
        CALL LEER(2)
        WRITE (iunout,*) 'SIGNAL: END POINT ON CHORD'
        CALL CHCTRC(X0,Y0,Z0,16,8)
        CALL LEER(2)
        TRCHST=TRCSAV
      ENDIF
C
500   CONTINUE
C
C  LINE OF SIGHT INTEGRATION IS DONE NOW.
C  DEALLOCATE ARRAYS IN SIGCX, SIGRAD, ETC...
C

      IF (IFIRST < 0) RETURN

      IF (NCHTAL(ICHORI).EQ.1) THEN
        CALL SIGCX (2,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
      ELSEIF (NCHTAL(ICHORI).EQ.2) THEN
C       CALL SIGHA (2,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
      ELSEIF (NCHTAL(ICHORI).EQ.3) THEN
        CALL SIGRAD (2,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
      ELSEIF (NCHTAL(ICHORI).EQ.10) THEN
C       CALL SIGUSR(2,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST,XD0,YD0,ZD0,
C    .              XD1,YD1,ZD1)
      ELSE
C       CALL SIGTST(2,JJJ,ZDS,PEN,PSIG,TIMAX,ARGST)
      ENDIF
C
      JJJ=JJJ+1
      XNTG(JJJ)=TRACKS
C
C  PLOT INDIVIDUAL CONTRIBUTIONS ALONG LINE OF SIGHT.
C  ACTIVATION OF THIS PLOT DISABLES FURTHER LINE OF SIGHTS TO BE
C  PLOTTED INTO GEOMETRY PLOT.
C
      IF (PLSPEC.AND.TRCSIG) THEN
        IF (PLHST) THEN
          WRITE (IUNOUT,*) 'FROM LININT: '
          WRITE (IUNOUT,*) 'PLOTTING OF FURTHER LINE OF SIGHTS DISABLED'
          WRITE (IUNOUT,*) 'BECAUSE NEW FRAME FOR CONTRIBUTIONS ALONG  '
          WRITE (IUNOUT,*) 'LINE OF SIGHT                              '
          PLHST=.FALSE.
        ENDIF
        IF (ISP.GT.0.AND.ISP.LE.NSPI) THEN
          AA(1:JJJ) = ARGST(ISP,1:JJJ)
        ELSEIF (ISP.EQ.0) THEN
          AA(1:JJJ) = SUM(ARGST(1:NSPI,1:JJJ),1)
        ELSE
          WRITE (iunout,*) 'ERROR IN SUBR. LININT: ISP= ',ISP
          CALL EXIT_OWN(1)
        ENDIF
        PPMA = MAXVAL(AA(1:JJJ))
        IF (NCHTAL(ICHORI).EQ.1) AA(1:JJJ) = MAX(1._DP,AA(1:JJJ)) 
        IF (PPMA.GT.0._DP) THEN
          IPLOTS = IPLOTS + 1
          write (iunout,*) 'iplots,jen,nchni,ppma ',
     .     iplots,jen,nchni,ppma
          YPLOT(1:JJJ,IPLOTS) = AA(1:JJJ)
          YMN2(IPLOTS) = MINVAL(AA(1:JJJ))
          YMX2(IPLOTS) = MAXVAL(AA(1:JJJ))
          IF (ABS(YMX2(IPLOTS)-YMN2(IPLOTS)) < EPS30) 
     .        YMX2(IPLOTS) = YMN2(IPLOTS) + 1._dp
          YMNLG2(IPLOTS)=YMN2(IPLOTS)
          YMXLG2(IPLOTS)=YMX2(IPLOTS)
          LSDVI(IPLOTS)=.FALSE.
          LPLOT2(IPLOTS)=.TRUE.
          IR1(IPLOTS)=1
          IR2(IPLOTS)=JJJ
          IRS(IPLOTS)=1
          TXTALL(IPLOTS) = TXTSIG(ICHORI)
          TXSPEC(IPLOTS)=REPEAT(' ',24)
          TXUNIT(IPLOTS)=REPEAT(' ',24)
          TXSPEC(IPLOTS)(1:8)='ENERGY ='
          WRITE (TXSPEC(IPLOTS)(9:),'(ES12.4)') PEN
        END IF

        IF (JEN == NCHNI) THEN    ! last energy for this present chord?
C  INITALIZE NEW PICTURE FOR NEW CHORD
          IF (NSPSCL(ICHORI).EQ.0) THEN
            LOGX=.FALSE.
            LOGY=.FALSE.
          ELSEIF (NSPSCL(ICHORI).EQ.1) THEN
            LOGX=.FALSE.
            LOGY=.TRUE.
          ELSEIF (NSPSCL(ICHORI).EQ.2) THEN
            LOGX=.TRUE.
            LOGY=.FALSE.
          ELSEIF (NSPSCL(ICHORI).EQ.3) THEN
            LOGX=.TRUE.
            LOGY=.TRUE.
          ENDIF
          XMI = 0._DP
          XMA = XNTG(JJJ)
          FITY=.FALSE.
          TXHEAD=REPEAT(' ',72)
          IF (NCHTAL(ICHORI) == 1) 
     .      TXHEAD(1:58) = 
     .      'NET SOURCE DISTRIBUTION ALONG LINE OF SIGHT FOR CX SPECTRA'
          IF (NCHTAL(ICHORI) == 2) 
     .      TXHEAD(1:58) = 
     .      'EMISSIVITY DISTRIBUTION ALONG LINE OF SIGHT               '
          IF (NCHTAL(ICHORI) == 3)
     .      TXHEAD(1:58) = 
     .      'SPECTRAL EMISSIVITY DISTRIBUTION ALONG LINE OF SIGHT      '

          CALL PLTTLY (XNTG,YPLOT,VPLOT,YMN2,YMX2,
     .         IR1,IR2,IRS,
     .         IPLOTS,TXTALL,TXSPEC,TXUNIT,TXTRUN,TXHEAD,
     .         LSDVI,XMI,XMA,YMNLG2,YMXLG2,LPLOT2,.FALSE.,IERR,
     .         NRAD,NRAD,L_SAME)
        END IF
      END IF
C
      IF (TRCSIG) THEN
        IF (NCHTAL(ICHORI).EQ.1) THEN
          WRITE (iunout,*) 'ENERGY (EV): ',PEN
          WRITE (iunout,*)  'J,XNTG(J),ARGST(J), FOR IATM= ',ISP
          DO 530 J=1,JJJ
530         WRITE (iunout,*) J,XNTG(J),AA(J)
        ELSEIF (NCHTAL(ICHORI).EQ.2) THEN
          WRITE (iunout,*)  'J,XNTG(J),ARGST(J), CONTRIBUTION ISP= ',ISP
          DO 540 J=1,JJJ
540         WRITE (iunout,*) J,XNTG(J),AA(J)
        ELSEIF (NCHTAL(ICHORI).EQ.3) THEN
          WRITE (iunout,*) 'ENERGY (EV): ',PEN
          WRITE (iunout,*)  'J,XNTG(J),ARGST(J), FOR IPHOT = ',ISP
          DO 550 J=1,JJJ
550         WRITE (iunout,*) J,XNTG(J),AA(J)
        ENDIF
      ENDIF
C
      RETURN
C
990   CONTINUE
      CALL MASAGE ('ERROR IN LININT, STEP SIZE.LE.0. OR UNDEFINED  ')
      CALL MASR3 ('ZDT1,ZTST,ZDS=     ',ZDT1,ZTST,ZDS)
      CALL MASAGE ('INTEGRATION IN LININT IS STOPPED               ')
      CALL MASJ1 ('CHORD   ',ICHORI)
      GOTO 380
991   CONTINUE
      CALL MASAGE ('ERROR IN LININT, NRCELL OUT OF RANGE           ')
      CALL MASJ1 ('CHORD   ',ICHORI)
      CALL EXIT_OWN(1)
995   CONTINUE
      CALL MASAGE ('ERROR IN LININT, NOT ENOUGH STORAGE FOR LINE   ')
      CALL MASAGE ('INTEGRATION. INCREASE ARRAYS XNTG,ARGST,       ')
      CALL MASAGE ('AA AND ZWORK. EXIT CALLED                      ')
      CALL EXIT_OWN(1)
      RETURN
      END
