C EIRENE06 COMPILATION
C ===== SOURCE: addcol.f
!pb  05.10.06: option for single sided switching of additional surfaces introduced
C
      SUBROUTINE ADDCOL (XLI,YLI,ZLI,SG,*,*)
C
C  SG:    =SIGN OF COSINE OF ANGLE OF INCIDENCE
C  RETURN 1:  NO SURFACE TALLIES, FLIGHT CONTINUES
C  RETURN 2:  SURFACE TALLIES,
C             THEN ABSORBTION, REFLECTION MODEL OR CONTINUATION OF FLIGHT
C             (CALL SUBR. ESCAPE)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CGRID
      USE COMPRT
      USE CLGIN
      USE COUTAU

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: XLI, YLI, ZLI
      REAL(DP) :: WINK, CNORM, XL,YL, ZL, CSAVE, ROT, PPP, XXR, X0E,
     .          Y0E, Z0E, SCOSE, SG, XR, X0SA, Y0SA, Z0SA
      INTEGER :: LEARCA, LEARC1, LEARC2, IAN, IEN, IWEI, NACLLS, MM,
     .           MSURFE, ICOS, NN, NTNEW, MASRFS, IPERIDE
C
C   COLLISION WITH ADDITIONAL SURFACE NO. MASURF
C
C  SAVE DATA OF OLD POINT FOR DIAGNOSTICS
      X0SA=X0
      Y0SA=Y0
      Z0SA=Z0
      MASRFS=MSURF
      NACLLS=NACELL
C  SET NEW POINT ON ADDITIONAL SURFACE MASURF. FLIGHT TIME: TL
      X0=XLI  ! = X0 + VELX * TL
      Y0=YLI  ! = Y0 + VELY * TL
      Z0=ZLI  ! = Z0 + VELZ * TL
      TIME=TIME+TL/VEL
      MSURF=MASURF
      MRSURF=0
      MPSURF=0
      MTSURF=0
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
      SCOS=SG
      ICOS=SCOS
C  SET PHI AND X01
      IF (NLTRA) THEN
C  IN CASE OF NLTRA=TRUE, CO-ORDINATES ARE GIVEN IN LOCAL CO-ORDINATE SYSTEM
C  OF TOROIDAL CELL NO. ILTOR(MASURF),
C  WHICH MAY OR MAY NOT BE EQUAL IPERID!
C  FIND NEW LOCAL CO-ORDINATES X0,Z0, IN THE CORRECT ZONE
C  FIND TOROIDAL ANGLE PHI
C  AND TEST, IF NTNEW=NTCELL AS IT SHOULD BE
C  NTCELL MAY NOT BE KNOWN, IN CASE NLTRA AND NOT NLTOR!!
C  USE IPERID INSTEAD
        IF (ILTOR(MASURF).GT.0.AND.ILTOR(MASURF).NE.IPERID) THEN
          CALL FZRTOR(X0,Z0,ILTOR(MASURF),XR,PHI,NTNEW,NLTEST,IPERID)
          CALL FZRTRI(X0,Z0,NTNEW,XR,PHI,NTNEW)
        ELSE
          PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
        ENDIF
        X01=X0+RMTOR
      ENDIF
C  SET IPOLG
      IF (NRCELL.GT.0.AND.NRCELL.LE.NR1STM) THEN
        IF (LEVGEO.EQ.3.OR.(LEVGEO.EQ.2.AND.NLPOL))
     .  NN=LEARC1(X0,Y0,Z0,IPOLG,NRCELL,NRCELL,.FALSE.,.FALSE.,
     .                           NPANU,'ADDCOL  ')
      ENDIF
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C
C  DEFAULT CELL SWITCHING NOT NEEDED HERE, BECAUSE ADDITIONAL SURFACE
C
      IWEI=ILSIDE(MASURF)*ICOS
      IF (IWEI.LT.0) GOTO 300
      IF (ILIIN(MASURF).EQ.2) GOTO 400
C
C  OPERATE A SWITCH
C
      IF (ILSWCH(MASURF).NE.0) THEN
C
C  TURN ON OR OFF THE STANDARD GRID CALCULATION (ONLY ADD. SRF).
        IF (ISWICH(1,MASURF).NE.0) ITIME=ICOS*ISWICH(1,MASURF)
C
C  TURN ON OR OFF MFP AND REACTION RATES: PARTICLE ENTERS VACUUM
        IF (ISWICH(2,MASURF).NE.0) IFPATH=ICOS*ISWICH(2,MASURF)
C
C  TURN ON OR OFF VOLUME AVERAGED TALLIES
        IF (ISWICH(3,MASURF).NE.0) IUPDTE=ICOS*ISWICH(3,MASURF)
C
C  NEW ADD. CELL INDEX NACELL, IF PARTICLE IN ADDITIONAL CELL REGION
C  NEW BLOCK INDEX NBLOCK, IF PARTICLE IN STD. MESH REGION
        IF (ISWICH(4,MASURF).NE.0) THEN
          IF (NACELL.GT.0) THEN
            NACELL=NACELL+ISWICH(4,MASURF)*ICOS*ILACLL(MASURF)
            IF (NACELL.GT.NRADD.OR.NACELL.LT.1) THEN
              IWEI=-10
              GOTO 300
            ENDIF
          ELSEIF (NACELL.EQ.0) THEN
            NBLOCK=NBLOCK+ILBLCK(MASURF)*ICOS*ISWICH(4,MASURF)
            IF (.NOT.NLMLT.OR.(NBLOCK.GT.NBMLT.OR.NBLOCK.LT.1)) THEN
              IWEI=-10
              GOTO 300
            ENDIF
          ENDIF
          NBLCKA=NSTRD*(NBLOCK-1)+NACELL
C
C  ENTRANCE INTO STANDARD MESH, INTO BLOCK NBLOCK=ILBLCK
C  OR
C  EXIT FROM STANDARD MESH, INTO CELL NACELL=ILACLL
        ELSEIF (ISWICH(5,MASURF).NE.0) THEN
          IF (NACELL.EQ.0) THEN
C  SET CELL INDEX EQUAL TO ILACLL
            IF (ILACLL(MASURF) > 0) THEN
              NACELL=ILACLL(MASURF)
              NBLOCK=NBMLTP
              NRCELL=0
              NPCELL=1
              NTCELL=1
              IF (.NOT.NLADD.OR.NACELL.GT.NRADD.OR.NACELL.LT.1) THEN
                IWEI=-10
                GOTO 300
              ENDIF
            ENDIF
          ELSEIF (NACELL.GT.0) THEN
C  ENTRANCE INTO STANDARD MESH, INTO NBLOCK=ILBLCK
            NBLOCK=ILBLCK(MASURF)
            NACELL=0
C  FIND  NRCELL,IPOLG,NPCELL,NTCELL IN STANDARD MESH, BLOCK ILBLCK
C
            IAN=1
            IEN=NR1STM
            NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,.FALSE.,.FALSE.,NPANU,
     .                   'ADDCOL      ')
C
C  FIND NTCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLTOR) THEN
              IF (NLTRZ) THEN
                NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'ADDCOL   ')
              ELSEIF (NLTRA) THEN
                NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'ADDCOL   ')
                IPERID=NTCELL
              ENDIF
            ELSE
              NTCELL=1
              IF (NLTRA) IPERID=LEARCA(PHI,ZSURF,1,NTTRA,1,'ADDCOL   ')
            ENDIF
            IF (NLPOL) THEN
              IF (LEVGEO.EQ.1) THEN
                NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'ADDCOL')
              ELSEIF (LEVGEO.EQ.2) THEN
                IF (NLCRC) THEN
                  WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
                  NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'ADDCOL')
                ELSE
                  NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'ADDCOL')
                ENDIF
              ELSEIF (LEVGEO.EQ.3) THEN
                NPCELL=IPOLG
              ELSE
                WRITE (iunout,*) 'ERROR EXIT FROM ADDCOL. NLPOL ',LEVGEO
                CALL EXIT_OWN(1)
              ENDIF
            ELSE
              NPCELL=1
            ENDIF
          ENDIF
          NBLCKA=NSTRD*(NBLOCK-1)+NACELL
C  ENTRANCE INTO STANDARD MESH, BLOCK ILBLCK
C  OR
C  EXIT FROM STANDARD MESH, INTO NACELL=NBLOCK+ILACLL
        ELSEIF (ISWICH(6,MASURF).NE.0) THEN
          IF (NACELL.EQ.0) THEN
C  SET CELL INDEX EQUAL TO NBLOCK+ILACLL
            NACELL=NBLOCK+ICOS*ISWICH(6,MASURF)*ILACLL(MASURF)
            NBLOCK=NBMLTP
C
            NRCELL=0
            NPCELL=1
            NTCELL=1
            IF (.NOT.NLADD.OR.NACELL.GT.NRADD.OR.NACELL.LT.1) THEN
              IWEI=-10
              GOTO 300
            ENDIF
          ELSEIF (NACELL.GT.0) THEN
C  ENTRANCE INTO STANDARD MESH, INTO BLOCK NBLOCK=NACELL+ILBLCK
            NBLOCK=NACELL+ICOS*ISWICH(6,MASURF)*ILBLCK(MASURF)
            NACELL=0
C  FIND  NRCELL,IPOLG IN STANDARD MESH, BLOCK NBLOCK
C
C           IF (IDIM.EQ. ???) THEN
              NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,
     .                     .FALSE.,.FALSE.,NPANU,
     .                     'ADDCOL      ')
C           ENDIF
C  FIND NTCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLTOR) THEN
              IF (NLTRZ) THEN
                NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'ADDCOL    ')
              ELSEIF (NLTRA) THEN
                NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'ADDCOL   ')
                IPERID=NTCELL
              ENDIF
            ELSE
              NTCELL=1
              IF (NLTRA) IPERID=LEARCA(PHI,ZSURF,1,NTTRA,1,'ADDCOL   ')
            ENDIF
C  FIND NPCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLPOL) THEN
              IF (LEVGEO.EQ.1) THEN
                NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'ADDCOL')
              ELSEIF (LEVGEO.EQ.2) THEN
                IF (NLCRC) THEN
                  WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
                  NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'ADDCOL')
                ELSE
                  NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'ADDCOL')
                ENDIF
              ELSEIF (LEVGEO.EQ.3) THEN
                NPCELL=IPOLG
              ELSE
                WRITE (iunout,*) 'ERROR EXIT FROM ADDCOL. NLPOL ',LEVGEO
                CALL EXIT_OWN(1)
              ENDIF
            ELSE
              NPCELL=1
            ENDIF
          ENDIF
          NBLCKA=NSTRD*(NBLOCK-1)+NACELL
        ENDIF
      ENDIF
C
C  SWITCHING DONE
C
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,8)
C
      IF (ILIIN(MASURF).LT.0) THEN
        IF (ILIIN(MASURF).EQ.-1) RETURN 1
        RETURN 2
      ENDIF
C
C  ILIIN(MASURF) .GT. 0, AND  ILIIN(MASURF) .NE. 2
C  PREPARE REFLECTION, I.E. SET OUTER NORMAL
C
      GOTO 100
C
      ENTRY ADDNOR (X0E,Y0E,Z0E,SCOSE,MSURFE,IPERIDE,*,*)
      X0=X0E
      Y0=Y0E
      Z0=Z0E
      SCOS=SCOSE
      MSURF=MSURFE
      IPERID=IPERIDE
C
100   CONTINUE
C
C  COEFFICIENTS OF SURFACE MASURF MAY BE GIVEN IN LOCAL SYSTEM ILTOR(MASURF)
C  AND CURRENT PARTICLE CO-ORDINATES CORRESPOND TO LOCAL SYSTEM IPERID
C
      MM=MASURF
      IF (JUMLIM(MM).GT.0) THEN
        CRTX=A1LM(MM)*SCOS
        CRTY=A2LM(MM)*SCOS
        CRTZ=A3LM(MM)*SCOS
      ELSE
        IF (NLTRA.AND.ILTOR(MM).NE.0.AND.(IPERID.NE.ILTOR(MM))) THEN
          CALL FZRTOR (X0,Z0,IPERID,XXR,PPP,NTNEW,.FALSE.,0)
          CALL FZRTRI (XL,ZL,ILTOR(MM),XXR,PPP,NTNEW)
          YL=Y0
        ELSE
          XL=X0
          YL=Y0
          ZL=Z0
        ENDIF
        CRTX=A1LM(MM)+ALM (MM)*XL+A7LM(MM)*YL+A8LM(MM)*ZL
        CRTY=A2LM(MM)+A7LM(MM)*XL+BLM (MM)*YL+A9LM(MM)*ZL
        CRTZ=A3LM(MM)+A8LM(MM)*XL+A9LM(MM)*YL+CLM (MM)*ZL
        CNORM=1./SQRT(CRTX*CRTX+CRTY*CRTY+CRTZ*CRTZ)*SCOS
        CRTX=CRTX*CNORM
        CRTY=CRTY*CNORM
        CRTZ=CRTZ*CNORM
      ENDIF
      IF (NLTRA.AND.ILTOR(MM).NE.0.AND.(IPERID.NE.ILTOR(MM))) THEN
        ROT=-2.*(IPERID-ILTOR(MM))*ALPHA
        CSAVE=CRTX
        CRTX=COS(ROT)*CSAVE-SIN(ROT)*CRTZ
        CRTZ=SIN(ROT)*CSAVE+COS(ROT)*CRTZ
      ENDIF
      RETURN 2
C
C
300   CONTINUE
      IF (IWEI.EQ.-1) THEN
C  PARTICLE HAS HIT A SURFACE FROM AN ABSORBING SIDE
C  UPDATE FLUXES (DO NOT SET WEIGHT=0.D0) AND ABSORB PARTICLE
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,8)
          WRITE (iunout,*) 'ABSORB PARTICLE: NPANU ',NPANU
        ENDIF
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        LGPART=.FALSE.
        RETURN 2
      ELSEIF (IWEI.EQ.-2) THEN
        PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
        ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
C  KILL THIS PARTICLE BECAUSE IT COMES FROM WRONG SIDE
C  DO NOT UPDATE FLUXES (SET WEIGHT=0.D0)
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,18)
        ENDIF
        WRITE (iunout,*) 'ERROR DETECTED IN SUBR. ADDCOL '
        WRITE (iunout,*) 'PARTICLE COMES FROM WRONG SIDE '
        CALL MASJ1 ('NPANU=  ',NPANU)
        CALL MASJ1 ('MASRF NW',MASURF)
        CALL MASJ1 ('MASRF OD',MASRFS)
        CALL MASR3 ('X0,Y0,Z0 (NEW)          ',X0,Y0,Z0)
        CALL MASR3 ('X0,Y0,Z0 (OLD)          ',X0SA,Y0SA,Z0SA)
        CALL MASR3 ('VELX,VELY,VELZ          ',VELX,VELY,VELZ)
        CALL MASR2 ('WEIGHT,E0       ',WEIGHT,E0)
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        WEIGHT=0.
        LGPART=.FALSE.
        RETURN 2
      ELSEIF (IWEI.EQ.-3) THEN
C  SURFACE IS NOT SEEN BY THE PARTICLE BECAUSE OF ILSIDE OPTION
C  I.E. SURFACE IS TRANSPARENT FROM THIS SIDE
C  ACTS AS ILIIN=0 OPTION (NO SURFACE TALLIES, NO SWITCHES)
        RETURN 1
      ELSEIF (IWEI.EQ.-10) THEN
C  KILL THIS PARTICLE BECAUSE CELL NUMBER OF RANGE DUE TO SWITCHING
C  DO NOT UPDATE FLUXES (SET WEIGHT=0.D0)
        PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
        ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,18)
        ENDIF
        WRITE (iunout,*) 'ERROR DETECTED IN SUBR. ADDCOL '
        WRITE (iunout,*) 'SOME CELL INDEX OUT OF RANGE '
        CALL MASJ1 ('NPANU=  ',NPANU)
        WRITE (iunout,*) 'NLMLT,NLADD ',NLMLT,NLADD
        WRITE (iunout,*) 'NBMLT,NRADD ',NBMLT,NRADD
        CALL MASJ1 ('MASRF NW',MASURF)
        CALL MASJ1 ('MASRF OD',MASRFS)
        CALL MASJ1 ('NACL NEW',NACELL)
        CALL MASJ1 ('NACL OLD',NACLLS)
        CALL MASJ1 ('NBLOCK  ',NBLOCK)
        CALL MASR3 ('X0,Y0,Z0 (NEW)          ',X0,Y0,Z0)
        CALL MASR3 ('X0,Y0,Z0 (OLD)          ',X0SA,Y0SA,Z0SA)
        CALL MASR3 ('VELX,VELY,VELZ          ',VELX,VELY,VELZ)
        CALL MASR2 ('WEIGHT,E0       ',WEIGHT,E0)
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        WEIGHT=0.
        LGPART=.FALSE.
        RETURN 2
      ENDIF
C
400   CONTINUE
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,8)
      RETURN 2
      END
C ===== SOURCE: collide.f
C 27.6.05 : colphot: iadd removed
C 27.6.05 : colatm : mode, il removed (lgaot(..2),lgaot(..5)
C 27.6.05 : colphot: mode, il removed (lgphot(..2),lgphot(..5)
C 15.12.05: irds --> irei, iids --> iiei
C 16.12.05: wminv re-connected to "ei"-processes. suppress
C           reactions with zero test particle secondaries
C           now connected for: colatm, colmol, colion
C           still to be done: include other processes, and colphot
C 2.2.06:  wghtO set at suppression of absorption, for collision estimators.
C 2.2.06:  REMOVED: OT PROCESSES FOR ATOMS
C          GENERATION LIMIT FOR POST COLLISION ATOMS FROM PHOTONS: REMOVED
C 10.3.06: bug fix: LGEI_RED(NRDS) --> LGEI_RED(0:NRDS)
C          (some compilers had been unhappy with this)
C
      SUBROUTINE COLLIDE
C
C  SAMPLE FROM COLLISION KERNEL C
C
C  INPUT:  COMPRT, COMMON BLOCK, CONTAINING ACTUAL PARTICLE PARAMETERS
C          CFLAG,  FLAG FOR POST COLLISION KINETICS
C  OUTPUT: COMPRT, MODIFIED TO POST COLLISION PARTICLE PARAMETERS
C          COLTYP, FLAG: =1 CONTINUE IN CALLING ROUTINE
C                           (FOLNEUT OR FOLION)
C                        =2 EXIT FROM CALLING ROUTINE
C                           EITHER ABSORBTION, OR
C                           TRANSITION NEUTRAL-->ION (IF CALLED
C                           BY FOLNEUT), OR
C                           TRANSITION ION-->NEUTRAL (IF CALLED
C                           BY FOLION)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CRAND
      USE CINIT
      USE CZT1
      USE CGEOM
      USE COMPRT
      USE CSDVI
      USE COUTAU
      USE COMXS
      USE COMSPL
      USE PHOTON

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: CFLAG(7,3), DIST
      REAL(DP), INTENT(OUT) :: COLTYP
      REAL(DP) :: DUMT(3), DUMV(3)
      REAL(DP) :: ZEP1, SIGSUM, WGHTO, FRSTP, PTOT, E0O, VELXO,
     .          VELYO, VELZO, BX, BY, BZ, V0_PARBO, VELO, SCNDP,
     .          EDEL, VDEL, SIG, V0_PARB, FP, FLTEST, ZEP3, VELQ, VX,
     .          VY, VZ, VPLASP, RMAIO, RMMIO
      REAL(DP) :: SIG_ELIM, SIG_TOT_N, SIG_TOT_O, SIG_TEST
      INTEGER :: IICX, IIEI, IMEL, IOLD, NOLD, IACX, IRCX, IAEI, IREI,
     .           IBGK, IAD, IAEL, IREL, IP, IMEI, IMCX, IAPI, II, NFLAG,
     .           IATMN, IPLSN, IRPI, NCLLO, IPLSV
      INTEGER :: NEIIM_RED,NEII_RED,LGEI_RED(0:NRDS)


csw add n 2lines
      INTEGER :: iaot,irot,kk,updf,t1,t2
      real(dp):: sump
csw external
      integer, external :: idez
      real(dp), external :: ranf_eirene

      SAVE
C
      ENTRY COLATM(CFLAG,COLTYP,DIST)
C
C  INCIDENT SPECIES: IOLD
      VELXO=VELX
      VELYO=VELY
      VELZO=VELZ
      VELO=VEL
      NCLLO = NCELL
      NCELL = NCLTAL(NCLLO)

      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BX,BY,BZ,1)
      ELSE
        BX=BXIN(NCLLO)
        BY=BYIN(NCLLO)
        BZ=BZIN(NCLLO)
      END IF

      V0_PARBO=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
      V0_PARBO=V0_PARBO*AMUA*RMASSA(IATM)
      E0O=E0
      WGHTO=WEIGHT
      IOLD=IATM
      NOLD=NSPH+IATM

      IF (IMETCL(NCELL) == 0) THEN
        NCLMT = NCLMT+1
        ICLMT(NCLMT) = NCELL
        IMETCL(NCELL) = NCLMT
      END IF
C
C  ABSORBTION BIASSING: SUPPRESS IREI PROCESSES WITH ZERO
C                       TEST PARTICLE SECONDARIES

      SIG_ELIM=0.
      SIG_TOT_N=SIGTOT
      SIG_TOT_O=SIGTOT
      NEII_RED=0

      IF (WEIGHT.LT.WMINV) THEN
C  NO SUPPRESION OF ABSORPTION
        NEII_RED=NAEII(IOLD)
        LGEI_RED(:)=LGAEI(IOLD,:)
      ELSE
C  TRY TO SUPPRESS ABSORPTION. IDENTIFY POSSIBLE PROCESSES
C                              WITH ZERO TEST PARTICLE SECONARIES
      DO IAEI=1,NAEII(IOLD)
        IREI=LGAEI(IOLD,IAEI)
        IF (WEIGHT.GT.WMINV) THEN
C  REMAINING RATE AFTER POSSIBLE ELIMINATION OF IREI
C  SIG_TEST=0 WOULD VIOLATE RADON-NYKODYM CONDITION OF WEIGHTING
          SIG_TEST=SIG_TOT_N-SIGVEI(IREI)
          PTOT=P2NDS(IREI)
          IF (PTOT.EQ.0..AND.SIG_TEST.GT.0.) THEN
C  ELIMINATE PROCESS IREI FROM ALL POSSIBLE PROCESSES 
C  REDUCE WEIGHT ACCORDINGLY
            SIG_ELIM=SIG_ELIM+SIGVEI(IREI)
            SIG_TOT_N=SIG_TEST
            WEIGHT=WEIGHT*SIG_TOT_N/SIG_TOT_O
            WGHTO=WEIGHT
            SIG_TOT_O=SIG_TOT_N
            IF (IESTEI(IREI,1).NE.0) GOTO 990
            IF (IESTEI(IREI,2).NE.0) GOTO 990
            IF (IESTEI(IREI,3).NE.0) GOTO 990
          ELSE
C  NO, THIS PROCESS REMAINS ACTIVE
            NEII_RED=NEII_RED+1
            LGEI_RED(NEII_RED)=IREI
          ENDIF
        ELSE
C  WEIGHT TOO SMALL COMPARED TO WMINV. ANALOG GAME
          NEII_RED=NEII_RED+1
          LGEI_RED(NEII_RED)=IREI
        ENDIF
      ENDDO
      ENDIF
C
C  FIRST DECIDE: ELECTRON IMPACT OR ION IMPACT
C
      ZEP1=SIG_ELIM+RANF_EIRENE( )*SIG_TOT_N
      SIGSUM=SIG_ELIM
      NEIIM_RED=NEII_RED-1
C
      IF (ZEP1.LE.SIGEIT) THEN
C
C  AT THIS POINT: NEII.GE.1, FOR OTHERWISE ZEP1 COULD NOT HAVE
C                 POINTED TO EI-PROCESSES
C
C  ELECTRON IMPACT COLLISION:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,2)
        IF (NLSTOR) CALL STORE(2)

C  FIND TYP OF ELECTR. IMPACT COLLISION PROCESS: IREI
        DO 240 IAEI=1,NEIIM_RED
          IREI=LGEI_RED(IAEI)
          SIGSUM=SIGSUM+SIGVEI(IREI)
          IF (ZEP1.LE.SIGSUM) GOTO 245
240     CONTINUE
        IREI=LGEI_RED(NEII_RED)
245     CONTINUE
C
C  CALCULATE WEIGHT OF THE NEXT GENERATION PARTICLE
C  ONLY ONE ATOM, MOLECULE OR TEST-ION HISTORY WITH MODIFIED WEIGHT
C  IS FOLLOWED
C
        PTOT=P2NDS(IREI)
C       PTOTAL=PTOT+PPLDS(IREI,0)
C  ABSORBED WEIGHT: WEIABS
C       WEIABS=WEIGHT*PPLDS(IREI,0)
C
C  COLLISION ESTIMATOR FOR EAAT, EAPL AND EAEL
        IF (IESTEI(IREI,3).NE.0) THEN
          IF (LEAAT) EAAT(NCELL)=EAAT(NCELL)-WEIGHT*E0
          IF (LEAPL) EAPL(NCELL)=EAPL(NCELL)+WEIGHT*ESIGEI(IREI,4)
          IF (LEAEL) EAEL(NCELL)=EAEL(NCELL)+WEIGHT*ESIGEI(IREI,5)
        ENDIF
C
C  ABSORBTION (INTO BULK SPECIES) IS SUPPRESSED
        WEIGHT=WEIGHT*PTOT
C
C  ARE THERE TEST PARTICLE SECONDARIES AT ALL?
        IF (WEIGHT.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL=NCLLO
          RETURN
        ENDIF
C
        CALL VELOEI(NCLLO,IREI,VELXO,VELYO,VELZO,VELO)
        XGENER=0.D0
C
C  UPDATE COLLISION ESTIMATORS CONTRIBUTION TO EAAT;EAML;EAIO
        IF (ITYP.EQ.1) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEAAT) EAAT(NCELL)=EAAT(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=1
        ELSEIF (ITYP.EQ.2) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEAML) EAML(NCELL)=EAML(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=1
        ELSEIF (ITYP.EQ.3) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEAIO) EAIO(NCELL)=EAIO(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=2
        ENDIF
        NCELL = NCLLO
        RETURN
C
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT) THEN
C
C  CHARGE EXCHANGE:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,6)
C
C   FIND SPECIES INDEX OF CHARGE EXCHANGING BULK ION
        SIGSUM=SIGEIT
        DO 271 IACX=1,NACXIM(IATM)
          IRCX=LGACX(IATM,IACX,0)
          IPLS=LGACX(IATM,IACX,1)
          SIGSUM=SIGSUM+SIGVCX(IRCX)
          IF (ZEP1.LT.SIGSUM) GOTO 272
271     CONTINUE
        IRCX=LGACX(IATM,NACXI(IATM),0)
        IPLS=LGACX(IATM,NACXI(IATM),1)
272     CONTINUE
        FRSTP=N1STX(IRCX,3)
        SCNDP=N2NDX(IRCX,3)

        IPLSV=MPLSV(IPLS)
C
C  ARE THERE SECONDARY TEST PARTICLES AT ALL?

        IF (SCNDP.LE.EPS30) THEN
C  POST COLLISION ESTIMATOR FOR PAPL,EAPL,COPV: TO BE WRITTEN
C  E.G. FOR CX RECOMBINATION
          LGPART=.FALSE.
          IF (IESTCX(IRCX,1).NE.0) GOTO 999
          IF (IESTCX(IRCX,2).NE.0) GOTO 999
          IF (IESTCX(IRCX,3).NE.0) GOTO 999
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF
C
C  NEW SPECIES TYPE, INDEX AND ENERGY
C  SUPPRESSION OF ABSORBTION AT CX
C  I.E., NO RANDOM DECISION BETWEEN BULK AND TEST SECONDARIES
        WEIGHT=WEIGHT*SCNDP
        ZEP3=RANF_EIRENE( )*SCNDP
        IF (ZEP3.LE.FRSTP) THEN
C  FOLLOW FIRST SECONDARY, SPEED FROM BULK POPULATION
          ITYP=N1STX(IRCX,1)
          NFLAG=CFLAG(3,1)
          CALL VELOCX(NCLLO,VELXO,VELYO,VELZO,VELO,IOLD,NOLD,VELQ,
     .                NFLAG,IRCX,DUMT,DUMV)

          SELECT CASE(ITYP)
C
          CASE(1)
C  1ST SECONDARY IS ATOM
            IATM=N1STX(IRCX,2)
            E0=CVRSSA(IATM)*VELQ
C
C  GENERATION LIMIT
            IF (NGENA(IATM).GT.0) THEN
              IF (IATM.EQ.IOLD) THEN
                XGENER=XGENER+1.D0
              ELSE
                XGENER=0.D0
              ENDIF
              IF (XGENER.GT.NGENA(IATM)) THEN
C  UPDATE GENERATION LIMIT TALLIES
C  USE POST COLLISION WEIGHT, VELOCITY AND ENERGY
C  SHOULD MAKE NO DIFFERENCE ON AVERAGE, IF GENERATION LIMIT IS VALID.
C  IF NOT, ONLY THIS GIVES CORRECT BALANCES.
                IF (LPGENA) PGENA(IATM,NCELL)=PGENA(IATM,NCELL)-WEIGHT
                IF (LEGENA)
     .            EGENA(IATM,NCELL)=EGENA(IATM,NCELL)-WEIGHT*E0
                IF (LVGENA) THEN
                  V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                  V0_PARB=V0_PARB*AMUA*RMASSA(IATM)
                  VGENA(IATM,NCELL)=VGENA(IATM,NCELL)-WEIGHT*V0_PARB
                END IF
                LGPART=.FALSE.
                IF (LPGENA.OR.LEGENA.OR.LVGENA) LMETSP(NSPH+IATM)=.TRUE.
                IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,16)
                ITYP=4
                COLTYP=2
                NCELL = NCLLO
                RETURN
              ENDIF
            ENDIF
C
C  FLUID LIMIT
            IF (NGENA(IATM).LT.0) THEN
              FP=VELO/SIGVCX(IRCX)
              FLTEST=FP/DIST
              IF (FLTEST.LT.FDLMCX(IRCX)) THEN
C  UPDATE FLUID LIMIT TALLIES
C  USE POST COLLISION WEIGHT, VELOCITY AND ENERGY
C  SHOULD MAKE NO DIFFERENCE ON AVERAGE, IF GENERATION LIMIT IS VALID.
C  IF NOT, ONLY THIS GIVES CORRECT BALANCES.
                IF (LPGENA) PGENA(IATM,NCELL)=PGENA(IATM,NCELL)-WEIGHT
                IF (LEGENA)
     .            EGENA(IATM,NCELL)=EGENA(IATM,NCELL)-WEIGHT*E0
                IF (LVGENA) THEN
                  V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                  V0_PARB=V0_PARB*AMUA*RMASSA(IATM)
                  VGENA(IATM,NCELL)=VGENA(IATM,NCELL)-WEIGHT*V0_PARB
                END IF
                LGPART=.FALSE.
                IF (LPGENA.OR.LEGENA.OR.LVGENA) LMETSP(NSPH+IATM)=.TRUE.
                IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,17)
                ITYP=4
                COLTYP=2
                NCELL = NCLLO
                RETURN
              ENDIF
            ENDIF
C
C  NEXT LINES: COLLISION ESTIMATOR FOR CHARGE EXCHANGE NO. IRCX
C  CONSERVE CHARGE IN EACH COLLISION, NOT ONLY ON AVERAGE
C
            IF (IESTCX(IRCX,1).NE.0) THEN
C  IATMN ATOM SPECIES AFTER CX
              IATMN=IATM
              IF (LPAAT) THEN
                PAAT(IOLD,NCELL) =PAAT(IOLD,NCELL)-WGHTO
                PAAT(IATMN,NCELL)=PAAT(IATMN,NCELL)+WEIGHT
                LMETSP(NSPH+IOLD)=.TRUE.
                LMETSP(NSPH+IATMN)=.TRUE.
              END IF
              IF (LPAPL) THEN
                PAPL(IPLS,NCELL) =PAPL(IPLS,NCELL)-WEIGHT
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (LPAEL) PAEL(NCELL)      =PAEL(NCELL)-WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
C  IPLSN ION SPECIES AFTER CX
                IPLSN=N2NDX(IRCX,2)
                IF (LPAPL) THEN
                  PAPL(IPLSN,NCELL)=PAPL(IPLSN,NCELL)+WGHTO
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
                IF (LPAEL) PAEL(NCELL)      =PAEL(NCELL)+WGHTO
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            IF (IESTCX(IRCX,3).NE.0) THEN
              IF (LEAAT) EAAT(NCELL)=EAAT(NCELL)-E0O*WGHTO
              IF (LEAAT) EAAT(NCELL)=EAAT(NCELL)+E0*WEIGHT
              IF (LEAPL) EAPL(NCELL)=EAPL(NCELL)-E0*WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LEAPL) EAPL(NCELL)=EAPL(NCELL)+E0O*WGHTO
              ELSE
                GOTO 999
              ENDIF
            ENDIF
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION TO MAPL (COPV)
            IF (IESTCX(IRCX,2).NE.0) THEN
              IF (LMAPL) THEN
                V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                V0_PARB=V0_PARB*AMUA*RMASSA(IATM)
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR(2,VX,VY,VZ,IPLSV)
                  VPLASP=VX*BX+VY*BY+VZ*BZ
                ELSE
                  VPLASP = BVIN(IPLSV,NCLLO)
                ENDIF
                SIG=SIGN(1._DP,VPLASP)
C ASSUME: OLD (INCIDENT) ION MOMENTUM IS EQUAL TO NEW ATOM MOMENTUM
                MAPL(IPLS,NCELL)=MAPL(IPLS,NCELL)-WEIGHT*V0_PARB*SIG
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LMAPL) THEN
C  IPLSN ION SPECIES AFTER CX
                  IPLSN=N2NDX(IRCX,2)
C ASSUME: NEW ION MOMENTUM IS EQUAL TO INCIDENT ATOM MOMENTUM
                  MAPL(IPLSN,NCELL)=MAPL(IPLSN,NCELL)+
     .                              WGHTO*V0_PARBO*SIG
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            COLTYP=1
            NCELL=NCLLO
            RETURN

          CASE(2)
C  1ST SECONDARY IS MOLECULE
            IMOL=N1STX(IRCX,2)
            E0=CVRSSM(IMOL)*VELQ
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE(3)
C  1ST SECONDARY IS TEST ION
            IION=N1STX(IRCX,2)
            E0=CVRSSI(IION)*VELQ
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP = ',ITYP,' AS FIRST SECONDARY IS',
     .                  ' NOT FORESEEN IN COLLIDE '
          END SELECT

        ELSE
C  FOLLOW 2ND SECONDARY, SPEED OF PREVIOUS TEST PARTICLE
          ITYP=N2NDX(IRCX,1)

          SELECT CASE(ITYP)
C
          CASE(1)
            IATM=N2NDX(IRCX,2)
            XGENER= 0.D0
C
            E0=CVRSSA(IATM)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN
C
          CASE(2)
            IMOL=N2NDX(IRCX,2)
            XGENER= 0.D0
C
            E0=CVRSSM(IMOL)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN
C
          CASE(3)
            IION=N2NDX(IRCX,2)
            XGENER=0.D0
C
            E0=CVRSSI(IION)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

         CASE DEFAULT
            WRITE (iunout,*) ' ITYP = ',ITYP,' AS SECOND SECONDARY IS',
     .                  ' NOT FORESEEN IN COLLIDE '
          END SELECT

        ENDIF
C
C  ELASTIC COLLISION
C
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT+SIGELT) THEN
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,5)
C   FIND SPECIES INDEX OF BULK ION COLLISION PARTNER
        SIGSUM=SIGEIT+SIGCXT
        DO 281 IAEL=1,NAELIM(IATM)
          IREL=LGAEL(IATM,IAEL,0)
          IPLS=LGAEL(IATM,IAEL,1)
          SIGSUM=SIGSUM+SIGVEL(IREL)
          IF (ZEP1.LT.SIGSUM) GOTO 282
281     CONTINUE
        IREL=LGAEL(IATM,NAELI(IATM),0)
        IPLS=LGAEL(IATM,NAELI(IATM),1)
282     CONTINUE

        IPLSV=MPLSV(IPLS)
C
C  NEW SPECIES INDEX AND ENERGY
C       WEIGHT=WEIGHT*1.
C  FOLLOW SECONDARY, NEW SPEED FROM SUBROUTINE VELOEL
C       ITYP=1
        NFLAG=CFLAG(5,1)
        RMAIO=RMASSA(IOLD)
        CALL VELOEL(NCLLO,VELXO,VELYO,VELZO,VELO,IOLD,NOLD,VELQ,
     .              NFLAG,IREL,RMAIO)
C
        IATM=IOLD
        E0=CVRSSA(IATM)*VELQ
C  DO NOT UPDATE BGK TALLIES HERE
        IBGK=NPBGKP(IPLS,1)
        IF (IBGK.NE.0) GOTO 300
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION
C  ASSUME, AS BEFORE, NO CHANGE IN SPECIES/TYP
        IF (IESTEL(IREL,1).NE.0) THEN
          IF (LPAAT) THEN
            PAAT(IOLD,NCELL) =PAAT(IOLD,NCELL)-WGHTO
            PAAT(IATM,NCELL) =PAAT(IATM,NCELL)+WEIGHT
            LMETSP(NSPH+IOLD)=.TRUE.
            LMETSP(NSPH+IATM)=.TRUE.
          END IF
        ENDIF
        IF (IESTEL(IREL,3).NE.0) THEN
          EDEL=E0O*WGHTO-E0*WEIGHT
          IF (LEAAT) EAAT(NCELL)      =EAAT(NCELL)-EDEL
          IF (LEAPL) EAPL(NCELL)      =EAPL(NCELL)+EDEL
        ENDIF
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION TO MAPL (COPV)
        IF (IESTEL(IREL,2).NE.0) THEN
          IF (LMAPL) THEN
            V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
            V0_PARB=V0_PARB*AMUA*RMASSA(IATM)
            VDEL=V0_PARBO*WGHTO-V0_PARB*WEIGHT
            IF (INDPRO(4) == 8) THEN
              CALL VECUSR(2,VX,VY,VZ,IPLSV)
              VPLASP=VX*BX+VY*BY+VZ*BZ
            ELSE
              VPLASP=BVIN(IPLSV,NCLLO)
            ENDIF
            VDEL=VDEL*SIGN(1._DP,VPLASP)
            MAPL(IPLS,NCELL)=MAPL(IPLS,NCELL)+VDEL
            LMETSP(NSPAMI+IPLS)=.TRUE.
          END IF
        ENDIF
300     CONTINUE
        COLTYP=1
        NCELL = NCLLO
        RETURN
C
C  GENERAL ION IMPACT COLLISION: PI-PROCESSES. NOT READY
C
      ELSE
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,5)
        SIGSUM=SIGEIT+SIGCXT+SIGELT
        DO 261 IAPI=1,NAPIIM(IATM)
C   FIND INDEX OF THAT ION IMPACT COLLISION
          IRPI=LGAPI(IATM,IAPI,0)
          IPLS=LGAPI(IATM,IAPI,1)
          SIGSUM=SIGSUM+SIGVPI(IRPI)
          IF (ZEP1.LT.SIGSUM) GOTO 262
261     CONTINUE
        IRPI=LGAPI(IATM,NAPII(IATM),0)
        IPLS=LGAPI(IATM,NAPII(IATM),1)
262     CONTINUE
        DO II=1,IPIOPI(IRPI,0)
          IION=IPIOPI(IRPI,II)
C         E0=E0
          VEL=RSQDVI(IION)*SQRT(E0)
          ITYP=3
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDDO
C  IONIZED INTO BULK SPECIES. STOP THIS TRACK
C  NO SUPPRESSION OF ABSORBTION  AT PI
        DO IP=1,IPPLPI(IRPI,0)
          IPLS=IPPLPI(IRPI,IP)
          ITYP=4
          LGPART=.FALSE.
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDDO
C
      ENDIF
      GOTO 999
C
      ENTRY COLMOL(CFLAG,COLTYP,DIST)
C
C  INCIDENT SPECIES: IOLD
      VELXO=VELX
      VELYO=VELY
      VELZO=VELZ
      VELO=VEL
      NCLLO = NCELL
      NCELL = NCLTAL(NCLLO)
      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BX,BY,BZ,1)
      ELSE
        BX=BXIN(NCLLO)
        BY=BYIN(NCLLO)
        BZ=BZIN(NCLLO)
      END IF
      V0_PARBO=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
      V0_PARBO=V0_PARBO*AMUA*RMASSM(IMOL)
      E0O=E0
      WGHTO=WEIGHT
      IOLD=IMOL
      NOLD=NSPA+IMOL

      IF (IMETCL(NCELL) == 0) THEN
        NCLMT = NCLMT+1
        ICLMT(NCLMT) = NCELL
        IMETCL(NCELL) = NCLMT
      END IF
C
C  ABSORBTION BIASSING: SUPPRESS IREI PROCESSES WITH ZERO
C                       TEST PARTICLE SECONDARIES

      SIG_ELIM=0.
      SIG_TOT_N=SIGTOT
      SIG_TOT_O=SIGTOT
      NEII_RED=0

      DO IMEI=1,NMDSI(IOLD)
        IREI=LGMEI(IOLD,IMEI)
        IF (WEIGHT.GT.WMINV) THEN
C  REMAINING RATE AFTER POSSIBLE ELIMINATION OF IREI
C  SIG_TEST=0 WOULD VIOLATE RADON-NYKODYM CONDITION OF WEIGHTING
          SIG_TEST=SIG_TOT_N-SIGVEI(IREI)
          PTOT=P2NDS(IREI)
          IF (PTOT.EQ.0..AND.SIG_TEST.GT.0.) THEN
C  ELIMINATE PROCESS IREI FROM ALL POSSIBLE PROCESSES 
C  REDUCE WEIGHT ACCORDINGLY
            SIG_ELIM=SIG_ELIM+SIGVEI(IREI)
            SIG_TOT_N=SIG_TEST
            WEIGHT=WEIGHT*SIG_TOT_N/SIG_TOT_O
            WGHTO=WEIGHT
            SIG_TOT_O=SIG_TOT_N
            IF (IESTEI(IREI,1).NE.0) GOTO 990
            IF (IESTEI(IREI,2).NE.0) GOTO 990
            IF (IESTEI(IREI,3).NE.0) GOTO 990
          ELSE
C  NO, THIS PROCESS REMAINS ACTIVE, BECAUSE THERE ARE TEST-PARTICLE SECONDARIES
            NEII_RED=NEII_RED+1
            LGEI_RED(NEII_RED)=IREI
          ENDIF
        ELSE
C  WEIGHT TOO SMALL COMPARED TO WMINV. ANALOG GAME
          NEII_RED=NEII_RED+1
          LGEI_RED(NEII_RED)=IREI
        ENDIF
      ENDDO
C
C  FIRST DECIDE: ELECTRON IMPACT OR ION IMPACT
C
      ZEP1=SIG_ELIM+RANF_EIRENE( )*SIG_TOT_N
      SIGSUM=SIG_ELIM
      NEIIM_RED=NEII_RED-1
C
      IF (ZEP1.LE.SIGEIT) THEN
C
C  AT THIS POINT: NEII.GE.1, FOR OTHERWISE ZEP1 COULD NOT HAVE
C                 POINTED TO EI-PROCESSES
C
C  ELECTRON IMPACT COLLISION:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,2)
        IF (NLSTOR) CALL STORE(2)
C
C  FIND TYP OF ELECTR. IMPACT COLLISION PROCESS: IREI
        DO 340 IMEI=1,NEIIM_RED
          IREI=LGEI_RED(IMEI)
          SIGSUM=SIGSUM+SIGVEI(IREI)
          IF (ZEP1.LE.SIGSUM) GOTO 345
340     CONTINUE
        IREI=LGEI_RED(NEII_RED)
345     CONTINUE
C
C  CALCULATE WEIGHT OF THE NEXT GENERATION PARTICLE
C  ONLY ONE ATOM, MOLECULE OR TEST-ION HISTORY WITH MODIFIED WEIGHT
C  IS FOLLOWED
C
        PTOT=P2NDS(IREI)
C       PTOTAL=PTOT+PPLDS(IREI,0)
C  ABSORBED WEIGHT: WEIABS
C       WEIABS=WEIGHT*PPLDS(IREI,0)
C
C  PRE- COLLISION ESTIMATOR FOR EMML,
C  PRE- AND POST COLLISION ESTIMATOR FOR EMPL AND EMEL
        IF (IESTEI(IREI,3).NE.0) THEN
          IF (LEMML) EMML(NCELL)=EMML(NCELL)-WEIGHT*E0
          IF (LEMPL) EMPL(NCELL)=EMPL(NCELL)+WEIGHT*ESIGEI(IREI,4)
          IF (LEMEL) EMEL(NCELL)=EMEL(NCELL)+WEIGHT*ESIGEI(IREI,5)
        ENDIF
C
C  ABSORBTION (INTO BULK SPECIES) IS SUPPRESSED
        WEIGHT=WEIGHT*PTOT
C
C  ARE THERE TEST PARTICLE SECONDARIES AT ALL?
        IF (WEIGHT.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF
C
        CALL VELOEI(NCLLO,IREI,VELXO,VELYO,VELZO,VELO)
        XGENER=0.D0
C
C  POST-COLLISION ESTIMATORS CONTRIBUTION TO EMAT;EMML;EMIO
        IF (ITYP.EQ.1) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEMAT) EMAT(NCELL)=EMAT(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=1
        ELSEIF (ITYP.EQ.2) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEMML) EMML(NCELL)=EMML(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=1
        ELSEIF (ITYP.EQ.3) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEMIO) EMIO(NCELL)=EMIO(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=2
        ENDIF
        NCELL = NCLLO
        RETURN
C
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT) THEN
C
C  CHARGE EXCHANGE:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,6)
C
C   FIND SPECIES INDEX OF CHARGE EXCHANGING BULK ION
        SIGSUM=SIGEIT
        DO 371 IMCX=1,NMCXIM(IMOL)
          IRCX=LGMCX(IMOL,IMCX,0)
          IPLS=LGMCX(IMOL,IMCX,1)
          SIGSUM=SIGSUM+SIGVCX(IRCX)
          IF (ZEP1.LT.SIGSUM) GOTO 372
371     CONTINUE
        IRCX=LGMCX(IMOL,NMCXI(IMOL),0)
        IPLS=LGMCX(IMOL,NMCXI(IMOL),1)
372     CONTINUE
C
C  ARE THERE SECONDARY TEST PARTICLES AT ALL?
        FRSTP=N1STX(IRCX,3)
        SCNDP=N2NDX(IRCX,3)
        IF (SCNDP.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF
C
C  NEW SPECIES TYPE, INDEX AND ENERGY
C  SUPPRESSION OF ABSORBTION AT CX
C  I.E., NO RANDOM DECISION BETWEEN BULK AND TEST SECONDARIES
        WEIGHT=WEIGHT*SCNDP
        ZEP3=RANF_EIRENE( )*SCNDP
        IF (ZEP3.LE.FRSTP) THEN
C  FOLLOW FIRST SECONDARY, SPEED FROM BULK POPULATION
          ITYP=N1STX(IRCX,1)
          NFLAG=CFLAG(3,1)
          CALL VELOCX(NCLLO,VELXO,VELYO,VELZO,VELO,IOLD,NOLD,VELQ,
     .                NFLAG,IRCX,DUMT,DUMV)

          SELECT CASE (ITYP)
C
          CASE (1)
C  1ST SECONDARY IS ATOM
            IATM=N1STX(IRCX,2)
            E0=CVRSSA(IATM)*VELQ
            XGENER=0.D0
C
            E0=CVRSSA(IATM)*VELQ
C  NEXT LINES: COLLISION ESTIMATOR FOR CHARGE EXCHANGE NO. IRCX
C  CONSERVE CHARGE IN EACH COLLISION, NOT ONLY ON AVERAGE
            IF (IESTCX(IRCX,1).NE.0) THEN
C  IATMN ATOM SPECIES AFTER CX
              IATMN=IATM
              IF (LPMML) THEN
                PMML(IOLD,NCELL) =PMML(IOLD,NCELL)-WGHTO
                LMETSP(NSPA+IOLD)=.TRUE.
              END IF
              IF (LPMAT) THEN
                PMAT(IATMN,NCELL)=PMAT(IATMN,NCELL)+WEIGHT
                LMETSP(NSPH+IATMN)=.TRUE.
              END IF
              IF (LPMPL) THEN
                PMPL(IPLS,NCELL) =PMPL(IPLS,NCELL)-WEIGHT
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (LPMEL) PMEL(NCELL)      =PMEL(NCELL)-WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
C  IPLSN ION SPECIES AFTER CX
                IPLSN=N2NDX(IRCX,2)
                IF (LPMPL) THEN
                  PMPL(IPLSN,NCELL)=PMPL(IPLSN,NCELL)+WGHTO
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
                IF (LPMEL) PMEL(NCELL)      =PMEL(NCELL)+WGHTO
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            IF (IESTCX(IRCX,3).NE.0) THEN
              IF (LEMML) EMML(NCELL)=EMML(NCELL)-E0O*WGHTO
              IF (LEMAT) EMAT(NCELL)=EMAT(NCELL)+E0*WEIGHT
              IF (LEMPL) EMPL(NCELL)=EMPL(NCELL)-E0*WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LEMPL) EMPL(NCELL)=EMPL(NCELL)+E0O*WGHTO
              ELSE
                GOTO 999
              ENDIF
            ENDIF
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION TO MMPL (COPV)
            IF (IESTCX(IRCX,2).NE.0) THEN
              IF (LMMPL) THEN
                V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                V0_PARB=V0_PARB*AMUA*RMASSM(IMOL)
                IPLSV=MPLSV(IPLS)
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR(2,VX,VY,VZ,IPLSV)
                  VPLASP=VX*BX+VY*BY+VZ*BZ
                ELSE
                  VPLASP=BVIN(IPLSV,NCLLO)
                ENDIF
                SIG=SIGN(1._DP,VPLASP)
C ASSUME: OLD (INCIDENT) ION MOMENTUM IS EQUAL TO NEW MOLECULE MOMENTUM
                MMPL(IPLS,NCELL)=MMPL(IPLS,NCELL)-WEIGHT*V0_PARB*SIG
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LMMPL) THEN
C  IPLSN ION SPECIES AFTER CX
                  IPLSN=N2NDX(IRCX,2)
                  IAD=2*NPLSI+IPLSN
C ASSUME: NEW ION MOMENTUM IS EQUAL TO INCIDENT MOLECULE MOMENTUM
                  MMPL(IPLSN,NCELL)=MMPL(IPLSN,NCELL)+
     .                              WGHTO*V0_PARBO*SIG
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE (2)
C  1ST SECONDARY IS MOLECULE
            IMOL=N1STX(IRCX,2)
            E0=CVRSSM(IMOL)*VELQ
C
            IF (NGENM(IMOL).GT.0) THEN
              IF (IMOL.EQ.IOLD) THEN
                XGENER=XGENER+1.D0
              ELSE
                XGENER=0.D0
              ENDIF
              IF (XGENER.GT.NGENM(IMOL)) THEN
C  UPDATE GENERATION LIMIT TALLIES
                IF (LPGENM) PGENM(IMOL,NCELL)=PGENM(IMOL,NCELL)-WEIGHT
                IF (LEGENM)
     .            EGENM(IMOL,NCELL)=EGENM(IMOL,NCELL)-WEIGHT*E0
                IF (LVGENM) THEN
                  V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                  V0_PARB=V0_PARB*AMUA*RMASSM(IMOL)
                  VGENM(IMOL,NCELL)=VGENM(IMOL,NCELL)-WEIGHT*V0_PARB
                END IF
                IF (LPGENM.OR.LEGENM.OR.LVGENM) LMETSP(NSPA+IMOL)=.TRUE.
                LGPART=.FALSE.
                IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,16)
                ITYP=4
                COLTYP=2
                NCELL = NCLLO
                RETURN
              ENDIF
            ENDIF
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE (3)
C  1ST SECONDARY IS TEST ION
            IION=N1STX(IRCX,2)
            E0=CVRSSI(IION)*VELQ
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP ',ITYP,' AS 1ST SECONDARY IS NOT',
     .                  ' FORESEEN IN COLLIDE '
          END SELECT

        ELSE

C  FOLLOW 2ND SECONDARY, SPEED OF PREVIOUS TEST PARTICLE
          ITYP=N2NDX(IRCX,1)
          SELECT CASE (ITYP)
C
          CASE (1)
            IATM=N2NDX(IRCX,2)
            XGENER=0.D0
C
            E0=CVRSSA(IATM)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE (2)
            IMOL=N2NDX(IRCX,2)
            XGENER=0.D0
C
            E0=CVRSSM(IMOL)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE(3)
            IION=N2NDX(IRCX,2)
            XGENER=0.D0
C
            E0=CVRSSI(IION)*VELO*VELO
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP ',ITYP,' AS 2ND SECONDARY IS NOT',
     .                  ' FORESEEN IN COLLIDE '
          END SELECT
        ENDIF
C
C  ELASTIC COLLISION
C
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT+SIGELT) THEN
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,5)
C   FIND SPECIES INDEX OF BULK ION COLLISION PARTNER
        SIGSUM=SIGEIT+SIGCXT
        DO 398 IMEL=1,NMELIM(IMOL)
          IREL=LGMEL(IMOL,IMEL,0)
          IPLS=LGMEL(IMOL,IMEL,1)
          SIGSUM=SIGSUM+SIGVEL(IREL)
          IF (ZEP1.LT.SIGSUM) GOTO 399
398     CONTINUE
        IREL=LGMEL(IMOL,NMELI(IMOL),0)
        IPLS=LGMEL(IMOL,NMELI(IMOL),1)
399     CONTINUE
C
C  NEW SPECIES INDEX AND ENERGY
C       WEIGHT=WEIGHT*1.
C  FOLLOW SECONDARY, NEW SPEED FROM SUBROUTINE VELOEL
C       ITYP=2
        NFLAG=CFLAG(5,1)
        RMMIO=RMASSM(IOLD)
        CALL VELOEL(NCLLO,VELXO,VELYO,VELZO,VELO,IOLD,NOLD,VELQ,
     .              NFLAG,IREL,RMMIO)
C
        IMOL=IOLD
        E0=CVRSSM(IMOL)*VELQ
C  DO NOT UPDATE BGK TALLIES HERE
        IBGK=NPBGKP(IPLS,1)
        IF (IBGK.NE.0) GOTO 400
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION
C  ASSUME, AS BEFORE, NO CHANGE IN SPECIES/TYP
        IF (IESTEL(IREL,1).NE.0) THEN
          IF (LPMML) THEN
            PMML(IOLD,NCELL) =PMML(IOLD,NCELL)-WGHTO
            PMML(IMOL,NCELL) =PMML(IMOL,NCELL)+WEIGHT
            LMETSP(NSPA+IOLD)=.TRUE.
            LMETSP(NSPA+IMOL)=.TRUE.
          END IF
        ENDIF
        IF (IESTEL(IREL,3).NE.0) THEN
          EDEL=E0O*WGHTO-E0*WEIGHT
          IF (LEMML) EMML(NCELL)      =EMML(NCELL)-EDEL
          IF (LEMPL) EMPL(NCELL)      =EMPL(NCELL)+EDEL
        ENDIF
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION TO MMPL (COPV)
        IF (IESTEL(IREL,2).NE.0) THEN
          IF (LMMPL) THEN
            V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
            V0_PARB=V0_PARB*AMUA*RMASSM(IMOL)
            VDEL=V0_PARBO*WGHTO-V0_PARB*WEIGHT
            IPLSV=MPLSV(IPLS)
            IF (INDPRO(4) == 8) THEN
              CALL VECUSR(2,VX,VY,VZ,IPLSV)
              VPLASP=VX*BX+VY*BY+VZ*BZ
            ELSE
              VPLASP=BVIN(IPLSV,NCLLO)
            ENDIF
            VDEL=VDEL*SIGN(1._DP,VPLASP)
            IAD=2*NPLSI+IPLS
            MMPL(IPLS,NCELL)=MMPL(IPLS,NCELL)+VDEL
            LMETSP(NSPAMI+IPLS)=.TRUE.
          END IF
        ENDIF
400     CONTINUE
        COLTYP=1
        NCELL = NCLLO
        RETURN
C
C  GENERAL ION IMPACT COLLISION: PI-PROCESSES. NOT READY
C
      ELSE
C
        WRITE (iunout,*) 'ERROR IN COLMOL '
        CALL EXIT_OWN(1)
C
      ENDIF
      GOTO 999
C
      ENTRY COLION(CFLAG,COLTYP,DIST)
C
C  INCIDENT SPECIES: IOLD
      VELXO=VELX
      VELYO=VELY
      VELZO=VELZ
      VELO=VEL
      NCLLO = NCELL
      NCELL = NCLTAL(NCLLO)
      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BX,BY,BZ,1)
      ELSE
        BX=BXIN(NCLLO)
        BY=BYIN(NCLLO)
        BZ=BZIN(NCLLO)
      END IF
      V0_PARBO=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
      V0_PARBO=V0_PARBO*AMUA*RMASSI(IION)
      E0O=E0
      WGHTO=WEIGHT
      IOLD=IION
      NOLD=NSPAM+IION

      IF (IMETCL(NCELL) == 0) THEN
        NCLMT = NCLMT+1
        ICLMT(NCLMT) = NCELL
        IMETCL(NCELL) = NCLMT
      END IF
C
C  ABSORBTION BIASSING: SUPPRESS IREI PROCESSES WITH ZERO
C                       TEST PARTICLE SECONDARIES

      SIG_ELIM=0.
      SIG_TOT_N=SIGTOT
      SIG_TOT_O=SIGTOT
      NEII_RED=0

      DO IIEI=1,NIDSI(IOLD)
        IREI=LGIEI(IOLD,IIEI)
        IF (WEIGHT.GT.WMINV) THEN
C  REMAINING RATE AFTER POSSIBLE ELIMINATION OF IREI
C  SIG_TEST=0 WOULD VIOLATE RADON-NYKODYM CONDITION OF WEIGHTING
          SIG_TEST=SIG_TOT_N-SIGVEI(IREI)
          PTOT=P2NDS(IREI)
          IF (PTOT.EQ.0..AND.SIG_TEST.GT.0.) THEN
C  ELIMINATE PROCESS IREI FROM ALL POSSIBLE PROCESSES 
C  REDUCE WEIGHT ACCORDINGLY
            SIG_ELIM=SIG_ELIM+SIGVEI(IREI)
            SIG_TOT_N=SIG_TEST
            WEIGHT=WEIGHT*SIG_TOT_N/SIG_TOT_O
            WGHTO=WEIGHT
            SIG_TOT_O=SIG_TOT_N
            IF (IESTEI(IREI,1).NE.0) GOTO 990
            IF (IESTEI(IREI,2).NE.0) GOTO 990
            IF (IESTEI(IREI,3).NE.0) GOTO 990
          ELSE
C  NO, THIS PROCESS REMAINS ACTIVE
            NEII_RED=NEII_RED+1
            LGEI_RED(NEII_RED)=IREI
          ENDIF
        ELSE
C  WEIGHT TOO SMALL COMPARED TO WMINV. ANALOG GAME
          NEII_RED=NEII_RED+1
          LGEI_RED(NEII_RED)=IREI
        ENDIF
      ENDDO
C
C  FIRST DECIDE: ELECTRON IMPACT OR ION IMPACT
C
      ZEP1=SIG_ELIM+RANF_EIRENE( )*SIG_TOT_N
      SIGSUM=SIG_ELIM
      NEIIM_RED=NEII_RED-1
C
      IF (ZEP1.LE.SIGEIT) THEN
C
C  AT THIS POINT: NEII.GE.1, FOR OTHERWISE ZEP1 COULD NOT HAVE
C                 POINTED TO EI-PROCESSES
C
C  ELECTRON IMPACT COLLISION:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,2)
        IF (NLSTOR) CALL STORE(2)
C
C  FIND TYP OF ELECTR. IMPACT COLLISION PROCESS: IREI
        DO 440 IIEI=1,NEIIM_RED
          IREI=LGEI_RED(IIEI)
          SIGSUM=SIGSUM+SIGVEI(IREI)
          IF (ZEP1.LE.SIGSUM) GOTO 445
440     CONTINUE
        IREI=LGEI_RED(NEII_RED)
445     CONTINUE
C
C  CALCULATE WEIGHT OF THE NEXT GENERATION PARTICLE
C  ONLY ONE ATOM, MOLECULE OR TEST-ION HISTORY WITH MODIFIED WEIGHT
C  IS FOLLOWED
C
        PTOT=P2NDS(IREI)
C       PTOTAL=PTOT+PPLDS(IREI,0)
C  ABSORBED WEIGHT: WEIABS
C       WEIABS=WEIGHT*PPLDS(IREI,0)
C
C  COLLISION ESTIMATOR FOR EIIO, EIPL AND EIEL
        IF (IESTEI(IREI,3).NE.0) THEN
          IF (LEIIO) EIIO(NCELL)=EIIO(NCELL)-WEIGHT*E0
          IF (LEIPL) EIPL(NCELL)=EIPL(NCELL)+WEIGHT*ESIGEI(IREI,4)
          IF (LEIEL) EIEL(NCELL)=EIEL(NCELL)+WEIGHT*ESIGEI(IREI,5)
        ENDIF
C
C  ABSORBTION (INTO BULK SPECIES) IS SUPPRESSED
        WEIGHT=WEIGHT*PTOT
C
C  ARE THERE TEST PARTICLE SECONDARIES AT ALL?
        IF (WEIGHT.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF
C
        CALL VELOEI(NCLLO,IREI,VELXO,VELYO,VELZO,VELO)
C
C  UPDATE COLLISION ESTIMATORS CONTRIBUTION TO EIAT;EIML;EIIO
        IF (ITYP.EQ.1) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEIAT) EIAT(NCELL)=EIAT(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=2
        ELSEIF (ITYP.EQ.2) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEIML) EIML(NCELL)=EIML(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=2
        ELSEIF (ITYP.EQ.3) THEN
          IF (IESTEI(IREI,3).NE.0) THEN
            IF (LEIIO) EIIO(NCELL)=EIIO(NCELL)+WEIGHT*E0
          ENDIF
          COLTYP=1
        ENDIF
        NCELL = NCLLO
        RETURN
C
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT) THEN
C
C  CHARGE EXCHANGE:
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,6)
C
C   FIND SPECIES INDEX OF CHARGE EXCHANGING BULK ION
        SIGSUM=SIGEIT
        DO 490 IICX=1,NICXIM(IION)
          IRCX=LGICX(IION,IICX,0)
          IPLS=LGICX(IION,IICX,1)
          SIGSUM=SIGSUM+SIGVCX(IRCX)
          IF (ZEP1.LT.SIGSUM) GOTO 491
490     CONTINUE
        IRCX=LGICX(IION,NICXI(IION),0)
        IPLS=LGICX(IION,NICXI(IION),1)
491     CONTINUE
C
C  ARE THERE SECONDARY TEST PARTICLES AT ALL?
        FRSTP=N1STX(IRCX,3)
        SCNDP=N2NDX(IRCX,3)
        IF (SCNDP.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF
C
C  NEW SPECIES TYPE, INDEX AND ENERGY
C  SUPPRESSION OF ABSORBTION AT CX
C  I.E., NO RANDOM DECISION BETWEEN BULK AND TEST SECONDARIES
        WEIGHT=WEIGHT*SCNDP
        ZEP3=RANF_EIRENE( )*SCNDP
        IF (ZEP3.LE.FRSTP) THEN
C  FOLLOW FIRST SECONDARY, SPEED FROM BULK POPULATION
          ITYP=N1STX(IRCX,1)
          NFLAG=CFLAG(3,1)
          CALL VELOCX(NCLLO,VELXO,VELYO,VELZO,VELO,IOLD,NOLD,VELQ,
     .                NFLAG,IRCX,DUMT,DUMV)

          SELECT CASE (ITYP)
C
          CASE (1)
C  1ST SECONDARY IS ATOM
            IATM=N1STX(IRCX,2)
            E0=CVRSSA(IATM)*VELQ
            XGENER=0.D0
C
C  NEXT LINES: COLLISION ESTIMATOR FOR CHARGE EXCHANGE NO. IRCX
C  CONSERVE CHARGE IN EACH COLLISION, NOT ONLY ON AVERAGE
            IF (IESTCX(IRCX,1).NE.0) THEN
C  IATMN ATOM SPECIES AFTER CX
              IATMN=IATM
              IF (LPIIO) THEN
                PIIO(IOLD,NCELL) =PIIO(IOLD,NCELL)-WGHTO
                LMETSP(NSPAM+IOLD)=.TRUE.
              END IF
              IF (LPIAT) THEN
                PIAT(IATMN,NCELL)=PIAT(IATMN,NCELL)+WEIGHT
                LMETSP(NSPH+IATMN)=.TRUE.
              END IF
              IF (LPIPL) THEN
                PIPL(IPLS,NCELL) =PIPL(IPLS,NCELL)-WEIGHT
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (LPIEL) PIEL(NCELL)      =PIEL(NCELL)-WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
C  IPLSN ION SPECIES AFTER CX
                IPLSN=N2NDX(IRCX,2)
                IF (LPIPL) THEN
                  PIPL(IPLSN,NCELL)=PIPL(IPLSN,NCELL)+WGHTO
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
                IF (LPIEL) PIEL(NCELL)      =PIEL(NCELL)+WGHTO
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            IF (IESTCX(IRCX,3).NE.0) THEN
              IF (LEIIO) EIIO(NCELL)=EIIO(NCELL)-E0O*WGHTO
              IF (LEIAT) EIAT(NCELL)=EIAT(NCELL)+E0*WEIGHT
              IF (LEIPL) EIPL(NCELL)=EIPL(NCELL)-E0*WEIGHT
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LEIPL) EIPL(NCELL)=EIPL(NCELL)+E0O*WGHTO
              ELSE
                GOTO 999
              ENDIF
            ENDIF
C  UPDATE COLLISION ESTIMATOR CONTRIBUTION TO MIPL (COPV)
            IF (IESTCX(IRCX,2).NE.0) THEN
              IF (LMIPL) THEN
                V0_PARB=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
                V0_PARB=V0_PARB*AMUA*RMASSI(IION)
                IPLSV=MPLSV(IPLS)
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR(2,VX,VY,VZ,IPLSV)
                  VPLASP=VX*BX+VY*BY+VZ*BZ
                ELSE
                  VPLASP=BVIN(IPLSV,NCLLO)
                ENDIF
                SIG=SIGN(1._DP,VPLASP)
C ASSUME: OLD (INCIDENT) ION MOMENTUM IS EQUAL TO NEW ATOM MOMENTUM
                MIPL(IPLS,NCELL)=MIPL(IPLS,NCELL)-WEIGHT*V0_PARB*SIG
                LMETSP(NSPAMI+IPLS)=.TRUE.
              END IF
              IF (N2NDX(IRCX,1).EQ.4) THEN
                IF (LMIPL) THEN
C  IPLSN ION SPECIES AFTER CX
                  IPLSN=N2NDX(IRCX,2)
C ASSUME: NEW ION MOMENTUM IS EQUAL TO INCIDENT ATOM MOMENTUM
                  MIPL(IPLSN,NCELL)=MIPL(IPLSN,NCELL)+
     .                              WGHTO*V0_PARBO*SIG
                  LMETSP(NSPAMI+IPLSN)=.TRUE.
                END IF
              ELSEIF (N2NDX(IRCX,1).NE.4) THEN
                GOTO 999
              ENDIF
            ENDIF
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE (2)
C  1ST SECONDARY IS MOLECULE
            IMOL=N1STX(IRCX,2)
            E0=CVRSSM(IMOL)*VELQ
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE (3)
C  1ST SECONDARY IS TEST ION
            IION=N1STX(IRCX,2)
            E0=CVRSSI(IION)*VELQ
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP ',ITYP,' AS 1ST SECONDARY IS NOT ',
     .                  ' FORESEEN IN COLLIDE '
          END SELECT

        ELSE
C  FOLLOW 2ND SECONDARY, SPEED OF PREVIOUS TEST PARTICLE
          ITYP=N2NDX(IRCX,1)

          SELECT CASE (ITYP)
C
          CASE (1)
            IATM=N2NDX(IRCX,2)
            E0=CVRSSA(IATM)*VELO*VELO
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE (2)
            IMOL=N2NDX(IRCX,2)
            E0=CVRSSM(IMOL)*VELO*VELO
            XGENER=0.D0
C
            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=2
            NCELL = NCLLO
            RETURN

          CASE (3)
            IION=N2NDX(IRCX,2)
            E0=CVRSSI(IION)*VELO*VELO
            XGENER=0.D0

            IF (IESTCX(IRCX,1).NE.0) GOTO 999
            IF (IESTCX(IRCX,2).NE.0) GOTO 999
            IF (IESTCX(IRCX,3).NE.0) GOTO 999
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP ',ITYP,' AS 2ND SECONDARY IS NOT ',
     .                  ' FORESEEN IN COLLIDE '
          END SELECT
        ENDIF
C
C  ELASTIC COLLISION
C
      ELSE
C
C
        WRITE (iunout,*) 'ERROR IN COLION '
        CALL EXIT_OWN(1)
C
C
      ENDIF
      GOTO 999
C
      ENTRY COLPHOT(CFLAG,COLTYP,DIST)
C
C  INCIDENT SPECIES: IOLD
      VELXO=VELX
      VELYO=VELY
      VELZO=VELZ
      VELO=VEL
      NCLLO = NCELL
      NCELL = NCLTAL(NCLLO)
      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BX,BY,BZ,1)
      ELSE
        BX=BXIN(NCLLO)
        BY=BYIN(NCLLO)
        BZ=BZIN(NCLLO)
      END IF
C     V0_PARBO=VEL*(VELX*BX+VELY*BY+VELZ*BZ)
c     V0_PARBO=V0_PARBO*AMUA*RMASSA(IATM)
      E0O=E0
      WGHTO=WEIGHT
      IOLD=IPHOT
      NOLD=0+IPHOT

      IF (IMETCL(NCELL) == 0) THEN
        NCLMT = NCLMT+1
        ICLMT(NCLMT) = NCELL
        IMETCL(NCELL) = NCLMT
      END IF
C
C  FIRST DECIDE: ELECTRON IMPACT OR ION IMPACT
C
      ZEP1=RANF_EIRENE( )*SIGTOT
      SIGSUM=0.
C
      IF (ZEP1.LE.SIGEIT) THEN
C
C  ELECTRON IMPACT COLLISION:
C
        goto 999
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT) THEN
C
C  CHARGE EXCHANGE:
C
        goto 999
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT+SIGELT) THEN
C
C  ELASTIC COLLISION
C
        goto 999
      ELSEIF (ZEP1.LE.SIGEIT+SIGCXT+SIGELT+SIGOTT) THEN
C
C  PHOTON COLLISION (analog to cx in colatm)
C
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,3)
C
C   FIND SPECIES INDEX OF BULK COLLISION PARTNER
        SIGSUM=SIGEIT+SIGCXT+SIGELT
        DO IAOT=1,PHV_NPHOTI(IPHOT)-1
          IROT=PHV_LGPHOT(IPHOT,IAOT,0)
          IPLS=PHV_LGPHOT(IPHOT,IAOT,1)
          KK  =PHV_LGPHOT(IPHOT,IAOT,3)
          UPDF=PHV_LGPHOT(IPHOT,IAOT,4)
          SIGSUM=SIGSUM+SIGVOT(IROT)
          IF (ZEP1.LT.SIGSUM) GOTO 1272
        enddo
        IROT=PHV_LGPHOT(IPHOT,PHV_NPHOTI(IPHOT),0)
        IPLS=PHV_LGPHOT(IPHOT,PHV_NPHOTI(IPHOT),1)
        KK  =PHV_LGPHOT(IPHOT,PHV_NPHOTI(IPHOT),3)
        UPDF=PHV_LGPHOT(IPHOT,PHV_NPHOTI(IPHOT),4)
1272    CONTINUE
C
C  ARE THERE SECONDARY TEST PARTICLES AT ALL?
        FRSTP=dble(PHV_N1STOTph(iphot,IROT,3))
        SCNDP=dble(PHV_N2NDOTph(iphot,IROT,3))
        SUMP=frstp+scndp
        IF (SUMP.LE.EPS30) THEN
          LGPART=.FALSE.
          ITYP=4
          COLTYP=2
          NCELL = NCLLO
          RETURN
        ENDIF

csw check type first secondary
         if(phv_n1stotph(iphot,irot,1) == 4) then
            t1=phv_n2ndotph(iphot,irot,1)
            select case(t1)
            case(0)
csw check ipl
               if(phv_n2ndotph(iphot,irot,2) == 0) then
                  lgpart=.false.
                  ityp=4
                  coltyp=2
                  ncell=ncllo
                  return
               endif
            case(4)
               lgpart=.false.
               ityp=4
               coltyp=2
               ncell=ncllo
               return
            end select
         endif
csw check type second secondary
         if(phv_n2ndotph(iphot,irot,1) == 4) then
            t1=phv_n1stotph(iphot,irot,1)
            select case(t1)
            case(0)
csw check ipl
               if(phv_n1stotph(iphot,irot,2) == 0) then
                  lgpart=.false.
                  ityp=4
                  coltyp=2
                  ncell=ncllo
                  return
               endif
            case(4)
               lgpart=.false.
               ityp=4
               coltyp=2
               ncell=ncllo
               return
            end select
         endif


C
C  NEW SPECIES TYPE, INDEX AND ENERGY

C  I.E., NO RANDOM DECISION BETWEEN BULK AND TEST SECONDARIES
        WEIGHT=WEIGHT*SUMP
        ZEP3=RANF_EIRENE( )*SUMP
        IF (ZEP3.LE.FRSTP) THEN
C  FOLLOW FIRST SECONDARY, SPEED FROM BULK POPULATION
csw no  coll.estim.
            IF (PHV_IESTOTph(iphot,IROT,1).NE.0) goto 999
            IF (PHV_IESTOTph(iphot,IROT,2).NE.0) goto 999
            IF (PHV_IESTOTph(iphot,IROT,3).NE.0) goto 999
            ITYP=PHV_N1STOTph(iphot,IROT,1)
            write (iunout,*) 
     .        'ot not ready for photons. exit from collide '
            call exit_own(1)
c           call PH_POST_ENERGY(ncllo,kk,mode,il,
c    .           iold,0,velxo,velyo,velzo,velo,e0o,ityp)

          SELECT CASE(ITYP)
C
          CASE(0)
C  1ST secondary is PHOTON, E0 set by PH_POST_ENERGY
            IPHOT=PHV_N1STOTph(iphot,IROT,2)
c  implement generation limit in the future...?
            COLTYP=1
            NCELL=NCLLO
            RETURN
C
          CASE(1)
C  1ST SECONDARY IS ATOM
            IATM=PHV_N1STOTph(iphot,IROT,2)
            E0=CVRSSA(IATM)*VEL*VEL
C
C
            COLTYP=1
            NCELL=NCLLO
            RETURN

          CASE(2)
C  1ST SECONDARY IS MOLECULE
            IMOL=PHV_N1STOTph(iphot,IROT,2)
            E0=CVRSSM(IMOL)*VEL*VEL
            XGENER=0.D0
C
            COLTYP=1
            NCELL = NCLLO
            RETURN

          CASE(3)
C  1ST SECONDARY IS TEST ION
            IION=PHV_N1STOTph(iphot,IROT,2)
            E0=CVRSSI(IION)*VEL*VEL
            XGENER=0.D0
C
            COLTYP=2
            NCELL = NCLLO
            RETURN
c
          case(4)
            lgpart=.false.
            ipls=phv_n1stotph(iphot,irot,2)
            e0=cvrssp(ipls)*vel*vel

            coltyp=2
            ncell=ncllo
            return

          CASE DEFAULT
            WRITE (iunout,*) ' ITYP = ',ITYP,' AS FIRST SECONDARY IS',
     .                  ' NOT FORESEEN IN COLLIDE '
          END SELECT

        ELSE
C  FOLLOW 2ND SECONDARY, SPEED OF PREVIOUS TEST PARTICLE
csw no coll.estim.
            IF (PHV_IESTOTph(iphot,IROT,1).NE.0) GOTO 999
            IF (PHV_IESTOTph(iphot,IROT,2).NE.0) GOTO 999
            IF (PHV_IESTOTph(iphot,IROT,3).NE.0) GOTO 999
          ITYP=PHV_N2NDOTph(iphot,IROT,1)
          vel=velo
            write (iunout,*) 
     .        'ot not ready for photons. exit from collide '
            call exit_own(1)
c new energy?
c         call PH_POST_ENERGY(ncllo,kk,mode,il,
c    .           iold,0,velxo,velyo,velzo,velo,e0o,ityp)

          SELECT CASE(ITYP)
C
          CASE(0)
            IPHOT=PHV_N2NDOTph(iphot,IROT,2)
            XGENER=0.D0
csw e0 set by ph_post energy
            coltyp=1
            ncell=ncllo
            return

C
            CASE(1)
              IATM=PHV_N2NDOTph(iphot,IROT,2)
              XGENER= 0.D0
C
              E0=CVRSSA(IATM)*VEL*VEL
              COLTYP=1
              NCELL = NCLLO
              RETURN
C
            CASE(2)
              IMOL=PHV_N2NDOTph(iphot,IROT,2)
              XGENER= 0.D0
C
              E0=CVRSSM(IMOL)*VEL*VEL
              COLTYP=1
              NCELL = NCLLO
              RETURN
C
            CASE(3)
              IION=PHV_N2NDOTph(iphot,IROT,2)
              XGENER=0.D0
C
              E0=CVRSSI(IION)*VEL*VEL
              COLTYP=2
              NCELL = NCLLO
              RETURN
c
            case(4)
              ipls=phv_n2ndotph(iphot,irot,2)
              lgpart=.false.
              ityp=4
              e0=cvrssp(ipls)*vel*vel
              coltyp=2
              ncell=ncllo
              return
            CASE DEFAULT
              WRITE (iunout,*) ' ITYP = ',ITYP,
     .                    ' AS SECOND SECONDARY IS',
     .                    ' NOT FORESEEN IN COLLIDE '
            END SELECT

         ENDIF

      ELSE
C     GENERAL IMPACT COLLISION: NOT READY
      ENDIF

      GOTO 999
C
990   WRITE (iunout,*) 'ERROR IN COLLIDE '
      WRITE (iunout,*) 'IREI=  ',IREI,' IS SUPPRESSED, BUT'
      WRITE (iunout,*) 'COLLISION ESTIMATOR WAS SELECTED  '
      WRITE (iunout,*) 'SET WMINV = INFTY, OR USE TRACKLENGTH ESTIM. '
      CALL EXIT_OWN(1)
C
999   WRITE (iunout,*) 'ERROR IN COLLIDE '
      WRITE (iunout,*) 'ITYP ',ITYP,IPHOT,IATM,IMOL,IION,IPLS
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: escape.f
!pb 21.08.06: calls to update_surface introduced
!pb 18.08.06: if a particle hits a periodic surface with the conditional 
!             expectation estimator switched on and a collision is already stored  
!             the track is continued as if the periodic surface is transparent
!             additional changes have been made in stdcol 
!pb 01.03.06: switch off storing of trajectory if a nontransparent surface is hit
c   20.01.06: sheath repulsion added for negative ions (or
c             positive ions and positive sheath potentials).
!PB 12.01.06: index added to calc_spectrum indicating particle has hit a surface
CVK 25.02.04: splitting for sputtering is re-introduced, (from eirene_02)
CVK 25.02.04: the ILIIN=-3 option support is re-introduced
CVK 25.02.04: spttot updated (total sputtered flux tally)
CDR 25.02.04: return, return1 for reflected flux tallies moved after call
CDR 25.02.04:                 to upsusr, calc_spectrum (from eirene_02)
C
      SUBROUTINE ESCAPE(PR,SG,*,*,*)
C
C  PROCESS ESCAPING PARTICLES
C  INPUT:
C        LGPART=.TRUE.  UPDATE TALLIES FOR INCIDENT PARTICLES, THEN SURFACE MODE
C        LGPART=.FALSE. UPDATE TALLIES FOR INCIDENT PARTICLES, THEN STOP.
C
C  RETURN  : STOP TRACK OF THIS PARTICLE TYPE. RETURN TO SUBR. MCARLO
C  RETURN 1: START NEW TRACK OF SAME TYPE IN CALLING PROGRAM 
C            (I.E. IN FOLNEUT OR FOLION)
C  RETURN 2: CONTINUE THIS TRACK IN CALLING PROGRAM (TRANSP. SURFACE)
C  RETURN 3: RESTORE COLLISION DATA, CONDITIONAL EXPECTATION WAS USED
C
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CRAND
      USE CINIT
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE COMPRT
      USE COMSPL
      USE CLGIN
      USE COUTAU
      USE CTRIG
      USE CUPD

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: PR, SG
      REAL(DP) :: DIWL(NPLS), VPWL(NPLS)
      REAL(DP) :: VXSPTC, VYSPTC, VZSPTC, VSPTC, ESPTC, VXSPTP,
     .          VYSPTP, VZSPTP, ESPTP, VELXS, VELYS, VELZS, VSPTP, TW,
     .          E0TERM, ZEP1, FR2, COSI2, ZVZ, WABS,
     .          CUR, GAMMA, TEWL, VX, VY, VZ, FCHAR, WPR, FMASS,
     .          FLX, YIELD1, YIELD2, VELS, WEIGHS, E0S, ESHET,
     .          VSHETQ, V, VELSH, VC, VCQ, VC2,SHEATH, SPLFLG
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: ISG, ISPZS, I, J, IDIM, MS, IC, IP, ITOLD, ISTS,
     .           ISSPTP, ISSPTC, IPV
      LOGICAL :: NLSPUT, LTRANS
C
C
C  .................
C  .               .
C  .  PERIODICITY: .
C  .................
C
C  CURRENTLY: ONLY IN CASE LEVGEO=1, NLTRZ. HENCE: VEL_OLD=VEL_NEW
C  TO BE WRITTEN: TOROIDICITY AS SPECIAL CASE OF PERIODICITY
      IF (ILIIN(MSURF).GE.4) THEN
C  CONDITIONAL EXPECTATION ESTIMATOR: HAS THIS PARTICLE COLLIDED IN THE VOLUME,
C  BEFORE IT HIT THE WALL?
        NLTRJ = .FALSE.
        TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
!pb        IF (ICOL.EQ.1) RETURN 3
        IF (ICOL.EQ.1) RETURN 2
C  NO
        IF (.NOT.LGPART) THEN
          WRITE (iunout,*) 'ERROR AT PERIODICITY SURFACE, LGPART=FALSE '
          RETURN
        ENDIF
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,11)
        RETURN 1
      ENDIF
C
C  .............................
C  .                           .
C  .  UPDATE INCIDENT FLUXES:  .
C  .............................
C
      ITOLD=ITYP
      WPR=WEIGHT*PR
C
C  UPDATE PARTICLE EFFLUX  ONTO SURFACE MSURF
C  UPDATE ENERGY FLUX ONTO SURFACE MSURF
C
C  SPATIAL RESOLUTION ON NON DEFAULT STANDARD SURFACE?
      IF (MSURF.GT.NLIM.AND.NLMPGS.GT.NLIMPS) THEN
        IF (LEVGEO.LE.3) THEN
          ISTS=MSURF-NLIM
          MSURFG=NLIM+NSTS+MSURFG+(ISTS-1)*NGITT
          FLX=FLXOUT(MSURFG)
        ELSE IF (LEVGEO.EQ.4) THEN
          MSURFG=NLIM+NSTS+INSPAT(IPOLGN,MRSURF)
          FLX=FLXOUT(MSURFG)
        ELSE
          MSURFG=0
          FLX=FLXOUT(MSURF)
        END IF
      ELSEIF (MSURF.GT.0) THEN
        MSURFG=0
        FLX=FLXOUT(MSURF)
      ELSE
        WRITE (iunout,*) 'ERROR IN ESCAPE: MSURF=0. KILL PARTICLE '
        RETURN
      ENDIF
C
C  FOR NON-TRANSPARENT SURFACES: INCIDENT FLUX
C  FOR     TRANSPARENT SURFACES: ONE SIDED FLUX, POSITIVE COMPONENT
C
      IF ((ILIIN(MSURF).LT.0).AND.(SG.LT.0.D0).AND.(ILIIN(MSURF).NE.-3))
     .GOTO 10
C
      IF (ITYP.EQ.1) THEN
        IF (LEOTAT) EOTAT(IATM,MSURF)=EOTAT(IATM,MSURF)+E0*WPR
        IF (LPOTAT) POTAT(IATM,MSURF)=POTAT(IATM,MSURF)+WPR
        FMASS=DBLE(NMASSA(IATM))
        FCHAR=DBLE(NCHARA(IATM))
      ELSEIF (ITYP.EQ.2) THEN
        IF (LEOTML) EOTML(IMOL,MSURF)=EOTML(IMOL,MSURF)+E0*WPR
        IF (LPOTML) POTML(IMOL,MSURF)=POTML(IMOL,MSURF)+WPR
        FMASS=DBLE(NMASSM(IMOL))
        FCHAR=DBLE(NCHARM(IMOL))
      ELSEIF (ITYP.EQ.3) THEN
        IF (ILIIN(MSURF).GT.0) THEN
          ESHET=0.D0
C  ACCOUNT FOR ELECTROSTATIC SHEATH AT SURFACE FOR TEST IONS
          IF (FSHEAT(MSURF).LE.0.D0) THEN
            GAMMA=0.
            CUR=0.
            IC=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
            IF (.NOT.LGVAC(IC,NPLS+1)) THEN
              TEWL=TEIN(IC)
              DO 30 IP=1,NPLSI
                IPV=MPLSV(IP)
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR (2,VX,VY,VZ,IP)
                ELSE
                  VX=VXIN(IPV,IC)
                  VY=VYIN(IPV,IC)
                  VZ=VZIN(IPV,IC)
                ENDIF
                VPWL(IP)=SQRT(VX**2+VY**2+VZ**2)
                DIWL(IP)=DIIN(IP,IC)
30            CONTINUE
              ESHET=NCHRGI(IION)*SHEATH(TEWL,DIWL,VPWL,
     .                                  NCHRGP,GAMMA,CUR,NPLSI,MSURF)
            ENDIF
          ELSE
            IC=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
            IF (.NOT.LGVAC(IC,NPLS+1)) THEN
              TEWL=TEIN(IC)
              ESHET=FSHEAT(MSURF)*TEWL*NCHRGI(IION)
            ENDIF
          ENDIF
C  SIMPLE SHEATH MODEL:
C    SHEATH IS NOT RESOLVED SPATIALLY. 
C    CASE A: ACCELERATING SHEATH (ESHET.GT.0):
C      THE VELOCITY COMPONENT
C      NORMAL TO THE SURFACE IS ENHANCED BY A "SHEATH-VELOCITY"
C      VELSH (CM/S), SUCH THAT THE ENERGY INCREASES BY ESHET(EV)
C    CASE B: REPULSIVE SHEATH (ESHET.LT.0):
C      CASE B1: PARTICLE STILL OVERCOMES SHEATH, BUT WITH REDUCED ENERGY
C      CASE B2: PARTICLE IS REFLECTED BY SHEATH
C
C  VSHETQ SHEATH ENERGY IN UNITS OF CM^2/S^2
C     NEGATIVE FOR REPULSIVE POTENTIAL
C     POSITIVE FOR ATTRACTIVE POTENTIAL
          VSHETQ=ESHET*RSQDVI(IION)*RSQDVI(IION)
C  VC = NORMAL COMPONENT OF VELOCITY VECTOR:
          VC=VEL*(VELX*CRTX+VELY*CRTY+VELZ*CRTZ)
          VCQ=VC*VC
C
          IF (ESHET.GT.0.D0) THEN
C  POSITIVELY CHARGED  IONS, ATTRACTIVE SHEATH POTENTIAL
C  ADD VELOCITY DUE TO SHEATH ACCELERATION
            VELSH=-VC+SQRT(VCQ+VSHETQ)
            VX=VEL*VELX+VELSH*CRTX
            VY=VEL*VELY+VELSH*CRTY
            VZ=VEL*VELZ+VELSH*CRTZ
            V=SQRT(VX*VX+VY*VY+VZ*VZ)
            VELX=VX/V
            VELY=VY/V
            VELZ=VZ/V
            E0=E0+ESHET
            VEL=SQRT(E0)*RSQDVI(IION)
            EELFI(IION,ISTRA)=EELFI(IION,ISTRA)+ESHET*WPR
          ELSEIF (ESHET.LT.0.D0) THEN
C  NEGATIVELY CHARGED  IONS
            IF (VCQ.GT.-VSHETQ) THEN
C  CASE B1
C  REDUCE NORMAL VELOCITY DUE TO SHEATH REPULSION
              VELSH=-VC+SQRT(VCQ+VSHETQ)
              VX=VEL*VELX+VELSH*CRTX
              VY=VEL*VELY+VELSH*CRTY
              VZ=VEL*VELZ+VELSH*CRTZ
              V=SQRT(VX*VX+VY*VY+VZ*VZ)
              VELX=VX/V
              VELY=VY/V
              VELZ=VZ/V
              E0=E0+ESHET
              VEL=SQRT(E0)*RSQDVI(IION)
              EELFI(IION,ISTRA)=EELFI(IION,ISTRA)+ESHET*WPR
            ELSEIF (VCQ.LT.-VSHETQ) THEN
C  CASE B2:  REFLECTION AT SHEATH, NO CHANGE IN ENERGY
              VC2=VC+VC
              VX=VEL*VELX-VC2*CRTX
              VY=VEL*VELY-VC2*CRTY
              VZ=VEL*VELZ-VC2*CRTZ
              V=SQRT(VX*VX+VY*VY+VZ*VZ)
              VELX=VX/V
              VELY=VY/V
              VELZ=VZ/V
C             E0=E0
C             VEL=SQRT(E0)*RSQDVI(IION)
              NLTRJ = .FALSE.
              TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
              RETURN 1
            ENDIF  !  REFLECT AT SHEATH OR TRANSMISSION ?
          ENDIF !  SHEATH > < 0 ?
        ENDIF ! ILIIN > 0 ?

        IF (LEOTIO) EOTIO(IION,MSURF)=EOTIO(IION,MSURF)+E0*WPR
        IF (LPOTIO) POTIO(IION,MSURF)=POTIO(IION,MSURF)+WPR
        FMASS=DBLE(NMASSI(IION))
        FCHAR=DBLE(NCHARI(IION))
      ELSEIF (ITYP.EQ.0) THEN
        IF (LEOTPHT) EOTPHT(IPHOT,MSURF)=EOTPHT(IPHOT,MSURF)+E0*WPR
        IF (LPOTPHT) POTPHT(IPHOT,MSURF)=POTPHT(IPHOT,MSURF)+WPR
        FMASS=0._dp
        FCHAR=0._dp
      ENDIF
      IF (MSURFG.GT.0) THEN
        IF (ITYP.EQ.1) THEN
          IF (LEOTAT) EOTAT(IATM,MSURFG)=EOTAT(IATM,MSURFG)+E0*WPR
          IF (LPOTAT) POTAT(IATM,MSURFG)=POTAT(IATM,MSURFG)+WPR
        ELSEIF (ITYP.EQ.2) THEN
          IF (LEOTML) EOTML(IMOL,MSURFG)=EOTML(IMOL,MSURFG)+E0*WPR
          IF (LPOTML) POTML(IMOL,MSURFG)=POTML(IMOL,MSURFG)+WPR
        ELSEIF (ITYP.EQ.3) THEN
          IF (LEOTIO) EOTIO(IION,MSURFG)=EOTIO(IION,MSURFG)+E0*WPR
          IF (LPOTIO) POTIO(IION,MSURFG)=POTIO(IION,MSURFG)+WPR
        ELSEIF (ITYP.EQ.0) THEN
          IF (LEOTPHT) EOTPHT(IPHOT,MSURFG)=EOTPHT(IPHOT,MSURFG)+E0*WPR
          IF (LPOTPHT) POTPHT(IPHOT,MSURFG)=POTPHT(IPHOT,MSURFG)+WPR
        ENDIF
      ENDIF
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
10    CONTINUE
C
C  ADDITIONAL INCIDENT SURFACE TALLIES
      IF (NADSI.GE.1) CALL UPSUSR (WPR,1)
      IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WPR,1,0)
C
C  STOP TRAJECTORY, FOR SOME REASON IN SUBROUTINE ADDCOL OR STDCOL
C
      IF (.NOT.LGPART) RETURN
C
C   ........................
C   .                      .
C   .  CALL SPUTTER MODEL  .
C   ........................
C
C
C  TENTATIVELY ASSUME: NO SPUTTERED PARTICLES WILL BE FOLLOWED
      NLSPUT=.FALSE.
C
      WGHTSP=0.
      WGHTSC=0.
      YIELD1=0.
      YIELD2=0.
      ISSPTP=0
      ISSPTC=0
C
      IF (ILSPT(MSURF).NE.0) THEN
C
C  AT THIS POINT: ILIIN.EQ.1
C  SAVE PARAMETERS OF INCIDENT PARTICLE
        E0S=E0
        WEIGHS=WEIGHT
        VELS=VEL
        VELXS=VELX
        VELYS=VELY
        VELZS=VELZ
        ISPZS=ISPZ
        CALL SPUTR1(WMINS,FMASS,FCHAR,FLX,
     .              ISRS(ISPZ,MSURF),
     .              YIELD1,
     .              ISSPTP,ESPTP,VSPTP,VXSPTP,VYSPTP,VZSPTP,
     .              ISRC(ISPZ,MSURF),
     .              YIELD2,
     .              ISSPTC,ESPTC,VSPTC,VXSPTC,VYSPTC,VZSPTC)
        NLSPUT=YIELD1.GT.0..OR.YIELD2.GT.0.
        WGHTSP=WPR*YIELD1
        WGHTSC=WPR*YIELD2
C
C  UPDATE SPUTTERED FLUX IF AVAILABLE. SORTED BY INCIDENT PARTICLE TYPE
C
        IF (NLSPUT) THEN
C  UPDATE TOTAL SPUTTERED FLUX TALLY
          IF (LSPTTOT) SPTTOT(MSURF)=SPTTOT(MSURF)+WGHTSP+WGHTSC
          IF (ITYP.EQ.1) THEN
            IF (LSPTAT)
     .        SPTAT(IATM,MSURF)=SPTAT(IATM,MSURF)+WGHTSP+WGHTSC
          ELSEIF (ITYP.EQ.2) THEN
            IF (LSPTML)
     .        SPTML(IMOL,MSURF)=SPTML(IMOL,MSURF)+WGHTSP+WGHTSC
          ELSEIF (ITYP.EQ.3) THEN
            IF (LSPTIO)
     .       SPTIO(IION,MSURF)=SPTIO(IION,MSURF)+WGHTSP+WGHTSC
C         ELSEIF (ITYP.EQ.4) THEN
C           IF (LSPTPL)
C     .       SPTPL(IPLS,MSURF)=SPTPL(IPLS,MSURF)+WGHTSP+WGHTSC
          ELSEIF (ITYP.EQ.0) THEN
            IF (LSPTPHT)
     .        SPTPHT(IPHOT,MSURF)=SPTPHT(IPHOT,MSURF)+WGHTSP+WGHTSC
          ENDIF
          IF (MSURFG.GT.0) THEN
            IF (LSPTTOT) SPTTOT(MSURFG)=SPTTOT(MSURFG)+WGHTSP+WGHTSC
            IF (ITYP.EQ.1) THEN
              IF (LSPTAT)
     .          SPTAT(IATM,MSURFG)=SPTAT(IATM,MSURFG)+WGHTSP+WGHTSC
            ELSEIF (ITYP.EQ.2) THEN
              IF (LSPTML)
     .          SPTML(IMOL,MSURFG)=SPTML(IMOL,MSURFG)+WGHTSP+WGHTSC
            ELSEIF (ITYP.EQ.3) THEN
              IF (LSPTIO)
     .          SPTIO(IION,MSURFG)=SPTIO(IION,MSURFG)+WGHTSP+WGHTSC
C           ELSEIF (ITYP.EQ.4) THEN
C              IF (LSPTPL)
C     .         SPTPL(IPLS,MSURFG)=SPTPL(IPLS,MSURFG)+WGHTSP+WGHTSC
            ELSEIF (ITYP.EQ.0) THEN
              IF (LSPTPHT)
     .          SPTPHT(IPHOT,MSURFG)=SPTPHT(IPHOT,MSURFG)+WGHTSP+WGHTSC
            ENDIF
          ENDIF
        ENDIF
C
      ENDIF
C
C
C   ...................................................................
C   .                                                                 .
C   .  SEMI-TRANSPARENT SURFACE, FOR A FRACTION "TRANSP" OF THE FLUX  .
C   ...................................................................
C
C
      LTRANS=.FALSE.
      IF (TRANSP(ISPZ,1,MSURF).GT.0.D0.OR.
     .    TRANSP(ISPZ,2,MSURF).GT.0.D0) THEN
C
C  AT THIS POINT: ILIIN(MSURF).GT.0
C
        IF (SG.GT.0) ISG=1
        IF (SG.LT.0) ISG=2
        LTRANS=RANF_EIRENE( ).LE.TRANSP(ISPZ,ISG,MSURF)
        IF (LTRANS) THEN
C  A NON TRANSPARENT SURFACE IS MADE TRANSPARENT FOR THIS
C  PARTICULAR PARTICLE
C  STANDARD OR ADDITIONAL SURFACE?
          MS=MSURF
          IF (MSURF.GT.NLIM) THEN
            ISTS=MSURF-NLIM
            MS=-ISTS
            IF (INUMP(ISTS,1).NE.0) IDIM=1
            IF (INUMP(ISTS,2).NE.0) IDIM=2
            IF (INUMP(ISTS,3).NE.0) IDIM=3
C  CELL NUMBER SWITCHES LIKE A TRANSPARENT DEFAULT STANDARD SURFACE IN STDCOL
            IF (IDIM.EQ.1) NRCELL=NRCELL+NINCX
            IF (IDIM.EQ.2) THEN
              NPCELL=NPCELL+NINCY
              IPOLG=MPSURF
            END IF
            IF (IDIM.EQ.3) NTCELL=NTCELL+NINCZ
          ENDIF
          IF (NLTRC) THEN
            CALL LEER(1)
            WRITE (iunout,*) 'SURFACE MSURF= ',MS,' IS MADE TRANSPARENT'
            WRITE (iunout,*) 'ORIENTATION, SPECIES: ',ISG,ISPZ
          ENDIF
        ENDIF
C
      ENDIF
C
C
C   ...................................
C   .                                 .
C   .  PERFECTLY ABSORBING SURFACES   .
C   ...................................
C
C
C  NOTHING ELSE TO BE DONE, RETURN
C
      IF (ILIIN(MSURF).EQ.2.AND..NOT.LTRANS) THEN
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WPR
        WEIGHT=0.D0
        LGPART=.FALSE.
        NLTRJ = .FALSE.
        TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
        IF (ICOL.EQ.1) RETURN 3
        RETURN
      ENDIF
C
C   ..............................................
C   .                                            .
C   .   MIRROR, OR SEMI-TRANSPARENT SURFACE      .
C   .   REEMITTED FLUX=INCOMING FLUX AND RETURN  .
C   ..............................................
C
      IF (LTRANS.OR.ILIIN(MSURF).EQ.3) THEN
C
C ITOLD=ITNEW=ITYP
C
        IF (ITYP.EQ.1) THEN
          IF (LERFAAT) ERFAAT(IATM,MSURF)=ERFAAT(IATM,MSURF)+E0*WPR
          IF (LPRFAAT) PRFAAT(IATM,MSURF)=PRFAAT(IATM,MSURF)+WPR
        ELSEIF (ITYP.EQ.2) THEN
          IF (LERFMML) ERFMML(IMOL,MSURF)=ERFMML(IMOL,MSURF)+E0*WPR
          IF (LPRFMML) PRFMML(IMOL,MSURF)=PRFMML(IMOL,MSURF)+WPR
        ELSEIF (ITYP.EQ.3) THEN
          IF (LERFIIO) ERFIIO(IION,MSURF)=ERFIIO(IION,MSURF)+E0*WPR
          IF (LPRFIIO) PRFIIO(IION,MSURF)=PRFIIO(IION,MSURF)+WPR
        ELSEIF (ITYP.EQ.0) THEN
          IF (LERFPHPHT)
     .      ERFPHPHT(IPHOT,MSURF)=ERFPHPHT(IPHOT,MSURF)+E0*WPR
          IF (LPRFPHPHT)
     .      PRFPHPHT(IPHOT,MSURF)=PRFPHPHT(IPHOT,MSURF)+WPR
        ENDIF
        IF (MSURFG.GT.0) THEN
          IF (ITYP.EQ.1) THEN
            IF (LERFAAT) ERFAAT(IATM,MSURFG)=ERFAAT(IATM,MSURFG)+E0*WPR
            IF (LPRFAAT) PRFAAT(IATM,MSURFG)=PRFAAT(IATM,MSURFG)+WPR
          ELSEIF (ITYP.EQ.2) THEN
            IF (LERFMML) ERFMML(IMOL,MSURFG)=ERFMML(IMOL,MSURFG)+E0*WPR
            IF (LPRFMML) PRFMML(IMOL,MSURFG)=PRFMML(IMOL,MSURFG)+WPR
          ELSEIF (ITYP.EQ.3) THEN
            IF (LERFIIO) ERFIIO(IION,MSURFG)=ERFIIO(IION,MSURFG)+E0*WPR
            IF (LPRFIIO) PRFIIO(IION,MSURFG)=PRFIIO(IION,MSURFG)+WPR
          ELSEIF (ITYP.EQ.0) THEN
            IF (LERFPHPHT)
     .        ERFPHPHT(IPHOT,MSURFG)=ERFPHPHT(IPHOT,MSURFG)+E0*WPR
          IF (LPRFPHPHT)
     .        PRFPHPHT(IPHOT,MSURFG)=PRFPHPHT(IPHOT,MSURFG)+WPR
          ENDIF
        ENDIF
C
C  EITHER: SEMI-TRANSPARENT SURFACE
C
        IF (LTRANS) THEN
          IF (NADSI.GE.1) CALL UPSUSR (WPR,2)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WPR,2,0)
          RETURN 2
C
C  OR: MIRROR
C
        ELSEIF (ILIIN(MSURF).EQ.3) THEN
          COSI2=-2.*(VELX*CRTX+VELY*CRTY+VELZ*CRTZ)
          VELX=VELX+COSI2*CRTX
          VELY=VELY+COSI2*CRTY
          VELZ=VELZ+COSI2*CRTZ
          IF (NADSI.GE.1) CALL UPSUSR (WPR,2)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WPR,2,0)
          NLTRJ = .FALSE.
          TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
          IF (ICOL.EQ.1) RETURN 3
          RETURN 1
        ENDIF
      ENDIF
C
C   .........................
C   .                       .
C   .  TRANSPARENT SURFACE  .
C   .........................
C
      IF (ILIIN(MSURF).LT.0) THEN
C
C  ONE SIDED FLUX: NEGATIVE COMPONENT
C  IN CASE ILIIN=-3: NET FLUXES HAVE ALREADY BEEN UPDATED ABOVE.
C                    NEED NOT BE UPDATED AGAIN HERE.
C
        IF (SG.GT.0.D0.OR.ILIIN(MSURF).EQ.3) GOTO 90
C
C ITOLD=ITNEW=ITYP
C
        IF (ITYP.EQ.1) THEN
          IF (LERFAAT) ERFAAT(IATM,MSURF)=ERFAAT(IATM,MSURF)+E0*WPR
          IF (LPRFAAT) PRFAAT(IATM,MSURF)=PRFAAT(IATM,MSURF)+WPR
        ELSEIF (ITYP.EQ.2) THEN
          IF (LERFMML) ERFMML(IMOL,MSURF)=ERFMML(IMOL,MSURF)+E0*WPR
          IF (LPRFMML) PRFMML(IMOL,MSURF)=PRFMML(IMOL,MSURF)+WPR
        ELSEIF (ITYP.EQ.3) THEN
          IF (LERFIIO) ERFIIO(IION,MSURF)=ERFIIO(IION,MSURF)+E0*WPR
          IF (LPRFIIO) PRFIIO(IION,MSURF)=PRFIIO(IION,MSURF)+WPR
        ELSEIF (ITYP.EQ.0) THEN
          IF (LERFPHPHT)
     .      ERFPHPHT(IPHOT,MSURF)=ERFPHPHT(IPHOT,MSURF)+E0*WPR
          IF (LPRFPHPHT)
     .      PRFPHPHT(IPHOT,MSURF)=PRFPHPHT(IPHOT,MSURF)+WPR
        ENDIF
        IF (MSURFG.GT.0) THEN
          IF (ITYP.EQ.1) THEN
            IF (LERFAAT) ERFAAT(IATM,MSURFG)=ERFAAT(IATM,MSURFG)+E0*WPR
            IF (LPRFAAT) PRFAAT(IATM,MSURFG)=PRFAAT(IATM,MSURFG)+WPR
          ELSEIF (ITYP.EQ.2) THEN
            IF (LERFMML) ERFMML(IMOL,MSURFG)=ERFMML(IMOL,MSURFG)+E0*WPR
            IF (LPRFMML) PRFMML(IMOL,MSURFG)=PRFMML(IMOL,MSURFG)+WPR
          ELSEIF (ITYP.EQ.3) THEN
            IF (LERFIIO) ERFIIO(IION,MSURFG)=ERFIIO(IION,MSURFG)+E0*WPR
            IF (LPRFIIO) PRFIIO(IION,MSURFG)=PRFIIO(IION,MSURFG)+WPR
          ELSEIF (ITYP.EQ.0) THEN
            IF (LERFPHPHT)
     .        ERFPHPHT(IPHOT,MSURFG)=ERFPHPHT(IPHOT,MSURFG)+E0*WPR
            IF (LPRFPHPHT)
     .        PRFPHPHT(IPHOT,MSURFG)=PRFPHPHT(IPHOT,MSURFG)+WPR
          ENDIF
        ENDIF
C
90      CONTINUE
        IF (NADSI.GE.1) CALL UPSUSR (WPR,2)
        IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WPR,2,0)
        RETURN 2
      ENDIF
C
C
100   CONTINUE
C
C   .............................
C   .                           .
C   .  NON TRANSPARENT SURFACE  .
C   .............................
C
      XGENER=0.
C
C  ALL INCIDENT SURFACE TALLIES (INCLUDING SPUTTERING TALLIES, AND
C  INCLUDING CONDITIONAL EXPECTATION CORRECTION, ARE UPDATED.
C  TRANSPARENT, MIRROR AND ABSORBING SURFACES ARE ALSO DONE
C
C  CONDITIONAL EXPECTATION ESTIMATOR: HAS THIS PARTICLE COLLIDED IN THE VOLUME,
C  BEFORE IT HIT THE WALL?
C
      IF (ICOL.EQ.1) THEN
        NLTRJ = .FALSE.
        TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
        RETURN 3
      END IF
C
C  ..........................................................................
C
C  NOW DEAL WITH REFLECTED AND/OR SPUTTERED PARTICLES.
C  ..........................................................................
C
C  REFLECTION FROM SURFACE
C
C  ......................................................
C  .                                                    .
C  .  REFLECTION MODEL 600--699 FOR INCIDENT MOLECULES  .
C  ......................................................
C
C
600   CONTINUE
C
      IF (ITYP.EQ.2) THEN
C
C  TEST FOR REFLECTION
C
        IF (WEIGHT.GE.WMINS) THEN
C  WITH SUPPRESSION OF ABSORPTION
          WABS=WEIGHT*(1.D0-RECYCT(ISPZ,MSURF))
          IF (WABS.GT.0.D0) THEN
            IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WABS
            WEIGHT=WEIGHT-WABS
          ENDIF
          IF (WEIGHT.GT.EPS30) GOTO 610
          LGPART=.FALSE.
          RETURN
        ELSEIF (RECYCT(ISPZ,MSURF).NE.1.D0) THEN
C  NO SUPPRESSION OF ABSORPTION
          ZVZ=RANF_EIRENE( )
          IF (ZVZ.LT.RECYCT(ISPZ,MSURF)) GOTO 610
C  ABSORB THIS PARTICLE
          IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
          LGPART=.FALSE.
          RETURN
        ENDIF
C
610     CONTINUE
C
C  NEW SPECIES: AGAIN MOLECULE
C
C       ITYP=2
        IMOL=ISRT(ISPZ,MSURF)
        IF (IMOL.GT.NMOLI) THEN
          FR2=RANF_EIRENE( )
          DO 621 I=1,NMOLI
            IMOL=I
            IF (FR2.LE.DMOL(IMOL)) GOTO 622
621       CONTINUE
          GOTO 995
622       CONTINUE
        ELSEIF (IMOL.EQ.0) THEN
C  NO THERMAL EMISSION, ABSORB INSTEAD
          IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
          LGPART=.FALSE.
          RETURN
        ELSEIF (IMOL.LT.0) THEN
C  NOT IN USE
          GOTO 995
        ENDIF
C
        ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
        E0TERM=EWALL(MSURF)
        IF (E0TERM.GT.0) THEN
C  MONOENERGETIC DISTRIBUTION
          E0=E0TERM
          E0_MEAN=E0
          VEL=RSQDVM(IMOL)*SQRT(E0)
C   AZIMUTAL ANGLE: EQUIDISTRIBUTION
C   POLAR ANGLE: COSINE
          IF (INIV4.EQ.0) CALL FCOSIN
          VX=FC1(INIV4)
          VY=FC2(INIV4)
          VZ=FC3(INIV4)
          INIV4=INIV4-1
          CALL ROTATF (VELX,VELY,VELZ,VX,VY,VZ,CRTX,CRTY,CRTZ)
        ELSEIF (E0TERM.LT.0.D0) THEN
C  SAMPLE FROM MAXWELLIAN FLUX AROUND INNER (!) NORMAL AT TEMP. TW (EV)
          TW=-E0TERM
          CALL VELOCS (TW,0._DP,0._DP,0._DP,0._DP,0._DP,RSQDVM(IMOL),
     .                 CVRSSM(IMOL),
     .                -CRTX,-CRTY,-CRTZ,
     .                 E0,VELX,VELY,VELZ,VEL)
          E0_MEAN=2.*TW
        ELSE
          WRITE (iunout,*) 'ERROR IN ESCAPE, EXIT CALLED '
          CALL EXIT_OWN(1)
        ENDIF
C
C  ...............................................
C  .                                             .
C  .  REFLECTION MODEL FOR ATOMS OR ATOMIC IONS  .
C  ...............................................
C
      ELSEIF (ITYP.EQ.1.OR.ITYP.EQ.3) THEN
C
C
C  THESE INCIDENT PARTICLES MAY HAVE SPUTTERED AT THIS  SURFACE
C
        SPLFLG=0.
C
        IF (WGHTSP.GT.0..AND.ISSPTP.GT.0) THEN
C  FOLLOW SPUTTERED PARTICLES LATER. PUT THEM INTO STATISTICAL CELLAR
C
          IF (NLEVEL.GE.15) THEN
            WRITE (iunout,*) 'SPLITTING ABANDONED FOR PART. NO. ',NPANU
            WRITE (iunout,*) 'CASCADE OVERFLOW: NEVEL: ',NLEVEL
            GOTO 4712
          ENDIF
          SPLFLG=SPLFLG+1.
          ISPZ=ISSPTP
          ITYP=ISPEZI(ISPZ,-1)
          IPHOT=ISPEZI(ISPZ,0)
          IATM=ISPEZI(ISPZ,1)
          IMOL=ISPEZI(ISPZ,2)
          IION=ISPEZI(ISPZ,3)
          IPLS=ISPEZI(ISPZ,4)
          E0=ESPTP
          WEIGHT=WGHTSP
          VEL=VSPTP
          VELX=VXSPTP
          VELY=VYSPTP
          VELZ=VZSPTP
C  ITOLD.NE.ITNEW=ITYP POSSIBLE
C
          CALL UPDATE_SURFACE (ITOLD)
          IF (NADSI.GE.1) CALL UPSUSR (WEIGHT,2)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WEIGHT,2,0)
C
C.....................................................................
C  SPLITTING
C
          NLEVEL=NLEVEL+1
C  SAVE LOCATION, WEIGHT AND OTHER PARAMETERS AT CURRENT LEVEL
          DO 533 J=1,NPARTC
            RSPLST(NLEVEL,J)=RPST(J)
533       CONTINUE
          DO 534 J=1,MPARTC
            ISPLST(NLEVEL,J)=IPST(J)
534       CONTINUE
C  NUMBER OF NODES AT THIS LEVEL
          NODES(NLEVEL)=2
C
        ENDIF
C
C  SPLITTING FOR PHYSICAL SPUTTERING DONE

C
        IF (WGHTSC.GT.0..AND.ISSPTC.GT.0) THEN
C
C  CHEMICAL SPUTTERING
C
C  FOLLOW SPUTTERED PARTICLES LATER. PUT THEM INTO STATISTICAL CELLAR
          IF (NLEVEL.GE.15) THEN
            WRITE (iunout,*) 'SPLITTING ABANDONED FOR PART. NO. ',NPANU
            WRITE (iunout,*) 'CASCADE OVERFLOW: NEVEL: ',NLEVEL
            GOTO 4712
          ENDIF
          SPLFLG=SPLFLG+1.
          ISPZ=ISSPTC
          ITYP=ISPEZI(ISPZ,-1)
          IPHOT=ISPEZI(ISPZ,0)
          IATM=ISPEZI(ISPZ,1)
          IMOL=ISPEZI(ISPZ,2)
          IION=ISPEZI(ISPZ,3)
          IPLS=ISPEZI(ISPZ,4)
          E0=ESPTC
          WEIGHT=WGHTSC
          VEL=VSPTC
          VELX=VXSPTC
          VELY=VYSPTC
          VELZ=VZSPTC
C  ITOLD.NE.ITNEW=ITYP POSSIBLE
C
          CALL UPDATE_SURFACE (ITOLD)
          IF (NADSI.GE.1) CALL UPSUSR (WEIGHT,2)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WEIGHT,2,0)
C
C.....................................................................
C  SPLITTING
C
          NLEVEL=NLEVEL+1
C  SAVE LOCATION, WEIGHT AND OTHER PARAMETERS AT CURRENT LEVEL
          DO 535 J=1,NPARTC
            RSPLST(NLEVEL,J)=RPST(J)
535       CONTINUE
          DO 536 J=1,MPARTC
            ISPLST(NLEVEL,J)=IPST(J)
536       CONTINUE
C  NUMBER OF NODES AT THIS LEVEL
          NODES(NLEVEL)=2
C
        ENDIF
C
C  SPLITTING FOR CHEMICAL SPUTTERING DONE.
C
C  RESTORE INCIDENT PARTICLE, FOR SURFACE REFLECTION ROUTINE
C
4712    CONTINUE
        IF (SPLFLG.NE.0) THEN
          E0=E0S
          WEIGHT=WEIGHS
          VEL=VELS
          VELX=VELXS
          VELY=VELYS
          VELZ=VELZS
          ISPZ=ISPZS
          LGPART=.FALSE.
        ENDIF
C
        CALL REFLC1 (WMINS,FMASS,FCHAR,NPRT(ISPZ),
     .               ISRF(ISPZ,MSURF),ISRT(ISPZ,MSURF))
        ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
        IF (.NOT.LGPART) THEN
          WEIGHT=0.
        ENDIF
C
C  ............................................
C  .                                          .
C  .  REFLECTION MODEL 700...799 FOR PHOTONS  .
C  ............................................
C
      ELSEIF (ITYP.EQ.0) THEN

        CALL REFLC1_PHOTON (WMINS,FMASS,FCHAR,NPRT(ISPZ),
     .               ISRF(ISPZ,MSURF),ISRT(ISPZ,MSURF))
        ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
        IF (.NOT.LGPART) THEN
          WEIGHT=0.
        ENDIF
      ENDIF
C
C  UPDATE REFLECTED PARTICLE AND ENERGY FLUX
C
      IF (.NOT.LGPART) RETURN
C
C  ITOLD.NE.ITNEW=ITYP POSSIBLE
C
      CALL UPDATE_SURFACE (ITOLD)
      IF (NADSI.GE.1) CALL UPSUSR (WEIGHT,2)
      IF (NADSPC.GE.1) CALL CALC_SPECTRUM (WEIGHT,2,0)
C
      NLTRJ = .FALSE.
      TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
      IF  (ITYP.EQ.ITOLD) RETURN 1
      IF ((ITYP.EQ.1.AND.ITOLD.EQ.2).OR.
     .    (ITYP.EQ.2.AND.ITOLD.EQ.1)) RETURN 1
      RETURN
C
995   CONTINUE
      WRITE (iunout,*) 'SPECIES INDEX OUT OF RANGE IN ESCAPE '
      WRITE (iunout,*) 'IMOL, MSURF ',IMOL,MSURF
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: folion.f
!PB 12.01.06: calls to calc_spectrum introduced for cell based spectra
!PB 18.04.06: xstorv=0 in "vacuum region" added
!DR  4.08.06: check v_par=0, otherwise stop trajectory (lable 992)
!DR 10.08.06: cut off Ti with T_vac for collision frequency, for
!             ion tracing in vacuum region
!DR 10.8.06: introduce LCART: TRUE, if velx,vely,velx,vel are cartesian
!                             FALSE,if velx,vely,velx,vel guiding centre
!                                   in this case, cartesian velocity
!                                   is stored in: velxs, velys, velzs, vels
!PB 28.09.06: sg corrected for levgeo=4 and levgeo=5

C  Sept 05: also vel=velpar before call  to ...col  routines.

C  MAY05: CALL UPDATE FROM STATIC LOOP WITH IFLAG=4 (RATHER =1)
C         WG. COLL EST. ON 1ST FLIGHT AFTER BIRTH.
C
      SUBROUTINE FOLION
C
C     CHARGED PARTICLE, LAUNCHED AT X0,Y0,Z0 IN CELL NRCELL, IPOLG,
C     IPERID, NPCELL, NTCELL, NACELL, NBLOCK, WITH VELOCITY VELX,VELY,VELX
C     IS FOLLOWED.
C     (MODULE: COMPRT.F)
c
c
c
c
c
c
c
C
C  ON INPUT:
C     ITYP=3
C  ON OUTPUT:
C
C           ITYP=0  NEXT GENERATION PHOTON IPHOT IS GENERATED
C           ITYP=1  NEXT GENERATION ATOM IATM IS GENERATED
C           ITYP=2  NEXT GENERATION MOLECULE IMOL IS GENERATED
C           ITYP=4  NO NEXT GENERATION PARTICLE IS GENERATED
C                   (PARTICLE ABSORBED IN BULK ION SPECIES)
C
C  DIFFERENCES FROM SUBR. FOLNEUT:
C    1) MOTION ALONG B (VELPAR,VERPER,....)
C    2) ADDITIONALLY: "FOKKER PLANCK COLLISIONS", ISRFCL=4
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CFPLK
      USE CLOGAU
      USE CRAND
      USE CINIT
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CGEOM
      USE CTETRA
      USE COMPRT
      USE COMNNL
      USE CLGIN
      USE COUTAU
      USE COMXS
      USE CTRIG
      USE CTRCEI
      IMPLICIT NONE

      REAL(DP) :: CFLAG(7,3), DUMT(3), DUMV(3)
      REAL(DP) :: AX(2),v,vv,vx,vy,vz
      REAL(DP) :: XSTOR2(MSTOR1,MSTOR2,N2ND+N3RD),
     .            XSTORV2(NSTORV,N2ND+N3RD),
     .            BVEC_1(3), VVEC(3)
      REAL(DP) :: GYRO, cosin, XLI, YLI, ZLI, FNUI, DIST,
     .          PR, WS, COLTYP, X0ERR, Y0ERR, Z0ERR, 
     .          VELXS, VELYS, VELZS, VELS, 
     .          PUX, PUY, SG,
     .          VCOS, ZLOG, ZINT1, ZEP1, ZTST, ZINT2,
     .          ZMFP, PN, SH, FPATHI, ZTC, 
     .          FNUEQI, XNI, TI,
     .          DELFAC,TIFAC,
     .          SCOS_NEW, XOLD, YOLD
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: ISTS, LEARC2, NCOUS, ICOU, J, JJ, IPL, NRCELL_OLD,
     .           ICO, NLI, NLE, NPCELL_OLD, JCOL, NRC, NTCELL_OLD,
     .           NRCOLD, IPLTI, I, IM, IFLAG, ICOUN,NTEST,
     .           LEARC1, IDUM, IFPB
      LOGICAL :: LCNDEXP
C
C  NO CONDITIONAL EXPECTATION ESTIMATORS FOR TEST IONS
C
C  ENERGY LOSS FREQUENCY (LANGER APPROXIMATION) (1/SEC)
C  NUCL.FUS. 22, NO. 6, (1986) P754
      FNUEQI(XNI,TI)=8.8E-8*XNI*TI**(-1.5)
C
C  ALL CELL INDICES MUST BE KNOWN AT THIS POINT
C  TENTATIVELY ASSUME: A NEXT GENERATION PARTICLE WILL BE BORN
C
C  IC_NEUT, IC_ION: COUNTER FOR GENERATIONS WITHIN STATIC LOOP
      IC_ION=IC_NEUT
      LCART=.TRUE.
100   LGPART=.TRUE.
C  FULL CARTESIAN VELOCITY VECTOR VEL,VELX,VELY,VELZ AT THIS POINT
      IF (.NOT.LCART) GOTO 9921
      IC_ION=IC_ION+1
      XGENER=0
      ico=0
      IF (ITYP.EQ.3.AND.(IION.LE.0.OR.IION.GT.NIONI)) GOTO 998
C
C  THE  CELL NUMBER NRCELL, IPOLG, IPERID, NPCELL, NTCELL, NACELL, NBLOCK
C  WAS ALREADY SET IN CALLING SUBROUTINE MCARLO
C
C  IF NLSRFX, SURFACE INDEX MRSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFY, SURFACE INDEX MPSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFZ, SURFACE INDEX MTSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFA, SURFACE INDEX MASURF MUST BE DEFINED AT THIS POINT
C
C  FIND DIRECTION PARALLEL TO B-FIELD
C  I.E. CONVERT CARTESIAN VELOCITY UNIT VECTOR VELX,VELY,VELX INTO
C       PARALLEL AND PERPENDICULAR UNIT VELOCITY COMPONENTES  VELPAR
C
1005  NUPC(1)=NPCELL-1+(NTCELL-1)*NP2T3
      NCELL=NRCELL+NUPC(1)*NR1P2+NBLCKA
      IF (NCELL.GT.NSBOX.OR.NCELL.LT.1) GOTO 991
      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BBX,BBY,BBZ,1)
      ELSE
        BBX=BXIN(NCELL)
        BBY=BYIN(NCELL)
        BBZ=BZIN(NCELL)
      END IF
      BVEC = (/ BBX, BBY, BBZ /)
1003  CONTINUE
      VCOS=VELX*BBX+VELY*BBY+VELZ*BBZ
      IF (ABS(VCOS).LT.EPS30) GOTO 992
      SIGPAR=SIGN(1._DP,VCOS)
      VELXS=VELX
      VELYS=VELY
      VELZS=VELZ
      VELS=VEL
C  USE B-FIELD LINE AS TRAJECTORY
      VLXPAR=SIGPAR*BBX
      VLYPAR=SIGPAR*BBY
      VLZPAR=SIGPAR*BBZ
      VELPAR=ABS(VEL*VCOS)
      VELPER=SQRT(MAX(0._DP,VEL**2 - VELPAR**2))
C  VELOCITY WITH RESPECT TO B-FIELD IS NOW DEFINED:
C  VELPAR: PARALLEL VELOCITY, ABSOLUTE VALUE
C  SIGPAR: SIGN OF PARALLEL VELOCITY WITH RESPECT TO B
C  VELPER: PERPENDICULAR VELOCITY, ALWAYS NON-NEGATIVE
C  VL_PAR: PARALLEL UNIT SPEED VECTOR, VL_PAR=SIG*B
C     VL_PAR=(/VLXPAR,VLYPAR,VLZPAR/)
C
C  SET ION ENERGY = PARALLEL ENERGY OF THE IONIZED TEST PARTICLE
      E0PAR=CVRSSI(IION)*VELPAR*VELPAR
C
1004  CONTINUE
C
C  FOLLOW MOTION OF TEST ION OR "STATIC APPROXIMATION"?
      IF (NFOLI(IION).EQ.-1.AND.IFPATH.EQ.1) GOTO 1001 ! go to static loop
C
C  the particle may be sitting exactly on a surface (nlsrf...=.true.).
C
C  this part is special for ions: due to projection of velocity
C  onto Gyro Center motion (or even onto B-field) the correct
C  angle of incidence onto surface may be lost (e.g. cosin lt 0 may result).
C
C  Was the correct ncell used, in case of nlsrf?
C  Fiddle around a bit with cell number and flight direction in this case.
C


      IF (NLSRFX) THEN

c  particle is exactly on one of the radial grid surfaces (MRSURF)
C  RADIAL CELL NO. NRCELL MAY BE WRONG
C  CHECK ORIENTATION OF PARALLEL MOTION RELATIV TO RADIDAL COORDINATE
C
        NRCELL_OLD=NRCELL
        IF (LEVGEO.EQ.1) THEN
          SG=SIGN(1._DP,VLXPAR)
          IF (SG.LT.0) THEN
            NRCELL=MRSURF-1
          ELSEIF (SG.GT.0) THEN
            NRCELL=MRSURF
          ENDIF
        ELSEIF (LEVGEO.EQ.2) THEN
          PUX= X0-EP1(MRSURF)
          PUY= Y0/ELL(MRSURF)/ELL(MRSURF)
          PN=SQRT(PUX*PUX+PUY*PUY+EPS60)
          PUX=PUX/PN
          PUY=PUY/PN
          SG=VLXPAR*PUX+VLYPAR*PUY
          IF (ABS(SG) .LT. EPS12) THEN
            NLSRFX=.FALSE.
            SH=SIGN(1._DP,SG)*CELDIA(NCELL)*1.D-2
            X0 = X0 + SH*PUX
            Y0 = Y0 + SH*PUY
          END IF
          IF (SG.LT.0) THEN
            NRCELL=NGHPLS(1,MRSURF,NPCELL)
          ELSEIF (SG.GT.0) THEN
            NRCELL=NGHPLS(3,MRSURF,NPCELL)
          ENDIF
        ELSEIF (LEVGEO.EQ.3) THEN
          IFPB = 1
          XOLD = X0
          YOLD = Y0
          IDUM = NPCELL
          SG=VLXPAR*PLNX(MRSURF,NPCELL)+VLYPAR*PLNY(MRSURF,NPCELL)
          DO 
            IF (ABS(SG) .LT. EPS12) THEN
              NLSRFX=.FALSE.
              SH=SIGN(1._DP,SG)*CELDIA(NCELL)*1.D-2
              X0 = XOLD + SH*PLNX(MRSURF,NPCELL)*IFPB
              Y0 = YOLD + SH*PLNY(MRSURF,NPCELL)*IFPB
            END IF
            IF (SG.LT.0) THEN
              NRCELL=NGHPLS(1,MRSURF,NPCELL)
            ELSEIF (SG.GT.0) THEN
              NRCELL=NGHPLS(3,MRSURF,NPCELL)
            ELSE
              NRCELL=LEARC1(X0,Y0,Z0,IDUM,MRSURF-1,MRSURF,NLSRFX,NLSRFY,
     .                      NPANU,'FOLION      ')
            ENDIF
            IF (NPCELL == IDUM) EXIT
            IFPB = -1
          END DO
        ELSEIF (LEVGEO.EQ.4) THEN
          SG=VLXPAR*PTRIX(IPOLG,MRSURF)+
     .       VLYPAR*PTRIY(IPOLG,MRSURF)
          IF (ABS(SG) .LT. EPS12) THEN
            NLSRFX=.FALSE.
            SH=SIGN(1._DP,SG)*CELDIA(NCELL)*1.D-8
            X0 = X0  +SH*PTRIX(IPOLG,MRSURF)
            Y0 = Y0  +SH*PTRIY(IPOLG,MRSURF)
            WRITE (iunout,*) 'on SURFACE IN FOLION ',NPANU
            WRITE (iunout,*) 'and parallel to SURFACE'
            WRITE (iunout,*) 'push Back in cell, sh ',sh
          ELSEIF (SG.GT.0) THEN
            NTEST=NCHBAR(IPOLG,MRSURF)
            IF (NTEST.EQ.0) THEN
c  no neighbor. push back into old cell.
              SH=-CELDIA(NCELL)*1.D-8
              WRITE (iunout,*) 'ON SURFACE IN FOLION ',NPANU
              WRITE (iunout,*) 'Back in cell: sh, NRCELL ',sh,NRCELL
              NLSRFX=.FALSE.
c  strictly: particle should be pushed towards COM.
              X0 = X0  +SH*PTRIX(IPOLG,MRSURF)
              Y0 = Y0  +SH*PTRIY(IPOLG,MRSURF)
            ELSE
c  neighbor found. continue in neighbor cell.
              NRCELL=NTEST
              IPOLG=NSEITE(IPOLG,MRSURF)
              MRSURF=NRCELL
            ENDIF
          ELSEIF (SG.LT.0) THEN
c  continue flight in original cell.
C  NOTHING TO BE DONE
          ENDIF
        ELSEIF (LEVGEO.EQ.5) THEN
          SG=VLXPAR*PTETX(IPOLG,MRSURF)+
     .       VLYPAR*PTETY(IPOLG,MRSURF)+
     .       VLZPAR*PTETZ(IPOLG,MRSURF)
          IF (ABS(SG) .LT. EPS12) THEN
C  TO BE WRITTEN
            WRITE (iunout,*) 'PARALLEL TO SURFACE IN FOLION ',NPANU
            CALL EXIT_OWN(1)
          ELSEIF (SG.GT.0) THEN
            NRCELL=NTBAR(IPOLG,MRSURF)
            IPOLG=NTSEITE(IPOLG,MRSURF)
            MRSURF=NRCELL
          ELSEIF (SG.LT.0) THEN
C  NOTHING TO BE DONE
          ENDIF
        ELSE
          write (iunout,*) 'levgeo in folion  ', levgeo
          write (iunout,*) 'option not ready, exit called'
          call exit_own(1)
        ENDIF

        IF (NRCELL.NE.NRCELL_OLD) THEN
          ico=ico+1
          if (ico.le.1) goto 1005
        ENDIF


      ELSEIF (NLSRFY) THEN


c  particle is on one of the poloidal grid surfaces (MPSURF)
C  POLOIDAL CELL NO. NPCELL MAY BE WRONG
C  CHECK ORIENTATION OF PARALLEL MOTION RELATIV TO POLOIDAL COORDINATE
C
        NPCELL_OLD=NPCELL
        IF (LEVGEO.EQ.1) THEN
          SG=SIGN(1._DP,VLYPAR)
          IF (SG.LT.0) THEN
            NPCELL=MPSURF-1
          ELSEIF (SG.GT.0) THEN
            NPCELL=MPSURF
          ENDIF
        ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
          SG=VLXPAR*PPLNX(NRCELL,MPSURF)+VLYPAR*PPLNY(NRCELL,MPSURF)
          IF (SG.LT.0) THEN
            npcell=nghpls(4,nrcell,mpsurf)
            ipolg=npcell
C  ACCOUNT FOR CUTS, PERIODICITY, ETC.
C           mpsurf is correct
          ELSEIF (SG.GT.0) THEN
            npcell=nghpls(2,nrcell,mpsurf)
            ipolg=npcell
C  ACCOUNT FOR CUTS, PERIODICITY, ETC.
            mpsurf=npcell
          ENDIF
        ENDIF
        IF (NPCELL.NE.NPCELL_OLD) THEN
          ico=ico+1
          if (ico.le.1) goto 1005
        ENDIF


      ELSEIF (NLSRFZ) THEN


c  particle is on one of the toroidal grid surfaces (MTSURF)
C  TOROIDAL CELL NO. NTCELL MAY BE WRONG
C  CHECK ORIENTATION OF PARALLEL MOTION RELATIV TO POLOIDAL COORDINATE
C
        NTCELL_OLD=NTCELL
C  VLZPAR IS THE RELEVANT VELOCITY COMPONENT, BOTH FOR
C  NLTRZ AND NLTRT OPTION
        SG=SIGN(1._DP,VLZPAR)
        IF (SG.LT.0) THEN
          NTCELL=MTSURF-1
        ELSEIF (SG.GT.0) THEN
          NTCELL=MTSURF
        ENDIF
        IF (NTCELL.NE.NTCELL_OLD) THEN
          ico=ico+1
          if (ico.le.1) goto 1005
        ENDIF
      ENDIF
C
C AT THIS POINT: V_PARALLEL, V_PERP , GYROPHASE, KNOWN
C
      GOTO 1002
C
1001  CONTINUE
      IF (IC_ION.EQ.1.AND.NLTRC.AND.TRCHST)
     .  WRITE (iunout,*) 'TRAJECTORY ENTERS STATIC LOOP, ITYP=', ITYP

C***********************************************************************
C  STATIC APPROXIMATION
C  SIMULATE NEXT COLLISION INSTANTANEOUSLY
C***********************************************************************
 
C  WEIGHT TOO SMALL? STOP HISTORY
      IF (WEIGHT.LT.EPS30) THEN
        LGPART=.FALSE.
        RETURN
      ENDIF
C
C  PARTICLE ON SURFACE ?
      IF (NLSRFX.OR.NLSRFY.OR.NLSRFZ.OR.NLSRFA) THEN
C  EMITTED  ?  CALL COLLIDE, AFTER UPDATE
        IF (IC_ION.EQ.1) THEN
C  FIRST ENTRY INTO "STATIC LOOP", ALWAYS: EMITTED FROM FROM SURFACE
C    (CRTXG,....,...): NORMAL RELATIVE TO DEFAULT SETTINGS
C                      NEEDED LATER IF PARTICLE LEAVES STATIC LOOP
C                      VIA STDCOL OR ADDCOL
          CRTXG=CRTX*SCOS
          CRTYG=CRTY*SCOS
          CRTZG=CRTZ*SCOS
          SCOS = SIGN(1.D0,VLXPAR*CRTXG+VLYPAR*CRTYG+VLZPAR*CRTZG)
          SCOS_SAVE = SCOS
          SCOS_NEW  = SCOS
C  INCIDENT DURING STATIC LOOP?  CALL ESCAPE, AFTER UPDATE
        ELSE
          SCOS_NEW = SIGN(1.D0,VLXPAR*CRTXG+VLYPAR*CRTYG+VLZPAR*CRTZG)
        ENDIF
      ELSE
C  PARTICLE NOT ON SURFACE
        SCOS_SAVE = SCOS
        SCOS_NEW  = SCOS
      ENDIF
C
      NCOU=1
      IF (NR1P2 == 0) THEN
        NUPC(1)=0
      ELSE
        NUPC(1)=(NCELL-NRCELL-NBLCKA)/NR1P2
      END IF
C     IF (ITYP.EQ.3) THEN
        LOGION(IION,ISTRA)=.TRUE.
        ZMFP=FPATHI(NCELL,CFLAG,1,1)
C     ENDIF
C  XSTOR IN STATIC LOOP:  NOT NEEDED, BECAUSE NCOU=1
C     XSTOR2(:,:,1)=XSTOR(:,:)
C     XSTORV2(:,1)=XSTORV(:)
C  DECIDE TO FOLLOW OR NOT TO FOLLOW THIS TRACK ON BASIS OF MFP
C
C  TO BE WRITTEN
C
      CLPD(1)=ZMFP
      IF (IUPDTE.GE.1) THEN
        IFLAG=4
        CALL UPDION (XSTOR2,XSTORV2,IFLAG)
        CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
      ENDIF
      ZTC=0.
C  CARRY OUT INELASTIC COLLISION EVENT, DIRECTLY AT PLACE OF BIRTH
      IF (SCOS_SAVE.EQ.SCOS_NEW) THEN
        GOTO 230
      ELSE
C  AT THIS POINT: PARTICLE INCIDENT ON SURFACE, IC_ION GT 1 NECESSARILY
        IF (ILIIN(MSURF).GT.0) THEN
          SCOS=SCOS_NEW
          GOTO 380
        ELSE
          GOTO 230
        END IF
      ENDIF
C
C
1002  CONTINUE
C  NO STATIC APPROXIMATION, FOLLOW MOTION
C
      IF (IC_ION.GT.1.AND.NLTRC.AND.TRCHST)
     .  WRITE (iunout,*) 'TRAJECTORY LEAVES STATIC LOOP, ITYP=',ITYP
      IF (IC_ION.GT.1.AND.
     .   (NLSRFX.OR.NLSRFY.OR.NLSRFZ.OR.NLSRFA)) THEN
C  PARTICLE CONTINUES FROM SURFACE AND FROM PREVIOUS "STATIC LOOP" ?
        IC_ION=0
        IC_NEUT=0
        SCOS_NEW = SIGN(1.D0,VLXPAR*CRTXG+VLYPAR*CRTYG+VLZPAR*CRTZG)
        IF (SCOS_SAVE.NE.SCOS_NEW) THEN
          SCOS=SCOS_NEW
          ZT=0.D0
          TL=0.D0
          IPOLGN=IPOLG
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS=VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          IF (NLSRFA) THEN
            CALL ADDCOL (X0,Y0,Z0,SCOS,*101,*380)
          ELSEIF (NLSRFX) THEN
            IF (LEVGEO.LE.3) THEN
              ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
              MSURFG=NPCELL+(NTCELL-1)*NP2T3
              IF (ILIIN(NLIM+ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.4) THEN
              ISTS=ABS(INMTI(IPOLGN,MRSURF))
              MSURFG=INSPAT(IPOLGN,MRSURF)
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.5) THEN
              ISTS=ABS(INMTIT(IPOLGN,MRSURF))
C             MSURFG= ??
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.6) THEN
              ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
C             MSURFG= ??
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ENDIF
          ELSEIF (NLSRFY) THEN
            ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
            MSURFG=NRCELL+(NTCELL-1)*NR1P2
            IF (ILIIN(NLIM+ISTS) .NE. 0)
     .        CALL STDCOL (ISTS,2,SCOS,*101,*380)
          ELSEIF (NLSRFZ) THEN
            ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
            MSURFG=NRCELL+(NPCELL-1)*NR1P2
            IF (ILIIN(NLIM+ISTS) .NE. 0)
     .        CALL STDCOL (ISTS,3,SG,*101,*380)
          ENDIF
        ENDIF
      ENDIF

C**********************************************************************
C   STATIC LOOP FINISHED. REGULAR PARTICLE TRACKING CONTINUES
C**********************************************************************

      IC_ION=0
      IC_NEUT=0
C
C  PARTICLE IN VOLUME OR ON SURFACE BUT NOT FROM "STATIC LOOP"
C
C  EACH TEST ION TRACK STARTS AT THIS POINT, IC_ION=0 HERE
C
101   CONTINUE
C     IF (ITYP.EQ.3) THEN
        LOGION(IION,ISTRA)=.TRUE.
C       NLPR=   : NOT AVAILABLE
        NRC=NRCI(IION)
C     ENDIF
C  WEIGHT TOO SMALL? STOP HISTORY
      IF (WEIGHT.LT.EPS30) THEN
        LGPART=.FALSE.
        RETURN
      ENDIF
      ICOL=0
      JCOL=0
C
      ZEP1=RANF_EIRENE( )
      ZLOG=-LOG(ZEP1)
      ZINT1=0.0
      ZINT2=ZINT1
      AX(1)=1.
      AX(2)=1.
      IF (NLTRA) X01=X0+RMTOR
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C  CLEAR WORK VARIABLES AND: CONTINUE FLIGHTS THROUGH TRANSPARENT
C                            SURFACES FROM THIS POINT
104   CONTINUE
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
      NJUMP=0
      DO I=1,NIMINT
        IM=IIMINT(I)
        TIMINT(IM)=0._DP
        IIMINT(I)=0
      END DO
      NIMINT = 0
      TT=1.D30
      TL=1.D30
      TS=1.D30
      ZTST=1.D30
      ZT=0.0
C
      NCOU=1
      NUPC(1)=0
      NCOUNT(1)=1
      NCOUNP(1)=1
      ISRFCL=-1
C
C TL: DISTANCE TO NEXT ADDITIONAL SURFACE
      IF (NCELL.LE.NOPTIM) THEN
        NLI=NLIMII(NCELL)
        NLE=NLIMIE(NCELL)
      ELSE
        NLI=1
        NLE=NLIMI
      ENDIF
      IF (NLI.LE.NLE) THEN
        CALL TIMEA1 (MSURF,NCELL,NLI,NLE,NTCELL,IPERID,X0,Y0,Z0,TIME,
     .               VLXPAR,VLYPAR,VLZPAR,VELPAR,
     .               MASURF,XLI,YLI,ZLI,SG,TL,NLTRC,LCNDEXP)
C       NLPR= :NOT AVAILABLE FOR TEST IONS
        ZTST=TL
        ZDT1=TL
        CLPD(1)=ZDT1
        IF (MASURF.NE.0) ISRFCL=1
      ENDIF
C
C TT: DISTANCE UNTIL NEXT TIMESTEP LIMIT IS REACHED
C     USE VELPAR INSTEAD OF VEL, BECAUSE ORBIT IS COMPUTED WITH VELPAR
C     LATER: VELPAR --> VEL_GC
      IF (LGTIME) THEN
        TT=(DTIMVI-TIME)*VELPAR
        IF (TT.LT.ZTST) THEN
          ZTST=TT
          ZDT1=TT
          CLPD(1)=ZDT1
          ISRFCL=2
        ENDIF
      ENDIF
C
C FNUI: COLLISION FREQUENCY WITH BACKGROUND IONS.
      FNUI=1.D-30
      IF (NRC.GE.0) THEN
        DO IPL=1,NPLSI
          IPLTI=MPLSTI(IPL)
          IF (.NOT.LGVAC(NCELL,IPL))
     .    FNUI=FNUI+FNUEQI(DIIN(IPL,NCELL),TIIN(IPLTI,NCELL))
        ENDDO
      ENDIF
C TAUE: RELAXATION TIME
      TAUE=1./FNUI
C STEPSIZE=0.1*VEL_PARALLEL*TAUE, I.E. 10 COULOMB COLLISIONS PER RELAX.TIME
C TF: DISTANCE UNTIL NEXT COULOMB COLLISION
C DELFAC: INCREASE STEPSIZE AS E0 APPROACHES 1.5 * TI
      TIFAC=MAX(TVAC,TIIN(1,NCELL))
      DELFAC=1.5_DP*TIFAC/ABS(E0-1.5_DP*TIFAC+EPS60)
C  DELTA_T = TAUE*0.1*DELFAC
C  DELTA_S = DELTA_T * VELPAR  ! = TF
C     USE VELPAR INSTEAD OF VEL, BECAUSE ORBIT IS COMPUTED WITH VELPAR
C     LATER: VELPAR --> VEL_GC
      TF=TAUE*VELPAR*0.1*DELFAC

      IF (TF.LT.ZTST) THEN
        ZTST=TF
        ZDT1=TF
        CLPD(1)=ZDT1
        ISRFCL=4
      ENDIF
C
C  SCAN OVER RADIAL CELLS
C
210   CONTINUE
C
C  TS:   DISTANCE TO NEXT RADIAL SURFACE OF STANDARD MESH
C  ZDT1: DISTANCE TRAVELLED IN CURRENT RADIAL CELL
C
C  USE PARALLEL VELOCITY, I.E., COMPUTE PARALLEL DISTANCES IN GRID
C  THUS ZT,TS,ZTST,ZDT1,CLPD ETC. ARE PARALLEL DISTANCES
C
      IF (ITIME.EQ.1) THEN
        IF (LCART) THEN
          VELXS=VELX
          VELYS=VELY
          VELZS=VELZ
          VELS =VEL
          VELX=VLXPAR
          VELY=VLYPAR
          VELZ=VLZPAR
          VEL =VELPAR
          LCART=.FALSE.
        ENDIF

        IF (NLRAD) THEN
          WRITE(0,*) 'DEBUG: CALLING TIMER A'
          CALL TIMER(TS)
          WRITE(0,*) 'DEBUG: RETURN FROM TIMER A'
C
          IF (TL.LT.TS.OR.TT.LT.TS.OR.TF.LT.TS) THEN
            MRSURF=0
            IPOLGN=0
C  COLLISION WITH ADDITIONAL SURFACE
            IF (TL.LE.TT.AND.TL.LE.TF) THEN
              ZDT1=TL-ZT
              TL=ZT+ZDT1
              ZTST=TL
              ISRFCL=1
C  COLLISION WITH TIME SURFACE
            ELSEIF (TT.LT.TL.AND.TL.LE.TF) THEN
              ZDT1=TT-ZT
              TT=ZT+ZDT1
              ZTST=TT
              ISRFCL=2
C  FOKKER PLANCK COLLISION
            ELSEIF (TF.LT.TL.AND.TF.LE.TT) THEN
              ZDT1=TF-ZT
              TF=ZT+ZDT1
              ZTST=TF
              ISRFCL=4
            ENDIF
          ELSE
C  COLLISION WITH RADIAL SURFACE
            ISRFCL=0
            ZDT1=TS-ZT
            ZTST=TS
          ENDIF
        ENDIF
C
        NCOU=1
        NUPC(1)=0
        CLPD(1)=ZDT1
        NCOUNT(1)=1
        NCOUNP(1)=1
C
        IF (NLTOR.OR.NLTRA) THEN
          CALL TIMET (ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (NLPOL) THEN
          CALL TIMEP(ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (ZDT1.LE.0.D0) GOTO 990
        IF (.NOT.LCART) THEN
          VELX=VELXS
          VELY=VELYS
          VELZ=VELZS
          VEL =VELS
          LCART=.TRUE.
        ENDIF

      ENDIF
      IF (ZTST.GE.1.D30) GOTO 990
C
C  LOCAL MEAN FREE PATH
C  USE PARALLEL VELOCITY, I.E., COMPUTE PARALLEL MFP
C  BECAUSE CLPD IS THE PARALLEL DISTANCE IN EACH CELL (EXCLUD. GYRO)
C  ETC.. E.G LAMBDA(PARALLEL)=VEL(PARALLEL)/SIGV.
C  THE COLLISION FREQUENCY SIGV, HOWEVER, MUST BE COMPUTED USING THE
C  FULL TEST ION VELOCITY VECTOR, BECAUSE IT MAY DEPEND UPON THE RELATIV
C  INTERACTION ENERGY: TO BE WRITTEN
C  FOR INTERACTIONS WITH ELECTRONS THIS IS IRRELEVANT
C
      IF (IFPATH.NE.1.OR.NRC.LT.0) THEN
        XSTORV(:)=0.D0
        DO 214 J=1,NCOU
          JJ=J
          XSTOR2(:,:,J)=0.D0
          XSTORV2(:,J)=0.D0
          ZMFP=1.D10
          IF (NLPOL) NPCELL=NCOUNP(J)
          IF (NLTOR) NTCELL=NCOUNT(J)
C         VEL=VELS
          GOTO 213
214     CONTINUE
      ELSE
        IF (LCART) THEN
          VELXS=VELX
          VELYS=VELY
          VELZS=VELZ
          VELS =VEL
          VELX=VLXPAR
          VELY=VLYPAR
          VELZ=VLZPAR
          VEL =VELPAR
          LCART=.FALSE.
        ENDIF
        DO 212 J=1,NCOU
          JJ=J
          NCELL=NRCELL+NUPC(J)*NR1P2+NBLCKA
          ZMFP=FPATHI(NCELL,CFLAG,J,NCOU)
          IF (NCOU.GT.1) THEN
            XSTOR2(:,:,J)=XSTOR(:,:)
            XSTORV2(:,J)=XSTORV(:)
          ENDIF
C  UPDATE INTEGRAL
          ZINT1=ZINT1+CLPD(J)*ZMFPI
C         IF (.NOT.NLPR) THEN
CCC         IF (ZINT1.GE.ZLOG) THEN
              IF (NLPOL) NPCELL=NCOUNP(J)
              IF (NLTOR) NTCELL=NCOUNT(J)
              VELX=VELXS
              VELY=VELYS
              VELZ=VELZS
              VEL =VELS
              LCART=.TRUE.
              GOTO 213
CCC         ENDIF
C  THESE NEXT TWO LINES CAN NEVER BE REACHED, BECAUSE ONLY ONE
C  CELL FOR EACH TRACK OF IONS (DISTINCT FROM FOLNEUT).
C  THEN (AT THE LATEST): ROTATION OF VELOCITY DUE TO NEW B-FIELD
C           ZINT2=ZINT1
C           ZT=ZT+CLPD(J)
C         ELSEIF (JCOL.EQ.0) THEN
C   CONDITIONAL EXPECTATION ESTIMATOR FOR TEST IONS: TO BE WRITTEN
C         ENDIF
212     CONTINUE
        VELX=VELXS
        VELY=VELYS
        VELZ=VELZS
        VEL =VELS
        LCART=.TRUE.
      ENDIF
C
213   CONTINUE
      NCOUS=NCOU
      NCOU=JJ

CCC  IF NO COLLISION, THEN: ENFORCE ONLY ONE STEP AT A TIME
      IF (ZINT1.LT.ZLOG.AND.NCOUS.GT.1) THEN
        MRSURF=0
        MPSURF=0
        MTSURF=0
        MASURF=0
        ISRFCL=0
        NINCX=0
        NINCY=0
        NINCZ=0
      ENDIF
CCC
C
C  CHECK FOR EVENT
C
C     IF (NLPR)    ......
      IF (ZINT1.GE.ZLOG) GO TO 220
C
      ZINT2=ZINT1
      ZT=ZTST
C
C  RESET CLPD TO REAL PATH LENGTH OF GYRO MOTION
      DO 217 ICOU=1,NCOU
        CLPD(ICOU)=CLPD(ICOU)*VEL/VELPAR
217   CONTINUE
C
C  UPDATE CONTRIBUTION TO VOLUME AVERAGED ESTIMATORS
C
      IF (IUPDTE.GE.1) THEN
        CALL UPDION(XSTOR2,XSTORV2,3)
        CALL CALC_SPECTRUM (WEIGHT,3,1)
      ENDIF
C
C  STOP TRACK ?
C
CDR: ALLE DISTANZEN IN ...COL routines sind parallele distanzen
CDR: Daher auch wg. x = x + dist/vel  parallele geschwindigkeiten.
      IF (LCART) THEN
        VELXS=VELX
        VELYS=VELY
        VELZS=VELZ
        VELS =VEL
        VELX=VLXPAR
        VELY=VLYPAR
        VELZ=VLZPAR
        VEL =VELPAR
        LCART=.FALSE.
      ENDIF
      IF (ISRFCL.EQ.1) CALL ADDCOL(XLI,YLI,ZLI,SG,*104,*380)
      IF (ISRFCL.EQ.2) CALL TIMCOL(AX(2),         *104,*800)
      IF (ISRFCL.EQ.3) CALL TORCOL(               *104)
      IF (ISRFCL.EQ.4) CALL FPKCOL(               *104,*100)
      VELX=VELXS
      VELY=VELYS
      VELZ=VELZS
      VEL =VELS
      LCART=.TRUE.
C
C  NO, CONTINUE TRACK
C
216   CONTINUE
C
C  NEXT CELL - CHECK FOR ESCAPE OR NON DEFAULT ACTING STANDARD SURFACE
C
      IF (LEVGEO.LE.3) THEN
C
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=NPCELL+(NTCELL-1)*NP2T3
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
        ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
        IF (NLTOR.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCZ)
          NLSRFZ=.TRUE.
          MSURFG=NRCELL+(NPCELL-1)*NR1P2
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,3,SG,*104,*380)
        ENDIF
        ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
        IF (NLPOL.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCY)
          NLSRFY=.TRUE.
          MSURFG=NRCELL+(NTCELL-1)*NR1P2
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,2,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.4) THEN
        ISTS=ABS(INMTI(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
!pb          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=INSPAT(IPOLGN,MRSURF)
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          SG=SIGN(1._DP,VELX*PTRIX(IPOLGN,MRSURF)+
     .                  VELY*PTRIY(IPOLGN,MRSURF))
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.5) THEN
        ISTS=ABS(INMTIT(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
!pb          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          SG=SIGN(1._DP,VELX*PTETX(IPOLGN,MRSURF)+
     .                  VELY*PTETY(IPOLGN,MRSURF)+
     .                  VELZ*PTETZ(IPOLGN,MRSURF))
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.6) THEN
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          IF (LCART) THEN
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            VELS =VEL
            VELX=VLXPAR
            VELY=VLYPAR
            VELZ=VLZPAR
            VEL =VELPAR
            LCART=.FALSE.
          ENDIF
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
      ENDIF
C
C
      NRCELL=NRCELL+NINCX
      IF (NRCELL.GT.NR1STM.OR.NRCELL.LT.1) GOTO 990
C
CDR: SPLITTING AND COND.EXP.EST. NOT AVAILABLE FOR TEST IONS
C
C  CHECK IF WE HAVE ENCOUNTERED A SPLITTING ZONE
C     IF (NLSPLT(MRSURF).AND.NLEVEL.LT.MAXLEV.AND.ICOL.EQ.0) GOTO 330
C
C  SWITCH OFF CONDITIONAL EXP. ESTIMATOR ?
C     IF (AX(2).LT.WMINC) THEN
C       IF (ICOL.EQ.1) GOTO 512
C  NO COLLISION YET; RESTART AGAIN WITH COND. EXP. ESTIMATOR
C                    IN NEW CELL
C       AX(1)=1.
C       AX(2)=1.
C       JCOL=0
C     ENDIF
CCC
      ZTC=CLPD(1)*VELPAR/VEL
      GOTO 2211
CCC
CCC   GOTO 210
C
C  POINT OF COLLISION  220---240
C
220   CONTINUE
C
      CLPD(NCOU)=(ZLOG-ZINT2)*ZMFP
      ZTC=ZT+CLPD(NCOU)
C  RESET CLPD TO REAL PATH LENGTH OF GYRO MOTION
      DO 221 ICOU=1,NCOU
        CLPD(ICOU)=CLPD(ICOU)*VEL/VELPAR
221   CONTINUE
      IF (IUPDTE.GE.1) THEN
        CALL UPDION (XSTOR2,XSTORV2,4)
        CALL CALC_SPECTRUM (WEIGHT,4,1)
      ENDIF
2211  continue
      X0=X0+VLXPAR*ZTC
      Y0=Y0+VLYPAR*ZTC
      Z0=Z0+VLZPAR*ZTC
      TIME=TIME+ZTC/VELPAR
      IF (LEVGEO.LE.3.AND.NLPOL) THEN
        IPOLG=NPCELL
      ELSEIF (NLPLG) THEN
        IPOLG=LEARC2(X0,Y0,NRCELL,NPANU,'FOLION 2     ')
      ELSEIF (NLFEM) THEN
        IPOLG=0
      ELSEIF (NLTET) THEN
        IPOLG=0
      ENDIF
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      NLSRFA=.FALSE.
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      MSURF=0
      IF (NLTRA) PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
C
CCC
      IF (ZINT1.LT.ZLOG) THEN
C  DELTA EVENT AT CELL BOUNDARY
        IF (NINCX.NE.0) THEN
          NLSRFX=.TRUE.
          IF (LEVGEO < 4) THEN
            MRSURF=NRCELL
            IF (NINCX.EQ.-1) MRSURF=NRCELL+1
          ELSEIF (LEVGEO == 4) THEN
            NRCOLD=NRCELL-NINCX
            MRSURF=NCHBAR(IPOLGN,NRCOLD)
            IPOLG=NSEITE(IPOLGN,NRCOLD)
          ELSEIF (LEVGEO == 5) THEN
            NRCOLD=NRCELL-NINCX
            MRSURF=NTBAR(IPOLGN,NRCOLD)
            IPOLG=NTSEITE(IPOLGN,NRCOLD)
          ELSE
            WRITE (iunout,*) 'DELTA EVENT AT CELL BOUNDARY NOT READY '
            WRITE (iunout,*) 'FOR LEVGEO=6 IN SUBR. FOLION. '
            CALL EXIT_OWN(1)
          END IF
        ELSEIF (NINCZ.NE.0) THEN
          NLSRFZ=.TRUE.
          NTCELL=KUPC(1)+NINCZ
          IF (NINCZ == 1) THEN
            MTSURF=NTCELL
          ELSEIF (NINCZ.EQ.-1) THEN
            MTSURF=NTCELL+1
          ENDIF
        ELSEIF (NINCY.NE.0) THEN
          NLSRFY=.TRUE.
          IF (LEVGEO.EQ.1) THEN
            NPCELL=JUPC(1)+NINCY
            IF (NINCY == 1) THEN
              MPSURF=NPCELL
            ELSEIF (NINCY.EQ.-1) THEN
              MPSURF=NPCELL+1
            ENDIF
          ELSEIF (LEVGEO.LE.3) THEN
            MPSURF=LUPC(1)
            IF (MUPC(1).EQ.1) NPCELL=NGHPLS(2,NRCELL,MPSURF)
            IF (MUPC(1).NE.1) NPCELL=NGHPLS(4,NRCELL,MPSURF)
C  PERIODICITY FOR LEVGEO=2 (TO BE WRITTEN INTO MORE GENERAL TERMS)
            IF (NPCELL.EQ.0.AND.LEVGEO.EQ.2) THEN
              WRITE (iunout,*) 'should not be here '
              MPSURF=NP2ND
              NPCELL=NP2NDM
            ELSEIF (NPCELL.EQ.NP2ND.AND.LEVGEO.EQ.2) THEN
              WRITE (iunout,*) 'should not be here '
              MPSURF=1
              NPCELL=1
            ENDIF
            IF (LEVGEO.LE.3.AND.NLPOL) THEN
              IPOLG=NPCELL
            ELSEIF (LEVGEO.EQ.3.AND..NOT.NLPOL) THEN
              IPOLG=LEARC2(X0,Y0,NRCELL,NPANU,'FOLION neu   ')
            ENDIF
          ENDIF
        ELSE
          GOTO 994
        ENDIF
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,8)
        NUPC(1)=NPCELL-1+(NTCELL-1)*NP2T3
        NCELL=NRCELL+NUPC(1)*NR1P2+NBLCKA
C  DELTA COLLISION AT SURFACE DONE, NEW CELL FOUND
C  FIND NEW B-FIELD 
        CALL NEWFIELD(X0,Y0,Z0)
C  FIND NEW MAGNETIC FIELD
c       IF (INDPRO(5) == 8) THEN
c         CALL VECUSR(1,BBX,BBY,BBZ,1)
c       ELSE
c         BBX=BXIN(NCELL)
c         BBY=BYIN(NCELL)
c         BBZ=BZIN(NCELL)
c       END IF
c       BVEC = (/ BBX, BBY, BBZ /)
C  RETAIN VEL, V_PARALLEL, V_PERP, SIGPAR, 
C  SAMPLE PHASE, AND FIND NEW CARTESIAN VX,VY,VZ (SAME VEL=VELS)
c       VLXPAR=SIGPAR*BBX
c       VLYPAR=SIGPAR*BBY
c       VLZPAR=SIGPAR*BBZ
c       VELPAR=ABS(VELS*VCOS)*(1.D0-EPS12)
c       E0PAR=CVRSSI(IION)*VELPAR*VELPAR
c       VELPER = SQRT(VELS**2 - VELPAR**2)
C  NEW GYRO PHASE
c       GYRO=RANF_EIRENE()*PI2A
C  BACK TO CARTESIAN COORDIANTES
c       CALL B_PROJI (BVEC,BVEC_1,VVEC,SIGPAR*VELPAR,VELPER,GYRO)
c       VELX = VVEC(1)
c       VELY = VVEC(2)
c       VELZ = VVEC(3)
c       VEL=VELS
c       LCART=.TRUE.
        ICO = 0
        GOTO 1004
      ENDIF
CCC
C
230   CONTINUE
C
C  PRE COLLISION ESTIMATOR
C
      IF (NCLVI.GT.0) THEN
        WS=WEIGHT/SIGTOT
        CALL UPCUSR(WS,1)
        CALL CALC_SPECTRUM (WS,1,1)
      ENDIF
C
C
C  TEST FOR CORRECT CELL NUMBER AT COLLISION POINT
C  KILL PARTICLE, IF TOO LARGE ROUND OFF ERRORS DURING
C  PARTICLE TRACING
C
      IF (NLTEST) CALL CLLTST(*997)
C
C  SAMPLE FROM COLLISION KERNEL FOR TEST IONS
C  FIND NEW WEIGHT, SPECIES INDEX, VELOCITY AND RETURN
C
      CALL COLION(CFLAG,COLTYP,DIST)
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
C  POST COLLISION ESTIMATOR
C
      IF (NCLVI.GT.0) THEN
        WS=WEIGHT/SIGTOT
        CALL UPCUSR(WS,2)
        CALL CALC_SPECTRUM (WS,2,1)
      ENDIF
C
      IF (COLTYP.EQ.2.) GOTO 700
C
      GOTO 100
C
C  SIMULATION OF COLLISION EVENT FINISHED
C
C
C
C   INCIDENT ONTO SURFACE
C
380   CONTINUE
      WRITE(0,*) 'DEBUG: LEV.EQ.5 4.00 at 380'
C
C   REFLECTION FROM  SURFACE
C   USE PARALLEL VELOCITY, BECAUSE GYROMOTION WAS NOT CONSIDERED
C   IN FINDING THE INTERSECTION WITH THIS SURFACE. THE GYRO-PHASE
C   IS NOT KNOWN EITHER. AND A WRONG PHASE MAY LEAD TO A NEGATIVE "COSIN".
C
      IF (.NOT.LCART) THEN
        ICOUN=0
        DO
          CALL NEWFIELD(X0,Y0,Z0)
          COSIN=VELX*CRTX+VELY*CRTY+VELZ*CRTZ
          IF (COSIN.GT.0.) EXIT
          ICOUN=ICOUN+1
          IF (ICOUN.EQ.100) THEN
            WRITE (IUNOUT,*) 'PARTICLE KILLED AT SURFACE IN FOLION'
            LGPART=.FALSE.
            WEIGHT=0.
            RETURN
          ENDIF
        ENDDO
C       VELXS=VELX
C       VELYS=VELY
C       VELZS=VELZ
C       VELS =VEL
C       VELX=VLXPAR
C       VELY=VLYPAR
C       VELZ=VLZPAR
C       VEL =VELPAR
C       LCART=.FALSE.
      ENDIF
C
C  UPDATE EFFLUXES ONTO SURFACE AND REFLECT PARTICLE
      PR=1.
      IF (ILIIN(MSURF).LE.-2) PR=SG
C
C  FOR NONTRANSPARENT SURFACES:
C  ACCELERATION IN SHEATH IS DONE IN SUBR. ESCAPE
C
      CALL ESCAPE(PR,SG,*100,*104,*996)
      RETURN
C
C   100: START NEW ION TRACK
C   104: CONTINUE THIS TRACK, TRANSPARENT SURFACE IS CROSSED
C
C
700   CONTINUE
C  REGULAR STOP IN SUBR. FOLION, CONTINUE IN SUBR. MCARLO
      RETURN
C
800   CONTINUE
C  REGULAR STOP IN SUBR. FOLION, STOP HISTORY, CENSUS ARRAY FULL
C     IF (ICOL.EQ.1.AND..NOT.LGLAST) GOTO 512
      LGPART=.FALSE.
      WEIGHT=0.
      RETURN
C
990   CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLION,  ZDT1 OR NRCELL OUT OF RANGE  ')
      CALL MASAGE ('PARTICLE IS KILLED                            ')
      WRITE (iunout,*) 'NPANU,NRCELL,ZDT1,ZTST ',NPANU,NRCELL,ZDT1,ZTST
      WRITE (iunout,*) 'TL,TS,ZINT1,ZLOG ',TL,TS,ZINT1,ZLOG
      GOTO 995
991   CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLION,  NCELL OUT OF RANGE            ')
      CALL MASAGE ('PARTICLE IS KILLED                            ')
      WRITE (iunout,*) 'NPANU,NCELL,NRCELL,NPCELL,NTCELL '
      WRITE (iunout,*)  NPANU,NCELL,NRCELL,NPCELL,NTCELL
      GOTO 995
992   CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLION,  PROJECTION TO V_PAR, V_PERP   ')
      CALL MASAGE ('PROBABLY ILL DEFINED B-FIELD WRT. PARTICLE SPEED')              ')
      WRITE (iunout,*) 'BBX,BBY,BBZ ',BBX,BBY,BBZ
      ZT=0.
      GOTO 9951
9921  CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLION,  LCART HAS WRONG VALUE       ')
      WRITE (iunout,*) 'npanu,lcart ',npanu,lcart
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,18)
      GOTO 999
993   CALL MASAGE ('ERROR IN FOLION,  NO PARTICLE TRACING BUT     ')
      CALL MASAGE ('IFPATH.NE.1. PARTICLE IS KILLED               ')
      WRITE (iunout,*) 'IION ',IION
      GOTO 999
C
994   CALL MASAGE ('ERROR IN FOLION,  AT SURFACE DELTA EVENT      ')
      WRITE (iunout,*) 'IION,NPANU ',IION,NPANU
      GOTO 999
C
995   WRITE (iunout,*) 'MRSURF,MPSURF,MTSURF,MASURF ',
     .                  MRSURF,MPSURF,MTSURF,MASURF
9951  X0ERR=X0+ZT*VELX
      Y0ERR=Y0+ZT*VELY
      Z0ERR=Z0+ZT*VELZ
      IF (NLTRC) THEN
        CALL CHCTRC(X0ERR,Y0ERR,Z0ERR,16,18)
      ELSE
        WRITE (iunout,*) 'X0,Y0,Z0,ZT ',X0,Y0,Z0,ZT
        WRITE (iunout,*) 'VELX,VELY,VELZ ',VELX,VELY,VELZ
        WRITE (iunout,*) 'X0ERR,Y0ERR,Z0ERR ',X0ERR,Y0ERR,Z0ERR
      ENDIF
      GOTO 999
996   CALL MASAGE ('ERROR IN FOLION, COND. EXP. ESTIM. NOT IN USE ')
      GOTO 999
997   CALL MASAGE ('ERROR IN FOLION,  DETECTED IN SUBR. CLLTST    ')
      CALL MASAGE ('PARTICLE IS KILLED                            ')
C   DETAILED PRINTOUT ALREADY DONE FROM SUBR. CLLTST
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,18)
      GOTO 999
998   WRITE (iunout,*) 'ERROR IN FOLION, SPECIES INDEX OUT OF RANGE '
      WRITE (iunout,*) ' NPANU,IION ',NPANU,IION
      GOTO 999
C
999   PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
      ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
      LGPART=.FALSE.
      WEIGHT=0.
      CALL LEER(1)
      RETURN
      END

      SUBROUTINE NEWFIELD(X,Y,Z)
C  FIND NEW MAGNETIC FIELD AT NEW POINT X,Y,Z IN CELL NCELL
C  RETAIN V_PARALLEL, V_PERP, BUT PROVIDE NEW CARTESIAN VELOCITY
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CFPLK
      USE COMPRT
      USE CRAND
      USE CINIT
      IMPLICIT NONE
      REAL(DP), EXTERNAL :: RANF_EIRENE
      REAL(DP), INTENT(IN) :: X,Y,Z
      REAL(DP) :: BVEC_1(3), VVEC(3), GYRO

      IF (INDPRO(5) == 8) THEN
        CALL VECUSR(1,BBX,BBY,BBZ,1)
      ELSE
        BBX=BXIN(NCELL)
        BBY=BYIN(NCELL)
        BBZ=BZIN(NCELL)
      END IF
      BVEC = (/ BBX, BBY, BBZ /)
C  RETAIN VEL, V_PARALLEL, V_PERP, SIGPAR, 
C  SAMPLE PHASE, AND FIND NEW CARTESIAN VELX,VELY,VELZ (SAME VEL=VELS)
      VLXPAR=SIGPAR*BBX
      VLYPAR=SIGPAR*BBY
      VLZPAR=SIGPAR*BBZ
C  NEW GYRO PHASE
      GYRO=RANF_EIRENE()*PI2A
C  BACK TO CARTESIAN COORDIANTES
      CALL B_PROJI (BVEC,BVEC_1,VVEC,SIGPAR*VELPAR,VELPER,GYRO)
      VELX = VVEC(1)
      VELY = VVEC(2)
      VELZ = VVEC(3)
!     VEL  = VELS
      LCART=.TRUE.
      RETURN
      END
C ===== SOURCE: folneut.f
C
!PB 12.01.06: calls to calc_spectrum introduced for cell based spectra
!PB 02.03.06: Store trajectory from birth place to first collision with the
!             wall. It is assumed that conditional epectation estimator is
!             switched on.
!PB 18.04.06: xstorv=0 in "vacuum region" added
!PB 26.09.06: sg corrected for levgeo=4 and levgeo=5

C  MAY05: CALL UPDATE FROM STATIC LOOP WITH IFLAG=4 (RATHER =1)
C         WG. COLL EST. ON 1ST FLIGHT AFTER BIRTH.
C
      SUBROUTINE FOLNEUT
C
C     NEUTRAL PARTICLE, LAUNCHED AT X0,Y0,Z0, IN CELL NRCELL, IPOLG,
C     IPERID, NPCELL, NTCELL, NACELL, NBLOCK, IS FOLLOWED
C
C  ON INPUT
C     ITYP=0 OR ITYP=1 OR ITYP=2
C
C  ON OUTPUT:
C
C     LGPART=TRUE
C     ITYP=3            A NEXT GENERATION TEST ION IS BORN
C                          IION= SPECIES INDEX OF NEXT GENERATION ION
C     LGPART=FALSE
C     ITYP=4  NO NEXT GENERATION TEST PARTICLE
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CRAND
      USE CUPD
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CTETRA
      USE COMPRT
      USE CPES
      USE COMNNL
      USE COMSPL
      USE CLGIN
      USE COUTAU
      USE COMXS
      USE CTRIG
      USE CTRCEI

      IMPLICIT NONE

      REAL(DP) :: CFLAG(7,3)
      REAL(DP) :: AX(2)
      REAL(DP) :: XSTOR2(MSTOR1,MSTOR2,N2ND+N3RD),
     .            XSTORV2(NSTORV,N2ND+N3RD)
      REAL(DP) :: XSTORC(MSTOR1,MSTOR2), XSTORVC(NSTORV)
      REAL(DP) :: VELXC, TIMEC, PR, WS, COLTYP, X0C, Y0C, Z0C, ZDT1C,
     .          X0ERR, Y0ERR, Z0ERR, VELC, E0C, VELYC, VELZC, SG,
     .          GENRC, PHIC, WEIGHC, ZLI, DG, XLI, YLI, T, ZTS,
     .          ZMFP, ZEP1, ZLOG, ZTST, ZINT1, ZINT2, Z0S, TIMES,
     .          X0S, Y0S, PHIS, DIST, ZTC, PSAVE, TSAVE, FPATHM, FPATHA,
     .          EX, EXPM, FPATHPH, WMINC_LOCAL,
     .          SCOS_NEW
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: NBLCKC, NCELLC, NRCLLC, NACLLC, ITIMEC, IPERIDC,
     .           IFPTHC, IUPDTC, NPCLLC, NTCLLC, NTSAVE, NPSAVE,
     .           LEARC2, J, NCOUS, NLE, NRC, JCOL, NLI, ISTS, NPCOLC,
     .           JJ, NPCELC, NTCELC, NTCOLC, IFLAG, I1, I2, I3, I, IM
      LOGICAL :: NLPR, LTRANS, LCNDEXP
      TYPE(CELL_INFO), POINTER :: NEW_CELL
C
C  TENTATIVELY ASSUME: A NEXT GENERATION PARTICLE WILL BE BORN
C
C  IC_NEUT, IC_ION: COUNTER FOR GENERATIONS WITHIN STATIC LOOP
      IC_NEUT=IC_ION
100   LGPART=.TRUE.
      IC_NEUT=IC_NEUT+1
      XGENER=0
      NLPR=.FALSE.
      AX(1)=1.
      AX(2)=1.
      WMINC_LOCAL=WMINC
      IF (ITYP.EQ.0) THEN
        IF (IPHOT.LE.0.OR.IPHOT.GT.NPHOTI) GOTO 998
      ELSEIF (ITYP.EQ.1) THEN
        IF (IATM.LE.0.OR.IATM.GT.NATMI) GOTO 998
      ELSEIF (ITYP.EQ.2) THEN
        IF (IMOL.LE.0.OR.IMOL.GT.NMOLI) GOTO 998
      ENDIF
C
C  THE  CELL NUMBER NRCELL, IPOLG, IPERID, NPCELL, NTCELL, NACELL, NBLOCK
C  WAS ALREADY SET IN CALLING SUBROUTINE MCARLO
C
C  IF NLSRFX, SURFACE INDEX MRSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFY, SURFACE INDEX MPSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFZ, SURFACE INDEX MTSURF MUST BE DEFINED AT THIS POINT
C  IF NLSRFA, SURFACE INDEX MASURF MUST BE DEFINED AT THIS POINT
C
C  FOLLOW MOTION OF NEUTRAL PARTICLE OR "STATIC APPROXIMATION"?
      IF (IFPATH.NE.1) GOTO 1002
      IF (ITYP.EQ.1) THEN
        IF (NFOLA(IATM).EQ.-1) GOTO 1001
      ELSEIF (ITYP.EQ.2) THEN
        IF (NFOLM(IMOL).EQ.-1) GOTO 1001
      ELSEIF (ITYP.EQ.0) THEN
        IF (NFOLPH(IPHOT).EQ.-1) GOTO 1001
      ENDIF
      GOTO 1002
C
1001  CONTINUE
      IF (IC_NEUT.EQ.1.AND.NLTRC.AND.TRCHST)
     .  WRITE (iunout,*) 'TRAJECTORY ENTERS STATIC LOOP, ITYP=', ITYP

C***********************************************************************
C  STATIC APPROXIMATION
C  SIMULATE NEXT COLLISION INSTANTANEOUSLY
C***********************************************************************

C  WEIGHT TOO SMALL? STOP HISTORY
        IF (WEIGHT.LT.EPS30) THEN
          LGPART=.FALSE.
          RETURN
        ENDIF
C
C  PARTICLE ON SURFACE ?
        IF (NLSRFX.OR.NLSRFY.OR.NLSRFZ.OR.NLSRFA) THEN
C  EMITTED  ?  CALL COLLIDE, AFTER UPDATE
          IF (IC_NEUT.EQ.1) THEN
C  FIRST ENTRY INTO "STATIC LOOP", ALWAYS: EMITTED FROM FROM SURFACE
C    (CRTXG,....,...): NORMAL RELATIVE TO DEFAULT SETTINGS
C                      NEEDED LATER IF PARTICLE LEAVES STATIC LOOP
C                      VIA STDCOL OR ADDCOL
            CRTXG=CRTX*SCOS
            CRTYG=CRTY*SCOS
            CRTZG=CRTZ*SCOS
            SCOS = SIGN(1.D0,VELX*CRTXG+VELY*CRTYG+VELZ*CRTZG)
            SCOS_SAVE = SCOS
            SCOS_NEW  = SCOS
C  INCIDENT OR EMITTED DURING STATIC LOOP?
C  CALL ESCAPE OR CALL COLLIDE, AFTER UPDATE
          ELSE
            SCOS_NEW = SIGN(1.D0,VELX*CRTXG+VELY*CRTYG+VELZ*CRTZG)
          ENDIF
        ELSE
C  PARTICLE NOT ON SURFACE
          SCOS_SAVE = SCOS
          SCOS_NEW  = SCOS
        ENDIF
C
        NCOU=1
        NUPC(1)=(NCELL-NRCELL-NBLCKA)/NR1P2
        IF (IFPATH.NE.1) GOTO 993
        IF (ITYP.EQ.0) THEN
          LOGPHOT(IPHOT,ISTRA)=.TRUE.
          ZMFP=FPATHPH(NCELL,CFLAG,1,1)
        ELSEIF (ITYP.EQ.1) THEN
          LOGATM(IATM,ISTRA)=.TRUE.
          ZMFP=FPATHA(NCELL,CFLAG,1,1)
        ELSEIF (ITYP.EQ.2) THEN
          LOGMOL(IMOL,ISTRA)=.TRUE.
          ZMFP=FPATHM(NCELL,CFLAG,1,1)
        ENDIF
C  XSTOR IN STATIC LOOP:  NOT NEEDED, BECAUSE NCOU=1
C       XSTOR2(:,:,1)=XSTOR(:,:)
C       XSTORV2(:,1) =XSTORV(:)
C  DECIDE TO FOLLOW OR NOT TO FOLLOW THIS TRACK ON BASIS OF MFP
C
C  TO BE WRITTEN
C
        CLPD(1)=ZMFP
        IF (IUPDTE.EQ.1) THEN
          IFLAG=4
          IF (ITYP.EQ.0) THEN
            CALL UPDPHOT(XSTOR2,XSTORV2,IFLAG)
          ELSEIF (ITYP.EQ.1) THEN
            CALL UPDATM (XSTOR2,XSTORV2,IFLAG)
          ELSEIF (ITYP.EQ.2) THEN
            CALL UPDMOL (XSTOR2,XSTORV2,IFLAG)
          ENDIF
          IF (NADSPC >= 1) CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
        ENDIF
        ZTC=0.
C  CARRY OUT INELASTIC COLLISION EVENT, DIRECTLY AT PLACE OF BIRTH
        IF (SCOS_SAVE.EQ.SCOS_NEW) THEN
          GOTO 230
        ELSE
C  AT THIS POINT: PARTICLE INCIDENT ON SURFACE, IC_NEUT GT 1 NECESSARILY
          IF (ILIIN(MSURF).GT.0) THEN
            SCOS=SCOS_NEW
            GOTO 380
          ELSE
            GOTO 230
          END IF
        ENDIF
C
C
1002  CONTINUE
C  NO STATIC APPROXIMATION, FOLLOW MOTION
C
      IF (IC_NEUT.GT.1.AND.NLTRC.AND.TRCHST)
     .  WRITE (iunout,*) 'TRAJECTORY LEAVES STATIC LOOP, ITYP=',ITYP
      IF (IC_NEUT.GT.1.AND.
     .   (NLSRFX.OR.NLSRFY.OR.NLSRFZ.OR.NLSRFA)) THEN
C  PARTICLE CONTINUES FROM SURFACE AND FROM PREVIOUS "STATIC LOOP" ?
        IC_ION=0
        IC_NEUT=0
        SCOS_NEW = SIGN(1.D0,VELX*CRTXG+VELY*CRTYG+VELZ*CRTZG)
        IF (SCOS_SAVE.NE.SCOS_NEW) THEN
          SCOS=SCOS_NEW
          ZT=0.D0
          TL=0.D0
          IPOLGN=IPOLG
          IF (NLSRFA) THEN
            CALL ADDCOL (X0,Y0,Z0,SCOS,*101,*380)
          ELSEIF (NLSRFX) THEN
            IF (LEVGEO.LE.3) THEN
              ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
              MSURFG=NPCELL+(NTCELL-1)*NP2T3
              IF (ILIIN(NLIM+ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.4) THEN
              ISTS=ABS(INMTI(IPOLGN,MRSURF))
              MSURFG=INSPAT(IPOLGN,MRSURF)
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.5) THEN
              ISTS=ABS(INMTIT(IPOLGN,MRSURF))
C             MSURFG= ??
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ELSEIF (LEVGEO.EQ.6) THEN
              ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
C             MSURFG= ??
              IF (ILIIN(ISTS) .NE. 0)
     .          CALL STDCOL (ISTS,1,SCOS,*101,*380)
            ENDIF
          ELSEIF (NLSRFY) THEN
            ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
            MSURFG=NRCELL+(NTCELL-1)*NR1P2
            IF (ILIIN(NLIM+ISTS) .NE. 0)
     .        CALL STDCOL (ISTS,2,SCOS,*101,*380)
          ELSEIF (NLSRFZ) THEN
            ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
            MSURFG=NRCELL+(NPCELL-1)*NR1P2
            IF (ILIIN(NLIM+ISTS) .NE. 0)
     .        CALL STDCOL (ISTS,3,SG,*101,*380)
          ENDIF
        ENDIF
      ENDIF

C**********************************************************************
C   STATIC LOOP FINISHED. REGULAR PARTICLE TRACKING CONTINUES
C**********************************************************************

      IC_ION=0
      IC_NEUT=0
C
C  PARTICLE IN VOLUME OR ON SURFACE BUT NOT FROM "STATIC LOOP"
C
C  EACH NEUTRAL PARTICLE TRACK STARTS AT THIS POINT, IC_NEUT=0 HERE
C
101   CONTINUE
      IF (ITYP.EQ.1) THEN
        LOGATM(IATM,ISTRA)=.TRUE.
        NLPR=NLPRCA(IATM)
        NRC=NRCA(IATM)
      ELSEIF (ITYP.EQ.2) THEN
        LOGMOL(IMOL,ISTRA)=.TRUE.
        NLPR=NLPRCM(IMOL)
        NRC=NRCM(IMOL)
      ELSEIF (ITYP.EQ.0) then
        LOGPHOT(IPHOT,ISTRA)=.TRUE.
        NLPR=NLPRCPH(IPHOT)
        NRC=NRCPH(IPHOT)
      ENDIF
      IF (NLTRJ .AND. .NOT.NLPR) THEN
        WRITE (IUNOUT,*) ' STORING OF TRAJECTORIES SWITCHED OFF',
     .           ' BECAUSE NO CONDITIONAL EXPECTATION ESTIMATOR'
        NLTRJ = .FALSE.
      END IF
C  WEIGHT TOO SMALL? STOP HISTORY
      IF (WEIGHT.LT.EPS30) THEN
        LGPART=.FALSE.
        RETURN
      ENDIF
      ICOL=0
      JCOL=0
C
      ZEP1=RANF_EIRENE( )
      ZLOG=-LOG(ZEP1)
      ZINT1=0.0
      ZINT2=ZINT1
      IF (NLTRA) X01=X0+RMTOR
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C
C  CLEAR WORK VARIABLES AND: CONTINUE FLIGHTS THROUGH TRANSPARENT
C                            SURFACES FROM THIS POINT
104   CONTINUE
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
      NJUMP=0
      DO I=1,NIMINT
        IM=IIMINT(I)
        TIMINT(IM)=0._DP
        IIMINT(I)=0
      END DO
      NIMINT = 0
      PHIS=0
      TT=1.D30
      TL=1.D30
      TS=1.D30
      ZTST=1.D30
      ZT=0.0
C
      NCOU=1
      NUPC(1)=0
      NCOUNT(1)=1
      NCOUNP(1)=1
      ISRFCL=-1
C
C TL: DISTANCE TO NEXT ADDITIONAL SURFACE
      IF (NCELL.LE.NOPTIM) THEN
        NLI=NLIMII(NCELL)
        NLE=NLIMIE(NCELL)
      ELSE
        NLI=1
        NLE=NLIMI
      ENDIF
      IF (NLI.LE.NLE) THEN
        CALL TIMEA1 (MSURF,NCELL,NLI,NLE,NTCELL,IPERID,X0,Y0,Z0,TIME,
     .               VELX,VELY,VELZ,VEL,
     .               MASURF,XLI,YLI,ZLI,SG,TL,NLTRC,LCNDEXP)
!pb     NLPR=NLPRCS(MASURF).OR.NLPR
        NLPR=LCNDEXP.OR.NLPR
        ZDT1=TL
        ZTST=TL
        CLPD(1)=ZDT1
        IF (MASURF.NE.0) ISRFCL=1
      ENDIF
C
C TT: DISTANCE UNTIL NEXT TIMESTEP LIMIT IS REACHED
      IF (LGTIME) THEN
        TT=(DTIMVI-TIME)*VEL
        IF (TT.LT.TL) THEN
          ZDT1=TT
          ZTST=TT
          CLPD(1)=ZDT1
          ISRFCL=2
        ENDIF
      ENDIF
C
C  SCAN OVER SEGMENT
C
210   CONTINUE
C
C  TS:   DISTANCE TO NEXT SURFACE OF STANDARD MESH
C  ZDT1: DISTANCE TRAVELLED IN CURRENT RADIAL CELL
C  ZT: DISTANCE ALREADY TRAVELLED IN PREVIOUS PARTS OF THIS TRACK
C
      IF (ITIME.EQ.1) THEN
        IF (NLRAD) THEN
          WRITE(0,*) 'DEBUG: CALLING TIMER B'
          CALL TIMER(TS)
          WRITE(0,*) 'DEBUG: RETURN FROM TIMER B'
C
          T=TS/TL-1.0_DP
          WRITE(0,*) 'DEBUG: TIMER B 1.00',t
          IF (ABS(T).LE.EPS10.AND.TL.NE.1.E30_DP) GOTO 992
          IF (TL.LT.TS.OR.TT.LT.TS) THEN
            MRSURF=0
            IPOLGN=0
C  COLLISION WITH ADDITIONAL SURFACE
            IF (TL.LE.TT) THEN
              ZDT1=TL-ZT
              TL=ZT+ZDT1
              ZTST=TL
              ISRFCL=1
C  COLLISION WITH TIME SURFACE
            ELSEIF (TT.LT.TL) THEN
              ZDT1=TT-ZT
              TT=ZT+ZDT1
              ZTST=TT
              ISRFCL=2
            ENDIF
          ELSE
C  COLLISION WITH RADIAL SURFACE
            ISRFCL=0
            ZDT1=TS-ZT
            ZTST=TS
          ENDIF
        ENDIF
        WRITE(0,*) 'DEBUG: TIMER B 2.00'
C
        NCOU=1
        NUPC(1)=0
        CLPD(1)=ZDT1
        NCOUNT(1)=1
        NCOUNP(1)=1
C
        IF (NLTOR.OR.NLTRA) THEN
          CALL TIMET (ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        IF (NLPOL) THEN
          CALL TIMEP(ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
C
        WRITE(0,*) 'DEBUG: TIMER B 3.00',zdt1
        IF (ZDT1.LE.0.D0) GOTO 990
C
      ELSEIF (ITIME.NE.1) THEN
C
        IF (NLTOR.OR.NLTRA) THEN
          CALL TIMET (ZDT1)
          TS=ZT+ZDT1
          ZTST=TS
        ENDIF
      ENDIF
C
        WRITE(0,*) 'DEBUG: TIMER B 4.00',ztst
      IF (ZTST.GE.1.D30) GOTO 990
C
C  LOCAL MEAN FREE PATH
C
C  NCOU CELLS ARE CROSSED BY THE CURRENT TRACK.
C  EVALUATE RACTION RATES, MFP, ETC. IN THESE CELLS
C
      IFLAG=3

      IF (NLTRJ) THEN
        TRAJ(ITRJ)%TRJ%NCOU_CELL = TRAJ(ITRJ)%TRJ%NCOU_CELL + NCOU
        DO J=1,NCOU
          NCELL=NRCELL+NUPC(J)*NR1P2+NBLCKA
          ALLOCATE(NEW_CELL)
          NEW_CELL%NO_CELL = NCELL
          NEW_CELL%FLIGHT = CLPD(J)
          CALL CELL_INSERT(ITRJ,NEW_CELL)
        END DO 
      END IF
      IF (IFPATH.NE.1.OR.NRC.LT.0) THEN
C  USE VACUUM VALUES FOR REACTION RATES, MFP, ETC..
        XSTORV(:) =0.D0
        IF (NCOU.GT.1) THEN
          XSTOR2(:,:,1:NCOU)=0.D0
          XSTORV2(:,1:NCOU) =0.D0
        ENDIF
        ZMFP=1.D10
      ELSE
        NCOUS=NCOU
        ZTS=ZT
        DO 212 J=1,NCOU
          JJ=J
          NCELL=NRCELL+NUPC(J)*NR1P2+NBLCKA
          IF (ITYP.EQ.0) ZMFP=FPATHPH(NCELL,CFLAG,J,NCOU)
          IF (ITYP.EQ.1) ZMFP=FPATHA (NCELL,CFLAG,J,NCOU)
          IF (ITYP.EQ.2) ZMFP=FPATHM (NCELL,CFLAG,J,NCOU)
          IF ((ITYP.EQ.0).AND.(ZMFP < WMINL*CLPD(J))) WMINC_LOCAL=1._DP
          IF (NCOU.GT.1) THEN
            XSTOR2(:,:,J) = XSTOR(:,:)
            XSTORV2(:,J) = XSTORV(:)
          ENDIF
C  UPDATE INTEGRAL
          ZINT1=ZINT1+CLPD(J)*ZMFPI
          IF (.NOT.NLPR) THEN
            IF (ZINT1.GE.ZLOG) THEN
C  COLLISION IN SECTION JJ
              IF (NLPOL) NPCELL=NCOUNP(J)
              IF (NLTOR) NTCELL=NCOUNT(J)
              GO TO 213
            ENDIF
            ZINT2=ZINT1
            ZT=ZT+CLPD(J)
          ELSEIF (NLPR) THEN
            IF (JCOL.EQ.0) THEN
              IF (ZINT1.GE.ZLOG) THEN
                JCOL=JJ
                IF (NLPOL) NPCOLC=NCOUNP(J)
                IF (NLTOR) NTCOLC=NCOUNT(J)
              ELSE
                ZINT2=ZINT1
                ZT=ZT+CLPD(J)
              ENDIF
            ENDIF
            AX(1)=AX(2)
            EX=CLPD(J)*ZMFPI
            IF (EX.LE.1.D-10) THEN
              EXPM=1.
C             AX(1)=AX(1)
            ELSEIF (EX.GT.1.D2) THEN
              EXPM=0.D0
              AX(1)=AX(1)/EX
            ELSE
              EXPM=EXP(-EX)
              AX(1)=AX(1)*(1.-EXPM)/EX
            ENDIF
            ZTS=ZTS+CLPD(J)
            IF (NLPOL) NPCELC=NCOUNP(J)
            IF (NLTOR) NTCELC=NCOUNT(J)
            CLPD(J)=CLPD(J)*AX(1)
            AX(2)=AX(2)*EXPM
C  COND. EXP.EST: STOP BECAUSE OF WMINC-CRITERION
            IF (.NOT.NLTRJ.AND.(AX(2).LE.WMINC_LOCAL)) THEN
C    RESTORE POINT OF COLLISION ?
              IF (JCOL.NE.0) GOTO 213
C    NO COLLISION YET; CONTINUE LOOP 212
              AX(1)=1.
              AX(2)=1.
            ENDIF
          ENDIF
212     CONTINUE   ! NCOU LOOP DONE
C
213     CONTINUE   ! EXIT FROM NCOU LOOP DUE TO COLLISION AT ICOU=JJ
        NCOU=JJ
      ENDIF
      WRITE(0,*) 'DEBUG: CHECK EVENT 1.00',nlpr,zint1,zlog
C
C  CHECK FOR EVENT
C
      IF (NLPR) THEN
C  CHECK FOR 1.ST COLLISION ALONG TRACK
        IF (ICOL.EQ.0.AND.ZINT1.GE.ZLOG) GOTO 505
C  STOP TRACK BECAUSE OF WMINC-CRITERION?
        IF (NCOU.LT.NCOUS) THEN
          IFLAG=2
          IF (IUPDTE.GE.1) THEN
            IF (ITYP.EQ.1) CALL UPDATM (XSTOR2,XSTORV2,IFLAG)
            IF (ITYP.EQ.2) CALL UPDMOL (XSTOR2,XSTORV2,IFLAG)
            IF (ITYP.EQ.0) CALL UPDPHOT(XSTOR2,XSTORV2,IFLAG)
            IF (NADSPC >= 1) CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
          ENDIF
          ZT=ZTS
          GOTO 216
        ENDIF
C  STOP TRACK BECAUSE OF COLLISION
      ELSEIF (ZINT1.GE.ZLOG) THEN
        WRITE(0,*) 'DEBUG: CHECK EVENT OFF TO 220'
        GO TO 220
      ENDIF
C
215   CONTINUE
C
      ZINT2=ZINT1
      ZT=ZTST
C
C  UPDATE CONTRIBUTION TO VOLUME AVERAGED ESTIMATORS
C
      WRITE(0,*) 'DEBUG: VOLUME TALLY 1.00',iupdte,ityp
      IF (IUPDTE.GE.1) THEN
        IF (ITYP.EQ.1) CALL UPDATM (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.2) CALL UPDMOL (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.0) CALL UPDPHOT(XSTOR2,XSTORV2,IFLAG)
        IF (NADSPC >= 1) CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
      ENDIF
C
C  STOP TRACK ?
C
      WRITE(0,*) 'DEBUG: STOP TRACK? 1.00',isrfcl
      IF (ISRFCL.EQ.1) CALL ADDCOL (XLI,YLI,ZLI,SG,*104,*380)
      IF (ISRFCL.EQ.2) CALL TIMCOL (AX(2),         *104,*800)
      IF (ISRFCL.EQ.3) CALL TORCOL (               *104)
C
C  NO, CONTINUE TRACK
C
C  NEXT CELL - CHECK FOR ESCAPE OR NON DEFAULT ACTING STANDARD SURFACE
C
      IF (LEVGEO.LE.3) THEN
C
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          MSURFG=NPCELL+(NTCELL-1)*NP2T3
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
        ISTS=INMP2I(IRCELL,MPSURF,ITCELL)
        IF (NLPOL.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCY)
          NLSRFY=.TRUE.
          MSURFG=NRCELL+(NTCELL-1)*NR1P2
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,2,SG,*104,*380)
        ENDIF
        ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
        IF (NLTOR.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCZ)
          NLSRFZ=.TRUE.
          MSURFG=NRCELL+(NPCELL-1)*NR1P2
          IF (ILIIN(NLIM+ISTS) .NE. 0) CALL STDCOL (ISTS,3,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.4) THEN
        ISTS=ABS(INMTI(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
!pb          SG=ISIGN(1,NINCX)
          SG=SIGN(1._DP,VELX*PTRIX(IPOLGN,MRSURF)+
     .                  VELY*PTRIY(IPOLGN,MRSURF))
          NLSRFX=.TRUE.
          MSURFG=INSPAT(IPOLGN,MRSURF)
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.5) THEN
        WRITE(0,*) 'DEBUG: LEV.EQ.5 1.00'
        ISTS=ABS(INMTIT(IPOLGN,MRSURF))
        IF (NLRAD.AND.ISTS.NE.0) THEN
!pb          SG=ISIGN(1,NINCX)
!pb          IF (NRCELL == 0) SG = -1.D0
          SG=SIGN(1._DP,VELX*PTETX(IPOLGN,MRSURF)+
     .                  VELY*PTETY(IPOLGN,MRSURF)+
     .                  VELZ*PTETZ(IPOLGN,MRSURF))
          NLSRFX=.TRUE.
C         MSURFG= ??
          WRITE(0,*) 'DEBUG: LEV.EQ.5 2.00',ILIIN(ISTS)
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
C
      ELSEIF (LEVGEO.EQ.6) THEN
        ISTS=INMP1I(MRSURF,IPCELL,ITCELL)
        IF (NLRAD.AND.ISTS.NE.0) THEN
          SG=ISIGN(1,NINCX)
          NLSRFX=.TRUE.
          IF (ILIIN(ISTS) .NE. 0) CALL STDCOL (ISTS,1,SG,*104,*380)
        ENDIF
      ENDIF
C
      NRCELL=NRCELL+NINCX
      IF (NRCELL.GT.NR1STM) GOTO 990
      IF (NACELL.LT.1.AND.NRCELL.LT.1) GOTO 990
C
C  PARTICLE ON SURFACE MRSURF BELONGING TO 1ST (RADIAL OR X-) GRID
C
C  IF NOT, THEN IT MUST, FOR SOME REASON,
C  HAVE BEEN STOPPED IN THE MIDDLE OF A TRACK.
      IF (MRSURF.EQ.0) THEN
C  ADVANCE IN SAME CELL, AND CONTINUE TRACK
        X0=X0+VELX*ZT
        Y0=Y0+VELY*ZT
        Z0=Z0+VELZ*ZT
        TIME=TIME+ZT/VEL
        IPOLG=IPOLGN
        MASURF=0
        MSURF=0
        IF (NLTRA) THEN
          PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
          X01=X0+RMTOR
        ENDIF
        X00=X0
        Y00=Y0
        Z00=Z0
        Z01=Z0
        GOTO 104
      ENDIF
C
C  CHECK IF WE HAVE ENCOUNTERED A SPLITTING ZONE
C  SPLITTING AND RR NOT READY FOR LEVGEO.GE.4
      IF (LEVGEO.LE.3) THEN
        IF (NLSPLT(MRSURF).AND.NLEVEL.LT.MAXLEV.AND.ICOL.EQ.0) THEN
          CALL SPLTRR(1,MRSURF,NINCX,*210,*700)
        ENDIF
      ENDIF
C
216   CONTINUE
C
C  SWITCH OFF CONDITIONAL EXP. ESTIMATOR ?
      IF (NLPR.AND..NOT.NLTRJ.AND.(AX(2).LT.WMINC_LOCAL)) THEN
        IF (NLTRC) THEN
          X0S=X0+VELX*ZT
          Y0S=Y0+VELY*ZT
          Z0S=Z0+VELZ*ZT
          TIMES=TIME+ZT/VEL
          IF (NLTRA)
     .      PHIS=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0S,(X0S+RMTOR)),PI2A)
          PSAVE=PHI
          PHI=PHIS
          TSAVE=TIME
          TIME=TIMES
          CALL CHCTRC(X0S,Y0S,Z0S,16,8)
          PHI=PSAVE
          TIME=TSAVE
        ENDIF
        IF (ICOL.EQ.1) GOTO 512
C  NO COLLISION YET; RESTART AGAIN WITH COND. EXP. ESTIMATOR
C                    IN NEW CELL
        AX(1)=1.
        AX(2)=1.
        JCOL=0
      ENDIF
C  EITHER: GOTO 101, NEW RANDOM NUMBER, ZINT1=0, X=XS
C  OR    : GOTO 210, CONTINUE TRACK,
C  THIS IS THE SAME, BECAUSE OF EXPONENTIAL DISTRIBUTION OF PATH LENGTHS
      GOTO 210
C
C  POINT OF COLLISION  220 -- 240
C
220   CONTINUE
      WRITE(0,*) 'DEBUG: 220 1.00'
      DIST=CLPD(NCOU)
      CLPD(NCOU)=(ZLOG-ZINT2)*ZMFP
      ZTC=ZT+CLPD(NCOU)
      IFLAG=4
      WRITE(0,*) 'DEBUG: 220 2.00',iupdte
      IF (IUPDTE.GE.1) THEN
        IF (ITYP.EQ.1) CALL UPDATM (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.2) CALL UPDMOL (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.0) CALL UPDPHOT(XSTOR2,XSTORV2,IFLAG)
        IF (NADSPC >= 1) CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
      ENDIF
      X0=X0+VELX*ZTC
      Y0=Y0+VELY*ZTC
      Z0=Z0+VELZ*ZTC
      TIME=TIME+ZTC/VEL
      IF (LEVGEO.LE.3.AND.NLPOL) THEN
        IPOLG=NPCELL
      ELSEIF (NLPLG) THEN
        IPOLG=LEARC2(X0,Y0,NRCELL,NPANU,'FOLNEUT 2    ')
      ELSEIF (NLFEM) THEN
        IPOLG=0
      ELSEIF (NLTET) THEN
        IPOLG=0
      ENDIF
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      NLSRFA=.FALSE.
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      MSURF=0
      IF (NLTRA) PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
C
230   CONTINUE
      WRITE(0,*) 'DEBUG: 230 1.00'
C
C  PRE COLLISION ESTIMATOR
C
      IF (NCLVI.GT.0) THEN
        WS=WEIGHT/SIGTOT
        CALL UPCUSR(WS,1)
      ENDIF
C
C  TEST FOR CORRECT CELL NUMBER AT COLLISION POINT
C  KILL PARTICLE, IF TOO LARGE ROUND OFF ERRORS DURING
C  PARTICLE TRACING
C
      WRITE(0,*) 'DEBUG: 230 2.00',nltest
      IF (NLTEST) CALL CLLTST(*997)
C
C  SAMPLE FROM COLLISION KERNEL FOR NEUTRAL PARTICLES
C  AT PRESENT: NO SUPPRESSION OF ABSORBTION AT IONIZATION
C  FIND NEW WEIGHT, SPECIES INDEX, VELOCITY AND RETURN
C
      WRITE(0,*) 'DEBUG: 230 3.00',ityp
      IF (ITYP.EQ.1) THEN
        CALL COLATM(CFLAG,COLTYP,DIST)
      ELSEIF (ITYP.EQ.2) THEN
        CALL COLMOL(CFLAG,COLTYP,DIST)
      ELSEIF (ITYP.EQ.0) THEN
        CALL COLPHOT(CFLAG,COLTYP,DIST)
      ENDIF
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
C  POST COLLISION ESTIMATOR
C
      IF (NCLVI.GT.0) THEN
        WS=WEIGHT/SIGTOT
        CALL UPCUSR(WS,2)
      ENDIF
C
      IF (COLTYP.EQ.2.) GOTO 700
C
      WRITE(0,*) 'DEBUG: 230 OFF TO 100'
      GOTO 100
C
C  SIMULATION OF COLLISION EVENT FINISHED
C
C
C  ..............................................................
C  .
C  .  INCIDENT ONTO SURFACE
C  ..............................................................
C
380   CONTINUE
C
C
      PR=AX(2)
      IF (ILIIN(MSURF).LE.-2) PR=PR*SG
C
C  UPDATE EFFLUXES ONTO SURFACE AND REFLECT PARTICLE
C
      CALL ESCAPE(PR,SG,*100,*104,*512)
C
C   GOTO 100: START NEW TRACK OF NEUTRAL PARTICLE
C   GOTO 104: CONTINUE THIS TRACK, TRANSPARENT SURFACE IS CROSSED
C   GOTO 512: RESTORE PREVIOUS COLLISION DATA,
C             CONDITIONAL EXPECTATION ESTIMATOR WAS USED
C
      NLTRJ = .FALSE.
      TRAJ(ITRJ)%TRJ%NO_SURF = MSURF
      RETURN
C
C
C  ...................................................
C  .                                                 .
C  .  CONDITIONAL EXPECTATION ESTIMATOR  500 -- 599  .
C  ...................................................
C
C
C
C
C   SAVE DATA OF FIRST COLLISION ALONG CONDITIONAL TRACK
505   CONTINUE
      IF (NCOU.GT.1) THEN
        ZMFP=1./XSTORV2(NSTORV,JCOL)
      ELSE
C  IN CASE NCOU.EQ.1: XSTORV HAS NOT BEEN STORED ONTO XSTORV2
        ZMFP=1./XSTORV(NSTORV)
      ENDIF
      NPCLLC=1
      NTCLLC=1
      IF (NLPOL) NPCLLC=NPCOLC
      IF (NLTOR) NTCLLC=NTCOLC
      ZDT1C=(ZLOG-ZINT2)*ZMFP
      ZTC=ZT+ZDT1C
      X0C=X0+VELX*ZTC
      Y0C=Y0+VELY*ZTC
      Z0C=Z0+VELZ*ZTC
      TIMEC=TIME+ZTC/VEL
      NRCLLC=NRCELL
      NACLLC=NACELL
      NBLCKC=NBLOCK
      NCELLC=NCELL
      ITIMEC=ITIME
      IFPTHC=IFPATH
      IUPDTC=IUPDTE
      IPERIDC=IPERID
      VELXC=VELX
      VELYC=VELY
      VELZC=VELZ
      VELC=VEL
      E0C=E0
      GENRC=XGENER
      WEIGHC=WEIGHT
      IF (NLTRA)
     .  PHIC=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0C,(X0C+RMTOR)),PI2A)
      IF (NCOU.GT.1) THEN
        XSTORC(:,:) = XSTOR2(:,:,JCOL)
        XSTORVC(:)  = XSTORV2(:,JCOL)
      ELSE
C  IN CASE NCOU.EQ.1: XSTORV HAS NOT BEEN STORED ONTO XSTORV2
        XSTORC(:,:) = XSTOR(:,:)
        XSTORVC(:)  = XSTORV(:)
      ENDIF
      IF (NLTRC) THEN
        PSAVE=PHI
        TSAVE=TIME
        NPSAVE=NPCELL
        NTSAVE=NTCELL
        IF (NLTRA) PHI=PHIC
        TIME=TIMEC
        NPCELL=NPCLLC
        NTCELL=NTCLLC
        CALL CHCTRC(X0C,Y0C,Z0C,16,13)
        PHI=PSAVE
        TIME=TSAVE
        NPCELL=NPSAVE
        NTCELL=NTSAVE
      ENDIF
      ICOL=1
      IFLAG=5
C  TRACK COMPLETED ?
      IF (NCOU.GE.NCOUS) GOTO 215
C
C  TRACK NOT COMPLETED BECAUSE OF WMINC-CRITERION
C  UPDATE CONTRIBUTION TO VOLUME AVERAGED ESTIMATORS
C
      IF (IUPDTE.GE.1) THEN
        IF (ITYP.EQ.1) CALL UPDATM (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.2) CALL UPDMOL (XSTOR2,XSTORV2,IFLAG)
        IF (ITYP.EQ.0) CALL UPDPHOT(XSTOR2,XSTORV2,IFLAG)
        IF (NADSPC >= 1) CALL CALC_SPECTRUM (WEIGHT,IFLAG,1)
      ENDIF
      GOTO 216
C
C   RESTORE PRE COLLISION DATA AND SAMPLE FROM COLLISION KERNEL
512   X0=X0C
      Y0=Y0C
      Z0=Z0C
      TIME=TIMEC
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      MSURF=0
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      NRCELL=NRCLLC
      NPCELL=NPCLLC
      NTCELL=NTCLLC
      NACELL=NACLLC
      NBLOCK=NBLCKC
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
      NCELL=NCELLC
      ITIME=ITIMEC
      IFPATH=IFPTHC
      IUPDTE=IUPDTC
      IPERID=IPERIDC
      VELX=VELXC
      VELY=VELYC
      VELZ=VELZC
      VEL=VELC
      E0=E0C
      XGENER=GENRC
      WEIGHT=WEIGHC
      IF (LEVGEO.LE.3.AND.NLPOL) THEN
        IPOLG=NPCELL
      ELSEIF (NLPLG) THEN
        IPOLG=LEARC2(X0,Y0,NRCELL,NPANU,'FOLNEUT 3    ')
      ELSEIF (NLFEM) THEN
        IPOLG=0
      ELSEIF (NLTET) THEN
        IPOLG=0
      ENDIF
      IF (NLTRA) PHI=PHIC
      XSTOR(:,:) = XSTORC(:,:)
      XSTORV(:)  = XSTORVC(:)
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,14)
      ICOL=0
      LGPART=.TRUE.
      NLTRJ = .FALSE.
      GOTO 230
C
700   CONTINUE
C  REGULAR STOP IN SUBR. FOLNEUT, CONTINUE IN SUBR. MCARLO
      RETURN
C
800   CONTINUE
C  REGULAR STOP IN SUBR. FOLNEUT, STOP HISTORY, CENSUS ARRAY FULL
      IF (ICOL.EQ.1.AND..NOT.LGLAST) GOTO 512
      LGPART=.FALSE.
      WEIGHT=0.
      RETURN
C
990   CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLNEUT, ZDT1 OR NRCELL OUT OF RANGE  ')
      CALL MASAGE ('PARTICLE IS KILLED                             ')
      WRITE (iunout,*) 'NPANU,NRCELL,ZDT1,ZTST,TL,TS '
      WRITE (iunout,*) NPANU,NRCELL,ZDT1,ZTST,TL,TS
      GOTO 995
C
992   CONTINUE
      CALL LEER(1)
      CALL MASAGE ('ERROR IN FOLNEUT, SURFACE CONFLICT             ')
      CALL MASR2  ('TL,TS           ',TL,TS)
      WRITE (iunout,*) 'NPANU ',NPANU
      ZT=TL
      GOTO 995
C
993   CALL MASAGE ('ERROR IN FOLNEUT, NO PARTICLE TRACING BUT     ')
      CALL MASAGE ('IFPATH.NE.1. PARTICLE IS KILLED               ')
      WRITE (iunout,*) 'ISPEZ ',ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
      GOTO 999
C
995   WRITE (iunout,*) 'MRSURF,MPSURF,MTSURF,MASURF ',
     .             MRSURF,MPSURF,MTSURF,MASURF
      X0ERR=X0+ZT*VELX
      Y0ERR=Y0+ZT*VELY
      Z0ERR=Z0+ZT*VELZ
      IF (NLTRC) THEN
        CALL CHCTRC(X0ERR,Y0ERR,Z0ERR,16,18)
      ELSE
        WRITE (iunout,*) 'X0,Y0,Z0,ZT ',X0,Y0,Z0,ZT
        WRITE (iunout,*) 'VELX,VELY,VELZ ',VELX,VELY,VELZ
        WRITE (iunout,*) 'X0ERR,Y0ERR,Z0ERR ',X0ERR,Y0ERR,Z0ERR
      ENDIF
      GOTO 999
997   CALL MASAGE ('ERROR IN FOLNEUT, DETECTED IN SUBR. CLLTST    ')
      CALL MASAGE ('PARTICLE IS KILLED                            ')
C   DETAILED PRINTOUT ALREADY DONE FROM SUBR. CLLTST
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,18)
      GOTO 999
C
998   WRITE (iunout,*) 'ERROR IN FOLNEUT, SPECIES INDEX OUT OF RANGE '
      WRITE (iunout,*) ' NPANU,ITYP,IATM,IMOL,IPHOT ',
     .                   NPANU,ITYP,IATM,IMOL,IPHOT
      GOTO 999
C
999   CONTINUE
      PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
      ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
      LGPART=.FALSE.
      CALL LEER(1)
      RETURN
      END
C ===== SOURCE: fpkcol.f
C  sept. 05: use only parallel velocity, vel=velpar,....
C            this is now made consistent in calling program folion.f
C  aug 06: move call to chctrc: pre-collision status at point of collision
C          and: return new velocity vector in full cartesian coord.
C               fetch new BVEC at point of collision
C
      SUBROUTINE FPKCOL(*,*)
C
C  FOKKER PLANCK ELASTIC COLLISION
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CFPLK
      USE CLOGAU
      USE CUPD
      USE CGRID
      USE CGEOM
      USE CZT1
      USE COMPRT
      USE CLGIN
      USE COUTAU
      USE COMXS

      IMPLICIT NONE

      REAL(DP) :: DUR, E0OLD, E0NEW, VNEW, WS, FAC, GYRO,
     .            BVEC_1(3), VVEC(3)
      INTEGER :: IOLD, LEARC2, NCELLT
      REAL(DP), EXTERNAL :: RANF_EIRENE
C  RETURN 1:  NOT IN USE
C  RETURN 2:  START COMPLETELY NEW TEST ION TRACK, SAME SPECIES
C
C  SAVE INCIDENT SPECIES: IOLD
      IOLD=IION
      E0OLD=E0
      NCELLT=NCLTAL(NCELL)
C
      X0=X0+VELX*ZT
      Y0=Y0+VELY*ZT
      Z0=Z0+VELZ*ZT
      TIME=TIME+ZT/VEL
      IF (LEVGEO.LE.3.AND.NLPOL) THEN
        IPOLG=NPCELL
      ELSEIF (NLPLG) THEN
        IPOLG=LEARC2(X0,Y0,NRCELL,NPANU,'FOLION 2     ')
      ELSEIF (NLFEM) THEN
        IPOLG=0
      ENDIF
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      MSURF=0
      IF (NLTRA) PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,7)
C
255   CONTINUE
C
C
C  PRE COLLISION ESTIMATOR
C
      IF (NCLVI.GT.0) THEN
        WS=WEIGHT/SIGTOT
        CALL UPCUSR(WS,1)
      ENDIF
C
C
C  TEST FOR CORRECT CELL NUMBER AT COLLISION POINT
C  KILL PARTICLE, IF TOO LARGE ROUND OFF ERRORS DURING
C  PARTICLE TRACING
C
      IF (NLTEST) CALL CLLTST(*997)
      IF (ZT.GT.0.D0) THEN
C
C  FLIGHT WITH PARALLEL VELOCITY VEL=VELPAR (CM/SEC)
C  PARALLEL DISTANCE ZT (CM)
C  ENERGY RELAXATION CONSTANT TAUE
C
        DUR=ZT/VEL
        E0NEW=E0OLD*EXP(-DUR/TAUE)+1.5*TIIN(1,NCELL)*(1.-EXP(-DUR/TAUE))
        VNEW=RSQDVI(IOLD)*SQRT(E0NEW)
C
C  UPDATE ESTIMATORS EIIO,EIPL
        EIIO(NCELLT)=EIIO(NCELLT)+WEIGHT*(E0NEW-E0OLD)
        EIPL(NCELLT)=EIPL(NCELLT)-WEIGHT*(E0NEW-E0OLD)
C
        IF (.NOT.LCART) THEN
          FAC=SQRT(E0NEW/E0OLD)
          VELPAR=VELPAR*FAC
          VELPER=VELPER*FAC


C  NEW GYRO PHASE
          GYRO=RANF_EIRENE()*PI2A
C  BACK TO CARTESIAN COORDIANTES
          BVEC = (/ BBX, BBY, BBZ /)
          CALL B_PROJI (BVEC,BVEC_1,VVEC,SIGPAR*VELPAR,VELPER,GYRO)
          VELX = VVEC(1)
          VELY = VVEC(2)
          VELZ = VVEC(3)
          VEL=VNEW
          LCART=.TRUE.
        ELSE
          VEL=VNEW
        ENDIF
C  RETURN WITH FULL CARTESIAN VELOCITY VECTOR
        E0=E0NEW
        RETURN 2
      ENDIF
C
C  POST COLLISION ESTIMATOR
C
C     IF (NCLVI.GT.0) THEN
C       WS=WEIGHT/SIGTOT
C       CALL UPCUSR(WS,2)
C     ENDIF
      RETURN 2
C
997   CALL MASAGE ('ERROR IN FPKCOL,  DETECTED IN SUBR. CLLTST    ')
      CALL MASAGE ('PARTICLE IS KILLED                            ')
C   DETAILED PRINTOUT ALREADY DONE FROM SUBR. CLLTST
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,18)
      GOTO 999
C
999   PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
      ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
      LGPART=.FALSE.
      WEIGHT=0.
      CALL LEER(1)
      RETURN 2
      END
C ===== SOURCE: locate.f
!PB 12.01.06: index added to calc_spectrum indicating particle starts on surface
!PB 02.03.06: store startpoint of trajectory 
cdr 12.05.06: argument vn added to ph_energy, for doppler+motional stark effect
c             directly to be included in line shape sampling
!pb 27.09.06: spttot updated with sputtering of bulk ions (total sputtered flux tally)
!pb           spatial resolution of sptpl and spttot added 
!pb  8.11.06: set timestep index for time dependent mode
!pb  8.11.06: as SORLIM can be negative ISOR=ABS(SORLIM)

      SUBROUTINE LOCATE
c  old option:
c              sorind=irrc for volume sources
c  new option (additionally):
c              sorind=0 for volume sources
c              then: automatically detect all relevant irrc and
c                    sample, if more than one:
c                    1.) ipls (must be specified), and icell
c                    2.) find irrc (random) amongst tabrc1
c                    3.) find ityp, iatm,....
c
c  to be done?  pppl and eppl: primary particle/energy source rates,
c                              bulk particles
c  done in jan05
c  jan05:  2nd bulk secondary for irrc processes in pppl, eppl
c          (also affected: comxs, xstrc, xsectp)
c
c  for testing sampling and evaluation of line profiles:
c  re-activate ILOOP loop, plot e-spectrum sampled with ph_energy
c                          plot e-spectrum evaluated with ph_getcoeff
c  jet 2005, patch 1:
c  nov.05:  step functions shstep and elstep connected.
c           shwl in parameter list for calls to smvol1, smpnt1, smsrf1.
c           shstep overrules all other sheath options, if shstep (=shwl) gt.0
c           elstep is now nemod1=8,9  (was previously: -2, -3, but this
c           could not be chosen in input, due to use of IDEZ function for nemods
C
C  LOCATE MONTE-CARLO PARTICLE
C
C  CALLED AT ENTRY LOCAT0 AT INITIALISATION FOR EACH STRATUM ISTRA
C     PURPOSE: PRECOMPUTING SOME QUANTITIES TO SPEED UP RANDOM SAMPLING
C              DURING PARTICLE TRACING
C
C  CALLED AT ENTRY LOCAT1 FOR EACH NEW LAUNCHED MONTE CARLO TRAJECTORY
C  FROM PARTICLE LOOP IN SUBR. MCARLO
C     PURPOSE: SET INITIAL TEST FLIGHT STATE, DEFINED BY THE VARIABLES
C              NO. 1 ... TO NPARTC+MPARTC OF COMMON BLOCK "COMPRT"
C              I.E.,
C                  X0... TO IUPDTE
C     UPDATE SOURCE ESTIMATORS FOR BALANCES: PPPL,PPML,PPAT, EPPL,  ETC.
C     UPDATE CUMULATED SOURCE WEIGHT FOR SCALING: WTOTA, WTOTP, ETC.
C
C
C  CALLED PROGRAMS: SAMPNT (POINT SOURCE)
C                   SAMLNE (LINE SOURCE)  (NOT READY)
C                   SAMSRF (SURFACE SOURCE)
C                   SAMVOL (VOLUME SOURCE)
C  LOCAL VARIABLES: TEWL,TIWL(IPLS),DIWL(IPLS),
C                   VXWL(IPLS),VYWL(IPLS),VZWL(IPLS),EFWL(IPLS),SHWL
C
C                   THESE ARE BACKGROUND PARAMETERS USED FOR SAMPLING
C                   IN VELOCITY SPACE, IN CASE NLPLS, I.E., IF THE
C                   TEST FLIGHT STARTS AS BACKGROUND PARTICLE, THEN
C                   "RECOMBINING" INTO A TEST PARTICLE
C                   EG. AT A SURFACE (NLSRF) OR IN THE VOLUME (NLVOL)
C                   IN THE OPPOSITE CASE (.NOT.NLPLS) PARAMETERS
C                   FOR THE SAMPLING DISTRIBUTION ARE SPECIFIED
C                   BY INPUT PARAMETERS IN BLOCK 7.,EG. SORENE,SORENI
C                   SORVDX,SORVDY,SORVDZ AND APPROPRIATE NEMOD2 AND
C                   NEMOD3 FLAGS
C
C                   WEISPZ(ISPZ):
C
C                   ANALOG SPECIES SAMPLING DISTRIBUTION
C                   SPECIES SAMPLING MAY ALSO BE DONE BY BIASED SOURCE
C                   SAMPLING, USING THE DATM,DMOL,DION OR DPLS DISTRIB.
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CSPEZ
      USE CZT1
      USE CTRCEI
      USE CGEOM
      USE CTETRA
      USE COMPRT
      USE COMNNL
      USE COMSOU
      USE COMSPL
      USE CLGIN
      USE COUTAU
      USE COMXS
      USE CTRIG
      USE CRAND
      USE CSPEI
      USE PHOTON

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: IPANU
      REAL(DP) :: DUMT(3),DUMV(3)
      REAL(DP), ALLOCATABLE, SAVE :: WMM(:), WEISPZ(:), X1LINE(:,:),
     .                               X2LINE(:,:)
      REAL(DP) :: VXWL(NPLS), VYWL(NPLS), VZWL(NPLS), VPWL(NPLS),
     .            TIWL(NPLS), DIWL(NPLS), EFWL(NPLS), SHWL, TEWL,
     .            CUMDIS(0:NREC)
      REAL(DP) :: YIELD1, YIELD2, FMASS, FCHAR, VELXS, VELYS, FTABRC1,
     .          VELZS, E0S, WEIGHS, VELS, FLX, VPARZ, VPAR, VTERM,
     .          VPERP, VPARX, VPARY, EMAXW, ESHET, SHEATH, GAMMA, CUR,
     .          VYSPTP, VZSPTP, ESPTC, ESPTP, VSPTP, VXSPTP, VSPTC, SG,
     .          VXSPTC, VYSPTC, VZSPTC, A, ZV, SUM1, ZEP1,
     .          EMAX, VWD, VXWD, VYWD, VZWD, CS, VELQ, VO, SUMM,
     .          VXO, VYO, VZO, DAT, RSQDV, DML, FR, DIO, DPL, TIWD,
     .          TEWD, DPH, E00, DE, HW, SHIFT, DVDW, FAC, dwde, prmax,
     .          raw, res
      REAL(DP) :: VEL_B, VELX_B, VELY_B, VELZ_B, VN, xl, xr, xm, yl,
     .            yr, ym, prmin, sig, zmfp, ean, een, ye,
     .            fpathph, flxfc, zmfp_cut, zmfp_e0, zmfp_e00,
     .            fac_e0, fac_e00,
     .            hwvdw_pb,pla,B_NU, EN, spcvl, spcmx, sumspc,
     .            xleft, xright, weights
      real(sp), allocatable :: eplot(:), y1plot(:), y2plot(:)
      real(sp) :: y1a,y1e,y2a,y2e,e00_plot
      real(DP) :: EMINSP,EMAXSP,e_min,e_max
      real(dp) :: cflag(7,3)
      REAL(DP), SAVE :: SNORM
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER, ALLOCATABLE, SAVE :: IICSOR(:), ITISOR(:),
     .                              IUPSOR(:), IFPSOR(:)
      INTEGER, SAVE :: NEMOD1, NEMOD2, NEMOD3, NEMDSP
      INTEGER :: ISSPTP, ISSPTC, ISTS, IP, ISPZS, IRC, IIRC, IRRC,
     .           I2, IM, J, I1, IMP, NPANUO, ILINE, ISURF, ITRSF,
     .           IUPATH, IPOINT, ISOUR, ISRFS, I, ISTEP,
     .           ISECT, IDUMM, ICOS, NFLAG, NCELLT, IPLSTI,
     .           IPLV, IDUM, IO, NO, IVOLM, ISOR, INDTEC, IPL, IPP,
     .           IPLTI, IROT, IL, IGND, ICELL, KK, IR, ILOOP, ISPC, nen,
     .           NLOOP, IE, ictoff, iloc, ITOLD
      INTEGER, SAVE :: NLIMSQ
      INTEGER, EXTERNAL :: IDEZ
      LOGICAL :: NLSPUT, NLTST, NL_add_Doppler
      integer, save :: ifrstpb=0
      integer :: ityp_b1,ityp_b2,ipls_b1,ipls_b2
      real(dp) :: weight_b1,weight_b2,e0_b1,e0_b2
C
      ENTRY LOCAT0
C
C  PREPARE DATA FOR SAMPLING SUBSTRATA FOR STRATUM ISTRA: 1--10
C
      IF (.NOT.ALLOCATED(WMM)) THEN
        ALLOCATE (WMM(NSRFS))
        ALLOCATE (WEISPZ(NSPZ))
        ALLOCATE (IICSOR(NSRFS))
        ALLOCATE (ITISOR(NSRFS))
        ALLOCATE (IUPSOR(NSRFS))
        ALLOCATE (IFPSOR(NSRFS))
      END IF

      DO 1 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
1     CONTINUE
C
      SUMM=0.
      DO 2 ISRFS=1,NSRFSI(ISTRA)
2       SUMM=SUMM+SORWGT(ISRFS,ISTRA)
      IF (SUMM.LE.0.D0) THEN
        WRITE (iunout,*) 'NO SOURCE MODEL FOR STRATUM NO ISTRA=',ISTRA
        WRITE (iunout,*) 'BECAUSE THE SUM OF THE FLUXES'
        WRITE (iunout,*) 'FROM THE SUBSTRATA DEFINED BY'
        WRITE (iunout,*) 'SORWGT(SUBSTRATUM,STRATUM) IS .LE. ZERO'
        WRITE (iunout,*) 'THIS STRATUM IS TURNED OF !!'
        NPTS(ISTRA)=0
        RETURN
      ENDIF
      SUM1=0.
      NLIMSQ=NSRFSI(ISTRA)
      DO 4 ISOUR=1,NSRFSI(ISTRA)
        SUM1=SUM1+SORWGT(ISOUR,ISTRA)
        WMM(ISOUR)=SUM1/SUMM
4     CONTINUE
C
C  PREPARE SOME DATA FOR ENERGY SAMPLING AND HISTORY INITIALIZATION
C
      NEMOD1=IDEZ(NEMODS(ISTRA),1,4)
      NEMOD2=IDEZ(NEMODS(ISTRA),2,4)
      NEMOD3=IDEZ(NEMODS(ISTRA),3,4)
      NEMDSP=IDEZ(NEMODS(ISTRA),4,4)
C
      DO 5 ISRFS=1,NSRFSI(ISTRA)
        IF (SORIFL(ISRFS,ISTRA).NE.0) THEN
          IDUMM=SORIFL(ISRFS,ISTRA)
          ITISOR(ISRFS)=IDEZ(IDUMM,1,4)
          IF (ITISOR(ISRFS).EQ.2) ITISOR(ISRFS)=-1
          IFPSOR(ISRFS)=IDEZ(IDUMM,2,4)
          IF (IFPSOR(ISRFS).EQ.2) IFPSOR(ISRFS)=-1
          IUPSOR(ISRFS)=IDEZ(IDUMM,3,4)
          IF (IUPSOR(ISRFS).EQ.2) IUPSOR(ISRFS)=-1
          IICSOR(ISRFS)=IDEZ(IDUMM,4,4)
          IF (IICSOR(ISRFS).EQ.2) IICSOR(ISRFS)=-1
        ELSE
          ITISOR(ISRFS)=0
          IFPSOR(ISRFS)=0
          IUPSOR(ISRFS)=0
          IICSOR(ISRFS)=0
        ENDIF
5     CONTINUE
C
      SNORM=SQRT(SORCTX(ISTRA)**2+SORCTY(ISTRA)**2+SORCTZ(ISTRA)**2)
      IF (SNORM.GT.EPS10) THEN
        SORCTX(ISTRA)=SORCTX(ISTRA)/SNORM
        SORCTY(ISTRA)=SORCTY(ISTRA)/SNORM
        SORCTZ(ISTRA)=SORCTZ(ISTRA)/SNORM
      ENDIF
C
      IF (NLVOL(ISTRA).AND.NLPLS(ISTRA).AND.NEMOD1.EQ.1) THEN
        WRITE (iunout,*) 'WARNING: NEMOD1=1: NEW MEANING: '
        WRITE (iunout,*) '                   MONOENERGETIC SOURCE'
      ENDIF
      IF (TRCSOU) THEN
        WRITE (iunout,*) 'NEMOD1,NEMOD2,NEMOD3 ',NEMOD1,NEMOD2,NEMOD3
        WRITE (iunout,*) 'SNORM  ',SNORM
        WRITE (iunout,*) 'ISRFS,IICSOR(I),ITISOR(I),IFPSOR(I),IUPSOR(I)'
        DO 6 I=1,NSRFSI(ISTRA)
          WRITE (iunout,*) I,IICSOR(I),ITISOR(I),IFPSOR(I),IUPSOR(I)
6       CONTINUE
      ENDIF
C
C  PREPARE SOME DATA FOR SPECIES SAMPLING
C

      IF (NLVOL(ISTRA) .AND. (NEMOD1 == 9) .AND.
     .    ANY(SORIND(1:NSRFSI(ISTRA),ISTRA) > 0)) THEN

        IF (ALLOCATED(X1LINE)) THEN
          IF (SIZE(X1LINE) /= NSRFSI(ISTRA)) THEN
            DEALLOCATE(X1LINE)
            DEALLOCATE(X2LINE)
            ALLOCATE(X1LINE(NSRFSI(ISTRA),NRAD))
            ALLOCATE(X2LINE(NSRFSI(ISTRA),NRAD))
          END IF
        ELSE
          ALLOCATE(X1LINE(NSRFSI(ISTRA),NRAD))
          ALLOCATE(X2LINE(NSRFSI(ISTRA),NRAD))
        END IF

        X1LINE = -1._DP
        X2LINE = 0._DP
      END IF

      RETURN
C
      ENTRY LOCAT1(IPANU)
C
C  TENTATIVELY ASSUME: A TEST PARTICLE WILL BE BORN
      LGPART=.TRUE.
C
C   SET SOME DEFAULT DATA TO INITIALIZE THIS HISTORY
C
      SCOS_SAVE=0._DP
      WEIGHT=1.0
      IATM=0
      IMOL=0
      IION=0
      IPLS=0
      IPHOT=0
      ITYP_B1=0
      ITYP_B2=0
C
      ITIME=1
      IFPATH=1
      IUPDTE=1
      IC_ION=0
      IC_NEUT=0
C
      NCELL=0
      NBLOCK=1
      NACELL=0
      NBLCKA=0
      NRCELL=0
      NPCELL=1
      NTCELL=1
      IPOLG=1
      IPOLGN=1
      IPERID=1
      ICOL=0
      XLEFT = HUGE(1._DP)
      XRIGHT = 0._DP
C
C  DETAILED PRINTOUT OF TRAJECTORY FOR THIS PARTICLE?
C
      NLTRC=NPANU.GE.I1TRC.AND.NPANU.LE.I2TRC
C
C  =====================================================
C  =SAMPLE STARTING POINT FOR  ATOMS, MOLECULES OR IONS=
C  =====================================================
C
      LGTIME=NPRNLI.GT.0
C  DISTANCE TO "TIME-SURFACE"
      IF (.NOT.LGTIME) THEN
        DTIMVI=1.D30
      ELSEIF (LGTIME) THEN
        DTIMVI=TIME0+DTIMV
      ENDIF
C
C   SOURCE DUE TO TIME DEP. MODE, READ PARTICLES FROM CENSUS: RPARTC,IPARTC
      IF (NLCNS(ISTRA).AND.ISTRA.EQ.NSTRAI) THEN
C   LABELS  11---20
C   AT PRESENT: ONLY ONE SUBSTRATUM
        ISECT=1
        NLSTOR=IPANU.LE.ISTOR(ISECT,ISTRA)
C
        IF (NLMOVIE) THEN
          IMP=IPANU
        ELSE
C   RANDOM SEARCH IN RPARTW ARRAY
          A=RANF_EIRENE()*RPARTW(IPRNL)
C   BINARY SEARCH
          I1=0
          I2=IPRNL
9         IM=(I1+I2)/2
          IF(A.LT.RPARTW(IM)) THEN
            I2=IM
            GOTO 9
          ELSEIF(A.GT.RPARTW(IM+1)) THEN
            I1=IM
            GOTO 9
          ENDIF
          IMP=IM+1
C  PARTICLE NO. IMP FROM CENSUS ARRAY IDENTIFIED
        ENDIF
C
C  LAUNCH PARTICLE NO. IMP FROM CENSUS ARRAY
C
        DO 11 J=1,NPARTT
          RPSTT(J)=RPARTC(IMP,J)
11      CONTINUE
        NPANUO=NPANU
        DO 12 J=1,MPARTT
          IPSTT(J)=IPARTC(IMP,J)
12      CONTINUE
        ITYP=ISPEZI(ISPZ,-1)
        IPHOT=ISPEZI(ISPZ,0)
        IATM=ISPEZI(ISPZ,1)
        IMOL=ISPEZI(ISPZ,2)
        IION=ISPEZI(ISPZ,3)
        IPLS=ISPEZI(ISPZ,4)
        CALL NCELLN(NCELL,NRCELL,NPCELL,NTCELL,NACELL,NBLOCK,
     .              NR1ST,NP2ND,NT3RD,NBMLT,NLRAD,NLPOL,NLTOR)
        NBLCKA=NSTRD*(NBLOCK-1)+NACELL
        NCELLT=NCLTAL(NCELL)
        NPANU=NPANUO
        NLSRFX=.FALSE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        MSURF=NLIM+NSTS
C
        WEIGHT=1.D0
!pb  set number of timestep for time dependent mode
        ITMSTP=1
C
        IF (ITYP.EQ.1) THEN
          WTOTA(IATM,ISTRA)=WTOTA(IATM,ISTRA)+WEIGHT
          ETOTA(ISTRA)=ETOTA(ISTRA)+E0*WEIGHT
          LOGATM(IATM,ISTRA)=.TRUE.
        ELSEIF (ITYP.EQ.2) THEN
          WTOTM(IMOL,ISTRA)=WTOTM(IMOL,ISTRA)+WEIGHT
          ETOTM(ISTRA)=ETOTM(ISTRA)+E0*WEIGHT
          LOGMOL(IMOL,ISTRA)=.TRUE.
        ELSEIF (ITYP.EQ.3) THEN
          WTOTI(IION,ISTRA)=WTOTI(IION,ISTRA)+WEIGHT
          ETOTI(ISTRA)=ETOTI(ISTRA)+E0*WEIGHT
          LOGION(IION,ISTRA)=.TRUE.
        ELSEIF (ITYP.EQ.0) THEN
          WTOTPH(IPHOT,ISTRA)=WTOTPH(IPHOT,ISTRA)+WEIGHT
          ETOTPH(ISTRA)=ETOTPH(ISTRA)+E0*WEIGHT
          LOGPHOT(IPHOT,ISTRA)=.TRUE.
        ELSE
          WRITE (iunout,*) 'ERROR IN LOCATE, CALL EXIT '
          WRITE (iunout,*) 'INVALID ITYP ON CENSUS     '
          CALL EXIT_OWN(1)
        ENDIF
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
        IF (NLSTOR) CALL STORE(1)
C
        GOTO 5000
C
C  POINT SOURCE MODEL  21---30
C
      ELSEIF (NLPNT(ISTRA)) THEN
C
C   FIRSTLY FIND POINT NUMBER IPOINT
        IPOINT=1
        IF (NLIMSQ.GT.1) THEN
          ZV=RANF_EIRENE( )
          DO 21 IPOINT=1,NLIMSQ
            IF (ZV.LT.WMM(IPOINT)) GOTO 22
21        CONTINUE
22        CONTINUE
        ENDIF
        ISECT=IPOINT
        NLSTOR=IPANU.LE.ISTOR(ISECT,ISTRA)
C
C   NEXT FIND CO-ORDINATES AND CELL INDICES,
C   LOCAL BACKGROUND TEMPERATURES TIWL AND TEWL, AND
C   LOCAL PLASMA DRIFT VELOCITIES VXWL,VYWL,VZWL FOR EACH BULK
C   ION SPECIES IPLS=1,NPLSI
C
C   NLPT=POINT INDEX IN (NSRFS) SOURCE ARRAYS
        CALL SAMPNT (IPOINT,
     .               TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
        IF (.NOT.LGPART) RETURN
C
        IF (ITISOR(IPOINT).NE.0) THEN
          ITIME=ITISOR(IPOINT)
        ENDIF
        IF (IFPSOR(IPOINT).NE.0) THEN
          IFPATH=IFPSOR(IPOINT)
        ENDIF
        IF (IUPSOR(IPOINT).NE.0) THEN
          IUPATH=IUPSOR(IPOINT)
        ENDIF
        MSURF=0
C
C   LINE SOURCE  31---50
C
      ELSEIF (NLLNE(ISTRA)) THEN
        ILINE=1
        ISECT=ILINE
        MSURF=0
        WRITE (iunout,*) 'LINE SOURCE OPTION STILL TO BE WRITTEN. EXIT'
        CALL EXIT_OWN(1)
C
C   SURFACE SOURCE MODEL  51---70
C
      ELSEIF (NLSRF(ISTRA)) THEN
C
C   FIRST FIND SOURCE-SURFACE NUMBER ISURF
        ISURF=1
        IF (NLIMSQ.GT.1) THEN
          ZV=RANF_EIRENE( )
          DO 51 ISURF=1,NLIMSQ
            IF (ZV.LT.WMM(ISURF)) GOTO 52
51        CONTINUE
52        CONTINUE
        ENDIF
        ISECT=ISURF
        NLSTOR=IPANU.LE.ISTOR(ISECT,ISTRA)
C
C   NEXT FIND POSITION ON THIS SOURCE SURFACE, AS WELL AS
C   CELL INDICES, LOCAL TEMPERATURES TIWL AND TEWL, AND
C   LOCAL PLASMA DRIFT VELOCITIES VXWL,VYWL,VZWL FOR EACH BULK
C   ION SPECIES IPLS=1,NPLSI
C
        CALL SAMSF1 (ISURF,
     .               TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
        IF (.NOT.LGPART) RETURN
C
C   MSURF: NUMBER OF NON-DEFAULT (OR ADDITIONAL) SURFACE
C   MSURF=0 MEANS: SOURCE NOT ON ANY KNOWN SURFACE.
C                  DEFAULT SURFACE INTERACTION MODEL
        MSURF=0
        IF (LEVGEO.EQ.4) THEN
          IF (MASURF == 0) THEN
            MSURF=ABS(INMTI(IPOLG,NRCELL))
          ELSE
            MSURF=MASURF
          END IF
        ELSEIF (LEVGEO.EQ.5) THEN
          MSURF=ABS(INMTIT(IPOLG,NRCELL))
!pb          IF (MSURF > 0) MSURF=MSURF+NLIM !changed in infcop
        ELSE
          IF (MASURF.GT.0) THEN
            MSURF=MASURF
            ITRSF=0
          ELSEIF (MRSURF.GT.0) THEN
            ITRSF=INMP1I(MRSURF,NPCELL,NTCELL)
          ELSEIF (MPSURF.GT.0) THEN
            ITRSF=INMP2I(NRCELL,MPSURF,NTCELL)
          ELSEIF (MTSURF.GT.0) THEN
            ITRSF=INMP3I(NRCELL,NPCELL,MTSURF)
          ENDIF
          IF (ITRSF.GT.0) MSURF=NLIM+ITRSF
        ENDIF
C
C  SET ICOS AND SCOS SUCH AS IF THE SOURCE PARTICLE HAD ARRIVED
C  AT THE SURFACE FROM THE CORRECT SIDE AND IS NOW REFLECTED
C  (NOTE: THE FLAG "IWEI" USED IN SUBR. STDCOL AND ADDCOL
C  WILL ALWAYS BE POSITIVE WITH THIS DEFINITION OF SCOS)
C  THIS DEFAULT SETTING MAY BE OVERRULED BY SORIFL FLAG
C
        IF (IICSOR(ISURF).NE.0) THEN
          ICOS=IICSOR(ISURF)
        ELSEIF (ILSIDE(MSURF).NE.0) THEN
          ICOS=ISIGN(1,ILSIDE(MSURF))
        ELSE
C  TRY TO FIND ICOS AUTOMATICALLY, IF POSSIBLE
          IF (LEVGEO.EQ.3.AND.MRSURF.GT.0) THEN
            IF (MRSURF.EQ.NRCELL) THEN
              ICOS=-1
            ELSE
              ICOS=1
            ENDIF
          ELSEIF (LEVGEO.EQ.3.AND.MPSURF.GT.0) THEN
            IF (MPSURF.EQ.NPCELL) THEN
              ICOS=-1
            ELSE
              ICOS=1
            ENDIF
          ELSEIF (LEVGEO.EQ.4.AND.MRSURF.GT.0) THEN
C  CURRENTLY: ONLY MATH. POSITIVELY ORIENTED TRIANGLES,
C             HENCE: NORMAL VECTOR OUTSIDE.
            ICOS=1
          ELSE
            GOTO 990
          ENDIF
        ENDIF
C
        SCOS=ICOS
C
        IF (ITISOR(ISURF).NE.0) THEN
          ITIME=ITISOR(ISURF)
        ELSEIF (ISWICH(1,MSURF).NE.0) THEN
          ITIME=ISWICH(1,MSURF)*ICOS
        ENDIF
        IF (IFPSOR(ISURF).NE.0) THEN
          IFPATH=IFPSOR(ISURF)
        ELSEIF (ISWICH(2,MSURF).NE.0) THEN
          IFPATH=ISWICH(2,MSURF)*ICOS
        ENDIF
        IF (IUPSOR(ISURF).NE.0) THEN
          IUPDTE=IUPSOR(ISURF)
        ELSEIF (ISWICH(3,MSURF).NE.0) THEN
          IUPDTE=ISWICH(3,MSURF)*ICOS
        ENDIF
C
C  FIND SURFACE NORMAL AT PLACE OF BIRTH
C
        IF (INDIM(ISURF,ISTRA).EQ.0) THEN
          CALL ADDNOR(X0,Y0,Z0,SCOS,MSURF,IPERID,*55,*55)
        ELSEIF (INDIM(ISURF,ISTRA).GT.0) THEN
          CALL STDNOR (X0,Y0,Z0,INDIM(ISURF,ISTRA),SCOS,MSURF,*55,*55)
        ENDIF
55      CONTINUE
C
C  VOLUME SOURCE MODEL  71---90
C
      ELSEIF (NLVOL(ISTRA)) THEN
C  SUBSTRATA OF VOLUME SOURCE: IVOLM
        IVOLM=1
        IF (NLIMSQ.GT.1) THEN
          ZV=RANF_EIRENE( )
          DO 71 IVOLM=1,NLIMSQ
            IF (ZV.LT.WMM(IVOLM)) GOTO 72
71        CONTINUE
72        CONTINUE
        ENDIF
        ISECT=IVOLM
        CALL SAMVL1(IVOLM,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
        IF (.NOT.LGPART) RETURN
        NLSTOR=IPANU.LE.ISTOR(ISECT,ISTRA)
        MSURF=0
      ENDIF
C
      IRCELL=NRCELL
      IPCELL=NPCELL
      ITCELL=NTCELL
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
      NSTCLL=NCELL
      NCELLT=NCLTAL(NCELL)
C
C  SAMPLE STARTING TIME
C
      ITMSTP=1
      IF (.NOT.LGTIME) THEN
        TIME=0.
      ELSEIF (LGTIME) THEN
        ISOR=ABS(SORLIM(ISECT,ISTRA))
        INDTEC=IDEZ(ISOR,4,4)
        IF (INDTEC.EQ.0) INDTEC=2
        IF (INDTEC.LE.1) TIME=TIME0
        IF (INDTEC.EQ.2) TIME=TIME0+RANF_EIRENE()*DTIMV
      ENDIF
C
C  INITIAL POSITION OF PARTICLE IS DEFINED NOW, FURTHERMORE:
C    NRCELL,NPCELL,NTCELL,IPOLG,IPERID,NBLOCK,NACELL,
C    AND THE LOCAL BACKGROUND PARAMETERS
C    TEWL,(TIWL(IPLS),DIWL(IPLS),VXWL(IPLS),VYWL(IPLS),VZWL(IPLS),IPLS=1,NPLSI)
C
C    PLUS: WEISPZ FOR SOURCE SPECIES SAMPLING
C          WEISPZ IS THE ANALOG SAMPLING DISTRIBUTION
C          DPLS,DATM,DMOL,DION ARE THE NONANALOG SAMPLING DISTRIBUTIONS
C
C    PLUS: CRTX,CRTY,CRTZ,SCOS
C
C .........................................................................
C
C  FIND TYPE AND SPECIES INDEX AND RELATED CONSTANTS 100---199
C .........................................................................
C
      IF (NLATM(ISTRA)) THEN
        ITYP=1
        IF (NSPEZ(ISTRA).LT.0) THEN
C  CHECK RADON-NIKODYM CONDITION FOR NON-ANALOG SAMPLING
          DO IATM=1,NATMI
            IF (DATD(IATM).LE.0.D0.AND.WEISPZ(IATM).GT.0.D0) THEN
              GOTO 992
            ENDIF
          ENDDO
        ENDIF
C  FIXED SPECIES INDEX
        IATM=NSPEZ(ISTRA)
        IF (IATM.LT.0.OR.IATM.GT.NATMI) THEN
C  SPECIES SAMPLING FROM DATM
          FR=RANF_EIRENE( )
          DO 102 I=1,NATMIM
            IATM=I
            IF (FR.LE.DATM(IATM)) GOTO 101
102       CONTINUE
          IATM=NATMI
101       CONTINUE
          IF (NSPEZ(ISTRA).LT.0) THEN
C  WEIGHT CORRECTION
            DAT=DATD(IATM)
            IF (WEISPZ(IATM).LT.0.D0) GOTO 999
            WEIGHT=WEIGHT*WEISPZ(IATM)/DAT
          ENDIF
        ELSEIF (IATM.EQ.0) THEN
C  ANALOG SPECIES SAMPLING FROM WEISPZ
          FR=RANF_EIRENE( )
          SUMM=0.
          DO 112 I=1,NATMIM
            IATM=I
            IF (WEISPZ(IATM).LT.0.D0) GOTO 999
            SUMM=SUMM+WEISPZ(IATM)
            IF (FR.LE.SUMM) GOTO 111
112       CONTINUE
          IATM=NATMI
111       CONTINUE
        ENDIF
        RSQDV=RSQDVA(IATM)*SQ2I
      ELSEIF (NLMOL(ISTRA)) THEN
        ITYP=2
        IF (NSPEZ(ISTRA).LT.0) THEN
C  CHECK RADON-NIKODYM CONDITION FOR NON-ANALOG SAMPLING
          DO IMOL=1,NMOLI
            IF (DMLD(IMOL).LE.0.D0.AND.WEISPZ(IMOL).GT.0.D0) THEN
              GOTO 992
            ENDIF
          ENDDO
        ENDIF
C  FIXED SPECIES INDEX
        IMOL=NSPEZ(ISTRA)
        IF (IMOL.LT.0.OR.IMOL.GT.NMOLI) THEN
C  NONANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          DO 104 I=1,NMOLIM
            IMOL=I
            IF (FR.LE.DMOL(IMOL)) GOTO 103
104       CONTINUE
          WRITE(0,*) 'DEBUG: LEV.EQ.5 3.00 at 104'
          IMOL=NMOLI
103       CONTINUE
C  WEIGHT CORRECTION
          IF (NSPEZ(ISTRA).LT.0) THEN
            DML=DMLD(IMOL)
            IF (WEISPZ(IMOL).LT.0.D0) GOTO 999
            WEIGHT=WEIGHT*WEISPZ(IMOL)/DML
          ENDIF
        ELSEIF (IMOL.EQ.0) THEN
C  ANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          SUMM=0.
          DO 114 I=1,NMOLIM
            IMOL=I
            IF (WEISPZ(IMOL).LT.0.D0) GOTO 999
            SUMM=SUMM+WEISPZ(IMOL)
            IF (FR.LE.SUMM) GOTO 113
114       CONTINUE
          IMOL=NMOLI
113       CONTINUE
        ENDIF
        RSQDV=RSQDVM(IMOL)*SQ2I
      ELSEIF (NLION(ISTRA)) THEN
        ITYP=3
        IF (NSPEZ(ISTRA).LT.0) THEN
C  CHECK RADON-NIKODYM CONDITION FOR NON-ANALOG SAMPLING
          DO IION=1,NIONI
            IF (DIOD(IION).LE.0.D0.AND.WEISPZ(IION).GT.0.D0) THEN
              GOTO 992
            ENDIF
          ENDDO
        ENDIF
C  FIXED SPECIES INDEX
        IION=NSPEZ(ISTRA)
        IF (IION.LT.0.OR.IION.GT.NIONI) THEN
C  NONANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          DO 106 I=1,NIONIM
            IION=I
            IF (FR.LE.DION(IION)) GOTO 105
106       CONTINUE
          IION=NIONI
105       CONTINUE
C  WEIGHT CORRECTION
          IF (NSPEZ(ISTRA).LT.0) THEN
            DIO=DIOD(IION)
            IF (WEISPZ(IION).LT.0.D0) GOTO 999
            WEIGHT=WEIGHT*WEISPZ(IION)/DIO
          ENDIF
        ELSEIF (IION.EQ.0) THEN
C  ANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          SUMM=0.
          DO 116 I=1,NIONIM
            IION=I
            IF (WEISPZ(IION).LT.0.D0) GOTO 999
            SUMM=SUMM+WEISPZ(IION)
            IF (FR.LE.SUMM) GOTO 115
116       CONTINUE
          IION=NIONI
115       CONTINUE
        ENDIF
        RSQDV=RSQDVI(IION)*SQ2I
      ELSEIF (NLPLS(ISTRA)) THEN
        ITYP=4
        IF (NSPEZ(ISTRA).LT.0) THEN
C  CHECK RADON-NIKODYM CONDITION FOR NON-ANALOG SAMPLING
          DO IPLS=1,NPLSI
            IF (DPLD(IPLS).LE.0.D0.AND.WEISPZ(IPLS).GT.0.D0) THEN
              GOTO 992
            ENDIF
          ENDDO
        ENDIF
C
C  FIXED SPECIES INDEX
        IPLS=NSPEZ(ISTRA)
        IF (IPLS.LT.0.OR.IPLS.GT.NPLSI) THEN
C  NONANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          DO 108 I=1,NPLSIM
            IPLS=I
            IF (FR.LE.DPLS(IPLS)) GOTO 107
108       CONTINUE
          IPLS=NPLSI
107       CONTINUE
C  WEIGHT CORRECTION
          IF (NSPEZ(ISTRA).LT.0) THEN
            DPL=DPLD(IPLS)
            IF (WEISPZ(IPLS).LT.0.D0) GOTO 999
            WEIGHT=WEIGHT*WEISPZ(IPLS)/DPL
          ENDIF
        ELSEIF (IPLS.EQ.0) THEN
C  ANALOG SPECIES SAMPLING
          FR=RANF_EIRENE( )
          SUMM=0.
          DO 118 I=1,NPLSIM
            IPLS=I
            IF (WEISPZ(IPLS).LT.0.D0) GOTO 999
            SUMM=SUMM+WEISPZ(IPLS)
            IF (FR.LE.SUMM) GOTO 117
118       CONTINUE
          IPLS=NPLSI
117       CONTINUE
        ENDIF
        RSQDV=RSQDVP(IPLS)*SQ2I
      ELSEIF(NLPHOT(ISTRA)) THEN
        ITYP=0
        IF (NSPEZ(ISTRA).LT.0) THEN
C  CHECK RADON-NIKODYM CONDITION FOR NON-ANALOG SAMPLING
          DO IPHOT=1,NPHOTI
            IF (DPHD(IPHOT).LE.0.D0.AND.WEISPZ(IPHOT).GT.0.D0) THEN
              GOTO 992
            ENDIF
          ENDDO
        ENDIF
C  FIXED SPECIES INDEX
        IPHOT=NSPEZ(ISTRA)
        IF (IPHOT.LT.0.OR.IPHOT.GT.NPHOTI) THEN
C  SPECIES SAMPLING FROM DPHOT
          FR=RANF_EIRENE( )
          DO 1021 I=1,NPHOTIM
            IPHOT=I
            IF (FR.LE.DPHOT(IPHOT)) GOTO 1011
1021      CONTINUE
          IPHOT=NPHOTI
1011      CONTINUE
          IF (NSPEZ(ISTRA).LT.0) THEN
C  WEIGHT CORRECTION
            DPH=DPHD(IPHOT)
            IF (WEISPZ(IPHOT).LT.0.D0) GOTO 999
            WEIGHT=WEIGHT*WEISPZ(IPHOT)/DPH
          ENDIF
        ELSEIF (IPHOT.EQ.0) THEN
C  ANALOG SPECIES SAMPLING FROM WEISPZ
          FR=RANF_EIRENE( )
          SUMM=0.
          DO 1121 I=1,NPHOTIM
            IPHOT=I
            IF (WEISPZ(IPHOT).LT.0.D0) GOTO 999
            SUMM=SUMM+WEISPZ(IPHOT)
            IF (FR.LE.SUMM) GOTO 1111
1121      CONTINUE
          IPHOT=NPHOTI
1111      CONTINUE
        ENDIF
        RSQDV=0.
csw end branch
      ENDIF
C
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C  .............................................................
C
C  SPECIES SAMPLING DONE
C  .............................................................
C
C  MAKE SURE NOT TO WASTE TIME IN PARTICLES WITH ZERO WEIGHT
C
      LGPART=WEIGHT.GT.0.D0
      IF (.NOT.LGPART) RETURN
C
C  PARAMETERS FOR VELOCITY SAMPLING DISTRIBUTION:
C  TEWD,TIWD,VXWD,VYWD,VZDW
C
      IF (NEMOD2.EQ.1) THEN
C  SET SAMPLING TEMPERATURES FROM FIXED INPUT DATA
        TIWD=ABS(SORENI(ISTRA))
        TEWD=ABS(SORENE(ISTRA))
      ELSEIF (NEMOD2.EQ.2) THEN
C  NOT IN USE
      ELSEIF (NEMOD2.EQ.3) THEN
C  SET SAMPLING TEMPERATURES FROM LOCAL PLASMA DATA FOR SPECIES IPLTI
        IPLTI=NEMDSP
        IF (IPLTI.LT.1.OR.IPLTI.GT.NPLSI) GOTO 999
        TIWD=TIWL(IPLTI)
        TEWD=TEWL
      ELSE
C  DEFAULT: ONLY FOR NLPLS=TRUE, OR NLION=TRUE
C  SET SAMPLING TEMPERATURES FROM LOCAL PLASMA DATA FOR SPECIES IPLS
        TEWD=TEWL
        IF (NLPLS(ISTRA)) THEN
          IPL=IPLS
          TIWD=TIWL(IPL)
        ELSEIF (NLION(ISTRA)) THEN
          TIWD=0.
          DO IPP=1,NPLSI
            IF (NMASSI(IION).EQ.NMASSP(IPP).AND.
     .          NCHARI(IION).EQ.NCHARP(IPP).AND.
     .          NCHRGI(IION).EQ.NCHRGP(IPP)) THEN
              IPL=IPP
              TIWD=TIWL(IPL)
            ENDIF
          ENDDO
        ELSE
C  SET SAMPLING ION-TEMPERATURE TO ZERO
          TIWD=0.
        ENDIF
      ENDIF
C
      IF (NEMOD3.EQ.1) THEN
C  SET SAMPLING DRIFT VELOCITIES FROM INPUT DATA FOR DRIFT VELOCITY
        VXWD=SORVDX(ISTRA)
        VYWD=SORVDY(ISTRA)
        VZWD=SORVDZ(ISTRA)
      ELSEIF (NEMOD3.EQ.2) THEN
C  SET SAMPLING DRIFT VELOCITIES FROM INPUT DATA FOR MACH NUMBER
        CS=SQRT(1.*TIWD+TEWD)*RSQDV
        VXWD=SORVDX(ISTRA)*CS
        VYWD=SORVDY(ISTRA)*CS
        VZWD=SORVDZ(ISTRA)*CS
      ELSEIF (NEMOD3.EQ.3) THEN
        IPLV=NEMDSP
        IF (IPLV.LT.1.OR.IPLV.GT.NPLSI) GOTO 999
        VXWD=VXWL(IPLV)
        VYWD=VYWL(IPLV)
        VZWD=VZWL(IPLV)
      ELSE
C  DEFAULT: ONLY FOR NLPLS=TRUE, OR NLION=TRUE
C  SET SAMPLING DRIFT VELOCITIES FROM BACKGROUND DATA FOR SPECIES IPL
        IF (NLPLS(ISTRA)) THEN
          IPL=IPLS
          VXWD=VXWL(IPL)
          VYWD=VYWL(IPL)
          VZWD=VZWL(IPL)
        ELSEIF (NLION(ISTRA)) THEN
          VXWD=0.
          VYWD=0.
          VZWD=0.
          DO IPP=1,NPLSI
            IF (NMASSI(IION).EQ.NMASSP(IPP).AND.
     .          NCHARI(IION).EQ.NCHARP(IPP).AND.
     .          NCHRGI(IION).EQ.NCHRGP(IPP)) THEN
              IPL=IPP
              VXWD=VXWL(IPL)
              VYWD=VYWL(IPL)
              VZWD=VZWL(IPL)
            ENDIF
          ENDDO
        ELSE
          VXWD=0.
          VYWD=0.
          VZWD=0.
        ENDIF
      ENDIF
C
C  .....................................
C
C  FIND VELOCITY VECTOR NEXT
C  .....................................
C
C  PURELY ATOMIC SOURCE?  200 --- 299
C
      IF (NLATM(ISTRA)) THEN
        IF (NEMOD1.EQ.1) THEN
          EMAX=SORENI(ISTRA)
        ELSEIF (NEMOD1.EQ.6) THEN
          EMAX=0.
        ELSE
          GOTO 998
        ENDIF

        LOGATM(IATM,ISTRA)=.TRUE.
        IF (EMAX.GT.0) THEN
          E0=EMAX
          VEL=SQRT(E0)*RSQDVA(IATM)
C
C  COSINE LIKE OR GAUSSIAN ANGLE DISTRIBUTION
C
C  IN CASE (CRTX,CRTY,CRTZ) NE (0.,0.,0.)
C  USE REFLECTION MODEL ANGULAR DISTRIBUTION
          VELX=CRTX
          VELY=CRTY
          VELZ=CRTZ
          CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C         VEL_MEAN=VEL
C         E0_MEAN=E0
        ELSEIF (EMAX.LE.0.D0.AND..NOT.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM SHIFTED TRUNCATED MAXWELLIAN FLUX
C              AROUND INNER (!) NORMAL AT TEMP. TW (EV) = TIWD
          IF (TIWD.LE.0.) TIWD=ABS(EMAX)
          VWD=SQRT(VXWD**2+VYWD**2+VZWD**2)
          CALL VELOCS (TIWD,0._DP,VWD,VXWD,VYWD,VZWD,RSQDVA(IATM),
     .                 CVRSSA(IATM),
     .                 -CRTX,-CRTY,-CRTZ,E0,VELX,VELY,VELZ,VEL)
C  MODIFY ANGULAR DISTRIBUTION IN CASE SORCOS .NE. 0.5 (I.E., IN CASE
C  A NON-COSINE DISTRIBUTION IS REQUESTED
          IF (ABS(SORCOS(ISTRA)-0.5).GT.1.D-5) THEN
            VELX=CRTX
            VELY=CRTY
            VELZ=CRTZ
            CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                  SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C           VEL_MEAN=VEL
C           E0_MEAN=E0
          ENDIF
        ELSEIF (EMAX.LE.0..AND.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM MAXWELLIAN AT TEMP. TW (EV) =TIWD
C
          IF (TIWD.LE.0.) TIWD=ABS(EMAX)
          NFLAG=2
          IDUM=1
          DUMT(1)=SQRT(TIWD/RMASSA(IATM))*CVEL2A
          DUMT(2)=DUMT(1)
          DUMT(3)=DUMT(1)
          DUMV(1)=0
          DUMV(2)=0
          DUMV(3)=0
          CALL VELOCX(0,VXO,VYO,VZO,VO,IO,NO,VELQ,NFLAG,
     .                IDUM,DUMT,DUMV)
          E0=VELQ*CVRSSA(IATM)
C         E0_MEAN=1.5*TIWD+0.
        ELSE
          GOTO 998
        ENDIF
C
        WTOTA(IATM,ISTRA)=WTOTA(IATM,ISTRA)+WEIGHT
        ETOTA(ISTRA)=ETOTA(ISTRA)+E0*WEIGHT
        IF (NADSI.GE.1.AND.NLSRF(ISTRA)) CALL UPSUSR(WEIGHT,2)
        IF (NADSPC.GE.1.AND.NLSRF(ISTRA)) CALL CALC_SPECTRUM(WEIGHT,2,0)
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
        IF (NLSTOR) CALL STORE(1)
C
C  PURELY MOLECULAR SOURCE?  300 --- 399
C
      ELSEIF (NLMOL(ISTRA)) THEN
C
        IF (NEMOD1.EQ.1) THEN
          EMAX=SORENI(ISTRA)
        ELSEIF (NEMOD1.EQ.6) THEN
          EMAX=0.
        ELSE
          GOTO 998
        ENDIF
C
        LOGMOL(IMOL,ISTRA)=.TRUE.
        IF (EMAX.GT.0.D0) THEN
C  MONOENERGETIC DISTRIBUTION
          E0=EMAX
          VEL=RSQDVM(IMOL)*SQRT(E0)
C
C  COSINE LIKE OR GAUSSIAN ANGLE DISTRIBUTION
C
C  IN CASE (CRTX,CRTY,CRTZ) NE (0.,0.,0.)
C  USE REFLECTION MODEL ANGULAR DISTRIBUTION
          VELX=CRTX
          VELY=CRTY
          VELZ=CRTZ
          CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C         VEL_MEAN=VEL
C         E0_MEAN=E0
        ELSEIF (EMAX.LE.0..AND.TIWD.GT.0..AND..NOT.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM SHIFTED TRUNCATED MAXWELLIAN FLUX
C              AROUND INNER (!) NORMAL AT TEMP. TIWL
C
          VWD=SQRT(VXWD**2+VYWD**2+VZWD**2)
          CALL VELOCS (TIWD,0._DP,VWD,VXWD,VYWD,VZWD,RSQDVM(IMOL),
     .                 CVRSSM(IMOL),
     .                 -CRTX,-CRTY,-CRTZ,E0,VELX,VELY,VELZ,VEL)
C  MODIFY ANGULAR DISTRIBUTION IN CASE SORCOS .NE. 0.5 (I.E., IN CASE
C  A NON-COSINE DISTRIBUTION IS REQUESTED
          IF (ABS(SORCOS(ISTRA)-0.5).GT.1.D-5) THEN
            VELX=CRTX
            VELY=CRTY
            VELZ=CRTZ
            CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                  SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C           VEL_MEAN=VEL
C           E0_MEAN=E0
          ENDIF
        ELSEIF (EMAX.LE.0..AND.TIWD.GT.0..AND.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM MAXWELLIAN AT TEMP. TW (EV) =TIWD
C
          IF (TIWD.LE.0.) TIWD=ABS(EMAX)
          NFLAG=2
          IDUM=1
          DUMT(1)=SQRT(TIWD/RMASSM(IMOL))*CVEL2A
          DUMT(2)=DUMT(1)
          DUMT(3)=DUMT(1)
          DUMV(1)=0
          DUMV(2)=0
          DUMV(3)=0
          CALL VELOCX(0,VXO,VYO,VZO,VO,IO,NO,VELQ,NFLAG,
     .                IDUM,DUMT,DUMV)
          E0=VELQ*CVRSSM(IMOL)
C         E0_MEAN=1.5*TIWD+0.
        ELSE
          GOTO 998
        ENDIF
C
        WTOTM(IMOL,ISTRA)=WTOTM(IMOL,ISTRA)+WEIGHT
        ETOTM(ISTRA)=ETOTM(ISTRA)+WEIGHT*E0
        IF (NADSI.GE.1) CALL UPSUSR(WEIGHT,2)
        IF (NADSPC.GE.1) CALL CALC_SPECTRUM(WEIGHT,2,0)
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
        IF (NLSTOR) CALL STORE(1)
C
C  PURELY TEST IONIC SOURCE?  400 --- 499
C
      ELSEIF (NLION(ISTRA)) THEN
C
        IF (NEMOD1.EQ.1) THEN
          EMAX=SORENI(ISTRA)
        ELSEIF (NEMOD1.EQ.2.OR.NEMOD1.EQ.3) THEN
          EMAX=SORENI(ISTRA)*TIWD+SORENE(ISTRA)*TEWD
        ELSEIF (NEMOD1.EQ.4.OR.NEMOD1.EQ.5) THEN
          VPERP=VXWD*CRTX+VYWD*CRTY+VZWD*CRTZ
          IF (VPERP.GT.0.D0) GOTO 996
          VPARX=VXWD-VPERP*CRTX
          VPARY=VYWD-VPERP*CRTY
          VPARZ=VZWD-VPERP*CRTZ
          VPAR=SQRT(VPARX**2+VPARY**2+VPARZ**2)
          VTERM=SQRT(TIWD/RMASSI(IION))*CVELAA
          VPERP=VPERP/VTERM
          VPAR=VPAR/VTERM
          EMAX=EMAXW(TIWD,VPERP,VPAR)
        ELSEIF (NEMOD1.EQ.6.OR.NEMOD1.EQ.7) THEN
          EMAX=0.
        ELSEIF (NEMOD1.EQ.8.OR.NEMOD1.EQ.9) THEN
          EMAX=0.
C         EMAX=EFWL   to be written: find proper species index for efwl
        ELSE
          GOTO 998
        ENDIF
C
        IF (NEMOD1.EQ.3.OR.NEMOD1.EQ.5.OR.
     .      NEMOD1.EQ.7.OR.NEMOD1.EQ.9)   THEN
C  SET ELECTROSTATIC SHEATH ACCELERATION ENERGY "ESHET", eV
          IF (SHWL.GT.0.) THEN
            ESHET=NCHRGI(IION)*SHWL*TEWL
          ELSE
C  SHEATH POTENTIAL NOT YET SET IN SAMSRF. TRY TO FIND IT NOW
            IF (FSHEAT(MSURF).LE.0.D0) THEN
              GAMMA=0.
              CUR=0.
              DO IP=1,NPLSI
                VPWL(IP)=SQRT(VXWL(IP)**2+VYWL(IP)**2+VZWL(IP)**2)
                DIWL(IP)=DIWL(IP)
              ENDDO
              ESHET=NCHRGI(IION)*SHEATH(TEWL,DIWL,VPWL,
     .                                  NCHRGP,GAMMA,CUR,NPLSI,MSURF)
            ELSE
              ESHET=NCHRGI(IION)*FSHEAT(MSURF)*TEWL
            ENDIF

          ENDIF
C   NO SHEATH POTENTIAL TO BE ADDED
        ELSE
          ESHET=0.
        ENDIF

        LOGION(IION,ISTRA)=.TRUE.
        IF (EMAX.GT.0.D0) THEN
C  CONSTANT VELOCITY 
          E0=EMAX
          VEL=SQRT(E0)*RSQDVI(IION)
C
C  COSINE LIKE OR GAUSSIAN ANGLE DISTRIBUTION
C
C  IN CASE (CRTX,CRTY,CRTZ) NE (0.,0.,0.D0)
C  USE REFLECTION MODEL ANGULAR DISTRIBUTION
          VELX=CRTX
          VELY=CRTY
          VELZ=CRTZ
          CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C         VEL_MEAN=VEL
C         E0_MEAN=E0
        ELSEIF (EMAX.LE.0..AND.TIWD.GT.0..AND..NOT.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM SHIFTED TRUNCATED MAXWELLIAN FLUX
C              AROUND INNER (!) NORMAL AT TEMP. TW (EV)
          VWD=SQRT(VXWD**2+VYWD**2+VZWD**2)
          CALL VELOCS (TIWD,0._DP,VWD,VXWD,VYWD,VZWD,RSQDVI(IION),
     .                  CVRSSI(IION),
     .                 -CRTX,-CRTY,-CRTZ,E0,VELX,VELY,VELZ,VEL)
C  MODIFY ANGULAR DISTRIBUTION IN CASE SORCOS .NE. 0.5 (I.E., IN CASE
C  A NON-COSINE DISTRIBUTION IS REQUESTED
          IF (ABS(SORCOS(ISTRA)-0.5).GT.EPS10) THEN
            VELX=CRTX
            VELY=CRTY
            VELZ=CRTZ
            CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                  SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
          ENDIF
        ELSEIF (EMAX.LE.0..AND.TIWD.GT.0..AND.NLVOL(ISTRA)) THEN
C
C  SAMPLE FROM MAXWELLIAN AT TEMP. TW (EV) =TIWD
C
          IF (TIWD.LE.0.) TIWD=ABS(EMAX)
          NFLAG=2
          IDUM=1
          DUMT(1)=SQRT(TIWD/RMASSI(IION))*CVEL2A
          DUMT(2)=DUMT(1)
          DUMT(3)=DUMT(1)
          DUMV(1)=0
          DUMV(2)=0
          DUMV(3)=0
          CALL VELOCX(0,VXO,VYO,VZO,VO,IO,NO,VELQ,NFLAG,
     .                IDUM,DUMT,DUMV)
          E0=VELQ*CVRSSI(IION)
        ELSE
          GOTO 998
        ENDIF
C
        WTOTI(IION,ISTRA)=WTOTI(IION,ISTRA)+WEIGHT
        ETOTI(ISTRA)=ETOTI(ISTRA)+E0*WEIGHT
        IF (NADSI.GE.1) CALL UPSUSR(WEIGHT,2)
        IF (NADSPC.GE.1) CALL CALC_SPECTRUM(WEIGHT,2,0)
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
        IF (NLSTOR) CALL STORE(1)
C
C  PURELY BULK IONIC SOURCE?   500  ---  599
C
C  SOURCE DEFINED BY PRE COLLISION RATE OF BULK PARTICLES
C  THE RESULTING TEST PARTICLES MAY BE EITHER ATOMS, MOLECULES OR TEST
C  IONS. IN THIS CASE NOT THE TOTAL TEST PARTICLE FLUX BUT THE
C  THE TOTAL BULK ION FLUX IS SCALED TO A PRESCRIBED VALUE
C
C  SET ENERGY OF THE INCIDENT BULK ION : EMAX
C  IF EMAX=0, SAMPLE FROM SHIFTED TRUNCATED MAXWELLIAN
C  (ADD SHEATH CONTRIBUTION ESHET IF REQUESTED)
C
      ELSEIF (NLPLS(ISTRA)) THEN
C
        IF (NLSRF(ISTRA)) THEN
C
          IF (NEMOD1.EQ.1) THEN
            EMAX=SORENI(ISTRA)
          ELSEIF (NEMOD1.EQ.2.OR.NEMOD1.EQ.3) THEN
            EMAX=SORENI(ISTRA)*TIWD+SORENE(ISTRA)*TEWD
          ELSEIF (NEMOD1.EQ.4.OR.NEMOD1.EQ.5) THEN
            VPERP=VXWD*CRTX+VYWD*CRTY+VZWD*CRTZ
            IF (VPERP.LT.0.D0) GOTO 996
            VPARX=VXWD-VPERP*CRTX
            VPARY=VYWD-VPERP*CRTY
            VPARZ=VZWD-VPERP*CRTZ
            VPAR=SQRT(VPARX**2+VPARY**2+VPARZ**2)
            VTERM=SQRT(TIWD/RMASSP(IPLS))*CVELAA
            VPERP=VPERP/VTERM
            VPAR=VPAR/VTERM
            EMAX=EMAXW(TIWD,VPERP,VPAR)
          ELSEIF (NEMOD1.EQ.6.OR.NEMOD1.EQ.7) THEN
            EMAX=0.
          ELSEIF (NEMOD1.EQ.8.OR.NEMOD1.EQ.9) THEN
            EMAX=EFWL(IPLS)
          ELSE
            GOTO 998
          ENDIF
C
          IF (NEMOD1.EQ.3.OR.NEMOD1.EQ.5.OR.
     .      NEMOD1.EQ.7.OR.NEMOD1.EQ.9)   THEN
C  SET ELECTROSTATIC SHEATH ACCELERATION ENERGY "ESHET", eV
            IF (SHWL.GT.0.) THEN
              ESHET=NCHRGP(IPLS)*SHWL*TEWL
            ELSE
C  SHEATH POTENTIAL NOT YET SET IN SAMSRF. TRY TO FIND IT NOW                 
              IF (FSHEAT(MSURF).LE.0.D0) THEN
                GAMMA=0.
                CUR=0.
                DO 550 IP=1,NPLSI
                  VPWL(IP)=SQRT(VXWL(IP)**2+VYWL(IP)**2+VZWL(IP)**2)
C                 DIWL(IP)=DIWL(IP)
550             CONTINUE
                ESHET=NCHRGP(IPLS)*SHEATH(TEWL,DIWL,VPWL,
     .                                  NCHRGP,GAMMA,CUR,NPLSI,MSURF)
              ELSE
                ESHET=NCHRGP(IPLS)*FSHEAT(MSURF)*TEWL
              ENDIF
C
            ENDIF
          ELSE
C   NO SHEATH POTENTIAL TO BE ADDED
            ESHET=0.
          ENDIF
C
          CRTX=-CRTX
          CRTY=-CRTY
          CRTZ=-CRTZ
C
          LOGPLS(IPLS,ISTRA)=.TRUE.
          IF (EMAX.GT.0.D0) THEN
C  CONSTANT VELOCITY 
            E0=EMAX+ESHET
            VEL=SQRT(E0)*RSQDVP(IPLS)
C
C  COSINE LIKE OR GAUSSIAN ANGLE DISTRIBUTION
C
C  IN CASE (CRTX,CRTY,CRTZ) NE (0.,0.,0.D0)
C  USE REFLECTION MODEL ANGULAR DISTRIBUTION
            VELX=CRTX
            VELY=CRTY
            VELZ=CRTZ
C  TRUNCATED COSINE DISTRIBUTION ONTO WALL
            CALL REFANG(SORCOS(ISTRA),SORMAX(ISTRA),SORCTX(ISTRA),
     .                  SORCTY(ISTRA),SORCTZ(ISTRA),NAMODS(ISTRA),SNORM)
C           E0_MEAN=E0
C           VEL_MEAN=VEL
          ELSEIF (EMAX.LE.0.D0.AND.TIWD.GT.0.D0) THEN
C  SAMPLE FROM SHIFTED TRUNCATED MAXWELLIAN FLUX AND ACCELERATE IN SHEATH
            VWD=SQRT(VXWD**2+VYWD**2+VZWD**2)
            CALL VELOCS(TIWD,ESHET,VWD,VXWD,VYWD,VZWD,RSQDVP(IPLS),
     .                  CVRSSP(IPLS),
     .                  -CRTX,-CRTY,-CRTZ,E0,VELX,VELY,VELZ,VEL)
          ELSE
            GOTO 998
          ENDIF
C
          CRTX=-CRTX
          CRTY=-CRTY
          CRTZ=-CRTZ
C
C  A BULK ION, HITTING A SURFACE, HAS BEEN CREATED.
C
C  UPDATE PARTICLE EFFLUX  ONTO SURFACE MSURF
C  UPDATE ENERGY FLUX ONTO SURFACE MSURF
C
C  SPATIAL RESOLUTION ON NON DEFAULT STANDARD SURFACE?
C  FIND MSURFG, THE POSITION FOR STORING THE LOCAL FLUX ON THE
C               SURFACE AVERAGED TALLY ARRAYS
C  FIND FLX:  THE FLUX TO THIS SURFACE ELEMENT TO BE USED FOR
C             CHEMICAL SPUTTERING LFUX DEPENDENCE
          IF (MSURF.GT.NLIM.AND.NLMPGS.GT.NLIMPS) THEN
            IF (LEVGEO.LE.3) THEN
              ISTS=MSURF-NLIM
              IF (INUMP(ISTS,1).NE.0) MSURFG=NPCELL+(NTCELL-1)*NP2T3
              IF (INUMP(ISTS,2).NE.0) MSURFG=NRCELL+(NTCELL-1)*NR1P2
              IF (INUMP(ISTS,3).NE.0) MSURFG=NRCELL+(NPCELL-1)*NR1P2
              MSURFG=NLIM+NSTS+MSURFG+(ISTS-1)*NGITT
              FLX=FLXOUT(MSURFG)
            ELSE IF (LEVGEO.EQ.4) THEN
              MSURFG=NLIM+NSTS+INSPAT(IPOLG,MRSURF)
              FLX=FLXOUT(MSURFG)
            ELSE
              MSURFG=0
              FLX=FLXOUT(MSURF)
            END IF
          ELSEIF (MSURF.GT.0) THEN
            MSURFG=0
            FLX=FLXOUT(MSURF)
          ELSE
            MSURFG=0
            FLX=0
          ENDIF

C  WTOTP, ETOTP: INTEGRAL FLUXES FOR SCALING
          WTOTP(IPLS,ISTRA)=WTOTP(IPLS,ISTRA)-WEIGHT
          ETOTP(ISTRA)=ETOTP(ISTRA)-E0*WEIGHT
C  NEW (2004) VOLUME AVERAGED TALLIES
C  PPPL, EPPL AND THEIR INTEGRALS: ALSO FOR GLOBAL PARTICLE BALANCE
          IF (LPPPL) PPPL(IPLS,NCELLT)=PPPL(IPLS,NCELLT)-WEIGHT
          IF (LEPPL) EPPL(NCELLT)=EPPL(NCELLT)-E0*WEIGHT
C  SURFACE AVERAGED TALLIES (NOTE: FLUXES HERE COUNTED POSITIVE,
C                            BUT INTEGRALS OF OUTGOING SURFACE FLUXES
C                            POTPLI,... ARE TAKEN NEGATIVE).
C  POTPL,EOTPL,....FOR PRINTOUT OF SURFACE FLUXES
          IF (MSURF.GT.0) THEN
            IF (LPOTPL) POTPL(IPLS,MSURF)=POTPL(IPLS,MSURF)+WEIGHT
            IF (LEOTPL) EOTPL(IPLS,MSURF)=EOTPL(IPLS,MSURF)+WEIGHT*E0
            IF (MSURFG.GT.0) THEN
              IF (LPOTPL) POTPL(IPLS,MSURFG)=POTPL(IPLS,MSURFG)+WEIGHT
              IF (LEOTPL)
     .          EOTPL(IPLS,MSURFG)=EOTPL(IPLS,MSURFG)+E0*WEIGHT
            ENDIF
          ENDIF
          IF (NADSI.GE.1) CALL UPSUSR(-WEIGHT,1)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM(-WEIGHT,1,0)
C
          IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
          IF (NLSTOR) CALL STORE(2)
C
C  REFLECT THIS ION AS TEST PARTICLE FROM SURFACE NO. MSURF
C
C  BUT FIRST: CALL SPUTTER MODEL IF REQUESTED
C
          FMASS=DBLE(NMASSP(IPLS))
          FCHAR=DBLE(NCHARP(IPLS))
C
          WGHTSP=0.
          WGHTSC=0.
          YIELD1=0.
          YIELD2=0.
          ISSPTP=0
          ISSPTC=0
C
          NLSPUT=.FALSE.
          IF (ILSPT(MSURF).NE.0) THEN
C  SAVE INCIDENT PARTICLE'S SPEED AND ENERGY
            E0S=E0
            WEIGHS=WEIGHT
            VELS=VEL
            VELXS=VELX
            VELYS=VELY
            VELZS=VELZ
            ISPZS=ISPZ
C
            CALL SPUTR1(WMINS,FMASS,FCHAR,FLX,
     .                  ISRS(ISPZ,MSURF),
     .                  YIELD1,
     .                  ISSPTP,ESPTP,VSPTP,VXSPTP,VYSPTP,VZSPTP,
     .                  ISRC(ISPZ,MSURF),
     .                  YIELD2,
     .                  ISSPTC,ESPTC,VSPTC,VXSPTC,VYSPTC,VZSPTC)
            NLSPUT=YIELD1.GT.0..OR.YIELD2.GT.0.
            WGHTSP=WEIGHT*YIELD1
            WGHTSC=WEIGHT*YIELD2
C
C  UPDATE SPUTTER SURFACE TALLIES
C
            IF (LSPTPL)
     .        SPTPL(IPLS,MSURF)=SPTPL(IPLS,MSURF)+WGHTSP+WGHTSC
            IF (LSPTTOT)
     .        SPTTOT(MSURF)=SPTTOT(MSURF)+WGHTSP+WGHTSC
            IF (MSURFG.GT.0) THEN
              IF (LSPTPL)
     .          SPTPL(IPLS,MSURFG)=SPTPL(IPLS,MSURFG)+WGHTSP+WGHTSC
              IF (LSPTTOT)
     .          SPTTOT(MSURFG)=SPTTOT(MSURFG)+WGHTSP+WGHTSC
            ENDIF
          ENDIF
C
C  PHYSICAL SPUTTERING
C
          IF (WGHTSP.GT.0..AND.ISSPTP.GT.0) THEN
C  FOLLOW SPUTTERED PARTICLES LATER. PUT THEM INTO STATISTICAL CELLAR
C
            ISPZ=ISSPTP
            ITYP=ISPEZI(ISPZ,-1)
            IPHOT=ISPEZI(ISPZ,0)
            IATM=ISPEZI(ISPZ,1)
            IMOL=ISPEZI(ISPZ,2)
            IION=ISPEZI(ISPZ,3)
            IPLS=ISPEZI(ISPZ,4)
            E0=ESPTP
            WEIGHT=WGHTSP
            VEL=VSPTP
            VELX=VXSPTP
            VELY=VYSPTP
            VELZ=VZSPTP
C
C.....................................................................
C  SPLITTING
C
            NLEVEL=NLEVEL+1
C  SAVE LOCATION, WEIGHT AND OTHER PARAMETERS AT CURRENT LEVEL
            DO 533 J=1,NPARTC
              RSPLST(NLEVEL,J)=RPST(J)
533         CONTINUE
            DO 534 J=1,MPARTC
              ISPLST(NLEVEL,J)=IPST(J)
534         CONTINUE
C  NUMBER OF NODES AT THIS LEVEL
            NODES(NLEVEL)=2
C
C  SPLITTING DONE. NEXT: SURFACE TALLIES AND VOLUME TALLIES
C.....................................................................
C
            IF (NLTRC.AND.TRCHST) THEN
              WRITE (iunout,*) 'AFTER SUBR. SPUTER: PHYS. SPUTTERING'
              WRITE (iunout,'(1X,A8)') TEXTS(ISPZ)
              CALL MASR1('YIELDP  ',YIELD1)
              CALL MASR6 (
     .           'VELX,VELY,VELZ,VEL,E0,WEIGHT                    ',
     .            VELX,VELY,VELZ,VEL,E0,WEIGHT)
            ENDIF
C
            IF (ITYP.EQ.1) THEN
              LOGATM(IATM,ISTRA)=.TRUE.
              IF (LPPAT) PPAT(IATM,NCELLT)=PPAT(IATM,NCELLT)+WEIGHT
              IF (LEPAT) EPAT(NCELLT)=EPAT(NCELLT)+E0*WEIGHT
            ELSEIF (ITYP.EQ.2) THEN
              LOGMOL(IMOL,ISTRA)=.TRUE.
              IF (LPPML) PPML(IMOL,NCELLT)=PPML(IMOL,NCELLT)+WEIGHT
              IF (LEPML) EPML(NCELLT)=EPML(NCELLT)+E0*WEIGHT
            ELSEIF (ITYP.EQ.3) THEN
              LOGION(IION,ISTRA)=.TRUE.
              IF (LPPIO) PPIO(IION,NCELLT)=PPIO(IION,NCELLT)+WEIGHT
              IF (LEPIO) EPIO(NCELLT)=EPIO(NCELLT)+E0*WEIGHT
            ENDIF
            ITOLD = 4
            CALL UPDATE_SURFACE (ITOLD)
            IF (NADSI.GE.1) CALL UPSUSR(WEIGHT,2)
            IF (NADSPC.GE.1) CALL CALC_SPECTRUM(WEIGHT,2,0)
          ENDIF
C
C  CHEMICAL SPUTTERING
C
          IF (WGHTSC.GT.0..AND.ISSPTC.GT.0) THEN
C  FOLLOW SPUTTERED PARTICLES LATER. PUT THEM INTO STATISTICAL CELLAR
            ISPZ=ISSPTC
            ITYP=ISPEZI(ISPZ,-1)
            IPHOT=ISPEZI(ISPZ,0)
            IATM=ISPEZI(ISPZ,1)
            IMOL=ISPEZI(ISPZ,2)
            IION=ISPEZI(ISPZ,3)
            IPLS=ISPEZI(ISPZ,4)
            E0=ESPTC
            WEIGHT=WGHTSC
            VEL=VSPTC
            VELX=VXSPTC
            VELY=VYSPTC
            VELZ=VZSPTC
C
C.....................................................................
C  SPLITTING
C
            NLEVEL=NLEVEL+1
C  SAVE LOCATION, WEIGHT AND OTHER PARAMETERS AT CURRENT LEVEL
            DO 535 J=1,NPARTC
              RSPLST(NLEVEL,J)=RPST(J)
535         CONTINUE
            DO 536 J=1,MPARTC
              ISPLST(NLEVEL,J)=IPST(J)
536         CONTINUE
C  NUMBER OF NODES AT THIS LEVEL
            NODES(NLEVEL)=2
C
C  SPLITTING DONE. NEXT: SURFACE TALLIES AND VOLUME TALLIES
C.....................................................................
C
            IF (NLTRC.AND.TRCHST) THEN
              WRITE (iunout,*) 'AFTER SUBR. SPUTER: CHEM. SPUTTERING'
              WRITE (iunout,'(1X,A8)') TEXTS(ISPZ)
              CALL MASR1('YIELDC  ',YIELD2)
              CALL MASR6 (
     .           'VELX,VELY,VELZ,VEL,E0,WEIGHT                    ',
     .            VELX,VELY,VELZ,VEL,E0,WEIGHT)
            ENDIF
C
            IF (ITYP.EQ.1) THEN
              LOGATM(IATM,ISTRA)=.TRUE.
              IF (LPPAT) PPAT(IATM,NCELLT)=PPAT(IATM,NCELLT)+WEIGHT
              IF (LEPAT) EPAT(NCELLT)=EPAT(NCELLT)+E0*WEIGHT
            ELSEIF (ITYP.EQ.2) THEN
              LOGMOL(IMOL,ISTRA)=.TRUE.
              IF (LPPML) PPML(IMOL,NCELLT)=PPML(IMOL,NCELLT)+WEIGHT
              IF (LEPML) EPML(NCELLT)=EPML(NCELLT)+E0*WEIGHT
            ELSEIF (ITYP.EQ.3) THEN
              LOGION(IION,ISTRA)=.TRUE.
              IF (LPPIO) PPIO(IION,NCELLT)=PPIO(IION,NCELLT)+WEIGHT
              IF (LEPIO) EPIO(NCELLT)=EPIO(NCELLT)+E0*WEIGHT
            ENDIF
            ITOLD = 4
            CALL UPDATE_SURFACE (ITOLD)
            IF (NADSI.GE.1) CALL UPSUSR(WEIGHT,2)
            IF (NADSPC.GE.1) CALL CALC_SPECTRUM(WEIGHT,2,0)
          ENDIF
C
C  RESTORE INCIDENT PARTICLE, FOR SURFACE REFLECTION ROUTINE
C
          IF (ILSPT(MSURF).NE.0) THEN
            E0=E0S
            WEIGHT=WEIGHS
            VEL=VELS
            VELX=VELXS
            VELY=VELYS
            VELZ=VELZS
            ISPZ=ISPZS
            LGPART=.FALSE.
          ENDIF
C
C
C  NEXT: CALL REFLECTION MODEL
C
540       CONTINUE
          CALL REFLC1 (WMINS,FMASS,FCHAR,NPRT(ISPZ),
     .                 ISRF(ISPZ,MSURF),ISRT(ISPZ,MSURF))
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
          IF (NLTRC.AND.TRCHST) THEN
            IF (LGPART) THEN
              WRITE (iunout,*) 'AFTER SUBR. REFLEC: '
              WRITE (iunout,'(1X,A8)') TEXTS(ISPZ)
              CALL MASR6 (
     .           'VELX,VELY,VELZ,VEL,E0,WEIGHT                    ',
     .            VELX,VELY,VELZ,VEL,E0,WEIGHT)
            ELSE
              WRITE (iunout,*) 'ABSORBED IN SUBR. REFLEC'
            ENDIF
          ENDIF
C
C  SURFACE TALLIES (VOLUME TALLIES PPAT,PPML,....WILL BE DONE BELOW,
C                   ONCE FOR NLPNT,NLLNE,NLSRF,NLVOL)
C
          ITOLD = 4
          CALL UPDATE_SURFACE (ITOLD)
C
          IF (NLSTOR) CALL STORE(1)
          IF (NADSI.GE.1) CALL UPSUSR(WEIGHT,2)
          IF (NADSPC.GE.1) CALL CALC_SPECTRUM(WEIGHT,2,0)
C
        ELSEIF (NLVOL(ISTRA)) THEN
C
C  IDENTIFY "INCIDENT" BULK PARTICLE
C  SAMPLE FROM MAXWELLIAN AT LOCAL PLASMA PARAMETERS TIIN AND (VXIN,VYIN,VZIN)
C  IN CELL ICELL=NCELL
C
!         nloop=1e6
!         nloop=npts(istra)
!         DO ILOOP=1,nloop

          NFLAG=2
          IDUM=1

c         DUMT(1)=SQRT(TIIN(IPLS,NCELL)/RMASSp(Ipls))*CVEL2A
c         DUMT(2)=DUMT(1)
c         DUMT(3)=DUMT(1)
c         DUMV(1)=0._DP
c         DUMV(2)=0._DP
c         DUMV(3)=0._DP

          CALL VELOCX(NCELL,VXO,VYO,VZO,VO,IO,NO,VELQ,NFLAG,
     .                IDUM,DUMT,DUMV)
          E0=VELQ*CVRSSP(IPLS)
          LOGPLS(IPLS,ISTRA)=.TRUE.
          WTOTP(IPLS,ISTRA)=WTOTP(IPLS,ISTRA)-WEIGHT
          ETOTP(ISTRA)=ETOTP(ISTRA)-E0*WEIGHT
          IF (LPPPL) PPPL(IPLS,NCELLT)=PPPL(IPLS,NCELLT)-WEIGHT
          IF (LEPPL) EPPL(NCELLT)=EPPL(NCELLT)-E0*WEIGHT
          IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
          IF (NLSTOR) CALL STORE(2)
C
C  BULK SPECIES DONE
C  NEXT: IDENTIFY RESULTING TEST PARTICLE SPECIES
C  FOR THIS: FIRST FIND IRRC
C
C  SORLIM GT.0, HENCE: VOLUME RECOMBINATION SOURCE RATES ON TABRC1
C  RECOMBINING BULK ION (IPLS,E0,WEIGHT,...) IS NOW IDENTIFIED
C  FIND TYPE AND SPECIES OF NEW TEST PARTICLE FROM RECOMB. PROCESS: IRRC
          ISTEP=SORIND(IVOLM,ISTRA)
          IF (ISTEP.EQ.0) THEN
            IF (SORLIM(IVOLM,ISTRA).LE.0._DP) THEN
              WRITE (iunout,*) 'SPECIES DISTRIBUTION AFTER SAMUSR ? '
              WRITE (iunout,*) 'EXIT FROM LOCATE '
              CALL EXIT_OWN(1)
            ENDIF
C  FIND RECOMBINATION PROCESS IRRC (AMONGST THOSE AVAILABLE FOR IPLS)
            IF (NPRCI(IPLS).EQ.1) THEN
              IRRC=LGPRC(IPLS,1)
            ELSE
              CUMDIS(0)=0.
              DO IIRC=1,NPRCI(IPLS)
                IRRC=LGPRC(IPLS,IIRC)
                IF (NSTORDR >= NRAD) THEN
                  CUMDIS(IIRC)=CUMDIS(IIRC-1)+TABRC1(IRRC,NCELL)
                ELSE
                  CUMDIS(IIRC)=CUMDIS(IIRC-1)+FTABRC1(IRRC,NCELL)
                END IF
              END DO
C  SAMPLE IIRC (AND HENCE: IRRC) FROM CUMDIS
              ZEP1=RANF_EIRENE()*CUMDIS(NPRCI(IPLS))
              DO IRC=1,NPRCI(IPLS)-1
                IF (ZEP1.LE.CUMDIS(IRC)) THEN
                  IIRC=IRC
                  GOTO 560
                ENDIF
              ENDDO
              IIRC=NPRCI(IPLS)
560           IRRC=LGPRC(IPLS,IIRC)
            ENDIF
          ELSE
C  RECOMBINATION PROCESS IRRC IS KNOWN FOR THIS SUBSTRATUM
            IRRC=ISTEP
          ENDIF
C
C  IRRC NOW IDENTIFIED
C
C  IS THERE A BULK SECONDARY ?
          IF (NPLPRC(IRRC).GT.0) THEN
            ITYP_B1=4
            IPLS_B1=NPLPRC(IRRC)
            IF (IPLS_B1.LE.0.OR.IPLS_B1.GT.NPLSI) GOTO 999
            LOGPLS(IPLS_B1,ISTRA)=.TRUE.
            WEIGHT_B1=WEIGHT
            E0_B1=E0
            GOTO 570
C  IS THERE A TEST SECONDARY ?
          ELSEIF (NATPRC(IRRC).GT.0) THEN
            ITYP=1
            IATM=NATPRC(IRRC)
            RSQDV=RSQDVA(IATM)
            IF (IATM.LE.0.OR.IATM.GT.NATMI) GOTO 999
            GOTO 570
          ELSEIF (NMLPRC(IRRC).GT.0) THEN
            ITYP=2
            IMOL=NMLPRC(IRRC)
            RSQDV=RSQDVM(IMOL)
            IF (IMOL.LE.0.OR.IMOL.GT.NMOLI) GOTO 999
            GOTO 570
          ELSEIF (NIOPRC(IRRC).GT.0) THEN
            ITYP=3
            IION=NIOPRC(IRRC)
            RSQDV=RSQDVI(IION)
            IF (IION.LE.0.OR.IION.GT.NIONI) GOTO 999
            GOTO 570
          ELSEIF (NPHPRC(IRRC).GT.0) THEN
            ITYP=0
            IPHOT=NPHPRC(IRRC)
            RSQDV=0.
            IF(IPHOT.LE.0.OR.IPHOT.GT.NPHOTI) GOTO 999
            GOTO 570
          ELSE
            GOTO 999
          ENDIF
C
570       CONTINUE
C  IS THERE A 2ND SECONDARY ?
C
C   BULK SECONDARY ?
          IF (NPLPRC_2(IRRC).GT.0) THEN
            ITYP_B2=4
            IPLS_B2=NPLPRC_2(IRRC)
            IF (IPLS_B2.LE.0.OR.IPLS_B2.GT.NPLSI) GOTO 999
            LOGPLS(IPLS_B2,ISTRA)=.TRUE.
            WEIGHT_B2=WEIGHT
            E0_B2=E0
            GOTO 580
C  TEST SECONDARY ?
          ELSEIF (NATPRC_2(IRRC).GT.0) THEN
            ITYP=1
            IATM=NATPRC_2(IRRC)
            RSQDV=RSQDVA(IATM)
            IF (IATM.LE.0.OR.IATM.GT.NATMI) GOTO 999
            GOTO 580
          ELSEIF (NMLPRC_2(IRRC).GT.0) THEN
            ITYP=2
            IMOL=NMLPRC_2(IRRC)
            RSQDV=RSQDVM(IMOL)
            IF (IMOL.LE.0.OR.IMOL.GT.NMOLI) GOTO 999
            GOTO 580
          ELSEIF (NIOPRC_2(IRRC).GT.0) THEN
            ITYP=3
            IION=NIOPRC_2(IRRC)
            RSQDV=RSQDVI(IION)
            IF (IION.LE.0.OR.IION.GT.NIONI) GOTO 999
            GOTO 580
          ELSEIF (NPHPRC_2(IRRC).GT.0) THEN
            ITYP=0
            IPHOT=NPHPRC_2(IRRC)
            RSQDV=0.
            IF(IPHOT.LE.0.OR.IPHOT.GT.NPHOTI) GOTO 999
            GOTO 580
          ENDIF

C  EXACTLY ONE TEST PARTICLE SECONDARY HAS NOW BEEN IDENTIFIED
580       CONTINUE
          IF (ITYP.GE.4.OR.ITYP.LT.0) GOTO 999
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
C
C  SPECIES IDENTIFIED
C  NEXT: NEW VELOCITY, ENERGY, ETC...
C
C  NEW OPTIONS
          IF (NEMOD1.EQ.1) THEN
C  MONOENERGETIC, ISOTROP
            EMAX=SORENI(ISTRA)
            E0=EMAX
            VEL=SQRT(E0)*RSQDV
            IF (INIV3.EQ.0) CALL FISOTR
            VELX=FI1(INIV3)
            VELY=FI2(INIV3)
            VELZ=FI3(INIV3)
            INIV3=INIV3-1

          ELSEIF (ITYP.EQ.0.AND.NEMOD1.EQ.9) THEN

c  this option: only for photon test particles
c  cut off "black part". this is the part of the emission line which will
c  be reabsorbed within the same cell. hence it will not contribute to any
c  radiation transport
C  REJECTION PREPARED FOR BLACK BODY CONTRIBUTION
            KK = NREARC(IRRC)
            call get_reaction(kk)
            e00=reaction%e0
            ipl=reaction%ignd
            VEL=CLIGHT
! Achtung!!!!!!!!!
! irot =1 ist falsch, wenn das Photon mehrere Reaktionen ausfuehren kann
            irot=1
!  has this cell already been done?
            IF (X1LINE(IVOLM,NCELL) < 0._DP) THEN
!  no. find energy interval to be excluded
              e0=e00
              zmfp_e00=fpathph(ncell,cflag,1,1)
              zmfp_cut = TDGTEMX*celdia(ncell)
              if (zmfp_e00 > zmfp_cut) then
! mean free path at linecenter is large compared to cell diameter
! line is not thick  =>  sample from whole line
                x1line(ivolm,ncell) = huge(1._dp)
                x2line(ivolm,ncell) = 0._dp

              else

! mean free path at linecenter is small compared to cell diameter
! line is thick  =>  sample from wings only

! suche linkes Ende des Intervalls
                call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac_e00,res)
                if (hwvdw < eps30) hwvdw = e00 - eps6
                fac_e0 = fac_e00
                zmfp_e0 = zmfp_e00
                xl = e00
                yl = zmfp_e00
                do while (zmfp_e0 < zmfp_cut)
                  xr = xl
                  yr = yl
                  xl = xl-hwvdw
                  e0 = xl
                  call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac_e0,res)
                  zmfp_e0 = zmfp_e00*fac_e00/fac_e0
                  yl = zmfp_e0
                  if (xl < hwvdw) exit
                end do

                e0 = xl

                do while ((yl-yr)/yl > 1.E-3_dp)
                  xm = (xr + xl) * 0.5_dp
                  e0 = xm
                  call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac_e0,res)
                  zmfp_e0 = zmfp_e00*fac_e00/fac_e0
                  ym = zmfp_e0
                  if (ym < zmfp_cut) then
                    xr = xm
                    yr = ym
                  else if (ym > zmfp_cut) then
                    xl = xm
                    yl = ym
                  else           ! getroffen
                    xl = xm
                    xr = xm
                    exit
                  end if
                end do
                x1line(ivolm,ncell) = xl

! suche rechtes Ende des Intervalls
                xr = e00
                yr = zmfp_e00
                zmfp_e0 = zmfp_e00
                do while (zmfp_e0 < zmfp_cut)
                  xl = xr
                  yl = yr
                  xr = xr+hwvdw
                  e0 = xr
                  call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac_e0,res)
                  zmfp_e0 = zmfp_e00*fac_e00/fac_e0
                  yr = zmfp_e0
                end do

                do while ((yr-yl)/yr > 1.E-3_dp)
                  xm = (xr + xl) * 0.5_dp
                  e0 = xm
                  call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac_e0,res)
                  zmfp_e0 = zmfp_e00*fac_e00/fac_e0
                  ym = zmfp_e0
                  if (ym < zmfp_cut) then
                    xl = xm
                    yl = ym
                  else if (ym > zmfp_cut) then
                    xr = xm
                    yr = ym
                  else           ! getroffen
                    xl = xm
                    xr = xm
                    exit
                  end if
                end do
                x2line(ivolm,ncell) = xr

              endif ! X1LINE(EV), X2LINE(EV) FOR CELL NCELL DONE
              xleft = x1line(ivolm,ncell)
              xright = x2line(ivolm,ncell)

            END IF ! NEMOD1=9 OPTION for photons prepared

!  now apply nemod1=9 option for ityp=0

C  PHOTON EMISSION PROFILE OPTIONS 0-9
C  SAMPLE ONLY FROM LINE PROFILES WITHOUT DOPPLER CONTRIBUTION
C  I.E., IN THE REST FRAME OF THE EMITTING ATOM
C  SAVE VELOCITY OF EMITTING (BULK) PARTICLE FOR LATER DOPPLER CORRECTION
            VEL_B=VEL
            VELX_B=VELX
            VELY_B=VELY
            VELZ_B=VELZ
C  SAMPLE ISOTROPIC EMISSION OF PHOTON IN REST FRAME OF EMITTING PARTICLE
            VEL=CLIGHT
            IF (INIV3.EQ.0) CALL FISOTR
            VELX=FI1(INIV3)
            VELY=FI2(INIV3)
            VELZ=FI3(INIV3)
            INIV3=INIV3-1
C  EMITTER VELOCITY COMPONENT IN DIRECTION OF LIGHT EMISSION
            VN=VEL_B*(VELX_B*VELX+VELY_B*VELY+VELZ_B*VELZ)

C  SAMPLE THE ENERGY (FREQUENCY) OF THE PHOTON
C  IN CASE OF ZEEMAN SPLITTING, THIS IS CONDITIONAL 
C  ON THE DIRECTION OF EMISSION 
            KK = NREARC(IRRC)
C  TRY TO ESTIMATE LINE SHAPE SPECTRAL RANGE (EV)
            E_MIN=1.
            E_MAX=-1.
            E0=PH_ENERGY(NCELL,KK,IPLS,VN,NL_ADD_DOPPLER,
     .                   E_MIN,E_MAX)
C  CORRECT FOR DOPPLER SHIFT: XNU = XNU_0*(1+N*VEL_B/CLIGHT)
            IF (NL_ADD_DOPPLER) THEN
!  line shape profiles with doppler not yet done for nemod1=9 option
              WRITE (iunout,*) 'LOCATE: NEMOD1 =9 OPTION NOT READY  '
              WRITE (iunout,*) '        FOR DOPPLER BROADENED LINES '
              CALL EXIT_OWN(1)
!             E0=E0*(1._DP+VN/CLIGHT)
            ENDIF

            if ((e0 > x1line(ivolm,ncell)) .and.
     .          (e0 < x2line(ivolm,ncell))) then
              lgpart = .false.
              weight = 0._dp
            end IF
C  nemod1=9 option FOR PHOTONS finished.

!  NEXT: PHOTON DEFAULT OPTION: NEMOD1 IS NOT =9 AND NOT =1
!        SAME AS NEMOD=9, BUT WITHOUT CUT OFF OF BLACK PART

          ELSEIF (ITYP.EQ.0) THEN

C  PHOTON EMISSION PROFILE OPTIONS 0-9
C  SAMPLE ONLY FROM LINE PROFILES WITHOUT DOPPLER CONTRIBUTION
C  I.E., IN THE REST FRAME OF THE EMITTING ATOM
C  SAVE VELOCITY OF EMITTING (BULK) PARTICLE FOR LATER DOPPLER CORRECTION
            VEL_B=VEL
            VELX_B=VELX
            VELY_B=VELY
            VELZ_B=VELZ
C  SAMPLE ISOTROPIC EMISSION OF PHOTON IN REST FRAME OF EMITTING PARTICLE
            VEL=CLIGHT
            IF (INIV3.EQ.0) CALL FISOTR
            VELX=FI1(INIV3)
            VELY=FI2(INIV3)
            VELZ=FI3(INIV3)
            INIV3=INIV3-1
C  EMITTER VELOCITY COMPONENT IN DIRECTION OF LIGHT EMISSION
            VN=VEL_B*(VELX_B*VELX+VELY_B*VELY+VELZ_B*VELZ)

c FOR ZEEMAN-SAMPLING TEST:
c           VELX=1.
c           VELY=0.
c           VELZ=0.
c           BXIN(NCELL)=0.
c           BYIN(NCELL)=0.
c           BZIN(NCELL)=1.
c
C  SAMPLE THE ENERGY (FREQUENCY) OF THE PHOTON
C  IN CASE OF ZEEMAN SPLITTING, THIS IS CONDITIONAL 
C  ON THE DIRECTION OF EMISSION 
            KK = NREARC(IRRC)
C  TRY TO ESTIMATE LINE SHAPE SPECTRAL RANGE (EV)
            E_MIN=1.
            E_MAX=-1.
            E0=PH_ENERGY(NCELL,KK,IPLS,VN,NL_ADD_DOPPLER,
     .                   E_MIN,E_MAX)
C
C  planck value, for this current temperature, only for testing.
C           IPLSTI=MPLSTI(IPLS)
C           PLA=PLANCK(E0,TIIN(IPLSTI,NCELL),B_NU,1)
C
C  CORRECT FOR DOPPLER SHIFT: XNU = XNU_0*(1+N*VEL_B/CLIGHT)
            IF (NL_ADD_DOPPLER) THEN
              E0=E0*(1._DP+VN/CLIGHT)
            ENDIF

!  options for plotting of sampled volume emission spectra
c
c  put spectrum no. 1, and use energy range from input block 10F
c           if (nadspc < 1) then
c             write (iunout,*) 'locate: no storage for spectr. no. 1  '
c             call exit_own(1)
c           endif
c           msurf=estiml(1)%pspc%ispcsrf
c           call calc_spectrum (1._dp,1,0)

          ELSE
C  AT THIS POINT: ITYP NE 0 (NEW TEST PARTICLE IS NOT A PHOTON)
C                 AND NEMOD1 NE 1 (NEW TEST PARTICLE NOT SAMPLED
C                 FROM MONOENERGETIC ISOTROPIC DISTRIBUTION)
C
C  OLD DEFAULT: SAMPLING FROM LOCAL MAXWELLIAN, I.E.,
C               SAMPLED BULK PARTICLE VELOCITY ALSO FOR NEW TEST PARTICLE
C               E.G.: VOLUME RECOMBINATION OF PLASMA IONS INTO NEUTRALS
C         E0=E0
C         VEL=VEL
C
          ENDIF

c         end do ! iloop
c         IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,0,1)
c
c  for (computed) spectrum no. 2: use spectral range as set in input block 10F
c         if (nadspc < 2) then
c           write (iunout,*) 'locate: no storage for spectr. no. 2  '
c           call exit_own(1)
c         endif
c  use spectral range as set in input block 10F
c         ean=estiml(2)%pspc%spcmin+0.5_dp*estiml(2)%pspc%spcdel
c         een=estiml(2)%pspc%spcmax
c         de=estiml(2)%pspc%spcdel
c         nen=estiml(2)%pspc%nspc
c         allocate(eplot(nen))
c         allocate(y1plot(nen))
c         allocate(y2plot(nen))
cdr  this test is comparison of sampled and evaluated line profiles.
cdr  sampling is done using upper bulk species ipls. Hence: use also
cdr  same ipls for evaluation of same line profile in getcoeff.
c         ipl=reaction%ignd
c         ipl=ipls
c
! Achtung!!!!!!!!!
! irot =1 ist falsch, wenn das Photon mehrere Reaktionen ausfuehren kann
c          irot=1
!pbct          ictoff = nreact(kk)
c          do i=1,nen
c            e0=ean+(i-1)*de
c            eplot(i)=e0
c            call PH_GETCOEFF(kk,iphot,0,ncell,ipl,fac,res)
cdr  fac is 1/eV. hence: here times delta_E, because in calc-spectrum
cdr                      there is a division by delta_E.
cdr  times nloop, because: nloop particles sampled with ph_energy
cdr             further below: both spectra will be rescaled with 1/nloop
c            msurf=estiml(2)%pspc%ispcsrf
c            call calc_spectrum (fac*ESTIML(2)%PSPC%SPCDEL*nloop,1,0)
!pbct            spcvl = fac*ESTIML(2)%PSPC%SPCDEL*nloop
!pbct            call calc_spectrum (spcvl,1,0)
c
c  for second plot, not from plteir but explicitly done below
c  "flux" or "energy flux" units ?
c            y1plot(i) = fac
c            y1plot(i) = fac*E0
c            y2plot(i) = fpathph(ncell,cflag,1,1)
c          end do
!pbct          do i=1,nen
!pbct            ESTIML(2)%PSPC%SPC(I) = 
!pbct     .          ESTIML(2)%PSPC%SPC(I)/(xintleft(ictoff,ncell) +
!pbct     .              xint_inf(ictoff,ncell) 
!pbct     .             -xintright(ictoff,ncell))*xint_inf(ictoff,ncell)
!pbct          end do
c
c          flxfc=1._dp/nloop
c  substract line center energy e00 from abscissa
c          e00_plot=reaction%e0
c          eplot=eplot-e00_plot
c          DO ISPC=1,NADSPC
c            ESTIML(ISPC)%PSPC%SPC = ESTIML(ISPC)%PSPC%SPC*FLXFC*
c    .                               ESTIML(ISPC)%PSPC%SPCDELI
c            ESTIML(ISPC)%PSPC%SPCINT = SUM(ESTIML(ISPC)%PSPC%SPC*
c    .                                      ESTIML(ISPC)%PSPC%SPCDEL)
c            ESTIML(ISPC)%PSPC%ESP_00 = e00_plot
c          END DO
c  plot the sampled and the calculated line profiles 
C  using the spectrum tallies (histograms).
c          EMINSP=ESTIML(1)%PSPC%ESP_MIN
c          EMAXSP=ESTIML(1)%PSPC%ESP_MAX
 
!pbct          iloc = maxloc(ESTIML(1)%PSPC%SPC(1:nen),dim=1)+1
!pbct          spcvl = ESTIML(1)%PSPC%SPC(iloc)/ESTIML(2)%PSPC%SPC(iloc)

!pbct          write (iunout,*) ' estiml(1)   ',ESTIML(1)%PSPC%SPC(iloc)
!pbct          write (iunout,*) ' estiml(2)   ',ESTIML(2)%PSPC%SPC(iloc)
!pbct          write (iunout,*) ' scal.factor ',spcvl

!pbct          spcmx = maxval(ESTIML(1)%PSPC%SPC(1:nen))
c
!pbct          do i=1,nen
!pbct            ESTIML(2)%PSPC%SPC(I) = MIN(SPCMX,
!pbct     .          ESTIML(2)%PSPC%SPC(I))
!pbct          end do
c
c          nadspc=2
c          xmcp(istra)=nloop
c          iestr=istra
c          call plteir(istra)

!pbct          DO ISPC=1,NADSPC
!pbct             WRITE (56,*) ' SPECTRUM ',ISPC
!pbct             DO IE=1, ESTIML(ISPC)%PSPC%NSPC
!pbct                EN = ESTIML(ISPC)%PSPC%SPCMIN +
!pbct     .               (IE-0.5)*ESTIML(ISPC)%PSPC%SPCDEL
!pbct                WRITE (56,'(I6,2ES12.4)') IE,EN,
!pbct     .               ESTIML(ISPC)%PSPC%SPC(IE)
!pbct             END DO
!pbct             write (56,*) ' integral ',ESTIML(ISPC)%PSPC%SPCINT
!pbct             WRITE (56,'(///1X)')
!pbct          END DO
c
c  plot the calculated line profile once again (smooth curve)
c          call grnxtb(1,'LOCATE.F')
c          call grsclc (5.,2.,32.,24.)
c          y1a=minval(y1plot)
c          y1e=maxval(y1plot)
c          if (y1e.gt.y1a) then
c            call grsclv (eplot(1),y1a,eplot(nen),y1e)
c            call graxs (9,'X=1,Y=1,A',1,' ',1,' ')
c            call grnwpn(2)
c            call grln(eplot,y1plot,nen)
c            call grnwpn(3)
c  indicate line center on plot
c  here: e00_plot=0, because shift already done on eplot.
c            e00_plot=reaction%e0-e00_plot
c            call grjmp(e00_plot,y1a)
c            call grdrw(e00_plot,y1e)
c          endif
c  plot the mean free path vs. photon energy, if finite
c          y2a=minval(y2plot)
c          y2e=maxval(y2plot)
c          if (y2e.gt.y2a) then
c            call grsclv (eplot(1),y2a,eplot(nen),y2e)
c            call grnwpn(1)
c            call graxs (9,'X=2,Y=2,A',1,' ',1,' ')
c            call grnwpn(3)
c            call grln(eplot,y2plot,nen)
c            call grnwpn(1)
c          endif
c          call grend
c          write (iunout,*) 'nloop,ncell,Tiin(mplsti(ipls),ncell),',
c    .                      'Bfin(ncell),dein(ncell),tein(ncell)'
c          write (iunout,*)  nloop,ncell,Tiin(mplsti(ipls),ncell),
c    .                       Bfin(ncell),dein(ncell),tein(ncell)
c          do i=1,nen
c            write (iunout,*) eplot(i), estiml(1)%pspc%spc(i),
c    .                                  estiml(2)%pspc%spc(i),
c    .                                  y1plot(i),
c    .                                  y2plot(i)
c          enddo
c          write (iunout,*)
c    .       'spectrum in locate, emin, emax ',eminsp,emaxsp
c          stop
C
          
          IF (NLTRC.AND.TRCHST) THEN
            WRITE (iunout,*) 'AFTER RECOMBINATION: '
            CALL MASJ6
     .           ('ITYP,IPHOT,IATM,IMOL,IION,IPLS                  ',
     .             ITYP,IPHOT,IATM,IMOL,IION,IPLS)
          ENDIF
C
          IF (NLSTOR) CALL STORE(1)
C
        ELSEIF (NLLNE(ISTRA)) THEN
          WRITE (iunout,*) 
     .      'BULK ION LINE SOURCE NOT READY, EXIT CALLED '
          CALL EXIT_OWN(1)
C
        ELSEIF (NLPNT(ISTRA)) THEN
          WRITE (iunout,*) 
     .      'BULK ION POINT SOURCE NOT READY, EXIT CALLED '
          CALL EXIT_OWN(1)
        ENDIF
C
C  NLPNT,NLLNE,NLSRF,NLVOL DONE.
C
C  VOLUME TALLIES FOR TEST-SECONDARIES
        IF (ITYP.EQ.1) THEN
          LOGATM(IATM,ISTRA)=.TRUE.
          IF (LPPAT) PPAT(IATM,NCELLT)=PPAT(IATM,NCELLT)+WEIGHT
          IF (LEPAT) EPAT(NCELLT)=EPAT(NCELLT)+E0*WEIGHT
          LAST_EVENT%ISPEZ = IATM
        ELSEIF (ITYP.EQ.2) THEN
          LOGMOL(IMOL,ISTRA)=.TRUE.
          IF (LPPML) PPML(IMOL,NCELLT)=PPML(IMOL,NCELLT)+WEIGHT
          IF (LEPML) EPML(NCELLT)=EPML(NCELLT)+E0*WEIGHT
          LAST_EVENT%ISPEZ = IMOL
        ELSEIF (ITYP.EQ.3) THEN
          LOGION(IION,ISTRA)=.TRUE.
          IF (LPPIO) PPIO(IION,NCELLT)=PPIO(IION,NCELLT)+WEIGHT
          IF (LEPIO) EPIO(NCELLT)=EPIO(NCELLT)+E0*WEIGHT
          LAST_EVENT%ISPEZ = IION
        ELSEIF (ITYP.EQ.0) THEN
          LOGPHOT(IPHOT,ISTRA)=.TRUE.
          IF (LPPPHT) PPPHT(IPHOT,NCELLT)=PPPHT(IPHOT,NCELLT)+WEIGHT
          IF (LEPPHT) EPPHT(NCELLT)=EPPHT(NCELLT)+E0*WEIGHT
          LAST_EVENT%ISPEZ = IPHOT
          STEMIS=E0*WEIGHT
          STWEI=WEIGHT
        ENDIF
C  TALLIES FOR BULK-SECONDARIES (IF ANY)
        IF (ITYP_B1.EQ.4) THEN
          LOGPLS(IPLS_B1,ISTRA)=.TRUE.
          IF (LPPPL) PPPL(IPLS_B1,NCELLT)=PPPL(IPLS_B1,NCELLT)+WEIGHT_B1
          IF (LEPPL) EPPL(NCELLT)=EPPL(NCELLT)+E0_B1*WEIGHT_B1
        ELSEIF (ITYP_B2.EQ.4) THEN
          LOGPLS(IPLS_B2,ISTRA)=.TRUE.
          IF (LPPPL) PPPL(IPLS_B2,NCELLT)=PPPL(IPLS_B2,NCELLT)+WEIGHT_B2
          IF (LEPPL) EPPL(NCELLT)=EPPL(NCELLT)+E0_B2*WEIGHT_B2
        ENDIF
C
      ENDIF
C
5000  CONTINUE

      LAST_EVENT%IFLAG = 1
      LAST_EVENT%NCELL = NCELLT
      LAST_EVENT%ITYP = ITYP
      LAST_EVENT%E0 = E0
      LAST_EVENT%WEIGHT = WEIGHT
      IF (ITYP.EQ.1) THEN
        LAST_EVENT%ISPEZ = IATM
      ELSEIF (ITYP.EQ.2) THEN
        LAST_EVENT%ISPEZ = IMOL
      ELSEIF (ITYP.EQ.3) THEN
        LAST_EVENT%ISPEZ = IION
      ELSEIF (ITYP.EQ.0) THEN
        LAST_EVENT%ISPEZ = IPHOT
      ENDIF

C
C  HAS THE SOURCE PARTICLE BEEN ABSORBED IN SUBR. REFLEC OR SPUTER?
C
      IF (.NOT.LGPART) RETURN

      IF (NLRAY(ISTRA)) THEN
        TRAJ(ITRJ)%TRJ%VX = VELX
        TRAJ(ITRJ)%TRJ%VY = VELY
        TRAJ(ITRJ)%TRJ%VZ = VELZ
        TRAJ(ITRJ)%TRJ%WGHT = WEIGHT
        TRAJ(ITRJ)%TRJ%P1 = (/ X0, Y0, Z0 /)
        TRAJ(ITRJ)%TRJ%TYP = ITYP
        NLTRJ = .TRUE.
      END IF
C
C  IS THE PARTICLE LAUNCHED OUTSIDE THE COMPUTATIONAL BOX?
C
C  TEST FOR CORRECT CELL NUMBER AT BIRTH POINT
C  KILL PARTICLE, IF WRONG CELL INDICES
C
      IF (NLSRFX) THEN
C  RADIAL CELL NO. MAY BE WRONG
      ELSEIF (NLSRFY) THEN
C  POLOIDAL CELL NO. MAY BE WRONG
        IF (LEVGEO.EQ.1) THEN
          SG=SIGN(1._DP,VELY)
        ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
          SG=VELX*PPLNX(NRCELL,MPSURF)+VELY*PPLNY(NRCELL,MPSURF)
        ENDIF
        IF (SG.LT.0) THEN
          NPCELL=MPSURF-1
        ELSEIF (SG.GT.0) THEN
          NPCELL=MPSURF
        ELSE
          WRITE (iunout,*) 'ERROR EXIT IN LOCATE, SG=0 '
          CALL EXIT_OWN(1)
        ENDIF
        IPOLG=NPCELL
      ELSEIF (NLSRFZ) THEN
C  TOROIDAL CELL NO. MAY BE WRONG
      ENDIF

      IF (NLTEST) THEN
        CALL CLLTST(*997)
      ELSE
        NLTST=.FALSE.
        NLTST=NLTST.OR.(NLRAD.AND.(NRCELL.GT.NR1ST.OR.NRCELL.LT.0))
        NLTST=NLTST.OR.(NLPOL.AND.(NPCELL.GT.NP2ND.OR.NPCELL.LT.1))
        NLTST=NLTST.OR.(NLTOR.AND.(NTCELL.GT.NT3RD.OR.NTCELL.LT.1))
        NLTST=NLTST.OR.(NRCELL.EQ.0.AND.
     .                            (NACELL.GT.NRADD.OR.NACELL.LT.1))
        IF (NLTST) GOTO 995
      ENDIF
      RETURN

      ENTRY LOCAT2

      IF (ALLOCATED(WMM)) THEN
        DEALLOCATE (WMM)
        DEALLOCATE (WEISPZ)
        DEALLOCATE (IICSOR)
        DEALLOCATE (ITISOR)
        DEALLOCATE (IUPSOR)
        DEALLOCATE (IFPSOR)
      END IF

      RETURN
C
990   CONTINUE
      WRITE (iunout,*) 'ERROR IN LOCATE: ILSIDE OF SOURCE SURFACE IS 0.'
      WRITE (iunout,*) 
     .  'THUS NO OUTER NORMAL CAN BE DEFINED. EXIT CALLED'
      WRITE (iunout,*) 'SET EITHER ILSIDE NE 0 OR USE SORIFL FLAG '
      WRITE (iunout,*) 'MSURF,ISTSF,NRCELL,NPCELL,NTCELL '
      WRITE (iunout,*)  MSURF,ITRSF,NRCELL,NPCELL,NTCELL
      CALL EXIT_OWN(1)
991   CONTINUE
      WRITE (iunout,*) 'ERROR IN LOCATE: INCONSISTENT INPUT FLAGS   '
      WRITE (iunout,*) 'MSURF = ',MSURF
      CALL EXIT_OWN(1)
992   CONTINUE
      WRITE (iunout,*) 'ERROR IN LOCATE: RADON-NIKODYM CONDITION    '
      WRITE (iunout,*) 'VIOLATED FOR NON-ANALOG SOURCE SPECIES SAMPLING'
      WRITE (iunout,*) 'CHECK DATM,DMOL,DION OR DPLS ARRAYS (BLOCK) 6 '
      CALL EXIT_OWN(1)
995   CONTINUE
      WRITE (iunout,*) 'PARTICLE LAUNCHED OUTSIDE THE COMPUTATIONAL BOX'
      WRITE (iunout,*) 'OR WITH INVALID CELL INDICES'
      WRITE (iunout,*) 'NPANU,X0,Y0,Z0 ',NPANU,X0,Y0,Z0
      WRITE (iunout,*) 'NRCELL,NPCELL,NTCELL,NBLOCK,NACELL ',
     .                  NRCELL,NPCELL,NTCELL,NBLOCK,NACELL
      CALL EXIT_OWN(1)
996   CONTINUE
      WRITE (iunout,*) 'BULK ION LAUNCHED IN WRONG DIRECTION'
      WRITE (iunout,*) 'NPANU,VXWL,VYWL,VZWL ',
     .                  NPANU,VXWL(IPLS),VYWL(IPLS),VZWL(IPLS)
      WRITE (iunout,*) '      CRTX,CRTY,CRTZ ',CRTX,CRTY,CRTZ
      CALL EXIT_OWN(1)
997   CONTINUE
      WRITE (iunout,*) 
     .  'TEST PARTICLE LAUNCHED WITH INVALID CELL INDICES'
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,18)
      IF (NLSTOR) CALL STORE(100)
      WEIGHT=0.
      LGPART=.FALSE.
      RETURN
998   CONTINUE
      WRITE (iunout,*) 'ERROR IN LOCATE: NEMODS,ITYP= ',
     .                  NEMODS(ISTRA),ITYP
      WRITE (iunout,*) 'INVALID OPTION. TIWD= ',TIWD
      CALL EXIT_OWN(1)
999   CONTINUE
      WRITE (iunout,*) 'ERROR IN LOCATE: TYP OR SPECIES OUT OF RANGE'
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: sampnt.f
c  jet-2005, patch 1:  new arguments shwl and efwl in parameter list
C
C       ..............................
C       .                            .
C       .  SOURCE SAMPLING ROUTINES  .
C       .                            .
C       ..............................
C
C     SUBROUTINE SAMPNT
C     SUBROUTINE SAMLNE
C     SUBROUTINE SAMSRF
C     SUBROUTINE SAMVOL
C
      SUBROUTINE SAMPNT (NLPT,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,
     .                        EFWL,SHWL,WEISPZ)

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CLOGAU
      USE CINIT
      USE CGRID
      USE COMPRT
      USE COMSOU
      USE CTRIG

      IMPLICIT NONE

      REAL(DP), INTENT(OUT) :: TEWL, SHWL, TIWL(*), DIWL(*), EFWL(*),
     .                         VXWL(*), VYWL(*), VZWL(*), WEISPZ(*)
      INTEGER, INTENT(IN) :: NLPT
      REAL(DP) :: X01, CNORM, WINK
      INTEGER :: NT, LEARCA, LEARC1, LEARC2, LEARCT, LEAUSR, IPOINT,
     .           IAUSR, IBUSR, IRUSR, IPUSR, ITUSR, IPLSTI, IPLSV
C
      IPOINT=NLPT
      IF (SORLIM(IPOINT,ISTRA).LT.0.D0) THEN
        CALL SM1USR(NLPT,X0,Y0,Z0,
     .              SORAD1(NLPT,ISTRA),SORAD2(NLPT,ISTRA),
     .              SORAD3(NLPT,ISTRA),SORAD4(NLPT,ISTRA),
     .              SORAD5(NLPT,ISTRA),SORAD6(NLPT,ISTRA),
     .              IRUSR,IPUSR,ITUSR,IAUSR,IBUSR,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
      ELSE
        X0=SORAD1(IPOINT,ISTRA)
        Y0=SORAD2(IPOINT,ISTRA)
        Z0=SORAD3(IPOINT,ISTRA)
      ENDIF
C
      IF (NLTRA) PHI=SORAD3(IPOINT,ISTRA)*DEGRAD
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      NLSRFA=.FALSE.
      IF (NRSOR(IPOINT,ISTRA).GT.0.OR.NASOR(IPOINT,ISTRA).GT.0) THEN
        NRCELL=NRSOR(IPOINT,ISTRA)
        NACELL=NASOR(IPOINT,ISTRA)
        IPOLG =NISOR(IPOINT,ISTRA)
      ELSEIF (NRSOR(IPOINT,ISTRA).EQ.0.AND.
     .        NASOR(IPOINT,ISTRA).EQ.0) THEN
        IF (LEVGEO.LE.4) THEN
          NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,.FALSE.,.FALSE.,NPANU,
     .                 'SAMPNT      ')
        ELSEIF (LEVGEO.EQ.5) THEN
          NRCELL=LEARCT(X0,Y0,Z0)
        ELSEIF (LEVGEO.EQ.6) THEN
C          WRITE (iunout,*) 'INVALID CELL NUMBER IN SAMPNT '
C          CALL EXIT_OWN(1)
        write (iunout,*) ' marke 3 '
          nrcell=leausr(x0,y0,z0)
        END IF
        NACELL=0
      ELSE
        GOTO 991
      ENDIF
      NTCELL=1
      IPERID=1
      IF (NLTOR.AND.NACELL.EQ.0) THEN
        IF (NLTRZ) THEN
          IF (NTSOR(NLPT,ISTRA).GT.0) THEN
C  NTCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NTSOR
            NTCELL=NTSOR(NLPT,ISTRA)
          ELSEIF (NTSOR(NLPT,ISTRA).EQ.0) THEN
C  NTCELL IS COMPUTED IN STANDARD MESH
            NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'SAMPNT      ')
          ELSE
            GOTO 991
          ENDIF
        ELSEIF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
C  FIND Z0,NTCELL FROM X01,PHI
          NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'SAMPNT      ')
          IF (NTCELL.LE.0.OR.NTCELL.GT.NT3RDM) THEN
            WRITE (iunout,*) 'NTCELL OUT OF RANGE IN SAMPNT '
            WRITE (iunout,*) PHI,ZHALF
            CALL EXIT_OWN(1)
          ENDIF
          X01=X0+RMTOR
          CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
          IPERID=NTCELL
        ELSEIF (NLTRT) THEN
          WRITE (iunout,*) 'NLTRT: TO BE WRITTEN IN SAMPNT '
          CALL EXIT_OWN(1)
        ENDIF
      ELSEIF (.NOT.NLTOR.OR.NACELL.GT.0) THEN
        IF (NLTRA) THEN
C  FIND Z0, NT,  FROM X0,PHI
          NT=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMPNT      ')
          IF (NT.LE.0.OR.NT.GT.NTTRAM) THEN
            WRITE (iunout,*) 'NT OUT OF RANGE IN SAMPNT '
            WRITE (iunout,*) PHI,ZFULL
            CALL EXIT_OWN(1)
          ENDIF
          X01=X0+RMTOR
          CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
          IPERID=NT
        ELSEIF (NLTRT) THEN
          WRITE (iunout,*) 'NLTRT: TO BE WRITTEN IN SAMPNT '
          CALL EXIT_OWN(1)
        ENDIF
      ENDIF
C
      NPCELL=1
      IF (NLPOL.AND.NACELL.EQ.0) THEN
        IF (NPSOR(NLPT,ISTRA).GT.0) THEN
C  NPCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NPSOR
          NPCELL=NPSOR(NLPT,ISTRA)
        ELSEIF (NPSOR(NLPT,ISTRA).EQ.0) THEN
C  NPCELL IS COMPUTED IN STANDARD MESH
          IF (LEVGEO.EQ.1) THEN
            NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'SAMPNT')
          ELSEIF (LEVGEO.EQ.2) THEN
            IF (NLCRC) THEN
              WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
              NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'SAMPNT')
            ELSE
              NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'SAMPNT')
            ENDIF
          ELSEIF (LEVGEO.EQ.3) THEN
            NPCELL=IPOLG
          ELSE
            WRITE (iunout,*) 'ERROR EXIT FROM SAMPNT. NLPOL ',LEVGEO
            CALL EXIT_OWN(1)
          ENDIF
        ELSE
          GOTO 991
        ENDIF
      ENDIF
C
      NBLOCK=NBSOR(IPOINT,ISTRA)
      NBLOCK=MAX0(1,NBLOCK)
      NBLOCK=MIN0(NBLOCK,NBMLT)
C
      IF (NRCELL.GT.0) NACELL=0
      IF (NACELL.GT.0) NBLOCK=NBMLTP
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
      TEWL=TEIN(NCELL)
      DO 13 IPLS=1,NPLSI
        IPLSTI=MPLSTI(IPLS)
        IPLSV=MPLSV(IPLS)
        TIWL(IPLS)=TIIN(IPLSTI,NCELL)
        IF (INDPRO(4) == 8) THEN
          CALL VECUSR (2,VXWL(IPLS),VYWL(IPLS),VZWL(IPLS),IPLS)
        ELSE
          VXWL(IPLS)=VXIN(IPLSV,NCELL)
          VYWL(IPLS)=VYIN(IPLSV,NCELL)
          VZWL(IPLS)=VZIN(IPLSV,NCELL)
        END IF
        DIWL(IPLS)=DIIN(IPLS,NCELL)
13    CONTINUE
C
      DO 20 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
20    CONTINUE
      IF (NSPEZ(ISTRA).LE.0) THEN
C  ANALOG SAMPLING DISTRIBUTION NOT AVAILABLE FOR POINT SOURCE
        GOTO 992
      ENDIF
C
      CRTX=SORAD4(IPOINT,ISTRA)
      CRTY=SORAD5(IPOINT,ISTRA)
      CRTZ=SORAD6(IPOINT,ISTRA)
      CNORM=SQRT(CRTX**2+CRTY**2+CRTZ**2)+EPS60
      CRTX=CRTX/CNORM
      CRTY=CRTY/CNORM
      CRTZ=CRTZ/CNORM
C
      RETURN
991   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMPNT                               '
      CALL EXIT_OWN(1)
992   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMPNT, NSPEZ OUT OF RANGE           '
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: samsrf.f
C  6.4.04:  include torl in default step function
C  nov. 11.05  jet-2005 patch 1: new parameter shwl at call to smsrf1
C              added:  print ekflx, eshflx: total kinetic and sheath fluxes 
C              from newly added step functions  elstep, shstep
C              now return shwl, efwl(ipls) for use in locate.f
C              in locate: new options nemod1=8,9 for using efwl(ipls)
C              efwl(ipls) is the kinetic ion energy flux (W) at sheath entrance
C  nov.14.05: bug fix, v.k., istra --> istep for aleft(1,....) (twice)
C  may 06: sampling on 2nd order additional surface modified:
C          sign of determinant is now sampled. rejection with respect to bounding box
c  aug 06: new option SORIND.gt.100 for step functions introducted. 3rd digit is now
c          pointer to species of step function
C
      SUBROUTINE SAMSRF
C
C  THIS SUBROUTINE SAMPLES THE INITIAL CO-ORDINATES OF A PARTICLE
C  HISTORY, WHICH STARTS ON A SURFACE
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CADGEO
      USE CCONA
      USE CLOGAU
      USE CINIT
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CTRCEI
      USE CGEOM
      USE CTETRA
      USE COMPRT
      USE CPES
      USE COMSOU
      USE CSTEP
      USE CLGIN
      USE CTRIG

      IMPLICIT NONE

      REAL(DP), INTENT(OUT) :: TEWL, SHWL, VXWL(*), VYWL(*), VZWL(*),
     .                         TIWL(*), DIWL(*), EFWL(*), WEISPZ(*)
      INTEGER, INTENT(IN) :: NLSF
      REAL(DP) :: ZZ(3)
      REAL(DP) :: X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3, ELLZZ1, EP1ZZ1,
     .          WINK, XR, STEP0, DELR, CS, STEP, FL, DET, PH,
     .          X0TEST, Y0TEST, S, AN, P, Q, VVX, D, VVI, VVY, BL,
     .          Z0TEST, RNF, ZH, STEP1, DELTA, ZM, XLAMDA, BABS, CTETHA
      INTEGER :: ISID, IDUM, LEARC1, NDUM, LEARC2, NT, IEN, IAN,
     .           LEARCA, ITET, ISGRD1, IS2, IP, ISTEP, ISGRD2,
     .           IS1, ISGRD3, NSMX, K, NL3J, ISTR, ISR, NL2J, NL1J,
     .           IERROR, ISOR, ISRFS, ICOUNT, IPLG, I, ILTR, IAUSR,
     .           IBUSR, IRUSR, IPUSR, ITUSR, IK, J, JCALC, IINDEX,
     .           KAN, KEN, ISRPB, ISRND, ITRI, IS, NBIN, INDSRF,
     .           IPLSTI, IPLSV, IT, IPL, NANZ, IPLSD(NPLS), ISORFL, INS,
     .           ISTEP_SPEZ
      REAL(DP):: FF, TORL(NSTEP,NGITT) 
      REAL(DP):: FLX(NPLS),EKFLX(NPLS),ESHFLX(NPLS)
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER, EXTERNAL :: IDEZ
      REAL(DP), ALLOCATABLE, SAVE ::
     .        ALEFT(:,:,:), BRGHT(:,:,:), XI(:,:,:), XE(:,:,:)
      INTEGER, ALLOCATABLE, SAVE :: INDTEC(:,:)
      LOGICAL :: LOGTST
      INTEGER :: ITSIDE(3,4)
      DATA ITSIDE /1,2,3,
     .             1,4,2,
     .             2,4,3,
     .             3,4,1/
C
C  INITIALIZE DATA FOR SURFACE SAMPLING FOR STRATUM NO. ISTRA
C
      ENTRY SAMSF0

      DO ISTRA=1,NSTRAI

      IF (.NOT.NLSRF(ISTRA)) CYCLE

      IERROR=0

      IF (.NOT.ALLOCATED(INDTEC)) THEN
        ALLOCATE (INDTEC(3*NSRFS,NSTRA))
        ALLOCATE (ALEFT(3,NSRFS,NSTRA))
        ALLOCATE (BRGHT(3,NSRFS,NSTRA))
        ALLOCATE (XI(3,NSRFS,NSTRA))
        ALLOCATE (XE(3,NSRFS,NSTRA))
      END IF
C
C  LOOP OVER SOURCE SURFACES: ISRFS
C
      DO 1 ISRFS=1,NSRFSI(ISTRA)
C
        ISOR=SORLIM(ISRFS,ISTRA)
        ISORFL=IDEZ(INT(SORIFL(ISRFS,ISTRA)),4,4)
C
        IF (SORLIM(ISRFS,ISTRA).GT.0.AND.INDIM(ISRFS,ISTRA).EQ.1.) THEN
          IF (INGRDA(ISRFS,ISTRA,1).NE.INGRDE(ISRFS,ISTRA,1)) THEN
            WRITE (iunout,*) 'WARNING FROM SAMSF0, ISTRA= ',ISTRA
            WRITE (iunout,*) 'NEW INPUT FOR INGRDA,INGRDE....'
            WRITE (iunout,*) 'AUTOMATIC CORRECTION CARRIED OUT '
            INGRDA(ISRFS,ISTRA,2)=INGRDA(ISRFS,ISTRA,1)
            INGRDE(ISRFS,ISTRA,2)=INGRDE(ISRFS,ISTRA,1)
            INGRDA(ISRFS,ISTRA,1)=INSOR(ISRFS,ISTRA)
            INGRDE(ISRFS,ISTRA,1)=INSOR(ISRFS,ISTRA)
          ENDIF
        ENDIF
C  HAS THIS SURFACE SOURCE A PREPROGRAMMED DISTRIBUTION
C
        IF (ISOR.LE.0) THEN
          ISR=ISRFS
          ISTR=ISTRA
          CALL SM0USR(ISR,ISTR,
     .                SORAD1(ISR,ISTR),SORAD2(ISR,ISTR),
     .                SORAD3(ISR,ISTR),SORAD4(ISR,ISTR),
     .                SORAD5(ISR,ISTR),SORAD6(ISR,ISTR))
          GOTO 1
        ENDIF
C  YES
        NL1J=ISRFS
        NL2J=NL1J+NSRFS
        NL3J=NL2J+NSRFS
        INDTEC(NL1J,ISTRA)=IDEZ(ISOR,1,4)
        INDTEC(NL2J,ISTRA)=IDEZ(ISOR,2,4)
        INDTEC(NL3J,ISTRA)=IDEZ(ISOR,3,4)
C
C  IS A STEP FUNCTION REQUESTED?
C
        ISTEP=0
        ISTEP_SPEZ=0
        IF (INDTEC(NL1J,ISTRA).NE.4.AND.INDTEC(NL2J,ISTRA).NE.4.AND.
     .      INDTEC(NL3J,ISTRA).NE.4) GOTO 7
C
C  YES. CHECK INPUT DATA AND STORAGE
C
        ISTEP=MOD(IDINT(REAL(SORIND(ISRFS,ISTRA),KIND(1.D0))),100)
        ISTEP_SPEZ=SORIND(ISRFS,ISTRA)/100
C
        IF (ISTEP.EQ.0) THEN
          WRITE (iunout,*) 'ERROR IN PRIMARY SOURCE DATA '
          WRITE (iunout,*) 'STEPFUNCTION REQUESTED FOR SOURCE SURFACE '
          WRITE (iunout,*) 'NO. ', INSOR(ISRFS,ISTRA),
     .      ' BUT SORIND.EQ.0..'
          CALL EXIT_OWN(1)
        ELSEIF (ISTEP.GT.NSTEP) THEN
          CALL MASPRM('NSTEP',5,NSTEP,'ISTEP',5,ISTEP,IERROR)
          CALL EXIT_OWN(1)
        ENDIF
C
C  HAS THIS STEPFUNCTION NO. ISTEP STILL TO BE INITIALIZED?
C
        IF (ISTUF(ISTEP).EQ.0) THEN
C  YES
C
C  INITIALIZE STEPFUNCTION NO. ISTEP BY DEFAULT MODEL:
C  DEFAULT MODEL FOR ISTEP: NPLSI STEP FUNCTIONS FROM BULK ION FLUXES
C
C  FIRST: RADIAL STEP FUNCTION:
C
          IF (INDTEC(NL1J,ISTRA).EQ.4) THEN
C
C  USE X-OR RADIAL DISTRIBUTION OF ION FLUX 0.5*NI(R,Y0,Z0)*CS(R,Y0,Z0)*(DELTA-Z
C  WITH: CS = COMMON ION ACOUSTIC SPEED
C  WITH: DELTA-Z = LENGTH IN TOROIDAL OR Z-DIRECTION
C  Y0:
            IF (INDIM(ISRFS,ISTRA).NE.2.OR..NOT.NLPOL) THEN
              IP=1
            ELSEIF (INDIM(ISRFS,ISTRA).EQ.2.AND.NLPOL) THEN
              IP=INSOR(ISRFS,ISTRA)
            ENDIF
            IF (INDIM(ISRFS,ISTRA).NE.3.OR..NOT.NLTOR) THEN
              IT=1
            ELSEIF (INDIM(ISRFS,ISTRA).EQ.3.AND.NLTOR) THEN
              IT=INSOR(ISRFS,ISTRA)
              WRITE (iunout,*) 
     .          'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
              WRITE (iunout,*) 'SAMPLING OF RADIAL (OR X-) CO-ORDINATE '
              WRITE (iunout,*) 'ON A POLOIDAL (OR Y-) SURFACE '
              WRITE (iunout,*) 'DEFINE STEP FUNCTION ELSEWHERE, ',
     .                    'EG. IN SAMUSR'
              WRITE (iunout,*) 'CALL EXIT '
              CALL EXIT_OWN(1)
            ENDIF
C
C  CURRENTLY: IN STANDARD GEOMETRY BLOCK  IBLOCK=1, TOROIDAL CELL IT=1
C

            IF (LEVGEO.EQ.1) THEN
              KAN=1
              KEN=NR1STM
              DO K=1,NR1STM
                IRSTEP(ISTEP,K)=K
                IASTEP(ISTEP,K)=0
                IBSTEP(ISTEP,K)=1
                IPSTEP(ISTEP,K)=IP
                IF (ISORFL == 1) IPSTEP(ISTEP,K)=IP-1
                ITSTEP(ISTEP,K)=IT
                RRSTEP(ISTEP,K)=RSURF(K)
                IF (NLTRZ) THEN
                  TORL(ISTEP,K)=ZDF
                ELSEIF (NLTRA.OR.NLTRT) THEN
                  TORL(ISTEP,K)=(RSURF(K+1)+RSURF(K))/2._DP
                  TORL(ISTEP,K)=TORL(ISTEP,K)*2._DP*PIA
                ENDIF
              ENDDO
              NBIN=NR1ST
            ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
              KAN=1
              KEN=NR1STM
              DO K=1,NR1STM
                IRSTEP(ISTEP,K)=K
                IASTEP(ISTEP,K)=0
                IBSTEP(ISTEP,K)=1
                IPSTEP(ISTEP,K)=IP
                IF (ISORFL == 1) IPSTEP(ISTEP,K)=IP-1
                ITSTEP(ISTEP,K)=IT
                RRSTEP(ISTEP,K)=BGLP(K,IP)
                IF (NLTRZ) THEN
                  TORL(ISTEP,K)=ZDF
                ELSEIF (NLTRA.OR.NLTRT) THEN
                  TORL(ISTEP,K)=(XPOL(K+1,IP)+XPOL(K,IP))/2._DP
                  TORL(ISTEP,K)=TORL(ISTEP,K)*2._DP*PIA
                ENDIF
              ENDDO
              NBIN=NR1ST
            ELSEIF (LEVGEO.EQ.4) THEN
              K=0
              RRSTEP(ISTEP,1) = 0._DP
              INDSRF=INSOR(ISRFS,ISTRA)
              IF (INDSRF < 0) INDSRF=NLIM+ABS(INDSRF)
              DO ITRI=1,NTRII
                DO IS=1,3
                  IF (INMTI(IS,ITRI) == INDSRF) THEN
                    K=K+1
                    IS1=IS+1
                    IF (IS1.GT.3) IS1=1
                    IRSTEP(ISTEP,K)=ITRI
                    IPSTEP(ISTEP,K)=IS
                    ITSTEP(ISTEP,K)=IT
                    IASTEP(ISTEP,K)=0
                    IBSTEP(ISTEP,K)=1
!pb  projection to b-field switched off!!!
!pb  to allow for step functions on surfaces perpendicular to magnetic field 
!pb                    BABS=SQRT(BXIN(ITRI)**2+BYIN(ITRI)**2+BZIN(ITRI)**2)
!pb                    CTETHA=ABS((PTRIX(IS,ITRI)*BXIN(ITRI) +
!pb     .                          PTRIY(IS,ITRI)*BYIN(ITRI))/BABS)
                    CTETHA = 1._DP
                    RRSTEP(ISTEP,K+1)=RRSTEP(ISTEP,K) + CTETHA*SQRT(
     .              (XTRIAN(NECKE(IS,ITRI))-XTRIAN(NECKE(IS1,ITRI)))**2+
     .              (YTRIAN(NECKE(IS,ITRI))-YTRIAN(NECKE(IS1,ITRI)))**2)
                    IF (NLTRZ) THEN
                      TORL(ISTEP,K)=ZDF
                    ELSEIF (NLTRA.OR.NLTRT) THEN
                      TORL(ISTEP,K)=
     .                  (XTRIAN(NECKE(IS,ITRI))+XTRIAN(NECKE(IS1,ITRI)))
     .                  /2._DP
                      TORL(ISTEP,K)=TORL(ISTEP,K)*2._DP*PIA
                    ENDIF
                  END IF
                END DO
              END DO
              KAN=1
              KEN=K
              NBIN=K+1
            ELSEIF (LEVGEO.EQ.5) THEN
              K=0
              RRSTEP(ISTEP,1) = 0._DP
              WRITE(0,*) 'DEBUG: SAMSRF 1.00',ntet
              DO ITET=1,NTET
                DO IS=1,4
                  IF (INMTIT(IS,ITET) == NLIM+INSOR(ISRFS,ISTRA)) THEN
                    CALL TET_STEP (ISTEP,ITET,IS,K)
                  END IF
                END DO
              END DO
              KAN=1
              KEN=K
C  toroidal length: already included in RRSTEP, which is a surface area
              TORL(ISTEP,KAN:KEN)=1._DP
              NBIN=K+1
            ELSEIF (LEVGEO.GE.6) THEN
              GOTO 3
            ENDIF
C
C  NOW SET THE FLUX DISTRIBUTION FLSTEP
C
            DO K=KAN,KEN
              NBLCKA=NSTRD*(IBSTEP(ISTEP,K)-1)+IASTEP(ISTEP,K)
              NCELL=IRSTEP(ISTEP,K)+
     .            ((IPSTEP(ISTEP,K)-1)+(ITSTEP(ISTEP,K)-1)*NP2T3)*
     .             NR1P2+NBLCKA
              TESTEP(ISTEP,K)=TEIN(NCELL)
              DO 2 IPLS=1,NPLSI
                IPLSTI = MPLSTI(IPLS)
                IPLSV = MPLSV(IPLS)
                TISTEP(IPLSTI,ISTEP,K)=TIIN(IPLSTI,NCELL)
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR(2,VXSTEP(IPLSV,ISTEP,K),
     .                          VYSTEP(IPLSV,ISTEP,K),
     .                          VZSTEP(IPLSV,ISTEP,K),IPLSV)
                ELSE
                  VXSTEP(IPLSV,ISTEP,K)=VXIN(IPLSV,NCELL)
                  VYSTEP(IPLSV,ISTEP,K)=VYIN(IPLSV,NCELL)
                  VZSTEP(IPLSV,ISTEP,K)=VZIN(IPLSV,NCELL)
                END IF
                DISTEP(IPLS,ISTEP,K)=DIIN(IPLS,NCELL)
                CS=CVEL2A*SQRT((TIIN(IPLSTI,NCELL)+TEIN(NCELL))/
     .             RMASSP(IPLS))
                FF=ELCHA*CS
                FLSTEP(IPLS,ISTEP,K)=FF*DIIN(IPLS,NCELL)*TORL(ISTEP,K)
2             CONTINUE
            END DO
3           CONTINUE
C
C  LAST INTERVAL BOUNDARY FOR SAMPLING DISTRIBUTION
C
            IF (LEVGEO.EQ.1) THEN
              RRSTEP(ISTEP,NR1ST)=RSURF(NR1ST)
            ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
              RRSTEP(ISTEP,NR1ST)=BGLP(NR1ST,IP)
            ELSEIF (LEVGEO.GE.4) THEN
C  RRSTEP(ISTEP,NBIN) ALREADY SET ABOVE
            ENDIF
            FL=STEP(1,NPLSI,NBIN,ISTEP)
C
          ELSEIF (INDTEC(NL2J,ISTRA).EQ.4) THEN
            WRITE (iunout,*) 'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
            WRITE (iunout,*) 'SAMPLING OF RADIAL CO-ORDINATE '
            WRITE (iunout,*) 
     .        'DEFINE STEP FUNCTION ELSEWHERE, EG. IN SAMUSR'
            WRITE (iunout,*) 'CALL EXIT '
            CALL EXIT_OWN(1)
C
          ELSEIF (INDTEC(NL3J,ISTRA).EQ.4) THEN
            WRITE (iunout,*) 'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
            WRITE (iunout,*) 'SAMPLING OF RADIAL CO-ORDINATE '
            WRITE (iunout,*) 
     .        'DEFINE STEP FUNCTION ELSEWHERE, EG. IN SAMUSR'
            WRITE (iunout,*) 'CALL EXIT '
            CALL EXIT_OWN(1)
          ENDIF
C
        ENDIF
C
7       CONTINUE
C
C  DEFINE LEFT AND RIGHT BOUNDARY OF SAMPLING INTERVALS.
C
        IF (INDIM(ISRFS,ISTRA).EQ.1) THEN
C  SOURCE ON RADIAL SURFACE: SAMPLE SECOND AND THIRD CO-ORDINATE,
C                            COMPUTE FIRST CO-ORDINATE
C
          INDTEC(NL1J,ISTRA)=0
C
          ISGRD2=INGRDA(ISRFS,ISTRA,2)+INGRDE(ISRFS,ISTRA,2)
          ISGRD3=INGRDA(ISRFS,ISTRA,3)+INGRDE(ISRFS,ISTRA,3)
          IF ((LEVGEO.EQ.2.OR.LEVGEO.EQ.3).AND.ISGRD2.GT.0) THEN
            IS1=MAX0(1,INGRDA(ISRFS,ISTRA,2))
            IS2=MIN0(NP2ND,INGRDE(ISRFS,ISTRA,2))
            ALEFT(2,ISRFS,ISTRA)=BGL(INSOR(ISRFS,ISTRA),IS1)
            BRGHT(2,ISRFS,ISTRA)=BGL(INSOR(ISRFS,ISTRA),IS2)
          ELSEIF (LEVGEO.EQ.4.OR.LEVGEO.EQ.5) THEN
            ISTEP=MOD(IDINT(REAL(SORIND(ISRFS,ISTRA),KIND(1.D0))),100)
            ISTEP_SPEZ=SORIND(ISRFS,ISTRA)/100
            IF (ISTEP.NE.0.AND.NSMAX(ISTEP).NE.0) THEN
              ALEFT(2,ISRFS,ISTRA)=RRSTEP(ISTEP,1)
              BRGHT(2,ISRFS,ISTRA)=RRSTEP(ISTEP,NSMAX(ISTEP))
            ELSE IF ((ISTEP == 0) .AND. (LEVGEO == 4)) THEN
!PB                 
              INS = INSOR(ISRFS,ISTRA)
              ALEFT(2,ISRFS,ISTRA)=SURF_TRIAN(INS)%BGLT(1)
              BRGHT(2,ISRFS,ISTRA)=SURF_TRIAN(INS)%
     .                             BGLT(SURF_TRIAN(INS)%NUMTR+1)              
            ELSE
              WRITE (iunout,*) ' ERROR IN SAMSRF '
              WRITE (iunout,*) 
     .          ' INDIM=1 ONLY FORESEEN WITH STEPFUNCTION '
              WRITE (iunout,*) ' FOR LEVGEO=4 OR LEVGEO=5 '
              CALL EXIT_OWN(1)
            ENDIF
          ELSE
            ALEFT(2,ISRFS,ISTRA)=SORAD3(ISRFS,ISTRA)
            BRGHT(2,ISRFS,ISTRA)=SORAD4(ISRFS,ISTRA)
          ENDIF
          ALEFT(3,ISRFS,ISTRA)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS,ISTRA)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.2) THEN
C  SOURCE ON POLOIDAL SURFACE: SAMPLE FIRST AND THIRD CO-ORDINATE,
C                              COMPUTE SECOND CO-ORDINATE
C
          INDTEC(NL2J,ISTRA)=0
C
          ISGRD1=INGRDA(ISRFS,ISTRA,1)+INGRDE(ISRFS,ISTRA,1)
          ISGRD3=INGRDA(ISRFS,ISTRA,3)+INGRDE(ISRFS,ISTRA,3)
          IF ((LEVGEO.EQ.2.OR.LEVGEO.EQ.3).AND.ISGRD1.GT.0) THEN
            IS1=MAX0(1,INGRDA(ISRFS,ISTRA,1))
            IS2=MIN0(NR1ST,INGRDE(ISRFS,ISTRA,1))
            ALEFT(1,ISRFS,ISTRA)=BGLP(IS1,INSOR(ISRFS,ISTRA))
            BRGHT(1,ISRFS,ISTRA)=BGLP(IS2,INSOR(ISRFS,ISTRA))
          ELSE
            ALEFT(1,ISRFS,ISTRA)=SORAD1(ISRFS,ISTRA)
            BRGHT(1,ISRFS,ISTRA)=SORAD2(ISRFS,ISTRA)
          ENDIF
          ALEFT(3,ISRFS,ISTRA)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS,ISTRA)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.3) THEN
C  SOURCE ON TOROIDAL SURFACE: SAMPLE FIRST AND SECOND CO-ORDINATE,
C                              COMPUTE THIRD CO-ORDINATE
C
          INDTEC(NL3J,ISTRA)=0
C
          ISGRD1=INGRDA(ISRFS,ISTRA,1)+INGRDE(ISRFS,ISTRA,1)
          ISGRD2=INGRDA(ISRFS,ISTRA,2)+INGRDE(ISRFS,ISTRA,2)
C         IF (LEVGEO.EQ.3.AND.ISGRD1.GT.0) THEN
C         ELSE
            ALEFT(1,ISRFS,ISTRA)=SORAD1(ISRFS,ISTRA)
            BRGHT(1,ISRFS,ISTRA)=SORAD2(ISRFS,ISTRA)
C         ENDIF
          ALEFT(2,ISRFS,ISTRA)=SORAD3(ISRFS,ISTRA)
          BRGHT(2,ISRFS,ISTRA)=SORAD4(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.4) THEN
C  SOURCE ON RADIAL AND POLOIDAL SURFACES:
C      SAMPLE ARC-LENGTH AND THIRD CO-ORDINATE,
C      COMPUTE FIRST AND SECOND CO-ORDINATE FROM ARCLENGTH
C
          INDTEC(NL2J,ISTRA)=0
C
          ISTEP=MOD(IDINT(REAL(SORIND(ISRFS,ISTRA),KIND(1.D0))),100)
          ISTEP_SPEZ=SORIND(ISRFS,ISTRA)/100
          IF (ISTEP.NE.0.AND.NSMAX(ISTEP).NE.0) THEN
            ALEFT(1,ISRFS,ISTRA)=RRSTEP(ISTEP,1)
            BRGHT(1,ISRFS,ISTRA)=RRSTEP(ISTEP,NSMAX(ISTEP))
          ELSE
            WRITE (iunout,*) ' ERROR IN SAMSRF '
            WRITE (iunout,*) ' INDIM=4 ONLY FORESEEN WITH STEPFUNCTION '
            CALL EXIT_OWN(1)
          ENDIF
          ALEFT(3,ISRFS,ISTRA)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS,ISTRA)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.0) THEN
C  SOURCE ON ADDITIONAL SURFACE
          ALEFT(1,ISRFS,ISTRA)=SORAD1(ISRFS,ISTRA)
          BRGHT(1,ISRFS,ISTRA)=SORAD2(ISRFS,ISTRA)
          ALEFT(2,ISRFS,ISTRA)=SORAD3(ISRFS,ISTRA)
          BRGHT(2,ISRFS,ISTRA)=SORAD4(ISRFS,ISTRA)
          ALEFT(3,ISRFS,ISTRA)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS,ISTRA)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (TRCSOU.AND.ISTEP.GT.0) THEN
          NSMX=NSMAX(ISTEP)
C  IDENTIFY THOSE BULK SPECIES WITH NON-ZERO FLUX
          FLX=0.
          EKFLX=0.
          ESHFLX=0.
          DO  IPLS=1,NPLSI
            DO  K=1,NSMX-1
              DELR=RRSTEP(ISTEP,K+1)-RRSTEP(ISTEP,K)
              FF=FLSTEP(IPLS,ISTEP,K)*DELR
              FLX(IPLS)=FLX(IPLS)+FF
              EKFLX(IPLS)=EKFLX(IPLS)+ELSTEP(IPLS,ISTEP,K)*DELR
              ESHFLX(IPLS)=ESHFLX(IPLS)+
     .                     FF*SHSTEP(ISTEP,K)*TESTEP(ISTEP,K)
            ENDDO
          ENDDO
          NANZ=COUNT(FLX(:).GT.0.D0)
          IPLSD(1:NANZ)=PACK((/(IPL,IPL=1,NPLSI)/),FLX(:).GT.0.D0)
C
          WRITE (iunout,*) 'FUNCTION STEP NO. ',ISTEP,': '
          WRITE (iunout,'(1X,A4,A12,5(2X,A7,I2,A1))')
     .    '   K','  RRSTEP    ',('FLSTEP(',IPLSD(IPL),'): AMP/CM**2',
     .    IPL=1,NANZ)
          DO 4 K=1,NSMX-1
            WRITE (iunout,'(1X,I4,1P,6E12.4/(5x,1P,6E12.4))')
     .               K,RRSTEP(ISTEP,K),
     .               (FLSTEP(IPLSD(IPL),ISTEP,K),IPL=1,NANZ)
4         CONTINUE

          WRITE (iunout,'(1X,I4,1P,2E12.4)') NSMX,RRSTEP(ISTEP,NSMX)
          CALL LEER(1)

          WRITE (iunout,*) 'FLUXES: PART., KINET., SHEATH; INTEGRATED:'
          DO 5 IPL=1,NANZ
            CALL MASJ1R('IP,FLUX      [A]',IPL,FLX(IPLSD(IPL)))
            CALL MASJ1R('IP,EKIN-FLUX [W]',IPL,EKFLX(IPLSD(IPL)))
            CALL MASJ1R('IP,ESH-FLUX  [W]',IPL,ESHFLX(IPLSD(IPL)))
5         CONTINUE
          CALL LEER(2)
        ENDIF
C
C
C  STEP FUNCTION INITIALISATION FINISHED.
C  NEXT: STORE SOME DATA TO SPEED UP SAMPLING FROM STEP FUNCTION
C
        ISPZ=0
        IF (NSPEZ(ISTRA).GT.0) ISPZ=NSPEZ(ISTRA)
        IF (ISTEP_SPEZ.GT.0) ISPZ=ISTEP_SPEZ
C
        IF (ISTEP.GT.0) THEN
          IF (ISPZ.GT.0.AND.ISPZ.LT.NSPSTI(ISTEP)) GOTO 991
          IF (              ISPZ.GT.NSPSTE(ISTEP)) GOTO 991
C
          IF (INDTEC(NL1J,ISTRA).EQ.4) THEN
            XI(1,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,ALEFT(1,ISRFS,ISTRA))
            XE(1,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,BRGHT(1,ISRFS,ISTRA))
            IF (TRCSOU) THEN
              WRITE (IUNOUT,*) ' XI ',XI(1,ISRFS,ISTRA) 
              WRITE (IUNOUT,*) ' XE ',XE(1,ISRFS,ISTRA) 
              DO IPL=1,NANZ
                WRITE (IUNOUT,*) 'FLUX ONTO SOURCE SURFACE [A] ',IPL,
     .                (XE(1,ISRFS,ISTRA)-XI(1,ISRFS,ISTRA))*
     .                 FLX(IPLSD(IPL))
              END DO
            END IF
          ELSEIF (INDTEC(NL2J,ISTRA).EQ.4) THEN
            XI(2,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,ALEFT(2,ISRFS,ISTRA))
            XE(2,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,BRGHT(2,ISRFS,ISTRA))
            IF (TRCSOU) THEN
              WRITE (IUNOUT,*) ' XI ',XI(2,ISRFS,ISTRA) 
              WRITE (IUNOUT,*) ' XE ',XE(2,ISRFS,ISTRA) 
              DO IPL=1,NANZ
                WRITE (IUNOUT,*) 'FLUX ONTO SOURCE SURFACE [A] ',IPL,
     .                (XE(2,ISRFS,ISTRA)-XI(2,ISRFS,ISTRA))*
     .                 FLX(IPLSD(IPL))
              END DO
            END IF
          ELSEIF (INDTEC(NL3J,ISTRA).EQ.4) THEN
            XI(3,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,ALEFT(3,ISRFS,ISTRA))
            XE(3,ISRFS,ISTRA)=STEP0(ISPZ,ISTEP,BRGHT(3,ISRFS,ISTRA))
            IF (TRCSOU) THEN
              WRITE (IUNOUT,*) ' XI ',XI(3,ISRFS,ISTRA) 
              WRITE (IUNOUT,*) ' XE ',XE(3,ISRFS,ISTRA) 
              DO IPL=1,NANZ
                WRITE (IUNOUT,*) 'FLUX ONTO SOURCE SURFACE [A] ',IPL,
     .                (XE(3,ISRFS,ISTRA)-XI(3,ISRFS,ISTRA))*
     .                 FLX(IPLSD(IPL))
              END DO
            END IF
          ENDIF
        ENDIF
C
1     CONTINUE
C
      IF (TRCSOU) CALL LEER(2)

      END DO    ! STRATA LOOP

      RETURN
C
      ENTRY SAMSF1(NLSF,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
C
      ICOUNT=0
100   CONTINUE
      ICOUNT=ICOUNT+1
C
C   NLSF=SURFACE INDEX IN (NSRFS ) SOURCE  ARRAYS
C
      JCALC=0
      ISTEP=0
C
      DO 101 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
101   CONTINUE
C
C   USER SUPPLIED GENERATOR FOR X0,Y0,Z0. ONLY ONE CALL
C   FOR ALL 3 CO-ORDINATES. SUBR. SURTST IS NOT CALLED!
C
      IF (SORLIM(NLSF,ISTRA).LT.0.D0) THEN
        CALL SM1USR(NLSF,X0,Y0,Z0,
     .              SORAD1(NLSF,ISTRA),SORAD2(NLSF,ISTRA),
     .              SORAD3(NLSF,ISTRA),SORAD4(NLSF,ISTRA),
     .              SORAD5(NLSF,ISTRA),SORAD6(NLSF,ISTRA),
     .              IRUSR,IPUSR,ITUSR,IAUSR,IBUSR,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
        ISTEP=-1
        ZZ(1)=X0
        ZZ(2)=Y0
        ZZ(3)=Z0
        GOTO 1500
      ENDIF
C
      ZZ = 0._DP
      DO 1000 J=1,3
        IK=NLSF+(J-1)*NSRFS
        GOTO (10,20,30,40),INDTEC(IK,ISTRA)
C   ZZ(JCALC) IS TO BE CALCULATED FROM SURFACE-EQUATION
          IF (JCALC.NE.0) GOTO 997
          JCALC=J
          GOTO 1000
C   DELTA DISTRIBUTION AT CENTER OF INTERVALL
10      CONTINUE
          ZZ(J)=(ALEFT(J,NLSF,ISTRA)+BRGHT(J,NLSF,ISTRA))*0.5
          GOTO 1000
C   UNIFORM DISTRIBUTION IN THIS CO-ORDINATE
20      CONTINUE
          ZZ(J)=RANF_EIRENE( )*(BRGHT(J,NLSF,ISTRA)-
     .          ALEFT(J,NLSF,ISTRA))+ALEFT(J,NLSF,ISTRA)
          GOTO 1000
C   TRUNCATED EXPONENTIAL DECAY WITH LENGTH XLAMDA, FOR ONE CO-ORDINATE ONLY
C   PARAMETER: SOREXP
C   METHOD: COVEYOU-TRICK  (SPANIER-GELBARD, ADDISON WESLEY,  P 35)
30      CONTINUE
          DELTA=BRGHT(J,NLSF,ISTRA)-ALEFT(J,NLSF,ISTRA)
          XLAMDA=SOREXP(NLSF,ISTRA)
          ZM=DELTA/XLAMDA
          ZH=MOD(-LOG(RANF_EIRENE( )),ZM)
          ZZ(J)=XLAMDA*ZH+ALEFT(J,NLSF,ISTRA)
          GOTO 1000
C   STEPFUNCTION NO. ISTEP, FOR ONE CO-ORDINATE ONLY
C   PARAMETER: SORIND
40      CONTINUE
          ISTEP=MOD(IDINT(REAL(SORIND(NLSF,ISTRA),KIND(1.D0))),100)
          ISTEP_SPEZ = SORIND(NLSF,ISTRA)/100
          ISPZ=NSPEZ(ISTRA)
          IF (ISTEP_SPEZ.GT.0) ISPZ=ISTEP_SPEZ
          RNF=XI(J,NLSF,ISTRA)+RANF_EIRENE( )*
     .        (XE(J,NLSF,ISTRA)-XI(J,NLSF,ISTRA))
          ZZ(J)=STEP1(IINDEX,ISTEP,RNF,ISPZ)
          GOTO 1000
1000  CONTINUE
C
      IPOLG=1
C
1500  CONTINUE
C
C  1500---2000
C  IN CASE OF DEFAULT SAMPLING:
C    TWO OUT OF THE THREE CO-ORDINATES ZZ(1),ZZ(2),ZZ(3) ARE
C    SAMPLED.
C    FIND 3RD CO-ORDINATE FROM SURFACE EQUATION
C    CONVERT ZZ(1), ZZ(2), ZZ(3) TO CARTHESIAN CO-ORDINATES X0,Y0,Z0
C  IN CASE OF USER SUPPLIED SAMPLING:
C    THE THREE CARTHESIAN CO-ORDINATES X0,Y0,Z0 ARE GIVEN NOW
C    ONLY SURFACE FLAGS NLSRFX,...MRSURF,.... MUST BE SET
C
      IF (INDIM(NLSF,ISTRA).EQ.0) THEN
C  BIRTH POINT ON ADDITIONAL SURFACE, ZZ( ) ARE CARTHESIAN
        NLSRFX=.FALSE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        MTSURF=0
        MPSURF=0
        MRSURF=0
        MASURF=INSOR(NLSF,ISTRA)
        ILTR=ILTOR(MASURF)
        IF (NLTRZ.OR.     ILTR.NE.0) THEN
C Z0 IS GIVEN IN LOCAL CO-ORDINATE SYSTEM ILTOR
          Z0=ZZ(3)
        ELSEIF (NLTRA.AND.ILTR.EQ.0) THEN
          PHI=ZZ(3)*DEGRAD
C Z0 IS IRRELEVANT HERE, AND IS DETERMINED LATER FROM PHI
        ELSEIF (NLTRT.AND.ILTR.EQ.0) THEN
          PHI=ZZ(3)*DEGRAD
C Z0 IS IRRELEVANT HERE, AND IS DETERMINED LATER FROM PHI
        ENDIF
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
C
        IF (JCALC.EQ.1) THEN
C  FIND X CO-ORDINATE X0 FROM Y=Y0 AND Z=Z0 ON SURFACE NO. MASURF
          Y0=ZZ(2)
          IF (NLTRA.AND.ILTR.EQ.0) THEN
            WRITE (iunout,*) 'Z0 IN SAMSRF FOR JCALC=1 ?? '
            CALL EXIT_OWN(1)
          ENDIF
          IF (JUMLIM(MASURF).NE.0) THEN
            IF (ABS(A1LM(MASURF)).LE.EPS12) GOTO 9931
            AN=-1./A1LM(MASURF)
            X0=(A0LM(MASURF)+Y0*A2LM(MASURF)+Z0*A3LM(MASURF))*AN
          ELSE
            S=A4LM(MASURF)
            Q=A0LM(MASURF)+(A2LM(MASURF)+A5LM(MASURF)*Y0)*Y0+
     .        (A3LM(MASURF)+A6LM(MASURF)*Z0+A9LM(MASURF)*Y0)*Z0
            P=A1LM(MASURF)+A7LM(MASURF)*Y0+A8LM(MASURF)*Z0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN X
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                X0=PH
              ELSEIF (DET.GT.0.D0) THEN
                X0=PH+SIGN(1._DP,RANF_EIRENE()-0.5_DP)*SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) THEN
                  IF (ICOUNT.LE.1000) GOTO 100
                  WRITE (IUNOUT,*) 'PROBABLY ILL DEFINED SURFACE '
                  WRITE (IUNOUT,*) 'SAMPLING, MASURF = ',MASURF
                  LGPART=.FALSE.
                  RETURN
                ENDIF
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN X
              X0=Q/P
            ELSE
C  INDEPENDENT OF X
              GOTO 9931
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR X0?
          X0TEST=ABS(ALEFT(1,NLSF,ISTRA)-BRGHT(1,NLSF,ISTRA))
          IF (X0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(1,NLSF,ISTRA).GT.X0 .OR.
     .        BRGHT(1,NLSF,ISTRA).LT.X0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (iunout,*) 
     .        'WARNING FROM SAMSRF FROM X0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF

        ELSEIF (JCALC.EQ.2) THEN
C    FIND Y CO-ORDINATE Y0 FROM X=X0 AND Z=Z0 ON SURFACE NO. MASURF
          X0=ZZ(1)
          IF (NLTRA.AND.ILTR.EQ.0) THEN
C  FIND Z0, NT,  FROM X0,PHI
            IF (PHI.LT.ZSURF(1)) PHI=PHI+PI2A
            IF (PHI.GT.ZSURF(NTTRA)) PHI=PHI-PI2A
            NT=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMSRF     1')
            IF (NT.LE.0.OR.NT.GT.NTTRAM) THEN
              WRITE (iunout,*) 'NT OUT OF RANGE IN SAMSRF '
              WRITE (iunout,*) PHI,ZFULL
              CALL EXIT_OWN(1)
            ENDIF
            X01=X0+RMTOR
            CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
          ENDIF
          IF (JUMLIM(MASURF).NE.0) THEN
            IF (ABS(A2LM(MASURF)).LE.EPS12) GOTO 9931
            AN=-1./A2LM(MASURF)
            Y0=(A0LM(MASURF)+X0*A1LM(MASURF)+Z0*A3LM(MASURF))*AN
          ELSE
            S=A5LM(MASURF)
            Q=A0LM(MASURF)+(A1LM(MASURF)+A4LM(MASURF)*X0)*X0+
     .        (A3LM(MASURF)+A6LM(MASURF)*Z0+A8LM(MASURF)*X0)*Z0
            P=A2LM(MASURF)+A7LM(MASURF)*X0+A9LM(MASURF)*Z0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN Y
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                Y0=PH
              ELSEIF (DET.GT.0.D0) THEN
                Y0=PH+SIGN(1._DP,RANF_EIRENE()-0.5_DP)*SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) THEN
                  IF (ICOUNT.LE.1000) GOTO 100
                  WRITE (IUNOUT,*) 'PROBABLY ILL DEFINED SURFACE '
                  WRITE (IUNOUT,*) 'SAMPLING, MASURF = ',MASURF
                  LGPART=.FALSE.
                  RETURN
                ENDIF
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN Y
              Y0=Q/P
            ELSE
C  INDEPENDENT OF Y
              GOTO 9931
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR Y0?
          Y0TEST=ABS(ALEFT(2,NLSF,ISTRA)-BRGHT(2,NLSF,ISTRA))
          IF (Y0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(2,NLSF,ISTRA).GT.Y0 .OR.
     .        BRGHT(2,NLSF,ISTRA).LT.Y0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (iunout,*) 
     .        'WARNING FROM SAMSRF FROM Y0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF

        ELSEIF (JCALC.EQ.3) THEN
C    FIND Z CO-ORDINATE Z0 FROM X=X0 AND Y=Y0 ON SURFACE NO. MASURF
          X0=ZZ(1)
          Y0=ZZ(2)
          IF ((NLTRA.OR.NLTRT).AND.ILTR.EQ.0) GOTO 9931
          IF (JUMLIM(MASURF).NE.0) THEN
            IF (ABS(A3LM(MASURF)).LE.EPS12) GOTO 9931
            AN=-1./A3LM(MASURF)
            Z0=(A0LM(MASURF)+X0*A1LM(MASURF)+Y0*A2LM(MASURF))*AN
          ELSE
            S= A6LM(MASURF)
            Q= A0LM(MASURF)+(A1LM(MASURF)+A4LM(MASURF)*X0)*X0+
     .        (A2LM(MASURF)+A5LM(MASURF)*Y0+A7LM(MASURF)*X0)*Y0
            P= A3LM(MASURF)+A8LM(MASURF)*X0+A9LM(MASURF)*Y0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN Z
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                Z0=PH
              ELSEIF (DET.GT.0.D0) THEN
                Z0=PH+SIGN(1._DP,RANF_EIRENE()-0.5_DP)*SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) THEN
                  IF (ICOUNT.LE.1000) GOTO 100
                  WRITE (IUNOUT,*) 'PROBABLY ILL DEFINED SURFACE '
                  WRITE (IUNOUT,*) 'SAMPLING, MASURF = ',MASURF
                  LGPART=.FALSE.
                  RETURN
                ENDIF
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN Z
              Z0=Q/P
            ELSE
C  INDEPENDENT OF Z
              GOTO 9931
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR Z0?
          Z0TEST=ABS(ALEFT(3,NLSF,ISTRA)-BRGHT(3,NLSF,ISTRA))
          IF (Z0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(3,NLSF,ISTRA).GT.Z0 .OR.
     .        BRGHT(3,NLSF,ISTRA).LT.Z0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (iunout,*) 'WARNING FROM SAMSRF, Z0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF
C
        ELSE
          X0=ZZ(1)
          Y0=ZZ(2)
          Z0=ZZ(3)
        ENDIF
C
        CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
        IF (.NOT.LOGTST) GOTO 998
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.1) THEN
C  BIRTH POINT ON STANDARD RADIAL SURFACE  MRSURF
C  Y- OR POLOIDAL AND Z- OR TOROIDAL CO-ORDINATES MUST BE SAMPLED
C  X-OR RADIAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
C  SPECIAL CASE: LEVGEO=5: SAMPLE ON SURFACE IN 3D, DISCRETISED BY
C                SET OF TRIANGLES (SELECTED SIDES OF TETRAHEDONS)
        NLSRFX=.TRUE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        MRSURF=INSOR(NLSF,ISTRA)
        MPSURF=0
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.2.OR.JCALC.EQ.3) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=RSURF(MRSURF)
          Y0=ZZ(2)
        ELSEIF (LEVGEO.EQ.2) THEN
          X0=RSURF(MRSURF)*COS(ZZ(2)*DEGRAD)+EP1(MRSURF)
          Y0=RSURF(MRSURF)*SIN(ZZ(2)*DEGRAD)*ELL(MRSURF)
        ELSEIF (LEVGEO.EQ.3) THEN
          BL=ZZ(2)
          DO 1501 I=1,NPPLG
            DO 1501 J=NPOINT(1,I),NPOINT(2,I)
            IF (BL.LE.BGL(MRSURF,J)) GOTO 1502
1501      CONTINUE
          GOTO 996
1502      CONTINUE
          IPLG=J-1
          D=BL-BGL(MRSURF,IPLG)
          VVX=VPLX(MRSURF,IPLG)
          VVY=VPLY(MRSURF,IPLG)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
          X0=XPOL(MRSURF,IPLG)+D*VVX*VVI
          Y0=YPOL(MRSURF,IPLG)+D*VVY*VVI
        ELSEIF (LEVGEO.EQ.4) THEN
          BL=ZZ(2)
          IF (ISTEP.LE.0) THEN
            DO I=1,SURF_TRIAN(MRSURF)%NUMTR
              IF (BL.LE.SURF_TRIAN(MRSURF)%BGLT(I+1)) GOTO 1503
            END DO
            GOTO 996
 1503       CONTINUE
            ITRI = SURF_TRIAN(MRSURF)%ITRIAS(I)
            IPLG = SURF_TRIAN(MRSURF)%ITRISI(I)
            D = BL - SURF_TRIAN(MRSURF)%BGLT(I)
            MRSURF=ITRI
          ELSE
            ITRI=IRSTEP(ISTEP,IINDEX)
            IPLG=IPSTEP(ISTEP,IINDEX)
            MRSURF=ITRI
            D=BL-RRSTEP(ISTEP,IINDEX)
          END IF
          VVX=VTRIX(IPLG,ITRI)
          VVY=VTRIY(IPLG,ITRI)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
          X0=XTRIAN(NECKE(IPLG,ITRI))+D*VVX*VVI
          Y0=YTRIAN(NECKE(IPLG,ITRI))+D*VVY*VVI
        ELSEIF (LEVGEO.EQ.5) THEN
          IF (ISTEP.LE.0) GOTO 995
          ITET=IRSTEP(ISTEP,IINDEX)
          ISID=IPSTEP(ISTEP,IINDEX)
          MRSURF=ITET
          X1=XTETRA(NTECK(ITSIDE(1,ISID),ITET))
          Y1=YTETRA(NTECK(ITSIDE(1,ISID),ITET))
          Z1=ZTETRA(NTECK(ITSIDE(1,ISID),ITET))
          X2=XTETRA(NTECK(ITSIDE(2,ISID),ITET))
          Y2=YTETRA(NTECK(ITSIDE(2,ISID),ITET))
          Z2=ZTETRA(NTECK(ITSIDE(2,ISID),ITET))
          X3=XTETRA(NTECK(ITSIDE(3,ISID),ITET))
          Y3=YTETRA(NTECK(ITSIDE(3,ISID),ITET))
          Z3=ZTETRA(NTECK(ITSIDE(3,ISID),ITET))
          CALL FPOLYT_3(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X0,Y0,Z0)
        ELSEIF (LEVGEO.EQ.6) THEN
          WRITE (iunout,*) 'ERROR EXIT FROM SAMSRF. NLPOL ',LEVGEO
          CALL EXIT_OWN(1)
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.2) THEN
C  BIRTH POINT ON STANDARD POLOIDAL SURFACE MPSURF
C  X-OR RADIAL CO-ORDINATE AND Z-OR TOROIDAL CO-ORDINATE MUST BE SAMPLED
C  Y-OR POLOIDAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
        NLSRFX=.FALSE.
        NLSRFY=.TRUE.
        NLSRFZ=.FALSE.
        MRSURF=0
        MPSURF=INSOR(NLSF,ISTRA)
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.3) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=ZZ(1)
          Y0=PSURF(MPSURF)
        ELSEIF (LEVGEO.EQ.2.AND.NLCRC) THEN
          X0=ZZ(1)*COSPH(MPSURF)
          Y0=ZZ(1)*SINPH(MPSURF)
        ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
          BL=ZZ(1)
          DO 1601 J=2,NR1ST
            IF (BL.LE.BGLP(J,MPSURF)) GOTO 1602
1601      CONTINUE
          GOTO 996
1602      CONTINUE
          IPLG=J-1
          D=BL-BGLP(IPLG,MPSURF)
          VVX=VVTX(IPLG,MPSURF)
          VVY=VVTY(IPLG,MPSURF)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
          X0=XPOL(IPLG,MPSURF)+D*VVX*VVI
          Y0=YPOL(IPLG,MPSURF)+D*VVY*VVI
        ELSE
          WRITE (iunout,*) 'ERROR IN SAMSRF: LEVGEO AND INDIM? '
          CALL EXIT_OWN(1)
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.3) THEN
C  BIRTH POINT ON STANDARD TOROIDAL SURFACE
C  X-OR RADIAL CO-ORDINATE AND Y-OR TOROIDAL CO-ORDINATE MUST BE SAMPLED
C  Z-OR TOROIDAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
        NLSRFX=.FALSE.
        NLSRFY=.FALSE.
        NLSRFZ=.TRUE.
        MRSURF=0
        MPSURF=0
        MTSURF=INSOR(NLSF,ISTRA)
        MASURF=0
        ILTR=0
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.2) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=ZZ(1)
          Y0=ZZ(2)
          Z0=ZSURF(MTSURF)
          IF (NLTRA) PHI=ZSURF(MTSURF)
        ELSEIF (LEVGEO.EQ.2.AND.NLCRC) THEN
          EP1ZZ1=0.0
          ELLZZ1=1.0
          X0=ZZ(1)*COS(ZZ(2)*DEGRAD)+EP1ZZ1
          Y0=ZZ(1)*SIN(ZZ(2)*DEGRAD)*ELLZZ1
          Z0=ZSURF(MTSURF)
          IF (NLTRA) PHI=ZSURF(MTSURF)
          IF (.NOT.NLCRC) GOTO 992
        ELSE
C  TO BE WRITTEN
          WRITE (iunout,*) 'ERROR IN SAMPLE, SOURCE ON TOR. SURFACE'
          CALL EXIT_OWN(1)
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.4) THEN
C  LEVGEO=3,4:
C     BIRTH POINT ON STANDARD RADIAL OR POLOIDAL SURFACE
C     ARC-LENGTH CO-ORDINATE IS SAMPLED FROM STEP FUNCTION
C  LEVGEO=5:
C     TRIANGULAR SURFACE SEGMENT IS SAMPLED FROM STEP FUNCTION
C     UNIFORM DISTRIBUTION WITHIN SURFACE SEGMENT
        IF (ISTEP.LE.0) GOTO 995
        NLSRFZ=.FALSE.
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.3) GOTO 993
C
        BL=ZZ(1)
        DO 1701 J=2,NSMAX(ISTEP)
          IF (BL.LE.RRSTEP(ISTEP,J)) GOTO 1702
1701    CONTINUE
        GOTO 996
1702    CONTINUE
        IPLG=J-1
        D=BL-RRSTEP(ISTEP,IPLG)
        IF (LEVGEO.EQ.4) THEN
          IF (ISTEP.LE.0) GOTO 995
          NLSRFX=.TRUE.
          NLSRFY=.FALSE.
          ITRI=IRSTEP(ISTEP,IINDEX)
          ISID=IPSTEP(ISTEP,IINDEX)
          MRSURF=ITRI
          VVX=VTRIX(ISID,ITRI)
          VVY=VTRIY(ISID,ITRI)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
          X0=XTRIAN(NECKE(ISID,ITRI))+D*VVX*VVI
          Y0=YTRIAN(NECKE(ISID,ITRI))+D*VVY*VVI
        ELSEIF (LEVGEO.EQ.5) THEN
          IF (ISTEP.LE.0) GOTO 995
          NLSRFX=.TRUE.
          NLSRFY=.FALSE.
          ITET=IRSTEP(ISTEP,IINDEX)
          ISID=IPSTEP(ISTEP,IINDEX)
          MRSURF=ITET
          X1=XTETRA(NTECK(ITSIDE(1,ISID),ITET))
          Y1=YTETRA(NTECK(ITSIDE(1,ISID),ITET))
          Z1=ZTETRA(NTECK(ITSIDE(1,ISID),ITET))
          X2=XTETRA(NTECK(ITSIDE(2,ISID),ITET))
          Y2=YTETRA(NTECK(ITSIDE(2,ISID),ITET))
          Z2=ZTETRA(NTECK(ITSIDE(2,ISID),ITET))
          X3=XTETRA(NTECK(ITSIDE(3,ISID),ITET))
          Y3=YTETRA(NTECK(ITSIDE(3,ISID),ITET))
          Z3=ZTETRA(NTECK(ITSIDE(3,ISID),ITET))
          CALL FPOLYT_3(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X0,Y0,Z0)
        ELSEIF (LEVGEO.EQ.3) THEN
          IF (IGSTEP(ISTEP,IPLG).LT.200000) THEN
C  RADIAL PART
            NLSRFX=.TRUE.
            NLSRFY=.FALSE.
            MPSURF=0
            MRSURF=IGSTEP(ISTEP,IPLG)-100000
            VVX=VPLX(MRSURF,IPSTEP(ISTEP,IPLG))
            VVY=VPLY(MRSURF,IPSTEP(ISTEP,IPLG))
            VVI=1./SQRT(VVX*VVX+VVY*VVY)
            X0=XPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVX*VVI
            Y0=YPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVY*VVI
          ELSE
C  POLOIDAL PART
            NLSRFX=.FALSE.
            NLSRFY=.TRUE.
            MRSURF=0
            MPSURF=IGSTEP(ISTEP,IPLG)-200000
            VVX=VVTX(IRSTEP(ISTEP,IPLG),MPSURF)
            VVY=VVTY(IRSTEP(ISTEP,IPLG),MPSURF)
            VVI=1./SQRT(VVX*VVX+VVY*VVY)
            X0=XPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVX*VVI
            Y0=YPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVY*VVI
          ENDIF
        ELSE
          GOTO 992
        ENDIF
      ENDIF
C
2000  CONTINUE
C
C  X0,Y0,Z0 AND PHI ARE GIVEN NOW.
C  MAKE SURE, THAT THESE ARE IN PROPER PERIODICITY BLOCK
C
      IF (NLTRA.AND.ILTR.GT.0) THEN
C  Z0 IS A CARTHESIAN CO-ORDINATE IN LOCAL SYSTEM ILTR
C  BIRTHPOINT IS ON ADDITIONAL SURFACE (BECAUSE ILTR.NE.0)
C  FIND PHI,NT AND THEN X0,Z0 IN CELL NT
        CALL FZRTOR(X0,Z0,ILTR,XR,PHI,NT,.FALSE.,0)
        IF (NT.NE.ILTR)
     .    CALL FZRTRI(X0,Z0,NT,XR,PHI,NT)
        X01=X0+RMTOR
      ELSEIF (NLTRA.AND.ILTR.EQ.0) THEN
C  PHI IS THE TOROIDAL ANGLE (RADIANS)
C  BIRTHPOINT IS EITHER ON ADDITIONAL OR ON STANDARD GRID SURFACE
C  FIND Z0, NT,  FROM X0,PHI
C
C  MOVE PHI AWAY FROM TOROIDAL PERIODICITY SURFACE
        IF (PHI.EQ.0.0.AND.ABS(ZSURF(1)).LT.EPS10) PHI=0.01
C  DONE
        IF (PHI.LT.ZSURF(1)) PHI=PHI+PI2A
        IF (PHI.GT.ZSURF(NTTRA)) PHI=PHI-PI2A
        NT=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMSRF     2')
        IF (NT.LE.0.OR.NT.GT.NTTRAM) THEN
          WRITE (iunout,*) 'NT OUT OF RANGE IN SAMSRF '
          WRITE (iunout,*) PHI,ZFULL
          CALL EXIT_OWN(1)
        ENDIF
        X01=X0+RMTOR
        CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
      ENDIF
C
C  FIND ZONE NUMBER NRCELL, NACELL ,NBLOCK AND IPOLG
C
      IF (NASOR(NLSF,ISTRA).GT.0.AND.NRSOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL=0
C  IPOLG=0
C  NBLOCK=NBMLTP
C  NACELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NASOR
        NACELL=NASOR(NLSF,ISTRA)
        NRCELL=0
        NBLOCK=NBMLTP
        IPOLG=0
      ELSEIF (NRSOR(NLSF,ISTRA).GT.0.AND.NASOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NRSOR
C  IPOLG  IS EXPLICITLY DEFINED BY INPUT VARIABLE NISOR
C  NBLOCK IS EXPLICITLY DEFINED BY INPUT VARIABLE NBSOR
C  NACELL=0
        NRCELL=NRSOR(NLSF,ISTRA)
        NBLOCK=NBSOR(NLSF,ISTRA)
        IPOLG=NISOR(NLSF,ISTRA)
        NACELL=0
      ELSEIF (NRSOR(NLSF,ISTRA).EQ.0.AND.NASOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL IS COMPUTED IN STANDARD MESH
C  IPOLG IS COMPUTED IN STANDARD MESH
C  NBLOCK IS EXPLICITLY DEFINED BY INPUT VARIABLE NBSOR
C  NACELL=0
        IF (NLSRFX) THEN
          NRCELL=MIN0(NR1STM,MRSURF)
          IAN=MRSURF
          IEN=MRSURF
          NDUM=LEARC1(X0,Y0,Z0,IPOLG,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .        'SAMSRF      ')
        ELSEIF (NLSRFY) THEN
          IPOLG=MIN0(NP2NDM,MPSURF)
          IAN=MPSURF
          IEN=MPSURF
          NRCELL=LEARC1(X0,Y0,Z0,IDUM,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                  'SAMSRF      ')
        ELSE
          NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,NLSRFX,NLSRFY,NPANU,
     .                  'SAMSRF      ')
        ENDIF
        NACELL=0
        NBLOCK=NBSOR(NLSF,ISTRA)
      ELSEIF (NRSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NRCELL IS FOUND FROM STEPFUNCTION DATA
C  IPOLG IS FOUND FROM STEPFUNCTION DATA
C  NBLOCK IS FOUND FROM STEPFUNCTION DATA
C  NACELL IS FOUND FROM STEPFUNCTION DATA
        NRCELL=IRSTEP(ISTEP,IINDEX)
        IPOLG =IPSTEP(ISTEP,IINDEX)
        NBLOCK=IBSTEP(ISTEP,IINDEX)
        NACELL=IASTEP(ISTEP,IINDEX)
      ELSEIF (NRSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NRCELL IS TRANSFERRED FROM SUBR. SAMUSR
C  IPOLG IS TRANSFERRED FROM SUBR. SAMUSR
C  NBLOCK IS TRANSFERRED FROM SUBR. SAMUSR
C  NACELL IS TRANSFERRED FROM SUBR. SAMUSR
        NRCELL=IRUSR
        NACELL=IAUSR
        NBLOCK=IBUSR
        IPOLG =IPUSR
      ELSE
        GOTO 999
      ENDIF
C
      NTCELL=1
      IPERID=1
      IF (NLTOR.AND.NACELL.EQ.0) THEN
        IF (NLTRZ) THEN
          IF (NTSOR(NLSF,ISTRA).GT.0) THEN
C  NTCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NTSOR
            NTCELL=NTSOR(NLSF,ISTRA)
          ELSEIF (NTSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NTCELL IS FOUND FROM STEPFUNCTION DATA
            NTCELL=ITSTEP(ISTEP,IINDEX)
          ELSEIF (NTSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NTCELL IS TRANSFERRED FROM SUBR. SAMUSR
            NTCELL=ITUSR
          ELSEIF (NTSOR(NLSF,ISTRA).EQ.0) THEN
C  NTCELL IS COMPUTED IN STANDARD MESH
            NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'SAMSRF     3')
          ELSE
            GOTO 999
          ENDIF
        ELSEIF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
          NTCELL=NT
          IPERID=NTCELL
        ELSEIF (NLTRT) THEN
          WRITE (iunout,*) 'NLTRT: TO BE WRITTEN IN SAMSRF '
          CALL EXIT_OWN(1)
        ENDIF
      ELSEIF (.NOT.NLTOR.OR.NACELL.GT.0) THEN
C       IF (NLTRZ) THEN
C  ALL DONE
        IF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
          IPERID=NT
        ELSEIF (NLTRT) THEN
          WRITE (iunout,*) 'NLTRT: TO BE WRITTEN IN SAMSRF '
          CALL EXIT_OWN(1)
        ENDIF
      ENDIF
C
      NPCELL=1
      IF (NLPOL.AND.NACELL.EQ.0) THEN
        IF (NPSOR(NLSF,ISTRA).GT.0) THEN
C  NPCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NPSOR
          NPCELL=NPSOR(NLSF,ISTRA)
        ELSEIF (NPSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NPCELL IS FOUND FROM STEPFUNCTION DATA
          NPCELL=IPSTEP(ISTEP,IINDEX)
        ELSEIF (NPSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NPCELL IS TRANSFERRED FROM SUBR. SAMUSR
          NPCELL=IPUSR
        ELSEIF (NPSOR(NLSF,ISTRA).EQ.0) THEN
C  NPCELL IS COMPUTED IN STANDARD MESH
          IF (LEVGEO.EQ.1) THEN
            NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'SAMSRF 4')
          ELSEIF (LEVGEO.EQ.2.AND.NLCRC) THEN
            WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
            NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'SAMSRF 5')
          ELSEIF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
            IF (NLSRFY) THEN
              NPCELL=MIN0(NP2NDM,MPSURF)
            ELSE
              NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'SAMSRF')
            ENDIF
          ELSE
            WRITE (iunout,*) 'ERROR EXIT FROM SAMSRF. NLPOL ',LEVGEO
            CALL EXIT_OWN(1)
          ENDIF
        ELSE
          GOTO 999
        ENDIF
      ENDIF
C
      NBLOCK=MAX0(1,NBLOCK)
      NBLOCK=MIN0(NBLOCK,NBMLT)
      IF (NRCELL.GT.0) NACELL=0
      IF (NACELL.GT.0) NBLOCK=NBMLTP
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
      IF (ISTEP.GT.0) THEN
C  TAKE BACKGROUND MEDIUM DATA AT PLACE OF BIRTH FROM STEP FUNCTION ISTEP
        TEWL=TESTEP(ISTEP,IINDEX)
        SHWL=SHSTEP(ISTEP,IINDEX)
        DELR=RRSTEP(ISTEP,IINDEX+1)-RRSTEP(ISTEP,IINDEX)
        DO 3010 IPLS=1,NPLSI
          IPLSTI=MPLSTI(IPLS)
          TIWL(IPLS)=TISTEP(IPLSTI,ISTEP,IINDEX)
          VXWL(IPLS)=VXSTEP(IPLS,ISTEP,IINDEX)
          VYWL(IPLS)=VYSTEP(IPLS,ISTEP,IINDEX)
          VZWL(IPLS)=VZSTEP(IPLS,ISTEP,IINDEX)
          DIWL(IPLS)=DISTEP(IPLS,ISTEP,IINDEX)
                  FF=FLSTEP(IPLS,ISTEP,IINDEX)
          EFWL(IPLS)=ELSTEP(IPLS,ISTEP,IINDEX)/(FF+EPS30)
3010    CONTINUE
      ELSEIF (ISTEP.EQ.0) THEN
C  TAKE BACKGROUND MEDIUM DATA AT PLACE OF BIRTH FROM LOCAL BULK PLASMA DATA 
C                              IN SAMPLED CELL NCELL
        TEWL=TEIN(NCELL)
        SHWL=0.
        DO 3020 IPLS=1,NPLSI
          IPLSTI = MPLSTI(IPLS)
          IPLSV = MPLSV(IPLS)
          TIWL(IPLS)=TIIN(IPLSTI,NCELL)
          IF (INDPRO(4) == 8) THEN
            CALL VECUSR (2,VXWL(IPLS),VYWL(IPLS),VZWL(IPLS),IPLS)
          ELSE
            VXWL(IPLS)=VXIN(IPLSV,NCELL)
            VYWL(IPLS)=VYIN(IPLSV,NCELL)
            VZWL(IPLS)=VZIN(IPLSV,NCELL)
          END IF
          DIWL(IPLS)=DIIN(IPLS,NCELL)
          EFWL(IPLS)=0.
3020    CONTINUE
      ELSEIF (ISTEP.LT.0) THEN
C  TEWL, TIWL, .... SHWL ALREADY DEFINED IN SM1USR
C  NOTHING MORE TO BE DONE HERE
      ENDIF
C
C  SET ANALOG SPECIES INDEX DISTRIBUTION WEISPZ
C
      IF (NSPEZ(ISTRA).LE.0) THEN
        IF (ISTEP.GT.0) THEN
C  WEISPZ FROM STEP FUNCTION
          DO 4100 ISPZ=NSPSTI(ISTEP),NSPSTE(ISTEP)
            WEISPZ(ISPZ)=FLSTEP(ISPZ,ISTEP,IINDEX)/
     .                   FLSTEP(0,   ISTEP,IINDEX)
4100      CONTINUE
          DO ISPZ=1,NSPSTI(ISTEP)-1
            WEISPZ(ISPZ)=0.D0
          ENDDO
          DO ISPZ=NSPSTE(ISTEP)+1,NSPZ
            WEISPZ(ISPZ)=0.D0
          ENDDO
        ELSE
C  WEISPZ NOT DEFINED
        ENDIF
      ENDIF
C
      RETURN


      ENTRY SAMSF2

      IF (ALLOCATED(INDTEC)) THEN
        DEALLOCATE (INDTEC)
        DEALLOCATE (ALEFT)
        DEALLOCATE (BRGHT)
        DEALLOCATE (XI)
        DEALLOCATE (XE)
      END IF

      RETURN

991   CONTINUE
      WRITE (iunout,*) ' ERROR IN SAMSRF '
      WRITE (iunout,*) 'SPECIES INDEX DISTRIBUTION NOT KNOWN'
      CALL EXIT_OWN(1)
992   CONTINUE
      WRITE (iunout,*) ' ERROR IN SAMSRF '
      WRITE (iunout,*) 'INDIM, LEVGEO: ',INDIM(NLSF,ISTRA),LEVGEO
      WRITE (iunout,*) ' THIS CASE IS TO BE WRITTEN '
      CALL EXIT_OWN(1)
993   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 'SOURCE ON STANDARD SURFACE BUT INVALID "JCALC"'
      WRITE (iunout,*) 'CHANGE INPUT FLAG "INDTEC"'
      CALL EXIT_OWN(1)
9931  CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 
     .  'SOURCE ON ADDITIONAL SURFACE BUT INVALID "JCALC"'
      WRITE (iunout,*) 'CHANGE INPUT FLAG "INDTEC"'
      CALL EXIT_OWN(1)
994   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMPLE. EXIT CALLED'
      WRITE (iunout,*) 
     .  'ARCLENGTH REQUESTED ON STANDARD SURFACE BUT LEVGEO'
      WRITE (iunout,*) 'IS NOT = 3. THIS OPTION IS STILL TO BE WRITTEN'
      CALL EXIT_OWN(1)
995   CONTINUE
      WRITE (iunout,*) ' ERROR IN SAMSRF '
      WRITE (iunout,*) 'INDIM, LEVGEO: ',INDIM(NLSF,ISTRA),LEVGEO
      WRITE (iunout,*) 
     .  ' AND NO STEP FUNCTION FOR COMPUTING THE BIRTH PLACE'
      WRITE (iunout,*) ' THIS CASE IS TO BE WRITTEN '
      CALL EXIT_OWN(1)
996   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 'ARCLENGTH BL GREATER THAN THE LENGTH OF THE '
      WRITE (iunout,*) 'POLYGONE    BL = ',BL
c slmod begin - debug
      WRITE (iunout,*) 'NLSF   = ',NLSF
      WRITE (iunout,*) 'NRCELL = ',NRCELL
c slmod end
      CALL EXIT_OWN(1)
997   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 'CHECK INPUT OF SORLIM, BECAUSE EIRENE TRIES TO'
      WRITE (iunout,*) 
     .  'COMPUTE MORE THAN ONE VARIABLES FROM THE SURFACE'
      WRITE (iunout,*) 'EQUATION'
      CALL EXIT_OWN(1)
998   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 'X0,Y0,Z0 ',X0,Y0,Z0
      WRITE (iunout,*) 'BUT OUTSIDE THE VALID AREA OF THIS SURFACE'
      CALL EXIT_OWN(1)
999   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (iunout,*) 'INITIAL CELL NUMBER INVALID OR DET NEGATIVE'
      WRITE (iunout,*) 'X0,Y0,Z0,DET ',X0,Y0,Z0,DET
      WRITE (iunout,*) 'ISTEP ',ISTEP
      WRITE (iunout,*) 'NBLOCK,NACELL,NRCELL ',NBLOCK,NACELL,NRCELL
      WRITE (iunout,*) 'NPCELL,NTCELL,IPOLG ',NPCELL,NTCELL,IPOLG
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: samvol.f
!pb  271006: use flux set by user defined sampling routine 
!pb  240806: set output values for DIWL and SHWL
cdr  200806: tiwl(*), ... instead of tiwl(npls),... to unify code.
cdr  060406: check "istep out of range" moved to correct place
c  031105
c  iplsti moved after check of validity of ipls, to produce legal exit
c         rather than code crash
C  JET 2005, PATCH 1: NEW ARGUMENTS EFWL AND SHWL IN PARAMETER LIST
c                     AT ENTRY SMVOL1 AND SMUSR1
C
      SUBROUTINE SAMVOL

      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CLOGAU
      USE CINIT
      USE CPOLYG
      USE CGRID
      USE CZT1
      USE CTRCEI
      USE CGEOM
      USE COMPRT
      USE COMSOU
      USE COMXS
      USE CSPEI
      USE CTRIG
      USE CTETRA
      USE PHOTON
      IMPLICIT NONE
C

      REAL(DP), INTENT(OUT) :: TEWL, SHWL, TIWL(*), DIWL(*),
     .                         VXWL(*), VYWL(*), VZWL(*),
     .                         EFWL(*), WEISPZ(*)
      INTEGER, INTENT(IN) :: NVLM
      REAL(DP), ALLOCATABLE, SAVE :: FREC(:,:,:), VSOURC(:,:), VSMXI(:)
      REAL(DP), ALLOCATABLE, SAVE :: RQ21(:), PS21(:)
      REAL(DP), ALLOCATABLE, SAVE :: ASIMP(:,:)
      REAL(DP) :: D(3)
      INTEGER, ALLOCATABLE, SAVE  :: ISOURC(:,:), ICMX(:),
     .                               IFREC(:)
      REAL(DP) :: ZEP1, X1, Y1, X2, Y2, X3, Y3, RR, RRI, WINK,
     .            ZRM1, CNORM, EPR, ELR, RRD, RRN, ZZ, X01, Z1, Z2, Z3,
     .            REC, BX, BY, BZ, ADD, FTABRC1, CNDYNP, VX, VY, VZ,
     .            VPARA, EELRC, FEELRC1, SUMM, EISUMM, EISUM, SUM,
     .            X4, Y4, Z4, MOMPARA
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: IC1, IC2, ICOUNT, ICELL, IAUSR, IBUSR, IRUSR, IPUSR,
     .           ITUSR, IN, IIRC, IRC, IRRC, J, IT1, IT2, ISTEP, IFRC,
     .           IR2, IP1, IP2, ICTOT, IND, IR, IP, IT, IC, ISRFSI, I,
     .           ICC, IR1, ISR, ISTR, IL, IU, IM, MXREC, MXPLS, IFPLS,
     .           IPLSTI, IPLSV, KK, ICCT
      INTEGER, SAVE :: ISTROLD=-1
      LOGICAL, ALLOCATABLE, SAVE :: LPLSSR(:)
C
C  AT ENTRY SAMVL0:
C    DEFINE THE CUMULATIVE DISTRIBUTION FUNCTION
C    FREC(IPLS,IRRC,ICELL) FOR EACH VOLUME SOURCE DISTRIBUTION, FOR SAMPLING
C    THE CELL INDEX ICELL OF THE VOLUME SOURCE PARTICLE.
C
C    A FEW GEOMETRICAL CONSTANTS FOR RANDOM SAMPLING
C    OF THE STARTING POINT IN EACH CELL ARE COMPUTED
C
C    THE SOURCE STRENGTH FLUX(ISTRA) IS MODIFIED FOR THE
C    STRATA WITH NLVOL(ISTRA)=.TRUE.
C
C  AT ENTRY SAMVL1:
C    THE INITIAL CO-ORDINATES OF A TEST FLIGHT ARE SAMPLED,
C    AND THE CELL NUMBERS ARE COMPUTED
C
      ENTRY SAMVL0
C

      IF (.NOT.ALLOCATED(FREC)) THEN

C  LPLSSR(IPLS):
C  IDENTIFY THOSE IPLS WHICH NEED A VOLUME SOURCE DISTRIBUTION

        ALLOCATE (LPLSSR(NPLSI))
        LPLSSR = .FALSE.
        DO ISTR=1,NSTRAI
          IF (NLVOL(ISTR) .AND. NLPLS(ISTR) .AND. (NPTS(ISTR) > 0)
     .        .AND. (FLUX(ISTR) > 0._DP)) THEN
            IPLS = NSPEZ(ISTR)
            IF (IPLS.LE.0.OR.IPLS.GT.NPLSI) THEN
              LPLSSR = .TRUE.
            ELSE
              LPLSSR(IPLS) = .TRUE.
            END IF
          END IF
        END DO
        MXREC=MAXVAL(NPRCI(1:NPLSI))
        MXPLS=COUNT(LPLSSR(1:NPLSI))
        ALLOCATE (FREC(0:MXPLS,0:MXREC,0:NRAD))
        ALLOCATE (VSOURC(NSRFS,0:NRAD))
        ALLOCATE (VSMXI(NSRFS))
        ALLOCATE (RQ21(N1ST))
        ALLOCATE (PS21(N2ND))
        IF (LEVGEO == 3) ALLOCATE (ASIMP(2,NRAD))
        ALLOCATE (ISOURC(NSRFS,0:NRAD))
        ALLOCATE (ICMX(NSRFS))
        ALLOCATE (IFREC(NPLS))
      END IF
C
      FREC=0.
      SREC=0.
      IFREC=0
C
      IFPLS=0
      DO 2 IPLS=1,NPLSI
        IF (LGPRC(IPLS,0).EQ.0) GOTO 2
        IF (.NOT.LPLSSR(IPLS)) GOTO 2
        IFPLS=IFPLS+1
        IFREC(IPLS)=IFPLS
        DO 3 IIRC=1,NPRCI(IPLS)
          IRRC=LGPRC(IPLS,IIRC)
          KK=NREARC(IRRC)
          ICCT=NREACT(KK)
          DO 3 J=1,NSBOX
            ADD=0.
C  EXCLUDE DEAD CELLS (GRID CUTS, ISOLATED CELLS FROM COUPLE_.., ETC)
C  EXCLUDE IPLS-VACUUM CELLS
            IF (NSTGRD(J).EQ.0.AND..NOT.LGVAC(J,IPLS)) THEN
              IF (NSTORDR >= NRAD) THEN
                ADD=TABRC1(IRRC,J)*DIIN(IPLS,J)*VOL(J)*ELCHA
              ELSE
                ADD=FTABRC1(IRRC,J)*DIIN(IPLS,J)*VOL(J)*ELCHA
              END IF
            END IF
            IF (ICCT > 0) 
     .        ADD = ADD*(XINTLEFT(ICCT,J) + 
     .                   XINT_INF(ICCT,J) - XINTRIGHT(ICCT,J))
            FREC(IFPLS,IIRC,J)  =FREC(IFPLS,IIRC,J-1)+ADD
            SREC(IPLS,IRRC)     =SREC(IPLS,IRRC)+ADD
3       CONTINUE
2     CONTINUE

C  SUM OVER SPECIES AND RECOMBINATION TYP INDICES
      DO 4 IPLS=1,NPLSI
        IF (LGPRC(IPLS,0).EQ.0) GOTO 4
        IF (.NOT.LPLSSR(IPLS)) GOTO 4
        IFPLS=IFREC(IPLS)
        DO 5 IIRC=1,NPRCI(IPLS)
          IRRC=LGPRC(IPLS,IIRC)
          SREC(IPLS,0)=SREC(IPLS,0)+SREC(IPLS,IRRC)
          SREC(0,IRRC)=SREC(0,IRRC)+SREC(IPLS,IRRC)
          SREC(0,0)   =SREC(0,0)   +SREC(IPLS,IRRC)
          DO 5 J=1,NSBOX
            FREC(IFPLS,0,J)=FREC(IFPLS,0,J)+FREC(IFPLS,IIRC,J)
5         CONTINUE
4     CONTINUE
C
C
      IF (TRCSOU.AND.IFPLS.GT.0) THEN
        EIO=0.
        EEL=0.
        MOM=0.
C
        DO 7 IPLS=1,NPLSI
          CNDYNP=AMUA*RMASSP(IPLS)
          IF (LGPRC(IPLS,0).EQ.0) GOTO 7
          IF (.NOT.LPLSSR(IPLS)) GOTO 7
          IFPLS=IFREC(IPLS)
          IPLSTI = MPLSTI(IPLS)
          IPLSV = MPLSV(IPLS)
          DO 6 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            KK=NREARC(IRRC)
            ICCT=NREACT(KK)
            DO 6 J=1,NSBOX
              IF (NSTGRD(J).EQ.0.AND..NOT.LGVAC(J,IPLS)) THEN
                REC=FREC(IFPLS,IIRC,J)-FREC(IFPLS,IIRC,J-1)
                IF (REC.LE.0.D0) GOTO 6
                ADD=(1.5*TIIN(IPLSTI,J)+EDRIFT(IPLS,J))*REC
                IF (ICCT > 0) 
     .            ADD = ADD*(XINTLEFT(ICCT,J) + 
     .                       XINT_INF(ICCT,J) - XINTRIGHT(ICCT,J))
                EIO(IPLS,IRRC)=EIO(IPLS,IRRC)-ADD
                EIO(IPLS,0)   =EIO(IPLS,0   )-ADD
                IF (INDPRO(5) == 8) THEN
                  CALL VECUSR(1,BX,BY,BZ,1)
                ELSE
                  BX=BXIN(J)
                  BY=BYIN(J)
                  BZ=BZIN(J)
                END IF
                IF (INDPRO(4) == 8) THEN
                  CALL VECUSR(2,VX,VY,VZ,IPLSV)
                  VPARA=VX*BX+VY*BY+VZ*BZ
                  MOMPARA=VPARA*CNDYNP*SIGN(1._DP,VPARA)
                ELSE IF (INDPRO(5) == 8) THEN
                  VX = VXIN(IPLSV,J)
                  VY = VYIN(IPLSV,J)
                  VZ = VZIN(IPLSV,J)
                  VPARA=VX*BX+VY*BY+VZ*BZ
                  MOMPARA=VPARA*CNDYNP*SIGN(1._DP,VPARA)
                ELSE
                  MOMPARA=PARMOM(IPLS,J)
                ENDIF
                ADD=MOMPARA*REC
                IF (ICCT > 0) 
     .            ADD = ADD*(XINTLEFT(ICCT,J) + 
     .                       XINT_INF(ICCT,J) - XINTRIGHT(ICCT,J))
                MOM(IPLS,IRRC)=MOM(IPLS,IRRC)-ADD
                MOM(IPLS,0)   =MOM(IPLS,0   )-ADD
              ENDIF
6         CONTINUE
C
          DO 8 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            KK=NREARC(IRRC)
            ICCT=NREACT(KK)
            DO 8 J=1,NSBOX
              ADD=0.D0
              IF (NSTGRD(J).EQ.0.AND..NOT.LGVAC(J,IPLS)) THEN
                IF (NSTORDR >= NRAD) THEN
                  EELRC = EELRC1(IRRC,J)
                ELSE
                  EELRC = FEELRC1(IRRC,J)
                END IF
                ADD=EELRC*DIIN(IPLS,J)*VOL(J)*ELCHA
                IF (ICCT > 0) 
     .            ADD = ADD*(XINTLEFT(ICCT,J) + 
     .                       XINT_INF(ICCT,J) - XINTRIGHT(ICCT,J))
              ENDIF
              EEL(IPLS,IRRC)=EEL(IPLS,IRRC)+ADD
              EEL(IPLS,0   )=EEL(IPLS,0   )+ADD
8         CONTINUE
7       CONTINUE
C
        CALL LEER(1)
        WRITE (iunout,*) 'DIAGNOSTICS FROM SUBR. SAMVOL: '
        CALL LEER(1)
        WRITE (iunout,*) 'VOLUME RECOMBINATION RATES INTEGRATED OVER'
        WRITE (iunout,*) 'ENTIRE COMPUTATIONAL GRID '
        CALL LEER(1)
        WRITE (iunout,*) 'RECOMBINATION ION PARTICLE LOSS (AMP): '
        ITYP=4
        DO 10 IPLS=1,NPLSI
          IF (.NOT.LPLSSR(IPLS)) CYCLE
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
          DO 11 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASAJR('IPLS,IRRC, SREC         ',
     .                   TEXTS(ISPZ),IRRC,-SREC(IPLS,IRRC))
11        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASAJR('IPLS,TOT., SREC(IPLS,0) ',
     .                   TEXTS(ISPZ),0   ,-SREC(IPLS,0))
          ENDIF
10      CONTINUE
        CALL LEER(1)
        WRITE (iunout,*) 'RECOMBINATION ION ENERGY LOSS (WATT): '
        DO 12 IPLS=1,NPLSI
          IF (.NOT.LPLSSR(IPLS)) CYCLE
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
          DO 13 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASAJR('IPLS,IRRC,EIO           ',
     .                   TEXTS(ISPZ),IRRC,EIO(IPLS,IRRC))
13        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASAJR('IPLS,TOT.,EIO(IPLS,0)   ',
     .                   TEXTS(ISPZ),0   ,EIO(IPLS,0))
          ENDIF
12      CONTINUE
        CALL LEER(1)
        WRITE (iunout,*) 'RECOMBINATION ELECTRON ENERGY LOSS (WATT): '
        DO 14 IPLS=1,NPLSI
          IF (.NOT.LPLSSR(IPLS)) CYCLE
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
          DO 15 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASAJR('IPLS,IRRC,EEL           ',
     .                   TEXTS(ISPZ),IRRC,EEL(IPLS,IRRC))
15        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASAJR('IPLS,TOT.,EEL(IPLS,0)   ',
     .                   TEXTS(ISPZ),0   ,EEL(IPLS,0))
          ENDIF
14      CONTINUE
        CALL LEER(1)
        WRITE (iunout,*) 'RECOMBINATION PARALLEL MOMENTUM LOSS : '
        DO 16 IPLS=1,NPLSI
          IF (.NOT.LPLSSR(IPLS)) CYCLE
          ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
          DO 17 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASAJR('IPLS,IRRC,MOM           ',
     .                   TEXTS(ISPZ),IRRC,MOM(IPLS,IRRC))
17        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASAJR('IPLS,TOT.,MOM(IPLS,0)   ',
     .                   TEXTS(ISPZ),0   ,MOM(IPLS,0))
          ENDIF
16      CONTINUE
        CALL LEER(1)

      ENDIF    !trcsou
C
C  SET TOTAL SOURCE STRENGTH FOR STRATA WITH NLVOL(ISTRA)=.TRUE.,
C
      DO 50 ISTRA=1,NSTRAI
        IF (NLVOL(ISTRA).AND.NLPLS(ISTRA)) THEN
          IPLS=NSPEZ(ISTRA)
          IF (IPLS.LE.0.OR.IPLS.GT.NPLSI) THEN
            WRITE (iunout,*) 'SOURCE SPECIES INDEX NSPEZ OUT OF RANGE'
            WRITE (iunout,*) 'ISTRA, NSPEZ(ISTRA) ',ISTRA,NSPEZ(ISTRA)
            CALL EXIT_OWN(1)
          ENDIF
          IPLSTI = MPLSTI(IPLS)
          SUMM=0.D0
          EISUMM=0.D0
          DO 53 ISRFSI=1,NSRFSI(ISTRA)
            ISR=ISRFSI
            SUM=0.D0
            EISUM=0.D0
            IF (SORLIM(ISR,ISTRA).LT.0) THEN
C  INITIALIZE SAMPLING DISTRIBUTIONS FOR USER SPECIFIED VOLUME SOURCE
              CALL SM0USR(ISR,ISTRA,
     .                    SORAD1(ISR,ISTRA),SORAD2(ISR,ISTRA),
     .                    SORAD3(ISR,ISTRA),SORAD4(ISR,ISTRA),
     .                    SORAD5(ISR,ISTRA),SORAD6(ISR,ISTRA))
!pb assume flux is set in samusr
              SUMM=FLUX(ISTRA)
            ELSE
C  INITIALIZE SAMPLING DISTRIBUTIONS FOR DEFAULT VOLUME RECOMBINATION SOURCES
C  ACCOUNT FOR INGRDA(ISRFSI,ISTRA,...), INGRDE(ISRFSI,ISTRA,...)
              I=ISTRA
              ICC=0
              IRC=-1
              IF (NR1ST.GT.1) THEN
              IF (INGRDA(ISR,I,1).LE.0..OR.INGRDE(ISR,I,1).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (iunout,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (iunout,*) 
     .            'NEW INPUT FOR INGRDA(.,.,1),INGRDE(.,.,1)'
                WRITE (iunout,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(ISR,I,1)=1
                INGRDE(ISR,I,1)=MAX0(1,NR1ST)
                CALL LEER(1)
              ENDIF
              ENDIF
              IF (NP2ND.GT.1) THEN
              IF (INGRDA(ISR,I,2).LE.0..OR.INGRDE(ISR,I,2).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (iunout,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (iunout,*) 
     .            'NEW INPUT FOR INGRDA(.,.,2),INGRDE(.,.,2)'
                WRITE (iunout,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(ISR,I,2)=1
                INGRDE(ISR,I,2)=MAX0(1,NP2ND)
                CALL LEER(1)
              ENDIF
              ENDIF
              IF (NT3RD.GT.1) THEN
              IF (INGRDA(ISR,I,3).LE.0..OR.INGRDE(ISR,I,3).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (iunout,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (iunout,*) 
     .            'NEW INPUT FOR INGRDA(.,.,3),INGRDE(.,.,3)'
                WRITE (iunout,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(ISR,I,3)=1
                INGRDE(ISR,I,3)=MAX0(1,NT3RD)
                CALL LEER(1)
              ENDIF
              ENDIF
              IF (NPRCI(IPLS).EQ.0) THEN
                WRITE (iunout,*) 'NO DEFAULT VOLUME SOURCE DISTRIBUTION'
                WRITE (iunout,*) 'DEFINED. SUBSTRATUM TURNED OFF'
                WRITE (iunout,*) 'IPLS,ISRFSI,ISTRA ',IPLS,ISRFSI,ISTRA
                SORWGT(ISR,ISTRA)=0.D0
                GOTO 53
              ENDIF
              IF (NLRAD) THEN
                IR1=MAX0(1,INGRDA(ISR,ISTRA,1))
                IR2=MIN0(NR1ST,INGRDE(ISR,ISTRA,1))
              ELSE
                IR1=1
                IR2=2
              ENDIF
              IF (NLPOL) THEN
                IP1=MAX0(1,INGRDA(ISR,ISTRA,2))
                IP2=MIN0(NP2ND,INGRDE(ISR,ISTRA,2))
              ELSE
                IP1=1
                IP2=2
              ENDIF
              IF (NLTOR) THEN
                IT1=MAX0(1,INGRDA(ISR,ISTRA,3))
                IT2=MIN0(NT3RD,INGRDE(ISR,ISTRA,3))
              ELSE
                IT1=1
                IT2=2
              ENDIF

              ISTEP=SORIND(ISR,ISTRA)
              IFPLS=IFREC(IPLS)
              DO 52 IIRC=1,NPRCI(IPLS)
                IRRC=LGPRC(IPLS,IIRC)
                IF (ISTEP.EQ.IRRC) THEN
                  IRC=IRRC
                  IFRC=IIRC
                ELSEIF (ISTEP.EQ.0) THEN
C  SUM OVER ALL RECOMBINATION PROCESSES FOR SPECIES IPLS
                  IRC=0
                  IFRC=0
                  ISTEP=-1
                ELSE
                  WRITE (IUNOUT,*) 'ISTEP OUT OF RANGE IN SAMVOL '
                  WRITE (IUNOUT,*) 'NO VOL. RECOMBINATION SOURCE FOR: '
                  WRITE (IUNOUT,*) 'ISTRA, IPLS, IRRC ',ISTRA,IPLS,IRRC
                  GOTO 52
                ENDIF
                DO 51 IR=IR1,IR2-1
                  DO 51 IP=IP1,IP2-1
                    DO 51 IT=IT1,IT2-1
                      NCELL=IR+((IP-1)+(IT-1)*NP2T3)*NR1P2
                      ADD=FREC(IFPLS,IFRC,NCELL)-
     .                    FREC(IFPLS,IFRC,NCELL-1)
C  INDIRECT ADDRESSING
                      IF (ADD.GT.0.D0) THEN
                        ICC=ICC+1
                        SUM=SUM+ADD
                        EISUM=EISUM-
     .                   (1.5*TIIN(IPLSTI,NCELL)+EDRIFT(IPLS,NCELL))*ADD
                      ENDIF
51              CONTINUE
52            CONTINUE
              IF (SUM.EQ.0.D0) THEN
                WRITE (IUNOUT,*) 'NO VOL. RECOMBINATION SOURCE FOR: '
                WRITE (IUNOUT,*) 'ISTRA, ISRFSI, IPLS, ISTEP ',
     .                            ISTRA, ISR   , IPLS, ISTEP
                WRITE (IUNOUT,*) 'EITHER: ISTEP OUT OF RANGE IN SAMVOL'
                WRITE (IUNOUT,*) 'OR:  DENSITY OF RECOMBINING IPLS = 0 '
                SORWGT(ISR,ISTRA)=0.D0
                GOTO 53
              ENDIF
              SORWGT(ISR,ISTRA)=SUM
              CALL LEER(1)
              WRITE (iunout,*) 'SUB-STRATUM WEIGHT REDEFINED '
              CALL MASJ2R ('ISRFSI,ISTRA,SORWGT     ',ISRFSI,ISTRA,SUM)
              IF (TRCSOU) THEN
                CALL MASJ3 ('IRRC,IPLS,ICMX          ',
     .                       IRC ,IPLS,ICC)
                CALL LEER(1)
              ENDIF
              SUMM=SUMM+SUM
              EISUMM=EISUMM+EISUM
            ENDIF
53        CONTINUE
C
          IF (SUMM.GT.0.D0) THEN
            FLUX(ISTRA)=SUMM
            WRITE (iunout,*) 'SOURCE STRENGTH REDEFINED '
            CALL MASJR2('ISTRA, FLUX, EIFLUX     ',
     .                   ISTRA,FLUX(ISTRA),EISUMM)
            CALL LEER(1)
          ELSE 
            FLUX(ISTRA)=0.D0
            WRITE (iunout,*) 'SOURCE ISTRA= ',ISTRA,' TURNED OFF '
            CALL LEER(1)
          ENDIF
        ENDIF
50    CONTINUE
C
C  PREPARE SOME GEOMETRICAL CONSTANTS FOR RANDOM SAMPLING IN STANDARD MESH CELLS
      IF (LEVGEO.EQ.2) THEN
        IF (NLPOL) THEN
          DO 54 IP=1,NP2NDM
            PS21(IP)=PSURF(IP+1)-PSURF(IP)
54        CONTINUE
        ENDIF
        DO 55 IR=1,NR1STM
          RQ21(IR)=RQ(IR+1)-RQ(IR)
55      CONTINUE
      ENDIF
C
      IF (LEVGEO.EQ.3) THEN
        IT=1
        DO 56 IR=1,NR1ST-1
        DO 56 IP=1,NP2ND-1
          IND=IR+((IP-1)+(IT-1)*NP2T3)*NR1P2
          X1=XPOL(IR,IP)
          X2=XPOL(IR,IP+1)
          X3=XPOL(IR+1,IP+1)
          Y1=YPOL(IR,IP)
          Y2=YPOL(IR,IP+1)
          Y3=YPOL(IR+1,IP+1)
          ASIMP(1,IND)=0.5*(X1*(Y2-Y3)+X2*(Y3-Y1)+X3*(Y1-Y2))
          X1=XPOL(IR+1,IP)
          X2=XPOL(IR,IP)
          X3=XPOL(IR+1,IP+1)
          Y1=YPOL(IR+1,IP)
          Y2=YPOL(IR,IP)
          Y3=YPOL(IR+1,IP+1)
          ASIMP(2,IND)=0.5*(X1*(Y2-Y3)+X2*(Y3-Y1)+X3*(Y1-Y2))
56      CONTINUE
      ENDIF
C
      RETURN
C
C  AT THIS POINT: CALLED FROM PARTICLE LOOP TO INITIALIZE TEST FLIGHT
C
      ENTRY SAMVL1(NVLM,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
C  USER SUPPLIED SOURCE
C
      IF (SORLIM(NVLM,ISTRA).LT.0) THEN
        CALL SM1USR(NVLM,X0,Y0,Z0,
     .              SORAD1(NVLM,ISTRA),SORAD2(NVLM,ISTRA),
     .              SORAD3(NVLM,ISTRA),SORAD4(NVLM,ISTRA),
     .              SORAD5(NVLM,ISTRA),SORAD6(NVLM,ISTRA),
     .              IRUSR,IPUSR,ITUSR,IAUSR,IBUSR,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,EFWL,SHWL,WEISPZ)
        NRCELL=IRUSR
        NPCELL=IPUSR
        NTCELL=ITUSR
        NACELL=IAUSR
        NBLOCK=IBUSR
        NBLCKA=NSTRD*(NBLOCK-1)+NACELL
        NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
        MTSURF=0
        NLSRFZ=.FALSE.
        MPSURF=0
        NLSRFY=.FALSE.
        MRSURF=0
        NLSRFX=.FALSE.
        EFWL(1:NPLSI)=0._DP
        RETURN
      ENDIF
C
C  VOLUME RECOMBINATION SOURCE
C
C  TENTATIVELY ASSUME: A BULK ION WILL BE GENERATED
      LGPART=.TRUE.
      ITYP=4
C
      IF (.NOT.NLPLS(ISTRA)) GOTO 999

      IF (ISTROLD /= ISTRA) THEN
        ISTROLD=ISTRA
        IPLS=NSPEZ(ISTRA)
        DO ISRFSI=1,NSRFSI(ISTRA)
          ISR=ISRFSI
          ICC=0
          VSOURC(ISR,0)=0.D0
          IF (NLRAD) THEN
            IR1=MAX0(1,INGRDA(ISR,ISTRA,1))
            IR2=MIN0(NR1ST,INGRDE(ISR,ISTRA,1))
          ELSE
            IR1=1
            IR2=2
          ENDIF
          IF (NLPOL) THEN
            IP1=MAX0(1,INGRDA(ISR,ISTRA,2))
            IP2=MIN0(NP2ND,INGRDE(ISR,ISTRA,2))
          ELSE
            IP1=1
            IP2=2
          ENDIF
          IF (NLTOR) THEN
            IT1=MAX0(1,INGRDA(ISR,ISTRA,3))
            IT2=MIN0(NT3RD,INGRDE(ISR,ISTRA,3))
          ELSE
            IT1=1
            IT2=2
          ENDIF

          ISTEP=SORIND(ISR,ISTRA)
          IFPLS=IFREC(IPLS)
          DO IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            IF (ISTEP.EQ.IRRC) THEN
              IRC=IRRC
              IFRC=IIRC
            ELSEIF (ISTEP.EQ.0) THEN
C  SUM OVER ALL RECOMBINATION PROCESSES FOR SPECIES IPLS
              IRC=0
              IFRC=0
              ISTEP=-1
            ELSE
              CYCLE
            ENDIF
            DO IR=IR1,IR2-1
              DO IP=IP1,IP2-1
                DO IT=IT1,IT2-1
                  NCELL=IR+((IP-1)+(IT-1)*NP2T3)*NR1P2
                  ADD=FREC(IFPLS,IFRC,NCELL)-
     .                FREC(IFPLS,IFRC,NCELL-1)
C  INDIRECT ADDRESSING
                  IF (ADD.GT.0.D0) THEN
                    ICC=ICC+1
                    ISOURC(ISR,ICC)=NCELL
                    VSOURC(ISR,ICC)=VSOURC(ISR,ICC-1)+ADD
                  ENDIF
                END DO
              END DO
            END DO
          END DO ! IIRC
          ICMX(ISR)=ICC
          VSMXI(ISR) = 1._DP / VSOURC(ISR,ICC)
        END DO ! ISRFSI
C
      END IF
C
C  FIND CELL NUMBER: NCELL
C
      IF (INDIM(NVLM,ISTRA) .GE. 0) THEN
!PB  choose cell according to cell contribution to total source strength 
        IC1=0
        IC2=ICMX(NVLM)
        ZEP1=RANF_EIRENE()*VSOURC(NVLM,IC2)

        IL=0
        IU=IC2

c  binary search
        DO WHILE (IU-IL.gt.1)
          IM=(IU+IL)*0.5
          IF(ZEP1.GE.VSOURC(NVLM,IM)) THEN
            IL=IM
          ELSE
            IU=IM
          ENDIF
        END DO
c
        ICELL=IU

        NCELL=ISOURC(NVLM,ICELL)
      ELSE

!pb  uniform distribution 
        IC1=0
        IC2=ICMX(NVLM)

        ICELL = MIN(INT(1+RANF_EIRENE()*(IC2-1)),IC2)
        NCELL = ISOURC(NVLM,ICELL)

        WEIGHT=(VSOURC(NVLM,ICELL)-VSOURC(NVLM,ICELL-1))*VSMXI(NVLM)*IC2

      END IF
C     
      IF (NCELL.GT.NSURF) GOTO 991
C
C  A CELL NUMBER NCELL HAS NOW BEEN SAMPLED
C
      CALL NCELLN(NCELL,NRCELL,NPCELL,NTCELL,NACELL,NBLOCK,
     .            NR1ST,NP2ND,NT3RD,NBMLT,NLRAD,NLPOL,NLTOR)
C
C  FIND TOROIDAL CO-ORDINATE IN NTCELL
C
      IF (.NOT.NLTOR) THEN
C       NTCELL=1
        IPERID=1
        IF (NLTRZ) THEN
          Z0=0.
        ELSEIF (NLTRA) THEN
C  TACTICALLY ASSUME: PARTICLE STARTS IN LOCAL TOR. BASIS CELL NO.1
          ZRM1=ZSURF(1)
          PHI=ZRM1+RANF_EIRENE()*ZFULL
          IPERID=1
C         Z0=??, TO BE FOUND FROM X01,PHI LATER
C         IPERID=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMVOL      ')
        ELSEIF (NLTRT) THEN
          GOTO 999
        ENDIF
      ELSEIF (NLTOR) THEN
        IPERID=NTCELL
C  SAMPLE IN CELL NTCELL
        IF (NLTRZ) THEN
          Z0=ZSURF(NTCELL)+RANF_EIRENE()*(ZSURF(NTCELL+1)-ZSURF(NTCELL))
        ELSEIF (NLTRT) THEN
          PHI=ZSURF(NTCELL)+RANF_EIRENE()*
     .        (ZSURF(NTCELL+1)-ZSURF(NTCELL))
C         Z0=??, TO BE FOUND FROM X01,PHI LATER
        ELSEIF (NLTRA) THEN
          ZRM1=ZFULL*(NTCELL-1)
          PHI=ZRM1+RANF_EIRENE()*ZFULL
C         Z0=??, TO BE FOUND FROM X01,PHI LATER
        ENDIF
      ENDIF
C
C  FIND RADIAL AND POLOIDAL CO-ORDINATE
C
      IF (LEVGEO.EQ.1) THEN
        X0=RSURF(NRCELL)+RANF_EIRENE()*(RSURF(NRCELL+1)-RSURF(NRCELL))
        IF (NLPOL) THEN
          Y0=PSURF(NPCELL)+RANF_EIRENE()*(PSURF(NPCELL+1)-PSURF(NPCELL))
        ELSE
          Y0=YIA+RANF_EIRENE()*(YAA-YIA)
        END IF
      ELSEIF (LEVGEO.EQ.2) THEN
        IF (NLCRC) THEN
C  POLOIDAL CO-ORDINATE
          IF (NLPOL) THEN
            WINK=PSURF(NPCELL)+RANF_EIRENE( )*PS21(NPCELL)
          ELSEIF (.NOT.NLPOL) THEN
            WINK=RANF_EIRENE( )*PI2A
          ENDIF
C  RADIAL CO-ORDINATE
          RR=SQRT(RQ(NRCELL)+RANF_EIRENE( )*RQ21(NRCELL))
C
          X0=RR*COS(WINK)
          Y0=RR*SIN(WINK)
        ELSEIF (NLELL) THEN
CDR NOT READY. STRICKLY, THETA AND R ARE CORRELATED. USE
CDR            MARGINAL AND CONDITIONAL DISTRIBUTION F1(R) AND
CDR            F2(PHI, GIVEN R)
C  POLOIDAL CO-ORDINATE
          IF (NLPOL) THEN
            WINK=PSURF(NPCELL)+RANF_EIRENE( )*PS21(NPCELL)
          ELSEIF (.NOT.NLPOL) THEN
            WINK=RANF_EIRENE( )*PI2A
          ENDIF
C  RADIAL CO-ORDINATE
          RR=SQRT(RQ(NRCELL)+RANF_EIRENE( )*RQ21(NRCELL))
C
          RRI=RSURF(NRCELL)
          RRD=RSURF(NRCELL+1)-RRI
          RRN=(RR-RRI)/RRD
C
          ELR=ELL(NRCELL)+RRN*(ELL(NRCELL+1)-ELL(NRCELL))
          EPR=EP1(NRCELL)+RRN*(EP1(NRCELL+1)-EP1(NRCELL))
          X0=RR*COS(WINK)+EPR
          Y0=RR*SIN(WINK)*ELR
        ELSEIF (NLTRI) THEN
          GOTO 999
        ENDIF
      ELSEIF (LEVGEO.EQ.3.OR.LEVGEO.EQ.4) THEN
        IF (LEVGEO.EQ.3) THEN
          IF (.NOT.NLPOL) THEN
            GOTO 999
          ENDIF
          IN = NRCELL + (NPCELL-1)*NR1ST
          ZEP1=AREA(IN)*RANF_EIRENE()
!pb          IF (ZEP1.LE.ASIMP(1,NCELL)) THEN
          IF (ZEP1.LE.ASIMP(1,IN)) THEN
C   PUNKT IN DREIECK 1
            X1=XPOL(NRCELL,NPCELL)
            X2=XPOL(NRCELL,NPCELL+1)
            X3=XPOL(NRCELL+1,NPCELL+1)
            Y1=YPOL(NRCELL,NPCELL)
            Y2=YPOL(NRCELL,NPCELL+1)
            Y3=YPOL(NRCELL+1,NPCELL+1)
          ELSE
C   PUNKT IN DREIECK 2
            X1=XPOL(NRCELL+1,NPCELL)
            X2=XPOL(NRCELL,NPCELL)
            X3=XPOL(NRCELL+1,NPCELL+1)
            Y1=YPOL(NRCELL+1,NPCELL)
            Y2=YPOL(NRCELL,NPCELL)
            Y3=YPOL(NRCELL+1,NPCELL+1)
          ENDIF
          IPOLG=NPCELL
        ELSEIF (LEVGEO.EQ.4) THEN
          X1=XTRIAN(NECKE(1,NCELL))
          X2=XTRIAN(NECKE(2,NCELL))
          X3=XTRIAN(NECKE(3,NCELL))
          Y1=YTRIAN(NECKE(1,NCELL))
          Y2=YTRIAN(NECKE(2,NCELL))
          Y3=YTRIAN(NECKE(3,NCELL))
        ENDIF
        Z1=0.
        Z2=0.
        Z3=0.
        CALL FPOLYT_3(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X0,Y0,ZZ)
      ELSEIF (LEVGEO.EQ.5) THEN
        X1=XTETRA(NTECK(1,NCELL))
        Y1=YTETRA(NTECK(1,NCELL))
        Z1=ZTETRA(NTECK(1,NCELL))
        X2=XTETRA(NTECK(2,NCELL))
        Y2=YTETRA(NTECK(2,NCELL))
        Z2=ZTETRA(NTECK(2,NCELL))
        X3=XTETRA(NTECK(3,NCELL))
        Y3=YTETRA(NTECK(3,NCELL))
        Z3=ZTETRA(NTECK(3,NCELL))
        X4=XTETRA(NTECK(4,NCELL))
        Y4=YTETRA(NTECK(4,NCELL))
        Z4=ZTETRA(NTECK(4,NCELL))
        CALL FPOLYT_4(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4,X0,Y0,Z0)
      ELSEIF (LEVGEO.EQ.6) THEN
        WRITE (iunout,*) 'ERROR EXIT FROM SAMVOL. LEVGEO ',LEVGEO
        CALL EXIT_OWN(1)
      ENDIF
C
      IF (NLTRA) THEN
C  FIND Z0 FROM X01,PHI IN LOCAL TOROIDAL CELL NTCELL
        X01=X0+RMTOR
        CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
      ENDIF
C
      MTSURF=0
      NLSRFZ=.FALSE.
      MPSURF=0
      NLSRFY=.FALSE.
      MRSURF=0
      NLSRFX=.FALSE.
C
C  NEXT: ANALOG SPECIES INDEX DISTRIBUTION: WEISPZ(IPL)
C
      DO 630 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
630   CONTINUE
C
C  NOT IN USE ANYMORE
C  CURRENTLY: ONLY SINGLE SPECIES VOLUME SOURCES POSSIBLE
C  MULTI SPECIES VOL-SOURCES HAVE TO BE TREATED BY STRATIFIED SAMPLING
C     IF (NSPEZ(ISTRA).LE.0) THEN
C       IF (NCELL.EQ.1) THEN
C         DO 640 IPL=1,NPLSI
C           IREC=0
C           IFPLS=IFREC(IPLS)
C           WEISPZ(IPL)=(FREC(IFPLS,0,1))/
C    .                  (FREC(0,  0,1))
C           IF (WEISPZ(IPL).LT.0) GOTO 991
640       CONTINUE
C       ELSE
C         DO 645 IPL=1,NPLSI
C           IFPLS=IFREC(IPLS)
C           WEISPZ(IPL)=(FREC(IFPLS,0,NCELL)-FREC(IFPLS,0,NCELL-1))/
C     .                 (FREC(0,    0,NCELL)-FREC(0,    0,NCELL-1))
C           IF (WEISPZ(IPL).LT.0) GOTO 991
645       CONTINUE
C       ENDIF
C     ENDIF
C
      CRTX=SORAD4(NVLM,ISTRA)
      CRTY=SORAD5(NVLM,ISTRA)
      CRTZ=SORAD6(NVLM,ISTRA)
      CNORM=SQRT(CRTX**2+CRTY**2+CRTZ**2)+EPS60
      CRTX=CRTX/CNORM
      CRTY=CRTY/CNORM
      CRTZ=CRTZ/CNORM
!PB
      TEWL=TEIN(NCELL)
      TIWL(1:NPLSI)=TIIN(MPLSTI(1:NPLSI),NCELL)
      DIWL(1:NPLSI)=DIIN(1:NPLSI,NCELL)
      VXWL(1:NPLSI)=VXIN(MPLSV(1:NPLSI),NCELL)
      VYWL(1:NPLSI)=VYIN(MPLSV(1:NPLSI),NCELL)
      VZWL(1:NPLSI)=VZIN(MPLSV(1:NPLSI),NCELL)
      EFWL(1:NPLSI)=0._DP
      SHWL=0._DP
C
      RETURN
C
990   CONTINUE
      WRITE (iunout,*) 'ERROR IN SAMVOL'
      CALL EXIT_OWN(1)
991   CONTINUE
      WRITE (iunout,*) 'SAMPLING ERROR IN SAMVOL'
      WRITE (iunout,*) 'NCELL,NSURF,NSBOX ',NCELL,NSURF,NSBOX
      CALL EXIT_OWN(1)
997   CONTINUE
      WRITE (iunout,*) 'SORIND (=IRRC) OUT OF RANGE IN SAMVOL'
      WRITE (iunout,*) 'IRRC,NREC ',IRRC,NREC
      CALL EXIT_OWN(1)
999   CONTINUE
      WRITE (iunout,*) 'UNWRITTEN OPTION IN SAMVOL'
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: stdcol.f
!  18.08.06: after particle has been moved to surface correct particle 
!            positions used in timep and timet
!pb  05.10.06: option for single sided switching of nondefault standard 
!pb            surfaces introduced
!pb  07.12.06: cell number corrected for nltet option
C
      SUBROUTINE STDCOL (ISTS,IDIM,SG,*,*)
C
C  1.) ADVANCE TRAJECTORY TO A NON-DEFAULT STANDARD SURFACE (DISTANCE: ZT)
C  2.) SWITCHING (CELL NUMBERS, FLAGS, ETC...)
C  3A.) IF TRANSPARENT AND NO SURFACE TALLIES: CONTINUE FLIGHT
C  3B.) ELSE: IF NEEDED, PREPARE REFLECTION (SURFACE NORMALS), THEN CALL EXCAPE
C
C  SG:    =SIGN OF COSINE OF ANGLE OF INCIDENCE
C  ISTS:  =SURFACE INDEX IN NSTSI ARRAYS
C  IDIM:  =INDEX (1,2,3) FOR: RADIAL, POLOIDAL OR TOROIDAL SURFACE
C  RETURN 1:  NO SURFACE TALLIES, FLIGHT CONTINUES
C  RETURN 2:  SURFACE TALLIES,
C             THEN ABSORBTION, REFLECTION MODEL OR CONTINUATION OF FLIGHT
C             (CALL SUBR. ESCAPE)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CPOLYG
      USE CGRID
      USE CTETRA
      USE COMPRT
      USE CLGIN
      USE COUTAU
      USE CTRIG

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: SG
      INTEGER, INTENT(IN) :: ISTS, IDIM

      REAL(DP) :: WINK, TANPHI, PHINM, X0E, Y0E, Z0E, SCOSE, X0SA,
     .          Y0SA, Z0SA,
     .          COSROT,SINROT,VELX_OLD
      INTEGER :: IDUM, LEARCA, LEARC1, IAN, IEN, NDUM, LEARC2,
     .           IR, M, IP, IST, MSURFE, NACLLS, ICOS, IWEI, MSURFS
      INTEGER, EXTERNAL :: IDEZ
C
C   COLLISION WITH STANDARD SURFACE NO. MSURF=NLIM+ISTS
C   OF THE RADIAL   (OR X-) GRID: IDIM=1
C   OR THE POLOIDAL (OR Y-) GRID: IDIM=2
C   OR THE TOROIDAL (OR Z-) GRID: IDIM=3
C
C  SAVE DATA OF OLD POINT FOR DIAGNOSTICS
      X0SA=X0
      Y0SA=Y0
      Z0SA=Z0
      MSURFS=MSURF
      NACLLS=NACELL
C  SET NEW POINT ON NON DEFAULT STANDARD SURFACE ISTS. FLIGHT TIME: ZT
      X0=X0+VELX*ZT
      Y0=Y0+VELY*ZT
      Z0=Z0+VELZ*ZT
      TIME=TIME+ZT/VEL
      if (nlfem.or.nltet) then
        MSURF=ISTS
      else
        MSURF=NLIM+ISTS
      endif
      ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
      SCOS=SG
      ICOS=SCOS
C  SET PHI AND X01
      IF (NLTRA) THEN
        PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
        X01=X0+RMTOR
      ENDIF
C  SET IPOLG
      IPOLG=IPOLGN
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
C
C  CARRY OUT DEFAULT CELL SWITCHING AT TRANSPARENT STANDARD SURFACES
      IF (IDIM.EQ.1) THEN
        NLSRFX=.TRUE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        IF (ILIIN(MSURF).LE.0) NRCELL=NRCELL+ICOS
C
C  IN NLFEM, NLTET AND NLGEN OPTIONS: ALL SURFACES ARE IDIM=1 SURFACES
        IF (NLFEM) NRCELL=MRSURF
        IF (NLTET) NRCELL=MRSURF
        IF (NLGEN) NRCELL=MRSURF
C
      ELSEIF (IDIM.EQ.2) THEN
        NLSRFX=.FALSE.
        NLSRFY=.TRUE.
        NLSRFZ=.FALSE.
        IF (ILIIN(MSURF).LE.0) NPCELL=NPCELL+ICOS
C
        IF (NLPLG.AND.ILIIN(MSURF).GT.0.AND.SCOS.GT.0) IPOLG=IPOLG-1
C
      ELSEIF (IDIM.EQ.3) THEN
        NLSRFX=.FALSE.
        NLSRFZ=.FALSE.
        NLSRFZ=.TRUE.
        IF (ILIIN(MSURF).LE.0) NTCELL=NTCELL+ICOS
      ENDIF
C
      IWEI=ILSIDE(MSURF)*ICOS
!pb      IF (IWEI.LT.0) GOTO 300
      IF (ILIIN(MSURF).EQ.2) GOTO 400
C
C  OPERATE A SWITCH
C
      IF (ILSWCH(MSURF).NE.0) THEN
C
C  TURN ON OR OFF THE STANDARD GRID CALCULATION
        IF (ISWICH(1,MSURF).NE.0) ITIME=ICOS*ISWICH(1,MSURF)

C  TURN ON OR OFF MFP AND REACTION RATES: PARTICLE ENTERS VACUUM
        IF (ISWICH(2,MSURF).NE.0) IFPATH=ICOS*ISWICH(2,MSURF)

C  TURN ON OR OFF VOLUME AVERAGED TALLIES
        IF (ISWICH(3,MSURF).NE.0) IUPDTE=ICOS*ISWICH(3,MSURF)

C  NEW ADD. CELL INDEX NACELL
C  NOTE: STANDARD SURFACES CANNOT SWITCH NACELL, NBLOCK, NRCELL,....
        IF (ISWICH(4,MSURF).NE.0) THEN
          GOTO 999
C
C  ENTRANCE INTO STANDARD MESH, INTO BLOCK NBLOCK=ILBLCK
C  OR
C  EXIT FROM STANDARD MESH, INTO CELL NACELL=ILACLL
        ELSEIF (ISWICH(5,MSURF).NE.0) THEN
          IF (NACELL.EQ.0) THEN
C  SET CELL INDEX EQUAL TO ILACLL
            IF (ILACLL(MSURF) > 0) THEN
              NACELL=ILACLL(MSURF)
              NBLOCK=NBMLTP
              NRCELL=0
              NPCELL=1
              NTCELL=1
              IF (.NOT.NLADD.OR.NACELL.GT.NRADD.OR.NACELL.LT.1) THEN
                IWEI=-10
                GOTO 300
              ENDIF
            ENDIF
          ELSEIF (NACELL.GT.0) THEN
C  ENTRANCE INTO STANDARD MESH, INTO NBLOCK=ILBLCK
            NBLOCK=ILBLCK(MSURF)
            NACELL=0
C  FIND  NRCELL,IPOLG IN STANDARD MESH, BLOCK NBLOCK
            IF (IDIM.EQ.1) THEN
              NRCELL=MIN0(NR1STM,MRSURF)
              IAN=MRSURF
              IEN=MRSURF
              NDUM=LEARC1(X0,Y0,Z0,IPOLG,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                   'STDCOL      ')
            ELSEIF (IDIM.EQ.2) THEN
              IPOLG=MIN0(NP2NDM,MPSURF)
              IAN=MPSURF
              IEN=MPSURF
              NRCELL=LEARC1(X0,Y0,Z0,IDUM,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                     'STDCOL      ')
            ELSE
              NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,
     .                     .FALSE.,.FALSE.,NPANU,
     .                     'STDCOL      ')
            ENDIF
C  FIND NTCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLTOR) THEN
              IF (NLTRZ) THEN
                NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'STDCOL    ')
              ELSEIF (NLTRA) THEN
                NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'STDCOL    ')

              ENDIF
            ELSE
              NTCELL=1

            ENDIF
C  FIND NPCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLPOL) THEN
              IF (LEVGEO.EQ.1) THEN
                NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'STDCOL')
              ELSEIF (LEVGEO.EQ.2) THEN
                IF (NLCRC) THEN
                  WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
                  NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'STDCOL')
                ELSE
                  NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'STDCOL')
                ENDIF
              ELSEIF (LEVGEO.EQ.3) THEN
                NPCELL=IPOLG
              ELSE
                WRITE (iunout,*) 'ERROR EXIT IN STDCOL, NLPOL ',LEVGEO
                CALL EXIT_OWN(1)
              ENDIF
            ELSE
              NPCELL=1
            ENDIF
          ENDIF
          NBLCKA=NSTRD*(NBLOCK-1)+NACELL
C  ENTRANCE INTO STANDARD MESH, BLOCK ILBLCK
C  OR
C  EXIT FROM STANDARD MESH, INTO NACELL=NBLOCK+ILACLL
        ELSEIF (ISWICH(6,MSURF).NE.0) THEN
          IF (NACELL.EQ.0) THEN
C  SET CELL INDEX EQUAL TO ILACLL
            NACELL=NBLOCK+ICOS*ISWICH(6,MSURF)*ILACLL(MSURF)
            NBLOCK=NBMLTP
C
            NRCELL=0
            NPCELL=1
            NTCELL=1
            IF (.NOT.NLADD.OR.NACELL.GT.NRADD.OR.NACELL.LT.1) THEN
              IWEI=-10
              GOTO 300
            ENDIF
          ELSEIF (NACELL.GT.0) THEN
C  ENTRANCE INTO STANDARD MESH, INTO NBLOCK=NACELL+ILBLCK
            NBLOCK=NACELL+ICOS*ISWICH(6,MSURF)*ILBLCK(MSURF)
            NACELL=0
C  FIND  NRCELL,IPOLG IN STANDARD MESH, BLOCK NBLOCK
            IF (IDIM.EQ.1) THEN
              NRCELL=MIN0(NR1STM,MRSURF)
              IAN=MRSURF
              IEN=MRSURF
              NDUM=LEARC1(X0,Y0,Z0,IPOLG,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                   'STDCOL      ')
            ELSEIF (IDIM.EQ.2) THEN
              IPOLG=MIN0(NP2NDM,MPSURF)
              IAN=MPSURF
              IEN=MPSURF
              NRCELL=LEARC1(X0,Y0,Z0,IDUM,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                     'STDCOL      ')
            ELSE
              NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,
     .                     .FALSE.,.FALSE.,NPANU,
     .                     'STDCOL      ')
            ENDIF
C  FIND NTCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLTOR) THEN
              IF (NLTRZ) THEN
                NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'STDCOL    ')
              ELSEIF (NLTRA) THEN
                NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'STDCOL    ')

              ENDIF
            ELSE
              NTCELL=1

            ENDIF
C  FIND NPCELL IN STANDARD MESH, BLOCK NBLOCK
            IF (NLPOL) THEN
              IF (LEVGEO.EQ.1) THEN
                NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'STDCOL')
              ELSEIF (LEVGEO.EQ.2) THEN
                IF (NLCRC) THEN
                  WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
                  NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'STDCOL')
                ELSE
                  NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'STDCOL')
                ENDIF
              ELSEIF (LEVGEO.EQ.3) THEN
                NPCELL=IPOLG
              ELSE
                WRITE (iunout,*) 'ERROR EXIT IN STDCOL, NLPOL ',LEVGEO
                CALL EXIT_OWN(1)
              ENDIF
            ELSE
              NPCELL=1
            ENDIF
          ENDIF
          NBLCKA=NSTRD*(NBLOCK-1)+NACELL
        ENDIF
      ENDIF
C
C  SWITCHING DONE
C
      IF (IWEI.LT.0) GOTO 300

      IF (NLTRC.AND.IDEZ(ILIIN(MSURF),1,2).LE.4) 
     .  CALL CHCTRC(X0,Y0,Z0,16,8)
C
C
      IF (ILIIN(MSURF).LT.0) THEN
        IF (ILIIN(MSURF).EQ.-1) RETURN 1
        RETURN 2
      ENDIF
C
C  ILIIN(MASURF) .GT. 0, AND  ILIIN(MASURF) .NE. 2
C  PREPARE REFLECTION, I.E. SET OUTER NORMAL
C
      GOTO (100,150,200),IDIM
C
      ENTRY STDNOR (X0E,Y0E,Z0E,IDIM,SCOSE,MSURFE,*,*)
      X0=X0E
      Y0=Y0E
      Z0=Z0E
      SCOS=SCOSE
      MSURF=MSURFE
      IRCELL=NRCELL
      IPCELL=NPCELL
      ITCELL=NTCELL
C
      GOTO (100,150,200,250),IDIM
C
C  RADIAL SURFACE
C
100   CONTINUE
C
      IF (LEVGEO.EQ.3) THEN
        IF (NLPOL)      IP=IPCELL
        IF (.NOT.NLPOL) IP=IPOLG
        CRTX=PLNX(MRSURF,IP)*SCOS
        CRTY=PLNY(MRSURF,IP)*SCOS
        CRTZ=0.
      ELSEIF (LEVGEO.EQ.2) THEN
        CRTX=(X0-EP1(MRSURF))*ELLQ(MRSURF)
        CRTY=Y0
        PHINM=SQRT(CRTX*CRTX+CRTY*CRTY)
        CRTX=CRTX/PHINM*SCOS
        CRTY=CRTY/PHINM*SCOS
        CRTZ=0.
      ELSEIF (LEVGEO.EQ.4) THEN
        IP=IPOLG
        CRTX=PTRIX(IP,MRSURF)*SCOS
        CRTY=PTRIY(IP,MRSURF)*SCOS
        CRTZ=0.
      ELSEIF (LEVGEO.EQ.5) THEN
        if (iliin(msurf).gt.3) then
          IST=MSURF-NLIM
          CALL NORUSR(IST,X0,Y0,Z0,CRTX,CRTY,CRTZ,SCOS,
     .                VELX,VELY,VELZ,NRCELL)
        else
          IP=IPOLG
          CRTX=PTETX(IP,MRSURF)*SCOS
          CRTY=PTETY(IP,MRSURF)*SCOS
          CRTZ=PTETZ(IP,MRSURF)*SCOS
        end if
      ELSEIF (LEVGEO.EQ.1) THEN
        CRTX=SCOS
        CRTY=0.
        CRTZ=0.
C  PERIODICITY SURFACE IN X DIRECTION
        IF (ILIIN(MSURF).GT.3) THEN
          M=IDEZ(ILIIN(MSURF),2,2)
C  NEW X0, AND KEEP Y AND Z (NLTRZ) OR Y AND PHI (NLTRA) CONSTANT
          IF (NLTRA) THEN
            TANPHI=Z0/(X0+RMTOR)
            X0=RSURF(M)
            Z0=TANPHI*(X0+RMTOR)
          ELSEIF (NLTRZ) THEN
            X0=RSURF(M)
          ELSEIF (NLTRT) THEN
            WRITE (iunout,*) 'EXIT IN STDNOR'
            CALL EXIT_OWN(1)
          ENDIF
C  NEW CELL NUMBERS
          MRSURF=M
          IF (SCOS.GT.0) NRCELL=M
          IF (SCOS.LT.0) NRCELL=M-1
          GOTO 500
        ENDIF
      ELSEIF (LEVGEO.EQ.6) THEN
C
C  GENERAL GEOMETRY OPTION: PROVIDE OUTER SURFACE NORMAL UNIT VECTOR
C                           CRTX,CRTY,CRTZ
C  IN CASE OF PERIODICITY: ALSO NEW POSITION, SPEED, SURFACE- AND CELL NUMBERS
C
        IST=MSURF-NLIM
        CALL NORUSR(IST,X0,Y0,Z0,CRTX,CRTY,CRTZ,SCOS,
     .              VELX,VELY,VELZ,NRCELL)
      ENDIF
      RETURN 2
C
C  POLOIDAL SURFACE
C
150   CONTINUE
C
      IF (LEVGEO.EQ.2.OR.LEVGEO.EQ.3) THEN
        IF (NLRAD)      IR=IRCELL
C       IF (.NOT.NLRAD) IR=???
        CRTX=PPLNX(IR,MPSURF)*SCOS
        CRTY=PPLNY(IR,MPSURF)*SCOS
        CRTZ=0.
      ELSEIF (LEVGEO.EQ.1) THEN
        CRTX=0.
        CRTY=SCOS
        CRTZ=0.
C  PERIODICITY SURFACE IN Y DIRECTION
        IF (ILIIN(MSURF).GT.3) THEN
          M=IDEZ(ILIIN(MSURF),2,2)
          Y0=PSURF(M)
C  NEW CELL NUMBERS
          MPSURF=M
          IF (SCOS.GT.0) NPCELL=M
          IF (SCOS.LT.0) NPCELL=M-1
          GOTO 500
        ENDIF
      ELSE
        WRITE (iunout,*) 'STDCOL IDIM=2, BUT LEVGEO.GT.3 CALL EXIT '
        CALL EXIT_OWN(1)
      ENDIF
      RETURN 2
C
C  TOROIDAL SURFACE
C
200   CONTINUE
C
      IF (NLTRZ) THEN
        CRTX=0.
        CRTY=0.
        CRTZ=SCOS
C  PERIODICITY SURFACE IN Z-DIRECTION
        IF (ILIIN(MSURF).GT.3) THEN
          M=IDEZ(ILIIN(MSURF),2,2)
          Z0=ZSURF(M)
          MTSURF=M
          IF (SCOS.GT.0) NTCELL=M
          IF (SCOS.LT.0) NTCELL=M-1
          GOTO 500
        ENDIF
      ELSEIF (NLTRA) THEN
        CRTX=-SIN(ALPHA)
        CRTY=0.
        CRTZ=SCOS*COS(ALPHA)
C  PERIODICITY SURFACE IN TOROIDAL-DIRECTION
        IF (ILIIN(MSURF).GT.3) THEN
          M=IDEZ(ILIIN(MSURF),2,2)
C  NEW POSITION. KEEP X0,Y0 FIXED
          PHI=ZSURF(M)
C  ROTATE VELOCITY BECAUSE OF LOCAL COORDIANTE SYSTEM ROTATION
          IF (ITYP.LE.2) THEN
C  ANGLE FOR ROTATION IS 2*ALPHA
            COSROT=COSAL
            SINROT=SINAL*FLOAT(NINCZ)
            VELX_OLD=VELX
            VELX= VELX_OLD*COSROT +VELZ*SINROT
            VELZ=-VELX_OLD*SINROT +VELZ*COSROT
          ENDIF
          Z01=-Z01
          Z0=Z01
C  NEW CELL NUMBERS
          MTSURF=M
          IF (SCOS.GT.0) NTCELL=M
          IF (SCOS.LT.0) NTCELL=M-1
          IPERID=NTCELL
          GOTO 500
        ELSE
C         CRTX=?
          CRTY=0.
C         CRTZ=?
          WRITE (iunout,*) 'STDCOL IDIM=3, BUT NOT PERIODIC. CALL EXIT '
          CALL EXIT_OWN(1)
        ENDIF
      ELSE
        WRITE (iunout,*) 
     .    'STDCOL IDIM=3, BUT NEITHER NLTRZ NOR NLTRA: EXIT '
        CALL EXIT_OWN(1)
      ENDIF
      RETURN 2
C
C  MIXED SURFACE
C
250   CONTINUE
      IF (NLSRFX) GOTO 100
      IF (NLSRFY) GOTO 150
      WRITE (iunout,*) ' ERROR IN STDNOR,',
     .            ' IDIM=4 AND NEITHER NLSRFX NOR NLSRFY '
      CALL EXIT_OWN(1)
C
C
300   CONTINUE
C
C  IWEI.LT.0, I.E., ILIIN OPTION IS OVERRULED FROM THIS SIDE
C
      IF (IWEI.EQ.-1) THEN
C  PARTICLE HAS HITTEN A SURFACE FROM AN ABSORBING SIDE
C  UPDATE FLUXES (DO NOT SET WEIGHT=0.D0) AND ABSORB PARTICLE
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,8)
          WRITE (iunout,*) 'ABSORB PARTICLE: NPANU ',NPANU
        ENDIF
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        LGPART=.FALSE.
        RETURN 2
      ELSEIF (IWEI.EQ.-2) THEN
C  KILL THIS PARTICLE BECAUSE IT COMES FROM WRONG SIDE
C  DO NOT UPDATE FLUXES (SET WEIGHT=0.D0)
        PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
        ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,18)
        ENDIF
        WRITE (iunout,*) 'ERROR DETECTED IN SUBR. STDCOL '
        WRITE (iunout,*) 'PARTICLE COMES FROM WRONG SIDE '
        CALL MASJ1 ('NPANU=  ',NPANU)
        CALL MASJ1 ('MSURF NW',-(MSURF-NLIM))
        IF (MSURFS.GT.NLIM) MSURFS=-(MSURFS-NLIM)
        CALL MASJ1 ('MSURF OD',MSURFS)
        CALL MASR3 ('X0,Y0,Z0 (NEW)          ',X0,Y0,Z0)
        CALL MASR3 ('X0,Y0,Z0 (OLD)          ',X0SA,Y0SA,Z0SA)
        CALL MASR3 ('VELX,VELY,VELZ          ',VELX,VELY,VELZ)
        CALL MASR2 ('WEIGHT,E0       ',WEIGHT,E0)
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        WEIGHT=0.
        LGPART=.FALSE.
        RETURN 2
      ELSEIF (IWEI.EQ.-3) THEN
C  SURFACE IS NOT SEEN BY THE PARTICLE BECAUSE OF ILSIDE OPTION
C  I.E., SURFACE IS TRANSPARENT FROM THIS SIDE
C  ACTS AS ILIIN=0 OPTION (NO SURFACE TALLIES, NO SWITCHES)
!pb for levgeo=4 or levgeo=5 increasing of cell numbers is wrong
        IF (LEVGEO <= 3) THEN
          IF (IDIM.EQ.1.AND.ILIIN(MSURF).GT.0) NRCELL=NRCELL+ICOS
          IF (IDIM.EQ.2.AND.ILIIN(MSURF).GT.0) NPCELL=NPCELL+ICOS
          IF (IDIM.EQ.3.AND.ILIIN(MSURF).GT.0) NTCELL=NTCELL+ICOS
        END IF
        IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,8)
        RETURN 1
      ELSEIF (IWEI.EQ.-10) THEN
C  KILL THIS PARTICLE BECAUSE CELL NUMBER OUT OF RANGE DUE TO SWITCHING
C  DO NOT UPDATE FLUXES (SET WEIGHT=0.D0)
        PTRASH(ISTRA)=PTRASH(ISTRA)-WEIGHT
        ETRASH(ISTRA)=ETRASH(ISTRA)-WEIGHT*E0
        IF (NLTRC) THEN
          CALL CHCTRC(X0,Y0,Z0,16,18)
        ENDIF
        WRITE (iunout,*) 'ERROR DETECTED IN SUBR. STDCOL '
        WRITE (iunout,*) 'NACELL OUT OF RANGE '
        CALL MASJ1 ('NPANU=  ',NPANU)
        WRITE (iunout,*) 'NLMLT,NLADD ',NLMLT,NLADD
        WRITE (iunout,*) 'NBMLT,NRADD ',NBMLT,NRADD
        CALL MASJ1 ('MSURF NW',-(MSURF-NLIM))
        IF (MSURFS.GT.NLIM) MSURFS=-(MSURFS-NLIM)
        CALL MASJ1 ('MSURF OD',MSURFS)
        CALL MASJ1 ('NACL NEW',NACELL)
        CALL MASJ1 ('NACL OLD',NACLLS)
        CALL MASR3 ('X0,Y0,Z0 (NEW)          ',X0,Y0,Z0)
        CALL MASR3 ('X0,Y0,Z0 (OLD)          ',X0SA,Y0SA,Z0SA)
        CALL MASR3 ('VELX,VELY,VELZ          ',VELX,VELY,VELZ)
        CALL MASR2 ('WEIGHT,E0       ',WEIGHT,E0)
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        WEIGHT=0.
        LGPART=.FALSE.
        RETURN 2
      ENDIF
C
C  ABSORBING SURFACE
C  UPDATE FLUXES (DO NOT SET WEIGHT=0.D0)
C
400   CONTINUE
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,8)
      RETURN 2
C
500   CONTINUE
      IF (NLTRA) X01=X0+RMTOR
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
      RETURN 2
      
C
999   CONTINUE
      WRITE (iunout,*) 'ERROR IN STDCOL, WRONG CELL SWITCHING '
      WRITE (iunout,*) 'NPANU, MSURF = ',NPANU,MSURF
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: timcol.f
C  SEPT 05:  IN CASE OF TEST IONS, VEL IS THE PARALLEL VELOCITY ONLY
C            THIS HAS STILL TO BE TAKEN INTO ACCOUNT WHEN STORING AND SAMPLING
C            THE CENSUS ARRAY

      SUBROUTINE TIMCOL (PR,*,*)
C
C  COLLISION WITH TIME SURFACE, FIND NEW CO-ORDINATES
C  UPDATE (TIME-) SURFACE TALLIES
C  UPDATE USER SUPPLIED SNAPSHOT ESTIMATED TALLIES (CALL UPNUSR)
C  PUT PARTICLE ONTO CENSUS ARRAYS
C  AND STOP HISTORY
C  RETURN 1: CONTINUE FLIGHT
C  RETURN 2: STOP FLIGHT
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CESTIM
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CGRID
      USE COMPRT
      USE COMNNL
      USE CLGIN

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: PR
      REAL(DP) :: DIST
      INTEGER :: J
C
      X0=X0+VELX*TT
      Y0=Y0+VELY*TT
      Z0=Z0+VELZ*TT
      TIME=TIME+TT/VEL
      MSURF=0
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
C
      IPOLG=IPOLGN
      IPERID=NNTCLL
      IF (NLTRA) THEN
        PHI=MOD(PHI-ATAN2(Z01,X01)+ATAN2(Z0,(RMTOR+X0)),PI2A)
        X01=X0+RMTOR
      ENDIF
      X00=X0
      Y00=Y0
      Z00=Z0
      Z01=Z0
      WEIGHT=WEIGHT*PR
C
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,15)
C
C  UPDATE SNAPSHOT ESTIMATORS
      IF (NSNVI.GT.0) CALL UPNUSR
C
c-dpc
      dist=sqrt(x0**2+y0**2)
      if(dist.gt.1e4) then
        write(*,*) 'timcol: ERROR!  dist = ',dist,
     1   ' (particle more than 100 m from the origin)'
        write(*,*) 'npanu,x0,y0,z0,velx,vely,velz ',
     1   npanu,x0,y0,z0,velx,vely,velz
        weight=0.
        goto 112
      endif
c-dpc
      IPRNLI=IPRNLI+1
      IPRNLS=IPRNLS+1
      IF (IPRNLS.GE.NPRNLS(ISTRA).AND..NOT.NLMOVIE) THEN
C  THIS IS THE LAST SCORE FOR THIS STRATUM TO BE STORED
        LGLAST=.TRUE.
      ENDIF
C
C   CENSUS ARRAYS:
C   SAVE LOCATION, WEIGHT AND OTHER PARAMETERS
      DO 100 J=1,NPARTT
        RPART(IPRNLI,J)=RPSTT(J)
100   CONTINUE
      DO 110 J=1,MPARTT
        IPART(IPRNLI,J)=IPSTT(J)
110   CONTINUE
C
112   continue
C  DECIDE: CONTINUE OR STOP TRAJECTORY
      IF ((NTMSTP.GE.0.AND.ITMSTP.GE.NTMSTP).OR.LGLAST) THEN
C
C  DO NOT CONTINUE THIS TRACK
C  UPDATE PARTICLE EFFLUX  ONTO TIME-SURFACE MSURF=NLIM+NSTSI
C  UPDATE ENERGY FLUX ONTO TIME-SURFACE MSURF=NLIM+NSTSI
C
        MSURF=NLIM+NSTSI
        IF (ITYP.EQ.1) THEN
          IF (LEOTAT) EOTAT(IATM,MSURF)=EOTAT(IATM,MSURF)+E0*WEIGHT
          IF (LPOTAT) POTAT(IATM,MSURF)=POTAT(IATM,MSURF)+WEIGHT
        ELSEIF (ITYP.EQ.2) THEN
          IF (LEOTML) EOTML(IMOL,MSURF)=EOTML(IMOL,MSURF)+E0*WEIGHT
          IF (LPOTML) POTML(IMOL,MSURF)=POTML(IMOL,MSURF)+WEIGHT
        ELSEIF (ITYP.EQ.3) THEN
          IF (LEOTIO) EOTIO(IION,MSURF)=EOTIO(IION,MSURF)+E0*WEIGHT
          IF (LPOTIO) POTIO(IION,MSURF)=POTIO(IION,MSURF)+WEIGHT
        ENDIF
        ISPZ=ISPEZ(ITYP,IPHOT,IATM,IMOL,IION,IPLS)
        IF (LSPUMP) SPUMP(ISPZ,MSURF)=SPUMP(ISPZ,MSURF)+WEIGHT
        RETURN 2
      ELSE
C  OTHERWISE: RESTORE WEIGHT = WEIGHT/PR, AND CONTINUE
        WEIGHT=WEIGHT/PR
        ITMSTP=ITMSTP+1
        TIME=TIME0
        RETURN 1
      ENDIF
      RETURN
      END
C ===== SOURCE: torcol.f
C
      SUBROUTINE TORCOL(*)

C  PARTICLE ON TOROIDAL PERIODICITY SURFACE MTSURF, FLIGHT INTO CELL NNTCLL
C  RETURN 1:  NO SURFACE TALLIES, FLIGHT CONTINUES

      USE PRECISION
      USE PARMMOD
      USE CCONA
      USE CLOGAU
      USE CUPD
      USE CGRID
      USE COMPRT
      USE CLGIN

      IMPLICIT NONE

      REAL(DP) :: VELX_OLD, SINROT,COSROT
      INTEGER :: LEARC1, ISTS, NN, IPERID_OLD
C
      TIME=TIME+ZT/VEL
C
      IF (NINCZ.EQ.0) THEN
        WRITE (iunout,*) 'ERROR IN TORCOL, NINCZ ?  '
        WRITE (iunout,*) 'NINCZ ',NINCZ
        CALL EXIT_OWN(1)
      ENDIF
C
C
      IF (ITYP.LE.2) THEN
C  ANGLE FOR ROTATION IS 2*ALPHA
        COSROT=COSAL
        SINROT=SINAL*FLOAT(NINCZ)
        VELX_OLD=VELX
        VELX= VELX_OLD*COSROT +VELZ*SINROT
        VELZ=-VELX_OLD*SINROT +VELZ*COSROT
      ENDIF
C  ADVANCE TO NEXT TOROIDAL CELL
      X0=X01-RMTOR
      Y0=Y0+ZT*VELY
      Z01=-Z01
      Z0=Z01
C
      NLSRFX=.FALSE.
      NLSRFZ=.FALSE.
      NLSRFZ=.TRUE.
      IPERID=NNTCLL
C
      IF (LEVGEO.EQ.3.OR.(LEVGEO.EQ.2.AND.NLPOL)) THEN
        IF (NRCELL.GT.0)
     .  NN=LEARC1(X0,Y0,Z0,IPOLG,NRCELL,NRCELL,.FALSE.,.FALSE.,
     .                           NPANU,'TORCOL 1')
      ENDIF
C
      IF (NLTRC) CALL CHCTRC(X0,Y0,Z0,16,11)
C
      IF (.NOT.NLTOR) THEN
C
        MSURF=0
        RETURN 1
      ELSE
C
C  NLTOR=TRUE:
C
        MSURF=0
        IF (NRCELL.GT.0) NTCELL=NNTCLL
        ISTS=INMP3I(IRCELL,IPCELL,MTSURF)
        IF (ISTS.EQ.0) RETURN 1
        ZT=0.
        RETURN
      ENDIF
C
997   CONTINUE
      END
C ===== SOURCE: velocs.f
C
      SUBROUTINE VELOCS (TIWL,ESHET,VWL,VXWL,VYWL,VZWL,RSQDV,CVRSS,
     .                   CX,CY,CZ,
     .                   E0S,VELXS,VELYS,VELZS,VELS)
C
C  FETCH A NEW VELOCITY FROM A MAXWELLIAN FLUX AT A SURFACE GIVEN
C  BY THE NORMAL: CX,CY,CZ
C  THE MAXWELLIAN IS DEFINED BY A TEMPERATURE TIWL (EV) AND A
C  DRIFT VECTOR VXWL,VYWL,VZWL (CM/SEC). VWL IS THE VECTOR
C  NORM OF THIS DRIFT VECTOR, AND IS NEEDED ONLY TO DECIDE, WHETHER
C  THERE IS A DRIFT AT ALL (VWL.GT.0) OR NOT (VWL.LE.0.).
C  THE PARTICLE MAY BE ACCELERATED PERPENDICULAR
C  TOWARDS THE TARGET BY A SHEATH POTENTIAL WITH ENERGY ESHET (EV)
C  (IF ESHET.GT.0.)
C  OUTPUT ENERGY, SPEED UNIT VECTOR AND VELOCITY ARE, RESP.:
C         E0S,    VELXS,VELYS,VELZS AND VELS
C
      USE PRECISION
      USE PARMMOD
      USE CCONA
      USE CRAND
      USE COMPRT
      IMPLICIT NONE
      REAL(DP), INTENT(IN) :: TIWL, ESHET, VWL, RSQDV, CVRSS, CX, CY, CZ
      REAL(DP), INTENT(INOUT) :: VXWL, VYWL, VZWL
      REAL(DP), INTENT(OUT) :: E0S, VELXS, VELYS, VELZS, VELS
      REAL(DP) :: ARBV, A1, A2, A3, VLLX, VLLY, VLLZ, VMX, SHIFT,
     .          CCM, A4, FNOM, VMXSQ, FACTOR, VELSQ, VELSH, A5, A6,
     .          VFKT, VLX, RCCM, ZARG, ZARG2, VXDR, VYDR, VZDR, ERF
      REAL(DP), EXTERNAL :: RANF_EIRENE
C
C---------------------------------------------------------------------
C
      IF (INIV1.EQ.0) CALL FMAXWL
C
      ZARG2=SQRT(TIWL)*RSQDV
      ZARG=ZARG2*SQ2I
C
C  ROTATE DRIFT VELOCITY VXWL,VYWL,VZWL FROM A GLOBAL CARTESIAN
C  INTO A CARTESIAN COORDINATE SYSTEM, IN WHICH THE TARGET NORMAL
C  IS NOW IN THE POSITIVE X-DIRECTION
C
      IF (VWL.GT.0.D0) THEN
        CALL ROTATI(VXWL,VYWL,VZWL,VXDR,VYDR,VZDR,CX,CY,CZ)
      ELSE
        VXDR=0.
        VYDR=0.
        VZDR=0.
      ENDIF
C
C  FROM NOW ON: TARGET NORMAL IS IN X DIRECTION, AND VXDR,VYDR,VZDR
C               IS THE PLASMA DRIFT VELOCITY IN THIS COORDINATE SYSTEM
C
C  MAXWELLIAN FLUX + DRIFT CONTRIBUTION
C  AT THIS POINT: THE SURFACE NORMAL IS IN THE POSITIVE X DIRECTION
C

      VLLX=FM1(INIV1)*ZARG
      VLLY=FM2(INIV1)*ZARG+VYDR
      VLLZ=FM3(INIV1)*ZARG+VZDR
      INIV1=INIV1-1
C  WEIGHT CORRECTION DUE TO DRIFT-COMPONENT VXDR IN MAXWELLIAN FLUX:
C  NORMALIZED DRIFT COMPONENT    VMX=VXDR/ZARG2
C  NORMALIZED THERMAL COMPONENT  VLX=VLLX/ZARG2
      IF (VXDR.NE.0.D0) THEN
        VMX=VXDR/ZARG2
        CCM=0.6026*VMX
        IF (CCM.GE.1.) THEN
C         WRITE (iunout,*) 'WARNING FROM SUBR. VELOCS:'
C         WRITE (iunout,*) 'MACH NUMBER PERP. TO TARGET TOO LARGE FOR'
C         WRITE (iunout,*) 'RANDOM SAMPLING ALGORITHM, M-PERP= ',VMX
C         WRITE (iunout,*) 'ARTIFICIAL CUT OFF IS USED! '
C         CCM=0.95
C         VMX=CCM/0.6026
CDR USE REJECTION TECHNIQUE RATHER THAN WEIGHT CORRECTION TECHNIQUE
C         WEIGHT=1.
          VLLX=VXDR
          SHIFT=VMX
100       ARBV=RANF_EIRENE()*(SHIFT+4.)
          A1=SQRT(SHIFT**2+2.)
          A2=SHIFT+A1
          A3=SHIFT-A1
          A4=0.5+0.5*SHIFT*A3
          A5=A4-(ARBV-SHIFT)**2
          A6=EXP(A5)
          VFKT=2.*ARBV/A2*A6
          IF(RANF_EIRENE().GT.VFKT) GOTO 100
          VLLX=ARBV*ZARG2
          GOTO 1000
CDR
        ENDIF
        RCCM=1./(1.-CCM)
        VLLX=VLLX*SQRT(RCCM)
        VLX=VLLX/ZARG2
C
        VMXSQ=-VMX*VMX
        FNOM=EXP(VLX*(VMX+VMX-CCM*VLX))*RCCM
        FACTOR=FNOM/(1.+VMX*PISQ*(1.+ERF(VMX))/EXP(VMXSQ))
        WEIGHT=WEIGHT*FACTOR
      ENDIF
1000  CONTINUE
C
C  SHEATH CONTRIBUTION: ADD A COMPONTENT TO X-VELOCITY VLLX (CM/S), 
C                       SUCH THAT ENERGY OF INCIDENT ION IS INCREASED BY
C                       ESHET (EV)
C
      IF (ESHET.GT.0.D0) THEN
        VELSH=SQRT(ESHET)*RSQDV
        VLLX=SQRT(VELSH**2+VLLX**2)
      ENDIF

C  NOW ROTATE BACK INTO GLOBAL CARTESIAN COODINATE SYSTEM

      CALL ROTATF(VELXS,VELYS,VELZS,VLLX,VLLY,VLLZ,CX,CY,CZ)
C
C  NORMALIZE CARTESIAN SPEED VECTOR, SET VEL=VELS(CM/S)  AND E0=E0S (EV)
      VELSQ=VELXS*VELXS+VELYS*VELYS+VELZS*VELZS
      VELS=SQRT(VELSQ)
      VELXS=VELXS/VELS
      VELYS=VELYS/VELS
      VELZS=VELZS/VELS
      E0S=CVRSS*VELSQ
C
      RETURN
      END
C ===== SOURCE: velocx.f
C
      SUBROUTINE VELOCX(K,VXO,VYO,VZO,VLO,IOLD,NOLD,VELQ,NFLAG,
     .                  IRCX,DUMT,DUMV)
C
C  THIS SUBROUTINE CARRIES OUT A CHARGE EXCHANGE COLLISION OF A TEST PARTICLE
C  WITH A BULK PARTICLE.
C  IT RETURNS THE POST COLLISION VELOCITY VECTOR.
C
C  NFLAG= 1:       SAMPLING FROM MONOENERGETIC DISTRIBUTION
C                  OF ION SPEED IN 1D, X DIRECTION
C                               IN 2D, X,Y DIRECTION
C                               IN 3D, X,Y,Z DIRECTION
C                  (I.E., DELTA FUNCTION IN ENERGY SPACE)
C                  E=ESIGCX(IRCX,1)
C  NFLAG= 2:       SAMPLING FROM SHIFTED MAXWELLIAN
C                  "FMAXW" AT TI AND V-DRIFT IN CELL K
C  NFLAG= 3:       SAMPLING FROM SHIFTED MAXWELLIAN + WEIGHT CORRECTION
C                  FACTOR = SIGMA*VREL*FMAXW/<SIGMA*VREL>
C                  OR ALTERNATIVELY: REJECTION
C

C  K   : .NE.0 :CELL INDEX FOR LOCAL BULK ION TI AND V_DRIFT
C  note: ti has already been converted into thermal velocity units: zrg(ipls,k)

C  K   : .EQ.0 :TX,TY,TZ,V-DRIFT_X,Y,Z ARE NOT FROM LOCAL BULK ION
C               SPECIES IPLS, BUT EXPLICITLY IN THE PARAMETERS DUMT AND DUMV.
C               RESPECTIVELY.
c  note: here dumt must also be in thermal velocity units

C  VXO : X COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VYO : Y COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VZO : Z COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VLO : VELOCITY OF TEST PARTICLE BEFORE EVENT
C  IOLD: SPECIES INDEX OF THE TEST PARTICLE BEFORE THE EVENT
C  NOLD: DITO, IN MODCOL-ARRAY
C  IPLS: SPECIES INDEX FOR THE THERMAL PLASMA ION VELOCITY
C        AND FOR THE PLASMA DRIFT VELOCITY TO BE USED AS
C        SHIFT VECTOR   (IPLS IN COMMON COMUSR)
C  IRCX: LABEL FOR CX-REACTION, E.G., FOR SIGVCX(IRCX)
C        NOT NEEDED FOR NFLAG=2, THEN SET E.G.: IRCX=1

C  USED E.G. FOR VOLUME RECOMBINATION SOURCE (NFLAG=2)
C  OR TO  FETCH A NEW  VELOCITY FOR A NEUTRAL ATOM "IATM",
C  A NEUTRAL MOLECULE "IMOL" OR A TEST ION "IION"
C  AFTER CX-EVENT WITH BULK ION "IPLS" IN CELL NO. K FROM A SHIFTED
C  MAXWELLIAN (NFLAG=2), WEIGHTED BY SIGMA*VREL (NFLAG=3)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CLOGAU
      USE CRAND
      USE CINIT
      USE CZT1
      USE CTRCEI
      USE COMPRT
      USE COMXS
      USE CLAST

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: DUMT(3), DUMV(3)
      REAL(DP), INTENT(IN) :: VXO, VYO, VZO, VLO
      REAL(DP), INTENT(OUT) :: VELQ
      INTEGER, INTENT(IN) :: K, IOLD, NOLD, NFLAG, IRCX

      REAL(DP) :: VXN, VYN, VZN, VX,VY,VZ, VN, ZARGX, ZARGY, ZARGZ,
     .          VXDR, VYDR, VZDR, VRELQ, E0MAX, TIMAX, SIGS, VRELS,
     .          WRMEAN, TEST, VREL, WRAT, WO, ELAB, ELLAB, CXS,
     .          VR, VRQ, CROSS, ELMAX, ELMIN
      REAL(DP), EXTERNAL :: RANF_EIRENE
      REAL(DP) :: WRMAX = -1000.D0, WRMIN = 1000.D0

      INTEGER :: IMEAN, IRX, ICOUNT, J, JJ, IRL, IREAC
      INTEGER :: IPMAX = 0, IPMIN = 0, IFIRST = 0

      SAVE
C
      IF (IFIRST.EQ.0) THEN
        IFIRST=1
        DO IRL=1,NRCXI
          IFLRCX(IRL)=0
          NCMEAN(IRL)=0
          XCMEAN(IRL)=0.D0
        ENDDO
      ENDIF
C
      IF (IFLRCX(IRCX).EQ.0.AND.NFLAG.NE.2) THEN
        IFLRCX(IRCX)=-1
C  PREPARE REJECTION SAMPLING OF INCIDENT ION VELOCITY
C  IS CROSS SECTION AVAILABLE?
        IREAC=MODCOL(3,1,IRCX)
        IF (IREAC.EQ.0) GOTO 1
C
        elmin=log(0.1_dp)
        elmax=log(1.e4_dp)
        SGCVMX(IRCX)=-1.D60
        JJ=1
        do j=1,1000
          elab=elmin+(j-1)/999._dp*(elmax-elmin)
          CXS=CROSS(ELAB,IREAC,IRCX,'VELOCX 1')
          vrq=exp(elab-defCX(IRCX))
          vr=sqrt(vrq)
          if (cXS*vr.gt.SGCVMX(IRCX)) then
            JJ=J
            SGCVMX(IRCX)=cXS*vr
          endif
        enddo
        CALL LEER(1)
        WRITE (iunout,*) 'FIRST CALL TO VELOCX FOR IRCX= ',IRCX
        WRITE (iunout,*) 'PREPARE REJECTION TECHNIQUE '
        WRITE (iunout,*) 'FIND MAX. "SGCVMX" OF SIGMA(VEL) * VEL '
        WRITE (iunout,*) 'SGCVMX IN VELOCX,JJ ',SGCVMX(IRCX),JJ
        IF (JJ.NE.1.AND.JJ.NE.1000) THEN
          elab=elmin+(JJ-1)/999.*(elmax-elmin)
          ELAB=EXP(ELAB)
          WRITE (iunout,*) 'TRUE MAXIMUM FOUND AT ELAB(EV) = ',ELAB
          IFLRCX(IRCX)=1
        ELSE
          WRITE (iunout,*) 'NO TRUE MAXIMUM FOUND, USE WEIGHING '
        ENDIF
        CALL LEER(1)
      ENDIF
1     CONTINUE
C
      ICOUNT=1

      IF (K.GT.0) THEN
        ZARGX=ZRG(IPLS,K)
        ZARGY=ZRG(IPLS,K)
        ZARGZ=ZRG(IPLS,K)
        IF (NLDRFT) THEN
          IF (INDPRO(4) == 8) THEN
            CALL VECUSR(2,VXDR,VYDR,VZDR,IPLS)
          ELSE
            VXDR=VXIN(IPLS,K)
            VYDR=VYIN(IPLS,K)
            VZDR=VZIN(IPLS,K)
          END IF
        ELSE
          VXDR=0.D0
          VYDR=0.D0
          VZDR=0.D0
        ENDIF
      ELSE
        IF (NFLAG.NE.2) GOTO 999
        ZARGX=DUMT(1)
        ZARGY=DUMT(2)
        ZARGZ=DUMT(3)
        VXDR=DUMV(1)
        VYDR=DUMV(2)
        VZDR=DUMV(3)
      ENDIF
C
123   CONTINUE
      IF (INIV2.LE.0) CALL FGAUSS
C
C  SAMPLE FROM 3D MAXWELLIAN
      VXN=FG1(INIV2)
      VYN=FG2(INIV2)
      VZN=FG3(INIV2)
      INIV2=INIV2-1
C
C  DRIFTING, MONOENERGETIC ISOTROPIC DISTRIBUTION
C
      IF (NFLAG.EQ.1) THEN
C  ZT1 CORRESPONDS TO ROOT MEAN SQUARE VELOCITY AT TIIN(IPLS,K)
        VEL=SQRT(ZT1(IPLS,K))
        VN=VEL/SQRT(VXN*VXN+VYN*VYN+VZN*VZN)
        VXN=VXN*VN+VXDR
        VYN=VYN*VN+VYDR
        VZN=VZN*VN+VZDR
      ELSE
        VXN=VXN*ZARGX+VXDR
        VYN=VYN*ZARGY+VYDR
        VZN=VZN*ZARGZ+VZDR
      ENDIF
C
C  DRIFTING MAXWELLIAN DISTRIBUTION (FOR MAXWELL-POTENTIAL: SIGMA*V = CONST.)
C
      IF (NFLAG.EQ.2) THEN
C
        VELQ=VXN*VXN+VYN*VYN+VZN*VZN
        VEL=SQRT(VELQ)
        VN=1./VEL
        VELX=VXN*VN
        VELY=VYN*VN
        VELZ=VZN*VN
C
C       VEL_MEAN=SQRT(VXDR**2+VYDR**2+VZDR**2)
C       VELX_MEAN=VXDR/(VEL_MEAN+EPS60)
C       VELY_MEAN=VYDR/(VEL_MEAN+EPS60)
C       VELZ_MEAN=VZDR/(VEL_MEAN+EPS60)
C
C   NOTHING MORE TO BE DONE
C
        RETURN
C
      ELSE
C
        VX=VXO*VLO
        VY=VYO*VLO
        VZ=VZO*VLO
C
C   ALL OTHER DISTRIBUTIONS
C
C   WEIGHT CORRECTION DUE TO ENERGY DEPENDENCE IN CROSS SECTION
C   OR: REJECTION     DUE TO ENERGY DEPENDENCE IN CROSS SECTION
C   PRESENT VERSION: REJECTION
        VRELQ=(VXN-VX)**2+(VYN-VY)**2+(VZN-VZ)**2
        VREL=SQRT(VRELQ)
        ELAB=LOG(VRELQ)+DEFCX(IRCX)
        IREAC=MODCOL(3,1,IRCX)
        CXS=CROSS(ELAB,IREAC,IRCX,'VELOCX 2')
C
C       IF (NLREJC) THEN    !  REJECTION IS NOW DEFAULT OPTION
C
        IF (IFLRCX(IRCX).GT.0) THEN
          TEST=RANF_EIRENE()*SGCVMX(IRCX)
          if (test.gt.cxs*vrel) then
c  reject
            icount=icount+1
            if (icount.lt.500) goto 123
            write (iunout,*) 
     .        'icount too large ( > 500) IN VELOCX. ACCEPT SAMPLE '
              ELLAB=EXP(ELAB)
            write (iunout,*) 'npanu, ireac, ircx, ELAB(EV) ',
     .                        npanu, ireac, ircx, ELLAB
          else
c  accept
            xcmean(ircx)=xcmean(ircx)+icount
            ncmean(ircx)=ncmean(ircx)+1
          endif
C       ELSEIF (NLWEIGHT) THEN

        ELSE
C  FOR SOME REASON SGCVMX COULD NOT BE FOUND. 
C  SO USE WEIGHTING RATHER THAN REJECTION
          WEIGHT=WEIGHT*CXS*VREL*DIIN(IPLS,K)/SIGVCX(IRCX)
        ENDIF
C
C
        VELQ=VXN*VXN+VYN*VYN+VZN*VZN
        VEL=SQRT(VELQ)
        VN=1./VEL
        VELX=VXN*VN
        VELY=VYN*VN
        VELZ=VZN*VN
C
C       VEL_MEAN=VEL
C       VELX_MEAN=VELX
C       VELY_MEAN=VELY
C       VELZ_MEAN=VELZ
C
      ENDIF
C
      RETURN
C
999   CONTINUE
      WRITE (iunout,*) 'PARAMETER ERROR IN SUBR. VELOCX. EXIT CALLED'
      CALL EXIT_OWN(1)
      END
C ===== SOURCE: veloei.f
C  27.6.05: test for photon secondaries added
c  15.12.05:  irds --> irei,  comments
C
      SUBROUTINE VELOEI(K,IREI,VXO,VYO,VZO,VLO)
C
C  FETCH A NEW SPECIES INDEX AND A
C          NEW VELOCITY OF TEST PARTICLE AFTER ELECTRON IMPACT COLLISION
C  AT THIS POINT: ONE NEXT GENERATION TEST PARTICLE WILL BE BORN
C                 I.E. WEIGHT ADJUSTMENT ALREADY DONE IN CALLING PROGRAM
C
C  K   : CELL INDEX
C  VXO : X COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VYO : Y COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VZO : Z COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VLO : VELOCITY OF TEST PARTICLE BEFORE EVENT
C
C
C  FIND TYPE OF NEXT GENERATION PARTICLE (ATOM, MOLECULE, TEST ION)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CRAND
      USE CZT1
      USE COMPRT
      USE COMXS

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: VXO, VYO, VZO, VLO
      INTEGER, INTENT(IN) :: K, IREI
      REAL(DP) :: FEHVDS1, VXDIS, VYDIS, VZDIS, EHEAVY, VX, VY, VZ,
     .            VELQ, CVRSS, RSQDV, EDISS, ZEP3, VELDS
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: ISPZI, ISPZM, ISPZA

      ZEP3=RANF_EIRENE( )
C
      IF (ZEP3.LE.P2ND(IREI,NSPH)) THEN
C
C  A PHOTON IS BORN, FIND SPECIES INDEX IPHOT AND VELOCITY
C
C  OPTION NOT WRITTEN
        WRITE (iunout,*) 'INVALID OPTION IN VELOEI. CALL EXIT '
        CALL EXIT_OWN(1)
C
      ELSEIF (ZEP3.LE.P2ND(IREI,NSPA)) THEN
C
C  A NEUTRAL ATOM IS BORN, FIND SPECIES INDEX IATM AND WEIGHT
C
        ITYP=1
        DO 448 IATM=1,NATMIM
          ISPZA=NSPH+IATM
          IF (ZEP3.LE.P2ND(IREI,ISPZA)) GOTO 449
448     CONTINUE
        IATM=NATMI
449     CONTINUE
        CVRSS=CVRSSA(IATM)
        RSQDV=RSQDVA(IATM)
        EDISS=EATDS(IREI,IATM,2)
C
      ELSEIF (ZEP3.LE.P2ND(IREI,NSPAM)) THEN
C
C  A NEUTRAL MOLECULE IS BORN, FIND SPECIES INDEX IMOL AND WEIGHT
C
        ITYP=2
        DO 458 IMOL=1,NMOLIM
          ISPZM=NSPA+IMOL
          IF (ZEP3.LE.P2ND(IREI,ISPZM)) GOTO 459
458     CONTINUE
        IMOL=NMOLI
459     CONTINUE
        CVRSS=CVRSSM(IMOL)
        RSQDV=RSQDVM(IMOL)
        EDISS=EMLDS(IREI,IMOL,2)
C
      ELSEIF (ZEP3.LE.P2ND(IREI,NSPAMI)) THEN
C
C  A TEST ION IS BORN, FIND SPECIES INDEX IION AND WEIGHT
C
        ITYP=3
        DO 468 IION=1,NIONIM
          ISPZI=NSPAM+IION
          IF (ZEP3.LE.P2ND(IREI,ISPZI)) GOTO 469
468     CONTINUE
        IION=NIONI
469     CONTINUE
        CVRSS=CVRSSI(IION)
        RSQDV=RSQDVI(IION)
        EDISS=EIODS(IREI,IION,2)
C
      ELSE
        WRITE (iunout,*) 'ERROR IN VELOEI '
        WRITE (iunout,*) 'IREI ',IREI,P2ND(IREI,NSPAMI)
        CALL EXIT_OWN(1)
      ENDIF
C
      IF (NSTORDR >= NRAD) THEN
        EHEAVY=EHVDS1(IREI,K)
      ELSE
        EHEAVY=FEHVDS1(IREI,K)
      END IF
      EDISS=EDISS*EHEAVY
C
C  FIND SPEED VECTOR FROM ISOTROPIC DISTRIBUTION IN CENTER OF MASS
C  SYSTEM
C

      IF (EDISS.GT.0.D0) THEN
C
C  NEXT LINES: E-NEW=E-OLD+EDIS, ON AVERAGE
C
        IF (INIV3.EQ.0) CALL FISOTR
C
        VXDIS=FI1(INIV3)
        VYDIS=FI2(INIV3)
        VZDIS=FI3(INIV3)
        INIV3=INIV3-1
C
        VELDS=SQRT(EDISS)*RSQDV
        VX=VLO*VXO+VELDS*VXDIS
        VY=VLO*VYO+VELDS*VYDIS
        VZ=VLO*VZO+VELDS*VZDIS
        VELQ=VX*VX+VY*VY+VZ*VZ
        VEL=SQRT(VELQ)
        VELX=VX/VEL
        VELY=VY/VEL
        VELZ=VZ/VEL
      ELSE
        VELX=VXO
        VELY=VYO
        VELZ=VZO
        VEL=VLO
        VELQ=VEL*VEL
      ENDIF
      E0=CVRSS*VELQ
C
      RETURN
      END
C ===== SOURCE: veloel.f
c   061205:   au_to_cm2 --> ccona


      SUBROUTINE VELOEL(K,VXO,VYO,VZO,VLO,IOLD,NOLD,VELQ,NFLAG,
     .                  IREL,RMASS)
C
C  THIS SUBROUTINE CARRIES OUT AN ELASTIC COLLISION OF A TEST PARTICLE
C  WITH A BULK PARTICLE.
C  IT RETURNS THE POST COLLISION VELOCITY VECTOR.
C
C  NFLAG: AS IN SUBR. VELOCX
C
C  1ST STEP: FIND COLLISION PARTNER FROM BULK ION SPECIES "IPLS":
C            (VXN,VYN,VZN)
C  2ND STEP: FIND CROSS SECTION AS FUNCTION OF ELAB (AND
C            CARRY OUT WEIGHT CORRECTION, UNLESS REJECTION HAS BEEN USED
C            IN STEP 1
C  3RD STEP: FIND IMPACT PARAMETER B
C  4TH STEP: FIND NEW VELOCITY VECTOR
C
C
C  K   : CELL INDEX
C  VXO : X COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VYO : Y COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VZO : Z COMPONENT OF SPEED UNIT VECTOR OF TEST PARTICLE BEFORE EVENT
C  VLO : VELOCITY OF TEST PARTICLE BEFORE EVENT
C  IOLD: SPECIES INDEX OF THE TEST PARTICLE BEFORE THE EVENT
C  NOLD: DITO, IN MODCOL-ARRAY
C  IPLS: SPECIES INDEX FOR THE THERMAL PLASMA ION VELOCITY
C        AND FOR THE PLASMA DRIFT VELOCITY TO BE USED AS
C        SHIFT VECTOR   (IPLS IN COMMON COMUSR)
C  IREL: LABEL FOR EL-REACTION, E.G., FOR SIGVEL(IREL)
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE CCONA
      USE CLOGAU
      USE CRAND
      USE CINIT
      USE CZT1
      USE CTRCEI
      USE COMPRT
      USE COMXS
      USE CLAST

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: VXO, VYO, VZO, VLO, RMASS
      REAL(DP), INTENT(OUT) :: VELQ
      INTEGER, INTENT(IN) :: K, IOLD, NOLD, NFLAG, IREL

      REAL(DP) :: WRMEAN, WRAT, TEST, WO, TIMAX, SIGS, VRELX, VRELS,
     .          E0MAX, ELABS, VXI, VYI, VZI, VRELQ, VN, VREL,
     .          RLMS, RAN, RMSI, RMN, RMI, VRELY, EPS, CPH, CHI,
     .          RSTERN, RESULT, SPH, VRSX, VRSY, VRSZ, CEPS, SEPS, RS,
     .          VSX, VSY, VRYZ, VRELZ, VRQYZ, VSZ, DUMSIGMA, PH,
     .          CTTETHA, BMAX, ELTHETA, ER, ELMIN, ELMAX, B,
     .          VXDR, VYDR, VZDR, ZARGX, ZARGY, ZARGZ, VXN, VYN, VZN,
     .          VX, VY, VZ, ELTHDUM, CTCHDUM, SIGHABER, ELAB,
     .          VR, ZARG, CEL, CROSS, VRQ
      REAL(DP), EXTERNAL :: RANF_EIRENE
      REAL(DP) :: P(9)
!     REAL(DP) :: P_HE_H(9),P_NE_H(9),P_AR_H(9),P_KR_H(9),P_XE_H(9)
!     REAL(DP) :: P_H2_H(9)
!     REAL(DP) :: P_HE_HE(9)
      INTEGER :: IMEAN, IFLAG, IRL, IREAC, JJ, J, ICOUNT, KK
      INTEGER :: IFIRST=0
!  PARAMETERS FOR INTERACTION POTENTIALS ARE NOW READ FROM FILE AMJUEL,
!  NOT HARD WIRED IN THIS ROUTINE OR (EVEN OLDER VERSIONS)
!  IN FUNTIONS FI, FIVEC
!     DATA P_HE_HE/2.55,2.35,0.90,1.9842,1.3990 ,2.6345  ,0.,-1.9125,0./
!     DATA P_H2_H /2.70,3.00,1.00,2.8355,2.18038,3.490687,0.,-2.025 ,0./
!     DATA P_HE_H /2.00,2.20,0.85,1.4556,0.99699,1.99515 ,0.,-1.5   ,0./
!     DATA P_NE_H /2.28,2.68,0.85,1.8709,1.3870 ,2.4402  ,0.,-1.71  ,0./
!     DATA P_AR_H /4.04,2.50,0.86,2.4756,1.7892 ,3.2737  ,0.,-3.03  ,0./
!     DATA P_KR_H /4.45,2.50,0.80,2.7779,2.0077 ,3.7406  ,0.,-3.3375,0./
!     DATA P_XE_H /6.75,3.80,1.08,3.2882,2.6884 ,3.8436  ,0.,-5.0625,0./
      SAVE
C
      IF (IFIRST.EQ.0) THEN
c  special relations for MORSE-Potential functions:
c                iflag=2, projectile A on target B
c                these parameters P(5), P(6), P(8) are also now
c                read from file AMJUEL rather then initialising them here
c       P_A_B(5)=P(4)*(1.-LOG(2.)/P(2))         (=R0, ROOT OF V)
c       P_A_B(6)=P(4)*(1.+LOG(2.)/P(2)/P(3))    (=RW, INFLECTION OF V)
c       P_A_B(8)=-3.*P(1)/4.                    (=V(RW) )
        IFIRST=1
        DO IRL=1,NRELI
          IFLREL(IRL)=0
          NEMEAN(IRL)=0
          XEMEAN(IRL)=0.D0
        ENDDO
      ENDIF
C
      IF (IFLREL(IREL).EQ.0.AND.NFLAG.NE.2) THEN
        IFLREL(IREL)=-1
C  PREPARE REJECTION SAMPLING OF INCIDENT ION VELOCITY
C  IS CROSS SECTION AVAILABLE?
        IREAC=MODCOL(5,1,IREL)
        IF (IREAC.EQ.0) GOTO 1
C
        elmin=log(0.01)
        elmax=log(1.e3)
        SGEVMX(IREL)=-1.D60
        JJ=1
        do j=1,1000
          elab=elmin+(j-1)/999.*(elmax-elmin)
          IF (LHABER) THEN
            CALL SCATANG (ELAB,-1._DP,ELTHDUM,CTCHDUM,SIGHABER)
            CEL= SIGHABER*AU_TO_CM2
          ELSE
            CEL=CROSS(ELAB,IREAC,IREL,'VELOEL 1')
          END IF
          vrq=exp(elab-defel(IREL))
          vr=sqrt(vrq)
          if (cel*vr.gt.SGEVMX(IREL)) then
            JJ=J
            SGEVMX(IREL)=cel*vr
          endif
        enddo
        CALL LEER(1)
        WRITE (iunout,*) 'FIRST CALL TO VELOEL FOR IREL= ',IREL
        WRITE (iunout,*) 'PREPARE REJECTION TECHNIQUE '
        WRITE (iunout,*) 'SGEVMX IN VELOEL,JJ ',SGEVMX(IREL),JJ
        IF (JJ.NE.1.AND.JJ.NE.1000) IFLREL(IREL)=1
        CALL LEER(1)
      ENDIF
1     CONTINUE
C
      ICOUNT=1
C
C  NEXT: STEP 1
C
      ZARG=ZRG(IPLS,K)
      ZARGX=ZRG(IPLS,K)
      ZARGY=ZRG(IPLS,K)
      ZARGZ=ZRG(IPLS,K)
      IF (NLDRFT) THEN
        IF (INDPRO(4) == 8) THEN
          CALL VECUSR (2,VXDR,VYDR,VZDR,IPLS)
        ELSE
          VXDR=VXIN(IPLS,K)
          VYDR=VYIN(IPLS,K)
          VZDR=VZIN(IPLS,K)
        END IF
      ELSE
        VXDR=0.D0
        VYDR=0.D0
        VZDR=0.D0
      ENDIF
C
      VX=VXO*VLO
      VY=VYO*VLO
      VZ=VZO*VLO
C
123   CONTINUE
      IF (INIV2.LE.0) CALL FGAUSS
C
C  SAMPLE FROM 3D MAXWELLIAN
      VXN=FG1(INIV2)
      VYN=FG2(INIV2)
      VZN=FG3(INIV2)
      INIV2=INIV2-1
C
C  DRIFTING, MONOENERGETIC ISOTROPIC DISTRIBUTION
C
      IF (NFLAG.EQ.1) THEN
C  ZT1 CORRESPONDS TO ROOT MEAN SQUARE VELOCITY AT TIIN(IPLS,K)
        VEL=SQRT(ZT1(IPLS,K))
        VN=VEL/SQRT(VXN*VXN+VYN*VYN+VZN*VZN)
        VXN=VXN*VN+VXDR
        VYN=VYN*VN+VYDR
        VZN=VZN*VN+VZDR
      ELSE
        VXN=VXN*ZARGX+VXDR
        VYN=VYN*ZARGY+VYDR
        VZN=VZN*ZARGZ+VZDR
      ENDIF
C
C  DRIFTING MAXWELLIAN DISTRIBUTION (FOR MAXWELL-POTENTIAL: SIGMA*V = CONST.)
C
      IF (NFLAG.EQ.2) THEN
C
        VXI=VXN
        VYI=VYN
        VZI=VZN
C
      ELSE
C
C   ALL OTHER DISTRIBUTIONS
C
C   WEIGHT CORRECTION DUE TO ENERGY DEPENDENCE IN CROSS SECTION
C   OR: REJECTION     DUE TO ENERGY DEPENDENCE IN CROSS SECTION
C   PRESENT VERSION: REJECTION
        VRELQ=(VXN-VX)**2+(VYN-VY)**2+(VZN-VZ)**2
        VREL=SQRT(VRELQ)
        ELAB=LOG(VRELQ)+DEFEL(IREL)
        IREAC=MODCOL(5,1,IREL)
        CEL=CROSS(ELAB,IREAC,IREL,'VELOEL 2')
C
CH FOR SCATTERING ANGLE FROM DIFFERENTIAL CROSS SECTION:
C
        IF (LHABER) THEN
          RMN=RMASS
          RMI=RMASSP(IPLS)
          RMSI=1./(RMN+RMI)
          RLMS=RMN*RMI*RMSI
          ER=RLMS*VRELQ*CVELI2
          RAN=RANF_EIRENE()
          CALL SCATANG (ER,RAN,ELTHDUM,CTCHDUM,SIGHABER)
          CEL= SIGHABER*AU_TO_CM2
        END IF
CH
C
C       IF (NLREJC) THEN
        IF (IFLREL(IREL).GT.0) THEN
          TEST=RANF_EIRENE()*SGEVMX(IREL)
          IF (TEST.GT.CEL*VREL) THEN
C  REJECT
            ICOUNT=ICOUNT+1
            IF (ICOUNT.LT.500) GOTO 123
            WRITE (iunout,*) 
     .        'ICOUNT TOO LARGE IN VELOEL. ACCEPT SAMPLE '
            WRITE (iunout,*) 'NPANU, IREAC, IREL, ELAB ',
     .                   NPANU, IREAC, IREL, ELAB
          ELSE
C  ACCEPT
            XEMEAN(IREL)=XEMEAN(IREL)+ICOUNT
            NEMEAN(IREL)=NEMEAN(IREL)+1
          ENDIF
C       ELSEIF (NLWEIGHT) THEN
        ELSE
          WEIGHT=WEIGHT*CEL*VREL*DIIN(IPLS,K)/SIGVEL(IREL)
        ENDIF
C
        VXI=VXN
        VYI=VYN
        VZI=VZN
      ENDIF
C
C  STEP 1 FINISHED, COLLIDING BULK ION'S VELOCITY IS SET: VXI,VYI,VZI
C
200   CONTINUE
C
C  FIND TYPE OF COLLISION: IFLAG
C
C  NEUTRAL ATOMS:
C
      IF (ITYP.EQ.1) THEN
C  NEUTRAL-NEUTRAL, IN BGK APPROXIMATION
        IF (NCHRGP(IPLS).EQ.0) THEN
          IFLAG=0
C  NEUTRAL-ION, INTERACTION POTENTIAL GIVEN
        ELSEIF (MODCOL(5,0,IREL).NE.0) THEN
          KK=MODCOL(5,0,IREL)
          IFLAG=IFTFLG(KK,0)
          P(1:9)=REACDAT(KK)%POT%POLY%DBLPOL(1:9,1)
        ELSE
          GOTO 995
        ENDIF
C
C  NEUTRAL MOLECULES:
C
      ELSEIF (ITYP.EQ.2) THEN
C  NEUTRAL-NEUTRAL, BGK APPROXIMATION
        IF (NCHRGP(IPLS).EQ.0) THEN
          IFLAG=0
C  NEUTRAL-ION, INTERACTION POTENTIAL GIVEN
        ELSEIF (MODCOL(5,0,IREL).NE.0) THEN
          KK=MODCOL(5,0,IREL)
          IFLAG=IFTFLG(KK,0)
          P(1:9)=REACDAT(KK)%POT%POLY%DBLPOL(1:9,1)
        ELSE
          GOTO 995
        ENDIF
      ELSE
        GOTO 995
      ENDIF
C
C  NEXT: STEP 2, FIND PRE COLLISION DATA AND TOTAL CROSS SECTION
C
      IF (IFLAG.NE.0) THEN
        RMN=RMASS
        RMI=RMASSP(IPLS)
        RMSI=1./(RMN+RMI)
        RLMS=RMN*RMI*RMSI
C  RELATIV VELOCITY AND RELATED DATA
        VRELX=VX-VXI
        VRELY=VY-VYI
        VRELZ=VZ-VZI
        VRQYZ=         VRELY**2+VRELZ**2
        VRELQ=VRELX**2+VRQYZ
        ER=RLMS*VRELQ*CVELI2
c
        VREL=SQRT(VRELQ)
        VRYZ=SQRT(VRQYZ+EPS60)
C  IMPACT PARAMETER --> SCATTERING ANGLE --> NEW VELOCITY
        IF (.NOT.LHABER) THEN
C  CENTER OF MASS VELOCITY
          VSX=(RMI*VXI+RMN*VX)*RMSI
          VSY=(RMI*VYI+RMN*VY)*RMSI
          VSZ=(RMI*VZI+RMN*VZ)*RMSI
C  TOTAL CROSS SECTION (ONLY IF NOT COMPUTED EARLIER AT THIS CALL)
          IF (NFLAG.NE.3) THEN
            ELAB=LOG(VRELQ)+DEFEL(IREL)
            IREAC=MODCOL(5,1,IREL)
            IF (IREAC.EQ.0) GOTO 995
            CEL=CROSS(ELAB,IREAC,IREL,'VELOEL 3')
          ENDIF
C
C  STEP 2 FINISHED, CROSS SECTION CEL IS FOUND
C  NEXT: STEP 3
C
          BMAX=SQRT(CEL*PIAI)/0.52917E-8
          B= SQRT(RANF_EIRENE( ))*BMAX
C  DIRECT SAMPLING FROM DIFFERENTIAL CROSS SECTION
C       ELSEIF (LHABER) THEN
C  NOTHING TO BE DONE HERE
        END IF
      ENDIF
C
C  STEP 3 FINISHED, IMPACT PARAMETER IS FOUND , IN UNITS: BOHR RADIA
C  NEXT: STEP 4
C
      IF (IFLAG.EQ.0) THEN
C
C  THIS PART: ONLY RELAXATION TO MAXWELLIAN, I.E., POST COLLISION
C             NEUTRAL SAMPLED FROM BULK ION POPULATION (E.G.: BGK-COLLISION)
C
        VELQ=VXI*VXI+VYI*VYI+VZI*VZI
        VEL=SQRT(VELQ)
        VELX=VXI/VEL
        VELY=VYI/VEL
        VELZ=VZI/VEL
C
      ELSE
C
C  THIS PART: FIND DEFLECTION ANGLE
C             BINARY COLLISION KINETICS (IF NOT LHABER) OR
C             SAMPLING FROM DIFFERENTIAL CROSS SECTION (IF LHABER)
C
        IF (LHABER) THEN
          RAN=RANF_EIRENE()
          CALL SCATANG (ER,RAN,ELTHETA,CTTETHA,DUMSIGMA)
          PH=ELTHETA
        ELSE
C
C  COLLISION PARAMETERS IFLAG, ER AND B ARE DEFINED NOW.
C
C  FIND DISTANCE OF CLOSEST APPROACH: RSTERN
C
          RS=RSTERN(ER,B,IFLAG,P)
C
C  INTEGRAL TO FIND DEFLECTION ANGLE CHI
C
          CALL GAUMEH (RS,ER,B,IFLAG,P,10,1,RESULT)
          CHI=PIA-2.*B/RS*RESULT
C
C  CONVERT FROM DEFLECTION ANGLE TO OBSERVABLE SCATTERING ANGLE
          PH=ACOS(COS(CHI))
        END IF
C
C  POLAR ANGLE
        EPS=PI2A*RANF_EIRENE( )
C
C  CONVERT POST COLLISON VELOCITY BACK INTO LAB-FRAME
C
        CPH=COS(PH)
        SPH=SIN(PH)
        CEPS=COS(EPS)
        SEPS=SIN(EPS)
        VRSX=VRELX*CPH+SPH*SEPS*VRYZ
        VRSY=VRELY*CPH+SPH*(VREL*VRELZ*CEPS-VRELX*VRELY*SEPS)/VRYZ
        VRSZ=VRELZ*CPH-SPH*(VREL*VRELY*CEPS+VRELX*VRELZ*SEPS)/VRYZ
C
        VELX=VSX+RLMS/RMN*VRSX
        VELY=VSY+RLMS/RMN*VRSY
        VELZ=VSZ+RLMS/RMN*VRSZ
        VELQ=VELX*VELX+VELY*VELY+VELZ*VELZ
        VEL=SQRT(VELQ)
        VELX=VELX/VEL
        VELY=VELY/VEL
        VELZ=VELZ/VEL
C
      ENDIF
C
C  STEP 4 FINISHED, POST COLLISION VELOCITY IS SET
C  NEXT: RETURN
      RETURN
C
995   CONTINUE
      WRITE (iunout,*) 'ERROR IN VELOEL, NO ELASTIC COLLISION DATA'
      WRITE (iunout,*) 'AVAILABLE '
      WRITE (iunout,*) 'ITYP,IATM,IMOL,IION,IPLS ',
     .                  ITYP,IATM,IMOL,IION,IPLS
      CALL EXIT_OWN(1)
      END
