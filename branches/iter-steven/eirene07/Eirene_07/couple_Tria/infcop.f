C   EIRENE CODE SEGMENT COUPLE_$, $ MAY CURRENTLY STAND FOR B2,
C                                                           B2.5,
C                                                           DIVIMP,
C                                                           TRIA,
C                                                           TETRA,
C                                                           TRANSP,
C                                                           DUMMY
C
C   THIS VERSION: $=Tria,  NOV. 2002
C
c  geometry data not any longer via work array into eirene
c                due to module structure
c  eliminate cut cells from balances (lcut(..))
c  new input: ncopib, ncopeb
C
C   UPDATES:
C   OPTION TO EVALUATE B-FIELD VECTORS FROM GRIDADAP FILE FT29
C   FOR NON-ORTHOGONAL GRIDS
C
C   THIS CODE SEGMENT CONTAINES VARIOUS SUBROUTINES NEEDED FOR
C   INTERFACING THE EIRENE CODE TO PLASMA FLUID CODES.
C   IT READS GEOMETRICAL DATA (MESHES) FROM FILE FT30
C   AND PRODUCES THE EIRENE INPUT DATA (BLOCK 2).
C   IT READS PLASMA BACKGROUND DATA FROM FILE FT31 OR COMMON BLOCKS,
C   IT MAY (OPTIONAL) ALSO READ PLASMA DATA FROM FILE FT13
C   WRITTEN IN A PREVIOUS EIRENE RUN (E.G. IN ORDER TO ITERATE
C   IN SOME BACKGROUND SPECIES)
C   IT THEN PRODUCES INPUT DATA FOR EIRENE
C   INPUT BLOCK 5 (PLASMA DATA) AND BLOCK 7 (SURFACE RECYCLING SOURCES)
C
C
C   THIS PARTICULAR VERSION LINKS EIRENE TO THE B2   2D MULTIFLUID EDGE
C   PLASMA TRANSPORT CODE.
C
C   IT WAS WRITTEN BY D.REITER AND P.BOERNER, KFA-JUELICH
C   E-MAIL: D.REITER @ EIRENE.DE
C
C
C
C   MOST OF THE FORTRAN IN THIS CODE SEGMENT HAS BEEN DEVELOPED
C   UNDER KFA-NET CONTRACT NO. 428/90-8/FU-D
C
C   FINAL REPORT BY: D.REITER(1), P.BOERNER(1), B.KUEPPERS(1),
C                    M.BAELMANS(2) AND G.P.MADDISON(3)
C                    (1992)
C   1): KFA-JUELICH GMBH
C   2): UNIV. LEUVEN, ERM, KFA-JUELICH
C   3): AEA TECHNOLOGY, FUSION, CULHAM, UKAEA FUSION ASSOCIATION
C
*DK COUPLE
C
      SUBROUTINE INFCOP
C
C     THIS SUBROUTINE DEFINES THE PLASMA MODEL IN CASE OF A COUPLED
C     NEUTRAL-PLASMA CALCULATION
C
C     THE ENTRY "IF0COP" RECEIVES GEOMETRICAL INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF1COP" RECEIVES PLASMA INPUT DATA FROM AN
C     EXTERNAL FILE (E.G. OTHER PLASMA CODES)
C     AND PREPARES THEM FOR AN EIRENE RUN
C
C     THE ENTRY "IF2COP" PREPARES THE SOURCE SAMPLING DISTRIBUTION
C     FROM THE EXTERNAL DATA, AND MAY OVERWRITE OTHER INPUT
C     DATA FROM BLOCKS 1 TO 13 AS WELL
C
C     THE ENTRIES "IF3COP, IF4COP" RETURN  RESULTS TO AN EXTERNAL CODE
C
!PB   17.11.05  NEMODS=-2  =>  NEMODS=8
!PB             NEMODS=-3  =>  NEMODS=9
      USE PRECISION
      USE PARMMOD
      USE BRASPOI
      USE COMUSR
      USE CESTIM
      USE COMSOU
      USE CSTEP
      USE COMPRT
      USE CINIT
      USE CGRID
      USE CCONA
      USE CGEOM
      USE CADGEO
      USE CSPEI
      USE CTRCEI
      USE CPLOT
      USE CLOGAU
      USE CTEXT
      USE CLGIN
      USE COUTAU
      USE CPOLYG
      USE CSDVI
      USE CSDVI_BGK
      USE CSDVI_COP
      USE COMXS
      USE CCOUPL
      USE COMNNL
      USE CZT1
      USE CTRIG
      USE BRAEIR
      USE EIRBRA
      USE BRASCL

      IMPLICIT NONE
C
C  GEOMETRICAL DATA FROM GRIDADAP
      REAL(DP), ALLOCATABLE ::
     R  ALPHXB(:,:), ALPHYB(:,:), XAISO(:,:)

      REAL(DP), ALLOCATABLE, SAVE ::
     R  PUX(:),      PUY(:),      PVX(:),      PVY(:)

      INTEGER, ALLOCATABLE ::
     I  IAISO(:,:)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
      REAL(DP) :: SEES0(NSTRA), SEIS0(NSTRA)
      REAL(DP) :: CHPM(NPLS,NRAD), CHEEM(NRAD), CHEIM(NRAD),
     .          CHMOM(NPLS,NRAD)
      REAL(DP) :: DI(NPLS), VP(NPLS)
C
      REAL(DP) :: PUXE(NRAD), PUYE(NRAD), PUXN(NRAD), PUYN(NRAD),
     R          EFLX(NSTRA),
     R          DUMMY(0:NDXP,0:NDYP),
     R          SFNIT(0:NSTEP), SFEIT(0:NSTEP),
     R          SFEET(0:NSTEP), SHEAE(0:NSTEP), SHEAI(0:NSTEP)

      INTEGER :: NRWL(NSTRA)

      REAL(DP), SAVE :: SCALM, SCALE, SCALI, SEES, SEIS, SFEISY, SFEESY,
     .          VPARA, PIADD, RECADD, EEADD, EIADD,
     .          SMOCL, CHEES, CHEIS, SNICL, SIGNUM, FNIYB0, SSE, BALANI,
     .          BALANE, SSEE, SSN, SSI, BALANN, RE, RI, RN, TOTI, TOTE,
     .          TOTN, SFEENY, SFNINY, SFEIWX, TIFLX, PIFLX, SFEINY,
     .          SFEEWX, SFNIEX, SSNI, SSEI, SFNIWX, SFEIEX, SFEEEX,
     .          XCOOR, YCOOR, ZCOOR, VSX, VSY, VS, VTX, VL, BVAC, V, T,
     .          BN, BX, BY, BZ, TX, TY, VPRO, VTY, VT, TEST, XMUE, PX,
     .          PY, ALX, ALN, ALS, AL, ALE, ALW, UUBC, VTEST, VR, CS,
     .          PERW, PARW, PARWI,PERWI, DRR, EADD, TE, CUR,
     .          VPZ, PM1, VPY, PN1, VPX, GAMMA, ESUM, CNDYNP,
     .          CHI, CHP, CHE, SUMEI, SUMEE, SUMM, SUMN, RESSEE,
     .          RESSEI, ETOT, FLXI, FLX, OR, DELY, XANF, YANF, UDBC,
     .          RBC, UPBC, VVBC, DELTI_PARA, DELX, PUYS, RRBS,
     .          EEMAX, EESHT, RP1, THMAX, TIS, TES, DELTE_PERP,
     .          DELTE_PARA, PIPV, PUXS, PNORM, PVXS, PVYS, PUPV,
     .          DELTI_PERP, SFNISY
      INTEGER, SAVE :: NREC11, IRC, JC, K, IADD, NAS, IPUNKT, NSSIR,
     .           NUMSI, NBAR, ISNR, ISC, IS, NASMOD, NRS, NADMOD,
     .           NBARSI, IP1, NP2NDQ, IFL, IS1, IR1, IAIN, IAOT, IREAD,
     .           NTGPRI, IPRT, IO29, NEND, NCOPI, NINI, NSSIP,
     .           LTARG, I,IT, IPL, IERROR, IMODE, NPLP,
     .           NRED, J, IDUMMY, NR1STQ, ISTS, ITRI,
     .           IR, IP, IN, IX, IY, NDX2, NEM, IIRC, NDXY,
     .           IFIRST, IF, ICPV, ISTRAI, NPES, MTRI, NPEC, NPBS,
     .           NPBC, IACT, IANF, IO, IIPLS, IEPLS, IG, ITARG, IGITT,
     .           I34, IRRC, ICOG, ISC1, ISC2, ISCS, ICOU, ISP,
     .           IXI, IXE, NCOPIB, NCOPEB, IPLSTI, IPLSV, IPLV
      INTEGER, INTENT(IN) :: ISTRAA, ISTRAE, NEW_ITER, IFRST, ITRG
      REAL(DP) :: STEP, FTABRC1, FEELRC1, SHEATH, EMAXW
      INTEGER, EXTERNAL :: IDEZ
C
      LOGICAL, INTENT(INOUT) :: LSTP
      LOGICAL :: LSHORT, LSTOP
      LOGICAL, ALLOCATABLE, SAVE :: LCUT(:)
CTRIG A
      TYPE :: CELL
        INTEGER :: TRIANGLE
        TYPE(CELL),POINTER :: NEXT
      END TYPE CELL

      TYPE :: POIFELD
        TYPE (CELL),POINTER :: P
      END TYPE POIFELD

      TYPE (POIFELD), ALLOCATABLE, SAVE :: HEADS(:,:)
      TYPE (CELL),POINTER :: CURPOI
CTRIG E
C
C  READ PLASMA PARAMETERS, RESCALE THEM IF NECESSARY
C  AND TRANSFER THEM TO EIRENE VIA
C  EIRENE FUNCTION "PROFR"  THROUGH EQUIVALENCE ON ARRAY SMESTV
C
      REAL(DP), ALLOCATABLE, SAVE ::
     . CHPS(:),    SNIS(:),    CHMOS(:),  SMOS(:),  SCALN(:),
     . SNIS0(:,:), SMOS0(:,:),
     . RESSNI(:),  RESSMO(:)

      REAL(DP), ALLOCATABLE ::
     . TORL(:,:), ESHT(:,:), ORI(:,:)


      INTEGER, ALLOCATABLE :: IHELP(:)
C
      CHARACTER(10) :: CHR
      CHARACTER(6)  :: CITARG
      CHARACTER(72) :: ZEILE
C
      DATA LTARG/0/
C
CTRIG A
C
!pb      INTEGER, ALLOCATABLE, SAVE :: IXTRI(:), IYTRI(:)
      INTEGER, ALLOCATABLE :: NUMTRI(:), NUMSID(:)
CTRIG E
C
      SAVE
C
      ENTRY IF0COP
C
      LSHORT=.FALSE.
C
      GOTO 99990
C
C  TO INITIALIZE THE SHORT CYCLING, THE GEOMETRY HAS TO BE
C  DEFINED ONCE (ENTRY: INTER0)
C
      ENTRY INTER0
      LSHORT=.TRUE.
99990 CONTINUE
C
      IERROR=0
C
      IMODE=IABS(NMODE)
C
      IF (.NOT.LSHORT.AND.ITIMV.LE.1) THEN
        WRITE (iunout,*) '        SUBROUTINE INFCOP IS CALLED  '
C  READ INPUT DATA OF BLOCK 14
C  SAVE INPUT DATA OF BLOCK 14 FOR SHORT CYCLE ON COMMON CCOUPL
        CALL LEER(1)
        CALL ALLOC_CCOUPL(1)
        READ (IUNIN,'(5L1)') LSYMET,LBALAN
        IF (TRCINT)
     .  WRITE (iunout,*) ' LSYMET,LBALAN = ',LSYMET,LBALAN
        READ (IUNIN,'(3I6)') NFLA,NCUTB,NCUTL
        NCUTB_SAVE=NCUTB
        IF (TRCINT) THEN
          WRITE (iunout,*) ' NFLA,NCUTB,NCUTL = ',NFLA,NCUTB,NCUTL
          WRITE (iunout,*) ' IPLS,IFLB(IPLS),FCTE(IPLS),BMASS(IPLS)'
        ENDIF
        DO 20 IPL=1,NPLSI
          READ (IUNIN,'(2I6,2E12.4)') I,IFLB(IPL),FCTE(IPL),BMASS(IPL)
          IF (TRCINT)
     .    WRITE (iunout,*) IPL,IFLB(IPL),FCTE(IPL),BMASS(IPL)
20      CONTINUE
        READ (IUNIN,'(2I6)') NDXA,NDYA
        IF (TRCINT) WRITE (iunout,*) 'NDXA,NDYA ',NDXA,NDYA
C  NUMBER OF TARGET SOURCES ON B2 SURFACES: NTARGI
        READ (IUNIN,'(I6)') NTARGI
        WRITE (iunout,*) '        NTARGI= ',NTARGI
        CALL LEER(1)
        IF (NTARGI.GT.NSTEP) THEN
          CALL MASPRM ('NSTEP',5,NSTEP,'NTARGI',6,NTARGI,IERROR)
          WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT_OWN(1)
        ENDIF
C  NUMBER OF PARTS PER TARGET SOURCE
        IF (NTARGI.GT.0) READ (IUNIN,'(12I6)') (NTGPRT(IT),IT=1,NTARGI)
        DO 22 IT=1,NTARGI
          IF (NTGPRT(IT).GT.NGITT) THEN
            NTGPRI=NTGPRT(IT)
            CALL MASPRM ('NGITT',5,NGITT,'NTGPRT',6,NTGPRI,IERROR)
            WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
            CALL EXIT_OWN(1)
          ENDIF
22      CONTINUE
C  ALL INDICES: AFTER INDEX MAPPING
C  NDT: INDEX OF X-CELL (EAST OR NORTH SURFACE OF BRAAMS CELL) OF TARGET
C  NINCT: DIRECTION OF OUTER TARGET NORMAL WITH RESPECT TO POSITIVE DIR.
C  NIXY: SOURCE ON Y SURFACE: NIXY=1; SOURCE ON X SURFACE: NIXY=2
C  NTIN,NTEN: SOURCE RANGE FROM GRIDPOINT NTIN TO GRIDPOINT NTEN
        IF (TRCINT)
     .  WRITE (iunout,*) '    IT,  NDT,NINCT, NIXY, NTIN, NTEN',
     .              ',NIFLG, NPTC,NSPZI,NSPZE,NEMOD'
        DO 30 IT=1,NTARGI
          DO 33 IPRT=1,NTGPRT(IT)
331         READ (IUNIN,'(A72)') ZEILE
            IREAD=1
            IF (ZEILE(1:1).EQ.'*') THEN
C             WRITE (iunout,......)
              GOTO 331
            ENDIF
            READ (ZEILE,'(12I6)') I,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                              NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                              NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                              NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                              NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IREAD=0
            NSPZI(IT,IPRT)=MAX0(1,NSPZI(IT,IPRT))
            NSPZE(IT,IPRT)=MIN0(NFLA,NSPZE(IT,IPRT))
            IF (NSPZE(IT,IPRT).LT.NSPZI(IT,IPRT)) THEN
              WRITE (iunout,*) 'WARNING FROM INFCOP: '
              WRITE (iunout,*) 'ITARG,IPRT : ',IT,IPRT
              WRITE (iunout,*) 'NSPZI,NSPZE MODIFIED TO 1,NFLA, RESP.'
              NSPZI(IT,IPRT)=1
              NSPZE(IT,IPRT)=NFLA
            ENDIF
            IF (TRCINT)
     .      WRITE (iunout,'(1X,12I6)') IT,NDT(IT,IPRT),NINCT(IT,IPRT),
     .                               NIXY(IT,IPRT),NTIN(IT,IPRT),
     .                               NTEN(IT,IPRT),NIFLG(IT,IPRT),
     .                               NPTC(IT,IPRT),NSPZI(IT,IPRT),
     .                               NSPZE(IT,IPRT),NEMOD(IT,IPRT)
            IF (NIXY(IT,IPRT).EQ.1) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NR1ST.OR.
     .            NTEN(IT,IPRT).GT.NR1ST) THEN
                WRITE (iunout,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT_OWN(1)
              ENDIF
            ELSEIF (NIXY(IT,IPRT).EQ.2) THEN
              IF (NTIN(IT,IPRT).LE.0.OR.NTIN(IT,IPRT).GE.NP2ND.OR.
     .            NTEN(IT,IPRT).GT.NP2ND) THEN
                WRITE (iunout,*) 'ERROR IN INPUT BLOCK 14, NTIN, NTEN '
                CALL EXIT_OWN(1)
              ENDIF
            ENDIF
33        CONTINUE
          IF (TRCINT) CALL LEER(1)
30      CONTINUE
        READ (IUNIN,'(6E12.4)')  CHGP,CHGEE,CHGEI,CHGMOM
        IF (TRCINT) WRITE (iunout,*) 'CHGP,CHGEE,CHGEI,CHGMOM ',
     .                           CHGP,CHGEE,CHGEI,CHGMOM
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM B2 INTO EIRENE
C  HERE: B2 VOLUME TALLIES
        READ (IUNIN,'(3I6)') NAINB,NCOPIB,NCOPEB
        NAIN = MAX(NAIN,NAINB)
        CALL ALLOC_CCOUPL(2)
        WRITE (iunout,*) '        NAINI = ',NAINB
        IF (TRCINT.AND.NAINB.GT.0)
     .      WRITE (iunout,*) 'I,NAINS(IAIN),NAINT(IAIN)'
        DO 40 IAIN=1,NAINB
          READ (IUNIN,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
          READ (IUNIN,'(A72)') TXTPLS(IAIN,12)
          READ (IUNIN,'(2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          IF (TRCINT) THEN
            WRITE (iunout,'(6I6)') I,NAINS(IAIN),NAINT(IAIN)
            WRITE (iunout,'(1X,A72)') TXTPLS(IAIN,12)
            WRITE (iunout,'(1X,2A24)') TXTPSP(IAIN,12),TXTPUN(IAIN,12)
          ENDIF
40      CONTINUE
C  READ ADDITIONAL DATA TO BE TRANSFERRED FROM EIRENE INTO B2
C  HERE: EIRENE SURFACE TALLIES
        READ (IUNIN,'(I6)') NAOTB
        WRITE (iunout,*) '        NAOTI = ',NAOTB
        IF (NAOTB.GT.NLIMPS) THEN
          CALL MASPRM ('NLIMPS',6,NLIMPS,'NAOTB',5,NAOTB,IERROR)
          WRITE (iunout,*) 'EXIT CALLED FROM SUBR. INFCOP '
          CALL EXIT_OWN(1)
        ENDIF
        IF (TRCINT.AND.NAOTB.GT.0)
     .      WRITE (iunout,*) 'I,NAOTS(IAOT),NAOTT(IAOT)'
        DO 50 IAOT=1,NAOTB
          READ (IUNIN,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          IF (TRCINT) THEN
            WRITE (iunout,'(6I6)') I,NAOTS(IAOT),NAOTT(IAOT)
          ENDIF
50      CONTINUE
      ENDIF
C
C READING BLOCK 14 FROM FORMATTED INPUT FILE (IUNIN) FINISHED
C
C
C  DEFINE ADDITIONAL TALLIES FOR COUPLING (UPDATED IN SUBR. UPTCOP
C                                              AND IN SUBR. COLLIDE)
      NCOPI=0
      IF (NMODE.GT.0) NCOPI=1
      IF (NCOPEB.NE.0) NCOPI=MAX(0,NCOPEB)
      NCPVI=NCOPI*NPLSI
      NCOP = NCOPI


C
C SAVE SOME MORE INPUT DATA FOR SHORT CYCLE ON COMMON CCOUPL
      NDX = NDXA
      NDY = NDYA
      NFL = NFLA
      NDXP = NDX+1
      NDYP = NDY+1
      LNLPLG=NLPLG
      LNLDRF=NLDRFT
      LTRCFL=TRCFLE
      NSTRI=NSTRAI
      DO 60 ISTRA=1,NSTRAI
        LNLVOL(ISTRA)=NLVOL(ISTRA)
60    CONTINUE
      NMODEI=NMODE
      NFILNN=NFILEN
C
      IF (NCPVI.EQ.0) GOTO 70
      DO IPLS=1,NPLSI
        ICPVE(IPLS)=1
        ICPRC(IPLS)=1
        TXTTAL(IPLS,NTALM)=
     .  'ENERGY WEIGHTED CX RATE OF ATOMS WITH IPLS                  '
        TXTSPC(IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(IPLS,NTALM)='AMP                       '
C
        ICPVE(NPLSI+IPLS)=3
        ICPRC(NPLSI+IPLS)=1
        TXTTAL(NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM ATOMS, FOR IPLS             '
        TXTSPC(NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
        ICPVE(2*NPLSI+IPLS)=3
        ICPRC(2*NPLSI+IPLS)=2
        TXTTAL(2*NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM MOLECULES, FOR IPLS         '
        TXTSPC(2*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(2*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
C
        ICPVE(3*NPLSI+IPLS)=3
        ICPRC(3*NPLSI+IPLS)=3
        TXTTAL(3*NPLSI+IPLS,NTALM)=
     .  'PAR. MOM. SOURCE, FROM TEST IONS, FOR IPLS         '
        TXTSPC(3*NPLSI+IPLS,NTALM)=TEXTS(NSPAMI+IPLS)
        TXTUNT(3*NPLSI+IPLS,NTALM)='G*CM/S* AMP * CM**-3       '
      ENDDO
C
70    CONTINUE
C
C
C  TRANSFER GEOMETRY
C
      IF (.NOT.(INDGRD(1).EQ.6.OR.INDGRD(2).EQ.6.OR.INDGRD(3).EQ.6))
     .RETURN
C
      OPEN (UNIT=29,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 29
C
      OPEN (UNIT=30,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 30
C
C  READ IN DATA TO SET UP GEOMETRY FOR NEUTRAL GAS TRANSPORT CODE
C  STATEMENT NUMBER 1000 ---> 1999
C
C  AT PRESENT THE DATA COME FROM THE FILE FT30
C  THIS PART WILL HAVE TO BE MODIFIED AS SOON AS BRAAMS PROVIDES
C  CELL VERTICES AND CUT DESCRIPTION
C
1000  CONTINUE
C
C  ACTUAL MESH SIZE USED IN THIS RUN: FIRST CARD OF GEOMETRY DATA FILE
C
C
      IF (NDYA.NE.NR1ST-1.OR.NDYA.GT.NDY) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (iunout,*) ' NDYA MUST BE = NR1ST-1 AND <= NDY'
        WRITE (iunout,*) ' NDYA,NR1ST-1,NDY = ',NDYA,NR1ST-1,NDY
        CALL EXIT_OWN(1)
      ELSEIF (NDXA.NE.NP2ND-1.OR.NDXA.GT.NDX) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INTFCE '
        WRITE (iunout,*) ' NDXA MUST BE = NP2ND-1 AND <= NDX'
        WRITE (iunout,*) ' NDXA,NP2ND-1,NDX = ',NDXA,NP2ND-1,NDX
        CALL EXIT_OWN(1)
      ENDIF
C
C  EACH FLUXSURFACE IS GIVEN BY A POLYGON OF LENGTH NDXA+1, I.E.
C  WITH NDXA SEGMENTS. THERE ARE NDYA+1 POLYGONS
C  READ IN POLYGONS CELL BY CELL. IX IS INDEX ALONG ONE POLYGON
C                                 IY IS INDEX PERP. TO THE POLYGONS
C
C
C         DIRECTION  OF INCREASING IY ("RADIAL")
C PERP.      ^                 ^ PERP.
C POLYG.NO.IX|      (VV,SY,    | POLYG.NO.IX+1
C            |       FNIY)     |
C            |       ^         |
C            |       |         |
C         X3,Y3      |        X4,Y4
C            ________X__________   -----> ALONG POLYGON NO. (IY+1)
C            |  CELL NO.(IX,IY)|
C            |                 |
C            |       X         X-----> (UU,UP,FNIX,SX)
C            |                 |
C            | (TE,TI,NI,PR,RR,|
C            |  VOL,GX,GY)     |
C            -------------------   -----> ALONG POLYGON NO. (IY)
C         X1,Y1               X2,Y2
C                                         DIRECTION OF INCREASING IX ("POLOIDAL"
C
C
      NPOINT = 0
      IF (.NOT.ALLOCATED(PUX)) THEN
        ALLOCATE (PUX(NRAD))
        ALLOCATE (PUY(NRAD))
        ALLOCATE (PVX(NRAD))
        ALLOCATE (PVY(NRAD))
      END IF
C
      CALL GEOMD (NDXA,NDYA,NPLP,NR1ST,
     .            PUX,PUY,PVX,PVY)
C
      IF (NDXA+1.NE.NRPLG) THEN
        WRITE (iunout,*) 'ERROR IN INFCOP: NRPLG.NE.NDXA+1'
        WRITE (iunout,*) 'NDXA+1,NRPLG ',NDXA+1,NRPLG
        CALL EXIT_OWN(1)
      ENDIF
      IF (NPLP.NE.NPPLG) THEN
        WRITE (iunout,*) 'ERROR IN INFCOP: NPPLG.NE.NPLP'
        WRITE (iunout,*) 'NPLP,NPPLG ',NPLP,NPPLG
        CALL EXIT_OWN(1)
      ENDIF
C
      CALL LEER(1)
      ALLOCATE(LCUT(0:NDXP))
      DO IX=0,NDXP
        LCUT(IX)=.FALSE.
        DO IPRT=1,NPLP-1
          IXI=NPOINT(2,IPRT)
          IXE=NPOINT(1,IPRT+1)
          IF (IX.GE.IXI.AND.IX.LT.IXE) THEN
            LCUT(IX)=.TRUE.
            WRITE (iunout,*) 'POLOIDAL CUT CELL INTRODUCED AT IP= ',IX
          ENDIF
        ENDDO
      ENDDO
      CALL LEER(1)

C  READ ADDITIONAL GEOMETRICAL DATA (MESH DISTORTION, DEAD CELLS)
C  SAME FORMAT AS FORT.31, I.E., INDEX MAPPING MAY BE NECESSARY
      READ (29,'(A)',IOSTAT=IO29) CHR
      IF (IO29.EQ.0) THEN
        REWIND 29
        NRED=(NPPLG-1)*(NCUTL-NCUTB)
        NDX2=NDXA-NRED

        ALLOCATE (ALPHXB(0:NDXP,0:NDYP))
        ALLOCATE (ALPHYB(0:NDXP,0:NDYP))
        ALLOCATE (XAISO(0:NDXP,0:NDYP))
        ALLOCATE (IAISO(0:NDXP,0:NDYP))

        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHXB)
        CALL PLASM (29,NDX2,NDYA,1,NDX,NDY,1,ALPHYB)
        DO IY=NDYA+1,0,-1
          READ (29,'(500I1)') (IAISO(IX,IY),IX=0,NDX2+1)
        ENDDO
C
        IF (NCUTL.EQ.NCUTB) GOTO 1020
C
C CONVERT IAISO TO REAL, FOR INDMAP
        XAISO=IAISO
        CALL INDMAP (XAISO,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
C IAISO BACK TO INTEGER
        IAISO=XAISO
C
        CALL INDMAP (ALPHXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
        CALL INDMAP (ALPHYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .               NPOINT,NPLP)
1020    CONTINUE
C
        DO IY=1,NDYA
          DO IX =1,NDXA
            IN=IY+(IX-1)*NR1ST
            ALE=ALPHXB(IX,IY)
            ALW=ALPHXB(IX-1,IY)
            IF (MAX(ALE,ALW)-MIN(ALE,ALW) > PIA) THEN
              AL=MIN(ALE,ALW)
              ALW=MAX(ALE,ALW)
              ALE=AL+PI2A
            END IF
            ALN=ALPHYB(IX,IY)
            ALS=ALPHYB(IX,IY-1)
            ALX=0.25D0*(ALE+ALW+ALN+ALS)
            PUX(IN)=COS(ALX)
            PUY(IN)=SIN(ALX)
            PUXE(IN)=COS(ALE)
            PUYE(IN)=SIN(ALE)
            PUXN(IN)=COS(ALN)
            PUYN(IN)=SIN(ALN)
            PVX(IN)=-PUY(IN)
            PVY(IN)=PUX(IN)
          END DO
        END DO

        DEALLOCATE (ALPHXB)
        DEALLOCATE (ALPHYB)
C
      ELSE
        CALL LEER(1)
        WRITE (iunout,*) 
     .   ' NO FILE FORT.29 WITH MODIFIED GRID INFO. FOUND '
        WRITE (iunout,*) ' OLD VERSION CALCULATION MAGN. FIELD FROM ',
     .               'GRID IS USED '
        WRITE (iunout,*) ' GRID IS ASSUMED TO BE ORTHOGONAL '
      END IF
C
C  TRANSFER FLAGS
C
      NAINI=NAINB
C
CTRIG A
C  READ DATA FOR TRIANGULAR MESH
C
      OPEN (UNIT=33,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      OPEN (UNIT=34,ACCESS='SEQUENTIAL',FORM='FORMATTED')
C
      READ(33,*) NRKNOT
      WRITE(iunout,*) 'NRKNOT = ',NRKNOT


C
C     READ IN THE NUMBER OF TRIANGLES AND ATTRIBUTES OF THE TRIANGLES
      READ(34,*) NTRII
      WRITE(iunout,*) 'NTRII = ',NTRII

C
C  EACH ELEMENT (TRIANGLE) IS GIVEN BY 3 POINTS
C
C                   3
C                 /   \
C            3  /       \  2
C             /           \
C           /               \
C          1.................2
C                  1
C
C
      READ(33,*) (XTRIAN(I),I=1,NRKNOT)
      READ(33,*) (YTRIAN(I),I=1,NRKNOT)

!      ALLOCATE (IXTRI(NTRII))
!      ALLOCATE (IYTRI(NTRII))
C
      IF (NTRII.GT.NRAD.OR.NTRII.GT.NTRI) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INFUSR '
        WRITE (iunout,*) ' NTRII MUST BE < NRAD AND <= NTRI'
        WRITE (iunout,*) ' NTRII,NRAD,NTRI = ',NTRII,NRAD,NTRI
        CALL EXIT_OWN(1)
      ENDIF
      DO I=1,NTRII
        READ(34,*) J,NECKE(1,J),NECKE(2,J),NECKE(3,J),
     >               NCHBAR(1,J),NSEITE(1,J),IDUMMY,
     >               NCHBAR(2,J),NSEITE(2,J),IDUMMY,
     >               NCHBAR(3,J),NSEITE(3,J),IDUMMY,
C
     >               IXTRI(J),IYTRI(J)
C       WRITE(iunout,*) J,NECKE(1,J),NECKE(2,J),NECKE(3,J),
C    >               NCHBAR(1,J),NSEITE(1,J),
C    >               NCHBAR(2,J),NSEITE(2,J),NCHBAR(3,J),NSEITE(3,J)

C THE SPECIAL SURFACE PROPERTY (IF ANY) IS ON INMTI ARRAY, AND TRANSFERED INTO
C EIRENE VIA COMMON.
      ENDDO

      ALLOCATE (HEADS(N1ST,N2ND))
      DO IR=1,NR1ST
        DO IP=1,NP2ND
          NULLIFY(HEADS(IR,IP)%P)
        ENDDO
      ENDDO

C  FOR ALL QUADRANGLES BUILD LIST OF TRIANGLES BELONGING
C  TO THE QUADRANGLE
      DO ITRI=1,NTRII
        IF (IXTRI(ITRI).GT.0) THEN
          IR=IYTRI(ITRI)
          IP=IXTRI(ITRI)
          ALLOCATE(CURPOI)
          CURPOI%TRIANGLE = ITRI
          CURPOI%NEXT => HEADS(IR,IP)%P
          HEADS(IR,IP)%P => CURPOI
        ENDIF
      ENDDO

      IF (IO29.EQ.0) THEN
        DO ITRI=1,NTRII
          IY=IYTRI(ITRI)
          IX=IXTRI(ITRI)
          IF (IX .GT. 0) THEN
            IN=IY+(IX-1)*NR1STQ
            NSTGRD(ITRI)=ABS(XAISO(IX,IY)-1.)
          ENDIF
        ENDDO
        DEALLOCATE (XAISO)
        DEALLOCATE (IAISO)
      ENDIF
C
C
C  DETERMINE THE ARRAY INMTI FOR ALL NON DEFAULT STD. SURFACES
C  ISTS=INMTI(ISIDE,NRCELL), ISIDE=1, 2, OR 3
C
      ICOG = 0
      DO ISTS=1,NSTSI

C  FIRST: RADIAL SURFACES

        DO IR=1,NR1ST
          IF (IR.EQ.INUMP(ISTS,1)) THEN
            IR1=IR+1
            IF (IR1.GT.NR1ST) IR1=IR-1
            DO IP=IRPTA(ISTS,2),IRPTE(ISTS,2)-1
              IF (IR.LT.NR1ST) THEN
                CURPOI => HEADS(IR,IP)%P
              ELSE
                CURPOI => HEADS(IR1,IP)%P
              ENDIF
              DO WHILE (ASSOCIATED(CURPOI))
                IT=CURPOI%TRIANGLE
                ISC=0
C  COUNT THE NUMBER OF CORNERS ON POLYGON NEXT TO THE TARGET
                DO IS=1,3
                  IF (((XPOL(IR1,IP)-XTRIAN(NECKE(IS,IT)))**2+
     .                 (YPOL(IR1,IP)-YTRIAN(NECKE(IS,IT)))**2) .LT.
     .                  EPS5) THEN
                    ISC=ISC+1
                    ISNR=IS
                  ENDIF
                  IF (((XPOL(IR1,IP+1)-XTRIAN(NECKE(IS,IT)))**2+
     .                 (YPOL(IR1,IP+1)-YTRIAN(NECKE(IS,IT)))**2) .LT.
     .                  EPS5) THEN
                    ISC=ISC+1
                    ISNR=IS
                  ENDIF
                ENDDO
                IF (ISC.EQ.1) THEN
C  ONLY THE CORNER "ISNR" BELONGS TO THE OPPOSITE SIDE OF THE QUADRANGLE
C  THIS MEANS SIDE "NUMSI" OF TRIANGLE "IT" BELONGS TO THE NONDEFAULT
C  STANDARD SURFACE "ISTS"
                  NUMSI=ISNR+1
                  IF (NUMSI.GT.3) NUMSI=1
C
                  ICOG=ICOG+1
                  INSPAT(NUMSI,IT)=ICOG
                  INMTI(NUMSI,IT)=NLIM+ISTS
                  NBAR=NCHBAR(NUMSI,IT)
                  IF (NBAR.GT.0) THEN
                    NBARSI=NSEITE(NUMSI,IT)
                    ICOG=ICOG+1
                    INSPAT(NBARSI,NBAR)=ICOG
                    INMTI(NBARSI,NBAR)=NLIM+ISTS
                  ENDIF
                ENDIF
                CURPOI => CURPOI%NEXT
              ENDDO
            ENDDO
          ENDIF
        ENDDO

C  NEXT: POLOIDAL SURFACES

        DO IP=1,NP2ND
          IF (IP.EQ.INUMP(ISTS,2)) THEN
            IP1=IP+1
            IF (IP1.GT.NP2ND) IP1=IP-1
            DO IR=IRPTA(ISTS,1),IRPTE(ISTS,1)-1
              IF (IP.LT.NP2ND) THEN
                CURPOI => HEADS(IR,IP)%P
              ELSE
                CURPOI => HEADS(IR,IP1)%P
              ENDIF
              DO WHILE (ASSOCIATED(CURPOI))
                IT=CURPOI%TRIANGLE
                ISC=0
C  COUNT THE NUMBER OF CORNERS ON POLYGON NEXT TO THE TARGET
                DO IS=1,3
                  IF (((XPOL(IR,IP1)-XTRIAN(NECKE(IS,IT)))**2+
     .                 (YPOL(IR,IP1)-YTRIAN(NECKE(IS,IT)))**2) .LT.
     .                  EPS5) THEN
                    ISC=ISC+1
                    ISNR=IS
                  ENDIF
                  IF (((XPOL(IR+1,IP1)-XTRIAN(NECKE(IS,IT)))**2+
     .                 (YPOL(IR+1,IP1)-YTRIAN(NECKE(IS,IT)))**2) .LT.
     .                  EPS5) THEN
                    ISC=ISC+1
                    ISNR=IS
                  ENDIF
                ENDDO
                IF (ISC.EQ.1) THEN
C  ONLY THE CORNER "ISNR" BELONGS TO THE OPPOSITE SIDE OF THE QUADRANGLE
C  THIS MEANS SIDE "NUMSI" OF TRIANGLE "IT" BELONGS TO THE NONDEFAULT
C  STANDARD SURFACE "ISTS"
                  NUMSI=ISNR+1
                  IF (NUMSI.GT.3) NUMSI=1
C
                  ICOG=ICOG+1
                  INSPAT(NUMSI,IT)=ICOG
                  INMTI(NUMSI,IT)=NLIM+ISTS
                  NBAR=NCHBAR(NUMSI,IT)
                  IF (NBAR.GT.0) THEN
                    NBARSI=NSEITE(NUMSI,IT)
                    ICOG=ICOG+1
                    INSPAT(NBARSI,NBAR)=ICOG
                    INMTI(NBARSI,NBAR)=NLIM+ISTS
                  ENDIF
                ENDIF
                CURPOI => CURPOI%NEXT
              ENDDO
            ENDDO
          ENDIF
        ENDDO
      ENDDO
C
C  NOW THE ADJUSTMENTS, WHICH ARE AUTOMATICALLY DONE IN GEOUSR OTHERWISE
C  (INPUT BLOCK 15, B2-CODE SPECIFIC)
C
      READ (IUNIN,*)
      READ (IUNIN,'(2I6)') NADMOD,NASMOD

      DO I=1,NADMOD
        READ (IUNIN,'(2I6,3E12.4)') NRS,IPUNKT,XCOOR,YCOOR,ZCOOR

        GOTO (1,2,3,4,5,6),IPUNKT
        WRITE (iunout,*) 'WRONG POINTNUMBER IN INFCOP '
        WRITE (iunout,*) 'INPUT LINE READING'
        WRITE (iunout,'(2I6,1P,3E12.4)') NRS,IPUNKT,XCOOR,YCOOR,ZCOOR
        WRITE (iunout,*) ' IS IGNORED '
        GOTO 10

    1   CONTINUE
        P1(1,NRS)=XCOOR
        P1(2,NRS)=YCOOR
        P1(3,NRS)=ZCOOR
        GOTO 10

    2   CONTINUE
        P2(1,NRS)=XCOOR
        P2(2,NRS)=YCOOR
        P2(3,NRS)=ZCOOR
        GOTO 10

    3   CONTINUE
        P3(1,NRS)=XCOOR
        P3(2,NRS)=YCOOR
        P3(3,NRS)=ZCOOR
        GOTO 10

    4   CONTINUE
        P4(1,NRS)=XCOOR
        P4(2,NRS)=YCOOR
        P4(3,NRS)=ZCOOR
        GOTO 10

    5   CONTINUE
        P5(1,NRS)=XCOOR
        P5(2,NRS)=YCOOR
        P5(3,NRS)=ZCOOR
        GOTO 10

    6   CONTINUE
        P6(1,NRS)=XCOOR
        P6(2,NRS)=YCOOR
        P6(3,NRS)=ZCOOR

   10   CONTINUE
      ENDDO

      DO I=1,NASMOD
        READ (IUNIN,'(5I6)') NAS,IPUNKT,NSSIR,NSSIP
        IF (IPUNKT.EQ.1) THEN
          P1(1,NAS)=XPOL(NSSIR,NSSIP)
          P1(2,NAS)=YPOL(NSSIR,NSSIP)
        ELSEIF (IPUNKT.EQ.2) THEN
          P2(1,NAS)=XPOL(NSSIR,NSSIP)
          P2(2,NAS)=YPOL(NSSIR,NSSIP)
        ELSE
          WRITE (iunout,*) 'WRONG POINTNUMBER IN GEOUSR '
          WRITE (iunout,*) 'INPUT LINE READING'
          WRITE (iunout,'(5I6)') NAS,IPUNKT,NSSIR,NSSIP
          WRITE (iunout,*) ' IS IGNORED '
        ENDIF
      ENDDO
C
C  DETERMINE THE ARRAY INMTI FOR ALL ADDITIONAL SURFACES
C  ISTS=INMTI(ISIDE,NRCELL), ISIDE=1, 2, OR 3
C
      DO I=1,NLIMI
        IF (IGJUM0(I)==0) THEN
C  SURFACE I IS ACTIV
          IF (ILPLG(I).NE.0) THEN
C  SURFACE I IS PART IF A CONTOUR USED FOR THE MESHGENERATOR
            VSX=P2(1,I)-P1(1,I)
            VSY=P2(2,I)-P1(2,I)
            VS=SQRT(VSX**2+VSY**2)+EPS60
C
            DO 1111 IT=1,NTRII
              DO IS=1,3
                IF (IS.EQ.1) THEN
                  VTX=XTRIAN(NECKE(2,IT))-XTRIAN(NECKE(1,IT))
                  VTY=YTRIAN(NECKE(2,IT))-YTRIAN(NECKE(1,IT))
                  ISCS=1
                  ISC1=1
                  ISC2=2
                ELSEIF (IS.EQ.2) THEN
                  VTX=XTRIAN(NECKE(3,IT))-XTRIAN(NECKE(2,IT))
                  VTY=YTRIAN(NECKE(3,IT))-YTRIAN(NECKE(2,IT))
                  ISCS=2
                  ISC1=2
                  ISC2=3
                ELSEIF (IS.EQ.3) THEN
                  VTX=XTRIAN(NECKE(1,IT))-XTRIAN(NECKE(3,IT))
                  VTY=YTRIAN(NECKE(1,IT))-YTRIAN(NECKE(3,IT))
                  ISCS=3
                  ISC1=3
                  ISC2=1
                ENDIF
                VT=SQRT(VTX**2+VTY**2)+EPS60
C
                VPRO=(VSX*VTY-VTX*VSY)/(VT*VS)
                IF (ABS(VPRO).LT.1.E-2) THEN
C  SURFACES ARE PARALLEL,
C  TEST IF ONE POINT OF THE APPROPRIATE TRIANGLE SIDE BELONGS TO
C  THE SURFACE
                  PX=P1(1,I)
                  PY=P1(2,I)
                  ICOU=1
                  ISC=ISC1
1112              TX=XTRIAN(NECKE(ISC,IT))
                  TY=YTRIAN(NECKE(ISC,IT))
                  IF (ABS(VSX).GT.ABS(VSY)) THEN
                    XMUE=(TX-PX)/VSX
                    IF (XMUE.GE.-1.D-5 .AND. XMUE.LE.1.+1.D-5) THEN
                      TEST=(TY-PY-XMUE*VSY)/VS
                      IF (ABS(TEST).LT.1.D-5) THEN
                        IF (ICOU.EQ.2) THEN
C  TAKE CORRESPONDING ADDITIONAL SURFACE "I" OUT
C  AND REPLACE IT BY NON DEFAULT STD. SURFACE
                          IGJUM0(I)=1
                          ICOG=ICOG+1
                          INSPAT(ISCS,IT)=ICOG
                          INMTI(ISCS,IT)=I
                          GOTO 1111
                        ELSE
                          ICOU=2
                          ISC=ISC2
                          GOTO 1112
                        ENDIF
                      ENDIF
                    ENDIF
                  ELSE
                    XMUE=(TY-PY)/VSY
                    IF (XMUE.GE.-1.D-5 .AND. XMUE.LE.1.+1.D-5) THEN
                      TEST=(TX-PX-XMUE*VSX)/VS
                      IF (ABS(TEST).LT.1.D-5) THEN
                        IF (ICOU.EQ.2) THEN
C  TAKE CORRESPONDING ADDITIONAL SURFACE "I" OUT
C  AND REPLACE IT BY NON DEFAULT STD. SURFACE
                          IGJUM0(I)=1
                          ICOG=ICOG+1
                          INSPAT(ISCS,IT)=ICOG
                          INMTI(ISCS,IT)=I
                          GOTO 1111
                        ELSE
                          ICOU=2
                          ISC=ISC2
                          GOTO 1112
                        ENDIF
                      ENDIF
                    ENDIF
                  ENDIF
                ENDIF
              ENDDO
1111        CONTINUE
          ENDIF
        ENDIF
      ENDDO

      DO IT=1,NTRII
        DO IS=1,3
          IF (NCHBAR(IS,IT).EQ.0.AND.INMTI(IS,IT).EQ.0) THEN
            WRITE (iunout,*) ' ERROR IN INFCOP '
            WRITE (iunout,*) ' OPEN SIDE OF TRIANGLE ',IT,' SIDE ',IS
            IS1=IS+1
            IF (IS.EQ.3) IS1=1
            WRITE (iunout,*) ' XTRIAN,YTRIAN ',XTRIAN(NECKE(IS,IT)),
     .                                    YTRIAN(NECKE(IS,IT))
            WRITE (iunout,*) ' XTRIAN,YTRIAN ',XTRIAN(NECKE(IS1,IT)),
     .                                    YTRIAN(NECKE(IS1,IT))
          ENDIF
        ENDDO
      ENDDO
C
      NLPLG=.FALSE.
      NLFEM=.TRUE.
      LEVGEO=4
      NR1STQ=NR1ST
      NP2NDQ=NP2ND
      NR1ST=NTRII+1
      NLPOL=.FALSE.
      NP2ND=1
      NR1TAL=NR1ST
      NP2TAL=NP2ND
      NT3TAL=NT3RD
      NSBOX_TAL=NR1TAL*NP2TAL*NT3TAL*NBMLT+NRADD
      NGITT = COUNT(INMTI(1:3,1:NTRII) .NE. 0)

      CALL LEER(2)
      CALL HEADNG(' CASE REDEFINED IN COUPLE_TRIA: ',32)
      WRITE (iunout,*) 'NLPLG,NLFEM ',NLPLG,NLFEM
      WRITE (iunout,*) 'NLPOL       ',NLPOL
      WRITE (iunout,*) 'NR1ST,NP2ND ',NR1ST,NP2ND
      WRITE (iunout,*) 'NR1TAL,NP2TAL,NSBOX_TAL ',
     .                  NR1TAL,NP2TAL,NSBOX_TAL
      CALL LEER(2)
CTRIG E
      RETURN
C
C   GEOMETRY DEFINITION PART FINISHED
C
      ENTRY IF1COP
C
C   NOW READ THE PLASMA STATE GIVEN BY BRAAMS
C   AT PRESENT THE DATA COME FROM THE FILE FT31
C   FURTHERMORE: SCALING TO EIRENE UNITS AND INDEX MAPPING
C   STATEMENT NO. 2000 ---> 2999
C
C  IN CASE OF "SHORT CYCLE" THE PLASMA STATE IS TRANSFERRED VIA COMMON
C
      LSHORT=.FALSE.
      CALL LEER(1)
      WRITE (iunout,*) 'IF1COP CALLED '
      IF (NLPLAS) WRITE (iunout,*) 'PLASMA DATA EXPECTED ON BRAEIR'
      IF (.NOT.NLPLAS) 
     .  WRITE (iunout,*) 'PLASMA DATA EXPECTED ON FORT.31'
C  SKIP READING PLASMA, IF NLPLAS
      IF (NLPLAS) GOTO 2100
C
      GOTO 99991
C
C  IN CASE OF "SHORT CYCLE" OR TIME DEP. MODE
C  THE PLASMA STATE IS TRANSFERRED VIA COMMON
C  ONLY SCALING TO EIRENE UNITS AND INDEX MAPPING NEEDS TO BE DONE HERE
C
      ENTRY INTER1
      LSHORT=.TRUE.
      GOTO 2100
C
99991 CONTINUE
C
C
C  TRANSFER PROFILES
C
      IF (.NOT.(INDPRO(1).EQ.6.OR.INDPRO(2).EQ.6.OR.INDPRO(3).EQ.6.OR.
     .          INDPRO(4).EQ.6)) RETURN
C
C
      OPEN (UNIT=31,ACCESS='SEQUENTIAL',FORM='FORMATTED')
      REWIND 31
C
      IF (NFLA.GT.NFL) THEN
        WRITE (iunout,*) ' PARAMETER ERROR DETECTED IN INFCOP '
        WRITE (iunout,*) ' NFLA MUST BE <= NFL'
        WRITE (iunout,*) ' NFLA,NFL = ',NFLA,NFL
        CALL EXIT_OWN(1)
      ENDIF

      CALL ALLOC_BRAEIR(NDX,NDY,NFL)
C
C  B2-BRAAMS CODE SPECIFIC BEGIN
      NRED=(NPPLG-1)*(NCUTL-NCUTB)
      NDX2=NDXA-NRED
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,DNIB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UUB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,VVB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TEB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,TIB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,PRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,UPB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,RRB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIXB)
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEIYB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEXB)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,FEEYB)
C
C  OPTIONAL ARRAYS: VOLB, BFELDB,FNIX_YB, FNIY_XB
      VOLB = 0.D0
      BFELDB = 0.D0
      FNIX_YB = 0.D0
      FNIY_XB = 0.D0
C  CELL VOLUMES AS USED IN B2
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,VOLB)
C  MAGNETIC FIELD STRENGTH (TESLA)
      CALL PLASM (31,NDX2,NDYA,1,NDX,NDY,1,BFELDB)
C  X-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A Y-FLUX TOO
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIX_YB)
C  Y-SURFACE MAY BE INCLINED, HENCE: IT MAY RECEIVE A X-FLUX TOO
      CALL PLASM (31,NDX2,NDYA,NFLA,NDX,NDY,NFL,FNIY_XB)
C
2100  CONTINUE
C
C  NO INDEX MAPPING REQUIRED, IF NEW TIMESTEP ON SAME PLASMA
C  BRAEIR NOT MODIFIED SINCE LAST CALL TO IF1COP
      IF (NCUTB_SAVE.EQ.NCUTL) THEN
        WRITE (iunout,*) 'NO INDEX MAPPING DONE'
      ELSE
        WRITE (iunout,*) 'INDEX MAPPING DONE ', NCUTB_SAVE,NCUTB,NCUTL
      ENDIF
      CALL LEER(1)
C
C  INDEX MAPPING : NDY DIRECTION
C
C  INDEX MAPPING : NDX DIRECTION
C  SET THE NUMBER OF COLUMNS PER CUT FROM NCUTB (BRAAMS IMPLEMENTATION)
C  TO WHAT IS FOUND FROM THE EIRENE GEOMETRY FILE (NCUTL)
C
      IF (NCUTL.EQ.NCUTB_SAVE) GOTO 2101
C  FIRST THE ZONE CENTERED DATA
      CALL INDMAP (DNIB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (TEB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (TIB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (RRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
      CALL INDMAP (PRB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,NCUTB,NCUTL,
     .             NPOINT,NPLP)
C  NOW THE SURFACE CENTERED DATA
      CALL INDMAP (FNIXB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIYB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UUB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (VVB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (UPB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEIYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEXB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FEEYB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (VOLB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (BFELDB,DUMMY,NDX,NDY,1,NDXA,NDYA,1,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIX_YB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
      CALL INDMAP (FNIY_XB,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .             NCUTB,NCUTL,NPOINT,NPLP)
C
2101  CONTINUE
C
C  INDICATE, THAT NOW BRAEIR CONTAINS DATA AFTER INDEX-MAPPING
      NCUTB_SAVE=NCUTL
C
C  RESET 2D ARRAYS ONTO 1D EIRENE ARRAYS, RESCALE TO EIRENE UNITS
C  AND CONVERT BRAAMS VECTORS INTO CARTHESIAN EIRENE VECTORS
C
C  UNITS CONVERSION FACTORS
      T=1./ELCHA
      V=1.E2
      VL=1.E6
CTRIG A
C  VACCUM DATA NEEDED FOR REGION OUTSIDE B2-MESH
      TVAC=0.02
      DVAC=1.D2
      VVAC=0.
      BVAC=1.
CTRIG E
      DO 2105 IPLS=1,NPLSI
        D(IPLS)=1.E-6*FCTE(IPLS)
        FL(IPLS)=ELCHA*FCTE(IPLS)
2105  CONTINUE
C
      BZINTF = 1._DP
      DO ITRI=1,NTRII
        IY=IYTRI(ITRI)
        IX=IXTRI(ITRI)
        IF (IX .GT. 0) THEN
          IN=IY+(IX-1)*NR1STQ
          TEINTF(ITRI)=TEB(IX,IY)*T
C
C  ONLY ONE ION TEMPERATURE AVAILABLE FROM PLASMA FLUID CODE,
C  SEE LOOP 2150 BELOW
          TIINTF(1,ITRI)=TIB(IX,IY)*T
C
          BX=PUX(IN)*RRB(IX,IY)+PVX(IN)*0.
          BY=PUY(IN)*RRB(IX,IY)+PVY(IN)*0.
          BZ=SQRT(1.-RRB(IX,IY)**2)
          BN=SQRT(BX*BX+BY*BY+BZ*BZ)
          BXINTF(ITRI)=BX/BN
          BYINTF(ITRI)=BY/BN
          BZINTF(ITRI)=BZ/BN
          VLINTF(ITRI)=VOLB(IX,IY)*VL
        ELSE
          TEINTF(ITRI)=TVAC
          TIINTF(1,ITRI)=TVAC
          BXINTF(ITRI)=0.
          BYINTF(ITRI)=0.
          BZINTF(ITRI)=1.
C         VLINTF(ITRI)=1.
        ENDIF
      ENDDO
C
C  SET SAME ION TEMPERATURE FOR ALL EIRENE BACKGROUND SPECIES
C

      DO 2150 IPLS=1,NPLSTI
      DO 2150 ITRI=1,NTRII
        TIINTF(IPLS,ITRI)=TIINTF(1,ITRI)
2150  CONTINUE
C
      IREAD=0
      DO 2200 IPLS=1,NPLSI
        IF (IFLB(IPLS).GT.0) THEN
          IPLSV=MPLSV(IPLS)
          DO 2201 IFL=1,NFLA
            IF (IFLB(IPLS).NE.IFL) GOTO 2201
            DO ITRI=1,NTRII
              IY=IYTRI(ITRI)
              IX=IXTRI(ITRI)
              IF (IX .GT. 0) THEN
                IN=IY+(IX-1)*NR1STQ
                DIINTF(IPLS,ITRI)=DNIB(IX,IY,IFL)*D(IPLS)
                UUBC=0.5*(UUB(IX-1,IY,IFL)+UUB(IX,IY,IFL))
                UPBC=0.5*(UPB(IX-1,IY,IFL)+UPB(IX,IY,IFL))
                VVBC=0.5*(VVB(IX,IY-1,IFL)+VVB(IX,IY,IFL))
C  UDBC: DIAMAGNETIC VELOCITY, SHOULD BE ZERO IN B2, AND NONZERO IN EB2
C        NOTE: IN LINEAR DEVICES: RRB=1
                IF (RRB(IX,IY).LT.1.D0) THEN
                  RBC=SQRT(1.-RRB(IX,IY)**2)
                  UDBC=1./RBC*(UUBC-RRB(IX,IY)*UPBC)
                ELSE
                  RBC=0.
                  UDBC=0.
                ENDIF
                VXINTF(IPLSV,ITRI)=(PUX(IN)*UUBC+PVX(IN)*VVBC)*V
                VYINTF(IPLSV,ITRI)=(PUY(IN)*UUBC+PVY(IN)*VVBC)*V
                VZINTF(IPLSV,ITRI)=(RBC*UPBC-RRB(IX,IY)*UDBC)*V
              ELSE
                DIINTF(IPLS,ITRI)=DVAC
                VXINTF(IPLSV,ITRI)=VVAC
                VYINTF(IPLSV,ITRI)=VVAC
                VZINTF(IPLSV,ITRI)=VVAC
              ENDIF
            ENDDO
C  EIRENE BACKGROUND SPECIES "IPLS" FILLED WITH B2 DATA "IFL"
2201      CONTINUE
C  NO DATA FOR "IPLS" IN B2 FILES
        ELSEIF (IFLB(IPLS).EQ.-13) THEN
C  READ DATA FOR "IPLS" FROM EIRENE DUMP FILE FT13
          IF (IREAD.EQ.0) THEN
            OPEN (UNIT=13,ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
            REWIND 13
            READ (13,IOSTAT=IO) TEIN,TIIN,DEIN,DIIN,VXIN,VYIN,VZIN
            IREAD=1
            IF (TRCFLE) WRITE (iunout,*) 'READ 13: RCMUSR, IO= ',IO
            CLOSE (UNIT=13)
          ENDIF
          IF (IO.EQ.0) THEN
            IPLSTI = MPLSTI(IPLS)
            IPLSV = MPLSV(IPLS)
            DO ITRI=1,NTRII
              DIINTF(IPLS,ITRI)=DIIN(IPLS,ITRI)
              VXINTF(IPLSV,ITRI)=VXIN(IPLSV,ITRI)
              VYINTF(IPLSV,ITRI)=VYIN(IPLSV,ITRI)
              VZINTF(IPLSV,ITRI)=VZIN(IPLSV,ITRI)
              TIINTF(IPLSTI,ITRI)=TIIN(IPLSTI,ITRI)
            ENDDO
          ENDIF
        ELSE
C  SET PARAMETERS FOR SPECIES IPLS TO ZERO
C  NOTHING TO BE DONE HERE
        ENDIF
2200  CONTINUE
C  B2-BRAAMS CODE SPECIFIC END
C
C
C  READ OTHER B2 ARRAYS INTO EIRENE, FOR PRINTOUT AND PLOTTING
C
      DO 2300 IAIN=1,NAINB
        IF (NAINT(IAIN).EQ.1.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2321 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=DNIB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2321      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.2.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2322 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=UUB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2322      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.3.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2323 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=VVB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2323      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.6) THEN
          DO 2326 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=PRB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2326      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.7.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2327 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=UPB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2327      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.8) THEN
          DO 2328 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=RRB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2328      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.9.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2329 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FNIXB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2329      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.10.AND.NAINS(IAIN).GT.0.AND.
     .      NAINS(IAIN).LE.NFLA) THEN
          DO 2330 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FNIYB(IXTRI(IN),IYTRI(IN),NAINS(IAIN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2330      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.11) THEN
          DO 2331 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FEIXB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2331      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.12) THEN
          DO 2332 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FEIYB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2332      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.13) THEN
          DO 2333 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FEEXB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2333      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.14) THEN
          DO 2334 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=FEEYB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2334      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.15) THEN
          DO 2335 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=VOLB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2335      CONTINUE
        ELSEIF (NAINT(IAIN).EQ.16) THEN
          DO 2336 IN=1,NTRII
            IF (IXTRI(IN).GT.0) THEN
              ADINTF(IAIN,IN)=BFELDB(IXTRI(IN),IYTRI(IN))
            ELSE
              ADINTF(IAIN,IN)=0.
            ENDIF
2336      CONTINUE
        ENDIF
2300  CONTINUE
C
      RETURN
C
2999  CONTINUE
C
C  PLASMA PROFILES ARE NOW READ IN
C
      ENTRY IF2COP(ITRG)
      ITARG=ITRG
      IF (ITARG.GT.NTARGI) THEN
        CALL LEER(1)
        WRITE (iunout,*) 'SOURCE DATA FOR STRATUM ISTRA= ',ITARG
        WRITE (iunout,*) 
     .    'CANNOT BE DEFINED IN IF2COP. CHANGE INDSRC(ISTRA)'
        CALL LEER(1)
        RETURN
      ENDIF
C
C  NEXT DEFINE FLUXES, TEMPERATURES AND VELOCITIES AT THE TARGETS
C  (FLUXES IN AMP/(CM ALONG TARGET), TEMPERATURES IN EV, VELOCITIES IN CM/SEC)
C   FNIXB*FL (FNIYB*FL) ARE GIVEN IN AMP
C  STATEMENT NO 3000 ---> 3999
C
3000  CONTINUE
C
      IF (TRCINT.AND.LTARG.EQ.0) THEN
        LTARG=1
        WRITE (iunout,*) 'ITARG: TARGET NUMBER '
        WRITE (iunout,*) 'IPRT : SUBSECTION OF TARGET '
        WRITE (iunout,*) 
     .    'NPBS : BRAAMS (SURFACE) X-CELL INDEX OF TARGET '
        WRITE (iunout,*) 'NPBC : BRAAMS (ZONE) P-CELL INDEX OF TARGET '
        WRITE (iunout,*) 'NPES : POLOIDAL SURFACE INDEX OF TARGET'
        WRITE (iunout,*) '       IN EIRENE MESH'
        WRITE (iunout,*) 'NPEC : 1ST POLOIDAL CELL INDEX OF EIRENE MESH'
        WRITE (iunout,*) '       SEEN BY MONTE CARLO HISTORIES'
      ENDIF
C
      DO 3005 IPLS=1,NPLSI
      DO 3005 IGITT=1,NGITT
        FLSTEP(IPLS,ITARG,IGITT)=0.
3005  CONTINUE
C
      ALLOCATE (NUMSID(NGITT))
      ALLOCATE (NUMTRI(NGITT))
      ALLOCATE (TORL(NSTRA,NGITT))
      ALLOCATE (ESHT(NSTEP,NGITT))
      ALLOCATE (ORI(NSTEP,NGITT))

      RRSTEP(ITARG,1)=0.
      IG=0
      IIPLS=NPLSI
      IEPLS=1
      DO 3040 IPRT=1,NTGPRT(ITARG)
C  NINCT= 1: PLASMA FLUX IN SAME   DIRECTION AS B2 CO-ORDINATE
C  NINCT=-1: PLASMA FLUX IN OPPOS. DIRECTION AS B2 CO-ORDINATE
C  BRAAMS X-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (SURFACE CENTERED, EAST OR NORTH) (AFTER INDEX MAPPING)
C  (E.G. SURFACE NO.0 AND SURFACE NO. NX) AT TARGETS.
        NPBS=NDT(ITARG,IPRT)
C  BRAAMS P-CELL CONTAINING THE TARGET DATA (BOUNDARY CONDITIONS)
C  (ZONE CENTERED) (AFTER INDEX MAPPING)
C
C  THIS LINE, IF B2-BOUNDARY CONDITIONS ARE COMPUTED FROM GUARD CELLS
C  (E.G. CELL NO.0 AND CELL NO. NX+1) AT TARGETS.
        NPBC=NPBS+MAX0(0,NINCT(ITARG,IPRT))
C
C  1ST EIRENE CELL ALONG TARGET
        NPEC=NPBS-MIN0(0,NINCT(ITARG,IPRT))
C  EIRENE SURFACE NUMBER AT TARGET
        NPES=NPBS+1
        IF (TRCINT) THEN
          WRITE (iunout,*) 'ITARG,IPRT,NPBS,NPBC,NPES,NPEC ',
     .                 ITARG,IPRT,NPBS,NPBC,NPES,NPEC
        ENDIF
C
C  FIRST: SOURCES AT POLOIDAL (Y) SURFACES (EAST OR WEST CELL FACES)
        IF (NIXY(ITARG,IPRT).EQ.2) GOTO 3020
C
        ITRI=0
        DO IY=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          CURPOI => HEADS(IY,NPEC)%P
          DO WHILE (ASSOCIATED(CURPOI))
            IT=CURPOI%TRIANGLE
C  TEST WHETHER TRIANGLE BELONGS TO QUADRANGULAR CELLS ALONG THE TARGET
            IF (IXTRI(IT).EQ.NPEC .AND.
     .         (IYTRI(IT).GE.NTIN(ITARG,IPRT) .AND.
     .          IYTRI(IT).LT.NTEN(ITARG,IPRT))) THEN
              ISC=0
C  COUNT THE NUMBER OF CORNERS ON POLYGON NEXT TO THE TARGET
              DO IS=1,3
                IF (((XPOL(IYTRI(IT),IXTRI(IT)-
     .                MIN(0,NINCT(ITARG,IPRT)))-XTRIAN(NECKE(IS,IT)))**2
     .               +(YPOL(IYTRI(IT),IXTRI(IT)-
     .                MIN(0,NINCT(ITARG,IPRT)))-
     .                YTRIAN(NECKE(IS,IT)))**2) .LT. EPS5) THEN
                  ISC=ISC+1
                  ISNR=IS
                ENDIF
                IF (((XPOL(IYTRI(IT)+1,IXTRI(IT)-
     .                MIN(0,NINCT(ITARG,IPRT)))-XTRIAN(NECKE(IS,IT)))**2
     .               +(YPOL(IYTRI(IT)+1,IXTRI(IT)-
     .                MIN(0,NINCT(ITARG,IPRT)))-
     .                YTRIAN(NECKE(IS,IT)))**2) .LT. EPS5) THEN
                  ISC=ISC+1
                  ISNR=IS
                ENDIF
              ENDDO
              IF (ISC.EQ.1) THEN
C  ONLY ONE CORNER BELONGS TO THE OPPOSITE SIDE OF THE QUADRANGLE
C  THIS MEANS ONE SIDE OF TRIANGLE BELONGS TO TARGET
                ITRI=ITRI+1
                IF (ITRI.GT.NGITT) THEN
                  WRITE (iunout,*) 
     .              ' NOT ENOUGH GRIDPOINTS FOR DEFINING',
     .              ' STEP-FUNCTION '
                  WRITE (iunout,*) ' INCREASE PARAMETER NGITT '
                  WRITE (iunout,*) ' NGITT = ',NGITT
                  CALL EXIT_OWN(1)
                ENDIF
                NUMTRI(ITRI)=IT
                IF (ISNR.EQ.1) THEN
                  NUMSID(ITRI)=2
                ELSEIF (ISNR.EQ.2) THEN
                  NUMSID(ITRI)=3
                ELSEIF (ISNR.EQ.3) THEN
                  NUMSID(ITRI)=1
                ENDIF
              ENDIF
            ENDIF
            CURPOI => CURPOI%NEXT
          ENDDO
        ENDDO
        MTRI=ITRI
C SORT TRIANGLES ALONG TARGET
         XANF=XPOL(NTIN(ITARG,IPRT),NPES)
         YANF=YPOL(NTIN(ITARG,IPRT),NPES)
         IANF=1
         IACT=1
         DO WHILE (IANF .LT. MTRI)
           DO IT=IANF,MTRI
             ITRI=NUMTRI(IT)
             IS=NUMSID(IT)
             IS1=IS+1
             IF (IS1.GT.3) IS1=1
             IF (((XANF-XTRIAN(NECKE(IS,ITRI)))**2+
     .           (YANF-YTRIAN(NECKE(IS,ITRI)))**2). LT. EPS5) THEN
              NUMTRI(IT)=NUMTRI(IACT)
              NUMSID(IT)=NUMSID(IACT)
              NUMTRI(IACT)=ITRI
              NUMSID(IACT)=IS
              IACT=IACT+1
              XANF=XTRIAN(NECKE(IS1,ITRI))
              YANF=YTRIAN(NECKE(IS1,ITRI))
            ELSEIF (((XANF-XTRIAN(NECKE(IS1,ITRI)))**2+
     .               (YANF-YTRIAN(NECKE(IS1,ITRI)))**2).LT.EPS5) THEN
              NUMTRI(IT)=NUMTRI(IACT)
              NUMSID(IT)=NUMSID(IACT)
              NUMTRI(IACT)=ITRI
              NUMSID(IACT)=IS
              IACT=IACT+1
              XANF=XTRIAN(NECKE(IS,ITRI))
              YANF=YTRIAN(NECKE(IS,ITRI))
            ENDIF
          ENDDO
          IANF=IACT
        ENDDO
C
        DO IT=1,MTRI
          ITRI=NUMTRI(IT)
          IS=NUMSID(IT)
          IS1=IS+1
          IF (IS1.GT.3) IS1=1
          IX=IXTRI(ITRI)
          IY=IYTRI(ITRI)
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(NPBC,IY)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  RRSTEP IS THE ARC LENGTH ALONG THE TARGET (CM)
          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .        SQRT((XTRIAN(NECKE(IS,ITRI))-XTRIAN(NECKE(IS1,ITRI)))**2+
     .             (YTRIAN(NECKE(IS,ITRI))-YTRIAN(NECKE(IS1,ITRI)))**2)
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
          IRSTEP(ITARG,IG)=ITRI
          IPSTEP(ITARG,IG)=IS
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=200000+IS
          IF (INMTI(IS,ITRI).EQ.0) THEN
            WRITE (iunout,*) 'ERROR IN INFCOP '
            WRITE (iunout,*) 'SOURCE NOT ON A KNOWN SURFACE'
            WRITE (iunout,*) 'ITARG,IG,IPRT ',ITARG,IG,IPRT
          ENDIF
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
          TORL(ITARG,IG)=2.*PIA*0.5*(XTRIAN(NECKE(IS,ITRI))+
     .                               XTRIAN(NECKE(IS1,ITRI)))
          DO 3013 IPLS=1,NPLSI
            IPLSTI=MPLSTI(IPLS)
            IPLSV=MPLSV(IPLS)
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLS,ITARG,IG) = TIB(NPBC,IY)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3013
            DISTEP(IPLS,ITARG,IG)=DNIB(NPBC,IY,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELY=SQRT((XPOL(IY+1,NPES)-XPOL(IY,NPES))**2+
     .                  (YPOL(IY+1,NPES)-YPOL(IY,NPES))**2)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELY.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                                FNIXB(NPBS,IY,IFL))*FL(IPLS)/DELY
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
C  USE SIGN FROM "MAIN" CONTRIBUTION TO DECIDE ORIENTATION OF SEC. CONTR.
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIX_YB(NPBS,IY,IFL))*
     .                   FL(IPLS)/DELY
                ENDIF
C  SET ION ENERGY FLUXES FROM B2-BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLSTI,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG)+
     .                                  FL(IPLS)/DELY*
     .            (TIS*delti_perp*ABS(Fnix_yb(npbs,iy,ifl))+
     .             TIS*delti_para*ABS(fnixb  (npbs,iy,ifl))+
     .             TES*delte_para*ABS(fnixb  (npbs,iy,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PV VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        DATA FOR POLOIDAL POLYGON NPES
            IN=IY+(NPEC-1)*NR1STQ
            PVXS=XPOL(IY+1,NPES)-XPOL(IY,NPES)
            PVYS=YPOL(IY+1,NPES)-YPOL(IY,NPES)
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
C  ORTHONORMALIZE PU VECTOR WITH RESPECT TO PV
            PUPV=PUX(IN)*PVXS+PUY(IN)*PVYS
            PUXS=PUX(IN)-PUPV*PVXS
            PUYS=PUY(IN)-PUPV*PVYS
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
            VXSTEP(IPLSV,ITARG,IG)=
     .            (PUXS*UUB(NPBS,IY,IFL)+PVXS*VVB(NPBS,IY,IFL))*V
            VYSTEP(IPLSV,ITARG,IG)=
     .            (PUYS*UUB(NPBS,IY,IFL)+PVYS*VVB(NPBS,IY,IFL))*V
            RRBS=UUB(NPBS,IY,IFL)/(UPB(NPBS,IY,IFL)+EPS60)
            VZSTEP(IPLSV,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(NPBS,IY,IFL))*V
3013      CONTINUE
        ENDDO
C
        GOTO 3030
C
3020    CONTINUE
C
C  SECOND: SOURCES AT RADIAL (X) SURFACES
C
        ITRI=0
        DO IX=NTIN(ITARG,IPRT),NTEN(ITARG,IPRT)-1
          CURPOI => HEADS(NPEC,IX)%P
          DO WHILE (ASSOCIATED(CURPOI))
            IT=CURPOI%TRIANGLE
C  TEST WHETHER TRIANGLE BELONGS TO QUADRANGULAR CELLS ALONG THE TARGET
            IF (IYTRI(IT).EQ.NPEC .AND.
     .         (IXTRI(IT).GE.NTIN(ITARG,IPRT) .AND.
     .          IXTRI(IT).LT.NTEN(ITARG,IPRT))) THEN
              ISC=0
C  COUNT THE NUMBER OF CORNERS ON POLYGON NEXT TO THE TARGET
              DO IS=1,3
                IF (((XPOL(IYTRI(IT)-MIN(0,NINCT(ITARG,IPRT)),
     .                IXTRI(IT))-XTRIAN(NECKE(IS,IT)))**2+
     .               (YPOL(IYTRI(IT)-MIN(0,NINCT(ITARG,IPRT)),
     .                IXTRI(IT))-YTRIAN(NECKE(IS,IT)))**2).LT.EPS5) THEN
                  ISC=ISC+1
                  ISNR=IS
                ENDIF
                IF (((XPOL(IYTRI(IT)-MIN(0,NINCT(ITARG,IPRT)),
     .                IXTRI(IT)+1)-XTRIAN(NECKE(IS,IT)))**2+
     .               (YPOL(IYTRI(IT)-MIN(0,NINCT(ITARG,IPRT)),
     .                IXTRI(IT)+1)-YTRIAN(NECKE(IS,IT)))**2).LT.EPS5)
     .          THEN
                  ISC=ISC+1
                  ISNR=IS
                ENDIF
              ENDDO
              IF (ISC.EQ.1) THEN
C  ONLY ONE CORNER BELONGS TO THE OPPOSITE SIDE OF THE QUADRANGLE
C  THIS MEANS ONE SIDE OF TRIANGLE BELONGS TO TARGET
                ITRI=ITRI+1
                NUMTRI(ITRI)=IT
                IF (ISNR.EQ.1) THEN
                  NUMSID(ITRI)=2
                ELSEIF (ISNR.EQ.2) THEN
                  NUMSID(ITRI)=3
                ELSEIF (ISNR.EQ.3) THEN
                  NUMSID(ITRI)=1
                ENDIF
              ENDIF
            ENDIF
            CURPOI => CURPOI%NEXT
          ENDDO
        ENDDO
        MTRI=ITRI
C SORT TRIANGLES ALONG TARGET
        XANF=XPOL(NPES,NTIN(ITARG,IPRT))
        YANF=YPOL(NPES,NTIN(ITARG,IPRT))
        IANF=1
        IACT=1
        DO WHILE (IANF .LT. MTRI)
          DO IT=IANF,MTRI
            ITRI=NUMTRI(IT)
            IS=NUMSID(IT)
            IS1=IS+1
            IF (IS1.GT.3) IS1=1
            IF (((XANF-XTRIAN(NECKE(IS,ITRI)))**2+
     .           (YANF-YTRIAN(NECKE(IS,ITRI)))**2). LT. EPS5) THEN
              NUMTRI(IT)=NUMTRI(IACT)
              NUMSID(IT)=NUMSID(IACT)
              NUMTRI(IACT)=ITRI
              NUMSID(IACT)=IS
              IACT=IACT+1
              XANF=XTRIAN(NECKE(IS1,ITRI))
              YANF=YTRIAN(NECKE(IS1,ITRI))
            ELSEIF (((XANF-XTRIAN(NECKE(IS1,ITRI)))**2+
     .               (YANF-YTRIAN(NECKE(IS1,ITRI)))**2).LT.EPS5) THEN
              NUMTRI(IT)=NUMTRI(IACT)
              NUMSID(IT)=NUMSID(IACT)
              NUMTRI(IACT)=ITRI
              NUMSID(IACT)=IS
              IACT=IACT+1
              XANF=XTRIAN(NECKE(IS,ITRI))
              YANF=YTRIAN(NECKE(IS,ITRI))
            ENDIF
          ENDDO
          IANF=IACT
        ENDDO
C
        DO IT=1,MTRI
          ITRI=NUMTRI(IT)
          IS=NUMSID(IT)
          IS1=IS+1
          IF (IS1.GT.3) IS1=1
          IX=IXTRI(ITRI)
          IY=IYTRI(ITRI)
          IG=IG+1
          IF (IG.GT.NGITT) GOTO 999
C  TESTEP, TISTEP: ZONE CENTERED TEMPERATURE IN BOUNDARY ZONE (EV)
          ORI(ITARG,IG) = NINCT(ITARG,IPRT)
          TESTEP(ITARG,IG) = TEB(IX,NPBC)*T
C  RRSTEP,IRSTEP,IPSTEP: GEOMETRICAL INFORMATION ALONG TARGET
C  EIRENE CELL NUMBER INFORMATION ALONG TARGET
          RRSTEP(ITARG,IG+1)=RRSTEP(ITARG,IG) +
     .       SQRT((XTRIAN(NECKE(IS,ITRI))-XTRIAN(NECKE(IS1,ITRI)))**2+
     .            (YTRIAN(NECKE(IS,ITRI))-YTRIAN(NECKE(IS1,ITRI)))**2)
          IRSTEP(ITARG,IG)=ITRI
          IPSTEP(ITARG,IG)=IS
          ITSTEP(ITARG,IG)=1
          IASTEP(ITARG,IG)=0
          IBSTEP(ITARG,IG)=1
          IGSTEP(ITARG,IG)=100000+IS
          IF (INMTI(IS,ITRI).EQ.0) THEN
            WRITE (iunout,*) 'ERROR IN INFCOP '
            WRITE (iunout,*) 'SOURCE NOT ON A KNOWN SURFACE'
            WRITE (iunout,*) 'ITARG,IG,IPRT ',ITARG,IG,IPRT
          ENDIF
C  TORL: TOROIDAL LENGTH (CM) AT TARGET SEGMENT IY: CENTER OF GRAVITY
          TORL(ITARG,IG)=2.*PIA*0.5*(XTRIAN(NECKE(IS,ITRI))+
     .                               XTRIAN(NECKE(IS1,ITRI)))
          DO 3023 IPLS=1,NPLSI
            IPLSTI=MPLSTI(IPLS)
            IPLSV=MPLSV(IPLS)
            ELSTEP(IPLS,ITARG,IG)=0.
            TISTEP(IPLSTI,ITARG,IG) = TIB(IX,NPBC)*T
C  DISTEP: ZONE CENTERED DENSITY IN BOUNDARY ZONE (EV)
            IFL=IFLB(IPLS)
            IF (IFL.LE.0.OR.IFL.GT.NFLA) GOTO 3023
            DISTEP(IPLS,ITARG,IG)=DNIB(IX,NPBC,IFL)*D(IPLS)
C  FLSTEP: SURFACE CENTERED FLUX (AMP/CM ALONG TARGET)
            IF (NSPZI(ITARG,IPRT).LE.IFL.AND.
     .                               IFL.LE.NSPZE(ITARG,IPRT)) THEN
              IIPLS=MIN0(IIPLS,IPLS)
              IEPLS=MAX0(IEPLS,IPLS)
              DELX=SQRT((XPOL(NPES,IX+1)-XPOL(NPES,IX))**2+
     .                  (YPOL(NPES,IX+1)-YPOL(NPES,IX))**2)
              FLSTEP(IPLS,ITARG,IG)=0.
              IF (DELX.GT.0.) THEN
                FLSTEP(IPLS,ITARG,IG)=MAX(0._DP,ORI(ITARG,IG)*
     .                            FNIYB(IX,NPBS,IFL))*FL(IPLS)/DELX
C  CORRECT FOR INCLINED TARGETS: ADD FLUXES FROM SECOND DIRECTION
                IF (FLSTEP(IPLS,ITARG,IG).GT.0.) THEN
                  FLSTEP(IPLS,ITARG,IG)=
     .            FLSTEP(IPLS,ITARG,IG)+ABS(FNIY_XB(IX,NPBS,IFL))*
     .                   FL(IPLS)/DELX
                ENDIF
C  SET ION ENERGY FLUXES FROM B2 BOUNDARY CONDITIONS
                delti_para=3
                delte_para=0.5
                delti_perp=2
                delte_perp=0
                tis=TISTEP(IPLSTI,ITARG,IG)
                tes=TESTEP(ITARG,IG)
                ELSTEP(IPLS,ITARG,IG) = ELSTEP(IPLS,ITARG,IG) +
     .                                  FL(IPLS)/DELX*
     .            (TIS*delti_perp*ABS(Fniyb  (ix,npbs,ifl))+
     .             TIS*delti_para*ABS(fniy_xb(ix,npbs,ifl))+
     .             TES*delte_para*ABS(fniy_xb(ix,npbs,ifl)))
              ENDIF
            ENDIF
C  VXSTEP,VYSTEP,VZSTEP: SURFACE CENTERED FLOW VELOCITY (CM/S)
C  NOTE: PU VECTOR IS CELL CENTERED, BUT EXACT VECTOR CAN BE FOUND FROM
C        RADIAL POLYGON NPES DATA
            IN=NPEC+(IX-1)*NR1STQ
            PUXS=XPOL(NPES,IX+1)-XPOL(NPES,IX)
            PUYS=YPOL(NPES,IX+1)-YPOL(NPES,IX)
            PNORM=SQRT(PUXS**2+PUYS**2)
            PUXS=PUXS/(PNORM+EPS60)
            PUYS=PUYS/(PNORM+EPS60)
C  ORTHONORMALIZE PV VECTOR WITH RESPECT TO PU
            PUPV=PUXS*PVX(IN)+PUYS*PVY(IN)
            PVXS=PVX(IN)-PUPV*PUXS
            PVYS=PVY(IN)-PUPV*PUYS
            PNORM=SQRT(PVXS**2+PVYS**2)
            PVXS=PVXS/(PNORM+EPS60)
            PVYS=PVYS/(PNORM+EPS60)
            VXSTEP(IPLSV,ITARG,IG)=
     .            (PUXS*UUB(IX,NPBS,IFL)+PVXS*VVB(IX,NPBS,IFL))*V
            VYSTEP(IPLSV,ITARG,IG)=
     .            (PUYS*UUB(IX,NPBS,IFL)+PVYS*VVB(IX,NPBS,IFL))*V
            RRBS=UUB(IX,NPBS,IFL)/(UPB(IX,NPBS,IFL)+EPS60)
            VZSTEP(IPLSV,ITARG,IG)=
     .            (SQRT(1.-RRBS**2)*UPB(IX,NPBS,IFL))*V
3023      CONTINUE
        ENDDO
3030    CONTINUE
C
3040  CONTINUE
      NRWL(ITARG)=IG+1

C
      IF (TRCSOU) CALL LEER(2)
C
C  INITIALIZE FUNCTION STEP (FOR RANDOM SAMPLING ALONG TARGET)
C  SET SOME SOURCE PARAMETERS EXPLICITLY TO ENFORCE INPUT CONSISTENCY
C
      FLUX(ITARG)=STEP(IIPLS,IEPLS,NRWL(ITARG),ITARG)
C
      NLPLS(ITARG)=.TRUE.
      NLATM(ITARG)=.FALSE.
      NLMOL(ITARG)=.FALSE.
      NLION(ITARG)=.FALSE.
C
      NLSRF(ITARG)=.TRUE.
      NLPNT(ITARG)=.FALSE.
      NLLNE(ITARG)=.FALSE.
      NLVOL(ITARG)=.FALSE.
      NLCNS(ITARG)=.FALSE.
C
      NSRFSI(ITARG)=1
CTRIG A
C  IN TRIA OPTION INDIM=4 (LEVGEO=3) CORRESPONDS TO INDIM=1 (LEVGEO=4)
      INDIM(1,ITARG)=1
CTRIG E
      IF (INDSRC(ITARG).NE.6) THEN
        I34=IDEZ(INT(SORLIM(1,ITARG)),3,3)
        SORLIM(1,ITARG)=I34*100+40
      ELSEIF (INDSRC(ITARG).EQ.6) THEN
C  SORLIM DEFAULT WAS 0.D0
        SORLIM(1,ITARG)=0240
      ENDIF
      SORIND(1,ITARG)=ITARG
C  IN CASE INDIM=4: INSOR,INDGRD,... ARE REDUNDANT
      NRSOR(1,ITARG)=-1
      NPSOR(1,ITARG)=-1
      IF (INDSRC(ITARG).LT.6) THEN
        WRITE (iunout,*) 'MESSAGE FROM IF2COP: '
        WRITE (iunout,*) 'SOURCE STRENGTH AND SPATIAL DISTRIBUTION FOR '
        WRITE (iunout,*) 'STRATUM ',ISTRA,' MODIFIED.'
        CALL MASR1('FLUX=   ',FLUX(ISTRA))
        WRITE (iunout,*) 'USE STEP FUNCTION ISTEP= ',ITARG,
     .    ' FROM BLOCK 14'
        CALL LEER(1)
      ENDIF
C
      IF (INDSRC(ITARG).EQ.6) THEN
C  DEFINE SOURCE FOR TARGET RECYCLING STRATUM ITARG
C  ASSUME NOW: ITARG=ISTRA
C  DEFAULTS ARE ALREADY SET IN SUBR. INPUT.
C
        CALL FTCRI(ITARG,CITARG)
        TXTSOU(ITARG)= 'SURFACE RECYCLING SOURCE NO.'//CITARG
        NPTS(ITARG)=NPTC(ITARG,1)
        NINITL(ITARG)=ITARG*1001
        NSPEZ(ITARG)=-1
        SORIFL(1,ITARG)=NIFLG(ITARG,1)
        SORWGT(1,ITARG)=1.
C  USE ENERGY FLUXES SPECIFIED HERE, IE., SORENE, SORENI ARE REDUNDANT
        NEMODS(ITARG)=9
        NAMODS(ITARG)=1
C
C  USE POLYGON MESH, IE., SORAD1,...,SORAD4 ARE REDUNDANT.
        SORAD5(1,ITARG)=ZIA
        SORAD6(1,ITARG)=ZAA
C
C  VELOCITY SPACE DISTRIBUTION
        SORCOS(ITARG)=1.
        SORMAX(ITARG)=0.
C
C
C  DO 2028 LOOP FROM SUBR. INPUT
        THMAX=MAX(0._DP,MIN(PIHA,SORMAX(ITARG)*DEGRAD))
        IF (NAMODS(ITARG).EQ.1) THEN
          RP1=SORCOS(ITARG)+1.
          SORCOS(ITARG)=1./RP1
          IF (ABS(COS(THMAX)).LE.EPS10) THEN
            SORMAX(ITARG)=1.
          ELSE
            SORMAX(ITARG)=1.-COS(THMAX)**RP1
          ENDIF
        ELSEIF (NAMODS(ITARG).EQ.2) THEN
          SORCOS(ITARG)=SORCOS(ITARG)*DEGRAD
          SORMAX(ITARG)=THMAX
        ENDIF
        NLSYMT(0)=NLSYMT(0).AND.NLSYMT(ITARG)
        NLSYMP(0)=NLSYMP(0).AND.NLSYMP(ITARG)
C
      ENDIF
C
C  SOURCE DEFINITION FOR TARGET RECYCLING STRATUM ITARG COMPLETED
C
3999  CONTINUE
C
C  TARGET DATA ARE DEFINED NOW
C
C
C  COMPUTE EXACT SURFACE ENERGY FLUXES FOR COMPARISON WITH SAMPLED
C  E-FLUX "ETOTP". THIS IS ONLY FOR DIAGNOSTICS PURPOSES
C  E.G. TO CHECK CONSISTENCY OF BOUNDARY CONDITIONS
C  STATEMENT NO. 6000 ---> 6500
C
      IF (.NOT.TRCSOU) GOTO 6500
C
      EEMAX=0.
      EESHT=0.
C
      DO 6011 IG=1,NRWL(ITARG)-1
        OR=ORI(ITARG,IG)
C
C  COMPUTE SHEATH POTENTIAL ESHT(ITARG,IG)
C  USE ALL NPLSI SPECIES, NOT JUST IFL=NSPZI,NSPZE
C
        ESHT(ITARG,IG)=0.D0
        NEM=IABS(NEMODS(ITARG))
        IF (NEM.EQ.3.OR.NEM.EQ.5.OR.NEM.EQ.7.OR.NEM.EQ.9) THEN
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
            ITRI=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            DO 6005 IPL=1,NPLSI
              IPLV=MPLSV(IPL)
              PM1=(PTRIX(NPES,ITRI)*VXSTEP(IPLV,ITARG,IG)+
     .             PTRIY(NPES,ITRI)*VYSTEP(IPLV,ITARG,IG))*OR
              VPZ=VZSTEP(IPLV,ITARG,IG)
              VP(IPL)=SQRT(PM1**2+VPZ**2)
              DI(IPL)=DISTEP(IPL,ITARG,IG)
6005        CONTINUE
            TE=TESTEP(ITARG,IG)
            CUR=0.
            GAMMA=0.
            ESHT(ITARG,IG)=SHEATH(TE,DI,VP,NCHRGP,GAMMA,CUR,NPLSI,
     .                           -ITARG)
          ELSEIF (IGSTEP(ITARG,IG).LT.200000) THEN
            ITRI=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-100000
            ESHT(ITARG,IG)= 0
          ENDIF
        ENDIF
C

        DO 6009 IPLS=1,NPLSI
          IF (FLSTEP(IPLS,ITARG,IG).EQ.0.D0) GOTO 6009
C
          IPLSTI=MPLSTI(IPLS)
          IPLSV=MPLSV(IPLS)
          IF (IGSTEP(ITARG,IG).GT.200000) THEN
C  CHECK BOHM CRITERION AT "POLOIDAL" TARGET SURFACE COMPONENTS
            ITRI=IRSTEP(ITARG,IG)
            NPES=IGSTEP(ITARG,IG)-200000
            VT=SQRT(2.*TISTEP(IPLSTI,ITARG,IG)/BMASS(IPLS))*CVEL2A
C  VELOCITY COMPONENT NORMAL TO POLOIDAL TARGET SURFACE
C  I.E., POLOIDAL COMPONENT V-POL
C  ASSUMING ORTHOGONAL TARGET
            PM1=(PTRIX(NPES,ITRI)*VXSTEP(IPLS,ITARG,IG)+
     .           PTRIY(NPES,ITRI)*VYSTEP(IPLS,ITARG,IG))
C  VELOCITY COMPONENT PARALLEL TO POLOIDAL TARGET SURFACE
C  I.E., RADIAL PLUS TOROIDAL COMPONENT, V-RAD + V-TOR
C  AGAIN: ASSUMING ORTHOGONAL TARGET
            VPX=VXSTEP(IPLSV,ITARG,IG)-PM1*PTRIX(NPES,ITRI)
            VPY=VYSTEP(IPLSV,ITARG,IG)-PM1*PTRIY(NPES,ITRI)
            VPZ=VZSTEP(IPLSV,ITARG,IG)-0.
            PN1=SQRT(VPX**2+VPY**2+VPZ**2)
            PERW=0.
            PARW=0.
            IF (VT.GT.0.) THEN
              PERW=PM1/VT
              PARW=PN1/VT
            ENDIF
C
            CS=SQRT((1.*TISTEP(IPLSTI,ITARG,IG)+
     .                  TESTEP(ITARG,IG))/BMASS(IPLS))*CVEL2A
C THE MACH NUMBER BOUNDARY CONDITION ONLY AFFECTS THE PARALLEL TO B
C MOMENTUM, I.E., NOT THE RADIAL VELOCITY
            VTEST=SQRT(PM1**2+VPZ**2)
            VTEST=VTEST/(CS+EPS60)
            VR=SQRT(VPX**2+VPY**2)
            WRITE (iunout,*) 'IPLS,ITARG,IG,MACH ',IPLS,ITARG,IG,VTEST
C           WRITE (iunout,*) 'POL., TOR., RAD. ',PM1,VPZ,VR
            CALL LEER(1)
          ENDIF
C
C  BOHM CRITERION CHECK DONE
C
C  NEXT: TARGET ENERGY FLUXES
          DRR=RRSTEP(ITARG,IG+1)-RRSTEP(ITARG,IG)
C  ENERGY FLUX DEFINED IN INPUT BLOCK 7
          IF (NEMODS(ITARG).EQ.1) THEN
            EADD=SORENI(ITARG)
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).EQ.2.OR.NEMODS(ITARG).EQ.3) THEN
            EADD=SORENI(ITARG)*TISTEP(IPLSTI,ITARG,IG)+SORENE(ITARG)*
     .           TESTEP(ITARG,IG)
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).GE.4) THEN
            IF (IGSTEP(ITARG,IG).LT.200000) THEN
              EADD=0.
              WRITE (iunout,*) 'INVALID OPTION FOUND IN IF2COP '
              WRITE (iunout,*) 'POSSIBLE ERROR IN TARGET ENERGY FLUX '
              WRITE (iunout,*) 'ITARG,IG ',ITARG,IG
            ELSE
              PERWI=PERW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
              PARWI=PARW/SQRT(BMASS(IPLS)/RMASSP(IPLS))
              EADD=EMAXW(TISTEP(IPLSTI,ITARG,IG),PERWI,PARWI)
            ENDIF
            ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
            EEMAX=EEMAX+ESUM*DRR
          ELSEIF (NEMODS(ITARG).EQ.8 .OR. NEMODS(ITARG).EQ.9) THEN
C  ENERGY FLUX DEFINED BY B2-BOUNDARY CONDITIONS
            EEMAX=EEMAX+ELSTEP(IPLS,ITARG,IG)*DRR
          ENDIF
C  SUM SHEATH ACCELERATION
          EADD=NCHRGP(IPLS)*ESHT(ITARG,IG)
          ESUM=EADD*FLSTEP(IPLS,ITARG,IG)
          EESHT=EESHT+ESUM*DRR
6009    CONTINUE
        GOTO 6011
6010    CONTINUE
C  TO BE WRITTEN
6011  CONTINUE
C
      CALL LEER(1)
      WRITE (iunout,*) 'TARGET DATA: TARGET NO. ITARG=ISTRA= ',ITARG
      WRITE (iunout,*)
     .' IG,  ARC,     P-FLUX,   E-FLUX,     TE,       TI,    SHEATH/TE'
      DO 6100 IG=1,NRWL(ITARG)-1
        WRITE (iunout,'(1X,I3,1P,6E11.3)')
     .             IG,RRSTEP(ITARG,IG),FLSTEP(0,ITARG,IG),
     .             ELSTEP(0,ITARG,IG),
     .             TESTEP(ITARG,IG),TISTEP(1,ITARG,IG),
     .             ESHT(ITARG,IG)/(TESTEP(ITARG,IG)+EPS60)
6100  CONTINUE
      WRITE (iunout,'(1X,I3,1P,1E11.3)') NRWL(ITARG),
     .                                 RRSTEP(ITARG,NRWL(ITARG))
      CALL MASR1 ('EEMAX    ',EEMAX)
      CALL MASR1 ('EESHT    ',EESHT)
C
      ETOT=EEMAX+EESHT
      EFLX(ITARG)=EEMAX+EESHT
      WRITE (iunout,*) 'PARTICLE FLUX(IPLS), IPLS=1,NPLSI '
      WRITE (iunout,'(1X,1P,6E12.4)') (FLTOT(ISP,ITARG),ISP=1,NPLSI)
      CALL LEER(1)
      WRITE (iunout,*) 'ENERGY FLUX '
      WRITE (iunout,'(1X,1P,1E12.4)') EFLX(ITARG)
      CALL LEER(2)
C
6300  CONTINUE
C
C  SET SOME OTHER DATA SPECIFIC FOR EIRENE CODE REQUIREMENTS
C  STATEMENT NO. 6500 ---> 6999
C
6500  CONTINUE

      DEALLOCATE (NUMSID)
      DEALLOCATE (NUMTRI)
      DEALLOCATE (TORL)
      DEALLOCATE (ESHT)
      DEALLOCATE (ORI)
C
C
      RETURN
999   CONTINUE
      WRITE (iunout,*) 'ERROR IN IF2COP: NGITT TOO SMALL '
      CALL EXIT_OWN(1)
      RETURN
C
C
      ENTRY IF3COP(ISTRAA,ISTRAE,NEW_ITER)
C
C
      WRITE (iunout,*) ' IF3COP IS CALLED, ISTRAA,ISTRAE '
      WRITE (iunout,*) ISTRAA,ISTRAE
      LSHORT=.FALSE.
      LSTOP=.TRUE.
      IFIRST=0
      NDXY=(NDXA-1)*NR1STQ+NDYA
      GOTO 99992
C
      ENTRY INTER3(LSTP,IFRST,ISTRAA,ISTRAE,NEW_ITER)
C
C  ENTRY FOR SHORT CYCLE FROM SUBR. EIRSRT
C
C  IFIRST=0: RESTORE DATA FROM A PREVIOUS EIRENE RUN, SET REFERENCE
C            DATA FOR "STOP-CRITERION" SNIS,SEES,SEIS
C  IFIRST>0: MODIFY SOURCE TERMS ACCORDING TO NEW PLASMA CONDITIONS,
C            COMPARE INTEGRALS WITH SNIS,...., AND DECIDE TO STOP OR
C            CONTINUE SHORT CYCLE (LSTOP)
C
      LSHORT=.TRUE.
      LSTOP=LSTP
      IFIRST=IFRST
      NDXY=(NDXA-1)*NR1STQ+NDYA
C
99992 CONTINUE

      IF (.NOT.ALLOCATED(CHPS)) THEN
        ALLOCATE (CHPS(NFL))
        ALLOCATE (SNIS(0:NFL))
        ALLOCATE (CHMOS(NFL))
        ALLOCATE (SMOS(0:NFL))
        ALLOCATE (SCALN(0:NFL))
        ALLOCATE (SNIS0(NSTRA,0:NFL))
        ALLOCATE (SMOS0(NSTRA,0:NFL))
        ALLOCATE (RESSNI(NFL))
        ALLOCATE (RESSMO(NFL))
        CALL ALLOC_BRASPOI
        CALL ALLOC_EIRBRA(NDX, NDY, NFL, NSTRA)
      END IF
C
!      IF ((ISTRAA.NE.ISTRAE).OR.(ISTRAA.EQ.1)) THEN
      IF (NEW_ITER == 0) THEN
        RESSNI = 0.D0
        RESSMO = 0.D0
        RESSEE = 0.D0
        RESSEI = 0.D0
      ENDIF

      DO 10000 ISTRAI=ISTRAA,ISTRAE
C
        IF (XMCP(ISTRAI).LE.1.) GOTO 10000
C
        IF (LSHORT) GOTO 7000
C
C  READ DATA FROM STRATUM NO. ISTRAI BACK INTO WORKING SPACE
C  IF REQUIRED
C
        IF (ISTRAI.EQ.IESTR) THEN
C  NOTHING TO BE DONE
        ELSEIF (NFILEN.EQ.1.OR.NFILEN.EQ.2) THEN
          IESTR=ISTRAI
          CALL RSTRT(ISTRAI,NSTRAI,NESTM1,NESTM2,NADSPC,
     .               ESTIMV,ESTIMS,ESTIML,
     .               NSDVI1,SDVI1,NSDVI2,SDVI2,
     .               NSDVC1,SIGMAC,NSDVC2,SGMCS,
     .               NSBGK,SIGMA_BGK,NBGV_STAT,SGMS_BGK,
     .               NSCOP,SIGMA_COP,NCPV_STAT,SGMS_COP,
     .               NSIGI_SPC,TRCFLE)
        ELSE
          WRITE (iunout,*) 'ERROR IN INFCOP: STRATUM ISTRAI= ',ISTRAI
          WRITE (iunout,*) 'IS NOT AVAILABLE. EXIT CALLED'
          CALL EXIT_OWN(1)
        ENDIF
C
C  DATA TRANSFER BCK FROM EIRENE TO EXTERNAL CODE
C  STATEMENT NO 7000 ---> 7999
C
7000    CONTINUE
C
C  SCALE SURFACE SOURCES PER UNIT FLUX, FOR OTHER SOURCES USE
C  EIRENE SCALINGS
        IF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).NE.0.) THEN
C  FLUX FROM EIRENE TO PLASMA CODE: NEGATIVE
          FLX=-WTOTP(0,ISTRAI)
          FLXI=1./FLX
        ELSEIF (ISTRAI.LE.NTARGI.AND.WTOTP(0,ISTRAI).EQ.0.) THEN
          WRITE (iunout,*) 'NO PLASMA FLUX FROM STRATUM NO. ISTRAI= ',
     .                      ISTRAI
          WRITE (iunout,*) 
     .      'NO DATA RETURNED TO PLASMA CODE FOR THIS STRATUM'
          GOTO 7999
        ELSEIF (ISTRAI.GT.NTARGI) THEN
          FLXI=1.
        ENDIF
C
C  FIRSTLY INITIALIZE SOURCE TERM ARRAYS
C
        DO 7100 IX=0,NDXA+1
          DO 7150 IY=0,NDYA+1
            SEE(IX,IY,ISTRAI)=0.
            SEI(IX,IY,ISTRAI)=0.
7150      CONTINUE
7100    CONTINUE
        DO 7210 IF=1,NFLA
          DO 7220 IX=0,NDXA+1
            DO 7230 IY=0,NDYA+1
              SNI(IX,IY,IF,ISTRAI)=0.
              SMO(IX,IY,IF,ISTRAI)=0.
7230        CONTINUE
7220      CONTINUE
7210    CONTINUE
C
!pb        DO 7300 IPLS=1,NPLSI
!pb        DO 7300 IN=1,NDXY
!pb          CHPM(IPLS,IN)=0.
!pb          CHMOM(IPLS,IN)=0.
!pb7300    CONTINUE
!pb        DO 7301 IN=1,NDXY
!pb          CHEEM(IN)=0.
!pb          CHEIM(IN)=0.
!pb7301    CONTINUE
        CHPM = 0._DP
        CHMOM = 0._DP
        CHEEM = 0._DP
        CHEIM = 0._DP
C
        IF (.NOT.LSHORT) GOTO 7400

        COPV=0.D0
        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IN=CPMUL%ICM
          COPV(ICPV,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MAPL=0.D0
        CPMUL => MAPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MAPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MMPL=0.D0
        CPMUL => MMPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MMPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MIPL=0.D0
        CPMUL => MIPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MIPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        MPHPL=0.D0
        CPMUL => MPHPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          MPHPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT IONISATION OF ATOMS
C                        AND BULK ION CHARGE EXCHANGE WITH ATOMS
C

        PAPL=0.D0
        CPMUL => PAPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PAPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EAEL=0.D0
        CPSIM => EAELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EAPL=0.D0
        CPSIM => EAPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EAPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7310

        CPMUL => PDENAS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IATM=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWA(IN,IATM,IPLS)-SPLODA(IN,IATM,IPLS))*ELCHA
            PAPL(IPLS,IN)=PAPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          ENDDO
          CHE=CPMUL%VALUEM*
     .        (SEENWA(IN,IATM)-SEEODA(IN,IATM))*ELCHA
          EAEL(IN)=EAEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

        CPMUL => COPVS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          ICPV=CPMUL%IART
          IF (ICPV.LE.NPLSI) THEN
            IPLS=ICPV
            IN=CPMUL%ICM
            CHI=CPMUL%VALUEM*
     .          (SEINWA(IN,IPLS)-SEIODA(IN,IPLS))*ELCHA
            EAPL(IN)=EAPL(IN)+CHI
            CHEIM(IN)=CHEIM(IN)+CHI
          ENDIF
          CPMUL => CPMUL%NXTMUL
        ENDDO

7310    CONTINUE

C
C  CORRECTION FOR ELECTRON IMPACT IONISATION AND CX OF ATOMS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS
C

        PIPL=0.D0
        CPMUL => PIPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PIPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EIEL=0.D0
        CPSIM => EIELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EIPL=0.D0
        CPSIM => EIPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EIPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7330

        CPMUL => PDENIS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IION=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM *
     .          (SPLNWI(IN,IION,IPLS)-SPLODI(IN,IION,IPLS))*ELCHA
            PIPL(IPLS,IN)=PIPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM *
     .        (SEENWI(IN,IION)-SEEODI(IN,IION))*ELCHA
          EIEL(IN)=EIEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CHI=CPMUL%VALUEM *
     .        (SEINWI(IN,IION)-SEIODI(IN,IION))*ELCHA
          EIPL(IN)=EIPL(IN)+CHI
          CHEIM(IN)=CHEIM(IN)+CHI
          CPMUL => CPMUL%NXTMUL
        ENDDO

7330    CONTINUE
C
C
C  CORRECTION FOR TEST IONS FINISHED
C
C
C  SHORT LOOP CORRECTION FOR ELECTRON IMPACT COLLISIONS
C             OF MOLECULES
C

        PMPL=0.D0
        CPMUL => PMPLS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IPLS=CPMUL%IART
          IN=CPMUL%ICM
          PMPL(IPLS,IN)=CPMUL%VALUEM
          CPMUL => CPMUL%NXTMUL
        ENDDO

        EMEL=0.D0
        CPSIM => EMELS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMEL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        EMPL=0.D0
        CPSIM => EMPLS(ISTRAI)%PSIM
        DO WHILE (ASSOCIATED(CPSIM))
          IN=CPSIM%ICS
          EMPL(IN)=CPSIM%VALUES
          CPSIM => CPSIM%NXTSIM
        END DO

        IF (IFIRST.EQ.0) GOTO 7350

        CPMUL => PDENMS(ISTRAI)%PMUL
        DO WHILE (ASSOCIATED(CPMUL))
          IMOL=CPMUL%IART
          IN=CPMUL%ICM
          DO IPLS=1,NPLSI
            CHP=CPMUL%VALUEM*
     .          (SPLNWM(IN,IMOL,IPLS)-SPLODM(IN,IMOL,IPLS))*ELCHA
            PMPL(IPLS,IN)=PMPL(IPLS,IN)+CHP
            CHPM(IPLS,IN)=CHPM(IPLS,IN)+CHP
          END DO
          CHE=CPMUL%VALUEM*
     .        (SEENWM(IN,IMOL)-SEEODM(IN,IMOL))*ELCHA
          EMEL(IN)=EMEL(IN)+CHE
          CHEEM(IN)=CHEEM(IN)+CHE
          CPMUL => CPMUL%NXTMUL
        ENDDO

7350    CONTINUE
C
C  CORRECTION FOR ELECTRON IMPACT DISSOCIATION OF TEST IONS FINISHED
C
C  SHORT LOOP CORRECTION FINISHED
C
7400    CONTINUE
C
C
C  ADD CONTRIBUTIONS FROM VOLUME RECOMBINATION SOURCE
C
        IF (NLVOL(ISTRAI)) THEN
C
          DO 7473 IPLS=1,NPLSI
            CNDYNP=AMUA*RMASSP(IPLS)
            IPLSTI = MPLSTI(IPLS)
            IPLSV = MPLSV(IPLS)
            DO 7472 IIRC=1,NPRCI(IPLS)
              IRRC=LGPRC(IPLS,IIRC)
              SUMN=0.0
              SUMM=0.0
              SUMEI=0.0
              SUMEE=0.0
              DO 7471 IT=1,NTRII
                IF (NSTORDR >= NRAD) THEN
                  RECADD=-TABRC1(IRRC,IT)*DIIN(IPLS,IT)*ELCHA
                  EEADD=  EELRC1(IRRC,IT)*DIIN(IPLS,IT)*ELCHA
                ELSE
                  RECADD=-FTABRC1(IRRC,IT)*DIIN(IPLS,IT)*ELCHA
                  EEADD=  FEELRC1(IRRC,IT)*DIIN(IPLS,IT)*ELCHA
                END IF
                PAPL(IPLS,IT)=PAPL(IPLS,IT)+RECADD
                SUMN=SUMN+RECADD*VOL(IT)
                VPARA=BVIN(IPLSV,IT)
                PIADD=VPARA*CNDYNP*RECADD
                PIADD=PIADD*SIGN(1._DP,VPARA)
                MAPL(IPLS,IT)=MAPL(IPLS,IT)+PIADD
                SUMM=SUMM+PIADD*VOL(IT)
                EIADD=(1.5*TIIN(IPLSTI,IT)+EDRIFT(IPLS,IT))*RECADD
                EAPL(IT)=EAPL(IT)+EIADD
                SUMEI=SUMEI+EIADD*VOL(IT)
                EAEL(IT)=EAEL(IT)+EEADD
                SUMEE=SUMEE+EEADD*VOL(IT)
7471          CONTINUE
              WRITE (iunout,*) 'IPLS,IRRC ',IPLS,IRRC
              CALL MASR4('SUMN, SUMM, SUMEI, SUMEE        ',
     .                     SUMN,SUMM,SUMEI,SUMEE)
7472        CONTINUE
7473      CONTINUE
        ENDIF
C
        IF (.NOT.LSYMET) GOTO 7500
C
C  SECONDLY SYMMETRISE EIRENE ARRAYS ACCORDING TO SYMMETRY IN MODEL
C
C
C   THIRDLY WRITE EIRENE ARRAYS (1D) ONTO BRAAMS ARRAYS (2D)
C   AND RESCALE TO PROPER UNITS: #/CELL/STRATUM FLUX
C   # STANDS FOR PARTICLES (SNI), MOMENTUM (SMO)
C   AND ENERGY (SEE,SEI)
C
7500    CONTINUE
        DO 7510 IFL=1,NFLA
          CHPS(IFL)=0.
          SNIS(IFL)=0.
          CHMOS(IFL)=0.
          SMOS(IFL)=0.
          DO 7510 IPLS=1,NPLSI
            IF (IFLB(IPLS).NE.IFL) GOTO 7510
            IPLSV=MPLSV(IPLS)
            DO 7520 IX=1,NDXA
              DO 7530 IY=1,NDYA
                CURPOI => HEADS(IY,IX)%P
                DO WHILE (ASSOCIATED(CURPOI))
                  IT=CURPOI%TRIANGLE
                  SNICL=(PAPL(IPLS,IT)+PMPL(IPLS,IT)+PIPL(IPLS,IT))*
     .                  VOLTAL(IT)
                  SNI(IX,IY,IFL,ISTRA)=SNI(IX,IY,IFL,ISTRA)+SNICL
                  SNIS(IFL)=SNIS(IFL)+ SNICL
                  CHPS(IFL)=CHPS(IFL)+CHPM(IPLS,IT)*VOLTAL(IT)
                  RESSNI(IFL)=RESSNI(IFL)+ABS(SIGMA_COP(NCPVI+IPLS,IT)*
     .                        SNICL/100.D0)
                  CURPOI=>CURPOI%NEXT
                ENDDO
7530          CONTINUE
7520        CONTINUE
!pb            DO 7539 IADD=NPLSI,3*NPLSI,NPLSI
!pb            IF (NCPVI.LT.IADD+NPLSI) GOTO 7539
            DO 7536 IX=1,NDXA
              DO 7533 IY=1,NDYA
                CURPOI => HEADS(IY,IX)%P
                DO WHILE (ASSOCIATED(CURPOI))
                  IT=CURPOI%TRIANGLE
                  SIGNUM=SIGN(1._DP,BVIN(IPLSV,IT))
                  SMOCL=(MAPL(IPLS,IT)+MMPL(IPLS,IT)+MIPL(IPLS,IT))*
     .                   VOLTAL(IT)*1.D-5*SIGNUM
                  SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)+SMOCL
                  SMOS(IFL)=SMOS(IFL)+SMOCL
                  CHMOS(IFL)=CHMOS(IFL)+CHMOM(IPLS,IT)*VOLTAL(IT)
                  RESSMO(IFL)=RESSMO(IFL)+ABS(SIGMA_COP(IADD+IPLS,IT)*
     .                      SMOCL/100.D0*1.D5)
                  CURPOI=>CURPOI%NEXT
                ENDDO
7533          CONTINUE
7536        CONTINUE
!pb 7539        CONTINUE
7510    CONTINUE
C
        CHEES=0.
        CHEIS=0.
        SEES=0.
        SEIS=0.
        DO 7540 IX=1,NDXA
          DO 7545 IY=1,NDYA
            CURPOI => HEADS(IY,IX)%P
            DO WHILE (ASSOCIATED(CURPOI))
              IT=CURPOI%TRIANGLE
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)+
     .                    (EAEL(IT)+EMEL(IT)+EIEL(IT))*VOLTAL(IT)*ELCHA
              CHEES=CHEES+CHEEM(IT)*VOLTAL(IT)
              SEES=SEES+(EAEL(IT)+EMEL(IT)+EIEL(IT))*VOLTAL(IT)
              RESSEE=RESSEE+ABS(SIGMA_COP(NCPVI+NPLSI+1,IT)*
     .               SEE(IX,IY,ISTRAI)/100.D0)
C
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)+
     .                    (EAPL(IT)+EMPL(IT)+EIPL(IT))*VOLTAL(IT)*ELCHA
              CHEIS=CHEIS+CHEIM(IT)*VOLTAL(IT)
              SEIS=SEIS+(EAPL(IT)+EMPL(IT)+EIPL(IT))*VOLTAL(IT)
              RESSEI=RESSEI+ABS(SIGMA_COP(NCPVI+NPLSI+2,IT)*
     .               SEI(IX,IY,ISTRAI)/100.D0)
              CURPOI=>CURPOI%NEXT
            ENDDO
7545      CONTINUE
7540    CONTINUE
C
C   NEXT:
C   IF LSHORT: CRITERION TO STOP SHORT CYCLE,
C   IF NOT LSHORT: RESCALE SURFACE SOURCE STRATA
C                  UNITS: # PER UNIT TARGET PLATE FLUX
C
        IF (LSHORT.AND.IFIRST.EQ.0) THEN
C
          SNIS0(ISTRAI,0)=0.
          SMOS0(ISTRAI,0)=0.
          DO 7550 IFL=1,NFLA
            SNIS0(ISTRAI,0)=SNIS0(ISTRAI,0)+SNIS(IFL)
            SNIS0(ISTRAI,IFL)=SNIS(IFL)
            SMOS0(ISTRAI,0)=SMOS0(ISTRAI,0)+SMOS(IFL)
            SMOS0(ISTRAI,IFL)=SMOS(IFL)
7550      CONTINUE
          SEES0(ISTRAI)=SEES
          SEIS0(ISTRAI)=SEIS
C
        ELSEIF (LSHORT.AND.IFIRST.GT.0) THEN
C
          SNIS(0)=0.
          DO 7551 IFL=1,NFLA
            SNIS(0)=SNIS(0)+SNIS(IFL)
            SCALN(IFL)=SNIS0(ISTRAI,IFL)/(SNIS(IFL)+EPS60)
7551      CONTINUE

          SCALN(0)=SNIS0(ISTRAI,0)/(SNIS(0)+EPS60)
C
C         SCALM=SMOS0(ISTRAI,0)/(SMOS(0)+EPS60)  ???
C         SCALE=SEES0(ISTRAI)/(SEES+EPS60)       ???
C         SCALI=SEIS0(ISTRAI)/(SEIS+EPS60)       ???
C
          SCALM=1.
          SCALE=1.
          SCALI=1.
          DO 7555 IX=0,NDXA+1
            DO 7552 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*SCALN(0)
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*SCALN(0)
7552        CONTINUE
7555      CONTINUE
          DO 7556 IFL=1,NFLA
            DO 7553 IX=0,NDXA+1
              DO 7554 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*SCALN(IFL)
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*SCALN(IFL)
7554          CONTINUE
7553        CONTINUE
7556      CONTINUE
C
          IF (LSTOP) THEN
            WRITE (iunout,*) 'STOP SHORT CYCLE: ALL B2 TIMESTEPS DONE '
          ELSE
            DO 7558 IFL=1,NFLA
              TEST=CHPS(IFL)/(SNIS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGP) THEN
                LSTP=.TRUE.
                WRITE (iunout,*) 'STOP SHORT CYCLE: PART. SOURCES: ',
     .                            SNIS(IFL),CHPS(IFL),TEST
                WRITE (iunout,*) 'STRATUM ISTRAI, SPECIES IFL ',
     .                            ISTRAI,IFL
              ENDIF
              TEST=CHMOS(IFL)/(SMOS(IFL)+1.D-60)*100.
              IF (ABS(TEST).GT.CHGMOM) THEN
                LSTP=.TRUE.
                WRITE (iunout,*) 'STOP SHORT CYCLE: MOMENTUM SOURCE: ',
     .                            SMOS(IFL),CHMOS(IFL),TEST
                WRITE (iunout,*) 'STRATUM ISTRAI, SPECIES IFL ',
     .                            ISTRAI,IFL
              ENDIF
7558        CONTINUE
            TEST=CHEES/(SEES+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEE) THEN
              LSTP=.TRUE.
              WRITE (iunout,*) 'STOP SHORT CYCLE: EL EN. SOURCE: ',SEES,
     .                          CHEES,TEST
              WRITE (iunout,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
            TEST=CHEIS/(SEIS+1.D-60)*100.
            IF (ABS(TEST).GT.CHGEI) THEN
              LSTP=.TRUE.
              WRITE (iunout,*) 'STOP SHORT CYCLE: ION EN. SOURCE: ',
     .                          SEIS,CHEIS,TEST
              WRITE (iunout,*) 'STRATUM ISTRAI ',ISTRAI
            ENDIF
          ENDIF
C
        ELSEIF (.NOT.LSHORT) THEN
C
          DO 7560 IX=0,NDXA+1
            DO 7565 IY=0,NDYA+1
              SEE(IX,IY,ISTRAI)=SEE(IX,IY,ISTRAI)*FLXI
              SEI(IX,IY,ISTRAI)=SEI(IX,IY,ISTRAI)*FLXI
7565        CONTINUE
7560      CONTINUE
          DO 7570 IFL=1,NFLA
            DO 7580 IX=0,NDXA+1
              DO 7590 IY=0,NDYA+1
                SNI(IX,IY,IFL,ISTRAI)=SNI(IX,IY,IFL,ISTRAI)*FLXI
                SMO(IX,IY,IFL,ISTRAI)=SMO(IX,IY,IFL,ISTRAI)*FLXI
7590          CONTINUE
7580        CONTINUE
7570      CONTINUE
C
        ENDIF
C
C   THIRDLY:
C   INDEX MAPPING BACK TO BRAAMS IMPLEMENTATION OF LINDA GEOMETRY
C
        IF (NCUTL.EQ.NCUTB) GOTO 7600
C
        CALL INDMPI (SNI,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SMO,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEE,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
        CALL INDMPI (SEI,DUMMY,NDX,NDY,1  ,NDXA,NDYA,1   ,
     .               NCUTB,NCUTL,NPOINT,NPPLG,NSTRA,ISTRAI)
C
7600    CONTINUE
C
7700    CONTINUE
C
7999    CONTINUE
C
C  DATA TRANSFER BACK TO PLASMA CODE FINISHED FOR STRATUM NO. ISTRAI
C
10000 CONTINUE
C
      RETURN
C
      ENTRY IF4COP
C
      NREC11=NOUTAU
      OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
      IRC=3
      WRITE (11,REC=IRC) RCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
      IRC=3
      ALLOCATE (IHELP(NOUTAU))
      JC=0
      DO K=1,NPTRGT
        DO J=1,10*NSTEP
          JC=JC+1
          IHELP(JC)=ICCPL1(J,K)
          IF (JC == NOUTAU) THEN
            IRC=IRC+1
            WRITE (11,REC=IRC) IHELP
            IF (TRCINT.OR.TRCFLE)   
     .        WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
            JC=0
          END IF
        END DO
      END DO
      IF (JC > 0) THEN
        IHELP(JC+1:NOUTAU) = 0
        IRC=IRC+1
        WRITE (11,REC=IRC) IHELP
        IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
      END IF
      DEALLOCATE (IHELP)
      IRC=IRC+1
      WRITE (11,REC=IRC) ICCPL2
      IRC=IRC+1
      WRITE (11,REC=IRC) LCCPL
      IF (TRCINT.OR.TRCFLE)   WRITE (iunout,*) 'WRITE 11  IRC= ',IRC
C
      IF (LSHORT) LSTOP=LSTP
C
      IF (.NOT.LSTOP) RETURN
C
      IF (.NOT.(LBALAN)) GOTO 11000
C
C  BALANCES, SHOULD BE DONE ONLY AT THE END OF B2 RUN
C  AT THE END OF AN EIRENE RUN THE BALANCES MAY BE OFF AT LEAST AT
C  THE BEGINNING OF THE CYCLING PROCEDURE, BECAUSE THE PLASMA STILL
C  HAS TO ADJUST TO THE NEW SOURCES
C
C
      SFEISY=0.
      SFEESY=0.
      SFNISY=0.
      NPBS=0
      NPES=NPBS+1
C
      DO 10113 IX=1,NDXA
C
C IS (IX,0) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.0) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10110
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
        IF (LCUT(IX)) GOTO 10113
C
C SURFACE NORMAL IS INWARD. HENCE: TAKE ALL FLUXES F...YB POSITIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEISY=SFEISY+FEIYB(IX,0)
        SFEESY=SFEESY+FEEYB(IX,0)
        DO 10111 IF=1,NFLA
          SFNISY=SFNISY+FNIYB(IX,0,IF)
10111   CONTINUE
        GOTO 10113
10110   CONTINUE
C  DO NOT RECYCLE TARGET FLUXES WITH FALSE ORIENTATION
        IF (ITARG.GT.0) THEN
C  ITARG, IPRT KNOWN FROM ABOVE
          FLX=0.
          TIFLX=0.
          PIFLX=0.
          DO 10112 IF=NSPZI(ITARG,IPRT),NSPZE(ITARG,IPRT)
            FLX=FLX+FNIYB(IX,0,IF)
            IF (NINCT(ITARG,IPRT)*FNIYB(IX,0,IF).LT.0) THEN
              WRITE (iunout,*) 
     .          'RECYCLING TARGET, BUT WRONG FLOW DIRECTION: '
              WRITE (iunout,*) 
     .          'SOUTH,IX,ITARG,IPRT,IF ',IX,ITARG,IPRT,IF
              PIFLX=PIFLX+FNIYB(IX,0,IF)
              TIFLX=TIFLX+FEIYB(IX,0)*FNIYB(IX,0,IF)
            ENDIF
10112     CONTINUE
          TIFLX=TIFLX/(FLX+EPS60)
          SFNISY=SFNISY+PIFLX
          SFEISY=SFEISY+TIFLX
        ENDIF
10113 CONTINUE

      SFNISY=SFNISY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM SOUTH EDGE '
      WRITE (37,8888) SFNISY,SFEISY,SFEESY
8888  FORMAT (3E14.6)
C
      SFEINY=0.
      SFEENY=0.
      SFNINY=0.
      NPBS=NDYA
      NPES=NPBS+1
      DO 10118 IX=1,NDXA
C
C IS (IX,NDYA) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.2.AND.NDT(ITARG,IPRT).EQ.NDYA) THEN
              IF (IX.GE.NTIN(ITARG,IPRT).AND.
     .            IX.LT.NTEN(ITARG,IPRT)) GOTO 10115
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
        IF (LCUT(IX)) GOTO 10118
C
C SURFACE NORMAL IS OUTWARD. HENCE: TAKE ALL FLUXES F...YB NEGATIVE
C SIGN OF ADDITIONAL COMPONENT DUE TO INCLINED GRID AS SIGN OF F...YB
        SFEINY=SFEINY-FEIYB(IX,NDYA)
        SFEENY=SFEENY-FEEYB(IX,NDYA)
        DO 10116 IF=1,NFLA
          SFNINY=SFNINY-FNIYB(IX,NDYA,IF)
10116   CONTINUE
        GOTO 10118
10115   CONTINUE
        IF (ITARG.GT.0) THEN
C  ITARG, IPRT KNOWN FROM ABOVE
          FLX=0.
          TIFLX=0.
          PIFLX=0.
          DO 10117 IF=NSPZI(ITARG,IPRT),NSPZE(ITARG,IPRT)
            FLX=FLX+FNIYB(IX,NDYA,IF)
            IF (NINCT(ITARG,IPRT)*FNIYB(IX,NDYA,IF).LT.0) THEN
              WRITE (iunout,*) 
     .          'RECYCLING TARGET, BUT WRONG FLOW DIRECTION: '
              WRITE (iunout,*) 
     .          'NORTH,IX,ITARG,IPRT,IF ',IX,ITARG,IPRT,IF
              PIFLX=PIFLX+FNIYB(IX,NDYA,IF)
              TIFLX=TIFLX+FEIYB(IX,NDYA)*FNIYB(IX,NDYA,IF)
            ENDIF
10117     CONTINUE
          TIFLX=TIFLX/(FLX+EPS60)
          SFNINY=SFNINY-PIFLX
          SFEINY=SFEINY-TIFLX
        ENDIF
10118 CONTINUE
C
      SFNINY=SFNINY*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO NORTH EDGE '
      WRITE (37,8888) SFNINY,SFEINY,SFEENY
C
      SFEIWX=0.
      SFEEWX=0.
      SFNIWX=0.
      DO 10123 IY=1,NDYA
C
C IS (0,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
             IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.0) THEN
               IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .             IY.LT.NTEN(ITARG,IPRT)) GOTO 10120
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        SFEIWX=SFEIWX+FEIXB(0,IY)
        SFEEWX=SFEEWX+FEEXB(0,IY)
        WRITE (iunout,*) 'WEST,IY ',IY
        DO 10121 IF=1,NFLA
          SFNIWX=SFNIWX+FNIXB(0,IY,IF)
10121   CONTINUE
10120   CONTINUE
        IF (ITARG.GT.0) THEN
C  ITARG, IPRT KNOWN FROM ABOVE
          FLX=0.
          TIFLX=0.
          PIFLX=0.
          DO 10122 IF=NSPZI(ITARG,IPRT),NSPZE(ITARG,IPRT)
            FLX=FLX+FNIXB(0,IY,IF)
            IF (NINCT(ITARG,IPRT)*FNIXB(0,IY,IF).LT.0) THEN
              WRITE (iunout,*) 
     .          'RECYCLING TARGET, BUT WRONG FLOW DIRECTION: '
              WRITE (iunout,*) 'WEST,IY,ITARG,IPRT,IF ',IY,ITARG,IPRT,IF
              PIFLX=PIFLX+FNIXB(0,IY,IF)
              TIFLX=TIFLX+FEIXB(0,IY)*FNIXB(0,IY,IF)
            ENDIF
10122     CONTINUE
          TIFLX=TIFLX/(FLX+EPS60)
          SFNIWX=SFNIWX+PIFLX
          SFEIWX=SFEIWX+TIFLX
        ENDIF
10123 CONTINUE
C
      SFNIWX=SFNIWX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES FROM WEST EDGE '
      WRITE (37,8888) SFNIWX,SFEIWX,SFEEWX
C
      SFEIEX=0.
      SFEEEX=0.
      SFNIEX=0.
      DO 10128 IY=1,NDYA
C
C IS (NDXA,IY) A RECYCLING SOURCE? IF YES, DO NOT COUNT HERE
C
        DO ITARG=1,NTARGI
          DO IPRT=1,NTGPRT(ITARG)
            IF (NIXY(ITARG,IPRT).EQ.1.AND.NDT(ITARG,IPRT).EQ.NDXA) THEN
              IF (IY.GE.NTIN(ITARG,IPRT).AND.
     .            IY.LT.NTEN(ITARG,IPRT)) GOTO 10125
            ENDIF
          ENDDO
        ENDDO
        ITARG=0
C
        WRITE (iunout,*) 'EAST,IY ',IY
        SFEIEX=SFEIEX-FEIXB(NDXA,IY)
        SFEEEX=SFEEEX-FEEXB(NDXA,IY)
        DO 10126 IF=1,NFLA
          SFNIEX=SFNIEX-FNIXB(NDXA,IY,IF)
10126   CONTINUE
10125   CONTINUE
        IF (ITARG.GT.0) THEN
C  ITARG, IPRT KNOWN FROM ABOVE
          FLX=0.
          TIFLX=0.
          PIFLX=0.
          DO 10127 IF=NSPZI(ITARG,IPRT),NSPZE(ITARG,IPRT)
            FLX=FLX+FNIXB(NDXA,IY,IF)
            IF (NINCT(ITARG,IPRT)*FNIXB(NDXA,IY,IF).LT.0) THEN
              WRITE (iunout,*) 
     .         'RECYCLING TARGET, BUT WRONG FLOW DIRECTION: '
              WRITE (iunout,*) 'EAST,IY,ITARG,IPRT,IF ',IY,ITARG,IPRT,IF
              PIFLX=PIFLX+FNIXB(NDXA,IY,IF)
              TIFLX=TIFLX+FEIXB(NDXA,IY)*FNIXB(NDXA,IY,IF)
            ENDIF
10127     CONTINUE
          TIFLX=TIFLX/(FLX+EPS60)
          SFNIEX=SFNIEX-PIFLX
          SFEIEX=SFEIEX-TIFLX
        ENDIF
10128 CONTINUE
C
      SFNIEX=SFNIEX*ELCHA
C
      WRITE (37,*) 'NON RECYCLING FLUXES TO EAST EDGE '
      WRITE (37,8888) SFNIEX,SFEIEX,SFEEEX
C
C  NEXT: FLUXES TO THOSE SURFACES, AT WHICH RECYCLING BOUNDARY
C        CONDITIONS ARE SPECIFIED
C
10130 CONTINUE
C
      SFEIT(0)=0.
      SFEET(0)=0.
      SFNIT(0)=0.
      SHEAE(0)=0.
      SHEAI(0)=0.
      DO 10139 I=1,NTARGI
        SFEIT(I)=0.
        SFEET(I)=0.
        SFNIT(I)=0.
        SHEAE(I)=0.
        SHEAI(I)=0.
        DO IPRT=1,NTGPRT(I)
          NPBS=NDT(I,IPRT)
          NPES=NPBS+1
          IF (NIXY(I,IPRT).EQ.1) THEN
C  BALANCE CONTRIB. X-GRID REC. SOURCE
            DO 10132 IY=NTIN(I,IPRT),NTEN(I,IPRT)-1
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIXB(NDT(I,IPRT),IY)
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEXB(NDT(I,IPRT),IY)
              DO 10131 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF).GT.0) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIXB(NDT(I,IPRT),IY,IF)
C               SHEAE(I)=SHEAE(I)+TEB(NDT(I,IPRT),IY)*
C    .                            FNIXB(NDT(I,IPRT),IY,IF)*(-2.5)
C               SHEAI(I)=SHEAI(I)+TEB(NDT(I,IPRT),IY)*
C    .                            FNIXB(NDT(I,IPRT),IY,IF)*2.5
                ENDIF
10131         CONTINUE
10132       CONTINUE
C  BALANCE CONTRIB. FROM Y-GRID REC. SOURCE
          ELSEIF (NIXY(I,IPRT).EQ.2) THEN
            DO 10135 IX=NTIN(I,IPRT),NTEN(I,IPRT)-1
              IF (LCUT(IX)) GOTO 10135
              SFEIT(I)=SFEIT(I)-NINCT(I,IPRT)*FEIYB(IX,NDT(I,IPRT))
              SFEET(I)=SFEET(I)-NINCT(I,IPRT)*FEEYB(IX,NDT(I,IPRT))
              DO 10136 IF=NSPZI(I,IPRT),NSPZE(I,IPRT)
                IF (NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF).GT.0.) THEN
                SFNIT(I)=SFNIT(I)-
     .                   NINCT(I,IPRT)*FNIYB(IX,NDT(I,IPRT),IF)
C               SHEAE(I)=SHEAE(I)+TEB(IX,NDT(I,IPRT))*
C    .                            FNIYB(IX,NDT(I,IPRT),IF)*(-2.5)
C               SHEAI(I)=SHEAI(I)+TEB(IX,NDT(I,IPRT))*
C    .                            FNIXB(IX,NDT(I,IPRT),IF)*2.5
                ENDIF
10136         CONTINUE
10135       CONTINUE
          ENDIF
        ENDDO
C
        SFNIT(I)=SFNIT(I)*ELCHA
C
C
        WRITE (37,*) 'FLUXES TO TARGET NO. ',I
        WRITE (37,8888) SFNIT(I),SFEIT(I),SFEET(I)
C
        SHEAE(I)=0.
        SHEAI(I)=0.
C
        SFEIT(0)=SFEIT(0)+SFEIT(I)
        SFEET(0)=SFEET(0)+SFEET(I)
        SFNIT(0)=SFNIT(0)+SFNIT(I)
        SHEAE(0)=SHEAE(0)+SHEAE(I)
        SHEAI(0)=SHEAI(0)+SHEAI(I)
10139 CONTINUE
C
      SSNI=0.
      SSEI=0.
      SSEE=0.
      DO 10150 ISTRA=1,NSTRAI
        IF (XMCP(ISTRA).LE.1) GOTO 10150
        FLX=0.
        IF (ISTRA.LE.NTARGI) THEN
          FLX=ABS(SFNIT(ISTRA))
        ELSE
          FLX=1.
        ENDIF
        SSN=0.
        SSI=0.
        SSE=0.
        DO 10140 IX=1,NDXA
           DO 10140 IY=1,NDYA
             DO 10141 IF=1,NFLA
               SSN=SSN+SNI(IX,IY,IF,ISTRA)
10141        CONTINUE
             SSI=SSI+SEI(IX,IY,ISTRA)
             SSE=SSE+SEE(IX,IY,ISTRA)
10140   CONTINUE
C
      WRITE (37,*) 'RECYCLING SOURCE RATES, POTENTIAL+RAD. EN. ',ISTRA
      WRITE (37,8888) SSN*FLX,SSI*FLX/ELCHA,SSE*FLX/ELCHA
C
C  TRENNEN VON RAD. UND POTENTIELLER ENERGY IM ELECTRONENKANAL.
C  DAZU ABER TEILCHENQUELLE SPEZIESAUFGELOEST NOETIG.
C
C
C
C     WRITE (37,*) 'RADIATION LOSSES VIA NEUTRAL CHANNEL ',ISTRA
C     WRITE (37,8888) 0.,0.,0.
C
        SSNI=SSNI+SSN*FLX
        SSEI=SSEI+SSI*FLX/ELCHA
        SSEE=SSEE+SSE*FLX/ELCHA
10150 CONTINUE
C
      WRITE (37,*) 'EQUILIBRATION '
      WRITE (37,8888) 0.,B2QIE,-B2QIE
C
C
      WRITE (37,*) 'BREMSSTRAHLUNG '
      WRITE (37,8888) 0.,0.,B2BREM
C
      WRITE (37,*) 'CHARGED IMPURITY RAD.,IONIZ. AND RECOMB. '
      WRITE (37,8888) 0.,0.,B2RAD
C
      WRITE (37,*) 'ELECTRIC FIELD TERMS (PRESSURE GRADIENTS)'
      WRITE (37,8888) 0.,B2VDP,-B2VDP
C
      BALANI=SFEISY+SFEINY+SFEIT(0)+SHEAI(0)+SSEI+B2QIE+B2VDP+
     .       SFEIWX+SFEIEX
      BALANE=SFEESY+SFEENY+SFEET(0)+SHEAE(0)+SSEE+B2BREM+B2RAD-B2QIE+
     .       SFEEWX+SFEEEX-B2VDP
      BALANN=SFNISY+SFNINY+SFNIWX+SFNIEX+SFNIT(0)+SSNI
C
      TOTI=ABS(SFEISY+SFEINY)+ABS(SFEIT(0))+
     .     ABS(SHEAI(0))+ABS(SSEI)
      TOTE=ABS(SFEESY+SFEENY)+ABS(SFEET(0))+
     .     ABS(SHEAE(0))+ABS(SSEE)
      TOTN=ABS(SFNISY+SFNINY)+ABS(SFNIT(0))+
     .     ABS(SSNI)
      RE=BALANE/(TOTE+EPS60)*100.
      RI=BALANI/(TOTI+EPS60)*100.
      RN=BALANN/(TOTN+EPS60)*100.
C
      CALL LEER (1)
      IF (LBALAN) THEN
        WRITE (iunout,*) 'B2-EIRENE GLOBAL BALANCES '
        WRITE (iunout,*) 'PARTICLE FLUXES (SFNI..) IN AMP'
        WRITE (iunout,*) 'ENERGY FLUXES (SFEI..,SFEE..,) IN WATT'
        CALL LEER(1)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT SOUTH EDGE '
        CALL MASR3(' SFEISY,SFEESY,SFNISY   ',SFEISY,SFEESY,SFNISY)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT NORTH EDGE'
        CALL MASR3(' SFEINY,SFEENY,SFNINY   ',SFEINY,SFEENY,SFNINY)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT WEST EDGE '
        CALL MASR3(' SFEIWX,SFEEWX,SFNIWX   ',SFEIWX,SFEEWX,SFNIWX)
        WRITE (iunout,*) ' NON RECYCLING FLUXES AT EAST EDGE '
        CALL MASR3(' SFEIEX,SFEEEX,SFNIEX   ',SFEIEX,SFEEEX,SFNIEX)
        CALL MASRR1 (' TARGETS,EI',SFEIT(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,EE',SFEET(1),NTARGI,5)
        CALL MASRR1 (' TARGETS,NI',SFNIT(1),NTARGI,5)
        CALL MASR3(' TOTALS, EI,EE,NI       ',SFEIT(0),
     .                                     SFEET(0),SFNIT(0))
        WRITE (iunout,*) ' NEUTRAL PLASMA INTERACTION: '
        CALL MASR3(' SSEI,SSEE,SSNI         ',SSEI,SSEE,SSNI)
        WRITE (iunout,*) 
     .    ' VOLUMETRIC ENERGY SINKS FOR ELECTRONS, FROM B2 '
        CALL MASR4(' B2BREM,B2RAD,-B2QIE,-B2VDP     ',
     .               B2BREM,B2RAD,-B2QIE,-B2VDP)
        CALL MASR3(' BALANI,BALANE,BALANN   ',BALANI,BALANE,BALANN)
        CALL MASR3(' REL. ERR.(%) RI,RE,RN  ',RI,RE,RN)
        CALL LEER(1)
        WRITE (iunout,*) ' NOISE FROM SOURCE TERMS '
        RESSNI(1:NFLA) = RESSNI(1:NFLA)/ELCHA
        CALL MASR4(' RESSEE,RESSEI,RESSNI,RESSMO    ',
     .        RESSEE,RESSEI,SUM(RESSNI(1:NFLA)),SUM(RESSMO(1:NFLA)))
        CALL LEER(1)
        WRITE (iunout,*) ' RESSNI-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSNI    ',RESSNI(1),NFLA,5)
        WRITE (iunout,*) ' RESSMO-CONTRIBUTIONS BY DIFFERENT SPECIES '
        CALL MASRR1 (' RESSMO    ',RESSMO(1),NFLA,5)
      ENDIF
C
      CALL LEER (1)
C
11000 CONTINUE
C
      RETURN
C
      END
