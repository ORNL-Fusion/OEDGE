C=======================================================================
C MISCELLANEOUS HSL ROUTINES USED BY EDGE2D
C
C!!!*** NB..FD05AD IS SET UP FOR THE IBM
C
C=======================================================================
C
C/     ADD NAME=GA15AD  HSL                     DOUBLE
C######DATE   24 JUN 1985     COPYRIGHT UKAEA, HARWELL.
C######ALIAS GA15AD
C###### CALLS KB05  NB01
      SUBROUTINE GA15AD(N, KIND, W, IW, IND, LND, X, Y, TT, XD, YD, LP)
      DOUBLE PRECISION A, B, BIG, C, CUBIC, D, DM, DP, DY, DYN,
     * EIGHT, EPS, FD05AD
      DOUBLE PRECISION ERR, F, FOUR, ONE, R, ROOT, ROOT1, RT, T, THREE
      DOUBLE PRECISION TL, TN, TT, TWO, T1, T2, W, W2, X, XD, XL
      DOUBLE PRECISION XMAX, XMIN, XN, Y, YD, YL, YN, YP, ZERO
      DIMENSION W(IW), X(N), Y(N), XD(N), YD(N), TT(N)
      DIMENSION IND(2,LND)
      DATA ZERO /0D0/, ONE /1D0/,  TWO /2D0/, THREE /3D0/,
     * FOUR /4D0/,  EIGHT /8D0/
      CUBIC(R) = D + R*(C+R*(B+R*A))
      BIG=FD05AD(5)*.1D0
      EPS=FD05AD(1)*100.D0
C  CHECK N GREATER THAN 4
      IF (N.LT.4) GO TO 430
C  CHECK DATA IS PERIODIC
      IF (X(1).NE.X(N) .OR. Y(1).NE.Y(N)) GO TO 420
C  CHECK KIND=1 OR KIND=2
      IF (KIND.NE.1 .AND. KIND.NE.2) GO TO 440
      IF (KIND.EQ.1) GO TO 20
C  CHECK VALUES OF TT IN ORDER (CUBICS ONLY)
      DO 10 I=2,N
        IF (TT(I).LE.TT(I-1)) GO TO 450
   10 CONTINUE
C  CHECK XD AND YD ARE PERIODIC  (CUBICS ONLY)
      IF (XD(1).NE.XD(N) .OR. YD(1).NE.YD(N)) GO TO 460
C
C     PARTITION THE STORAGE IN W
C     IN THE PARAMETRIC CUBIC CASE W(I),W(N+I),I=2,N HOLD THE MINIMUM
C  AND MAXIMUM VALUES OF X IN THE INTERVAL BETWEEN KNOTS I-1 AND I.
   20 I1 = 0
      IF (KIND.NE.1) I1 = 2*N
C     W(I1+I),I=1,2,... HOLD THE STATIONARY VALUES OF Y IN ASCENDING
C   ORDER.
      M = (IW-I1)/4
      I2 = I1 + M
C     W(I2+I),I=1,2,... HOLD THE VALUES OF CAPITAL T AT CRITICAL
C  POINTS IN SEQUENCE ROUND THE CURVE.
      I3 = I2 + M
      I4 = I3 + M
C     W(I3+I),W(I4+I),I=1,2,... HOLD THE MAXIMUM AND MINIMUM X VALUES
C  IN THE BOUNDARY SEGMENT ENDING AT THE ITH CRITICAL POINT.
      N1 = N - 1
      NSTAT = 0
      IF (KIND.NE.1) GO TO 50
C
C     FIND MAXIMA AND MINIMA OF Y IN POLYGONAL CASE
C     THE MAXIMA AND MINIMA OF Y AND CORRESPONDING CAPITAL T VALUES
C  ARE STORED TEMPORARILY IN W(I3+I),W(I4+I),I=1,2,...
      DY = Y(N) - Y(N-1)
      DO 40 I=2,N
        DYN = Y(I) - Y(I-1)
        IF (DY*DYN.GT.ZERO) GO TO 30
        NSTAT = NSTAT + 1
        IF (I3+NSTAT.GT.I4) GO TO 400
        W(I3+NSTAT) = Y(I-1)
        W(I4+NSTAT) = I - 1
   30   DY = DYN
   40 CONTINUE
      GO TO 140
C
C     FIND MAXIMA AND MINIMA OF X AND Y.
C     THE MAXIMA AND MINIMA OF Y AND CORRESPONDING CAPITAL T VALUES
C  ARE STORED TEMPORARILY IN W(I3+I),W(I4+I),I=1,2,...
   50 DO 130 I=2,N
        T1 = I - 1
        T2 = I
        CALL GA15CD(T1, T2, X, TT, XD, XMAX, XMIN, N)
        W(N+I) = XMAX
        W(I) = XMIN
        F = (Y(I)-Y(I-1))/FOUR
        A = (TT(I)-TT(I-1))/EIGHT
        DM = YD(I-1)*A
        DP = YD(I)*A
        A = THREE*(DM+DP-F)
        B = DP - DM
        C = THREE*F - DM - DP
        ROOT = -TWO
        ROOT1 = TWO
        IF (B*B.LE.A*C) GO TO 60
        D = B + DSIGN(DSQRT(B*B-A*C),B)
        ROOT = -C/D
        IF (A.NE.ZERO) ROOT1 = -D/A
C     TEST FOR STATIONARY POINTS AT ENDS OF RANGE.
   60   D = (DABS(A)+TWO*DABS(B)+DABS(C))*EPS
        IF (FOUR*DABS(DP).GT.D) GO TO 80
        IF (DABS(ROOT-ONE).LT.DABS(ROOT1-ONE)) GO TO 70
        ROOT1 = ONE
        GO TO 80
   70   ROOT = ONE
   80   IF (FOUR*DABS(DM).GT.D) GO TO 100
        IF (DABS(ROOT+ONE).LT.DABS(ROOT1+ONE)) GO TO 90
        ROOT1 = -ONE
        GO TO 100
   90   ROOT = -ONE
C     STORE STATIONARY POINTS
  100   A = DM + DP - F
        D = Y(I) - A - B - C
        RT = DMIN1(ROOT,ROOT1)
        DO 120 IR=1,2
          IF (DABS(RT).GT.ONE) GO TO 110
          NSTAT = NSTAT + 1
          IF (NSTAT+I3.GT.I4) GO TO 400
          W(NSTAT+I4) = I + (RT-ONE)/TWO
          W(NSTAT+I3) = CUBIC(RT)
  110     RT = DMAX1(ROOT,ROOT1)
  120   CONTINUE
  130 CONTINUE
C
C     SORT STATIONARY POINTS INTO ASCENDING ORDER.
  140 IND(2,1) = NSTAT
      IF (NSTAT.GT.LND) GO TO 410
      DO 150 I=1,NSTAT
        IND(2,I) = -1
        W(I+I1) = W(I+I3)
  150 CONTINUE
      CALL KB05AD(W(I1+1), NSTAT)
C
C     REMOVE ANY REPEATED STATIONARY POINTS.
      NREP = 0
      DO 160 I=2,NSTAT
        IF (W(I1+I-1).EQ.W(I1+I)) NREP = NREP + 1
        W(I1+I-NREP) = W(I1+I)
  160 CONTINUE
C
C     FIND CRITICAL POINTS AND INDEX THE BOUNDARY INTERVALS.
C     FOR EACH INTERVAL BETWEEN W(I1+I-1) AND W(I1+I),I=2,3,...
C  AN ASSOCIATED LIST OF INTEGERS IS HELD IN IND STARTING AT IND(1,I).
C  THE INTEGERS THEMSELVES ARE IN IND(1,.) AND WITH EACH IS
C  ASSOCIATED THE ADDRESS, HELD IN IND(2,.) OF THE NEXT INTEGER OR
C  ZERO TO INDICATE THE END.  EACH INTEGER K IN THIS LIST POINTS
C  TO AN INTERVAL W(I2+IABS(K)-1) TO W(I2+IABS(K)), WHOSE Y VALUES SPAN
C  THE INTERVAL W(I1+I-1) TO W(I1+I).  Y IS INCREASING OR DECREASING
C  IN THIS INTERVAL ACCORDING AS K IS POSITIVE OR NEGATIVE.
      YL = W(I3+NSTAT)
      TL = W(I4+NSTAT)
      NND = NSTAT - NREP
      NCRIT = 0
      IST = 0
  170 IST = IST + 1
      IF (W(I1+IST).NE.YL) GO TO 170
      DO 310 I=1,NSTAT
        YN = W(I3+I)
        TN = W(I4+I)
        IF (TL.GT.TN) TN = TN + N1
        INC = 1
        IF (YN.LT.YL) INC = -1
  180   NCRIT = NCRIT + 1
        IF (I2+NCRIT.GT.I3) GO TO 400
        W(I2+NCRIT) = W(I4+I)
        IF (YN.EQ.YL) GO TO 300
        IST = IST + INC
        YP = W(I1+IST)
        IF (YP.EQ.YN) GO TO 250
        K = TL
  190   J = K
        K = K + 1
        IF (J.GE.N) J = J - N1
        IF ((Y(J+1)-YP)*INC.LE.ZERO .AND. K.LT.TN) GO TO 190
        T1 = DMAX1(J+ZERO,TL)
        T2 = DMIN1(J+ONE,TN)
        IF (KIND.EQ.1) GO TO 240
C     FIND THE INTERCEPT OF Y=YP WITH THE  SPLINE IN Y
C    IN THE INTERVAL T1,T2 (ASSUMED TO LIE IN ONE KNOT INTERVAL).
        J = T1
        A = (TT(J+1)-TT(J))/EIGHT
        DM = YD(J)*A
        DP = YD(J+1)*A
        F = (Y(J+1)-Y(J))/FOUR
        A = DM + DP - F
        B = DP - DM
        C = THREE*F - DM - DP
        D = Y(J+1) - A - B - C
        K = 0
        T = DMAX1(DABS(T1),DABS(T2))*TWO
        ERR = EPS*(DABS(D)+DABS(C)*(ONE+T)+DABS(B)*(ONE+T+T)+DABS(A)*
     *   (ONE+T+T+T))
  200   CALL NB01AD(K, T1, T2, ERR, T, R, 100)
        GO TO (210, 230, 220, 220), K
  210   R = CUBIC((T-J)*TWO-ONE) - YP
        GO TO 200
  220   WRITE (LP,99999)
        IND(1,1) = 4
        GO TO 390
  230   W(I2+NCRIT) = T
        GO TO 250
  240   W(I2+NCRIT) = J + 1 + (YP-Y(J+1))/(Y(J+1)-Y(J))
C     INSERT CRITICAL INTERVAL IN APPROPRIATE LIST.
  250   J = IST - (INC-1)/2
  260   IF (IND(2,J)) 290, 280, 270
  270   J = IND(2,J)
        GO TO 260
  280   IND(2,J) = NND + 1
        NND = NND + 1
        IF (NND.GT.LND) GO TO 410
        J = NND
  290   IND(1,J) = NCRIT*INC
        IND(2,J) = 0
        IF (YP.NE.YN) GO TO 180
  300   TL = W(I4+I)
        YL = YN
  310 CONTINUE
      NSTAT = NSTAT - NREP
C
C     FIND MAXIMUM AND MINIMUM X VALUES FOR EACH INTERVAL BETWEEN
C  CRITICAL POINTS.
      TL = W(I2+NCRIT)
      DO 380 I=1,NCRIT
        TN = W(I2+I)
        IN = TN
        IN1 = IN + 1
        IF (IN1.GT.N) IN1 = 2
        XN = X(IN) + (TN-IN)*(X(IN1)-X(IN))
        IF (TL.GT.TN) TN = TN + N1
        IL = TL
        IN = TN
        IF (KIND.NE.1) GO TO 330
        XL = X(IL) + (TL-IL)*(X(IL+1)-X(IL))
        W(I3+I) = DMAX1(XL,XN)
        W(I4+I) = DMIN1(XL,XN)
        IL = IL + 1
        IF (IL.GT.IN) GO TO 370
        DO 320 K=IL,IN
          J = K
          IF (J.GE.N) J = J - N1
          W(I3+I) = DMAX1(W(I3+I),X(J))
          W(I4+I) = DMIN1(W(I4+I),X(J))
  320   CONTINUE
        GO TO 370
  330   DO 360 J=IL,IN
          T1 = DMAX1(J+ZERO,TL)
          T2 = DMIN1(J+ONE,TN)
          IF (T2.LE.N) GO TO 340
          T1 = T1 - N1
          T2 = T2 - N1
  340     CALL GA15CD(T1, T2, X, TT, XD, XMAX, XMIN, N)
          IF (J.NE.IL) GO TO 350
          W(I3+I) = XMAX
          W(I4+I) = XMIN
  350     W(I3+I) = DMAX1(W(I3+I),XMAX)
          W(I4+I) = DMIN1(W(I4+I),XMIN)
  360   CONTINUE
  370   TL = W(I2+I)
  380 CONTINUE
      IND(1,1) = -NSTAT
      IND(2,1) = NCRIT
      RETURN
C
C     ERROR RETURNS
  390 WRITE (LP,99998)
      RETURN
  400 WRITE (LP,99997)
      IND(1,1) = 1
      GO TO 390
  410 WRITE (LP,99996)
      IND(1,1) = 2
      GO TO 390
  420 WRITE (LP,99995)
      IND(1,1) = 3
      GO TO 390
  430 WRITE (LP,99994)
      IND(1,1) = 5
      GO TO 390
  440 WRITE (LP,99993)
      IND(1,1) = 6
      GO TO 390
  450 WRITE (LP,99992)
      IND(1,1) = 7
      GO TO 390
  460 WRITE (LP,99991)
      IND(1,1) = 8
      GO TO 390
99999 FORMAT (32X, 15HOF NB01 FAILURE)
99998 FORMAT (31H+ERROR RETURN FROM GA15 BECAUSE)
99997 FORMAT (32X, 15HIW IS TOO SMALL)
99996 FORMAT (32X, 16HLND IS TOO SMALL)
99995 FORMAT (32X, 24HTHE DATA IS NOT PERIODIC)
99994 FORMAT (32X, 14HN IS TOO SMALL)
99993 FORMAT (32X, 24HKIND NOT EQUAL TO 1 OR 2)
99992 FORMAT (32X, 14HT NOT IN ORDER)
99991 FORMAT (32X, 24HXD OR YD IS NOT PERIODIC)
      END
      SUBROUTINE GA15BD(XP, YP, RESULT, N, KIND, W, IW, IND, LND, X, Y,
     * TT, XD, YD, LP)
      DOUBLE PRECISION A, B, BIG, C, CUBIC, D, DIST, DM, DP, EIGHT, EPS
      DOUBLE PRECISION ERR, F, FOUR, ONE, R, RESL, RESULT
      DOUBLE PRECISION T, THREE, TT, TWO, T1, T2, W, X, XD, XDIST
      DOUBLE PRECISION XP, Y, YD, YP, ZERO, FD05AD
      DIMENSION W(IW), X(N), Y(N), XD(N), YD(N), TT(N)
      DIMENSION IND(2,LND)
      DATA ZERO /0D0/, ONE /1D0/,  TWO /2D0/, THREE /3D0/,
     * FOUR /4D0/,  EIGHT /8D0/
      CUBIC(R) = D + R*(C+R*(B+R*A))
      BIG=FD05AD(5)*.1D0
      EPS=FD05AD(1)*100.0D0
C     PARTITION THE STORAGE IN W
      I1 = 0
      IF (KIND.NE.1) I1 = 2*N
      M = (IW-I1)/4
      I2 = I1 + M
      I3 = I2 + M
      I4 = I3 + M
      N1 = N - 1
      NSTAT = -IND(1,1)
      NCRIT = IND(2,1)
C
C     FIND THE INTERVAL BETWEEN STATIONARY POINTS.
C     W(I1+JL).LT.YP.LE.W(I1+JU)
      JL = 0
      JU = NSTAT + 1
   10 IF (JU.EQ.JL+1) GO TO 30
      JT = (JL+JU)/2
      IF (YP.GT.W(I1+JT)) GO TO 20
      JU = JT
      GO TO 10
   20 JL = JT
      GO TO 10
   30 DIST = BIG
      RESULT = -BIG
      IF (JU.EQ.1) GO TO 220
      IF (JU.GT.NSTAT) GO TO 230
C
C     COUNT THE BOUNDARY SEGMENTS TO THE LEFT IN NL.  XDIST IS SET
C  POSITIVE OR NEGATIVE ACCORDING AS THE BOUNDARY SEGMENT IS TO THE LEFT
C  OR RIGHT.  ABS(XDIST) IS A LOWER BOUND ON DISTANCE TO THE BOUNDARY
C  AND IS ZERO FOR POINTS ON THE BOUNDARY.
   40 NL = 0
   50 J = IND(1,JU)
      F = J
      J = IABS(J)
C     TEST AGAINST MAXIMUM AND MINIMUM X VALUES FOR THE BOUNDARY
C  SEGMENT.
      XDIST = XP - W(I3+J)
      IF (XDIST.GT.ZERO) GO TO 200
      XDIST = XP - W(I4+J)
      IF (XDIST.LT.ZERO) GO TO 210
C     PERFORM A BINARY SEARCH TO FIND KNOT INTERVAL INVOLVED.
      IU = W(I2+J) + ONE
      IF (IU.EQ.N+1) IU = N
      IF (J.EQ.1) GO TO 60
      IL = W(I2+J-1)
      GO TO 70
   60 IL = W(I2+NCRIT)
   70 IF (IL.GE.IU) IL = IL - N1
      IF (IU.EQ.IL+1) GO TO 90
      IT = (IL+IU)/2
      IF (IT.LE.1) IT = IT + N1
      IF ((YP-Y(IT))*F.GT.ZERO) GO TO 80
      IU = IT
      IL = IL + N1
      GO TO 70
   80 IL = IT
      GO TO 70
C  CHECK FOR VERTEX
   90 XDIST=ZERO
      IF(XP.EQ.X(IU).AND.YP.EQ.Y(IU)) GO TO 190
      IF (KIND.NE.1) GO TO 100
C     PERFORM DIRECT TEST IN THE POLYGONAL CASE.
      XDIST = XP - (YP-Y(IL))*(X(IU)-X(IL))/(Y(IU)-Y(IL)) - X(IL)
      GO TO 190
C     TEST AGAINST MAXIMUM AND MINIMUM X VALUES IN KNOT INTERVAL.
  100 XDIST = XP - W(N+IU)
      IF (XDIST.GT.ZERO) GO TO 200
      XDIST = XP - W(IU)
      IF (XDIST.LT.ZERO) GO TO 210
C     FIND ACTUAL POINT OF INTERSECTION WITH THE BOUNDARY.
      T = W(I2+NCRIT)
      IF (J.NE.1) T = W(I2+J-1)
      T1 = IL
      IF (T.GT.IL .AND. T.LT.IU) GO TO 110
      XDIST = XP - X(IL)
      IF (YP-Y(IL)) 120, 190, 120
  110 T1 = T
  120 T = W(I2+J)
      T2 = IU
      IF (T.GT.IL .AND. T.LT.IU) GO TO 130
      XDIST = XP - X(IU)
      IF (YP.EQ.Y(IU)) GO TO 190
      GO TO 140
  130 T2 = T
C
C     FIND THE INTERCEPT OF Y=YP WITH THE  SPLINE IN Y
C    IN THE INTERVAL T1,T2 (ASSUMED TO LIE IN ONE KNOT INTERVAL).
  140 J = T1
      A = (TT(J+1)-TT(J))/EIGHT
      DM = YD(J)*A
      DP = YD(J+1)*A
      F = (Y(J+1)-Y(J))/FOUR
      A = DM + DP - F
      B = DP - DM
      C = THREE*F - DM - DP
      D = Y(J+1) - A - B - C
      K = 0
      T = DMAX1(DABS(T1),DABS(T2))*TWO
      ERR = EPS*(DABS(D)+DABS(C)*(ONE+T)+DABS(B)*(ONE+T+T)+DABS(A)*
     * (ONE+T+T+T))
  150 CALL NB01AD(K, T1, T2, ERR, T, R, 100)
      GO TO (160, 180, 170, 170), K
  160 R = CUBIC((T-J)*TWO-ONE) - YP
      GO TO 150
  170 WRITE (LP,99999)
      IND(1,1) = 4
      WRITE (LP,99998)
      RETURN
  180 A = (TT(J+1)-TT(J))/EIGHT
      DM = XD(J)*A
      DP = XD(J+1)*A
      F = (X(J+1)-X(J))/FOUR
      A = DM + DP - F
      B = DP - DM
      C = THREE*F - DM - DP
      D = X(J+1) - A - B - C
      XDIST = XP - CUBIC((T-J)*TWO-ONE)
C     TEST XDIST
  190 IF (XDIST) 210, 240, 200
  200 NL = NL + 1
  210 DIST = DMIN1(DIST,DABS(XDIST))
      JU = IND(2,JU)
      IF (JU.NE.0) GO TO 50
C
C     RETURN OR HANDLE THE SPECIAL CASE WHERE YP EQUALS A STATIONARY Y
C  VALUE.
      RESULT = DIST
      IF ((NL/2)*2.EQ.NL) RESULT = -DIST
      IF (YP.EQ.W(I1+JL)) GO TO 250
      JU = JL + 1
  220 IF (YP.EQ.W(I1+JU)) GO TO 260
  230 RETURN
  240 RESULT = ZERO
      RETURN
  250 IF (RESULT*RESL) 240, 230, 230
  260 RESL = -ONE
      IF (JU.EQ.NSTAT) GO TO 250
      JL = JU
      JU = JL + 1
      IF (RESULT.GT.ZERO) RESL = ONE
      GO TO 40
99999 FORMAT (32X, 15HOF NB01 FAILURE)
99998 FORMAT (31H+ERROR RETURN FROM GA15 BECAUSE)
      END
      SUBROUTINE GA15CD(T1, T2, X, TT, XD, XMAX, XMIN, N)
      DOUBLE PRECISION A, B, C, CUBIC, D, DM, DP, E, EIGHT
      DOUBLE PRECISION F, FOUR, ONE, ROOT, R, R1
      DOUBLE PRECISION R2, THREE, TT, TWO, T1, T2, X, XD
      DOUBLE PRECISION XMAX, XMIN, XX, X1, X2, ZERO
      DIMENSION X(N), XD(N), TT(N)
      DATA ZERO /0D0/, ONE /1D0/, TWO /2D0/, THREE /3D0/, FOUR /4D0/,
     * EIGHT /8D0/
      CUBIC(R) = D + R*(C+R*(B+R*A))
C
C     THE FOLLOWING INSTRUCTIONS FIND THE MAXIMUM AND MINIMUM VALUES OF
C  X IN THE INTERVAL T1,T2 (ASSUMED TO LIE IN ONE KNOT INTERVAL).
      L = MIN0(N,IDINT(T1)+1)
      F = (X(L)-X(L-1))/FOUR
      A = (TT(L)-TT(L-1))/EIGHT
      DM = XD(L-1)*A
      DP = XD(L)*A
      A = DM + DP - F
      B = DP - DM
      C = THREE*F - DM - DP
      D = X(L) - A - B - C
      R1 = (T1-L)*TWO + ONE
      R2 = (T2-L)*TWO + ONE
      X1 = CUBIC(R1)
      X2 = CUBIC(R2)
      IF (R1.EQ.-ONE) X1 = X(L-1)
      IF (R2.EQ.ONE) X2 = X(L)
      XMAX = DMAX1(X1,X2)
      XMIN = DMIN1(X1,X2)
      IF (B*B.LE.THREE*A*C) GO TO 30
      E = B + DSIGN(DSQRT(B*B-THREE*A*C),B)
      ROOT = -C/E
      DO 20 IR=1,2
        IF (ROOT.LE.R1 .OR. ROOT.GE.R2) GO TO 10
        XX = CUBIC(ROOT)
        XMAX = DMAX1(XMAX,XX)
        XMIN = DMIN1(XMIN,XX)
   10   IF (A.NE.ZERO) ROOT = -E/A
   20 CONTINUE
   30 RETURN
      END
C/     ENDUP
C
C=======================================================================
C
C/     ADD NAME=KB05AD  HSL                     DOUBLE
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS KB05AD
      SUBROUTINE KB05AD(COUNT,N)
C
C             KB05AD      HANDLES DOUBLE PRECISION VARIABLES
      DOUBLE PRECISION COUNT(1),AV,X
C  THE WORK-SPACE 'MARK' OF LENGTH 50 PERMITS UP TO 2**(50/2) NUMBERS
C  TO BE SORTED. THIS IS MORE THAN THE IBM VIRTUAL MEMORY SPACE
C  WILL HOLD .
      INTEGER MARK(50)
C  CHECK THAT A TRIVIAL CASE HAS NOT BEEN ENTERED
      IF(N.EQ.1)GOTO 280
      IF(N.GE.1)GO TO 110
      WRITE(6,100)
  100 FORMAT(///20X,65H ***KB05AD***NO NUMBERS TO BE SORTED ** RETURN TO
     2 CALLING PROGRAM )
      GOTO 280
C  'M' IS THE LENGTH OF SEGMENT WHICH IS SHORT ENOUGH TO ENTER
C  THE FINAL SORTING ROUTINE. IT MAY BE EASILY CHANGED.
  110 M=12
C  SET UP INITIAL VALUES.
      LA=2
      IS=1
      IF=N
      DO 270 MLOOP=1,N
C  IF SEGMENT IS SHORT ENOUGH SORT WITH FINAL SORTING ROUTINE .
      IFKA=IF-IS
      IF((IFKA+1).GT.M)GOTO 140
C********* FINAL SORTING ***
C  ( A SIMPLE BUBBLE SORT )
      IS1=IS+1
      DO 130 J=IS1,IF
      I=J
  120 IF(COUNT(I-1).LE.COUNT(I))GOTO 130
      AV=COUNT(I-1)
      COUNT(I-1)=COUNT(I)
      COUNT(I)=AV
      I=I-1
      IF(I.GT.IS)GOTO  120
  130 CONTINUE
      LA=LA-2
      GOTO 260
C             *******  QUICKSORT  ********
C  SELECT THE NUMBER IN THE CENTRAL POSITION IN THE SEGMENT AS
C  THE TEST NUMBER.REPLACE IT WITH THE NUMBER FROM THE SEGMENT'S
C  HIGHEST ADDRESS.
  140 IY=(IS+IF)/2
      X=COUNT(IY)
      COUNT(IY)=COUNT(IF)
C  THE MARKERS 'I' AND 'IFK' ARE USED FOR THE BEGINNING AND END
C  OF THE SECTION NOT SO FAR TESTED AGAINST THE PRESENT VALUE
C  OF X .
      K=1
      IFK=IF
C  WE ALTERNATE BETWEEN THE OUTER LOOP THAT INCREASES I AND THE
C  INNER LOOP THAT REDUCES IFK, MOVING NUMBERS AS NECESSARY,
C  UNTIL THEY MEET .
      DO 160 I=IS,IF
      IF(X.GT.COUNT(I))GOTO 160
      IF(I.GE.IFK)GOTO 170
      COUNT(IFK)=COUNT(I)
      K1=K
      DO 150 K=K1,IFKA
      IFK=IF-K
      IF(COUNT(IFK).GE.X)GOTO 150
      IF(I.GE.IFK)GOTO 180
      COUNT(I)=COUNT(IFK)
      GO TO 160
  150 CONTINUE
      GOTO 170
  160 CONTINUE
C  RETURN THE TEST NUMBER TO THE POSITION MARKED BY THE MARKER
C  WHICH DID NOT MOVE LAST. IT DIVIDES THE INITIAL SEGMENT INTO
C  2 PARTS. ANY ELEMENT IN THE FIRST PART IS LESS THAN ANY ELEMENT
C  IN THE SECOND PART, AND THEY MAY NOW BE SORTED INDEPENDENTLY.
  170 COUNT(IFK)=X
      IP=IFK
      GOTO 190
  180 COUNT(I)=X
      IP=I
C  STORE THE LONGER SUBDIVISION IN WORKSPACE.
  190 IF((IP-IS).GT.(IF-IP))GOTO 200
      MARK(LA)=IF
      MARK(LA-1)=IP+1
      IF=IP-1
      GOTO 210
  200 MARK(LA)=IP-1
      MARK(LA-1)=IS
      IS=IP+1
C  FIND THE LENGTH OF THE SHORTER SUBDIVISION.
  210 LNGTH=IF-IS
      IF(LNGTH)230,260,220
C  IF IT CONTAINS MORE THAN ONE ELEMENT STORE IT IN WORKSPACE .
  220 LA=LA+2
      MARK(LA)=IF
      MARK(LA-1)=IS
      GOTO 270
C  IF IT CONTAINS NO ELEMENTS RESELECT THE OTHER SUBDIVISION
C  AND FIND A DIFFERENT TEST NUMBER. NUMBERS WHICH ARE FOUND TO
C  EQUAL THE TEST NUMBER ARE SORTED OUT.
  230 IS=MARK(LA-1)
      IF=MARK(LA)
      IFEND=IF-1
      IK=IS
      DO 240 I=IK,IFEND
      IF(COUNT(I).NE.X)GOTO 250
      IS=IS+1
  240 CONTINUE
      LA=LA-2
      GO TO 260
  250 AV=COUNT(I)
      IY=(IF+IS)/2
      COUNT(I)=COUNT(IY)
      COUNT(IY)=AV
      GOTO 270
C  FIND IF SORTING IS COMPLETED.
  260 IF(LA.LE.0)GOTO 280
C  OBTAIN THE ADDRESS OF THE SHORTEST SEGMENT AWAITING QUICKSORT
      IF=MARK(LA)
      IS=MARK(LA-1)
  270 CONTINUE
  280 RETURN
      END
C
C=======================================================================
C
C/     ADD NAME=NB01AD  HSL                     DOUBLE
C######DATE   01 JAN 1984     COPYRIGHT UKAEA, HARWELL.
C######ALIAS NB01AD
      SUBROUTINE NB01AD(K,AZ,BZ,E2,X,Y,MAXIT)
      DOUBLE PRECISION A,B,H,U,X,Y,AZ,BZ,E2,X1,X2,YA,YB,Y1,YTEST
      SAVE
      IF(K .GT. 0)GO TO 30
C
C     CALCULATE Y(X) AT X=AZ.
      A = AZ
      B = BZ
      X = A
      J1 = 1
      IT = 1
      M = IABS(MAXIT)
   10 K = J1
   20 RETURN
C
C     PRINT X AND Y(X) WHEN REQUESTED.
   30 IF(MAXIT .LE. 0)WRITE(6,40)X,Y
   40 FORMAT(2X,8HNB01AD  ,2HX=,D24.16,2X,5HY(X)=,D24.16)
C
C     TEST WHETHER Y(X) IS SUFFICIENTLY SMALL.
      IF(DABS(Y) .GT. E2)GO TO 50
   45 K = 2
      GO TO 20
C
C     BRANCH DEPENDING ON THE VALUE OF J1.
   50 GO TO (60,70,100,170),J1
C
C     CALCULATE Y(X) AT X=BZ.
   60 YA = Y
      X = B
      J1 = 2
      GO TO 20
C
C     TEST WHETHER THE SIGNS OF Y(AZ) AND Y(BZ) ARE DIFFERENT.
   70 IF(YA*Y .LT.0.0D0)GO TO 120
C
C     BEGIN THE BINARY SUBDIVISION TO SEARCH FOR A BRACKET.
      X1 = A
      Y1 = YA
      J1 = 3
      H = B-A
      J2 = 1
   80 X2 = A+0.5D0*H
      J3 = 1
C
C     CHECK WHETHER MAXIT FUNCTION VALUES HAVE BEEN CALCULATED.
   90 IT = IT+1
      IF(IT .GE. M)GO TO 10
      X = X2
      GO TO 20
C
C     TEST WHETHER A BRACKET HAS BEEN FOUND.
  100 IF(YA*Y .LT.0.0D0)GO TO 120
C
C     CONTINUE THE SEARCH FOR A BRACKET.
      IF(J3 .GE. J2)GO TO 110
      A = X
      YA = Y
      X2 = X+H
      J3 = J3+1
      GO TO 90
  110 A = X1
      YA = Y1
      H = 0.5D0*H
      J2 = J2+J2
      GO TO 80
C
C     AT THIS POINT THE FIRST BRACKET HAS BEEN FOUND.
  120 B = X
      YB = Y
      J1 = 4
C
C     CALCULATE THE NEXT X BY THE SECANT METHOD BASED ON THE BRACKET.
  130 IF(DABS(YA) .LE.DABS(YB))GO TO 140
      X1 = A
      Y1 = YA
      X = B
      Y = YB
      GO TO 150
  140 X1 = B
      Y1 = YB
      X = A
      Y = YA
C
C     USE THE SECANT METHOD BASED ON THE FUNCTION VALUES Y1 AND Y.
  150 U = Y*(X-X1)/(Y-Y1)
  155 X2 = X-U
      IF(X2.EQ.X)GO TO 195
      X1 = X
      Y1 = Y
      YTEST =.5D0*DMIN1(DABS(YA),DABS(YB))
C
C     CHECK THAT X2 IS INSIDE THE INTERVAL (A,B).
      IF((X2-A)*(X2-B) .LT. 0.0D0)GO TO 90
C
C     CALCULATE THE NEXT VALUE OF X BY BISECTION.
  160 X2 = 0.5D0*(A+B)
      YTEST = 0.D0
C
C     CHECK WHETHER THE MAXIMUM ACCURACY HAS BEEN ACHIEVED.
      IF((X2-A)*(X2-B))90,45,45
C
C     REVISE THE BRACKET (A,B).
  170 IF(YA*Y .GE.0.0D0)GO TO 180
      B = X
      YB = Y
      GO TO 190
  180 A = X
      YA = Y
C
C     USE YTEST TO DECIDE THE METHOD FOR THE NEXT VALUE OF X.
  190 IF(YTEST .LE.0.0D0)GO TO 130
      IF(DABS(Y) -YTEST)150,150,160
  195 IF(U.EQ.0.0D0)GO TO 45
      U = U+U
      GO TO 155
      END
C
C=======================================================================
C
C/     ADD NAME=FD05AD  HSL             IBM     DOUBLE
*######DATE   27 FEB 1989     COPYRIGHT UKAEA, HARWELL.
*######ALIAS FD05AD
      DOUBLE PRECISION FUNCTION FD05AD( INUM )
      INTEGER INUM
      DOUBLE PRECISION DC( 5 )
C
C  REAL CONSTANTS (DOUBLE PRECISION ARITHMETIC).
C
C  OBTAINED FROM H.S.L. SUBROUTINE ZE02AM.
C  NICK GOULD AND SID MARLOW, HARWELL, JULY 1988.
C
C  DC(1) THE SMALLEST POSITIVE NUMBER: 1.0 + DC(1) > 1.0.
C  DC(2) THE SMALLEST POSITIVE NUMBER: 1.0 - DC(2) < 1.0.
C  DC(3) THE SMALLEST NONZERO +VE REAL NUMBER.
C  DC(4) THE SMALLEST FULL PRECISION +VE REAL NUMBER.
C  DC(5) THE LARGEST FINITE +VE REAL NUMBER.
C
      DATA DC( 1 ) /    1.3877787807814458D-17 /
      DATA DC( 2 ) /    1.3877787807814458D-17 /
      DATA DC( 3 ) /    2.9387358770557189D-39 /
      DATA DC( 4 ) /    2.9387358770557189D-39 /
      DATA DC( 5 ) /    1.7014118346046922D+38 /
      IF ( INUM .LE. 0 .OR. INUM .GE. 6 ) THEN
         PRINT 2000, INUM
         STOP
      ELSE
         FD05AD = DC( INUM )
      ENDIF
      RETURN
 2000 FORMAT( ' INUM =', I3, ' OUT OF RANGE IN FD05AD.',
     *        ' EXECUTION TERMINATED.' )
      END
