C
C=======================================================================
      SUBROUTINE VSUPP( REQ , ACT , IER )
      IMPLICIT REAL*8(A-H,O-Z)
C
      CHARACTER*9 VERSON
      PARAMETER( VERSON = '08-MAY-98' )
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO OBTAIN THE VERSION OF THE 'SUPPORTZ' MODULE.
C
C INPUT   : (C*9) REQ    = REQUIRED VERSION.
C
C OUTPUT  : (C*9) ACT    = ACTUAL VERSION.
C           (I*4) IER    = 0 IF REQ =  ACT
C                        = 1 IF REQ <> ACT
C
C PROGRAM : (C*9) VERSON = VERSION
C
C AUTHOR  : JAMES SPENCE (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 09-DEC-91
C
C-----------------------------------------------------------------------
C
C..INPUT
      CHARACTER*(*)   REQ
C..OUTPUT
      CHARACTER*9     ACT
      INTEGER*4       IER
C
C.......................................................................
C
      ACT = VERSON
C
C.......................................................................
C
      IF( REQ.EQ.ACT ) THEN
          IER = 0
      ELSE
          IER = 1
      END IF
C
C.......................................................................
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE GETVER(IOUT , MODULE , SUBVER , REQVER , ACTVER , IER )
      IMPLICIT REAL*8(A-H,O-Z)
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO OBTAIN THE VERSION OF A MODULE.
C
C INPUT   : (I*4) IOUT    = 0 --- NO OUTPUT.
C                         > 0 --- CHANNEL STREAM.
C           (C**) MODULE  = NAME OF CODE MODULE.
C           (   ) SUBVER  = SUBROUTINE IN 'MODULE' FOR GETTING 'ACTVER'.
C           (C*9) REQVER  = REQUIRED VERSION OF MODULE.
C
C OUTPUT  : (C*9) ACTVER  = ACTUAL VERSION OF MODULE.
C           (I*4) IER     = 0 IF REQVER =  ACTVER.
C                         = 1 IF REQVER <> ACTVER.
C
C NOTE    : THE CONTROL ARGUEMENT IS 'SUBVER'.  'MODULE' IS FOR COSMETIC
C           REASONS.
C
C AUTHOR  : JAMES SPENCE (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 10-DEC-91
C
C-----------------------------------------------------------------------
C
C..INPUT
      INTEGER*4       IOUT
      CHARACTER*(*)   MODULE
      CHARACTER*(*)   REQVER
C..OUTPUT
      INTEGER*4       IER
      CHARACTER*9     ACTVER
C
C.......................................................................
C
      CALL SUBVER( REQVER , ACTVER , IER )
C
      IF( IOUT.GT.0 ) WRITE(IOUT,1000) MODULE , ACTVER , REQVER
C
C.......................................................................
C
 1000 FORMAT(' MODULE = ' , A , ' VERSION = ' , A , ' (REQUIRED VERSION
     &= ' , A , ')' )
C
C.......................................................................
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDX(NX,X,A,V,U,CHI,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C              D/DX ( A * V * ( CSI * U' +  (1-CSI) * U) )  IN X(I)  AS
C
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2       PERIODICITY
C     WHERE
C           A(I), U(I), U'(I) ARE DEFINED AT X(I),
C           V(I) IS DEFINED AT (X(I-1)+X(I))/2  (I.E. IS STAGGERED)
C
C               1   2       I  I+1          N  N+1
C           V:  #   #   #   #   #   #   #   #   #
C           X: --+----+---+---+---+---+---+---+---
C           U:    *   *   *   *   *   *   *   *
C                 1   2       I          N-1  N
C     N.B.:
C     CENTERED (NOT CENTRAL !!) DERIVATIVES ARE OBTAINED BY
C              DEFINING  CHI(I)=(X(I)-X(I-1))/(X(I+1)-X(I-1))
C
      DIMENSION X(NX),A(NX),V(NX+1),U(NX),CHI(NX),ALPHA(4,NX)
C
C
      NXM1=NX-1
      UMCSI=1.0-CSI
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      GOTO (20,10), MODE
C                    PERIODICITY
C                         (BACKWARD/CENTRAL/FORWARD)
   10 CONTINUE
      I0=1
      GOTO 40
C
C
   20 CONTINUE
C                    GIVEN BOUNDARY CONDITIONS
      I0=2
C                    X(1) FORWARD (CHI(1)=1)
      HP = X(2)-X(1)
      CHID=1.0/HP
      B2=A(1)*(V(1)+V(2))
      BP=(A(1)+A(2))*V(2)*0.5
      Q=CHID*(BP-B2)
      P=CHID*BP
      ALPHA(1,1)=0.0
      ALPHA(2,1)=Q*CSI
      ALPHA(3,1)=P*CSI
      ALPHA(4,1)=UMCSI*(Q*U(1)+P*U(2))
C                    X(NX) BACKWARD (CHI(NX)=0)
      HM = X(NX)-X(NXM1)
      BM=(A(NXM1)+A(NX))*V(NX)*0.5
      B2=A(NX)*(V(NX)+V(NX+1))
      UMCHID= 1.0/HM
      R=-UMCHID*BM
      Q= UMCHID*(B2-BM)
      ALPHA(1,NX)=R*CSI
      ALPHA(2,NX)=Q*CSI
      ALPHA(3,NX)=0.0
      ALPHA(4,NX)=UMCSI*(R*U(NXM1)+Q*U(NX))
C
C                    X(2) TO X(NX-1) BACKWARD/CENTRAL/FORWARD
   40 DO 50 I=I0,NXM1
      IF( I.GT.1 )THEN
        IM1=I-1
      ELSE
        IM1=NXM1
      ENDIF
      IP1=I+1
      HM = CVMGT(X(I)-X(IM1),X(NX)-X(NXM1),I.GT.1)
      HP = X(IP1)-X(I)
      CHID=CHI(I)/HP
      UMCHID=(1.0-CHI(I))/HM
      BM=(A(IM1)+A(I))*V(I)*0.5
      B2=A(I)*(V(I)+V(IP1))
      BP=(A(I)+A(IP1))*V(IP1)*0.5
      R=-UMCHID*BM
      Q=CHID*(BP-B2) + UMCHID*(B2-BM)
      P=CHID*BP
      ALPHA(1,I)=R*CSI
      ALPHA(2,I)=Q*CSI
      ALPHA(3,I)=P*CSI
      ALPHA(4,I)=UMCSI*(R*U(IM1)+Q*U(I)+P*U(IP1))
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDXU(NX,X,A,VH,VI,U,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C              D/DX ( A * V * ( CSI * U' +  (1-CSI) * U) )  IN X(I)  AS
C
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C       WITH AUTOMATIC UPWIND ACCORDING TO THE DIRECTION OF V,
C            ----------------
C       SUITABLE FOR AN EQUATION OF THE TYPE (CONTINUITY) :
C
C              DU     D
C         H * ---- = --- (  A * V * U )           WHEN  A<0 IF H>0
C              DT     DX
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2       PERIODICITY
C     WHERE
C           A(I), U(I), U'(I) ARE DEFINED AT X(I),
C           V(I) IS DEFINED AT (X(I-1)+X(I))/2  (I.E. IS STAGGERED)
C                           AS  V(I) = VH(I) + (VI(I-1)+VI(I))/2
C
C               1   2       I  I+1          N  N+1
C           V:  #   #   #   #   #   #   #   #   #
C           X: ---+---+---+---+---+---+---+---+---
C           U:    *   *   *   *   *   *   *   *
C                 1   2       I          N-1  N
C
C
C     N.B.:
C
C  1) IN CASE OF GIVEN BOUNDARY CONDITIONS IT IS ASSUMED THAT
C             X(1-1/2)=X(1)-(X(NX)-X(NX-1)/2
C             X(NX+1/2)=X(NX)+(X(2)-X(1))/2
C             (SAME ONES AS THOSE IMPOSED BY PERIODICITY)
C
C
C  2) COEFFICIENTS ALPHA ARE RETURNED AT I=1 AND I=NX TOO,
C     COMPUTED BY UPWIND UNDER THE HYPOTHESIS THAT  V(1)<0, V(N)>0
C
C
C  3) CONSERVATION
C
C         A) INTEGRATION FROM X(1) TO X(N)  :
C            (ASSUMING V(1/2).LE.0, V(N+1/2).GE.0)
C    SUM(J:J=1,N)  (D(A*V*U)/DX)(J) * DX(J)  =  F(1)+F(N)
C           WHERE  DX(1)=X(1/2)-X(1)
C                  DX(J)=X(J+1/2)-X(J-1/2)        J=2,N-1
C                  DX(N)=X(N)-X(N-1/2)
C             AND  F(1)= -(A(1)*V(1/2)*U(1)+A(2)*V(3/2)*U(2))/2
C                  F(N)=  (A(N-1)*V(N-1/2)*U(N-1)+A(N)*V(N+1/2)*U(N))/2
C
C         B) INTEGRATION FROM X(L) TO X(R)  :
C            (L>1,R<N OR PERIODICITY)
C    SUM(J:J=L,R)  (D(A*V*U)/DX)(J) * DX(J)  =  F(L)+F(R)
C           WHERE  DX(J)=X(J+1/2)-X(J-1/2)        J=L,R
C             AND  F(L)= -1/2*( A(L-1)*U(L-1)*(V(L-1/2)+DABS(V(L-1/2)))+
C                              +A(L  )*U(L  )*(V(L-1/2)-DABS(V(L-1/2))))
C                  F(R)=  1/2*( A(R  )*U(R  )*(V(R+1/2)+DABS(V(R+1/2)))+
C                              +A(R+1)*U(R+1)*(V(R+1/2)-DABS(V(R+1/2))))
C
C
      DIMENSION X(NX),A(NX),VH(NX+1),VI(NX),U(NX),ALPHA(4,NX)
C
      DIMENSION V(201)
C
      NXM1=NX-1
      NXP1=NX+1
      UMCSI=1.0-CSI
C
      DO 2 I=2,NX
      V(I)=VH(I)+(VI(I-1)+VI(I))*0.5
    2 CONTINUE
      IF(MODE.EQ.1) THEN
        V(1)=VH(1)+VI(1)
        V(NXP1)=VH(NXP1)+VI(NX)
        ELSE
        V(1)=VH(1)+(VI(NXM1)+VI(NX))*0.5
C ABOVE V(NX)=V(1)
        V(NXP1)=V(2)
        END IF
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      GOTO (20,10), MODE
C                    PERIODICITY
C                         (BACKWARD/CENTRAL/FORWARD)
   10 CONTINUE
      I0=1
      GOTO 40
C
C
   20 CONTINUE
C                    GIVEN BOUNDARY CONDITIONS
      I0=2
C                    X(1) FORWARD
      H2=((X(2)-X(1))+(X(NX)-X(NXM1)))
      A0=A(1)
      AP=A(2)
      VM=V(1)
      VP=V(2)
      Q= A0*( (VP+DABS(VP)) - (VM-DABS(VM)) )/H2
      P= AP*(VP-DABS(VP))/H2
      ALPHA(1,1)=0.0
      ALPHA(2,1)=Q*CSI
      ALPHA(3,1)=P*CSI
      ALPHA(4,1)=UMCSI*(Q*U(1)+P*U(2))
C                    X(NX) BACKWARD
      AM=A(NXM1)
      A0=A(NX)
      VM=V(NX)
      VP=V(NXP1)
      R=-AM*(VM+DABS(VM))/H2
      Q= A0*( (VP+DABS(VP)) - (VM-DABS(VM)) )/H2
      ALPHA(1,NX)=R*CSI
      ALPHA(2,NX)=Q*CSI
      ALPHA(3,NX)=0.0
      ALPHA(4,NX)=UMCSI*(R*U(NXM1)+Q*U(NX))
C
C                    X(2) TO X(NX-1) BACKWARD/CENTRAL/FORWARD
   40 DO 50 I=I0,NXM1
      IF( I.GT.1 )THEN
        IM1=I-1
      ELSE
        IM1=NXM1
      ENDIF
      IP1=I+1
      HM = CVMGT(X(I)-X(IM1),X(NX)-X(NXM1),I.GT.1)
      HP = X(IP1)-X(I)
      H2= HM+HP
      AM=A(IM1)
      A0=A(I)
      AP=A(IP1)
      VM=V(I)
      VP=V(IP1)
      R=-AM*(VM+DABS(VM))/H2
      Q= A0*( (VP+DABS(VP)) - (VM-DABS(VM)) )/H2
      P= AP*(VP-DABS(VP))/H2
      ALPHA(1,I)=R*CSI
      ALPHA(2,I)=Q*CSI
      ALPHA(3,I)=P*CSI
      ALPHA(4,I)=UMCSI*(R*U(IM1)+Q*U(I)+P*U(IP1))
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDXO(NX,X,A,V,U,CHI,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C              D/DX ( A * V * ( CSI * U' +  (1-CSI) * U) )  IN X(I)  AS
C
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2       PERIODICITY
C     WHERE
C           A(I), U(I), U'(I) ARE DEFINED AT X(I),
C           V(I) IS DEFINED AT (X(I-1)+X(I))/2  (I.E. IS STAGGERED)
C
C               1   2       I  I+1          N  N+1
C           V:  #   #   #   #   #   #   #   #   #
C           X: --+----+---+---+---+---+---+---+---
C           U:    *   *   *   *   *   *   *   *
C                 1   2       I          N-1  N
C     N.B.:
C     CENTERED (NOT CENTRAL !!) DERIVATIVES ARE OBTAINED BY
C              DEFINING  CHI(I)=(X(I)-X(I-1))/(X(I+1)-X(I))
C
      DIMENSION X(NX),A(NX),V(NX+1),U(NX),CHI(NX),ALPHA(4,NX)
C
      PARAMETER (MX=85)
      DIMENSION VC(MX),XS(MX)
C
C
      NXM1=NX-1
      UMCSI=1.0-CSI
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      XS(1)=X(1)-(X(2)-X(1))*0.5
      DO 6 I=2,NX
      XS(I)=X(I-1)+(X(I)-X(I-1))*0.5
    6 CONTINUE
      XS(NX+1)=X(NX)+(X(NX)-X(NXM1))*0.5
      DO 7 I=1,NX
      VC(I)=V(I)+(V(I+1)-V(I))/(XS(I+1)-XS(I))*(X(I)-XS(I))
    7 CONTINUE
C
      GOTO (20,10), MODE
C                    PERIODICITY
C                         (BACKWARD/CENTRAL/FORWARD)
   10 CONTINUE
      I0=1
      GOTO 40
C
C
   20 CONTINUE
C                    GIVEN BOUNDARY CONDITIONS
      I0=2
C                    X(1) FORWARD (CHI(1)=1)
      HP = X(2)-X(1)
      CHID=1.0/HP
      Q=-CHID*(A(1)*VC(1))
      P=CHID*(A(2)*VC(2))
      ALPHA(1,1)=0.0
      ALPHA(2,1)=Q*CSI
      ALPHA(3,1)=P*CSI
      ALPHA(4,1)=UMCSI*(Q*U(1)+P*U(2))
C                    X(NX) BACKWARD (CHI(NX)=0)
      HM = X(NX)-X(NXM1)
      UMCHID= 1.0/HM
      R=-UMCHID*(A(NXM1)*VC(NXM1))
      Q= UMCHID*(A(NX)*VC(NX))
      ALPHA(1,NX)=R*CSI
      ALPHA(2,NX)=Q*CSI
      ALPHA(3,NX)=0.0
      ALPHA(4,NX)=UMCSI*(R*U(NXM1)+Q*U(NX))
C
C                    X(2) TO X(NX-1) BACKWARD/CENTRAL/FORWARD
   40 DO 50 I=I0,NXM1
      IF( I.GT.1 )THEN
        IM1=I-1
      ELSE
        IM1=NXM1
      ENDIF
      IP1=I+1
      HM = CVMGT(X(I)-X(IM1),X(NX)-X(NXM1),I.GT.1)
      HP = X(IP1)-X(I)
      CHID=CHI(I)/HP
      UMCHID=(1.0-CHI(I))/HM
      BM=A(IM1)*VC(IM1)
      B0=A(I)*VC(I)
      BP=A(IP1)*VC(IP1)
      R=-UMCHID*BM
      Q=(-CHID+UMCHID)*B0
      P=CHID*BP
      ALPHA(1,I)=R*CSI
      ALPHA(2,I)=Q*CSI
      ALPHA(3,I)=P*CSI
      ALPHA(4,I)=UMCSI*(R*U(IM1)+Q*U(I)+P*U(IP1))
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDX2(NX,X,A,C,U,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C       D/DX ( A * D/DX ( C * UCSI ) )    WITH UCSI = CSI*U'+(1-CSI)*U
C
C     AS:
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2       PERIODICITY
C
      DIMENSION X(NX),A(NX),C(NX),U(NX),ALPHA(4,NX)
C
C
      NXM1=NX-1
      UMCSI=1.0-CSI
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      GOTO (30,10), MODE
C
   10 CONTINUE
C                   X(1) (=X(NX)) FOR PERIODICITY
      HM = X(NX)-X(NXM1)
      HP = X(2)-X(1)
      H  = (HM+HP)*0.5
      AM=(A(NXM1)+A(NX))*0.5
      AP=(A(1)+A(2))*0.5
      BM=AM*C(NXM1)/(H*HM)
      B0=-(AP/HP+AM/HM)*C(1)/H
      BP=AP*C(2)/(H*HP)
      ALPHA(1,1)=BM*CSI
      ALPHA(2,1)=B0*CSI
      ALPHA(3,1)=BP*CSI
      ALPHA(4,1)=UMCSI*(BM*U(NXM1)+B0*U(1)+BP*U(2))
      DO 20 K=1,4
      ALPHA(K,NX)=ALPHA(K,1)
   20 CONTINUE
      GOTO 50
C
   30 CONTINUE
C                    DUMMY X(1) AND X(NX) FOR GIVEN BOUNDARY CONDITIONS
      DO 40 K=1,4
      ALPHA(K,NX)=0.0
      ALPHA(K,1 )=0.0
   40 CONTINUE
C                    X(2) TO X(NX-1)
   50 DO 60 I=2,NXM1
      HM = X(I)-X(I-1)
      HP = X(I+1)-X(I)
      H  = (X(I+1)-X(I-1))*0.5
      AM=(A(I-1)+A(I))*0.5
      AP=(A(I)+A(I+1))*0.5
      BM=AM*C(I-1)/(H*HM)
      B0=-(AP/HP+AM/HM)*C(I)/H
      BP=AP*C(I+1)/(H*HP)
      ALPHA(1,I)=BM*CSI
      ALPHA(2,I)=B0*CSI
      ALPHA(3,I)=BP*CSI
      ALPHA(4,I)=UMCSI*(BM*U(I-1)+B0*U(I)+BP*U(I+1))
   60 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDXCVX(NX,X,A,V,U,CSI, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C           (A(I+1)*(V(I+1)*U(I)+V(I)*U(I+1))*0.5
C                           -A(I)*(V(I-1)*U(I)+V(I)*U(I-1))*0.5)/H
C
C
C              D/DX ( A * V * ( CSI * U' +  (1-CSI) * U) )  IN X(I)  AS
C
C
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C
C     WHERE
C           A(I), V(I), U(I), U'(I) ARE DEFINED AT X(I)
C
      DIMENSION X(NX),A(NX),V(NX),U(NX),ALPHA(4,NX)
C
C
      NXM1=NX-1
      UMCSI=1.0-CSI
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      I0=2
C
C                    X(2) TO X(NX-1) BACKWARD/CENTRAL/FORWARD
   40 DO 50 I=I0,NXM1
      IM1=I-1
      IP1=I+1
      H=(X(I+1)-X(I-1))*0.5
      BM=-A(I)*V(I)*0.5
      B0=A(IP1)*V(IP1)*0.5-A(I)*V(IM1)*0.5
      BP=A(IP1)*V(I)*0.5
      R=BM/H
      Q=B0/H
      P=BP/H
      ALPHA(1,I)=R*CSI
      ALPHA(2,I)=Q*CSI
      ALPHA(3,I)=P*CSI
      ALPHA(4,I)=UMCSI*(R*U(IM1)+Q*U(I)+P*U(IP1))
   50 CONTINUE
      RETURN
      END
C
C=======================================================================
      SUBROUTINE DDX22(NX,X,A,C,D,U,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C       D/DX ( A * C* D/DX (  UCSI ) )    WITH UCSI = CSI*U'+(1-CSI)*U
C
C     AS:
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2       PERIODICITY
C
      DIMENSION X(NX),A(NX),C(NX),D(NX),U(NX),ALPHA(4,NX)
C
C
      NXM1=NX-1
      UMCSI=1.0-CSI
C
      DO 5 K=1,4
      DO 5 I=1,NX
      ALPHA(K,I)=0.0
    5 CONTINUE
C
      GOTO (30,10), MODE
C
   10 CONTINUE
C                   X(1) (=X(NX)) FOR PERIODICITY
      HM = X(NX)-X(NXM1)
      HP = X(2)-X(1)
      H  = (HM+HP)*0.5
      AM=(A(NXM1)+A(NX))*0.5
      AP=(A(1)+A(2))*0.5
C
      CM=(C(NXM1)+C(NX))*0.5
      CP=(C(1)+C(2))*0.5
C
      DM=D(NXM1)
      DP=D(1)
C
      BM=AM*CM*DM/(H*HM)
      B0=-(AP*CP*DP/HP+AM*CM*DM/HM)/H
      BP=AP*CP*DP/(H*HP)
      ALPHA(1,1)=BM*CSI
      ALPHA(2,1)=B0*CSI
      ALPHA(3,1)=BP*CSI
      ALPHA(4,1)=UMCSI*(BM*U(NXM1)+B0*U(1)+BP*U(2))
      DO 20 K=1,4
      ALPHA(K,NX)=ALPHA(K,1)
   20 CONTINUE
      GOTO 50
C
   30 CONTINUE
C                    DUMMY X(1) AND X(NX) FOR GIVEN BOUNDARY CONDITIONS
      DO 40 K=1,4
      ALPHA(K,NX)=0.0
      ALPHA(K,1 )=0.0
   40 CONTINUE
C                    X(2) TO X(NX-1)
   50 DO 60 I=2,NXM1
      HM = X(I)-X(I-1)
      HP = X(I+1)-X(I)
      H  = (X(I+1)-X(I-1))*0.5
      AM=(A(I-1)+A(I))*0.5
      AP=(A(I)+A(I+1))*0.5
C
      CM=(C(I-1)+C(I))*0.5
      CP=(C(I)+C(I+1))*0.5
C
      DM=D(I)
      DP=D(I+1)
C
      BM=AM*CM*DM/(H*HM)
      B0=-(AP*CP*DP/HP+AM*CM*DM/HM)/H
      BP=AP*CP*DP/(H*HP)
      ALPHA(1,I)=BM*CSI
      ALPHA(2,I)=B0*CSI
      ALPHA(3,I)=BP*CSI
      ALPHA(4,I)=UMCSI*(BM*U(I-1)+B0*U(I)+BP*U(I+1))
   60 CONTINUE
      RETURN
      END
C ======================== PEM:UTIL.CRAYLIB ==========================
C
C=======================================================================
      SUBROUTINE HEADER(IWT,TIT,AUT,VERS)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TIT,AUT,VERS
C
       WRITE(IWT,10)
   10  FORMAT(1H1,132('*'))
       CALL CDATE(IWT)
       WRITE(IWT,20)TIT
   20  FORMAT(///,45X,'PROGRAM: ',A)
       WRITE(IWT,30)AUT
   30  FORMAT(/,' AUTHOR(S): ',A)
       WRITE(IWT,40)VERS
   40  FORMAT(//,' VERSION : ',A)
       CALL CPUTIM(IWT)
       WRITE(IWT,50)
   50  FORMAT(//,1X,132('*'))
C
       RETURN
      END
C
C=======================================================================
      SUBROUTINE PRRMAT(A,IDIMA,IDIM1,IDIM2,IWT,TIT)
      IMPLICIT REAL*8(A-H,O-Z)
C PRINT OF REAL MATRIX A
C INPUT
C -------
C BY ARGUMENT-LIST:
C    A        - MATRIX OF DIMENSION A(IDIMA,IDIM2)
C               FIRST DIMENSION IS OCCUPIED ONLY WITH IDIM1 ELEMENTS
C    IDIMA    - LEADING DIMENSION OF A
C    IDIM1    - NUMBER OF ROWS OF A
C    IDIM2    - NUMBER OF COLUMNS OF A
C    IWT      - OUTPUT-CHANNEL FOR PRINTOUT
C    TIT      - CHARACTER STRING FOR TITLE
C=======================================================================
      DIMENSION A(IDIMA,IDIM2)
      CHARACTER*(*) TIT
      DATA INUM/9/
C INUM = NUMBER OF COLUMNS ON PAGE
C
      WRITE(IWT,50)TIT
C
      IF(IDIM2.GT.1)GOTO 20
         I1=1
         I2=0
         NR=IDIM1
         IN=(IDIM1-1)/INUM+1
         DO 10 II=1,IN
            I2=I2+INUM
            IF(NR.LT.INUM)I2=I2-INUM+NR
            NR=NR-INUM
            WRITE(IWT,80)(I,I=I1,I2)
            WRITE(IWT,80)
            WRITE(IWT,70)(A(I,1),I=I1,I2)
   10       I1=I1+INUM
         GOTO 90
C
   20 N1=1
      N=0
      NR=IDIM2
      IN=(IDIM2-1)/INUM +1
      DO 40 II=1,IN
         N=N+INUM
         IF (NR .LT. INUM ) N=N-INUM+NR
         NR=NR-INUM
         WRITE(IWT,80)(J,J=N1,N)
         WRITE(IWT,80)
         DO 30 I=1,IDIM1
   30       WRITE(IWT,60)I,(A(I,J),J=N1,N)
         N1=N1+INUM
   40    CONTINUE
C
   50 FORMAT(////,1X,A/1X,132('-'))
   60 FORMAT(1X,I4,   2X,1P,9E13.5)
   70 FORMAT(7X,1P,9E13.5)
   80 FORMAT(/,11X, 9(I4,9X))
   90 RETURN
      END
C
C=======================================================================
      SUBROUTINE PRNMAT(A,IDIMA,IDIM1,IDIM2,ILC,JFP,JLP,LAVCOL
     &                 ,IWT,TIT,UNDEF)
      IMPLICIT REAL*8(A-H,O-Z)
C PRINT OF REAL MATRIX A
C INPUT
C -------
C BY ARGUMENT-LIST:
C    A        - MATRIX OF DIMENSION A(IDIMA,IDIM2)
C               FIRST DIMENSION IS OCCUPIED ONLY WITH IDIM1 ELEMENTS
C    IDIMA    - LEADING DIMENSION OF A
C    IDIM1    - NUMBER OF ROWS OF A
C    IDIM2    - NUMBER OF COLUMNS OF A
C    ILC      - LAST CLOSED I-LINE OF A
C    JFP      - FIRST PERIODIC J OF A
C    JLP      - LAST  PERIODIC J OF A
C    LAVCOL   - .T. : AVERAGE COL. (=LAST COL.) & MUST BE HIGHLIGHTED
C    IWT      - OUTPUT-CHANNEL FOR PRINTOUT
C    TIT      - CHARACTER STRING FOR TITLE
C    UNDEF    - 'UNDEFINED' REAL NUMBER - PRINTED AS  'U'
C=======================================================================
      DIMENSION A(IDIMA,IDIM2)
      CHARACTER*124 LINE
      CHARACTER*13 CINDEF,STAR,CORE,BLANK
      LOGICAL LAVCOL
      DATA STAR /'       U     '/
      DATA CORE /'.............'/
      DATA BLANK/'             '/
      CHARACTER*(*) TIT
      DATA INUM/9/
C INUM = NUMBER OF COLUMNS ON PAGE
C
      WRITE(CINDEF,100) UNDEF
C
      WRITE(IWT,50)TIT
C
      IF(IDIM2.GT.1)GOTO 20
         I1=1
         I2=0
         NR=IDIM1
         IN=(IDIM1-1)/INUM+1
         DO 10 II=1,IN
            I2=I2+INUM
            IF(NR.LT.INUM)I2=I2-INUM+NR
            NR=NR-INUM
            WRITE(IWT,80) (I,I=I1,I2)
            WRITE(IWT,80)
            WRITE(LINE,70)(A(I,1),I=I1,I2)
            DO 5 L=1,INUM
               L1=8+(L-1)*13
               L2=L1+12
               IF(LINE(L1:L2).EQ.CINDEF) LINE(L1:L2)=STAR
    5       CONTINUE
            WRITE(IWT,90) LINE
            I1=I1+INUM
   10    CONTINUE
         GOTO 45
C
   20 N1=1
      N=0
      NR=IDIM2
      IN=(IDIM2-1)/INUM +1
      DO 40 II=1,IN
         N=N+INUM
         IF (NR .LT. INUM ) N=N-INUM+NR
C
         WRITE(LINE,85) (J,J=N1,N)
         IF( LAVCOL .AND. N.EQ.IDIM2 ) THEN
             L1=8+(NR-1)*13
             LINE(L1:L1)=CORE(1:1)
             WRITE(IWT,95) LINE(1:L1) // '     SOL   '
         ELSE
             WRITE(IWT,95) LINE
         END IF
C
         IF( LAVCOL .AND. N.EQ.IDIM2 ) THEN
             WRITE(LINE,87) (BLANK,J=N1,N)
             L1=8+(NR-1)*13
             L2=L1+12
             LINE(L1:L2)=CORE(1:1)
             WRITE(IWT,90) LINE(1:L1) // '   AVERAGE'
             WRITE(IWT,90) LINE(1:L1)
         ELSE
             WRITE(IWT,95)
         END IF
C
         DO 30 I=1,IDIM1
            WRITE(LINE,60)I,(A(I,J),J=N1,N)
            DO 25 L=1,INUM
               L1=8+(L-1)*13
               L2=L1+12
               IF(LINE(L1:L2).EQ.CINDEF) LINE(L1:L2)=STAR
   25       CONTINUE
            IF( LAVCOL .AND. N.EQ.IDIM2 ) THEN
                L1=8+(NR-1)*13
                LINE(L1:L1)=CORE(1:1)
            END IF
            IF( I.EQ.JFP .AND. N1.LE.ILC )
     &          WRITE(IWT,110) (CORE,J=N1,MIN0(N,ILC))
            WRITE(IWT,90) LINE
            IF( I.EQ.JLP .AND. N1.LE.ILC )
     &          WRITE(IWT,110) (CORE,J=N1,MIN0(N,ILC))
   30    CONTINUE
         N1=N1+INUM
         NR=NR-INUM
   40 CONTINUE
C
   45 RETURN
C
   50 FORMAT(////,1X,A/1X,132('-'))
   60 FORMAT(1X,I4,   2X,1P,9E13.5)
   70 FORMAT(7X,1P,9E13.5)
   80 FORMAT(/7X, 9(I4,9X))
   85 FORMAT(7X, 9(I4,9X))
   87 FORMAT(7X, 9(A))
   90 FORMAT(A)
   95 FORMAT(/A)
  100 FORMAT(1P,E13.5)
  110 FORMAT(7X,9(A))
      END
C
C=======================================================================
      SUBROUTINE PRUMAT(A,IDIMA,IDIM1,IDIM2,IWT,TIT,UNDEF)
      IMPLICIT REAL*8(A-H,O-Z)
C PRINT OF REAL MATRIX A
C INPUT
C -------
C BY ARGUMENT-LIST:
C    A        - MATRIX OF DIMENSION A(IDIMA,IDIM2)
C               FIRST DIMENSION IS OCCUPIED ONLY WITH IDIM1 ELEMENTS
C    IDIMA    - LEADING DIMENSION OF A
C    IDIM1    - NUMBER OF ROWS OF A
C    IDIM2    - NUMBER OF COLUMNS OF A
C    IWT      - OUTPUT-CHANNEL FOR PRINTOUT
C    TIT      - CHARACTER STRING FOR TITLE
C    UNDEF    - 'UNDEFINED' REAL NUMBER - PRINTED AS  'U'
C=======================================================================
      DIMENSION A(IDIMA,IDIM2)
      CHARACTER*124 LINE
      CHARACTER*13 CINDEF,STAR
      DATA STAR /'       U     '/
      CHARACTER*(*) TIT
      DATA INUM/9/
C INUM = NUMBER OF COLUMNS ON PAGE
C
      WRITE(CINDEF,100) UNDEF
C
      WRITE(IWT,50)TIT
C
      IF(IDIM2.GE.1)GOTO 20
         I1=1
         I2=0
         NR=IDIM1
         IN=(IDIM1-1)/INUM+1
         DO 10 II=1,IN
            I2=I2+INUM
            IF(NR.LT.INUM)I2=I2-INUM+NR
            NR=NR-INUM
            WRITE(IWT,80)(I,I=I1,I2)
            WRITE(IWT,80)
            WRITE(LINE,70)(A(I,1),I=I1,I2)
            DO 5 L=1,INUM
               L1=8+(L-1)*13
               L2=L1+12
               IF(LINE(L1:L2).EQ.CINDEF) LINE(L1:L2)=STAR
    5       CONTINUE
            WRITE(IWT,90) LINE
            I1=I1+INUM
   10    CONTINUE
         GOTO 45
C
   20 N1=1
      N=0
      NR=IDIM2
      IN=(IDIM2-1)/INUM +1
      DO 40 II=1,IN
         N=N+INUM
         IF (NR .LT. INUM ) N=N-INUM+NR
         NR=NR-INUM
         WRITE(IWT,80)(J,J=N1,N)
         WRITE(IWT,80)
         DO 30 I=1,IDIM1
            WRITE(LINE,60)I,(A(I,J),J=N1,N)
            DO 25 L=1,INUM
               L1=8+(L-1)*13
               L2=L1+12
               IF(LINE(L1:L2).EQ.CINDEF) LINE(L1:L2)=STAR
   25       CONTINUE
            WRITE(IWT,90) LINE
   30    CONTINUE
         N1=N1+INUM
   40 CONTINUE
C
   45 RETURN
C
   50 FORMAT(////,1X,A/1X,132('-'))
   60 FORMAT(1X,I4,   2X,1P,9E13.5)
   70 FORMAT(7X,1P,9E13.5)
   80 FORMAT(/,7X, 9(I4,9X))
   90 FORMAT(A)
  100 FORMAT(1P,E13.5)
      END
C
C=======================================================================
      SUBROUTINE PRRVAR(IWT, VAL,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TEXT
       WRITE(IWT,10)TEXT, VAL
   10  FORMAT(1X,A,' = ',1PE12.5)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE PRIVAR(IWT,IVAL,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TEXT
       WRITE(IWT,10)TEXT,IVAL
   10  FORMAT(1X,A,' = ',I12)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE PRRVEC(IWT,VAL,N,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TEXT
       DIMENSION  VAL(N)
       CHARACTER*1 DASH(120)
       DATA DASH/120*'-'/
       L=LEN(TEXT)
       WRITE(IWT,10)TEXT,(DASH(K),K=1,L)
   10  FORMAT(/1X,A/1X,120A1)
       WRITE(IWT,20)( I,VAL(I),I=1,N)
   20  FORMAT(' (',I3,',',1P,E12.5,')',2X,'(',I3,',',E12.5,')',2X,
     *         '(',I3,',',   E12.5,')',2X,'(',I3,',',E12.5,')',2X,
     *         '(',I3,',',   E12.5,')',2X,'(',I3,',',E12.5,')'   )
       RETURN
      END
C
C=======================================================================
      SUBROUTINE PRIVEC(IWT,IAL,N,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TEXT
       DIMENSION  IAL(N)
       CHARACTER*1 DASH(120)
       DATA DASH/120*'-'/
       L=LEN(TEXT)
       WRITE(IWT,10)TEXT,(DASH(K),K=1,L)
   10  FORMAT(/1X,A/1X,120A1)
       WRITE(IWT,20)( IAL(I),I=1,N)
   20  FORMAT(1X,20I5)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE MESAGE(IWT,TIT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*)TIT
       WRITE(IWT,10)TIT
   10  FORMAT(/1X,A)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE RESET4(V,N,A)
      IMPLICIT REAL*4(A-H,O-Z)
C
       DIMENSION V(N)
C
       IF(N.LE.0) RETURN
       DO 10 I=1,N
       V(I)=A
   10  CONTINUE
       RETURN
      END
C
C=======================================================================
      SUBROUTINE RESETR(V,N,A)
      IMPLICIT REAL*8(A-H,O-Z)
C
       DIMENSION V(N)
C
       IF(N.LE.0) RETURN
       DO 10 I=1,N
       V(I)=A
   10  CONTINUE
       RETURN
      END
C
C=======================================================================
      SUBROUTINE RESETI(IV,N,IA)
      IMPLICIT REAL*8(A-H,O-Z)
C
       DIMENSION IV(N)
C
       IF(N.LE.0) RETURN
       DO 10 I=1,N
       IV(I)=IA
   10  CONTINUE
       RETURN
      END
C
C=======================================================================
      SUBROUTINE BYEBYE(IWT,TEXT)
      IMPLICIT REAL*8(A-H,O-Z)
       CHARACTER*(*) TEXT
C
       WRITE(IWT,10)
   10  FORMAT(////,1X,132('*'))
       WRITE(IWT,20)TEXT
   20  FORMAT(    ' PROGRAM <',A,'> ENDED')
       CALL CPUTIM(IWT)
       CALL CDATE(IWT)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE EXITX(IWT)
      IMPLICIT REAL*8(A-H,O-Z)
C
      CALL EXITRC(IWT,10)
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE EXITRC(IWT,ISTOP)
      IMPLICIT REAL*8(A-H,O-Z)
C
      CALL BYEBYE(IABS(IWT),'ABNORMALLY')
      CALL GENEXIT(ISTOP)
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CPUTIM(IWT)
      IMPLICIT REAL*8(A-H,O-Z)
C
C      WRITES THE CPU TIME ELAPSED SINCE FIRST CALL
C
       EXTERNAL SECOND
C
       COMMON /COMCPU/ TBASE , TCPU
C
       DIMENSION NSEC(2),NMIN(2),NHOU(2)
C
       LOGICAL   START
CX     SAVE      START,TBASE
       SAVE      START
       DATA      START /.TRUE./
C
       CALL SECOND (TIME)
       TCPU = TIME
C
       IF(START) THEN
       TBASE=TIME
       START=.FALSE.
       RETURN
                 ELSE
       NSEC(2)=(TIME-TBASE)+0.5
       NMIN(2)=NSEC(2)/60
       NSEC(2)=NSEC(2)-NMIN(2)*60
       NHOU(2)=NMIN(2)/60
       NMIN(2)=NMIN(2)-NHOU(2)*60
C
       NSEC(1)=NSEC(2)/10
       NSEC(2)=NSEC(2)-NSEC(1)*10
       NMIN(1)=NMIN(2)/10
       NMIN(2)=NMIN(2)-NMIN(1)*10
       NHOU(1)=NHOU(2)/10
       NHOU(2)=NHOU(2)-NHOU(1)*10
C
       IF( IWT.GT.0 ) WRITE(IWT, 10) NHOU,NMIN,NSEC
   10  FORMAT(/   ' CPU TIME: ',I2,I1,':',2I1,':',2I1)
                 END IF
C
       RETURN
      END
C
C=======================================================================
      SUBROUTINE CPUFMT(CPUS,CPUSTR)
      IMPLICIT REAL*8(A-H,O-Z)
C
C      GIVEN CPU TIME IN SECS RETURNS FORMATTED STRING 'HHH:MM:SS'
C
C
       CHARACTER CPUSTR*(*)
       DIMENSION NSEC(2),NMIN(2),NHOU(2)
C
       NSEC(2)=CPUS+0.5
       NMIN(2)=NSEC(2)/60
       NSEC(2)=NSEC(2)-NMIN(2)*60
       NHOU(2)=NMIN(2)/60
       NMIN(2)=NMIN(2)-NHOU(2)*60
C
       NSEC(1)=NSEC(2)/10
       NSEC(2)=NSEC(2)-NSEC(1)*10
       NMIN(1)=NMIN(2)/10
       NMIN(2)=NMIN(2)-NMIN(1)*10
       NHOU(1)=NHOU(2)/10
       NHOU(2)=NHOU(2)-NHOU(1)*10
C
       WRITE(CPUSTR, 10) NHOU,NMIN,NSEC
   10  FORMAT(I3,I1,':',2I1,':',2I1)
C
       RETURN
      END
C
C=======================================================================
      SUBROUTINE CPUREM(SECS)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*4 TSECS
C
C      REMAINING CPU TIME
C
       CALL TREMAINJ(TSECS)
       SECS = TSECS
       RETURN
      END
C
C=======================================================================
C     SUBROUTINE SETMEM(BEGIN,END,VALUE)
C     IMPLICIT REAL*8(A-H,O-Z)
C     DIMENSION BEGIN(*),END(*)
C             SETS MEMORY FROM BEGIN(1) TO END(1) TO VALUE
C     L1=LOC(BEGIN(1))
C     L2=LOC(END(1))
C     DO 10 L=1,L2-L1+1
C     BEGIN(L)=VALUE
C  10 CONTINUE
C     RETURN
C     END
C
C=======================================================================
C//BEGIN CONTUB//
C=======================================================================
C
C                 S U B R O U T I N E  C O N T U B
C
C  AUTHOR:        B.J. BRAAMS  -  F.O.M., THE NETHERLANDS.
C  DATED:         00/00/00 (YY/MM/DD), VERSION 1.0.
C  REVISIONS:     R.S. (JET  30-MAY-1987)
C
C=======================================================================
C//DOCUMENTATION//
C
C
C  1. PURPOSE
C
C     CONTUB PRODUCES A CONTOUR PLOT ON THE PRINTER FILE.
C
C
C  2. SPECIFICATION
C
C     SUBROUTINE CONTUB (ICOO, X, Y, F, NXD, NX, NY, NC, NR,
C    .      FMIN, FMAX, OUTF, TXT1, TXT2, NOUT)
C
C     INTEGER ICOO, NXD, NX, NY, NC, NR, NOUT
C     'REAL' X(0:NX-1), Y(0:NY-1), F(0:NXD-1,0:NY-1), FMIN, FMAX, OUTF
C     CHARACTER*(*) TXT1, TXT2
C
C
C-----------------------------------------------------------------------
C
C
C  3. DESCRIPTION
C
C     A LINE PRINTER CONTOUR PLOT IS MADE OF THE CONTENTS OF ARRAY
C     F(0:NX-1,0:NY-1), WHICH IS ASSUMED TO REPRESENT A FUNCTION ON
C     A RECTANGULAR GRID. BILINEAR INTERPOLATION IS EMPLOYED
C     BETWEEN GRID POINTS.
C
C     IF    X(I) <X< X(I+1)   AND   Y(J) <Y< Y(J+1)   THEN
C        F(X,Y) = (1-DX) * (1-DY) * F(I,J) +
C               + DX * (1-DY) * F(I+1,J) +
C               + (1-DX) * DY * F(I,J+1) +
C               + DX * DY * F(I+1,J+1 )
C     WHERE
C        DX = (X-X(I)) / (X(I+1)-X(I)),  DY = (Y-Y(J)) / (Y(J+1)-Y(J))
C
C
C  4. REFERENCES
C
C
C  5. ARGUMENTS
C
C     NX, NY          - INTEGER, INPUT.
C     ON ENTRY, NX AND NY SPECIFY THE NUMBER OF POINTS IN THE GRID
C     ALONG THE X- AND THE Y-COORDINATE RESPECTIVELY.
C     UNCHANGED ON EXIT.
C
C     ICOO            - INTEGER, INPUT.
C     ON ENTRY, ICOO SPECIFIES WHETHER X AND Y ARE GIVEN OR NOT
C     (0-NOT GIVEN, 1-GIVEN). IF NOT GIVEN, THE MESH IS ASSUMED UNIFORM.
C     UNCHANGED ON EXIT.
C
C     X               - (0:NX-1) 'REAL' ARRAY, INPUT.
C     ON ENTRY, X HOLDS THE ABSCISSAS.
C     UNCHANGED ON EXIT.
C
C     Y               - (0:NY-1) 'REAL' ARRAY, INPUT.
C     ON ENTRY, Y HOLDS THE ABSCISSAS.
C     UNCHANGED ON EXIT.
C
C     F               - (0:NXD-1,0:NY-1) 'REAL' ARRAY, INPUT.
C     ON ENTRY, F(0:NX-1,0:NY-1) HOLDS THE FUNCTION WHICH IS TO BE
C     DISPLAYED.
C     UNCHANGED ON EXIT.
C
C     NXD             - INTEGER, INPUT.
C     ON ENTRY, NXD SPECIFIES THE SIZE OF THE LEADING DIMENSION OF
C     THE ARRAY F.
C     UNCHANGED ON EXIT.
C
C     NC              - INTEGER, INPUT.
C     ON ENTRY, NC SPECIFIES THE NUMBER OF CHARACTERS PER LINE IN THE
C     CONTOUR PLOT. THE FIRST AND LAST CHARACTER IN EACH LINE WILL
C     BE USED TO FORM A FRAME FOR THE PLOT, SO THAT NC-2 CHARACTERS
C     REMAIN AVAILABLE FOR THE PLOT PROPER.
C     NC .GE. 4.
C     UNCHANGED ON EXIT.
C
C     NR              - INTEGER, INPUT.
C     ON ENTRY, NR SPECIFIES THE NUMBER OF LINES IN THE CONTOUR PLOT.
C     THIS NUMBER INCL. THE TWO LINES WHICH FORM THE TOP AND THE
C     BOTTOM OF THE FRAME. IT DOES NOT INCL. THE TITLE LINE.
C     NR .GE. 4.
C     UNCHANGED ON EXIT.
C
C     FMIN, FMAX      - 'REAL', INPUT/OUTPUT.
C     ON ENTRY, IF FMIN .NE. FMAX, THESE SPECIFY THE RANGE OF F FOR
C     THE DISPLAY. IF FMIN = FMAX AUTOMATIC SCALING IS USED.
C     ...
C
C     OUTF            - 'REAL', INPUT.
C     IF F(I,J)=OUTF, THEN (I,J) IS TO BE CONSIDERED AS
C     AN 'EXTERNAL' POINT.
C     UNCHANGED ON EXIT.
C
C     TXT1, TXT2      - CHARACTER*(*), INPUT.
C     ON ENTRY, HOLD THE CONTENTS OF THE TITLE LINE ABOVE THE PLOT.
C     TXT1 WILL BE WRITTEN IN THE UPPER LEFT, AND TXT2 IN THE UPPER
C     RIGHT CORNER, JUST ABOVE THE ACTUAL PLOT.
C     UNCHANGED ON EXIT.
C
C     NOUT            - INTEGER, INPUT.
C     ON ENTRY, SPECIFIES THE OUTPUT CHANNEL NUMBER.
C     UNCHANGED ON EXIT.
C
C
C  6. ERROR INDICATORS
C
C     IF AN ERROR IN THE INPUTS IS DETECTED THE ROUTINE WILL ABORT
C     THROUGH A CALL TO SUBROUTINE EXIT.
C
C
C  7. AUXILIARY ROUTINES
C
C     EXIT            - SUBROUTINE.
C     STOPS THE PROGRAM.
C
C     SCAL10          - 'REAL' FUNCTION.
C     COMPUTES A 'ROUND' SCALE WHEN AUTOMATIC SCALING IS WANTED.
C
C
C 11. FURTHER COMMENTS
C
C
C=======================================================================
C//DECLARATIONS//
      SUBROUTINE CONTUB (ICOO, X, Y, F, NXD, NX, NY, NC, NR,
     .      FMIN, FMAX, OUTF, TXT1, TXT2, NOUT)
      IMPLICIT REAL*8(A-H,O-Z)
C     IMPLICIT NONE
C  -- INPUT ARGUMENTS --
      INTEGER ICOO, NX, NY, NXD, NC, NR, NOUT
      REAL*8 X(0:NX-1), Y(0:NY-1), F(0:NXD-1, 0:NY-1), FMIN, FMAX, OUTF
      CHARACTER*(*) TXT1, TXT2
C  -- LOCAL SCALARS --
      INTEGER NCMAX, NCC, NRR, I, J, K, JF, JF1, KF, KF1, L
      REAL*8 X1, Y1, FM, S2AMAX, YK, XJ
      PARAMETER (NCMAX = 132)
C  -- LOCAL ARRAYS --
      CHARACTER LINE*(NCMAX), CHAR(-30:30)
C  -- PROCEDURES --
C     INTRINSIC MIN, MAX, ABS
      REAL*8 SCAL10
      EXTERNAL EXITX, SCAL10
C  -- INITIALIZATION --
      DATA CHAR / '-', '.', 'E', '.', 'D', '.', 'C', '.', 'B', '.',
     .      'A', '.', '9', '.', '8', '.', '7', '.', '6', '.',
     .      '5', '.', '4', '.', '3', '.', '2', '.', '1',
     .      '.', '0', ' ',
     .      '1', ' ', '2', ' ', '3', ' ', '4', ' ', '5', ' ',
     .      '6', ' ', '7', ' ', '8', ' ', '9', ' ', 'A', ' ',
     .      'B', ' ', 'C', ' ', 'D', ' ', 'E', ' ', '+' /
C=======================================================================
C//COMPUTATION//
C  ---------------------------------------------------------------------
C  PRELIMINARIES.
C  ---------------------------------------------------------------------
C  -- TEST INPUTS --
      IF (NXD .LT. NX) THEN
         WRITE(NOUT,10)
   10    FORMAT(/'CONTUB - NXD < NX')
         CALL EXITX(NOUT)
      ELSE IF (NX .LT. 2 .OR. NY .LT. 2) THEN
         WRITE(NOUT,20)
   20    FORMAT(/'CONTUB - NX < 2 OR NY < 2')
         CALL EXITX(NOUT)
      ELSE IF (NC .LT. 4 .OR. NR .LT. 4) THEN
         WRITE(NOUT,30)
   30    FORMAT(/'CONTUB - NC < 4 OR NR < 4')
         CALL EXITX(NOUT)
      ELSE IF (NC .GT. NCMAX) THEN
         WRITE(NOUT,40)
   40    FORMAT(/'CONTUB - NC IS TOO LARGE')
         CALL EXITX(NOUT)
      ELSE IF (LEN(TXT1) .GT. NC .OR. LEN(TXT2) .GT. NC) THEN
         WRITE(NOUT,50)
   50    FORMAT(/'CONTUB - HEADER TEXT WILL NOT FIT')
         CALL EXITX(NOUT)
      END IF
C  -- SET AUXILIARIES --
      NCC = NC - 2
      NRR = NR - 2
C  ---------------------------------------------------------------------
C  COMPUTE THE SCALE.
C  ---------------------------------------------------------------------
      S2AMAX = 0
      DO 55 , I = 0, NX-1
      DO 55 , J = 0, NY-1
         IF (F(I,J) .NE. OUTF)  S2AMAX = DMAX1( DABS(F(I,J)) , S2AMAX )
   55 CONTINUE
      IF (FMIN .EQ. FMAX) THEN
C        AUTOMATIC SCALING IS REQUIRED.
         IF (FMAX .EQ. 0) THEN
C           THE SCALE WILL BE A NICE BASE-10 REAL.
            FMIN = 0
            FMAX = SCAL10 (0.9E0 * S2AMAX)
            IF(FMAX.EQ.0.0) FMAX = 1.0
         ELSE
C           THE SCALE WILL BE A NICE BASE-10 MULTIPLE OF DABS(FMAX).
            FMIN = 0
            FMAX = DABS(FMAX) * SCAL10 (0.9E0 * S2AMAX / DABS(FMAX))
            IF(FMAX.EQ.0.0) FMAX = 1.0
         END IF
      ELSE
C        AUTOMATIC SCALING IS NOT WANTED.
         CONTINUE
      END IF
C  ---------------------------------------------------------------------
C  PRINT HEADER LINE.
C  ---------------------------------------------------------------------
      LINE = TXT1
      LINE(NC+1-LEN(TXT2):NC) = TXT2
      WRITE (NOUT, '(1H1, A)') LINE(1:NC)
C  ---------------------------------------------------------------------
C  PRINT FMIN,FMAX.
C  ---------------------------------------------------------------------
      WRITE (NOUT, '(32X,''MIN.='',1P,E10.3,''   MAX.='',E10.3,
     .                   ''   "1"='',E10.3,'' (+-25%)'')')
     .       FMIN,FMAX,(FMAX-FMIN)/10.
C  ---------------------------------------------------------------------
C  PRINT THE CONTOUR PLOT.
C  ---------------------------------------------------------------------
C  -- TOP OF THE FRAME --
      WRITE (NOUT, 80) '+', ('-', J = 0, NCC-1), '+'
C  -- INTERIOR LINES --
      DO 70 , K = NRR-1, 0, -1
         IF(ICOO .NE.0) THEN
            YK = Y(0) + FLOAT(K) * (Y(NY-1)-Y(0)) / FLOAT(NRR-1)
            KF = 0
            DO 62 , L = 0, NY-2
               IF(Y(L).LT.YK) KF = L
   62          CONTINUE
            KF = MIN0( NY-2, KF )
            KF1 = KF + 1
            Y1  = (YK-Y(KF)) / (Y(KF1)-Y(KF))
            ELSE
            KF  = (K*(NY-1)) / (NRR-1)
            KF1 = (K*(NY-1) + NRR-2) / (NRR-1)
            Y1  = REAL(K*(NY-1)) / (NRR-1) -KF
            END IF
C        KF, KF1, AND Y1 ARE USED FOR THE INTERPOLATION IN THE
C        SECOND COORDINATE. THEY SATISFY THE FOLLOWING PROPERTIES:
C        A) 0 .LE. KF .LE. KF1 .LE. KF+1 .LE. NY-1;
C        B) 0 .LE. Y1 .LT. 1;
C        C) (Y1 .EQ. 0) .EQV. (KF .EQ. KF1).
         DO 60 , J = 0, NCC-1
            IF(ICOO .NE.0) THEN
               XJ = X(0) + FLOAT(J) * (X(NX-1)-X(0)) / FLOAT(NCC-1)
               JF = 0
               DO 64 , L = 0, NX-2
                  IF(X(L).LT.XJ) JF = L
   64             CONTINUE
               JF = MIN0( NX-2, JF )
               JF1 = JF + 1
               X1  = (XJ-X(JF)) / (X(JF1)-X(JF))
               ELSE
               JF  = (J*(NX-1)) / (NCC-1)
               JF1 = (J*(NX-1) + NCC-2) / (NCC-1)
               X1  = REAL(J*(NX-1)) / (NCC-1) -JF
               END IF
            IF( F(JF,KF).EQ.OUTF .OR. F(JF1,KF).EQ.OUTF .OR.
     .          F(JF,KF1).EQ.OUTF .OR. F(JF1,KF1).EQ.OUTF) THEN
                LINE(J+2:J+2)='?'
                GOTO 60
                END IF
C           JF, JF1, AND X1 ARE USED FOR THE INTERPOLATION IN THE
C           FIRST COORDINATE.
C        -- BILINEAR INTERPOLATION IN THE ARRAY F --
            FM = (1-X1)*(1-Y1)*F(JF,KF) + X1*(1-Y1)*F(JF1,KF) +
     .            (1-X1)*Y1*F(JF,KF1) + X1*Y1*F(JF1,KF1)
C        -- COMPUTE THE CHARACTER --
            I = MAX0(-30, MIN0(30,
     .            NINT(20.0*(FM-FMIN)/(FMAX-FMIN))))
            LINE(J+2:J+2) = CHAR(I)
   60    CONTINUE
C     -- EDGE OF THE FRAME --
C        LINE(1:1) = '|'
C        LINE(NC:NC) = '|'
         LINE(1:1) = 'I'
         LINE(NC:NC) = 'I'
         WRITE (NOUT, '(1X, A)') LINE(1:NC)
   70 CONTINUE
C  -- BOTTOM OF THE FRAME --
      WRITE (NOUT, 80) '+', ('-', J = 0, NCC-1), '+'
C  ---------------------------------------------------------------------
      RETURN
C=======================================================================
C//FORMATS//
   80 FORMAT (1X, 132A1)
C=======================================================================
C//END CONTUB//
      END
C
C=======================================================================
C//SCAL10//
      DOUBLE PRECISION FUNCTION SCAL10(Y)
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 Y
C     ------------------------------------------------------------------
C     THIS SERVICE ROUTINE CAN BE USED TO COMPUTE A PROPER SCALE FOR
C     GRAPHICAL OUTPUT. SCAL10(Y) RETURNS THE LEAST IN MAGNITUDE
C     REAL VALUE R WITH DABS(R) .GE. DABS(Y) AND WHICH HAS A DECIMAL
C     REPRESENTATION OF THE FORM
C           R  =  0,  OR
C           R  =  SGN(Y) * I1 * 10.0 ** I2
C     WHERE I1 IS 2 OR 5 OR 10, AND I2 IS AN INTEGER.
C     ------------------------------------------------------------------
      INTEGER I1, I2
      REAL*8 R1
C     INTRINSIC ALOG10, ABS, NINT, SIGN
C     ------------------------------------------------------------------
      IF (Y .EQ. 0) THEN
         SCAL10 = 0
      ELSE
         I2 = NINT (DLOG10(DABS(Y)) - 0.5)
         R1 = DABS(Y) * 10.0E0 ** (-I2)
C        R1 IS IN THE RANGE (1 .. 10), TO MACHINE ACCURACY.
         IF (R1 .LE. 2) THEN
            I1 = 2
         ELSE IF (R1 .LE. 5) THEN
            I1 = 5
         ELSE
            I1 = 10
         END IF
         SCAL10 = DSIGN(1.0D0, Y) * I1 * 10.0D0 ** (I2)
      END IF
      RETURN
C     ------------------------------------------------------------------
C//END SCAL10//
      END
C
C========  IMSL PACKAGE TO SOLVE A SYSTEM OF NONLINEAR EQUATIONS =======
C
C   IMSL ROUTINE NAME   - ZSYSTM
C
C-----------------------------------------------------------------------
C
C   COMPUTER            - IBM/SINGLE
C
C   LATEST REVISION     - JANUARY 1, 1978
C
C   PURPOSE             - DETERMINATION OF A ROOT OF A SYSTEM OF N
C                           SIMULTANEOUS NONLINEAR EQUATIONS IN N
C                           UNKNOWNS, F(X)=0, IN VECTOR FORM.
C
C   USAGE             - CALL ZSYSTM (F,EPS,RELCON,N,X,ITMAX,WA,PAR,IER)
C
C   ARGUMENTS    F      - F IS THE NAME OF THE FUNCTION CALLED BY
C                           ZSYSTM TO FURNISH THE VALUES OF THE
C                           EQUATIONS BEING SOLVED. THE USER SPECIFIES
C                           F BY WRITING A FUNCTION SUBPROGRAM
C                           F(X,K,PAR) WHICH COMPUTES THE K-TH
C                           COMPONENT OF F EVALUATED AT X. F MUST
C                           APPEAR IN AN EXTERNAL STATEMENT IN THE
C                           CALLING PROGRAM. F MUST BE TYPED
C                           APPROPRIATELY. SEE PRECISION/HARDWARE.
C                EPS    - FIRST STOPPING CRITERION. A ROOT X(1),...,
C                           X(N) IS ACCEPTED IF THE MAXIMUM ABSOLUTE
C                           VALUE OF F(X,K,PAR) IS LESS THAN OR EQUAL
C                           TO EPS, WHERE K=1,...,N. (INPUT)
C                RELCON - SECOND STOPPING CRITERION. A ROOT IS ACCEPTED
C                           IF TWO SUCCESSIVE APPROXIMATIONS TO A GIVEN
C                           ROOT AGREE WITHIN RELCON (INPUT)
C                             NOTE. IF EITHER, OR BOTH, OF THE STOPPING
C                                   CRITERIA ARE SATISFIED, THE ROOT IS
C                                   ACCEPTED.
C                N      - THE NUMBER OF EQUATIONS (= NUMBER OF UNKNOWNS)
C                           N CAN BE 1. (INPUT)
C                X      - THE VECTOR X OF LENGTH N, AS INPUT, IS THE
C                           INITIAL GUESS FOR THE ROOT. AS OUTPUT, IT
C                           IS THE COMPUTED SOLUTION.
C                ITMAX  - ON INPUT = THE MAXIMUM ALLOWABLE NUMBER OF
C                           ITERATIONS AND ON OUTPUT = THE NUMBER OF
C                           ITERATIONS USED IN FINDING THE COMPUTED
C                           SOLUTION.
C                WA     - AN ARRAY WORK AREA OF SIZE ((N+2)*(N-1))/2 +
C                           3*N SUPPLIED BY THE USER.
C                PAR    - PAR CONTAINS A PARAMETER SET (POSSIBLY A
C                           FUNCTION NAME) WHICH IS PASSED TO THE USER
C                           SUPPLIED FUNCTION F. PAR MAY BE USED TO
C                           PASS ANY AUXILIARY PARAMETERS NECESSARY FOR
C                           COMPUTATION OF THE FUNCTION F. PAR IS A TYPE
C                           REAL VECTOR IN ZSYSTM. (INPUT)
C                IER    - ERROR PARAMATER. (OUTPUT)
C                         TERMINAL ERROR
C                           IER = 129 INDICATES THE ALGORITHM FAILED TO
C                             CONVERGE WITHIN ITMAX ITERATIONS.
C                           IER = 130 INDICATES SINGULARITY (OF THE
C                             JACOBIAN MATRIX) HAS BEEN ENCOUNTERED
C                             TWICE.
C
C   PRECISION/HARDWARE  - SINGLE AND DOUBLE/H32
C                       - SINGLE/H36,H48,H60
C
C   REQD. IMSL ROUTINES - UERTST,UGETIO
C
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP
C
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.
C
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.
C
C-----------------------------------------------------------------------
C
      SUBROUTINE ZSYSTM (F,EPS,RELCON,N,X,ITMAX,WA,PAR,IER,LOUT)
      IMPLICIT REAL*8(A-H,O-Z)
C
      DIMENSION          X(2),WA(42),PAR(2)
      REAL*8             EPS,DELTA,XTEMP,PREC,ETA,TOP,RELCON,F,FMAX,
     1                   PT1,P2,HOLD,H,FPLUS,DERMAX,TEST,X,WA,E,PAR,
     2                   ZERO,PM1
      DATA               PREC,DELTA/5.E-12,5.E-9/
      DATA               ZERO,PM1,PT1,P2/0.,.1,.0001,.002/
C
C                                  FIRST EXECUTABLE STATEMENT
      NIN  = 0
      NOUT = LOUT
      CALL UGETIO(3,NIN,NOUT)
      IER=0
C                                  PREC IS A FUNCTION OF THE MACHINE
C                                  SIGNIFICANCE, SIG, AND SHOULD BE
C                                  COMPUTED AS PREC=5.*10.**(-SIG+2).
C                                  IN THIS INSTANCE WE WERE DEALING
C                                  WITH A 6 DIGIT MACHINE.
C                                  DELTA SHOULD BE TAKEN AS
C                                  5.*10.**(-(SIG+4)/2), FOR SIG EVEN,
C                                  AND 16.*10.**(-(SIG+5)/2, FOR SIG ODD
      N2 = N+N
C     RELCON=10.E+0**(-NSIG)
      JTEST = 1
      IERROR=0
      IPART=((N+2)*(N-1))/2
      ITMP=IPART+N
      LKSUB=ITMP+N
      DO 130 M = 1, ITMAX
         IQUIT=0
         FMAX=ZERO
         M1 = M-1
         K1 = LKSUB + 1
         KMIN = LKSUB + N
         XTEMP = ZERO
C                                  THE ARRAY WA(LKSUB+1),...,WA(LKSUB+N)
C                                  PERMITS A PARTIAL PIVOTING EFFECT
C                                  WITHOUT THE PHYSICAL INTERCHANGE
C                                  OF ROWS OR COLUMNS.
         DO 5 J = K1,KMIN
            XTEMP = XTEMP+1.
            WA(J) = XTEMP
    5    CONTINUE
         K = 1
   10    IF(K .LE. 1) GO TO 30
         KMIN = K-1
C                                  THE FOLLOWING CODE BACK-SOLVES THE
C                                  FIRST KMIN ROWS OF A TRIANGULARIZED
C                                  LINEAR SYSTEM FOR IMPROVED X VALUES
C                                  IN TERMS OF PREVIOUS ONES.
         KK = 1
   15    DO 25 K1=1,KMIN
            ISUB=K-K1
            MM=((ISUB-1)*(N2 -ISUB))/2
            LIM=N-ISUB
            KPOINT = WA(LKSUB+ISUB)+PM1
C                                  THE ADDITION OF  .1  IN THE LAST
C                                  STATEMENT (AND OTHERS LIKE IT
C                                  BELOW) IS ESSENTIAL, SINCE WA
C                                  CONTAINS INTEGERS AS WELL AS FLOATING
C                                  POINT NUMBERS.  FOR EXAMPLE, SUPPOSE
C                                  THE INTEGER 3 WAS STORED AS
C                                  2.99999999999998
            ISUB1 = ISUB-1
            X(KPOINT)=ZERO
            DO 20 L1=1,LIM
               JS1=ISUB1+L1
               LKJSUB=LKSUB + JS1 +1
               IJ=MM+JS1
               JPOINT= WA(LKJSUB) + PM1
               X(KPOINT)=X(KPOINT) + WA(IJ)*X(JPOINT)
   20       CONTINUE
            X(KPOINT)=X(KPOINT) + WA(MM+N)
   25    CONTINUE
         GO TO (30,45,105), KK
C
C                                  SET UP PARTIAL DERIVATIVES OF
C                                  KTH FUNCTION..
C
   30    E = F(X,K,PAR)
         FMAX= DMAX1(FMAX,DABS(E))
         IF(DABS(E) .GE. EPS) GO TO 35
         IQUIT=IQUIT+1
         IF(IQUIT .EQ. N) GO TO 140
   35    I = K
   40    IP=IPART+I
         ITEMP = WA(LKSUB+I) + PM1
         HOLD = X(ITEMP)
         ETA=.001E+00*DABS(HOLD)
         IF(DABS(HOLD) .LT.PREC) ETA=DELTA
         H = DMIN1(FMAX,ETA)
         IF(H .LT. PREC) H=PREC
         X (ITEMP)=HOLD+H
         IF (K .LE. 1) GO TO 45
         KK = 2
         GO TO 15
   45    FPLUS = F(X,K,PAR)
         TOP=FPLUS-E
         IF(DABS(TOP) .GE. PREC) GO TO 50
         WA(IP)=ZERO
         GO TO 55
   50    WA(IP)=TOP/H
   55    X(ITEMP)=HOLD
         I = I + 1
         IF (I .LE. N) GO TO 40
         IF (K .LT. N) GO TO 60
         IP=IPART+N
         IF(DABS( WA(IP)) .EQ. ZERO) GO TO 80
         X(ITEMP) = -E/ WA(IP) + X(ITEMP)
         GO TO 100
C
C                                  FIND PARTIAL DERIVATIVE OF LARGEST
C                                  ABSOLUTE VALUE..
C
   60    KL=LKSUB+K
         LOOK= WA(KL) + PM1
         KMAX=LOOK
         IP=IPART+K
         DERMAX=DABS( WA(IP))
         KPLUS = K+1
         DO 65 I = KPLUS,N
            TEST=DABS( WA(IPART+I))
            IF(TEST .LE. DERMAX) GO TO 65
            DERMAX = TEST
            KMAX=I
   65    CONTINUE
         IF(LOOK .EQ. KMAX) GO TO 75
         LKMAX=LKSUB+KMAX
         WA(KL)=WA(LKMAX)
         WA(LKMAX)=LOOK
         IP=IPART+KMAX
         XTEMP= WA(IP)
         IPK=IPART+K
         WA(IP)=WA(IPK)
         WA(IPK)=XTEMP
         IF(K .LT. 2) GO TO 75
         KMIN=K-1
         I1 = 0
         DO 70 I=1,KMIN
            L=((I1 )*(N2 -I))/2-1
            J=L+KMAX
            XTEMP= WA(J)
            JJ=L+K
            WA(J)=WA(JJ)
            WA(JJ)=XTEMP
            I1 = I
   70    CONTINUE
   75    IF (DABS(WA(IPART+K)).NE. ZERO) GO TO 90
   80    IF(IERROR .EQ. 1) GO TO 135
         DO 85  I=1,N
C                                  IF THE MODIFIED JACOBIAN IS SINGULAR
C                                  AT X, CHANGE THE COMPONENTS OF X AND
C                                  PROCEED WITH THE ITERATIONS.  IF IT
C                                  HAPPENS A SECOND TIME, TERMINATE.
            X(I) = 0.9*X(I) + .12345
   85    CONTINUE
         IERROR=1
         GO TO 105
C
C                                  SET UP COEFFICIENTS FOR KTH ROW
C                                  OF TRIANGULAR LINEAR SYSTEM USED
C                                  TO BACK-SOLVE FOR THE FIRST K X(I)
C                                  VALUES...
C
   90    L=((K-1)*(N2 -K))/2
         KN=L+N
         I1 = L-1
         WA(KN)=ZERO
         IPK=IPART+K
         DO 95  J = KPLUS,N
            JSUB= WA(LKSUB+J) + PM1
            JJ=I1+J
            IPJ=IPART+J
            WA(JJ)=-WA(IPJ)/WA(IPK)
            WA(KN)=WA(KN)+WA(IPJ)*X(JSUB)
   95    CONTINUE
         LK= WA(LKSUB+K) + PM1
         WA(KN)=(WA(KN)-E)/WA(IPK) + X(LK)
         K = K+1
         IF (K .LE. N) GO TO 10
C                                  BACK SUBSTITUTE TO OBTAIN NEXT
C                                  APPROXIMATION TO X
  100    IF( N .EQ. 1) GO TO 105
         KMIN=N-1
         KK = 3
         GO TO 15
  105    IF (M .LE. 1) GO TO 120
C
C                                  TEST FOR CONVERGENCE..
C
         DO 110 I = 1,N
            IF(DABS(WA(ITMP+I)-X(I)) .GT. DABS(X(I))*RELCON) GO TO 115
  110    CONTINUE
         JTEST = JTEST+1
         IF (JTEST-3)120,140,140
  115    JTEST = 1
  120    DO 125 I = 1,N
            WA(ITMP+I)=X(I)
  125    CONTINUE
  130 CONTINUE
      M=ITMAX
      IER = 129
      GO TO 240
  135 IER = 130
  140 FMAX=ZERO
      TEST=1.0E+15
      IF (N .GT. 1) GO TO 145
      WA(IPART+2) = F(X,1,PAR)
      FMAX = DMAX1(FMAX,DABS(WA(IPART+2)))
      GO TO 155
  145 DO 150 I = 1,N
         IP=IPART+I
         WA(IP) = F(X,I,PAR)
         FMAX=DMAX1(FMAX,DABS(WA(IP)))
  150 CONTINUE
C                                  CHECK TO SEE IF SMALL COMPONENTS ARE
C                                  ACTUALLY ZERO
  155 K=1
      DO 160 I=1,N
         WA(I)=X(I)
         IF(DABS(X(I)) .GT. P2) GO TO 160
         K=2
         WA(I)=ZERO
  160 CONTINUE
      IF(K .EQ. 1) GO TO 195
      KK = 1
      GO TO 205
  165 IF(FMAX .LT. TEST) GO TO 190
C                                  NOTE THAT SMALL COMPONENTS ARE SET
C                                  TO ZERO ONLY IF THE NORM OF THE
C                                  FUNCTION VECTOR IS REDUCED AS A
C                                  RESULT OF THIS PROCESS.
      DO 170 I=1,N
         X(I)= WA(I)
  170 CONTINUE
      IF (N .GT. 1) GO TO 175
      WA(IPART+2) = WA(ITMP+2)
      GO TO 185
  175 DO 180 I = 1,N
         WA(IPART+I) = WA(ITMP+I)
  180 CONTINUE
  185 FMAX=TEST
C                                  CHECK FOR INTEGER COMPONENTS
  190 K=1
  195 ITEST=0
      DO 200 I=1,N
         WA(I)=X(I)
         IF(DABS(X(I)) .LE. P2) GO TO 200
         L=X(I)+PT1
         J=X(I)-PT1
         IF(L .EQ. J) GO TO 200
         WA(I) =ISIGN(1,J)*MAX0(IABS(L),IABS(J))
         K=2
  200 CONTINUE
      IF(K .EQ. 1) GO TO 235
      KK = 2
  205 TEST=ZERO
      IF (N .GT. 1) GO TO 210
      WA(ITMP+2) = F(WA,1,PAR)
      TEST = DMAX1(TEST,DABS(WA(ITMP+2)))
      GO TO 220
  210 DO 215 I=1,N
         IT=ITMP+I
         WA(IT) = F(WA,I,PAR)
         TEST=DMAX1(TEST,DABS(WA(IT)))
  215 CONTINUE
  220 GO TO (165,225), KK
  225 IF(FMAX .LT. TEST) GO TO 235
C                                  NOTE THAT NEAR-INTEGER COMPONENTS
C                                  ARE SET TO BE INTEGERS ONLY IF THE
C                                  NORM OF THE FUNCTION VECTOR IS
C                                  REDUCED AS A RESULT OF THIS PROCESS.
      DO 230 I=1,N
         X(I)= WA(I)
  230 CONTINUE
      ITEST=1
C                                  TEST FOR CONVERGENCE
  235 IF(FMAX .LT. EPS .OR. TEST .LT. EPS)  IER = 0
  240 ITMAX=M1 + 1
 9000 CONTINUE
      IF (IER .NE. 0) CALL UERTST(IER,6HZSYSTM,LOUT)
 9005 RETURN
      END
C   IMSL ROUTINE NAME   - UERTST
C
C-----------------------------------------------------------------------
C
C   COMPUTER            - IBM/SINGLE
C
C   LATEST REVISION     - JANUARY 1, 1978
C
C   PURPOSE             - PRINT A MESSAGE REFLECTING AN ERROR CONDITION
C
C   USAGE               - CALL UERTST (IER,NAME)
C
C   ARGUMENTS    IER    - ERROR PARAMETER. (INPUT)
C                           IER = I+J WHERE
C                             I = 128 IMPLIES TERMINAL ERROR,
C                             I =  64 IMPLIES WARNING WITH FIX, AND
C                             I =  32 IMPLIES WARNING.
C                             J = ERROR CODE RELEVANT TO CALLING
C                                 ROUTINE.
C                NAME   - A SIX CHARACTER LITERAL STRING GIVING THE
C                           NAME OF THE CALLING ROUTINE. (INPUT)
C
C   PRECISION/HARDWARE  - SINGLE/ALL
C
C   REQD. IMSL ROUTINES - UGETIO
C
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP
C
C   REMARKS      THE ERROR MESSAGE PRODUCED BY UERTST IS WRITTEN
C                ONTO THE STANDARD OUTPUT UNIT. THE OUTPUT UNIT
C                NUMBER CAN BE DETERMINED BY CALLING UGETIO AS
C                FOLLOWS..   CALL UGETIO(1,NIN,NOUT).
C                THE OUTPUT UNIT NUMBER CAN BE CHANGED BY CALLING
C                UGETIO AS FOLLOWS..
C                                NIN = 0
C                                NOUT = NEW OUTPUT UNIT NUMBER
C                                CALL UGETIO(3,NIN,NOUT)
C                SEE THE UGETIO DOCUMENT FOR MORE DETAILS.
C
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.
C
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.
C
C-----------------------------------------------------------------------
C
      SUBROUTINE UERTST (IER,NAME,LOUT)
      IMPLICIT REAL*8(A-H,O-Z)
C                                  SPECIFICATIONS FOR ARGUMENTS
      INTEGER            IER
      CHARACTER*2          NAME(3)
C                                  SPECIFICATIONS FOR LOCAL VARIABLES
      CHARACTER*2          NAMSET(3),NAMEQ(3)
      DATA               NAMSET/'UE','RS','ET'/
      DATA               NAMEQ/'  ','  ','  ' /
C                                  FIRST EXECUTABLE STATEMENT
      DATA               LEVEL/4/,IEQDF/0/,IEQ/1H=/
C                                  SET OUTPUT UNIT NUMBER
      NIN  = 0
      NOUT = LOUT
      CALL UGETIO(3,NIN,NOUT)
      IF (IER.GT.999) GO TO 25
      IF (IER.LT.-32) GO TO 55
      IF (IER.LE.128) GO TO 5
      IF (LEVEL.LT.1) GO TO 30
C                                  PRINT TERMINAL MESSAGE
      CALL UGETIO(1,NIN,IOUNIT)
      IF (IEQDF.EQ.1) WRITE(IOUNIT,35) IER,NAMEQ,IEQ,NAME
      IF (IEQDF.EQ.0) WRITE(IOUNIT,35) IER,NAME
      GO TO 30
    5 IF (IER.LE.64) GO TO 10
      IF (LEVEL.LT.2) GO TO 30
C                                  PRINT WARNING WITH FIX MESSAGE
      CALL UGETIO(1,NIN,IOUNIT)
      IF (IEQDF.EQ.1) WRITE(IOUNIT,40) IER,NAMEQ,IEQ,NAME
      IF (IEQDF.EQ.0) WRITE(IOUNIT,40) IER,NAME
      GO TO 30
   10 IF (IER.LE.32) GO TO 15
C                                  PRINT WARNING MESSAGE
      IF (LEVEL.LT.3) GO TO 30
      CALL UGETIO(1,NIN,IOUNIT)
      IF (IEQDF.EQ.1) WRITE(IOUNIT,45) IER,NAMEQ,IEQ,NAME
      IF (IEQDF.EQ.0) WRITE(IOUNIT,45) IER,NAME
      GO TO 30
   15 CONTINUE
C                                  CHECK FOR UERSET CALL
      DO 20 I=1,3
         IF (NAME(I).NE.NAMSET(I)) GO TO 25
   20 CONTINUE
      LEVOLD = LEVEL
      LEVEL = IER
      IER = LEVOLD
      IF (LEVEL.LT.0) LEVEL = 4
      IF (LEVEL.GT.4) LEVEL = 4
      GO TO 30
   25 CONTINUE
      IF (LEVEL.LT.4) GO TO 30
C                                  PRINT NON-DEFINED MESSAGE
      CALL UGETIO(1,NIN,IOUNIT)
      IF (IEQDF.EQ.1) WRITE(IOUNIT,50) IER,NAMEQ,IEQ,NAME
      IF (IEQDF.EQ.0) WRITE(IOUNIT,50) IER,NAME
   30 IEQDF = 0
      RETURN
   35 FORMAT(19H *** TERMINAL ERROR,10X,7H(IER = ,I3,
     1       20H) FROM IMSL ROUTINE ,3A2,A1,3A2)
   40 FORMAT(36H *** WARNING WITH FIX ERROR  (IER = ,I3,
     1       20H) FROM IMSL ROUTINE ,3A2,A1,3A2)
   45 FORMAT(18H *** WARNING ERROR,11X,7H(IER = ,I3,
     1       20H) FROM IMSL ROUTINE ,3A2,A1,3A2)
   50 FORMAT(20H *** UNDEFINED ERROR,9X,7H(IER = ,I5,
     1       20H) FROM IMSL ROUTINE ,3A2,A1,3A2)
C                                  SAVE P FOR P = R CASE
C                                    P IS THE PAGE NAME
C                                    R IS THE ROUTINE NAME
   55 IEQDF = 1
      DO 60 I=1,3
   60 NAMEQ(I) = NAME(I)
   65 RETURN
      END
C   IMSL ROUTINE NAME   - UGETIO
C
C-----------------------------------------------------------------------
C
C   COMPUTER            - IBM/SINGLE
C
C   LATEST REVISION     - JANUARY 1, 1978
C
C   PURPOSE             - TO RETRIEVE CURRENT VALUES AND TO SET NEW
C                           VALUES FOR INPUT AND OUTPUT UNIT
C                           IDENTIFIERS.
C
C   USAGE               - CALL UGETIO(IOPT,NIN,NOUT)
C
C   ARGUMENTS    IOPT   - OPTION PARAMETER. (INPUT)
C                           IF IOPT=1, THE CURRENT INPUT AND OUTPUT
C                           UNIT IDENTIFIER VALUES ARE RETURNED IN NIN
C                           AND NOUT, RESPECTIVELY.
C                           IF IOPT=2 (3) THE INTERNAL VALUE OF
C                           NIN (NOUT) IS RESET FOR SUBSEQUENT USE.
C                NIN    - INPUT UNIT IDENTIFIER.
C                           OUTPUT IF IOPT=1, INPUT IF IOPT=2.
C                NOUT   - OUTPUT UNIT IDENTIFIER.
C                           OUTPUT IF IOPT=1, INPUT IF IOPT=3.
C
C   PRECISION/HARDWARE  - SINGLE/ALL
C
C   REQD. IMSL ROUTINES - NONE REQUIRED
C
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP
C
C   REMARKS      EACH IMSL ROUTINE THAT PERFORMS INPUT AND/OR OUTPUT
C                OPERATIONS CALLS UGETIO TO OBTAIN THE CURRENT UNIT
C                IDENTIFIER VALUES. IF UGETIO IS CALLED WITH IOPT=2 OR 3
C                NEW UNIT IDENTIFIER VALUES ARE ESTABLISHED. SUBSEQUENT
C                INPUT/OUTPUT IS PERFORMED ON THE NEW UNITS.
C
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.
C
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.
C
C-----------------------------------------------------------------------
C
      SUBROUTINE UGETIO(IOPT,NIN,NOUT)
      IMPLICIT REAL*8(A-H,O-Z)
C                                  SPECIFICATIONS FOR ARGUMENTS
      INTEGER            IOPT,NIN,NOUT
C                                  SPECIFICATIONS FOR LOCAL VARIABLES
      INTEGER            NIND,NOUTD
      DATA               NIND/5/,NOUTD/6/
C                                  FIRST EXECUTABLE STATEMENT
      IF (IOPT.EQ.3) GO TO 10
      IF (IOPT.EQ.2) GO TO 5
      IF (IOPT.NE.1) GO TO 9005
      NIN = NIND
      NOUT = NOUTD
      GO TO 9005
    5 NIND = NIN
      GO TO 9005
   10 NOUTD = NOUT
 9005 RETURN
      END
C
C=======================================================================
      SUBROUTINE    CDATE(IWT)
       IMPLICIT REAL*8(A-H,O-Z)
C      OUTPUT ON UNIT 'IWT' OF DATE,TIME AND JOBNAME
       CHARACTER*8  BB(3)
       CHARACTER*8 FIELD
       CHARACTER*2 DD,MM,YY,MNTH(12)
       CHARACTER*3 MONTH(12),MMM
       DATA MNTH/'01','02','03','04','05','06',
     *           '07','08','09','10','11','12'/
       DATA MONTH/'JAN','FEB','MAR','APR','MAY','JUN',
     *            'JUL','AUG','SEP','OCT','NOV','DEC'/
       CALL DATJOB(BB)
C      WRITE(IWT,10)BB(3),BB(1),BB(2)
C  10  FORMAT(    /,' JOB: ',A8,3X,'ON: ',A8,3X,'AT: ',A8)
       WRITE(FIELD,'(A8)') BB(1)
       DD=FIELD(4:5)
       IF(DD(1:1).EQ.'0') DD(1:1)=' '
       MM=FIELD(1:2)
       IF(MM(1:1).EQ.' ') MM(1:1)='0'
       YY=FIELD(7:8)
       DO 10 I=1,12
       IF(MM.EQ.MNTH(I)) MMM=MONTH(I)
   10  CONTINUE
       WRITE(FIELD,'(A8)') BB(3)
       IF(FIELD(1:1).EQ.'0') FIELD(1:1)=' '
       READ (FIELD,'(A8)') BB(3)
       WRITE(IWT,20) BB(3),DD,MMM,YY,BB(2)
   20  FORMAT(/,' JOB: ',A8,3X,'ON: ',A2,'-',A3,'-',A2,3X,'AT: ',A8)
       RETURN
      END
C
C=======================================================================
      SUBROUTINE PTGMAT(A,IDIMA,IDIM1,IDIM2,IWT,ICOL,TIME,TIT)
      IMPLICIT REAL*8(A-H,O-Z)
C PRINT OF REAL MATRIX A
C INPUT
C -------
C BY ARGUMENT-LIST:
C    A        - MATRIX OF DIMENSION A(IDIMA,IDIM2)
C               FIRST DIMENSION IS OCCUPIED ONLY WITH IDIM1 ELEMENTS
C    IDIMA    - LEADING DIMENSION OF A
C    IDIM1    - NUMBER OF TIME POINTS OF A
C    IDIM2    - NUMBER OF ROWS OF A
C    IWT      - OUTPUT-CHANNEL FOR PRINTOUT
C    ICOL     - TIME DEPENDENT ANALYSIS COLUMN
C    TIME     - TIME VALUES OF DIMENSION IDIMA
C    TIT      - CHARACTER STRING FOR TITLE
C=======================================================================
      DIMENSION A(IDIMA,1) , TIME(IDIMA)
      CHARACTER*(*) TIT
      DATA INUM/9/
C INUM = NUMBER OF COLUMNS ON PAGE
C
      WRITE(IWT,50) TIT , ICOL
C
      N1=1
      N=0
      NR=IDIM1
      IN=(IDIM1-1)/INUM +1
      DO 40 II=1,IN
         N=N+INUM
         IF (NR .LT. INUM ) N=N-INUM+NR
         NR=NR-INUM
         WRITE(IWT,80)(TIME(I),I=N1,N)
         WRITE(IWT,*)'   '
         DO 30 J=1,IDIM2
   30       WRITE(IWT,60)J,(A(I,J),I=N1,N)
         N1=N1+INUM
   40    CONTINUE
C
   50 FORMAT(////,1X,A,I2/1X,132('-'))
   60 FORMAT(1X,I4,   2X,1P,:9E13.5)
   80 FORMAT(/,' TIME :',1P,:9E13.5)
      RETURN
      END
C
C=======================================================================
C
C         EIGENVALUE & EIGENVECTOR PACKAGE FOR A GENERAL REAL MATRIX
C         ==========================================================
C
      SUBROUTINE EB06AD(A,IA,V,IV,E,N,W,LFAIL)
C***********************************************************************
C*                                                                     *
C* PURPOSE.                                                            *
C*    FINDS THE EIGENVALUES AND EIGENVECTORS OF A REAL MATRIX A        *
C*                                                                     *
C* ARGUMENT LIST                                                       *
C*    A     TWO DIMENSIONAL REAL ARRAY CONTAINING THE MATRIX A,THIS    *
C*          ARRAY IS OVERWRITTEN BY THE ROUTINE                        *
C*    IA    FIRST DIMENSION OF ARRAY A                                 *
C*    V     TWO DIMENSIONAL REAL ARRAY WHICH WILL CONTAIN THE          *
C*          EIGENVECTORS.IF THE ITH EIGENVALUE IS REAL THEN THE ITH    *
C*          COLUMN OF V WILL CONTAIN THE CORRESPONDING EIGENVECTOR.IF  *
C*          EIGENVALUES I AND I+1 ARE A COMPLEX PAIR THE COLUMNS I AND *
C*          I+1 OF V GIVE THE REAL AND IMAGINARY PART OF THE           *
C*          EIGENVECTOR CORRESPONDING TO THE EIGENVALUE WITH POSITIVE  *
C*          IMAGINARY PART.                                            *
C*    IV    FIRST DIMENSION OF THE ARRAY V                             *
C*    E     ONE DIMENSIONAL COMPLEX ARRAY WHICH WILL CONTAIN           *
C*          THE EIGENVALUES.                                           *
C*    N     ORDER OF THE MATRIX A.                                     *
C*    W     ONE DIMENSIONAL REAL ARRAY OF LENGTH 2*N WHICH WILL        *
C*          BE USED AS WORKING SPACE.                                  *
C*    LFAIL IS AN ERROR RETURN PARAMETER AND WILL BE ZERO ON           *
C*          ON A SUCCESSFUL RETURN.                                    *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C*                                                                     *
C* LABELLED COMMON ARGUMENT LIST       (DEFAULTED IN BLOCK DATA        *
C*    LP    IS INTEGER AND IS THE STREAM NUMBER FOR DIAGNOSTIC MESSAGES*
C*          (DEFAULT VALUE IS 6)                                       *
C*    LB    IS INTEGER AND SPECIFIES WHETHER BALANCING IS DONE.        *
C*          SET TO ZERO FOR NO BALANCING AND A NON ZERO VALUE FOR      *
C*          BALANCING.  (DEFAULT VALUE IS 0)                           *
C*    ITS   IS INTEGER AND IS SET TO THE UPPER LIMIT ON THE NUMBER OF  *
C*          ITERATIONS IN OBTAINING AN EIGENVALUE.                     *
C*          (DEFAULT VALUE IS 30)                                      *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C    ALL REAL VARIABLES IN THIS SUBROUTINE MUST BE DEFINED AS DOUBLE   *
C    PRECISION VARIABLES. PLEASE NOTE WHEN CHANGING THIS ROUTINE       *
C***********************************************************************
      COMMON /EB06BD/LP,LB,ITS
      COMMON /EB08BD/LPA,ITSM,LL,LU,JH  ,LFLG
      INTEGER LFLG
      COMPLEX*16 E(N)  ,CV
      DOUBLE PRECISION A(IA,N),V(IV,N),W(N),RV(2)
      DOUBLE PRECISION S,SJC,X,Y,Z,ZERO
C
      DATA ZERO/0D0/
      EQUIVALENCE(RV(1),CV)
C
C-----------------------------------------------------------------------
      IF(N.LE.0)GO TO 310
C
C     PRESERVE BLOCK COMMON OF EB08
      MP1=LPA
      MP2=ITSM
      MP3=LL
      MP4=LU
      MP5=JH
C
C     SET UP BLOCK COMMON OF EB08 FOR EB06 USAGE
      LPA=LP
      ITSM=ITS
      JH=1
      LL=1
      LU=N
C
C     SCALE MATRIX IF REQUESTED
      IF(LB.NE.0)CALL MC15AD(A,IA,N,W(N+1),LL,LU)
C
C     REDUCE MATRIX TO UPPER HESSENBERG FORM
      CALL MC14AD(A,N,IA,W,LL,LU)
C
C     ACCUMULATE TRANSFORMATIONS FROM FULL MATRIX TO UPPER HESSENBERG
C     FORM,THESE WILL BE UPDATED BY EB08.
      DO 110 I=1,N
      DO 100 J=1,N
  100 V(I,J)=ZERO
  110 V(I,I)=1D0
      L2=LU-2
      IF(L2.LT.LL)GO TO 160
      DO 150 KK=LL,L2
      K=LL+L2-KK
      M=K+1
      Y=A(M,K)
      IF(Y.EQ.ZERO)GO TO 150
      Y=Y*W(M)
      K2=K+2
      DO 120 I=K2,LU
  120 W(I)=A(I,K)
      DO 140 J=M,LU
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         IC=LU+1-M
         X=ZERO
         IF ( IC .LE. 0 ) GO TO 405
         DO 400 JC=1,IC
         KC=M+JC-1
 400     X=X+W(KC)*V(KC,J)
 405     CONTINUE
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      X=X/Y
      DO 130 I=M,LU
  130 V(I,J)=V(I,J)+X*W(I)
  140 CONTINUE
  150 CONTINUE
  160 CONTINUE
C
C     FIND EIGENVALUES AND EIGENVECTORS OF UPPER HESSENBERG FORM
      CALL EB08AD(A,IA,V,IV,E,N,  LFAIL)
      IF(LB.EQ.0)GO TO 290
C
C     BACKWARD TRANSFORMATION OF A SET OF RIGHT HAND EIGENVECTORS
C     OF A BALANCED MATRIX INTO THE EIGENVECTORS OF THE ORIGINAL MATRIX
C     FROM WHICH THE BALANCED MATRIX WAS DERIVED BY A CALL OF
C     ROUTINE MC15
      IF(LL.GT.LU)GO TO 185
      DO 180 I=LL,LU
      S=W(I+N)
      DO 170 J=1,N
  170 V(I,J)=V(I,J)*S
  180 CONTINUE
  185 I=LL
      L=0
  190 I=I-1
      IF(I.LT.1)GO TO 230
  200 K=W(I+N)
      IF(K.EQ.I)GO TO 220
      DO 210 J=1,N
      S=V(I,J)
      V(I,J)=V(K,J)
  210 V(K,J)=S
  220 IF(L)190,190,240
  230 I=LU
      L=1
  240 I=I+1
      IF(I.LE.N)GO TO 200
C
C     RENORMALISE EIGENVECTORS TO HAVE L2 NORM ONE
      I=0
  250 I=I+1
      IF(I.GT.N)GO TO 290
      CV=E(I)
      IF(RV(2).NE.ZERO)GO TO 270
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         Z=ZERO
         DO 410 JC=1,N
 410     Z=Z+V(KC,I)*V(KC,I)
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      Z=1D0/DSQRT(Z)
      DO 260 J=1,N
  260 V(J,I)=V(J,I)*Z
      GO TO 250
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
 270     IPL1=I+1
         Z=ZERO
         SJC=ZERO
         DO 420 JC=1,N
         Z=Z+V(JC,I)*V(JC,I)
 420     SJC=SJC+V(JC,IPL1)*V(JC,IPL1)
         Z=Z+SJC
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      Z=1D0/DSQRT(Z)
      DO 280 J=1,N
      V(J,I)=V(J,I)*Z
  280 V(J,I+1)=V(J,I+1)*Z
      I=I+1
      GO TO 250
C
C     RESTORE BLOCK COMMON OF EB08
  290 LPA=MP1
      ITSM=MP2
      LL=MP3
      LU=MP4
      JH=MP5
  300 RETURN
C
C     ERROR MESSAGES
  310 LFAIL=-1
      IF(LP.GT.0)WRITE(LP,320)N
  320 FORMAT(' ERROR RETURN FROM EB06,ORDER OF MATRIX=',I4)
      GO TO 300
      END
C
      BLOCK DATA XD1
      COMMON /EB06BD/LP,LB,ITS
      INTEGER*4 LP,LB,ITS
      DATA LP/6/
      DATA LB/0/
      DATA ITS/30/
      END
C
      SUBROUTINE EB08AD(H,IH,V,IV,E,N,LFAIL)
C***********************************************************************
C*                                                                     *
C* PURPOSE.                                                            *
C*    FINDS THE EIGENVALUES AND EIGENVECTORS OF AN UPPER               *
C*    HESSENBERG MATRIX H.                                             *
C*                                                                     *
C* ARGUMENT LIST                                                       *
C*    H     TWO DIMENSIONAL REAL ARRAY CONTAINING THE MATRIX H,THIS    *
C*          ARRAY IS OVERWRITTEN BY THE ROUTINE                        *
C*    IH    FIRST DIMENSION OF ARRAY H                                 *
C*    V     TWO DIMENSIONAL REAL ARRAY WHICH WILL CONTAIN THE          *
C*          EIGENVECTORS.IF THE ITH EIGENVALUE IS REAL THEN THE ITH    *
C*          COLUMN OF V WILL CONTAIN THE CORRESPONDING EIGENVECTOR.IF  *
C*          EIGENVALUES I AND I+1 ARE A COMPLEX PAIR THE COLUMNS I AND *
C*          I+1 OF V GIVE THE REAL AND IMAGINARY PART OF THE           *
C*          EIGENVECTOR CORRESPONDING TO THE EIGENVALUE WITH POSITIVE  *
C*          IMAGINARY PART.                                            *
C*    IV    FIRST DIMENSION OF THE ARRAY V                             *
C*    E     ONE DIMENSIONAL COMPLEX ARRAY WHICH WILL CONTAIN           *
C*          THE EIGENVALUES.                                           *
C*    N     ORDER OF THE MATRIX H.                                     *
C*    LFAIL IS AN ERROR RETURN PARAMETER AND WILL BE ZERO ON           *
C*          ON A SUCCESFUL RETURN.                                     *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C*                                                                     *
C* LABELLED COMMON ARGUMENT LIST       (DEFAULTED IN BLOCK DATA        *
C*    LP    IS INTEGER AND IS THE STREAM NUMBER FOR DIAGNOSTIC MESSAGES*
C*          (DEFAULT VALUE IS 6)                                       *
C*    ITSM  IS INTEGER AND IS SET TO THE UPPER LIMIT ON THE NUMBER OF  *
C*          ITERATIONS IN OBTAINING AN EIGENVALUE.                     *
C*          (DEFAULT VALUE IS 30)                                      *
C*    LLL   ARE INTEGERS WHICH HAVE BEEN PRODUCED IN BALANCING WHERE   *
C*    LLU   EIGENVALUES ARE ISOLATED IN POSITIONS 1 TO LLL-1 AND LLU+1 *
C*          TO N  (DEFAULT VALUES ARE BOTH 0)                          *
C*          NOTE THAT THE VALUE OF 0 FOR LLL IS TAKEN TO MEAN THE      *
C*          SAME AS LLL=1 AND LLU=N                                    *
C*    JH    IS INTEGER.IF JH HAS THE VALUE 0,THEN THE EIGENVECTOR      *
C*          MATRIX IS INITIALISED TO THE IDENTITY MATRIX.IF JH HAS A   *
C*          NON ZERO VALUE THEN IT IS ASSUMED THAT THE EIGENVECTOR     *
C*          MATRIX HAS ALREADY BEEN SET   (DEFAULT VALUE IS 0)         *
C*    LFLG  IS INTEGER (DEFAULT VALUE 0) WHICH INDICATES THAT THE      *
C*          ICNT ARRAY IS NOT USED.IF THE USER REQUIRES ICNT ARRAY     *
C*          TO BE USED THEN LFLG SHOULD BE SET TO A NON ZERO VALUE     *
C*    ICNT  ONE DIMENSIONAL INTEGER ARRAY OF LENGTH N WHICH WILL GIVE  *
C*          THE NUMBER OF ITERATIONS FOR THE EIGENVALUES.IF TWO        *
C*          EIGENVALUES ARE FOUND SIMULTANEOUSLY THEN THE NUMBER OF    *
C*          ITERATIONS IS GIVEN WITH A POSITIVE SIGN FOR THE FIRST     *
C*          OF THE PAIR AND WITH A NEGATIVE SIGN FOR THE SECOND        *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C    ALL REAL VARIABLES IN THIS SUBROUTINE MUST BE DEFINED AS DOUBLE   *
C    PRECISION VARIABLES. PLEASE NOTE WHEN CHANGING THIS ROUTINE       *
C***********************************************************************
      COMMON /EB08BD/LP,ITSM,LLL,LLU,JH  ,LFLG
      COMMON/EB08CD/    ICNT(1)
      INTEGER LFLG
      COMPLEX*16 E(N),CV
      DOUBLE PRECISION H(IH,N),V(IV,N),RV(2)
      DOUBLE PRECISION ACC,P  ,Q  ,R  ,RA ,S  ,SA ,SJC,T  ,U  ,
     .                 VI ,VR ,WI ,WR ,WW ,X  ,XN ,Y  ,Z  ,ZERO
C
      DATA ZERO/0D0/
C
      EQUIVALENCE(RV(1),CV)
      LOGICAL NOTLST
C
C-----------------------------------------------------------------------
C
C     RELATIVE MACHINE PRECISION FOR IBM AND CRAY
      ACC=1.0D0/16.0D0**13
C
      IF(N .LE.0)GO TO 230
      LL=1
      LU=N
      IF(LLL.LE.0)GO TO 90
      LL=LLL
      LU=LLU
   90 IF(JH.NE.0)GO TO 130
      DO 110 I=1,N
      DO 100 J=1,N
  100 V(I,J)=ZERO
  110 V(I,I)=1D0
  130 LFAIL=0
      T=ZERO
C
C     ISOLATED ROOTS
      I=0
  140 I=I+1
      IF(I.GT.LL-1)GO TO 150
      E(I)=H(I,I)
      IF(LFLG.NE.0)ICNT(I)=0
      GO TO 140
  150 I=LU
  155 I=I+1
      IF(I.GT.N)GO TO 160
      E(I)=H(I,I)
      IF(LFLG.NE.0)ICNT(I)=0
      GO TO 155
  160 NE=LU
  170 IF(NE.LT.LL)GO TO 520
      ITS=0
      NA=NE-1
C
C     LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT
  180 L=NE+1
      IF(NE.LE.LL)GO TO 200
      L1=LL+1
      DO 190 II=L1,NE
      L=L-1
      IF(DABS(H(L,L-1)).LE.(ACC*(DABS(H(L-1,L-1))+DABS(H(L,L)))))GO TO 2
     *10
  190 CONTINUE
  200 L=LL
  210 X=H(NE,NE)
      IF(L.EQ.NE)GO TO 450
      Y=H(NA,NA)
      U=H(NE,NA)*H(NA,NE)
      IF(L.EQ.NA) GO TO 460
      IF(ITS.NE.ITSM)GO TO 260
C     ERROR RETURNS
      IF(LP.GT.0)WRITE(LP,220)ITSM
  220 FORMAT(' ERROR RETURN FROM EB08 BECAUSE MORE THAN',I4,' ITERATIONS
     1 WERE REQUIRED')
      IF(LFLG.NE.0)ICNT(NE)=ITSM+1
      LFAIL=NE
      GO TO 250
  230 IF(LP.GT.0)WRITE(LP,240)N
  240 FORMAT(' ERROR RETURN FROM EB08 BECAUSE ORDER OF MATRIX WAS ',I4)
      LFAIL=-1
  250 RETURN
  260 IF((ITS.EQ.10).OR.(ITS.EQ.20)) GO TO 270
      GO TO 290
C
C     FORM EXCEPTIONAL SHIFT
  270 T=T+X
      DO 280 I=LL,NE
  280 H(I,I)=H(I,I)-X
      S=DABS(H(NE,NA))+DABS(H(NA,NE-2))
      X=0.75D0*S
      Y=X
      U=-0.4375D0*S*S
  290 ITS=ITS+1
      IF(L.GT.(NE-2))GO TO 310
      M=NE-1
      N2=NE-2
C
C     LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS
      DO 300 MM=L,N2
      M=M-1
      Z=H(M,M)
      R=X-Z
      S=Y-Z
      P=(R*S-U)/H(M+1,M)+H(M,M+1)
      Q=H(M+1,M+1)-Z-R-S
      R=H(M+2,M+1)
      S=DABS(P)+DABS(Q)+DABS(R)
      P=P/S
      Q=Q/S
      R=R/S
      IF(M.EQ.L) GO TO 310
      IF((DABS(H(M,M-1))*(DABS(Q)+DABS(R))).LE.
     1(ACC*DABS(P)*(DABS(H(M-1,M-1))+DABS(Z)+DABS(H(M+1,M+1)))))GO TO 31
     *0
  300 CONTINUE
  310 M2=M+2
      DO 320 I=M2,NE
  320 H(I,I-2)=ZERO
      M3=M+3
      IF(M3.GT.NE)GO TO 340
      DO 330 I=M3,NE
  330 H(I,I-3)=ZERO
C
C     DOUBLE QR STEP INVOLVING ROWS L TO N AND COLUMNS M TO N
  340 IF(M.GT.NA) GO TO 180
      DO 440 K=M,NA
      NOTLST=.TRUE.
      IF(K.EQ.NA) NOTLST=.FALSE.
      IF(K.EQ.M) GO TO 350
      P=H(K,K-1)
      Q=H(K+1,K-1)
      R=ZERO
      IF(NOTLST) R=H(K+2,K-1)
      X=DABS(P)+DABS(Q)+DABS(R)
      IF(X.EQ.ZERO)GO TO 440
      P=P/X
      Q=Q/X
      R=R/X
  350 S=DSQRT(P*P+Q*Q+R*R)
      IF(P.LT.ZERO)S=-S
      IF(K.NE.M) GO TO 360
      IF(L.NE.M) H(K,K-1)=-H(K,K-1)
      GO TO 370
  360 H(K,K-1)=-S*X
  370 P=P+S
      X=P/S
      Y=Q/S
      Z=R/S
      Q=Q/P
      R=R/P
C
C     ROW MODIFICATION
      DO 390 J=K,N
      P=H(K,J)+Q*H(K+1,J)
      IF(.NOT.NOTLST) GO TO 380
      P=P+R*H(K+2,J)
      H(K+2,J)=H(K+2,J)-P*Z
  380 H(K+1,J)=H(K+1,J)-P*Y
  390 H(K,J)=H(K,J)-P*X
      J=NE
      IF((K+3).LT.NE)J=K+3
C
C     COLUMN MODIFICATION
      DO 410 I=1,J
      P=X*H(I,K)+Y*H(I,K+1)
      IF(.NOT.NOTLST) GO TO 400
      P=P+Z*H(I,K+2)
      H(I,K+2)=H(I,K+2)-P*R
  400 H(I,K+1)=H(I,K+1)-P*Q
  410 H(I,K)=H(I,K)-P
C
C     ACCUMULATE TRANSFORMATIONS
      DO 430 I=LL,LU
      P=X*V(I,K)+Y*V(I,K+1)
      IF(.NOT.NOTLST)GO TO 420
      P=P+Z*V(I,K+2)
      V(I,K+2)=V(I,K+2)-P*R
  420 V(I,K+1)=V(I,K+1)-P*Q
  430 V(I,K)=V(I,K)-P
  440 CONTINUE
      GO TO 180
C
C     ONE ROOT FOUND
  450 E(NE)=X+T
      H(NE,NE)=E(NE)
      IF(LFLG.NE.0)ICNT(NE)=ITS
      NE=NA
      GO TO 170
C
C     TWO ROOTS FOUND
  460 P=(Y-X)/2.0D0
      Q=P*P+U
      Z=DSQRT(DABS(Q))
      X=X+T
      H(NE,NE)=X
      H(NA,NA)=Y+T
      IF(LFLG.NE.0)ICNT(NE)=-ITS
      IF(LFLG.NE.0)ICNT(NA)=ITS
      IF(Q.GT.ZERO)GO TO 470
C
C     COMPLEX PAIR
      E(NA)=DCMPLX(X+P,Z)
      E(NE)=DCMPLX(X+P,-Z)
      GO TO 510
C
C     REAL PAIR
  470 IF(P.LT.ZERO)Z=-Z
      Z=P+Z
      E(NA)=X+Z
      S=X-U/Z
      E(NE)=S
      X=H(NE,NA)
      R=DSQRT(X*X+Z*Z)
      P=X/R
      Q=Z/R
      DO 480 J=NA,N
      Z=H(NA,J)
      H(NA,J)=Q*Z+P*H(NE,J)
  480 H(NE,J)=Q*H(NE,J)-P*Z
      DO 490 I=1,NE
      Z=H(I,NA)
      H(I,NA)=Q*Z+P*H(I,NE)
  490 H(I,NE)=Q*H(I,NE)-P*Z
      DO 500 I=LL,LU
      Z=V(I,NA)
      V(I,NA)=Q*Z+P*V(I,NE)
  500 V(I,NE)=Q*V(I,NE)-P*Z
  510 NE=NE-2
      GO TO 170
C
C     CALCULATE NORM
  520 XN=ZERO
      K=1
      DO 540 I=1,N
      DO 530 J=K,N
  530 XN=XN+DABS(H(I,J))
  540 K=I
C
C     BACKSUBSTITUTION
      DO 670 KK=1,N
      NE=N+1-KK
      CV=E(NE)
      P=RV(1)
      Q=RV(2)
      NA=NE-1
      IF(Q)550,620,670
C
C     COMPLEX VECTOR ASSOCIATED WITH LAMBDA = P - I X Q
  550 M=NA
      IF(DABS(H(NE,NA)).GT.DABS(H(NA,NE)))GO TO 560
      CV=DCMPLX(-H(NA,NE),ZERO)/DCMPLX(H(NA,NA)-P,Q)
      H(NA,NA)=RV(1)
      H(NA,NE)=RV(2)
      GO TO 570
  560 H(NA,NA)=-(H(NE,NE)-P)/H(NE,NA)
      H(NA,NE)=-Q/H(NE,NA)
  570 CONTINUE
      H(NE,NA)=1D0
      H(NE,NE)=ZERO
      IF(NA.LT.2)GO TO 670
      DO 610 II=2,NA
      I=NA-II+1
      U=H(I,I)-P
      CV=E(I)
      WR=RV(1)
      WI=RV(2)
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         IC=NA+1-M
         RA=H(I,NE)
         SA=ZERO
         IF ( IC .LE. 0 ) GO TO 2005
         SJC=ZERO
         DO 2000 JC=1,IC
         KC=M+JC-1
         SJC=SJC+H(I,KC)*H(KC,NA)
 2000    SA=SA+H(I,KC)*H(KC,NE)
         RA=RA+SJC
 2005    CONTINUE
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      IF(WI.LT.ZERO)GO TO 600
      M=I
      IF(WI.EQ.ZERO)GO TO 590
      X=H(I,I+1)
      Y=H(I+1,I)
      VR=(WR-P)**2+WI*WI-Q*Q
      VI=(WR-P)*2D0*Q
      IF(DABS(VR)+DABS(VI).EQ.ZERO)VR=XN*ACC*(DABS(U)+DABS(Q)+DABS(X)+DA
     1 BS(Y)+DABS(Z))
      CV=DCMPLX(X*R-Z*RA+Q*SA,X*S-Z*SA-Q*RA)/DCMPLX(VR,VI)
      H(I,NA)=RV(1)
      H(I,NE)=RV(2)
      IF(DABS(X).GT.DABS(Z)+DABS(Q))GO TO 580
      CV=-DCMPLX(R+Y*H(I,NA),S+Y*H(I,NE))/DCMPLX(Z,Q)
      H(I+1,NA)=RV(1)
      H(I+1,NE)=RV(2)
      GO TO 610
  580 H(I+1,NA)=(-RA-U*H(I,NA)+Q*H(I,NE))/X
      H(I+1,NE)=(-SA-U*H(I,NE)-Q*H(I,NA))/X
      GO TO 610
  590 CV=-DCMPLX(RA,SA)/DCMPLX(U,Q)
      H(I,NA)=RV(1)
      H(I,NE)=RV(2)
      GO TO 610
  600 Z=U
      R=RA
      S=SA
  610 CONTINUE
      GO TO 670
C
C     REAL VECTOR
  620 M=NE
      H(NE,NE)=1D0
      IF(NA.LT.1)GO TO 670
      DO 660 II=1,NA
      I=NA+1-II
      U=H(I,I)-P
      CV=E(I)
      WR=RV(1)
      WI=RV(2)
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         IC=NA+1-M
         R=H(I,NE)
         IF ( IC .LE. 0 ) GO TO 2015
         SJC=ZERO
         DO 2010 JC=1,IC
         KC=M+JC-1
 2010    SJC=SJC+H(I,KC)*H(KC,NE)
         R=R+SJC
 2015    CONTINUE
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      IF(WI .LT. ZERO)GO TO 650
      M=I
      IF(WI .EQ. ZERO)GO TO 640
      X=H(I,I+1)
      Y=H(I+1,I)
      Q=(WR-P)**2+WI*WI
      T=(X*S-Z*R)/Q
      H(I,NE)=T
      IF(DABS(X).GT.DABS(Z))GO TO 630
      H(I+1,NE)=(-S-Y*T)/Z
      GO TO 660
  630 H(I+1,NE)=(-R-U*T)/X
      GO TO 660
  640 WW=U
      IF(WW.EQ.ZERO)WW=ACC*XN
      H(I,NE)=-R/WW
      GO TO 660
  650 Z=U
      S=R
  660 CONTINUE
  670 CONTINUE
C
C     VECTORS OF ISOLATED ROOTS
      IF(N.LT.2)GO TO 700
      K=0
      I=0
  675 IF(I.GT.LL-2)GO TO 690
  680 I=I+1
      IF(I.GE.N)GO TO 700
      I1=I+1
      DO 685 J=I1,N
  685 V(I,J)=H(I,J)
      IF(K)675,675,680
  690 I=LU
      K=1
      GO TO 680
  700 CONTINUE
C
C     MULTIPLY BT TRANSFORMATION MATRIX TO GIVE VECTORS OF ORIGINAL
C     FULL MATRIX
      IF(LL.GT.LU)GO TO 755
      DO 750 JJ=LL,N
      J=N+LL-JJ
      M=LU
      IF(J.LT.LU)M=J
      II=M+1-LL
      L=J-1
      CV=E(J)
      IF(RV(2))730,710,750
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
 710     IF ( II .LE. 0 ) GO TO 2025
         DO 720 I=LL,LU
         SJC=ZERO
         DO 2020 JC=1,II
         KC=LL+JC-1
 2020    SJC=SJC+V(I,KC)*H(KC,J)
  720    V(I,J)=SJC
         GO TO 750
 2025    DO 2026 I=LL,LU
 2026    V(I,J)=ZERO
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      GO TO 750
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
 730     IF ( II .LE. 0 ) GO TO 2035
         DO 740 I=LL,LU
         Z=ZERO
         SJC=ZERO
         DO 2030 JC=1,II
         KC=LL+JC-1
         Z=Z+V(I,KC)*H(KC,L)
 2030    SJC=SJC+V(I,KC)*H(KC,J)
         V(I,J)=SJC
  740    V(I,L)=Z
         GO TO 750
 2035    DO 2036 I=LL,LU
         V(I,J)=ZERO
 2036    V(I,L)=ZERO
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
  750 CONTINUE
C
C     NORMALISE EIGENVECTORS TO HAVE LARGEST ELEMENT ONE
  755 I=0
  760 I=I+1
      IF(I.GT.N)GO TO 800
      CV=E(I)
      IF(RV(2).NE.ZERO)GO TO 780
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         Z=ZERO
         DO 2040 JC=1,N
 2040    Z=Z+V(JC,I)*V(JC,I)
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      Z=1D0/DSQRT(Z)
      DO 770 J=1,N
  770 V(J,I)=V(J,I)*Z
      GO TO 760
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
 780     IPL1=I+1
         Z=ZERO
         SJC=ZERO
         DO 2050 JC=1,N
         Z=Z+V(JC,I)*V(JC,I)
 2050    SJC=SJC+V(JC,IPL1)*V(JC,IPL1)
         Z=Z+SJC
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      Z=1D0/DSQRT(Z)
      DO 790 J=1,N
      V(J,I)=V(J,I)*Z
  790 V(J,I+1)=V(J,I+1)*Z
      I=I+1
      GO TO 760
  800 RETURN
      END
C
      BLOCK DATA XD2
      COMMON /EB08BD/LP,ITSM,LLL,LLU,JH,LFLG
C
      INTEGER*4 LP,ITSM,LLL,LLU,JH
      DATA LP/6/
      DATA ITSM/30/
      DATA LLL/0/
      DATA LLU/0/
      DATA JH/0/
      INTEGER LFLG
      DATA LFLG/0/
      END
C
      SUBROUTINE MC15AD(A,IA,N,W,LL,LU)
C***********************************************************************
C*                                                                     *
C* PURPOSE.                                                            *
C*    BALANCES A MATRIX A. I.E. REDUCES THE NORM OF THE MATRIX A       *
C*          BY EXACT DIAGONAL SIMILARITY TRANSFORMATIONS               *
C*                                                                     *
C* ARGUMENT LIST.                                                      *
C*    A     TWO DIMENSIONAL REAL ARRAY CONTAINING THE MATRIX A,THIS    *
C*          ARRAY IS CHANGED BY THE ROUTINE.                           *
C*    IA    FIRST DIMENSION OF ARRAY A                                 *
C*    N     ORDER OF THE MATRIX A                                      *
C*    W     ONE DIMENSIONAL REAL ARRAY WHICH WILL CONTAIN INFORMATION  *
C*          DETERMINING THE PERMUTATATIONS USED AND THE SCALING FACTORS*
C*    LL,LU WILL BE SET BY THE ROUTINE SUCH THAT A(I,J)=0              *
C*          IF (1) J<I AND (2) J=1,2,..LL-1 OR I=LU+1,..,N             *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C    ALL REAL VARIABLES IN THIS SUBROUTINE MUST BE DEFINED AS DOUBLE   *
C    PRECISION VARIABLES. PLEASE NOTE WHEN CHANGING THIS ROUTINE       *
C***********************************************************************
      COMMON /MC15BD/LP
      DOUBLE PRECISION A(IA,N),W(N),ZERO
      DOUBLE PRECISION C     ,F     ,G     ,R     ,S
      DATA ZERO/0D0/
      INTEGER*4 IB
      LOGICAL*1 LF(4),LB(4)
      EQUIVALENCE (LF(1),F),(LB(1),IB)
      LOGICAL NOCONV
C
      IF(N.GT.0)GO TO 110
      IF(LP.GT.0)WRITE(LP,100)N
  100 FORMAT(/,' ERROR RETURN FROM MC15,ORDER OF MATRIX=',I5)
      GO TO 280
  110 L=0
      K=N+1
C
C     SEARCH FOR ROWS ISOLATING AN EIGENVALUE AND PUSH THEM DOWN
  120 K=K-1
      IF(K.LT.1)GO TO 170
      DO 160 JJ=1,K
      J=K+1-JJ
      DO 130 I=1,K
      IF(I.EQ.J)GO TO 130
      IF(A(J,I) .NE. ZERO)GO TO 160
  130 CONTINUE
      W(K)=J
      IF(J.EQ.K)GO TO 120
      DO 140 I=1,K
      F=A(I,J)
      A(I,J)=A(I,K)
  140 A(I,K)=F
      DO 150 I=1,N
      F=A(J,I)
      A(J,I)=A(K,I)
  150 A(K,I)=F
      GO TO 120
  160 CONTINUE
C
C     SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE AND PUSH THEM LEFT
  170 L=L+1
      IF(K.LT.L)GO TO 280
      DO 210 J=L,K
      DO 180 I=L,K
      IF(I.EQ.J)GO TO 180
      IF(A(I,J) .NE. ZERO)GO TO 210
  180 CONTINUE
      W(L)=J
      IF(J.EQ.L)GO TO 170
      DO 190 I=1,K
      F=A(I,J)
      A(I,J)=A(I,L)
  190 A(I,L)=F
      DO 200 I=L,N
      F=A(J,I)
      A(J,I)=A(L,I)
  200 A(L,I)=F
      GO TO 170
  210 CONTINUE
C
C     NOW BALANCE THE SUBMATRIX IN ROWS L THROUGH K
      DO 220 I=L,K
  220 W(I)=1D0
  230 NOCONV=.FALSE.
      DO 270 I=L,K
      C=ZERO
      R=ZERO
      DO 240 J=L,K
      IF(J.EQ.I)GO TO 240
      C=C+DABS(A(J,I))
      R=R+DABS(A(I,J))
  240 CONTINUE
      S=C+R
C
C     THE FOLLOWING 6 STATEMENTS FINDS F=B**L WHERE B=16=BASE OF MACHINE
C     SUCH THAT SQRT(R/(C*B)) .LE. F .LT. SQRT(R*B/C)
      F=R/C
      IB=0
      LB(4)=LF(1)
      IB=IB/2+33
      F=1D0
      LF(1)=LB(4)
      G=1D0/F
      IF((F*F*C+R)*G .GE. .95D0*S)GO TO 270
C
C     BALANCE
      W(I)=W(I)*F
      NOCONV=.TRUE.
      DO 250 J=L,N
  250 A(I,J)=A(I,J)*G
      DO 260 J=1,K
  260 A(J,I)=A(J,I)*F
  270 CONTINUE
      IF(NOCONV)GO TO 230
  280 LL=L
      LU=K
      RETURN
      END
C
      BLOCK DATA XD3
      COMMON /MC15BD/LP
      INTEGER*4 LP
      DATA LP/6/
      END
C
      SUBROUTINE MC14AD(A,N,IA,W,KK,LL)
C***********************************************************************
C*                                                                     *
C* PURPOSE.                                                            *
C*    THIS ROUTINE REDUCES A PARTTION OF THE UNSYMMETRIC MATRIX A      *
C*    TO AN UPPER HEESENBERG MATRIX BY ORTHOGONAL TRANSFORMATIONS      *
C*                                                                     *
C* ARGUMENT LIST.                                                      *
C*    A     TWO DIMENSIONAL REAL ARRAY CONTAINING THE MATRIXA,THE      *
C*          APPROPIATE SUBMATRIX PART OFIS ARRAY IS OVERWRITTEN BY THE *
C*          HESSENBERG FORM.THE ELENENTS IN THE TRIANGLE BELOW THE     *
C*          SUBDIAGONAL WILL CONTAIN DETAILS OF THE TRANSFORMATIONS    *
C*   IA     FIRST DIMENSION OF ARRAY A.                                *
C*    N     ORDER OF THE MATRIX A.                                     *
C*    W     WORKING SPACE ARRAY OF LENGTH N WHICH WILL CONTAIN DETAILS *
C*          OF THE TRANSFORMATIONS.                                    *
C*    KK    )PARAMETERS WHICH SPECIFY THE BOUNDS OF THE SUBMATRIX TO BE*
C*    LL    REDUCED.THE SUBMATRIX REDUCED IS OF ORDER LL-KK+1
C*          STARTING AT POSITION A( KK, KK) AND FINSHING AT POSITION   *
C*          A(LL,LL). IF KK+1 .GT. LL-1 THEN NO REDUCTION IS DONE      *
C*                                                                     *
C***********************************************************************
C***********************************************************************
C    ALL REAL VARIABLES IN THIS SUBROUTINE MUST BE DEFINED AS DOUBLE   *
C    PRECISION VARIABLES. PLEASE NOTE WHEN CHANGING THIS ROUTINE       *
C***********************************************************************
      COMMON /MC14CD/LP
      DOUBLE PRECISION A(IA,N),W(N)
      DOUBLE PRECISION F,G,H,TOL,ZERO
C
      DATA ZERO/0D0/
C
C     SMALLEST NUMBER DIVIDED BY THE MACHINE PRECISION ON IBM AND CRAY
      DATA TOL/.24D-62/
C
C-----------------------------------------------------------------------
      K=KK
      L=LL
      GO TO 50
      ENTRY MC14BD(A,N,IA,W)
      K=1
      L=N
   50 CONTINUE
      IF(N.LE.0)GO TO 190
  100 LA=L-1
      K1=K+1
      IF(K1.GT.LA)GO TO 180
      DO 170 M=K1,LA
      H=ZERO
      DO 110 II=M,L
      I=L+M-II
      F=A(I,M-1)
      W(I)=F
  110 H=H+F*F
      G=ZERO
      IF(H.LE.TOL)GO TO 160
      G=DSIGN(DSQRT(H),-F)
      H=H-F*G
      W(M)=F-G
C
C     FORM (I-(U X U(TRANSPOSE)/H) X A
      DO 130 J=M,N
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         IC=L+1-M
         F=ZERO
         IF ( IC .LE. 0 ) GO TO 305
         DO 300 JC=1,IC
         KC=M+JC-1
 300     F=F+W(KC)*A(KC,J)
 305     CONTINUE
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      F=F/H
      DO 120 I=M,L
  120 A(I,J)=A(I,J)-F*W(I)
  130 CONTINUE
C
C     FORM (I-U X U(TRANSPOSE)/H) X A X (I-U X U(TRANSPOSE)/H)
      DO 150 I=1,L
C-----------------------------------------------------------------------
C     REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
         IC=L+1-M
         F=ZERO
         IF ( IC .LE. 0 ) GO TO 315
         DO 310 JC=1,IC
         KC=M+JC-1
 310     F=F+W(KC)*A(I,KC)
 315     CONTINUE
C     END REPLACEMENT OF ASSEMBLER ROUTINE MC03AD
C-----------------------------------------------------------------------
      F=F/H
      DO 140 J=M,L
  140 A(I,J)=A(I,J)-F*W(J)
  150 CONTINUE
  160 A(M,M-1)=G
  170 CONTINUE
  180 RETURN
  190 IF(LP.GT.0)WRITE(LP,200)N
  200 FORMAT(' ERROR RETURN FROM MC14 BECAUSE ORDER OF MATRIX WAS ',I4)
      GO TO 180
      END
C
      BLOCK DATA XD4
      COMMON /MC14CD/LP
      INTEGER*4 LP
      DATA LP/6/
      END
C  END OF THE EIGENVALUE & EIGENVECTOR PACKAGE FOR A GENERAL REAL MATRIX
C  =====================================================================
C
C=======================================================================
      SUBROUTINE SLORA(MI,NI,NJ,ILC,JFP,JLP,A,B,C,D,E,F,U0,NITERS,
     *                 IRC,ISWEEP,JSWEEP,OMEGA,EPS,NOUT,ITUSED,U,IFAIL,
     *                 WM,WIJ)
C
      IMPLICIT NONE
C     SPECIFICATIONS FOR ARGUMENTS
      INTEGER   MI,NI,NJ,ILC,JFP,JLP,NITERS,NOUT,IFAIL,ITUSED,
     *          IRC,ISWEEP,JSWEEP
      REAL*8    A(MI,NJ),B(MI,NJ),C(MI,NJ),D(MI,NJ),E(MI,NJ),F(MI,NJ),
     *          U0(MI,NJ),U(MI,NJ),OMEGA,EPS
C
C - INPUT
C     MI       LEADING DIMENSION OF MATRICES
C     NI       NUMBER OF COLUMNS
C     NJ       NUMBER OR ROWS
C     ILC      LAST CLOSED I-COLUMN (BETWEEN JFP AND JLP)
C     JFP      FIRST PERIODIC J-MESH POINT
C     JLP      LAST  PERIODIC J-MESH POINT
C     A,B,C,D,E,F   MATRICES
C     U0       GUESS OF THE SOLUTION
C     NITERS   MAXIMUM NUMBER OF ITERATIONS
C     IRC      SWEEPING ORDER
C              (1: ALONG ROWS FIRST, 2: ALONG COLUMNS FIRST)
C     ISWEEP   DIRECTION OF SWEEP ALONG ROWS
C              (+1: POSITIVE, -1: NEGATIVE, 0: ALTERNATE ...
C                                          ... AWAY FROM EDGES I,NI-1+I)
C     JSWEEP   DIRECTION OF SWEEP ALONG COLUMNS
C              (AS ABOVE)
C     OMEGA    RELAXATION PARAMETER
C     EPS      REQUIRED ACCURACY
C     NOUT     OUTPUT CHANNEL
C - OUTPUT
C     ITUSED   NUMBER OF ITERATIONS PERFORMED
C     U        SOLUTION
C     IFAIL    ERROR FLAG (0-NO ERRORS, GT.0-ERRORS DETECTED)
C     WM       ATTAINED ACCURACY
C
C     PURPOSE: SOLVE THE SYSTEM
C
C       A(I,J)*U(I,J-1) + B(I,J)*U(I-1,J) + C(I,J)*U(I,J) +
C     + D(I,J)*U(I+1,J)                   + E(I,J)*U(I,J+1) = F(I,J)
C
C       IN THE RECTANGLE ((I=1,NI),J=1,NJ)
C
C       WITH (POSSIBLY INTERNAL) PERIODIC BOUNDARY CONDITIONS,
C            U( I,JFP-1/2 ) = U( I,JLP+1/2 )       I=1,ILC+1/2
C       (FULL PERIODICITY:  ILC=NI, JFP=1, JLP=NJ)
C
C
C
C  11   NJ     .  .  .  .  .  .  .  .  .
C
C  10          .  .  .  .  .  .  .  .  .
C
C   9   JLP+1  .  .  .  .  .  .  .  .  .
C             ------------
C   8   JLP    .  .  .  .  .  .  .  .  .
C
C   7          .  .  .  .  .  .  .  .  .
C
C   6          .  .  .  .  .  .  .  .  .
C
C   5   JFP    .  .  .  .  .  .  .  .  .
C             ------------
C   4   JFP-1  .  .  .  .  .  .  .  .  .
C
C   3          .  .  .  .  .  .  .  .  .
C
C   2          .  .  .  .  .  .  .  .  .
C
C   1   1      .  .  .  .  .  .  .  .  .
C
C              1       ILC            NI
C
C              1  2  3  4  5  6  7  8  9
C
C
C     METHOD: SUCCESSIVE LINE OVER-RELAXATION
C
      EXTERNAL TRID
C
C     SPECIFICATIONS FOR LOCAL VARIABLES
      INTEGER   M
      PARAMETER (M=200)
      REAL*8    V(M),R(M),Q(M),P(M),S(M),
     *          UIM1J,UIP1J,UIJM1,UIJP1,WIJ(MI,NJ),WM,LHS,RHS,LHA
C--->          ,RES(M,M)
      INTEGER   ITER,I,J,JP1,JM1,K,II,JJ
C
      INTRINSIC ABS,MOD,MAX
C
C
      IFAIL = 9
C
      IF( NI.GT.M .OR. NJ.GT.M) THEN
        WRITE(NOUT,10)
   10   FORMAT(' DIMENSION EXCEEDED IN SLORA')
        IFAIL = 1
        RETURN
      END IF
C
      IF( ILC.GT.0 .AND. (JFP.LT.1 .OR. JLP.GT.NJ .OR. JFP.GE.JLP) )THEN
        WRITE(NOUT,20) JFP,JLP,NJ
   20   FORMAT(' ERROR IN SLORA: JFP=',I2,' < 1,  OR  JLP=',I2,' > ',I2,
     *                        ', OR  JFP >= JLP')
        IFAIL = 1
        RETURN
      END IF
C
C
      DO 120 J=1,NJ
        DO 110 I=1,NI
          U(I,J) = U0(I,J)
C--->     RES(I,J) = 0.0D0
  110   CONTINUE
  120 CONTINUE
C
C     ITERATIONS
C
      DO 430 ITER=1,NITERS
C
        IF( IRC.EQ.2 ) GOTO 300
C
  200   CONTINUE
C       FOR EACH ROW J
        DO 230 JJ=1,NJ
          IF(JSWEEP) 201,202,203
  201       J=NJ-JJ+1
          GOTO 204
  202       J=JJ/2+1
            IF(MOD(JJ,2).EQ.0) J=NJ-JJ/2+1
          GOTO 204
  203       J=JJ
  204     CONTINUE
          DO 210 I=1,NI
            R(I) = B(I,J)
            Q(I) = C(I,J)/OMEGA
            P(I) = D(I,J)
            S(I) = F(I,J)-(OMEGA-1.0D0)/OMEGA*C(I,J)*U(I,J)
C--->&           - RES(I,J)
            JM1 = J-1
            JP1 = J+1
            IF( I.LE.ILC ) THEN
              IF( J.EQ.JFP-1 ) JP1=JLP+1
              IF( J.EQ.JFP ) JM1=JLP
              IF( J.EQ.JLP ) JP1=JFP
              IF( J.EQ.JLP+1 ) JM1=JFP-1
            ENDIF
            IF( JM1.GE.1  ) S(I) = S(I) - A(I,J)*U(I,JM1)
            IF( JP1.LE.NJ ) S(I) = S(I) - E(I,J)*U(I,JP1)
  210     CONTINUE
          R(1) = 0.0D0
          P(NI) = 0.0D0
          CALL TRID(NI,R(1),Q(1),P(1),S(1),NOUT,V(1),IFAIL)
          IF( IFAIL.GT.0 ) GOTO 600
          DO 220 I=1,NI
            U(I,J) = V(I)
  220     CONTINUE
  230   CONTINUE
        IF( IRC.EQ.2 ) GOTO 360
C
  300   CONTINUE
C       FOR EACH COLUMN I
        DO 350 II=1,NI
          IF(ISWEEP) 301,302,303
  301       I=NI-II+1
          GOTO 304
  302       I=II/2+1
            IF(MOD(II,2).EQ.0) I=NI-II/2+1
          GOTO 304
  303       I=II
  304     CONTINUE
C         NON-PERIODIC : J = 1, 2, 3, ..., JFP-1, JLP+1,...,NJ
          K = 0
          DO 310 J=1,NJ
            IF( I.LE.ILC .AND. J.GE.JFP .AND. J.LE.JLP ) GOTO 310
            K = K + 1
            R(K) = A(I,J)
            Q(K) = C(I,J)/OMEGA
            P(K) = E(I,J)
            S(K) = F(I,J)-(OMEGA-1.0D0)/OMEGA*C(I,J)*U(I,J)
C--->&           - RES(I,J)
            IF( I.GT.1  ) S(K) = S(K) - B(I,J)*U(I-1,J)
            IF( I.LT.NI ) S(K) = S(K) - D(I,J)*U(I+1,J)
  310     CONTINUE
          IF( K.GT.0 ) THEN
            R(1) = 0.0D0
            P(K) = 0.0D0
            CALL TRID(K,R(1),Q(1),P(1),S(1),NOUT,V(1),IFAIL)
            IF( IFAIL.GT.0 ) GOTO 600
            K = 0
            DO 320 J=1,NJ
              IF( I.LE.ILC .AND. J.GE.JFP .AND. J.LE.JLP ) GOTO 320
              K = K + 1
              U(I,J) = V(K)
  320       CONTINUE
          ENDIF
C         PERIODIC : J = JFP, JFP+1, ... ,JLP (,JLP+1=JFP)
          IF( I.GT.ILC .OR. JLP-JFP.LT.0 ) GOTO 350
          DO 330 J=JFP,JLP
            R(J) = A(I,J)
            Q(J) = C(I,J)/OMEGA
            P(J) = E(I,J)
            S(J) = F(I,J)-(OMEGA-1.0D0)/OMEGA*C(I,J)*U(I,J)
C--->&           - RES(I,J)
            IF( I.GT.1  ) S(J) = S(J) - B(I,J)*U(I-1,J)
            IF( I.LT.NI ) S(J) = S(J) - D(I,J)*U(I+1,J)
  330     CONTINUE
          CALL TRID(JLP-JFP+1,R(JFP),Q(JFP),P(JFP),S(JFP),NOUT,V(JFP),
     *              IFAIL)
          IF( IFAIL.GT.0 ) GOTO 600
          DO 340 J=JFP,JLP
            U(I,J) = V(J)
  340     CONTINUE
  350   CONTINUE
        IF( IRC.EQ.2 ) GOTO 200
C
  360   ITUSED = ITER
        IF( EPS.LE.0.0D0 ) GOTO 430
C
C       RESIDUES
        WM = 0.0D0
        DO 420 I=1,NI
          DO 410 J=1,NJ
C  J
            JM1 = J-1
            JP1 = J+1
            IF( I.LE.ILC ) THEN
              IF( J.EQ.JFP-1 ) JP1=JLP+1
              IF( J.EQ.JFP ) JM1=JLP
              IF( J.EQ.JLP ) JP1=JFP
              IF( J.EQ.JLP+1 ) JM1=JFP-1
            ENDIF
            UIJM1 = 0.0D0
            IF( JM1.GE.1 ) UIJM1 = U(I,JM1)
            UIJP1 = 0.0D0
            IF( JP1.LE.NJ) UIJP1 = U(I,JP1)
C  I
            UIM1J = 0.0D0
            IF( I.GT.1 ) UIM1J = U(I-1,J)
            UIP1J = 0.0D0
            IF( I.LT.NI ) UIP1J = U(I+1,J)
C
            LHS = A(I,J)*UIJM1 + B(I,J)*UIM1J + C(I,J)*U(I,J) +
     *            D(I,J)*UIP1J                + E(I,J)*UIJP1
            RHS = F(I,J)
            WIJ(I,J) = LHS - RHS
C--->       RES(I,J) = WIJ(I,J)+RES(I,J)
            IF( WIJ(I,J).EQ.0.0D0) GOTO 410
            IF(RHS.NE.0.0D0) THEN
              WIJ(I,J) = WIJ(I,J) / (LHS + RHS ) * 2.0D0
            ELSE
              LHA = ABS(A(I,J)*UIJM1)
     *            + ABS(B(I,J)*UIM1J)
     *            + ABS(C(I,J)*U(I,J))
     *            + ABS(D(I,J)*UIP1J)
     *            + ABS(E(I,J)*UIJP1)
              WIJ(I,J) = LHS/LHA
            ENDIF
            WM = MAX(ABS(WIJ(I,J)),WM)
  410     CONTINUE
  420   CONTINUE
        IF( WM.LT.EPS ) GOTO 440
C
  430 CONTINUE
C
  440 CONTINUE
C
      IFAIL = 0
C
C
  600 CONTINUE
      RETURN
      END
C
C-----------------------------------------------------------------------
      SUBROUTINE DDX2N(NX,X,A,C,U,CSI,MODE, ALPHA)
      IMPLICIT REAL*8(A-H,O-Z)
C
C     TO COMPUTE
C
C       D/DX ( A * D/DX ( C * UCSI ) )    WITH UCSI = CSI*U'+(1-CSI)*U
C
C     AS:
C     ALPHA(1,I)*U'(I-1)+ALPHA(2,I)*U'(I)+ALPHA(3,I)*U'(I+1)+ALPHA(4,I)
C
C     ACCORDING TO   MODE=1   FOR GIVEN BOUNDARY CONDITIONS
C                    MODE=2   FOR PERIODICITY  AT NX+1/2
C                         ...,X(1),X(2),...,X(NX-1),X(N),X(1),X(2),...
C
      DIMENSION X(NX+1),A(NX),C(NX),U(NX),ALPHA(4,NX)
C
C
      NXM1=NX-1
      NXP1=NX+1
      UMCSI=1.0-CSI
C
      IF(MODE.EQ.2) THEN
        I1 = 1
        I2 = NX
      ELSE
        I1 = 2
        I2 = NXM1
      ENDIF
C
      DO 60 I=I1,I2
        IF(I.EQ.1) THEN
          HM = X(NXP1)-X(NX)
          HP = X(2)-X(1)
          IP1 = 2
          IM1 = NX
        ELSE IF(I.EQ.NX) THEN
          HM = X(NX)-X(NXM1)
          HP = X(NXP1)-X(NX)
          IP1 = 1
          IM1 = NXM1
        ELSE
          HM = X(I)-X(I-1)
          HP = X(I+1)-X(I)
          IP1 = I+1
          IM1 = I-1
        ENDIF
        H = (HM+HP)*0.5
        AM = (A(IM1)+A(I))*0.5
        AP = (A(I)+A(IP1))*0.5
        BM = AM*C(IM1)/(H*HM)
        B0 = -(AP/HP+AM/HM)*C(I)/H
        BP = AP*C(IP1)/(H*HP)
        ALPHA(1,I) = BM*CSI
        ALPHA(2,I) = B0*CSI
        ALPHA(3,I) = BP*CSI
        ALPHA(4,I) = UMCSI*(BM*U(IM1)+B0*U(I)+BP*U(IP1))
   60 CONTINUE
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE IDELEM( IMASS , ZMASS , IER )
      IMPLICIT LOGICAL(A-H,O-Z)
C+
C-----------------------------------------------------------------------
C
C ROUTINE : IDELEM
C
C VERSION : V1.R0.M0
C
C PURPOSE : TO IDENTIFY AN ELEMENT FROM THE ATOMIC NUMBER OR MASS.
C
C I/O     : (I*4) IMASS = ATOMIC NUMBER
C           (R*8) ZMASS = MASS   NUMBER
C
C OUTPUT  : (I*4) IER   = 0 --- ROUTINE SUCCESSFUL
C                       = 1 --- IMASS .GT. NELEM
C                       = 1 --- IMASS .LE. 0 .AND. ZMASS .LE. 0.00D+00
C
C PROGRAM : (I*4) NELEM = NUMBER OF ELEMENTS IN DATABASE
C           (I*4) IZ()  = ATOMIC NUMBERS OF ELEMENTS IN DATABASE
C           (R*8) Z0()  = MASS   NUMBERS OF ELEMENTS IN DATABASE
C           (R*8) DIFF  = DIFFERENCE BETWEEN DATABASE AND INPUT MASS
C           (R*8) ZMIN  = MININUM VALUE OF DIFF
C           (I*4) I     = LOOP VARIABLE
C
C METHOD  : (1) IF IMASS .LE. 0 THEN ZMASS WILL BE USED TO FIND IMASS
C           (2) IF ZMASS .LE. 0 THEN IMASS WILL BE USED TO FIND ZMASS
C           (3) IF IMASS .GT. 0 AND ZMASS .GT. 0 THEN IMASS WILL BE
C               OVERWRITTEN BY THE VALUE DEDUCED FROM ZMASS
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R0.M0 -- 02/04/92 -- CREATION
C
C-----------------------------------------------------------------------
C-
C..INPUT/OUTPUT
      INTEGER*4  IMASS
      REAL*8     ZMASS
C..PROGRAM
      PARAMETER( NELEM = 30 )
      INTEGER*4  IZ(NELEM) , I
      REAL*8     Z0(NELEM) , DIFF , ZMIN
C
      DATA IZ/ 01       , 02        , 03        , 04        , 05
     &       , 06       , 07        , 08        , 09        , 10
     &       , 11       , 12        , 13        , 14        , 15
     &       , 16       , 17        , 18        , 19        , 20
     &       , 21       , 22        , 23        , 24        , 25
     &       , 26       , 27        , 28        , 29        , 30
     &       /
C
      DATA Z0/  1.00D+00 ,  4.00D+00 ,  6.94D+00 ,  9.00D+00 , 10.81D+00
     &       , 12.00D+00 , 14.01D+00 , 16.00D+00 , 19.00D+00 , 20.18D+00
     &       , 22.99D+00 , 24.31D+00 , 26.98D+00 , 28.09D+00 , 30.97D+00
     &       , 32.06D+00 , 35.45D+00 , 39.95D+00 , 39.10D+00 , 40.08D+00
     &       , 44.96D+00 , 47.90D+00 , 50.94D+00 , 52.00D+00 , 54.94D+00
     &       , 55.85D+00 , 58.98D+00 , 58.71D+00 , 63.55D+00 , 65.37D+00
     &       /
C
      IER = 0
C
      IF( ZMASS.LE.0.00D+00 ) THEN
          IF( IMASS.GT.0 ) THEN
              IF( IMASS.LE.NELEM ) THEN
                  DO 100 I = 1 , NELEM
                     IF( IZ(I).EQ.IMASS ) ZMASS = Z0(I)
  100             CONTINUE
              ELSE
                  IER   = 1
              END IF
          ELSE
              IER       = 2
          END IF
      ELSE
          ZMIN          = DABS( Z0(1) - ZMASS )
          IMASS         = IZ(1)
          DO 200 I      = 2 , NELEM
             DIFF       = DABS( Z0(I) - ZMASS )
             IF( DIFF.LT.ZMIN ) THEN
                 ZMIN   = DIFF
                 IMASS  = IZ(I)
             END IF
  200     CONTINUE
      END IF
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE MTRAN(M,N,A,B)
      IMPLICIT REAL*8(A-H,O-Z)
C
C TRANSPOSE A MATRIX
C
      DIMENSION A(M,N),B(N,M)
      DO 100 J=1,N
        DO 100 I=1,M
          B(J,I) = A(I,J)
 100  CONTINUE
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE VADD(N,A,B,C)
      IMPLICIT REAL*8(A-H,O-Z)
C
C ADD TWO VECTORS
C
      DIMENSION A(N),B(N),C(N)
      DO 100 I=1,N
        C(I) = A(I) + B(I)
 100  CONTINUE
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE VDIV(N,A,B,C)
      IMPLICIT REAL*8(A-H,O-Z)
C
C DIVIDE VECTOR A BY VECTOR B ELEMENT BY ELEMENT
C
      DIMENSION A(N),B(N),C(N)
      DO 100 I = 1 , N
        IF( B(I).NE.0.0D0 )THEN
          C(I) = A(I) / B(I)
        ELSE
          C(I) = 0.0D0
        ENDIF
 100  CONTINUE
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CHRLTU( STRIN , STROUT )
      IMPLICIT NONE
C
C++ ....................................................................
C
C VERSION : V1.R1.M0
C
C ROUTINE : CHARACTER LOWER TO UPPER CONVERSION
C           -- -      -     -- -
C
C PURPOSE : TO CONVERT LOWER CASE CHARACTERS IN A STRING TO UPPER CASE.
C
C INPUT   : (C**) STRIN   = INPUT STRING
C
C OUTPUT  : (C**) STROUT  = OUTPUT STRING
C
C PROGRAM : (I*4) I       = INDEX COUNTER
C                 ICODE0  = BEGINNING OF CODE RANGE
C                 ICODE1  = FINISH OF CODE RANGE
c                 ICODE   = CHARACTER CODE
C                 IOFSET  = CODE OFF-SET
C
C METHOD  : A) EACH CHARACTER IN THE INPUT STRING IS CHECKED TO SEE IF
C              IT LIES IN THE LOWER CASE CODE RANGE
C           B) IS SO, THEN AN OFF-SET IS ADDED ONTO THE CODE OF THE
C              CHARACTER TO BRING IT INTO THE CORRESPONDING UPPER CODE
C              RANGE.
C
C ROUTINE : (I*4) IHAT    = 0 --- OUTSIDE INCLUSIVE RANGE
C                         = 1 --- INSIDE  INCLUSIVE RANGE
C
C
C AUTHOR  : J.SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C HISTORY : V1.R1.M0 --- 01/09/94 --- CREATION
C
C-- ....................................................................
C
C..INPUT
      CHARACTER STRIN*(*)
C
C..OUTPUT
      CHARACTER STROUT*(*)
C
C..PROGRAM
      INTEGER*4 I , ICODE0 , ICODE1 , ICODE , IOFSET , IHAT
C
C-----------------------------------------------------------------------
C                            INITIALISE
C-----------------------------------------------------------------------
C
C..START OF CODE RANGE
      ICODE0 = ICHAR('a')
C
C..END   OF CODE RANGE
      ICODE1 = ICHAR('z')
C
C..OFF-SET
      IOFSET = ICHAR('A') - ICHAR('a')
C
C-----------------------------------------------------------------------
C                    TEST EACH CHARACTER AND CONVERT
C-----------------------------------------------------------------------
C
      DO 100 I           = 1 , MIN0(LEN(STRIN),LEN(STROUT))
C
C..CODE OF I-TH CHARACTER
             ICODE       = ICHAR(STRIN(I:I))
C
C..CONVERT CODE
             ICODE       = ICODE + IOFSET*IHAT(ICODE,ICODE0,ICODE1)
C
C..COPY CONVERTED CHARACTER TO OUTPUT STRING
             STROUT(I:I) = CHAR(ICODE)
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C                       PAD STROUT WITH BLANKS
C-----------------------------------------------------------------------
C
      DO 200 I           = LEN(STRIN)+1 , LEN(STROUT)
         STROUT(I:I)     = ' '
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE CHRUTL( STRIN , STROUT )
      IMPLICIT NONE
C
C++ ....................................................................
C
C VERSION : V1.R1.M0
C
C ROUTINE : CHARACTER UPPER TO LOWER CONVERSION
C           -- -      -     -- -
C
C PURPOSE : TO CONVERT UPPER CASE CHARACTERS IN A STRING TO LOWER CASE.
C
C INPUT   : (C**) STRIN   = INPUT STRING
C
C OUTPUT  : (C**) STROUT  = OUTPUT STRING
C
C PROGRAM : (I*4) I       = INDEX COUNTER
C                 ICODE0  = BEGINNING OF CODE RANGE
C                 ICODE1  = FINISH OF CODE RANGE
c                 ICODE   = CHARACTER CODE
C                 IOFSET  = CODE OFF-SET
C
C METHOD  : A) EACH CHARACTER IN THE INPUT STRING IS CHECKED TO SEE IF
C              IT LIES IN THE UPPER CASE CODE RANGE
C           B) IS SO, THEN AN OFF-SET IS ADDED ONTO THE CODE OF THE
C              CHARACTER TO BRING IT INTO THE CORRESPONDING LOWER CODE
C              RANGE.
C
C ROUTINE : (I*4) IHAT    = 0 --- OUTSIDE INCLUSIVE RANGE
C                         = 1 --- INSIDE  INCLUSIVE RANGE
C
C AUTHOR  : J.SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C HISTORY : V1.R1.M0 --- 01/09/94 --- CREATION
C
C-- ....................................................................
C
C..INPUT
      CHARACTER STRIN*(*)
C
C..OUTPUT
      CHARACTER STROUT*(*)
C
C..PROGRAM
      INTEGER*4 I , ICODE0 , ICODE1 , ICODE , IOFSET , IHAT
C
C-----------------------------------------------------------------------
C                            INITIALISE
C-----------------------------------------------------------------------
C
C..START OF CODE RANGE
      ICODE0 = ICHAR('A')
C
C..END   OF CODE RANGE
      ICODE1 = ICHAR('Z')
C
C..OFF-SET
      IOFSET = ICHAR('a') - ICHAR('A')
C
C-----------------------------------------------------------------------
C                    TEST EACH CHARACTER AND CONVERT
C-----------------------------------------------------------------------
C
      DO 100 I           = 1 , MIN0(LEN(STRIN),LEN(STROUT))
C
C..CODE OF I-TH CHARACTER
             ICODE       = ICHAR(STRIN(I:I))
C
C..CONVERT CODE
             ICODE       = ICODE + IOFSET*IHAT(ICODE,ICODE0,ICODE1)
C
C..COPY CONVERTED CHARACTER TO OUTPUT STRING
             STROUT(I:I) = CHAR(ICODE)
C
  100 CONTINUE
C
C-----------------------------------------------------------------------
C                       PAD STROUT WITH BLANKS
C-----------------------------------------------------------------------
C
      DO 200 I           = LEN(STRIN)+1 , LEN(STROUT)
         STROUT(I:I)     = ' '
  200 CONTINUE
C
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      FUNCTION IHAT( ITEST , IMIN , IMAX )
      IMPLICIT NONE
      INTEGER*4 IHAT
C
C++ ....................................................................
C
C VERSION : V1.R1.M0
C
C ROUTINE : INTEGER "TOP HAT" FUNCTION
C           -            ---
C
C PURPOSE : TO RETURN 1 OR 0 DEPENDING ON I BEING IN THE RANGE IMIN TO
C           IMAX (INCLUSIVELY) OR OUTSIDE RESPECTIVELY.
C
C INPUT   : (I*4) ITEST   = INTEGER TO TEST
C           (I*4) IMIN    = MINIMUM VALUE OF RANGE
C           (I*4) IMAXT   = MAXIMUM VALUE OF RANGE
C
C OUTPUT  : (I*4) IHAT    = 0 --- IMIN >  ITEST >  IMAX
C                         = 1 --- IMIN <= ITEST <= IMAX
C
C METHOD  : USE ROUTINE 'ISIGN'.
C
C AUTHOR  : J.SPENCE  (K1/0/80)  EXT. 4865
C           JET
C
C HISTORY : V1.R1.M0 --- 01/09/94 --- CREATION
C
C-- ....................................................................
C
C..INPUT
      INTEGER*4 ITEST , IMIN , IMAX
C
C-----------------------------------------------------------------------
C                            CALCULATION
C             (IMAX+1 MAKES THE UPPER RANGE INCLUSIVE)
C-----------------------------------------------------------------------
C
      IHAT  = ( ISIGN( 1 , ITEST - MIN0(IMIN,IMAX)     )
     &        - ISIGN( 1 , ITEST - MAX0(IMIN,IMAX) - 1 ) ) / 2
C
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C
C=======================================================================
      SUBROUTINE FCONV( FILE   , HWNAME , PREFIX , LPREFX
     O                , OFTYPE , NFTYPE , XFILE  , IXJOIN , MESS
     O                , IER )
      IMPLICIT NONE
C
C+ .....................................................................
C
C ROUTINE : FILE CONVERSION
C           -    ----
C VERSION : V2.R1.M0
C
C PURPOSE : TO CONVERT NAMED FILE FROM WORKSTATION TO MAINFRAME OR FROM
C           MAINFRAME TO WORKSTATION FORMAT IF NOT CONSISTANT WITH
C           CURRENT MACHINE.
C
C I/O     : (C60) FILE         = ORIGINAL FILE NAME
C                                (I.E PREFIX + XFILE)
C
C INPUT   : (C**) HWNAME       = HARDWARE (COMPUTER) NAME
C           (C**) PREFIX       = PREFIX ONTO CONVERTED FILE NAME
C           (I*4) LPREFX       = NON-BLANK SIZE OF 'PREFIX'
C
C OUTPUT  : (C**) OFTYPE       = ORIGINAL FORMAT OF FILE NAME
C           (C**) NFTYPE       = NEW      FORMAT OF FILE NAME
C           (C**) XFILE        = STRIPPED (APPENDIX) FILE NAME
C           (I*4) IXJOIN       = LENGTH ALONG XFILE TO LAST SEPARATOR
C           (C**) MESS         = ERROR MESSAGE (IF ANY)
C           (I*4) IER          = 0 --- ROUTINE SUCCESSFUL
C                              = 1 --- FILE NAME IS BLANK
C                              = 2 --- ORIGINAL FILETYPE IS UNKNOWN
C                              = 3 --- MACHINE           IS UNKNOWN
C                              = 4 --- NEW      FILETYPE IS UNKNOWN
C
C PROGRAM : (C*4) FTYPE()      = ALLOWABLE FILE TYPES
C           (C*1) MARK1        = ORIGINAL  FILE NAME SEPARATOR
C           (C*1) MARK2        = CONVERTED FILE NAME SEPARATOR
C           (I*4) NMARK        = SEPARATOR COUNT
C           (I*4) I            = LOOP INTEGER
C           (I*4) ILAST        = POSITION OF LAST SEPARATOR IN FILE NAME
C           (I*4) IPENUL       = POSITION OF PENULTIMATE SEPARATOR
C
C ROUTINE :       CHRUTL       = CONVERT STRING UPPER TO LOWER CASE
C                 CHRLTU       = CONVERT STRING LOWER TO UPPER CASE
C
C NOTE    : CONVESION METHOD - STRIP FILE NAME UNTIL IT BEGINS AT THE
C                              PENULTIMATE SEPARATOR AND THEN PREFIX
C                              IT WITH 'PREFIX'.  THE STRIPPED FILE
C                              IS COPIED TO 'XFILE' WITH LENGTH
C                              TO THE LAST SERARATOR 'IXFILE'.
C
C AUTHOR  : JAMES SPENCE  (K1/0/80)  EXT. 4866
C           JET
C
C HISTORY : V1.R1.M0 --- 01/03/95 --- CREATION
C           V2.R1.M0 --- 08/05/98 --- VARIOUS MACHINES MAY RUN THE
C                                     SAME FILE TYPE
C
C- .....................................................................
C
C..INPUT
      INTEGER*4 LPREFX
      CHARACTER FILE*60    , HWNAME*(*) , PREFIX*(*)
C
C.. OUTPUT
      INTEGER*4 IXJOIN     , IER
      CHARACTER OFTYPE*(*) , NFTYPE*(*) , XFILE*(*)  , MESS*(*)
C
C..PARAMETERS
      INTEGER*4   MFTYPE
      PARAMETER(  MFTYPE = 3 )
C
C..PROGRAM
      INTEGER*4   NMARK      , I          , ILAST      , IPENUL
     &        ,   LEN
      CHARACTER   MARK1      , MARK2
      CHARACTER*4 FTYPE(MFTYPE)
C
C..DATA
      DATA FTYPE/ 'MVS ' , 'UNIX' , '????' /
C
C------------------------------ INITIALISE -----------------------------
C
      IER = 0
C
C------------------------------ CHECK INPUT ----------------------------
C
      IF( FILE.EQ.' ' ) THEN
        MESS = 'FILE NAME IS UNSPECIFIED.'
        IER  = 1
        GOTO 9999
      ENDIF
C
C---------------------- DETERMINE ORIGINAL FILE TYPE -------------------
C
      IF( FILE(2:4).EQ.'JET' ) THEN
          OFTYPE = FTYPE(1)
      ELSE IF( FILE(2:3).EQ.'u/' ) THEN
          OFTYPE = FTYPE(2)
      ELSE
          OFTYPE = FTYPE(MFTYPE)
          MESS   = 'ORIGINAL FILETYPE IS UNKNOWN.'
          IER    = 2
          GOTO 9999
      END IF
C
C------------------------ DETERMINE NEW FILE TYPE ----------------------
C
      IF( HWNAME.EQ.'IBM3090' ) THEN
          NFTYPE = FTYPE(1)
      ELSE IF( HWNAME.EQ.'RS6000' ) THEN
          NFTYPE = FTYPE(2)
      ELSE IF( HWNAME.EQ.'X86/LINUX' ) THEN
          NFTYPE = FTYPE(2)
      ELSE
          NFTYPE = FTYPE(MFTYPE)
          MESS   = 'MACHINE IS UNKNOWN' // HWNAME
          IER    = 3
          GOTO 9999
      END IF
C
C-------------------------- SET CONVERSION MARKING ---------------------
C
      IF( OFTYPE.NE.NFTYPE .AND. FILE(1:LPREFX).NE.PREFIX ) THEN
C..(CONVERSION)
          IF( NFTYPE.EQ.'MVS' ) THEN
              MARK1 = '.'
              MARK2 = '/'
          ELSE IF( NFTYPE.EQ.'UNIX' ) THEN
              MARK1 = '/'
              MARK2 = '.'
          ELSE
              MESS  = 'NEW FILETYPE IS UNKNOWN ' // NFTYPE
              IER   = 4
              GOTO 9999
          END IF
C
      ELSE
C..(NO CONVERSION)
          IF( NFTYPE.EQ.'MVS' ) THEN
              MARK1 = '.'
              MARK2 = '.'
          ELSE IF( NFTYPE.EQ.'UNIX' ) THEN
              MARK1 = '/'
              MARK2 = '/'
          ELSE
              MESS  = 'NEW FILETYPE IS UNKNOWN ' // NFTYPE
              IER   = 4
              GOTO 9999
          END IF
      END IF
C
C----------------------- CONVERSION AND/OR APPENIX ---------------------
C
      NMARK        = 0
C
      DO 100 I     = LEN(FILE) , 1 , -1
C
         IF( FILE(I:I).EQ.MARK1 ) THEN
             NMARK = NMARK+1
             IF( NMARK.EQ.1 ) ILAST = I
             IF( MARK1.NE.MARK2 ) FILE(I:I) = MARK2
         END IF
C
         IPENUL    = I
C
         IF( NMARK.EQ.2 ) GOTO 10
C
  100 CONTINUE
C
   10 XFILE        = FILE(IPENUL+1:LEN(FILE))
C
C--------------------------- CASE CONVERSION ---------------------------
C... MVS  -> UNIX : CONVERT ALL CHARACTERS TO UPPER CASE
C... UNIX -> MVS  : CONVERT ALL CHARACTERS TO LOWER CASE
C
      IF     ( OFTYPE.EQ.'MVS'  .AND. NFTYPE.EQ.'UNIX' ) THEN
          CALL CHRUTL(XFILE,XFILE)
      ELSE IF( OFTYPE.EQ.'UNIX' .AND. NFTYPE.EQ.'MVS'  ) THEN
          CALL CHRLTU(XFILE,XFILE)
      END IF
C
C-------------------------------- APPENDIX -----------------------------
C
      IXJOIN       = ILAST - IPENUL
      IF( MARK1.NE.MARK2 ) FILE = PREFIX//XFILE
C
C-----------------------------------------------------------------------
C
 9999 RETURN
      END
C
C=======================================================================
      SUBROUTINE SETCOM( ICHAN )
      IMPLICIT NONE
C
C-----------------------------------------------------------------------
C
C PURPOSE : TO SET COMMON BLOCKS OUTPUT CHANNELS
C
C INPUT   : (I*4) ICHAN   = OUTPUT CHANNEL
C
C AUTHOR  : JAMES SPENCE (K1/0/80)  EXT. 4866
C           JET
C
C DATE    : 09-SEP-97
C
C-----------------------------------------------------------------------
C
C..INPUT
      INTEGER*4 ICHAN
C
C..COMMONS
      COMMON /EB06BD/LP1,LB,ITS
      INTEGER*4 LP1,LB,ITS
C
      COMMON /EB08BD/LP2,ITSM,LLL,LLU,JH,LFLG
      INTEGER*4 LP2,ITSM,LLL,LLU,JH
      INTEGER LFLG
C
      COMMON /MC15BD/LP3
      INTEGER*4 LP3
C
      COMMON /MC14CD/LP4
      INTEGER*4 LP4
C
C-----------------------------------------------------------------------
C
      LP1 = ICHAN
      LP2 = ICHAN
      LP3 = ICHAN
      LP4 = ICHAN
C
C-----------------------------------------------------------------------
C
      RETURN
      END
