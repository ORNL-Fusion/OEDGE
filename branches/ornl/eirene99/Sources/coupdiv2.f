      SUBROUTINE INDMAP(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     INDEX MAPPING FOR BRAAMS DATA FIELDS. DATA IN DUMMY ZONES
C     (CUTS OR BOUNDARY ZONES) MAY BE NEEDED AND THUS ARE KEPT
C     AND DUBLICATED IN CASE NCUTL GT NCUTB
C
C     NCUTB= NUMBER OF CELLS IN IX DIRECTION PER CUT IN BRAAMS
C     NCUTL= NUMBER OF CELLS IN IX DIRECTION PER CUT IN LINDA (AND
C            THUS ALSO IN EIRENE) GEOMETRY
      DIMENSION NPOINT(2,*)
      DIMENSION FIELD(0:NDX+1,0:NDY+1,NFL)
      DIMENSION DUMMY(0:NDX+1,0:NDY+1)
C
C  LOOP FOR THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=FIELD(IX,IY,IF)
C
C
C      NDX DIRECTION: IX=0: NOT MODIFIED
C                     IX=I(CUT): USE CUT VALUE
C                     IX=I(LAST X ZONE): MOVE TO NDXA+1
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(IX,IY)=FIELD(INB,IY,IF)
213         CONTINUE
            DUMMY(IINID,IY) = FIELD(INB+1,IY,IF)
            IF (IENDD.NE.IINID) DUMMY(IENDD,IY) = FIELD(INB+NCUTB,IY,IF)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN SUBR. INDMAP: THIS SUBR. IS VALID ONLY'
      WRITE (6,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT
991   WRITE (6,*) 'ERROR IN SUBR. INDMAP: INCONSISTENCY IN NUMBER OF '
      WRITE (6,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED.  '
      WRITE (6,*) 'NCUTL = ',NCUTL, ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT
      END
C
C
      SUBROUTINE INDMPI(FIELD,DUMMY,NDX,NDY,NFL,NDXA,NDYA,NFLA,
     .                  NCUTB,NCUTL,NPOINT,NPPLG,NSTR,ISTR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     INDEX MAPPING: INVERS TO SUBR. INDMAP
C
      DIMENSION NPOINT(2,*)
      DIMENSION FIELD(0:NDX+1,0:NDY+1,NFL,NSTR)
      DIMENSION DUMMY(0:NDX+1,0:NDY+1)
C
C  LOOP OVER THE SPECIES
C
      DO 500 IF=1,NFLA
C
C  INITIALIZE DUMMY
C
        DO 10 IY=0,NDY+1
          DO 10 IX=0,NDX+1
10          DUMMY(IX,IY)=0.
C
C
C      NDX DIRECTION
C
C  NPOINT(1,1)=1
C  NPOINT(2,NPPLG)=NDXA+1
C
        IF (NCUTB.LT.0) GOTO 990
        DO 211 IPART = 1,NPPLG
C  "VALID REGION"
          IINIV= NPOINT(1,IPART)
          IENDV= NPOINT(2,IPART)-1
C  "CUT REGION" AND LAST X ZONE IX = NDXA+1
          IF (IPART.LT.NPPLG) THEN
            IINID= NPOINT(2,IPART)
            IENDD= NPOINT(1,IPART+1)-1
            IF (IENDD-IINID+1.NE.NCUTL) GOTO 991
          ELSE
            IINID= NDXA+1
            IENDD= NDXA+1
          ENDIF
          DO 212 IY=0,NDYA+1
            DO 213 IX = IINIV,IENDV
              INB=IX-(IPART-1)*(NCUTL-NCUTB)
              DUMMY(INB,IY)=FIELD(IX,IY,IF,ISTR)
213         CONTINUE
            DUMMY(INB+1,IY)=FIELD(IINID,IY,IF,ISTR)
            IF (IENDD.NE.IINID)
     .          DUMMY(INB+NCUTB,IY)=FIELD(IENDD,IY,IF,ISTR)
212       CONTINUE
211     CONTINUE
        DO 220 IY=0,NDYA+1
          DO 220 IX=0,NDXA+1
            FIELD(IX,IY,IF,ISTR)=DUMMY(IX,IY)
220     CONTINUE
C
500   CONTINUE
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN SUBR. INDMPI: THIS SUBR. IS VALID ONLY'
      WRITE (6,*) 'NCUTB>=0 BUT NCUTB = ',NCUTB
      CALL EXIT
991   WRITE (6,*) 'ERROR IN SUBR. INDMPI: INCONSISTENCY IN NUMBER OF'
      WRITE (6,*) 'ZONES PER CUT FROM LINDA GEOMETRY DETECTED. '
      WRITE (6,*) 'NCUTL = ',NCUTL, ' IENDD-IINID+1 = ',IENDD-IINID+1
      CALL EXIT
      END
C
      SUBROUTINE EIRSRT(LSTOP,LTIME,DELTAT,FLUXES,
     .                  B2BRM,B2RD,B2Q,B2VP)
      USE BRASPOI
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMSOU'
      INCLUDE 'COMUSR'
      INCLUDE 'CLOGAU'
      INCLUDE 'CTRCEI'
      INCLUDE 'CGRID'
      INCLUDE 'CPOLYG'
      INCLUDE 'CGEOM'
      INCLUDE 'CSPEI'
      INCLUDE 'COUTAU'
      INCLUDE 'CSPEZ'
      INCLUDE 'CINIT'
      INCLUDE 'CCONA'
      INCLUDE 'CESTIM'
      INCLUDE 'COMXS'
      INCLUDE 'CSDVI'
      INCLUDE 'CSDVI_BGK'
      INCLUDE 'CSDVI_COP'
      INCLUDE 'CZT1'
      INCLUDE 'CCOUPL'
      INCLUDE 'COMPRT'
      INCLUDE 'COMNNL'
C
      DIMENSION RCOPLE(NCOUPL),ICOPLE(MCOUPL)
      LOGICAL   LCOPLE(LCOUPL)
      EQUIVALENCE (FCTE(1),RCOPLE(1)),
     .            (NDT(1,1),ICOPLE(1)),
     .            (LBALAN,LCOPLE(1))
      PARAMETER (NBRSLO=NRAD*((NPLS+2)*NATM+NPLS+
     P                        (NPLS+3)*NMOL+(NPLS+3)*NION))
      PARAMETER (NBRSCL=2*NBRSLO)
      COMMON /BRASCL/
     R  SPLODA(NRAD,NATM,NPLS),SEIODA(NRAD,NPLS),SEEODA(NRAD,NATM),
     R  SMODA(NRAD,NATM),
     R  SPLODI(NRAD,NION,NPLS),SEIODI(NRAD,NION),SEEODI(NRAD,NION),
     R  SMODI(NRAD,NION),
     R  SPLODM(NRAD,NMOL,NPLS),SEIODM(NRAD,NMOL),SEEODM(NRAD,NMOL),
     R  SMODM(NRAD,NMOL),
C
     R  SPLNWA(NRAD,NATM,NPLS),SEINWA(NRAD,NPLS),SEENWA(NRAD,NATM),
     R  SMNWA(NRAD,NATM),
     R  SPLNWI(NRAD,NION,NPLS),SEINWI(NRAD,NION),SEENWI(NRAD,NION),
     R  SMNWI(NRAD,NION),
     R  SPLNWM(NRAD,NMOL,NPLS),SEINWM(NRAD,NMOL),SEENWM(NRAD,NMOL),
     R  SMNWM(NRAD,NMOL)
C
      TYPE(CELLSIM), POINTER :: CPSIM
      TYPE(CELLMUL), POINTER :: CPMUL
C
C
      DIMENSION XWK(NBRSCL)
      EQUIVALENCE (XWK(1),SPLODA(1,1,1))
C
      DIMENSION RCMDTA(NMDTA),ICMDTA(MMDTA)
      EQUIVALENCE (RCMDTA(1),TABDS1(1,1))
      EQUIVALENCE (ICMDTA(1),MODCOL(1,1,1,0))
C
      DIMENSION ESTIM(NESTIM),OUTAU(NOUTAU),SDVI(NSDVI),
     .          SDVI_BGK(NSBGK),SDVI_COP(NSCOP)
      LOGICAL SPEZ(LSPEZ),LSTOP,LTIME
      DIMENSION FLUXES(NSTRA),FLUXS(NSTRA)
      EQUIVALENCE
     .  (ESTIM(1),PDENA(1,1)),
     .  (OUTAU(1),PDENAI(0,0)),
     .  (SDVI(1),SIGMA(1,1)),
     .  (SDVI_BGK(1),SIGMA_BGK(1,1)),
     .  (SDVI_COP(1),SIGMA_COP(1,1)),
     .  (SPEZ(1),LOGATM(0,0))
C
      SAVE
      DATA IFIRST/0/
C
      IF (LTIME) THEN
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        DUMMY=RESET_SECOND()
        IF(IFIRST.EQ.0) THEN
C
          CALL GRSTRT(35,8)
C
C  READ FORMATTED INPUT FILE IUNIN
C  AND RUN EIRENE FOR ONE TIME-CYCLE: ITIMV=1
C  WITH OR WITHOUT INITIAL DISTRIBUTION ON FILE FT15 (NFILE-J FLAG)
C  AS FINAL STRATUM
C  EXPECT PLASMA DATA ON FORT.31 (NLPLAS=.FALSE.)
C
          CALL EIRENE(DELTAT,.FALSE.)
C
C  EIRENE RUN DONE. CENSUS ARRAY WRITTEN
C  NOW ITIMV=ITIMV+1, NLPLAS=.TRUE.
C
          DO 3 ISTRA=1,NSTRAI
            FLUXS(ISTRA)=FLUX(ISTRA)
3         CONTINUE
          IFIRST=1
        ELSE
C
C  NOW: NLPLAS=.TRUE., I.E., PLASMA DATA EXPECTED ON BRAEIR
C  NOW: ITIMV=ITIMV+1
C  BUT: COMMON BRAEIR REDONE IN EXTERNAL CODE.
C  REACTIVATE INDEX MAPPING, EVEN WITHOUT READING INPUT BLOCK 14 AGAIN
          NCUTB_SAVE=NCUTB
C
          DTIMVO=DTIMV
          DTIMVN=DELTAT
C
C-----------------------------------------------------------------------
C
C  STRATA 1 TO NTARGI ARE SCALED IN PLASMA CODE  (RECYCLING STRATA)
C
C     RETURN TO PLASMA CODE THE PROFILES PER UNIT SOURCE STRENGTH
C     IE. THE PROFILES ARE SCALED BY 1./FLUX(ISTRA) BEFORE RETURN
C
C  STRATA NTARGI+1 TO NSTRAI-1  ARE SCALED BY EIRENE
C
C     (EG. GAS PUFF, VOLUME RECOMBINATION, ETC.)
C     THEY MAY BE RESCALED BY PLASMA CODE FACTORS: FLUXES(ISTRA)
C     RETURN TO PLASMA CODE THE PROFILES SCALED WITH
C     SOURCE STRENGTH: FLUX(ISTRA) (AMP)
C
C  STRATUM NSTRAI IS RESCALED WITH RATIO OF OLD TO NEW TIMESTEP
C
C     RETURN TO PLASMA CODE THE PROFILES WITH FLUX(ISTRA) (AMP)
C
          DO ISTRA=NTARGI+1,NSTRAI-1
            IF (FLUXES(ISTRA).NE.0.) THEN
              FLUX(ISTRA)=FLUXS(ISTRA)*FLUXES(ISTRA)*ELCHA
            ELSE
              FLUX(ISTRA)=FLUXS(ISTRA)
            ENDIF
          ENDDO
C
          IF (DTIMVN.NE.DTIMVO) THEN
            FLUX(NSTRAI)=FLUX(NSTRAI)*DTIMVO/DTIMVN
C
            WRITE (6,*) 'FLUX IS RESCALED BY DTIMV_OLD/DTIMV_NEW '
            CALL MASR1('FLUX    ',FLUX(NSTRAI))
            CALL LEER(1)
          ENDIF
C
C-----------------------------------------------------------------------
C
          DTIMV=DTIMVN
C
C  RUN EIRENE ON TIMESTEP DTIMV
C  THEN CALL INTERFACING ROUTINE AT ENTRY IF3COP (FROM EIRENE MAIN)
C
          CALL EIRENE_COUPLE
          IF (LSTOP) THEN
c...sltmp
            WRITE(0,*) 'CALLING: GREND from coupdiv'
            CALL GREND
          ENDIF
        ENDIF
        CALL LEER(2)
        WRITE(*,*) 'EIRENE USED ',SECOND_OWN(),' CPU SECONDS'
        CALL LEER(2)
C
        RETURN
C
      ELSEIF (.NOT.LTIME) THEN
C
        IF (IFIRST.GE.1) GOTO 10000
C
        NREC10=1500
        OPEN (UNIT=10,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC10)
        NREC11=NOUTAU
        OPEN (UNIT=11,ACCESS='DIRECT',FORM='UNFORMATTED',RECL=8*NREC11)
C
        IRC=3
        READ (11,REC=IRC) RCOPLE
        IRC=3
        DO 2 J=1,MCOUPL,NOUTAU
          IRC=IRC+1
          READ (11,REC=IRC) (ICOPLE(K),K=J,MIN(J+NOUTAU-1,MCOUPL))
2       CONTINUE
        IRC=IRC+1
        READ (11,REC=IRC) LCOPLE
        IF (LTRCFL)
     .    WRITE (6,*) 'READ DATA FOR SHORT CYCLE, SAVED ON  FT11 ',IRC
C
        NLPLG=LNLPLG
        NLDRFT=LNLDRF
        TRCFLE=LTRCFL
        NSTRAI=NSTRI
        DO 1 ISTRA=1,NSTRAI
          NLVOL(ISTRA)=LNLVOL(ISTRA)
1       CONTINUE
        NMODE=NMODEI
        NFILEN=NFILNN
C
C
        INDPRO(1)=6
        INDPRO(2)=6
        INDPRO(3)=6
        INDPRO(4)=6
        INDPRO(5)=6
C
        CALL SETCON
        CALL RGEOM(TRCFLE)
        CALL RPLAM(TRCFLE)
C
        IF (TRCFLE) WRITE (6,*) 'READ DATA FOR EIRENE RECALL OPTION'
        IRC=1
        READ (11,REC=IRC) SPEZ
        IF (TRCFLE)
     .    WRITE (6,*) 'DATA FOR RECALL OPTION READ FROM  FT11, IRC=1 '
        IRC=2
        READ (11,REC=IRC) OUTAU
        IF (TRCFLE)
     .    WRITE (6,*) 'DATA FOR RECALL OPTION READ FROM  FT11, IRC=2 '
C
        CALL INTER0
C
        NDXY=(NDXA-1)*NR1ST+NDYA
C
        DO 5 IBRSCL=1,NBRSLO
          XWK(IBRSCL)=0.
5       CONTINUE
C
C  INITIAL: ATOMS, EI-PROCESSES
C
        DO 21 IATM=1,NATMI
        DO 21 IPLS=1,NPLSI
        DO 21 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 21
          DO 22 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODA(IN,IATM,IPLS)=SPLODA(IN,IATM,IPLS)+
     .                        FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
22        CONTINUE
21      CONTINUE
        DO 23 IPLS=1,NPLSI
          DO 24 IN=1,NDXY
            SEIODA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLS,IN)+EDRIFT(IPLS,IN))
24        CONTINUE
23      CONTINUE
C
        DO 25 IATM=1,NATMI
        DO 25 IAEI=1,NAEII(IATM)
          IRDS=LGAEI(IATM,IAEI)
          DO 25 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODA(IN,IATM)=SEEODA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
25      CONTINUE
C
C  INITIAL: TEST IONS, EI-PROCESSES
C
        DO 26 IION=1,NIONI
        DO 26 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          DO 26 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODI(IN,IION)=SEEODI(IN,IION)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODI(IN,IION)=SEEODI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
26      CONTINUE
C
        DO 27 IION=1,NIONI
        DO 27 IPLS=1,NPLSI
        DO 27 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 27
          DO 28 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODI(IN,IION,IPLS)=SPLODI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ENDIF
28        CONTINUE
27      CONTINUE
C
        DO 29 IION=1,NIONI
        DO 29 IPLS=1,NPLSI
        DO 29 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 30 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODI(IN,IION)=SEIODI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODI(IN,IION)=SEIODI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
30        CONTINUE
29      CONTINUE
C
C
C  INITIAL: MOLECULES, EI-PROCESSES
C
        DO 35 IMOL=1,NMOLI
        DO 35 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 35 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEEODM(IN,IMOL)=SEEODM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            ENDIF
35      CONTINUE
C
        DO 47 IMOL=1,NMOLI
        DO 47 IPLS=1,NPLSI
        DO 47 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 47
          DO 48 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLODM(IN,IMOL,IPLS)=SPLODM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
48        CONTINUE
47      CONTINUE
C
        DO 49 IMOL=1,NMOLI
        DO 49 IPLS=1,NPLSI
        DO 49 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 50 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEIODM(IN,IMOL)=SEIODM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
50        CONTINUE
49      CONTINUE
C
C
C
        DO 60 ISTRA=1,NSTRAI
          IF (ISTRA.EQ.IESTR) THEN
C  NOTHING TO BE DONE
          ELSEIF ((NFILEN.EQ.1.OR.NFILEN.EQ.2).AND.ISTRA.NE.IESTR) THEN
            IESTR=ISTRA
            CALL RSTRT(ISTRA,NSTRAI,NESTIM,NSDVI,ESTIM,SDVI,
     .                 NSBGK,SDVI_BGK,NSCOP,SDVI_COP,TRCFLE)
            IF (NLSYMP(ISTRA).OR.NLSYMT(ISTRA)) THEN
              CALL SYMET(ESTIM,NTALV,NRAD,NR1ST,NP2ND,NT3RD,
     .                   NADDV,NFIRST,NLSYMP(ISTRA),NLSYMT(ISTRA))
            ENDIF
          ELSE
            WRITE (6,*) 'ERROR IN EIRSRT: STRATUM ISTRA= ',ISTRA
            WRITE (6,*) 'IS NOT AVAILABLE. EXIT CALLED'
            CALL EXIT
          ENDIF
C
C  SAVE EIRENE TALLIES, SCALE PER UNIT FLUX (AMP), ON COMMON BRASCL
C  WTOTP IS NEGATIVE IN EIRENE (SINK FOR IONS)
C  ALL STRATA WHICH ARE NOT SPECIFIED BY INPUT BLOCK 14 (FROM
C  PLASMA CODE DATA) ARE NOT RESCALED HERE
C
          IF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).NE.0.) THEN
            FLXI=-1./WTOTP(0,ISTRA)
          ELSEIF (ISTRA.LE.NTARGI.AND.WTOTP(0,ISTRA).EQ.0.) THEN
            GOTO 60
          ELSEIF (ISTRA.GT.NTARGI) THEN
            FLXI=1.
          ENDIF

          NULLIFY(PAPLS(ISTRA)%PMUL)
          NULLIFY(PMPLS(ISTRA)%PMUL)
          NULLIFY(PIPLS(ISTRA)%PMUL)

          NULLIFY(EAELS(ISTRA)%PSIM)
          NULLIFY(EMELS(ISTRA)%PSIM)
          NULLIFY(EIELS(ISTRA)%PSIM)
          NULLIFY(EAPLS(ISTRA)%PSIM)
          NULLIFY(EMPLS(ISTRA)%PSIM)
          NULLIFY(EIPLS(ISTRA)%PSIM)

          NULLIFY(PDENAS(ISTRA)%PMUL)
          NULLIFY(PDENMS(ISTRA)%PMUL)
          NULLIFY(PDENIS(ISTRA)%PMUL)
          NULLIFY(EDENAS(ISTRA)%PMUL)

          NULLIFY(COPVS(ISTRA)%PMUL)

          DO IPLS=1,NPLSI
            DO IN=1,NDXY
              IF (PAPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PAPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PAPLS(ISTRA)%PMUL
                PAPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PMPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PMPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PMPLS(ISTRA)%PMUL
                PMPLS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (PIPL(IPLS,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IPLS
                CPMUL%ICM = IN
                CPMUL%VALUEM = PIPL(IPLS,IN)*FLXI
                CPMUL%NXTMUL => PIPLS(ISTRA)%PMUL
                PIPLS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IN=1,NDXY
            IF (EAEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAEL(IN)*FLXI
              CPSIM%NXTSIM => EAELS(ISTRA)%PSIM
              EAELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMEL(IN)*FLXI
              CPSIM%NXTSIM => EMELS(ISTRA)%PSIM
              EMELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIEL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIEL(IN)*FLXI
              CPSIM%NXTSIM => EIELS(ISTRA)%PSIM
              EIELS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EAPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EAPL(IN)*FLXI
              CPSIM%NXTSIM => EAPLS(ISTRA)%PSIM
              EAPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EMPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EMPL(IN)*FLXI
              CPSIM%NXTSIM => EMPLS(ISTRA)%PSIM
              EMPLS(ISTRA)%PSIM => CPSIM
            ENDIF
            IF (EIPL(IN) .NE. 0.D0) THEN
              ALLOCATE(CPSIM)
              CPSIM%ICS = IN
              CPSIM%VALUES = EIPL(IN)*FLXI
              CPSIM%NXTSIM => EIPLS(ISTRA)%PSIM
              EIPLS(ISTRA)%PSIM => CPSIM
            ENDIF
          ENDDO
          DO IATM=1,NATMI
            DO IN=1,NDXY
              IF (PDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => PDENAS(ISTRA)%PMUL
                PDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
              IF (EDENA(IATM,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IATM
                CPMUL%ICM = IN
                CPMUL%VALUEM = EDENA(IATM,IN)*FLXI
                CPMUL%NXTMUL => EDENAS(ISTRA)%PMUL
                EDENAS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IMOL=1,NMOLI
            DO IN=1,NDXY
              IF (PDENM(IMOL,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IMOL
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENM(IMOL,IN)*FLXI
                CPMUL%NXTMUL => PDENMS(ISTRA)%PMUL
                PDENMS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
          DO IION=1,NIONI
            DO IN=1,NDXY
              IF (PDENI(IION,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = IION
                CPMUL%ICM = IN
                CPMUL%VALUEM = PDENI(IION,IN)*FLXI
                CPMUL%NXTMUL => PDENIS(ISTRA)%PMUL
                PDENIS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
c...sltmp
          STOP 'STOP: REFERENCE TO COPV 01'
          DO ICPV=1,NCPVI
            DO IN=1,NDXY
              IF (COPV(ICPV,IN) .NE. 0.D0) THEN
                ALLOCATE(CPMUL)
                CPMUL%IART = ICPV
                CPMUL%ICM = IN
                CPMUL%VALUEM = COPV(ICPV,IN)*FLXI
                CPMUL%NXTMUL => COPVS(ISTRA)%PMUL
                COPVS(ISTRA)%PMUL => CPMUL
              ENDIF
            ENDDO
          ENDDO
C
C
60      CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI)
C
        IFIRST=IFIRST+1
        RETURN
C
10000   CONTINUE
C
        CALL INTER1
C
        CALL PLASMA
C
        CALL PLASMA_DERIV
C
        CALL SETAMD
C
        DO 95 IBRSCL=NBRSLO+1,NBRSCL
          XWK(IBRSCL)=0.
95      CONTINUE
C
C  NEW: ATOMS, EI PROCESSES
C
        DO 101 IATM=1,NATMI
        DO 101 IPLS=1,NPLSI
          DO 102 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 101
            DO 102 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
              ELSE
                SPLNWA(IN,IATM,IPLS)=SPLNWA(IN,IATM,IPLS)+
     .                          FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
              END IF
102       CONTINUE
101     CONTINUE
C
        DO 103 IPLS=1,NPLSI
          DO 104 IN=1,NDXY
            SEINWA(IN,IPLS)=DIIN(IPLS,IN)*
     .                      (1.5*TIIN(IPLS,IN)+EDRIFT(IPLS,IN))
104       CONTINUE
103     CONTINUE
C
        DO 105 IATM=1,NATMI
          DO 105 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            DO 105 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWA(IN,IATM)=SEENWA(IN,IATM)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
105     CONTINUE
C
C  NEW: TEST IONS, EI PROCESSES
C
        DO 106 IION=1,NIONI
          DO 106 IIDS=1,NIDSI(IION)
            IRDS=LGIEI(IION,IIDS)
            DO 106 IN=1,NDXY
              IF (NSTORDR >= NRAD) THEN
                SEENWI(IN,IION)=SEENWI(IN,IION)+EELDS1(IRDS,IN)*
     .                                          TABDS1(IRDS,IN)
              ELSE
                SEENWI(IN,IION)=SEENWI(IN,IION)+FEELEI1(IRDS,IN)*
     .                                          FTABEI1(IRDS,IN)
              END IF
106     CONTINUE
C
        DO 107 IION=1,NIONI
        DO 107 IPLS=1,NPLSI
        DO 107 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 107
          DO 108 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWI(IN,IION,IPLS)=SPLNWI(IN,IION,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
108       CONTINUE
107     CONTINUE
C
        DO 109 IION=1,NIONI
        DO 109 IPLS=1,NPLSI
        DO 109 IIDS=1,NIDSI(IION)
          IRDS=LGIEI(IION,IIDS)
          ESIG=EPLDS(IRDS,2)
          DO 110 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWI(IN,IION)=SEINWI(IN,IION)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWI(IN,IION)=SEINWI(IN,IION)+FTABEI1(IRDS,IN)*ESIG
            END IF
110       CONTINUE
109     CONTINUE
C
C  NEW: MOLECULES, EI PROCESSES
C
        DO 115 IMOL=1,NMOLI
        DO 115 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          DO 116 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+EELDS1(IRDS,IN)*
     .                                        TABDS1(IRDS,IN)
            ELSE
              SEENWM(IN,IMOL)=SEENWM(IN,IMOL)+FEELEI1(IRDS,IN)*
     .                                        FTABEI1(IRDS,IN)
            END IF
116       CONTINUE
115     CONTINUE
C
        DO 117 IMOL=1,NMOLI
        DO 117 IPLS=1,NPLSI
        DO 117 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          IF (PPLDS(IRDS,IPLS).EQ.0.) GOTO 117
          DO 118 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             TABDS1(IRDS,IN)*PPLDS(IRDS,IPLS)
            ELSE
              SPLNWM(IN,IMOL,IPLS)=SPLNWM(IN,IMOL,IPLS)+
     .                             FTABEI1(IRDS,IN)*PPLDS(IRDS,IPLS)
            END IF
118       CONTINUE
117     CONTINUE
C
        DO 119 IMOL=1,NMOLI
        DO 119 IPLS=1,NPLSI
        DO 119 IMDS=1,NMDSI(IMOL)
          IRDS=LGMEI(IMOL,IMDS)
          ESIG=EPLDS(IRDS,2)
          DO 120 IN=1,NDXY
            IF (NSTORDR >= NRAD) THEN
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+TABDS1(IRDS,IN)*ESIG
            ELSE
              SEINWM(IN,IMOL)=SEINWM(IN,IMOL)+FTABEI1(IRDS,IN)*ESIG
            END IF
120       CONTINUE
119     CONTINUE
C
        B2BREM=B2BRM
        B2RAD=B2RD
        B2QIE=B2Q
        B2VDP=B2VP
        CALL INTER3(LSTOP,IFIRST,1,NSTRAI)
C
        IFIRST=IFIRST+1
        RETURN
C
      ENDIF

      END
C
      SUBROUTINE UPSCOP
      RETURN
      END
C
      SUBROUTINE UPTCOP(XSTOR2,WV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  USER SUPPLIED TRACKLENGTH ESTIMATOR, VOLUME AVERAGED
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'CUPD'
      INCLUDE 'COMXS'
      INCLUDE 'CSPEZ'
      INCLUDE 'COMUSR'
      INCLUDE 'CESTIM'
      INCLUDE 'CGRID'
      INCLUDE 'CLOGAU'
      INCLUDE 'CCONA'
      INCLUDE 'CPOLYG'
      INCLUDE 'CZT1'
      INCLUDE 'CSDVI'
      DIMENSION XSTOR(NSTOR),XSTOR2(NSTOR,N2ND+N3RD)
      EQUIVALENCE (XSTOR(1),SIGVCX(1))
      DIMENSION CNDYNA(NATM),CNDYNM(NMOL),CNDYNI(NION),CNDYNP(NPLS)
CDR
      DIMENSION VPX(NRAD),VPY(NRAD),VRX(NRAD),VRY(NRAD),
     .          VSIG_PARB(NPLS,NRAD)
CDR
      DATA IFIRST/0/
c...  sltmp
c      COMMON /temp1/ copvsave

      SAVE

c...  sltmp
c      IF (copv(3,1).NE.copvsave) THEN
c        WRITE(0,*) 'BUST: NPANU,COPV= ',npanu,copv(3,1)
c      ENDIF
c      copvsave2 = copv(3,1)
c      copvsave3  = copv2(3,1,IN01)
c      copvsave4  = copv2(3,1,IN02)
c      copvsave5  = copv2(3,1,IN03)
c      copvsave6  = copv2(3,1,IN04)
c      copvsave7  = copv2(3,1,IN05)
c      copvsave8  = copv2(3,1,IN06)
c      copvsave9  = copv2(3,1,IN07)
c      copvsave10 = copv2(3,1,IN08)
c      copvsave11 = copv2(3,1,IN09)
c      copvsave12 = copv2(3,1,IN10)
c      copvsave13 = copv2(3,1,IN11)
c      copvsave14 = copv2(3,1,IN12)
c      copvsave15 = copv2(3,1,IN13)
c      copvsave16 = copv2(3,1,IN14)
c      copvsave17 = copv2(3,1,IN15)
c      SUM1 = 0.0
c      DO I1 = 1, NMOMCHA
c        sum1 = sum1 + copv2(3,1,ini1)
c      ENDDO
c      copvsave18 = sum1

      IF (IFIRST.EQ.0) THEN
        IFIRST=1
        DO 11 IAT=1,NATMI
11        CNDYNA(IAT)=AMUA*RMASSA(IAT)
        DO 12 IML=1,NMOLI
12        CNDYNM(IML)=AMUA*RMASSM(IML)
        DO 13 IIO=1,NIONI
13        CNDYNI(IIO)=AMUA*RMASSI(IIO)
        DO 14 IPL=1,NPLSI
14        CNDYNP(IPL)=AMUA*RMASSP(IPL)
C
CDR
CDR  PROVIDE A RADIAL UNIT VECTOR PER CELL
CDR  VPX,VPY,  NEEDED FOR PROJECTING PARTICLE VELOCITIES
C
CDR  SAME FOR POLOIDAL UNIT VECTOR VRX,VRY
C
        DO 1 I=1,NRAD
          VPX(I)=0.
          VPY(I)=0.
          VRX(I)=0.
          VRY(I)=0.
1       CONTINUE
        DO 2 IR=1,NR1STM
          DO 2 IP=1,NP2NDM
            IRD=IR+(IP-1)*NR1P2
            VPX(IRD)=PLNX(IR,IP)
            VPY(IRD)=PLNY(IR,IP)
            VRX(IRD)=PPLNX(IR,IP)
            VRY(IRD)=PPLNY(IR,IP)
            DO 3 IPL=1,NPLSI
              VSIG_PARB(IPL,IRD)=CNDYNP(IPL)*
     .                           (VXIN(IPL,IRD)*BXIN(IRD)+
     .                            VYIN(IPL,IRD)*BYIN(IRD)+
     .                            VZIN(IPL,IRD)*BZIN(IRD))
3           CONTINUE
2       CONTINUE
C
      ENDIF

      NMTSP=NATMI+NMOLI+NIONI+NPLSI+NADVI+NALVI
C
C  WV=WEIGHT/VEL
C
C  ATOMS
      IF (ITYP.EQ.1) THEN
        DO 20 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
C
          IF (LGVAC(IRD,0)) GOTO 20
C
          DO 25 K=1,NSTOR
            XSTOR(K)=XSTOR2(K,ICOU)
25        CONTINUE
C
C  1,NPLSI:
C              PARTICLE CHARGE EXCHANGE RATE DUE TO IPLS: #/S
C              WITH ATOM SPECIES IATM=1,NATMI, PER ION
C  EACH RATE IS WEIGHTED WITH THE FACTOR (E0/EI-1), E0 BEING
C  THE NEUTRAL PARTCILE ENERGY, EI THE MEAN PLASMA ION ENERGY
C  THESE RATES ARE SCALED IN THE SHORT CYCLE WITH EI*NI
C
C
          IF (NCPVI.LT.NPLSI) GOTO 20
C
          IF (LGACX(IATM,0,0).EQ.0) GOTO 51
          DO 52 IACX=1,NACXI(IATM)
            IRCX=LGACX(IATM,IACX,0)
            IPLS=LGACX(IATM,IACX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 52
            EION=1.5*TIIN(IPLS,IRD)+EDRIFT(IPLS,IRD)
            WTRSIG=WTR*SIGVCX(IRCX)/DIIN(IPLS,IRD)
c slmod begin - tr
           COPV (IPLS,IRD     )=COPV (IPLS,IRD     )+WTRSIG*(E0/EION-1.)
           COPV2(IPLS,IRD,IN01)=COPV2(IPLS,IRD,IN01)+WTRSIG*(E0/EION-1.)
c
c            COPV(IPLS,IRD)=COPV(IPLS,IRD)+WTRSIG*(E0/EION-1.)
c slmod end
            LMETSP(NMTSP+IPLS)=.TRUE.
52        CONTINUE
51        CONTINUE
C
C.........................................
C
C   MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C.........................................
C
C
C  CONTRIBUTIONS FROM ATOMS
C  NPLSI+1, 2*NPLSI:
C
          IF (NCPVI.LT.2*NPLSI) GOTO 20
C
          IADD=NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNA(IATM)
C
          IF (LGACX(IATM,0,0).EQ.0) GOTO 59
          DO 56 IACX=1,NACXI(IATM)
            IRCX=LGACX(IATM,IACX,0)
            IPLS=LGACX(IATM,IACX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 56
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 56
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHA
C
            VSIGCX_PARB=VSIG_PARB(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGCX_PARB)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
c slmod begin - not tr (modifications required)
            COPV (IPL1,IRD     )=COPV (IPL1,IRD     )-WTRSIG*VSIGCX_PARB
            COPV2(IPL1,IRD,IN02)=COPV2(IPL1,IRD,IN02)-WTRSIG*VSIGCX_PARB
            LMETSP(NMTSP+IPL1)=.TRUE.
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
            COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*VSIGCX_PARB
            COPV2(IPL2,IRD,IN03)=COPV2(IPL2,IRD,IN03)+WTRSIG*VSIGCX_PARB
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
              COPV2(IPL2,IRD,IN04)=COPV2(IPL2,IRD,IN04)+WTRSIG*V0_PARB
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
c
c            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGCX_PARB
c            LMETSP(NMTSP+IPL1)=.TRUE.
cC  NEW BULK ION IPL
c            IF (N1STX(IRCX,1).EQ.4) THEN
c              IPL2=IADD+N1STX(IRCX,2)
c              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*VSIGCX_PARB
c              LMETSP(NMTSP+IPL2)=.TRUE.
c            ENDIF
c            IF (N2NDX(IRCX,1).EQ.4) THEN
c              IPL2=IADD+N2NDX(IRCX,2)
c              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c              LMETSP(NMTSP+IPL2)=.TRUE.
c            ENDIF
c slmod end
56        CONTINUE
59        CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 61 IAEI=1,NAEII(IATM)
            IRDS=LGAEI(IATM,IAEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 62 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  VSIGEI_PARB=VSIG_PARB(IPL,IRD)
                  WTRSIG=WTR*SIGVEI(IRDS)*P
                  WTRSIG=WTRSIG*SIGN(1.D0,VSIGEI_PARB)
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
c slmod begin - not tr
                COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
                COPV2(IPL2,IRD,IN05)=COPV2(IPL2,IRD,IN05)+WTRSIG*V0_PARB
c
c                  COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c slmod end
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
62            CONTINUE
            ENDIF
61        CONTINUE
C
C  ION IMPACT IONIZATION CONTRIBUTION: NOT INCLUDED
C
C
C  ELASTIC CONTRIBUTION FROM ATOMS
C
C
          IF (LGAEL(IATM,0,0).EQ.0) GOTO 80
C  DEFAULT TRACKLENGTH ESTIMATOR (BGK APPROXIMATION)
          DO 81  IAEL=1,NAELI(IATM)
            IREL=LGAEL(IATM,IAEL,0)
            IPLS=LGAEL(IATM,IAEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 81
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 81
C
            VSIGEL_PARB=VSIG_PARB(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGEL_PARB)
C
            IPL1=IADD+IPLS
            IPL2=IPL1
c slmod begin - not tr
            COPV (IPL1,IRD  )=COPV (IPL1,IRD  )-WTRSIG*VSIGEL_PARB
            STOP 'MARK: UNKNOWN COPV D'
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
            COPV2(IPL2,IRD,IN07)=COPV2(IPL2,IRD,IN07)+WTRSIG*V0_PARB
c
c            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGEL_PARB
c            LMETSP(NMTSP+IPL1)=.TRUE.
c            IPL2=IPL1
c            COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c slmod end
            LMETSP(NMTSP+IPL2)=.TRUE.
81        CONTINUE
80      CONTINUE
C
20      CONTINUE
C
C  MOLECULES
      ELSEIF (ITYP.EQ.2) THEN
C
        DO 200 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
C
          IF (LGVAC(IRD,0)) GOTO 200
C
          DO 250 K=1,NSTOR
            XSTOR(K)=XSTOR2(K,ICOU)
250       CONTINUE
C
C             MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C
C
C
C  CONTRIBUTIONS FROM MOLECULES
C  2*NPLSI+1, 3*NPLSI:
C
          IF (NCPVI.LT.3*NPLSI) GOTO 200
C
          IADD=2*NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNM(IMOL)
C
          IF (LGMCX(IMOL,0,0).EQ.0) GOTO 590
          DO 560 IMCX=1,NMCXI(IMOL)
            IRCX=LGMCX(IMOL,IMCX,0)
            IPLS=LGMCX(IMOL,IMCX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 560
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 560
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHM
C
            VSIGCX_PARB=VSIG_PARB(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGCX_PARB)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
c slmod begin - not tr
            COPV (IPL1,IRD     )=COPV (IPL1,IRD     )-WTRSIG*VSIGCX_PARB
            COPV2(IPL1,IRD,IN08)=COPV2(IPL1,IRD,IN08)-WTRSIG*VSIGCX_PARB
            LMETSP(NMTSP+IPL1)=.TRUE.
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
            COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*VSIGCX_PARB
            COPV2(IPL2,IRD,IN09)=COPV2(IPL2,IRD,IN09)+WTRSIG*VSIGCX_PARB
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
              COPV2(IPL2,IRD,IN10)=COPV2(IPL2,IRD,IN10)+WTRSIG*V0_PARB
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
c
c            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGCX_PARB
c            LMETSP(NMTSP+IPL1)=.TRUE.
cC  NEW BULK ION IPL
c            IF (N1STX(IRCX,1).EQ.4) THEN
c              IPL2=IADD+N1STX(IRCX,2)
c              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*VSIGCX_PARB
c              LMETSP(NMTSP+IPL2)=.TRUE.
c            ENDIF
c            IF (N2NDX(IRCX,1).EQ.4) THEN
c              IPL2=IADD+N2NDX(IRCX,2)
c              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c              LMETSP(NMTSP+IPL2)=.TRUE.
c            ENDIF
c slmod end
560       CONTINUE
590       CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 610 IMEI=1,NMDSI(IMOL)
            IRDS=LGMEI(IMOL,IMEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 620 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  VSIGEI_PARB=VSIG_PARB(IPL,IRD)
                  WTRSIG=WTR*SIGVEI(IRDS)*P
                  WTRSIG=WTRSIG*SIGN(1.D0,VSIGEI_PARB)
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
c slmod begin - not tr
                COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
                COPV2(IPL2,IRD,IN15)=COPV2(IPL2,IRD,IN15)+WTRSIG*V0_PARB
c
c                  COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c slmod end
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
620           CONTINUE
            ENDIF
610       CONTINUE
C
C
C  ELASTIC CONTRIBUTION FROM MOLECULES
C
C
          IF (LGMEL(IMOL,0,0).EQ.0) GOTO 800
C  DEFAULT TRACKLENGTH ESTIMATOR
          DO 810 IMEL=1,NMELI(IMOL)
            IREL=LGMEL(IMOL,IMEL,0)
            IPLS=LGMEL(IMOL,IMEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 810
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 810
C
            VSIGEL_PARB=VSIG_PARB(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGEL_PARB)
C
            IPL1=IADD+IPLS
            IPL2=IPL1
c slmod begin - not tr
            COPV (IPL1,IRD     )=COPV (IPL1,IRD     )-WTRSIG*VSIGEL_PARB
            COPV2(IPL1,IRD,IN12)=COPV2(IPL1,IRD,IN12)-WTRSIG*VSIGEL_PARB
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
            COPV2(IPL2,IRD,IN13)=COPV2(IPL2,IRD,IN13)+WTRSIG*V0_PARB
c
c            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGEL_PARB
c            LMETSP(NMTSP+IPL1)=.TRUE.
c            IPL2=IPL1
c            COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c slmod end
            LMETSP(NMTSP+IPL2)=.TRUE.
810       CONTINUE
800     CONTINUE
C
C
200     CONTINUE
C
C  TEST IONS
C
      ELSEIF (ITYP.EQ.3) THEN
C
        DO 2000 ICOU=1,NCOU
          DIST=CLPD(ICOU)
          WTR=WV*DIST
          IRD=NRCELL+NUPC(ICOU)*NR1P2+NBLCKA
C
          IF (LGVAC(IRD,0)) GOTO 2000
C
          DO 2500 K=1,NSTOR
            XSTOR(K)=XSTOR2(K,ICOU)
2500      CONTINUE
C
C             MOMENTUM EXCHANGE RATE: DYN/CM**3
C
C
C
C
C  CONTRIBUTIONS FROM TEST IONS
C  3*NPLSI+1, 4*NPLSI:
C
          IF (NCPVI.LT.4*NPLSI) GOTO 2000
C
          IADD=3*NPLSI
          V0_PARB=VEL*(VELX*BXIN(IRD)+VELY*BYIN(IRD)+VELZ*BZIN(IRD))
          V0_PARB=V0_PARB*CNDYNI(IION)
C
          IF (LGICX(IION,0,0).EQ.0) GOTO 5900
          DO 5600 IICX=1,NICXI(IION)
            IRCX=LGICX(IION,IICX,0)
            IPLS=LGICX(IION,IICX,1)
            IF (LGVAC(IRD,IPLS)) GOTO 5600
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTCX(IRCX,2).NE.0) GOTO 5600
C
C  PRESENTLY: PARALLEL COMPONENT OF VSIGCX(IRCX) NOT AVAILABLE
C             FROM FUNCTION FPATHI
C
            VSIGCX_PARB=VSIG_PARB(IPLS,IRD)
C
            WTRSIG=WTR*SIGVCX(IRCX)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGCX_PARB)
C  PREVIOUS BULK ION IPLS, NOW LOST
            IPL1=IADD+IPLS
            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGCX_PARB
            STOP 'MARK: UNKNOWN COPV A'
            LMETSP(NMTSP+IPL1)=.TRUE.
C  NEW BULK ION IPL
            IF (N1STX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N1STX(IRCX,2)
              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*VSIGCX_PARB
              STOP 'MARK: UNKNOWN COPV B'
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
            IF (N2NDX(IRCX,1).EQ.4) THEN
              IPL2=IADD+N2NDX(IRCX,2)
              COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
              STOP 'MARK: UNKNOWN COPV C'
              LMETSP(NMTSP+IPL2)=.TRUE.
            ENDIF
5600      CONTINUE
5900      CONTINUE
C
C  ELECTRON IMPACT CONTRIBUTION
C
          DO 6100 IIEI=1,NIDSI(IION)
            IRDS=LGIEI(IION,IIEI)
            IF (PPLDS(IRDS,0).GT.0) THEN
              DO 6200 IPL=1,NPLSI
                P=PPLDS(IRDS,IPL)
                IF (P.GT.0) THEN
                  VSIGEI_PARB=VSIG_PARB(IPL,IRD)
                  WTRSIG=WTR*SIGVEI(IRDS)*P
                  WTRSIG=WTRSIG*SIGN(1.D0,VSIGEI_PARB)
C  NEW BULK ION IPL
                  IPL2=IADD+IPL
c slmod begin - not tr
                COPV (IPL2,IRD     )=COPV (IPL2,IRD     )+WTRSIG*V0_PARB
                COPV2(IPL2,IRD,IN06)=COPV2(IPL2,IRD,IN06)+WTRSIG*V0_PARB
c
c                  COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
c slmod end
                  LMETSP(NMTSP+IPL2)=.TRUE.
                ENDIF
6200          CONTINUE
            ENDIF
6100      CONTINUE
C
C
C  ELASTIC CONTRIBUTION FROM TEST IONS
C
          IF (LGIEL(IION,0,0).EQ.0) GOTO 8000
C  DEFAULT TRACKLENGTH ESTIMATOR
          DO 8100 IIEL=1,NIELI(IION)
            IREL=LGIEL(IION,IIEL,0)
            IPLS=LGIEL(IION,IIEL,1)
            IBGK=NPBGKP(IPLS,1)
C
            IF (IBGK.NE.0) GOTO 8100
C  THIS TALLY IS A BGK TALLY. IT SHOULD NOT BE UPDATED HERE.
C
C  COLLISION ESTIMATOR IN SUBR. COLLIDE ?
            IF (IESTEL(IREL,2).NE.0) GOTO 8100
C
            VSIGEL_PARB=VSIG_PARB(IPLS,IRD)
            WTRSIG=WTR*SIGVEL(IREL)
            WTRSIG=WTRSIG*SIGN(1.D0,VSIGEL_PARB)
C
            IPL1=IADD+IPLS
            IPL2=IPL1
            COPV(IPL1,IRD)=COPV(IPL1,IRD)-WTRSIG*VSIGEL_PARB
            STOP 'MARK: UNKNOWN COPV E'
            LMETSP(NMTSP+IPL1)=.TRUE.
            IPL2=IPL1
            COPV(IPL2,IRD)=COPV(IPL2,IRD)+WTRSIG*V0_PARB
            STOP 'MARK: UNKNOWN COPV F'
            LMETSP(NMTSP+IPL2)=.TRUE.
8100      CONTINUE
8000    CONTINUE
C
C
2000    CONTINUE
C
C
      ENDIF
C
c...  sltmp
c      copvsave = copv(3,1)      
c      IF (copvsave2.NE.copv(3,1).AND..FALSE.) THEN
c        WRITE(0,*) copvsave2,copv(3,1)
c        WRITE(0,*)
c        WRITE(0,*) copvsave3 ,copv2(3,1,IN01)
c        WRITE(0,*) copvsave4 ,copv2(3,1,IN02)
c        WRITE(0,*) copvsave5 ,copv2(3,1,IN03)
c        WRITE(0,*) copvsave6 ,copv2(3,1,IN04)
c        WRITE(0,*) copvsave7 ,copv2(3,1,IN05)
c        WRITE(0,*) copvsave8 ,copv2(3,1,IN06)
c        WRITE(0,*) copvsave9 ,copv2(3,1,IN07)
c        WRITE(0,*) copvsave10,copv2(3,1,IN08)
c        WRITE(0,*) copvsave11,copv2(3,1,IN09)
c        WRITE(0,*) copvsave12,copv2(3,1,IN10)
c        WRITE(0,*) copvsave13,copv2(3,1,IN11)
c        WRITE(0,*) copvsave14,copv2(3,1,IN12)
c        WRITE(0,*) copvsave15,copv2(3,1,IN13)
c        WRITE(0,*) copvsave16,copv2(3,1,IN14)
c        WRITE(0,*) copvsave17,copv2(3,1,IN15)
c        SUM1 = 0.0
c        DO I1 = 1, NMOMCHA
c          sum1 = sum1 + copv2(3,1,i1)
c        ENDDO
c        IF ((DABS(copv(3,1)-copvsave)-DABS(sum1-copvsave18))
c     .      .GT.EPS30) THEN 
c          STOP 'STOP: TEST FAILURE'
c        ELSE
c          WRITE(0,*) 'MARK: CHECK'
c         WRITE(0,*)
c        END IF
c       STOP 'STOP: SEARCHING FOR CONTRIBUTION'
c      ENDIF
      RETURN
      END
C
C
      SUBROUTINE STATIS_COP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CCONA'
      INCLUDE 'COMUSR'
      INCLUDE 'COUTAU'
      INCLUDE 'CGRID'
      INCLUDE 'CESTIM'
      INCLUDE 'CSDVI'
      INCLUDE 'CSDVI_COP'
      LOGICAL LP,LT
C
      SAVE
C
      ENTRY STATS0_COP
C
      RETURN

C
      ENTRY STATS1_COP(NBIN,NRIN,NPIN,NTIN,NSIN,LP,LT)
      NSB=NBIN
      NR1=NRIN
      NP2=NPIN
      NT3=NTIN
C
C
      IF (NCPVI.EQ.0) RETURN
C
C
C
      DO 1012 ICPV=1,NCPVI
C
        IF (LMETSP(NSPAN(NTALM)+ICPV-1)) THEN
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SD1=COPV(ICPV,IR)-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR) = COPV(ICPV,IR)
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
1012  CONTINUE

C  STATISTICS FOR PARTICLE SOURCES
      ICPV=NCPVI
      DO IPL = 1,NPLSI
        IF (LMETSP(NSPAN(11)+IPL-1) .OR.
     .      LMETSP(NSPAN(16)+IPL-1) .OR.
     .      LMETSP(NSPAN(21)+IPL-1) ) THEN
          ICPV = NCPVI + IPL
          SD1S=0.
          DO ICO = 1,NCLMT
            IR = ICLMT(ICO)
            SDS=PAPL(IPL,IR)+PIPL(IPL,IR)+PMPL(IPL,IR)
            SD1=SDS-SDVIA_COP(ICPV,IR)
            SD1S=SD1S+SD1
            SDVIA_COP(ICPV,IR) = SDS
            SIGMA_COP(ICPV,IR)=SIGMA_COP(ICPV,IR)+SD1*SD1
          END DO
          SGMS_COP(ICPV)=SGMS_COP(ICPV)+SD1S*SD1S
        END IF
      END DO

C  STATISTICS FOR ELECTRON AND ION ENERGY SOURCES
      ICPV=NCPVI+NPLSI
      SD1S=0.
      SD2S=0.
      DO ICO = 1,NCLMT
        IR = ICLMT(ICO)
        SDE=EAEL(IR)+EIEL(IR)+EMEL(IR)
        SDI=EAPL(IR)+EIPL(IR)+EMPL(IR)
        SD1=SDE-SDVIA_COP(ICPV+1,IR)
        SD2=SDI-SDVIA_COP(ICPV+2,IR)
        SD1S=SD1S+SD1
        SD2S=SD2S+SD2
        SDVIA_COP(ICPV+1,IR) = SDE
        SDVIA_COP(ICPV+2,IR) = SDI
        SIGMA_COP(ICPV+1,IR)=SIGMA_COP(ICPV+1,IR)+SD1*SD1
        SIGMA_COP(ICPV+2,IR)=SIGMA_COP(ICPV+2,IR)+SD2*SD2
      END DO
      SGMS_COP(ICPV+1)=SGMS_COP(ICPV+1)+SD1S*SD1S

C
C
1020  CONTINUE
      RETURN
C
      ENTRY STATS2_COP(XN,FSIG,ZFLUX)
C
C  1. FALL  ALLE BEITRAEGE GLEICHES VORZEICHEN: SIG ZWISCHEN 0 UND 1
C           (=1, FALLS NUR EIN BEITRAG UNGLEICH 0, ODER (KUENSTLICH
C            ERZWUNGEN) FALLS GAR KEIN BEITRAG UNGLEICH NULL)
C  2. FALL  NEGATIVE UND POSITIVE BEITRAGE KOMMEN VOR:
C           LT. FORMEL SIND AUCH WERTE GROESSER 1  MOEGLICH.
C
      XNM=XN-1.
      IF (XNM.LE.0.) RETURN
      ZFLUXQ=ZFLUX*ZFLUX
C
      IF (NCPVI.EQ.0) GOTO 2200
C
      DO 2112 ICPV=1,NCPVI
C
        DS=SUM(COPV(ICPV,1:NSB))
        DO 2111 IR=1,NSB
          D=COPV(ICPV,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
2111    CONTINUE
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
2112  CONTINUE
C
C  STATISTICS FOR PARTICLE SOURCES
      ICPV = NCPVI
      DO IPLS=1,NPLSI
C
        ICPV = ICPV + 1
        DS=SUM(PAPL(IPLS,1:NSB))+SUM(PIPL(IPLS,1:NSB))+
     .     SUM(PMPL(IPLS,1:NSB))
        DO IR=1,NSB
          D=PAPL(IPLS,IR)+PMPL(IPLS,IR)+PIPL(IPLS,IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMA_COP(ICPV,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV,IR)=STV_COP(ICPV,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV,IR)=EE_COP(ICPV,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMS_COP(ICPV)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV)=SG*FSIG
C
        STVS_COP(ICPV)=STVS_COP(ICPV)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV)=EES_COP(ICPV)+DS*ZFLUX/XN
      END DO
C
C  STATISTICS FOR ELECTRON ENERGY SOURCES
        DS=SUM(EAEL(1:NSB))+SUM(EIEL(1:NSB))+SUM(EMEL(1:NSB))
        DO IR=1,NSB
          D=EAEL(IR)+EMEL(IR)+EIEL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMA_COP(ICPV+1,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+1,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+1,IR)=STV_COP(ICPV+1,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+1,IR)=EE_COP(ICPV+1,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMS_COP(ICPV+1)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+1)=SG*FSIG
C
        STVS_COP(ICPV+1)=STVS_COP(ICPV+1)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+1)=EES_COP(ICPV+1)+DS*ZFLUX/XN
C
C  STATISTICS FOR ION ENERGY SOURCES
        DS=SUM(EAPL(1:NSB))+SUM(EIPL(1:NSB))+SUM(EMPL(1:NSB))
        DO IR=1,NSB
          D=EAPL(IR)+EMPL(IR)+EIPL(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMA_COP(ICPV+2,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA_COP(ICPV+2,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV_COP(ICPV+2,IR)=STV_COP(ICPV+2,IR)+SG2*ZFLUXQ/XNM/XN
          EE_COP(ICPV+2,IR)=EE_COP(ICPV+2,IR)+D*ZFLUX/XN
        END DO
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMS_COP(ICPV+2)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS_COP(ICPV+2)=SG*FSIG
C
        STVS_COP(ICPV+2)=STVS_COP(ICPV+2)+SG2*ZFLUXQ/XNM/XN
        EES_COP(ICPV+2)=EES_COP(ICPV+2)+DS*ZFLUX/XN
C
2200  CONTINUE
      RETURN
      END
