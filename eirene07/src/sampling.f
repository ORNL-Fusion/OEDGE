C EIRENE07 COMPILATION
C ===== SOURCE: fcosin.f
C
C
      SUBROUTINE FCOSIN
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A COSINE POLAR AND
C  AN EQUI AZIMUTAL DISTRIBUTION
C  AND RETURN THEM IN THE ARRAYS FC1,FC2,FC3
C  THIS ROUTINE IS CALLED, IF INIV4=0, AND IT RETURNS INIV4=IRNDVC
C
      USE CRAND

      IMPLICIT NONE

      REAL(DP) :: A, ZCTHET, ZSTHET, ZCPHI, ZSPHI, PI2, ZTHET
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: J

      DATA PI2/6.283185/
C
      DO 100 J=1,IRNDVC
        ZTHET=PI2*RANF_EIRENE( )
        ZSTHET=SIN(ZTHET)
        ZCTHET=COS(ZTHET)
        A=RANF_EIRENE( )
        ZCPHI=SQRT(A)
        ZSPHI=SQRT(1.-A)
        FC1(J)=-ZCPHI
        FC2(J)=ZSPHI*ZCTHET
        FC3(J)=ZSPHI*ZSTHET
100   CONTINUE
      INIV4=IRNDVC
      RETURN
      END
C ===== SOURCE: fgauss.f
C
C
      SUBROUTINE FGAUSS
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A GAUSSIAN
C  AND RETURN THEM IN THE ARRAYS FG1,FG2,FG3
C  IT FIRST GENERATES IRNDVC PAIRS, AND THEN IRNDVC/2 PAIRS
C  THIS ROUTINE IS CALLED IF INIV2=0. IT RETURNS INIV2=IRNDVC
C
      USE CRAND

      IMPLICIT NONE

      REAL(DP) :: PI2, ZCOS, ZSIN, ZT, AR, ZZ
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: JJ

      DATA PI2/6.283185/
C
C    THIS FUNCTION SAMPLES FROM A GAUSSIAN OF THE
C    FORM EXP(-(X-ZA)**2/(2.*ZS**2))/(ZS*SQRT(2*PI))
C    ZA=0.
C    ZS=1.
C
C  IT IS THE BOX-MUELLER METHOD
C
C
      DO 1 JJ=1,IRNDVC
C   1. COMPUTE THE SINE AND COSINE OF 2*PI*RAN(1)
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FG1(JJ)=ZT*ZSIN
        FG2(JJ)=ZT*ZCOS
1     CONTINUE
C
      DO 2 JJ=1,IRNDVH
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FG3(JJ)=ZT*ZSIN
        FG3(JJ+IRNDVH)=ZT*ZCOS
2     CONTINUE
C
      INIV2=IRNDVC
      RETURN
      END
C ===== SOURCE: fisotr.f
C
C
      SUBROUTINE FISOTR
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A 3D ISOTROPIC
C  DISTRIBUTION
C  AND RETURN THEM IN THE ARRAYS FI1,FI2,FI3
C  THIS ROUTINE IS CALLED, IF INIV3=0, AND IT RETURNS INIV3=IRNDVC
C
      USE CRAND

      IMPLICIT NONE

      REAL(DP) :: ZCTHET, ZTHETA, ZSTHET, ZSPHI, ZCPHI, PI2, ZEP1, ZEP2
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: J

      DATA PI2/6.283185/
C
      DO 100 J=1,IRNDVC
        ZEP1=RANF_EIRENE( )
        ZEP2=RANF_EIRENE( )
C  THETA
        ZTHETA=PI2*ZEP2
        ZCTHET=COS(ZTHETA)
        ZSTHET=SIN(ZTHETA)
C  PHI
        ZCPHI=ZEP1+ZEP1-1.
        ZSPHI=SQRT(1.-ZCPHI*ZCPHI)
C
        FI1(J)=ZCPHI
        FI2(J)=ZSPHI*ZSTHET
        FI3(J)=ZSPHI*ZCTHET
100   CONTINUE
      INIV3=IRNDVC
      RETURN
      END
C ===== SOURCE: fmaxwl.f
C
C
      SUBROUTINE FMAXWL
C
C  SAMPLE IRNDVC RANDOM NUMBERS FROM A GAUSSIAN FLUX V*FMAX(V)
C  AND RETURN THEM THE ARRAY FM1
C  SAMPLE IRNDVC PAIRS OF RANDOM NUMBER FROM A GAUSSIAN
C  AND RETURN THEM IN THE ARRAYS FM2 AND FM3
C  THIS ROUTINE IS CALLED WHEN INIV1.EQ.0. IT RESETS INIV1=IRNDVC
C
      USE CRAND

      IMPLICIT NONE

      REAL(DP) :: PI2, ZCOS, ZSIN, ZT, AR, ZZ
      REAL(DP), EXTERNAL :: RANF_EIRENE
      INTEGER :: JJ

      DATA PI2/6.283185/
C
C  THIS FUNCTION SAMPLES FROM A GAUSSIAN OF THE
C  FORM EXP(-(X-ZA)**2/(2.*ZS**2))/(ZS*SQRT(2*PI))
C  ZA=0.
C  ZS=1.
C
C  IT IS THE BOX-MUELLER METHOD
C
C
      DO 1 JJ=1,IRNDVC
C   1. COMPUTE THE SINE AND COSINE OF 2*PI*RAN(1)
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FM2(JJ)=ZT*ZSIN
        FM3(JJ)=ZT*ZCOS
1     CONTINUE
C
C  SAMPLE FROM MAXWELLIAN FLUX BY INVERSION RULE
C
      DO 2 JJ=1,IRNDVC
        AR=LOG(RANF_EIRENE( ))
        FM1(JJ)=SQRT(-(AR+AR))
2     CONTINUE
      INIV1=IRNDVC
      RETURN
      END
C ===== SOURCE: fpolyt.f
C
C
      SUBROUTINE FPOLYT
C
C   CONVEX POLYTOP SAMPLING
C   L.DEVROYE, "NON UNIFORM RANDOM VARIATE GENERATION", SPRINGER
C   1986, P 568
C
      USE PRECISION

      IMPLICIT NONE

      REAL(DP) :: D(4)
      REAL(DP), INTENT(IN) :: X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3,
     .                        X4, Y4, Z4
      REAL(DP), INTENT(OUT) :: X, Y, Z
      REAL(DP) :: R1, R2, R3, RMI, RMA, RCT
      REAL(DP), EXTERNAL :: RANF_EIRENE
C
      ENTRY FPOLYT_3(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X,Y,Z)
C
C  SAMPLE UNIFORMLY ON TRIANGLE P1,P2,P3. (POLYTOP IN R3, 3 VERTICES). RETURN P
C
      R1=RANF_EIRENE()
      R2=RANF_EIRENE()
      RMA=MAX(R1,R2)
      RMI=MIN(R1,R2)
      D(1)=RMI-0.
      D(2)=RMA-RMI
      D(3)=1.-RMA
      X=D(1)*X1+D(2)*X2+D(3)*X3
      Y=D(1)*Y1+D(2)*Y2+D(3)*Y3
      Z=D(1)*Z1+D(2)*Z2+D(3)*Z3
      RETURN
C
      ENTRY FPOLYT_4(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X4,Y4,Z4,X,Y,Z)
C
C  SAMPLE UNIFORMLY ON TETRAHEDRON P1,P2,P3,P4 (POLYTOP IN R3, 4 VERTICES).
C  RETURN P
      R1=RANF_EIRENE()
      R2=RANF_EIRENE()
      R3=RANF_EIRENE()
      RMA=MAX(R1,R2,R3)
      RMI=MIN(R1,R2,R3)
      RCT=R1+R2+R3-RMI-RMA
      D(1)=RMI-0.
      D(2)=RCT-RMI
      D(3)=RMA-RCT
      D(4)=1.-RMA
      X=D(1)*X1+D(2)*X2+D(3)*X3+D(4)*X4
      Y=D(1)*Y1+D(2)*Y2+D(3)*Y3+D(4)*Y4
      Z=D(1)*Z1+D(2)*Z2+D(3)*Z3+D(4)*Z4
      RETURN
C
      END
C ===== SOURCE: fthomp.f
C
C
      FUNCTION FTHOMP(UB,EMAX)
C
C  RANDOM NUMBER "E" FROM A THOMPSON FUNCTION F(E,UB,EMAX)
C  F(E,UB,EMAX)=CONST*E/(E+UB)**3,  0<E<EMAX
C  CONST=UB/(0.5*1./(EMAX/UB+1.)**2-1./(EMAX/UB+1.)+0.5)
C
      USE PRECISION

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: UB, EMAX
      REAL(DP) :: A, E, ARG, BETAD2, FTHOMP, EMU
      REAL(DP), EXTERNAL :: RANF_EIRENE

      EMU=1./(EMAX/UB+1.)
      BETAD2=1./(EMU*EMU-EMU-EMU+1.)
C
      A=RANF_EIRENE()
      ARG=A/BETAD2
      E=UB/(1.-SQRT(ARG))-UB
      FTHOMP=E
C
      RETURN
      END
C ===== SOURCE: step.f
C jet-2005, patch 1, nov. 05:  add mcstep, fistep, festep, shstep, vpstep
c                              ve and eltot
c requires also:  jet-2005, patch 1 of cstep.f
C
      FUNCTION STEP(NSPZI,NSPZE,NS,ISTEP)
C
C   SET  CUMULATIVE DISTRIBUTION FUNCTION VF(I),I=1,NS; VF(1)=0;
C   VF(NS)=1. ON THE GRID RRSTEP(I),I=1,NS
C   FROM PIECEWISE CONSTANT DISTRIBUTION DENSITY FLSTEP(..,I),I=1,NS-1
C   FLSTEP(0,..,I) IS THE VALUE OF THE NON NORMALIZED DENSITY IN THE
C   INTERVALL RRSTEP(I)<X<=RRSTEP(I+1), AFTER SUMMATION OVER THE
C   FIRST (SPECIES) INDEX ISPZ=NSPZI,NSPZE
C
C   THE NORMALIZING FACTOR: INTEGR. FLSTEP(0,X) DX  IS RETURNED AS
C   "STEP"
C
      USE PRECISION
      USE PARMMOD
      USE COMUSR
      USE COMPRT, ONLY: IUNOUT
      USE CCONA
      USE CTRCEI
      USE CSTEP

      IMPLICIT NONE

      REAL(DP), INTENT(IN) :: X, Y
      INTEGER, INTENT(IN) :: NSPZ1, ISTEP, NSPZI, NSPZE, NS
      INTEGER, INTENT(OUT) :: IINDEX
c slmod begin - gfortran
      REAL(DP), ALLOCATABLE :: SP0(:,:),SP1(:,:),SP2(:,:),
     .                         SP3(:,:),SP4(:,:),SP5(:,:)
      INTEGER, ALLOCATABLE :: IP0(:),IP1(:),IP2(:),IP3(:),IP4(:)
c
c      REAL(DP) :: SP0(NSPZ,NGITT),SP1(NSPZ,NGITT),SP2(NSPZ,NGITT),
c     .            SP3(NSPZ,NGITT),SP4(NSPZ,NGITT),SP5(NSPZ,NGITT)
c      INTEGER :: IP0(NGITT),IP1(NGITT),IP2(NGITT),IP3(NGITT),IP4(NGITT)
c slmod end
      REAL(DP) ::  DELR, XX, STEP, STEP0, STEP1
      INTEGER :: NS1, ISPZ1, ISPZ, LEARCA, I, IS, JJ, JJM, NSM, J, IND,
     .           ISPZTI, ISPZV
      LOGICAL :: NLINV
c slmod begin
      INTEGER idum
c slmod end
      SAVE
c slmod begin - gfortran
      IF (.NOT.ALLOCATED(SP0)) ALLOCATE(SP0(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(SP1)) ALLOCATE(SP1(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(SP2)) ALLOCATE(SP2(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(SP3)) ALLOCATE(SP3(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(SP4)) ALLOCATE(SP4(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(SP5)) ALLOCATE(SP5(NSPZ,NGITT))
      IF (.NOT.ALLOCATED(IP0)) ALLOCATE(IP0(NGITT))
      IF (.NOT.ALLOCATED(IP1)) ALLOCATE(IP1(NGITT))
      IF (.NOT.ALLOCATED(IP2)) ALLOCATE(IP2(NGITT))
      IF (.NOT.ALLOCATED(IP3)) ALLOCATE(IP3(NGITT))
      IF (.NOT.ALLOCATED(IP4)) ALLOCATE(IP4(NGITT))
c slmod end
C     
      IF (NSPZE.GT.NSPZ) GOTO 991
      IF (NSPZI.LT.1) GOTO 991
      NSM=NS-1
      NSMAX(ISTEP)=NS
      NSPSTI(ISTEP)=NSPZI
      NSPSTE(ISTEP)=NSPZE
C
      NLINV=.FALSE.
1     CONTINUE
      IF (NLINV) THEN
        DO 2 J=1,NS
          SP0(1,J)=RRSTEP(ISTEP,J)
2       CONTINUE
        DO 3 J=1,NS
          RRSTEP(ISTEP,J)=SP0(1,NS-J+1)
3       CONTINUE
C
        DO 4 ISPZ=NSPZI,NSPZE
          DO J=1,NSM
            SP0(ISPZ,J)=FLSTEP(ISPZ,ISTEP,J)
            SP1(ISPZ,J)=ELSTEP(ISPZ,ISTEP,J)
          ENDDO
4       CONTINUE
        DO 5 ISPZ=NSPZI,NSPZE
          DO J=1,NSM
            FLSTEP(ISPZ,ISTEP,J)=SP0(ISPZ,NSM-J+1)
            ELSTEP(ISPZ,ISTEP,J)=SP1(ISPZ,NSM-J+1)
          ENDDO
5       CONTINUE
C
        DO 8 ISPZ=NSPZI,NSPZE
          ISPZTI=MPLSTI(ISPZ)
          ISPZV=MPLSV(ISPZ)
          DO 8 J=1,NSM
            SP1(ISPZ,J)=VXSTEP(ISPZV,ISTEP,J)
            SP2(ISPZ,J)=VYSTEP(ISPZV,ISTEP,J)
            SP3(ISPZ,J)=VZSTEP(ISPZV,ISTEP,J)
            SP4(ISPZ,J)=DISTEP(ISPZ,ISTEP,J)
            SP5(ISPZTI,J)=TISTEP(ISPZTI,ISTEP,J)
8       CONTINUE
        DO 9 ISPZ=NSPZI,NSPZE
          ISPZTI=MPLSTI(ISPZ)
          ISPZV=MPLSV(ISPZ)
          DO 9 J=1,NSM
            VXSTEP(ISPZV,ISTEP,J)=SP1(ISPZ,NSM-J+1)
            VYSTEP(ISPZV,ISTEP,J)=SP2(ISPZ,NSM-J+1)
            VZSTEP(ISPZV,ISTEP,J)=SP3(ISPZ,NSM-J+1)
            DISTEP(ISPZ,ISTEP,J)=SP4(ISPZ,NSM-J+1)
            TISTEP(ISPZTI,ISTEP,J)=SP5(ISPZTI,NSM-J+1)
9       CONTINUE
        DO  ISPZ=NSPZI,NSPZE
          ISPZTI=MPLSTI(ISPZ)
          ISPZV=MPLSV(ISPZ)
          DO  J=1,NSM
            SP1(ISPZ,J)=VPSTEP(ISPZV,ISTEP,J)
            SP2(ISPZ,J)=MCSTEP(ISPZ,ISTEP,J)
            SP3(ISPZ,J)=FISTEP(ISPZ,ISTEP,J)
          END DO
      END DO
        DO  ISPZ=NSPZI,NSPZE
          ISPZTI=MPLSTI(ISPZ)
          ISPZV=MPLSV(ISPZ)
          DO  J=1,NSM
            VPSTEP(ISPZV,ISTEP,J)=SP1(ISPZ,NSM-J+1)
            MCSTEP(ISPZ,ISTEP,J)=SP2(ISPZ,NSM-J+1)
            FISTEP(ISPZ,ISTEP,J)=SP3(ISPZ,NSM-J+1)
          END DO
        END DO
C
        DO 6 J=1,NSM
          SP0(1,J)=TESTEP(ISTEP,J)
          SP1(1,J)=SHSTEP(ISTEP,J)
          SP2(1,J)=FESTEP(ISTEP,J)
          IP0(J)=IRSTEP(ISTEP,J)
          IP1(J)=IPSTEP(ISTEP,J)
          IP2(J)=ITSTEP(ISTEP,J)
          IP3(J)=IASTEP(ISTEP,J)
          IP4(J)=IBSTEP(ISTEP,J)
6       CONTINUE
        DO 7 J=1,NSM
          TESTEP(ISTEP,J)=SP0(1,NSM-J+1)
          SHSTEP(ISTEP,J)=SP1(1,NSM-J+1)
          FESTEP(ISTEP,J)=SP2(1,NSM-J+1)
          IRSTEP(ISTEP,J)=IP0(NSM-J+1)
          IPSTEP(ISTEP,J)=IP1(NSM-J+1)
          ITSTEP(ISTEP,J)=IP2(NSM-J+1)
          IASTEP(ISTEP,J)=IP3(NSM-J+1)
          IBSTEP(ISTEP,J)=IP4(NSM-J+1)
7       CONTINUE
      ENDIF

C  inverting stepfunction: done
C
C  now: sum over species
C
      DO 10 J=1,NSM
        FLSTEP(0,ISTEP,J)=0.
        ELSTEP(0,ISTEP,J)=0.
        DO 11 ISPZ=NSPZI,NSPZE
          FLSTEP(0,ISTEP,J)=FLSTEP(0,ISTEP,J)+FLSTEP(ISPZ,ISTEP,J)
          ELSTEP(0,ISTEP,J)=ELSTEP(0,ISTEP,J)+ELSTEP(ISPZ,ISTEP,J)
11      CONTINUE
        DO ISPZ=NSPZE+1,NSPZ
          FLSTEP(ISPZ,ISTEP,J)=0.
          ELSTEP(ISPZ,ISTEP,J)=0.
        ENDDO
        DO ISPZ=1,NSPZI-1
          FLSTEP(ISPZ,ISTEP,J)=0.
          ELSTEP(ISPZ,ISTEP,J)=0.
        ENDDO
10    CONTINUE

C
C   set cummulative distribution VL (particles) and EL (energy),
C                   for all species: ispz and for sum over species: ispz=0
C
      DO 20 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 20
        VF(ISPZ,ISTEP,1)=0.
        VE(ISPZ,ISTEP,1)=0.
        DO 21 J=2,NS
          DELR=RRSTEP(ISTEP,J)-RRSTEP(ISTEP,J-1)
          IF (DELR.LT.0.D0) THEN
            IF (NLINV) GOTO 993
C  INVERT COMPLETE STEPFUNCTION ISTEP (ONLY ONCE)
            IF (TRCSOU) WRITE (iunout,*) 
     .        'STEPFUNCTION NO. ISTEP= ',ISTEP,' REVERSED'
            NLINV=.TRUE.
            GOTO 1
          ENDIF
          VF(ISPZ,ISTEP,J)=VF(ISPZ,ISTEP,J-1)+
     .                      FLSTEP(ISPZ,ISTEP,J-1)*DELR
          IF (VF(ISPZ,ISTEP,J).LT.VF(ISPZ,ISTEP,J-1)) GOTO 994
          VE(ISPZ,ISTEP,J)=VE(ISPZ,ISTEP,J-1)+
     .                     ELSTEP(ISPZ,ISTEP,J-1)
c slmod begin - debug
c         IF (istep.EQ.2) THEN
c           WRITE(0,'(A,3I6,4E10.2)') 
c     .       'STEP1:',ispz,istep,j,VF(ISPZ,ISTEP,J),VE(ISPZ,ISTEP,J),
c     .          FLSTEP(ISPZ,ISTEP,J-1),DELR
c         ENDIF
c slmod end
21      CONTINUE
20    CONTINUE
C  CUMMULATIVE STEPFUNCTION "VF" NO. ISTEP IS DEFINED NOW
C  RETURN TOTAL FLUX, SUM OVER SPECIES 
c slmod begin - debug
c      WRITE(0,*) 'STEP:',istep,ns,vf(0,istep,ns)
c slmod end

      STEP=VF(0,ISTEP,NS)

C  NORMALIZE VF TO 1.
C
      DO 25 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 25
C  save totals before normalization
        FLTOT(ISPZ,ISTEP)=VF(ISPZ,ISTEP,NS)
        ELTOT(ISPZ,ISTEP)=VE(ISPZ,ISTEP,NS)

        IF (FLTOT(ISPZ,ISTEP).LE.0.D0) THEN
          WRITE (iunout,*) 'WARNING FROM FUNCTION "STEP"'
          WRITE (iunout,*) 
     .      'DENSITY FUNCTION FLSTEP(ISPZ,ISTEP) VANISHES '
          WRITE (iunout,*) 'ISPZ,ISTEP ',ISPZ,ISTEP
        ENDIF
25    CONTINUE
C
      DO 30 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 30
        DO 31 J=1,NS
31        VF(ISPZ,ISTEP,J)=VF(ISPZ,ISTEP,J)/(FLTOT(ISPZ,ISTEP)+EPS60)
30      CONTINUE
C
C  SET SOME ARRAYS TO SPEED UP SAMPLING FROM VF(ISPZ,ISTEP,...)
      DO 40 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 40
        DO 41 J=1,NSM
          QUOT(ISPZ,ISTEP,J)=(RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J))/
     .               (VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J)+EPS60)
          ADD (ISPZ,ISTEP,J)=-QUOT(ISPZ,ISTEP,J)*VF(ISPZ,ISTEP,J)+
     .                         RRSTEP(ISTEP,J)
          QUOTI(ISPZ,ISTEP,J)=(VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J))/
     .                   (RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J)+EPS60)
          ADDIV(ISPZ,ISTEP,J)=-QUOTI(ISPZ,ISTEP,J)*RRSTEP(ISTEP,J)+
     .                          VF(ISPZ,ISTEP,J)
41      CONTINUE
40    CONTINUE
C
      IF (ISTUF(ISTEP).NE.0) THEN
        WRITE (iunout,*) 'WARNING FROM FUNCTION STEP: VF(ISTEP) IS   '
        WRITE (iunout,*) 'OVERWRITTEN. ISTEP= ',ISTEP
      ENDIF
      ISTUF(ISTEP)=1
      IF (TRCSOU) THEN
        WRITE (iunout,*) 'STEPFUNCTION NO. ISTEP= ',ISTEP,' INITIALISED'
        CALL LEER(1)
      ENDIF
      RETURN
C
      ENTRY STEP0(NSPZ1,ISTEP,X)
      ISPZ1=NSPZ1
C
C   COMPUTE VF(X) NO. ISTEP BY LINEAR INTERPOLATION
C
      IF (ISPZ1.LT.0) GOTO 990
      IF (ISPZ1.GT.0.AND.ISPZ1.LT.NSPSTI(ISTEP)) GOTO 990
      IF (ISPZ1.GT.NSPSTE(ISTEP)) GOTO 990
C
      IF (ISTEP.LE.0.OR.ISTEP.GT.NSTEP) GOTO  990
      IF (ISTUF(ISTEP).EQ.0) GOTO 990
C
      NS1=NSMAX(ISTEP)
      IF (X.LT.RRSTEP(ISTEP,1)) THEN
        WRITE (iunout,*) 'X OUT OF RANGE IN STEP0, X,RRSTEP(1) ',X,
     .               RRSTEP(ISTEP,1)
        STEP0=0.
      ELSEIF (X.GT.RRSTEP(ISTEP,NS1)) THEN
        WRITE (iunout,*) 'X OUT OF RANGE IN STEP0, X,RRSTEP(NS1) ',X,
     .               RRSTEP(ISTEP,NS1)
        STEP0=1.
      ELSE
        IND=LEARCA(X,RRSTEP,NSTEP,NS1,ISTEP,'STEP0       ')
        STEP0=ADDIV(ISPZ1,ISTEP,IND)+X*QUOTI(ISPZ1,ISTEP,IND)
      ENDIF
      RETURN
C
      ENTRY STEP1(IINDEX,ISTEP,Y,NSPZ1)
      ISPZ1=NSPZ1
C
C  INVERT FUNCTION VF(ISPZ1,X)=Y. NO. ISTEP, E.G.
C  SAMPLE FROM VF WITH Y=RANF,  RRSTEP(ISTEP,1)<=X<=RRSTEP(ISTEP,NS1)
C  RETURN THE VALUE X AS STEP1, AND THE INTERVAL NUMBER IINDEX OF
C  THE INTERVAL CONTAINING THIS X.
C
      IF (ISTEP.LE.0.OR.ISTEP.GT.NSTEP) GOTO  990
      IF (ISTUF(ISTEP).EQ.0) GOTO 990
C
      IF (ISPZ1.LT.0) ISPZ1=0
      IF (ISPZ1.GT.0.AND.ISPZ1.LT.NSPSTI(ISTEP)) ISPZ1=0
      IF (ISPZ1.GT.NSPSTE(ISTEP)) ISPZ1=0
C
      NS1=NSMAX(ISTEP)
      DO 100 J=2,NS1
        JJ=J
        IF (Y.LE.VF(ISPZ1,ISTEP,J)) GOTO 110
100   CONTINUE
110   JJM=JJ-1
      IINDEX=JJM
      XX=ADD(ISPZ1,ISTEP,JJM)+Y*QUOT(ISPZ1,ISTEP,JJM)
      STEP1=XX
      RETURN
C
990   CONTINUE
      WRITE (iunout,*) 'ERROR IN FUNCTION STEP, ISTEP= ',ISTEP
      CALL EXIT_OWN(1)
991   CONTINUE
      WRITE (iunout,*) 'PARAMETER ERROR IN FUNCTION STEP '
      WRITE (iunout,*) 'NSPZE MUST BE .LE. NSPZ '
      WRITE (iunout,*) 'NSPZI MUST BE .GE. 1    '
      WRITE (iunout,*) 'NSPZI,NSPZE,NSPZ = ',NSPZI,NSPZE,NSPZ
      CALL EXIT_OWN(1)
993   CONTINUE
      WRITE (iunout,*) 'ERROR IN FUNCTION STEP, ISTEP= ',ISTEP
      WRITE (iunout,*) 'RRSTEP NEITHER MONOTONICALLY INCREASING NOR'
      WRITE (iunout,*) 'DECREASING'
      CALL EXIT_OWN(1)
994   CONTINUE
      WRITE (iunout,*) 'ERROR IN FUNCTION "STEP" '
      WRITE (iunout,*) 'VF IS NOT MONOTONICALLY INCREASING'
      WRITE (iunout,*) 'POSSIBLE REASON: FLSTEP NEGATIVE SOMEWHERE? '
      WRITE (iunout,*) 'ISTEP, J ',ISTEP,J
      WRITE (iunout,*) ' I   RRSTEP     VF '
      DO 995 I=1,J
        WRITE (iunout,'(1X,I3,1P,5E12.4)') 
     .         I,RRSTEP(ISTEP,I),(VF(IS,ISTEP,I),IS=NSPZI,NSPZE)
995   CONTINUE
      CALL EXIT_OWN(1)
      END
