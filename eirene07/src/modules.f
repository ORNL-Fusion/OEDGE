C EIRENE07 COMPILATION
C ===== SOURCE: braeir.f
      MODULE BRAEIR

C  PLASMA DATA: NI,TE,TI,VV,UU,PR,UP,RR,FNIX,FNIY.. (BRAAMS ---> EIRENE)

      USE PRECISION
!pb      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_BRAEIR, DEALLOC_BRAEIR, INIT_BRAEIR

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  DNIB(:,:,:),    TEB(:,:),       TIB(:,:),   VVB(:,:,:),
     R  UUB(:,:,:),     PRB(:,:),       UPB(:,:,:), RRB(:,:),
     R  FNIXB(:,:,:),   FNIYB(:,:,:),   FEIXB(:,:), FEIYB(:,:),
     R  FEEXB(:,:),     FEEYB(:,:),     VOLB(:,:),  BFELDB(:,:),
     R  FNIX_YB(:,:,:), FNIY_XB(:,:,:),
     R  UUDIAB(:,:,:),  VVDIAB(:,:,:)

      INTEGER, SAVE :: NDXP, NDYP, NFL


      CONTAINS


      SUBROUTINE ALLOC_BRAEIR(NDXD, NDYD, NFLD)

      INTEGER, INTENT(IN) :: NDXD, NDYD, NFLD

      IF (ALLOCATED(DNIB)) RETURN

      NDXP = NDXD+1
      NDYP = NDYD+1
      NFL = NFLD

      ALLOCATE (DNIB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (TEB(0:NDXP,0:NDYP))
      ALLOCATE (TIB(0:NDXP,0:NDYP))
      ALLOCATE (VVB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (UUB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (PRB(0:NDXP,0:NDYP))
      ALLOCATE (UPB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (RRB(0:NDXP,0:NDYP))
      ALLOCATE (FNIXB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (FNIYB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (FEIXB(0:NDXP,0:NDYP))
      ALLOCATE (FEIYB(0:NDXP,0:NDYP))
      ALLOCATE (FEEXB(0:NDXP,0:NDYP))
      ALLOCATE (FEEYB(0:NDXP,0:NDYP))
      ALLOCATE (VOLB(0:NDXP,0:NDYP))
      ALLOCATE (BFELDB(0:NDXP,0:NDYP))
      ALLOCATE (FNIX_YB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (FNIY_XB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (UUDIAB(0:NDXP,0:NDYP,NFL))
      ALLOCATE (VVDIAB(0:NDXP,0:NDYP,NFL))

      WRITE (55,'(A,T25,I15)')
     .      ' BRAEIR ',(NDXP+1)*(NDYP+1)*(10*NFL+10)*8

      CALL INIT_BRAEIR

      RETURN
      END SUBROUTINE ALLOC_BRAEIR


      SUBROUTINE DEALLOC_BRAEIR

      IF (.NOT.ALLOCATED(DNIB)) RETURN

      DEALLOCATE (DNIB)
      DEALLOCATE (TEB)
      DEALLOCATE (TIB)
      DEALLOCATE (VVB)
      DEALLOCATE (UUB)
      DEALLOCATE (PRB)
      DEALLOCATE (UPB)
      DEALLOCATE (RRB)
      DEALLOCATE (FNIXB)
      DEALLOCATE (FNIYB)
      DEALLOCATE (FEIXB)
      DEALLOCATE (FEIYB)
      DEALLOCATE (FEEXB)
      DEALLOCATE (FEEYB)
      DEALLOCATE (VOLB)
      DEALLOCATE (BFELDB)
      DEALLOCATE (FNIX_YB)
      DEALLOCATE (FNIY_XB)
      DEALLOCATE (UUDIAB)
      DEALLOCATE (VVDIAB)

      RETURN
      END SUBROUTINE DEALLOC_BRAEIR


      SUBROUTINE INIT_BRAEIR

      DNIB    = 0.D0
      TEB     = 0.D0
      TIB     = 0.D0
      VVB     = 0.D0
      UUB     = 0.D0
      PRB     = 0.D0
      UPB     = 0.D0
      RRB     = 0.D0
      FNIXB   = 0.D0
      FNIYB   = 0.D0
      FEIXB   = 0.D0
      FEIYB   = 0.D0
      FEEXB   = 0.D0
      FEEYB   = 0.D0
      VOLB    = 0.D0
      BFELDB  = 0.D0
      FNIX_YB = 0.D0
      FNIY_XB = 0.D0
      UUDIAB  = 0.D0
      VVDIAB  = 0.D0

      RETURN
      END SUBROUTINE INIT_BRAEIR

      END MODULE BRAEIR
C ===== SOURCE: brascl.f
      MODULE BRASCL

C  RESCALING ARRAYS FOR NEUTRAL SOURCE TERMS IN SHORT LOOP

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_BRASCL, DEALLOC_BRASCL,
     P          INIT_BRASCL1, INIT_BRASCL2

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R SPLODA(:,:,:), SEIODA(:,:), SEEODA(:,:), SMOODA(:,:),
     R SPLODI(:,:,:), SEIODI(:,:), SEEODI(:,:), SMOODI(:,:),
     R SPLODM(:,:,:), SEIODM(:,:), SEEODM(:,:), SMOODM(:,:),
     R SPLNWA(:,:,:), SEINWA(:,:), SEENWA(:,:), SMONWA(:,:),
     R SPLNWI(:,:,:), SEINWI(:,:), SEENWI(:,:), SMONWI(:,:),
     R SPLNWM(:,:,:), SEINWM(:,:), SEENWM(:,:), SMONWM(:,:)


      CONTAINS


      SUBROUTINE ALLOC_BRASCL

      IF (ALLOCATED(SPLODA)) RETURN

      ALLOCATE (SPLODA(NRAD,NATM,NPLS))
      ALLOCATE (SEIODA(NRAD,NPLS))
      ALLOCATE (SEEODA(NRAD,NATM))
      ALLOCATE (SMOODA(NRAD,NATM))
      ALLOCATE (SPLODI(NRAD,NION,NPLS))
      ALLOCATE (SEIODI(NRAD,NION))
      ALLOCATE (SEEODI(NRAD,NION))
      ALLOCATE (SMOODI(NRAD,NION))
      ALLOCATE (SPLODM(NRAD,NMOL,NPLS))
      ALLOCATE (SEIODM(NRAD,NMOL))
      ALLOCATE (SEEODM(NRAD,NMOL))
      ALLOCATE (SMOODM(NRAD,NMOL))
      ALLOCATE (SPLNWA(NRAD,NATM,NPLS))
      ALLOCATE (SEINWA(NRAD,NPLS))
      ALLOCATE (SEENWA(NRAD,NATM))
      ALLOCATE (SMONWA(NRAD,NATM))
      ALLOCATE (SPLNWI(NRAD,NION,NPLS))
      ALLOCATE (SEINWI(NRAD,NION))
      ALLOCATE (SEENWI(NRAD,NION))
      ALLOCATE (SMONWI(NRAD,NION))
      ALLOCATE (SPLNWM(NRAD,NMOL,NPLS))
      ALLOCATE (SEINWM(NRAD,NMOL))
      ALLOCATE (SEENWM(NRAD,NMOL))
      ALLOCATE (SMONWM(NRAD,NMOL))

      WRITE (55,'(A,T25,I15)')
     .      ' BRASCL ',NRAD*(NATM*(2*NPLS+4)+NION*(2*NPLS+6)+
     .                 NMOL*(2*NPLS+6)+2*NPLS)*8

      CALL INIT_BRASCL1
      CALL INIT_BRASCL2

      RETURN
      END SUBROUTINE ALLOC_BRASCL


      SUBROUTINE DEALLOC_BRASCL

      IF (.NOT.ALLOCATED(SPLODA)) RETURN

      DEALLOCATE (SPLODA)
      DEALLOCATE (SEIODA)
      DEALLOCATE (SEEODA)
      DEALLOCATE (SMOODA)
      DEALLOCATE (SPLODI)
      DEALLOCATE (SEIODI)
      DEALLOCATE (SEEODI)
      DEALLOCATE (SMOODI)
      DEALLOCATE (SPLODM)
      DEALLOCATE (SEIODM)
      DEALLOCATE (SEEODM)
      DEALLOCATE (SMOODM)
      DEALLOCATE (SPLNWA)
      DEALLOCATE (SEINWA)
      DEALLOCATE (SEENWA)
      DEALLOCATE (SMONWA)
      DEALLOCATE (SPLNWI)
      DEALLOCATE (SEINWI)
      DEALLOCATE (SEENWI)
      DEALLOCATE (SMONWI)
      DEALLOCATE (SPLNWM)
      DEALLOCATE (SEINWM)
      DEALLOCATE (SEENWM)
      DEALLOCATE (SMONWM)

      RETURN
      END SUBROUTINE DEALLOC_BRASCL


      SUBROUTINE INIT_BRASCL1

      SPLODA = 0.D0
      SEIODA = 0.D0
      SEEODA = 0.D0
      SMOODA = 0.D0
      SPLODI = 0.D0
      SEIODI = 0.D0
      SEEODI = 0.D0
      SMOODI = 0.D0
      SPLODM = 0.D0
      SEIODM = 0.D0
      SEEODM = 0.D0
      SMOODM = 0.D0

      RETURN
      END SUBROUTINE INIT_BRASCL1


      SUBROUTINE INIT_BRASCL2

      SPLNWA = 0.D0
      SEINWA = 0.D0
      SEENWA = 0.D0
      SMONWA = 0.D0
      SPLNWI = 0.D0
      SEINWI = 0.D0
      SEENWI = 0.D0
      SMONWI = 0.D0
      SPLNWM = 0.D0
      SEINWM = 0.D0
      SEENWM = 0.D0
      SMONWM = 0.D0

      RETURN
      END SUBROUTINE INIT_BRASCL2

      END MODULE BRASCL
C ===== SOURCE: braspoi.f
      MODULE BRASPOI

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE
      PUBLIC :: ALLOC_BRASPOI, DEALLOC_BRASPOI, NEW_SIMARR, NEW_MULARR,
     .          FREE_SIMARR, FREE_MULARR
      PUBLIC :: CELLSIM, CELLMUL, SIMARR, MULARR,
     .          EAELS, EMELS, EIELS,
     .          EAPLS, EMPLS, EIPLS, PAPLS, PMPLS, PIPLS,
     .          PDENAS, PDENMS, PDENIS, EDENAS, COPVS,
     .          PPPL_COPS, CPPVS, EPPL_COPS, EPELS,
     .          MAPLS, MMPLS, MIPLS, MPHPLS

      TYPE :: CELLSIM
        REAL(DP) :: VALUES
        INTEGER :: ICS
        TYPE(CELLSIM), POINTER :: NXTSIM
      END TYPE CELLSIM

      TYPE :: CELLMUL
        REAL(DP) :: VALUEM
        INTEGER :: IART,ICM
        TYPE(CELLMUL), POINTER :: NXTMUL
      END TYPE CELLMUL

      TYPE :: SIMARR
        TYPE(CELLSIM),POINTER :: PSIM
      END TYPE SIMARR

      TYPE :: MULARR
        TYPE(CELLMUL),POINTER :: PMUL
      END TYPE MULARR

      TYPE(SIMARR), ALLOCATABLE, SAVE :: EAELS(:), EMELS(:), EIELS(:),
     .                                   EAPLS(:), EMPLS(:), EIPLS(:),
     .                                   EPPL_COPS(:), EPELS(:)
      TYPE(MULARR), ALLOCATABLE, SAVE :: PAPLS(:), PMPLS(:), PIPLS(:),
     .                                   PDENAS(:),PDENMS(:),PDENIS(:),
     .                                   EDENAS(:),COPVS(:),
     .                                   PPPL_COPS(:), CPPVS(:),
     .                                   MAPLS(:), MMPLS(:), MIPLS(:),
     .                                   MPHPLS(:)                    

      TYPE(CELLSIM),POINTER, SAVE :: COLLECT_SIMARR
      TYPE(CELLMUL),POINTER, SAVE :: COLLECT_MULARR

      CONTAINS


      SUBROUTINE ALLOC_BRASPOI

      INTEGER :: ISTRAI

      IF (ALLOCATED(EAELS)) RETURN

      ALLOCATE (EAELS(NSTRA))
      ALLOCATE (EMELS(NSTRA))
      ALLOCATE (EIELS(NSTRA))
      ALLOCATE (EAPLS(NSTRA))
      ALLOCATE (EMPLS(NSTRA))
      ALLOCATE (EIPLS(NSTRA))
      ALLOCATE (EPPL_COPS(NSTRA))
      ALLOCATE (EPELS(NSTRA))
      ALLOCATE (PAPLS(NSTRA))
      ALLOCATE (PMPLS(NSTRA))
      ALLOCATE (PIPLS(NSTRA))
      ALLOCATE (PDENAS(NSTRA))
      ALLOCATE (PDENMS(NSTRA))
      ALLOCATE (PDENIS(NSTRA))
      ALLOCATE (EDENAS(NSTRA))
      ALLOCATE (COPVS(NSTRA))
      ALLOCATE (PPPL_COPS(NSTRA))
      ALLOCATE (CPPVS(NSTRA))
      ALLOCATE (MAPLS(NSTRA))
      ALLOCATE (MMPLS(NSTRA))
      ALLOCATE (MIPLS(NSTRA))
      ALLOCATE (MPHPLS(NSTRA))


      DO ISTRAI=1,NSTRA

      NULLIFY(PAPLS(ISTRAI)%PMUL)
      NULLIFY(PMPLS(ISTRAI)%PMUL)
      NULLIFY(PIPLS(ISTRAI)%PMUL)

      NULLIFY(EAELS(ISTRAI)%PSIM)
      NULLIFY(EMELS(ISTRAI)%PSIM)
      NULLIFY(EIELS(ISTRAI)%PSIM)
      NULLIFY(EAPLS(ISTRAI)%PSIM)
      NULLIFY(EMPLS(ISTRAI)%PSIM)
      NULLIFY(EIPLS(ISTRAI)%PSIM)
      NULLIFY(EPPL_COPS(ISTRAI)%PSIM)
      NULLIFY(EPELS(ISTRAI)%PSIM)

      NULLIFY(PDENAS(ISTRAI)%PMUL)
      NULLIFY(PDENMS(ISTRAI)%PMUL)
      NULLIFY(PDENIS(ISTRAI)%PMUL)
      NULLIFY(EDENAS(ISTRAI)%PMUL)

      NULLIFY(COPVS(ISTRAI)%PMUL)
      NULLIFY(PPPL_COPS(ISTRAI)%PMUL)
      NULLIFY(CPPVS(ISTRAI)%PMUL)

      NULLIFY(MAPLS(ISTRAI)%PMUL)
      NULLIFY(MMPLS(ISTRAI)%PMUL)
      NULLIFY(MIPLS(ISTRAI)%PMUL)
      NULLIFY(MPHPLS(ISTRAI)%PMUL)

      END DO

      NULLIFY(COLLECT_SIMARR)
      NULLIFY(COLLECT_MULARR)

      WRITE (55,'(A,T25,I15)')
     .      ' BRASPOI ',18*NSTRA*8

      RETURN
      END SUBROUTINE ALLOC_BRASPOI


      SUBROUTINE DEALLOC_BRASPOI

      IF (.NOT.ALLOCATED(EAELS)) RETURN

      DEALLOCATE (EAELS)
      DEALLOCATE (EMELS)
      DEALLOCATE (EIELS)
      DEALLOCATE (EAPLS)
      DEALLOCATE (EMPLS)
      DEALLOCATE (EIPLS)
      DEALLOCATE (EPPL_COPS)
      DEALLOCATE (EPELS)
      DEALLOCATE (PAPLS)
      DEALLOCATE (PMPLS)
      DEALLOCATE (PIPLS)
      DEALLOCATE (PDENAS)
      DEALLOCATE (PDENMS)
      DEALLOCATE (PDENIS)
      DEALLOCATE (EDENAS)
      DEALLOCATE (COPVS)
      DEALLOCATE (PPPL_COPS)
      DEALLOCATE (CPPVS)
      DEALLOCATE (MAPLS)
      DEALLOCATE (MMPLS)
      DEALLOCATE (MIPLS)
      DEALLOCATE (MPHPLS)

      RETURN
      END SUBROUTINE DEALLOC_BRASPOI


      FUNCTION NEW_SIMARR() RESULT(NODE)

      TYPE(CELLSIM), POINTER :: NODE

      IF (ASSOCIATED(COLLECT_SIMARR)) THEN
        NODE => COLLECT_SIMARR
        COLLECT_SIMARR => COLLECT_SIMARR%NXTSIM
      ELSE
        ALLOCATE (NODE)
        NULLIFY (NODE%NXTSIM)
      END IF

      RETURN
      END FUNCTION NEW_SIMARR


      FUNCTION NEW_MULARR() RESULT(NODE)

      TYPE(CELLMUL), POINTER :: NODE

      IF (ASSOCIATED(COLLECT_MULARR)) THEN
        NODE => COLLECT_MULARR
        COLLECT_MULARR => COLLECT_MULARR%NXTMUL
      ELSE
        ALLOCATE (NODE)
        NULLIFY (NODE%NXTMUL)
      END IF

      RETURN
      END FUNCTION NEW_MULARR


      SUBROUTINE FREE_SIMARR(ISTRAI)

      INTEGER, INTENT(IN) :: ISTRAI
      TYPE(CELLSIM), POINTER :: P

C  FREE EAELS
      P => EAELS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EAELS(ISTRAI)%PSIM
        NULLIFY(EAELS(ISTRAI)%PSIM)
      END IF

C  FREE EMELS
      P => EMELS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EMELS(ISTRAI)%PSIM
        NULLIFY(EMELS(ISTRAI)%PSIM)
      END IF


C  FREE EIELS
      P => EIELS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EIELS(ISTRAI)%PSIM
        NULLIFY(EIELS(ISTRAI)%PSIM)
      END IF

C  FREE EAPLS
      P => EAPLS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EAPLS(ISTRAI)%PSIM
        NULLIFY(EAPLS(ISTRAI)%PSIM)
      END IF

C  FREE EMPLS
      P => EMPLS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EMPLS(ISTRAI)%PSIM
        NULLIFY(EMPLS(ISTRAI)%PSIM)
      END IF


C  FREE EIPLS
      P => EIPLS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EIPLS(ISTRAI)%PSIM
        NULLIFY(EIPLS(ISTRAI)%PSIM)
      END IF

C  FREE EPPL_COPS
      P => EPPL_COPS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EPPL_COPS(ISTRAI)%PSIM
        NULLIFY(EPPL_COPS(ISTRAI)%PSIM)
      END IF


C  FREE EPELS
      P => EPELS(ISTRAI)%PSIM
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTSIM))
          P => P%NXTSIM
        END DO
        P%NXTSIM => COLLECT_SIMARR
        COLLECT_SIMARR => EPELS(ISTRAI)%PSIM
        NULLIFY(EPELS(ISTRAI)%PSIM)
      END IF

      RETURN
      END SUBROUTINE FREE_SIMARR



      SUBROUTINE FREE_MULARR(ISTRAI)

      INTEGER, INTENT(IN) :: ISTRAI
      TYPE(CELLMUL), POINTER :: P

C  FREE PAELS
      P => PAPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PAPLS(ISTRAI)%PMUL
        NULLIFY(PAPLS(ISTRAI)%PMUL)
      END IF

C  FREE PMPLS
      P => PMPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PMPLS(ISTRAI)%PMUL
        NULLIFY(PMPLS(ISTRAI)%PMUL)
      END IF

C  FREE PIPLS
      P => PIPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PIPLS(ISTRAI)%PMUL
        NULLIFY(PIPLS(ISTRAI)%PMUL)
      END IF

C  FREE PDENAS
      P => PDENAS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PDENAS(ISTRAI)%PMUL
        NULLIFY(PDENAS(ISTRAI)%PMUL)
      END IF

C  FREE PDENMS
      P => PDENMS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PDENMS(ISTRAI)%PMUL
        NULLIFY(PDENMS(ISTRAI)%PMUL)
      END IF

C  FREE PDENIS
      P => PDENIS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PDENIS(ISTRAI)%PMUL
        NULLIFY(PDENIS(ISTRAI)%PMUL)
      END IF

C  FREE EDENAS
      P => EDENAS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => EDENAS(ISTRAI)%PMUL
        NULLIFY(EDENAS(ISTRAI)%PMUL)
      END IF

C  FREE COPVS
      P => COPVS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => COPVS(ISTRAI)%PMUL
        NULLIFY(COPVS(ISTRAI)%PMUL)
      END IF

C  FREE PPPL_COPS
      P => PPPL_COPS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => PPPL_COPS(ISTRAI)%PMUL
        NULLIFY(PPPL_COPS(ISTRAI)%PMUL)
      END IF

C  FREE CPPVS
      P => CPPVS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => CPPVS(ISTRAI)%PMUL
        NULLIFY(CPPVS(ISTRAI)%PMUL)
      END IF

C  FREE MAPLS
      P => MAPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => MAPLS(ISTRAI)%PMUL
        NULLIFY(MAPLS(ISTRAI)%PMUL)
      END IF

C  FREE MAPLS
      P => MMPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => MMPLS(ISTRAI)%PMUL
        NULLIFY(MMPLS(ISTRAI)%PMUL)
      END IF

C  FREE MIPLS
      P => MIPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => MIPLS(ISTRAI)%PMUL
        NULLIFY(MIPLS(ISTRAI)%PMUL)
      END IF

C  FREE MPHPLS
      P => MPHPLS(ISTRAI)%PMUL
      IF (ASSOCIATED(P)) THEN
        DO WHILE (ASSOCIATED(P%NXTMUL))
          P => P%NXTMUL
        END DO
        P%NXTMUL => COLLECT_MULARR
        COLLECT_MULARR => MPHPLS(ISTRAI)%PMUL
        NULLIFY(MPHPLS(ISTRAI)%PMUL)
      END IF

      RETURN
      END SUBROUTINE FREE_MULARR

      END MODULE BRASPOI
C ===== SOURCE: cadgeo.f
      MODULE CADGEO

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CADGEO, DEALLOC_CADGEO, INIT_CADGEO

      INTEGER, PUBLIC, SAVE ::
     I NPLIM,  NADGEO, MADGEO

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        RADGEO(:,:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     I         IADGEO(:,:)

C NADGEO, REAL
      REAL(DP), PUBLIC, POINTER, SAVE ::
     R A0LM(:),     A1LM(:),     A2LM(:),     A3LM(:),     A4LM(:),
     R A5LM(:),     A6LM(:),     A7LM(:),     A8LM(:),     A9LM(:),
     R ALIMS(:,:),  XLIMS(:,:),  YLIMS(:,:),  ZLIMS(:,:),
     R ALIMS0(:,:), XLIMS1(:,:), YLIMS1(:,:), ZLIMS1(:,:),
     R XLIMS2(:,:), YLIMS2(:,:), ZLIMS2(:,:),
     R XLIMS3(:,:), YLIMS3(:,:), ZLIMS3(:,:),
     R RLB(:),
     R P1(:,:),     P2(:,:),     P3(:,:),     P4(:,:),    P5(:,:),
     R P6(:,:),
     R ALM(:),      BLM(:),      CLM(:),
     R PS13(:,:),   PS23(:,:),
     R PS24(:,:),   PS34(:,:),   PS35(:,:),   PS45(:,:),
     R P1A(:),      P2A(:),      P1B(:),      P2B(:),
     R P1C(:),      P2C(:)

C MADGEO, INTEGER
      INTEGER, PUBLIC, POINTER, SAVE ::
     I ILIN(:),     ISCN(:)

      INTEGER, PUBLIC, SAVE :: NLIMI

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L RLBNOT(:)

      CONTAINS


      SUBROUTINE ALLOC_CADGEO

      IF (ALLOCATED(RADGEO)) RETURN

      NPLIM=10+14*9+10+12*3
      NADGEO=NLIM*NPLIM
      MADGEO=NLIM*2

      ALLOCATE (RADGEO(NPLIM,NLIM))
      ALLOCATE (IADGEO(2,NLIM))
      ALLOCATE (RLBNOT(NLIM))

      WRITE (55,'(A,T25,I15)')
     .      ' CADGEO ',NLIM*(NPLIM+1)*8 + 2*NLIM*4

      A0LM => RADGEO(1,:)
      A1LM => RADGEO(2,:)
      A2LM => RADGEO(3,:)
      A3LM => RADGEO(4,:)
      A4LM => RADGEO(5,:)
      A5LM => RADGEO(6,:)
      A6LM => RADGEO(7,:)
      A7LM => RADGEO(8,:)
      A8LM => RADGEO(9,:)
      A9LM => RADGEO(10,:)
      ALIMS => RADGEO(11:19,:)
      XLIMS => RADGEO(20:28,:)
      YLIMS => RADGEO(29:37,:)
      ZLIMS => RADGEO(38:46,:)
      ALIMS0 => RADGEO(47:55,:)
      XLIMS1 => RADGEO(56:64,:)
      YLIMS1 => RADGEO(65:73,:)
      ZLIMS1 => RADGEO(74:82,:)
      XLIMS2 => RADGEO(83:91,:)
      YLIMS2 => RADGEO(92:100,:)
      ZLIMS2 => RADGEO(101:109,:)
      XLIMS3 => RADGEO(110:118,:)
      YLIMS3 => RADGEO(119:127,:)
      ZLIMS3 => RADGEO(128:136,:)
      RLB => RADGEO(137,:)
      P1 => RADGEO(138:140,:)
      P2 => RADGEO(141:143,:)
      P3 => RADGEO(144:146,:)
      P4 => RADGEO(147:149,:)
      P5 => RADGEO(150:152,:)
      P6 => RADGEO(153:155,:)
      ALM => RADGEO(156,:)
      BLM => RADGEO(157,:)
      CLM => RADGEO(158,:)
      PS13 => RADGEO(159:161,:)
      PS23 => RADGEO(162:164,:)
      PS24 => RADGEO(165:167,:)
      PS34 => RADGEO(168:170,:)
      PS35 => RADGEO(171:173,:)
      PS45 => RADGEO(174:176,:)
      P1A => RADGEO(177,:)
      P2A => RADGEO(178,:)
      P1B => RADGEO(179,:)
      P2B => RADGEO(180,:)
      P1C => RADGEO(181,:)
      P2C => RADGEO(182,:)

      ILIN => IADGEO(1,:)
      ISCN => IADGEO(2,:)

      CALL INIT_CADGEO

      RETURN
      END SUBROUTINE ALLOC_CADGEO

      SUBROUTINE DEALLOC_CADGEO

      IF (.NOT.ALLOCATED(RADGEO)) RETURN

      DEALLOCATE (RADGEO)
      DEALLOCATE (IADGEO)
      DEALLOCATE (RLBNOT)

      RETURN
      END SUBROUTINE DEALLOC_CADGEO


      SUBROUTINE INIT_CADGEO

      RADGEO = 0.D0
      IADGEO = 0
      RLBNOT = .FALSE.

      RETURN
      END SUBROUTINE INIT_CADGEO

      END MODULE CADGEO


C ===== SOURCE: cai.f
      MODULE CAI

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CAI, DEALLOC_CAI, INIT_CAI

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE :: RATIO(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE :: NRECOM(:)

      CONTAINS


      SUBROUTINE ALLOC_CAI

      IF (ALLOCATED(RATIO)) RETURN

      ALLOCATE (RATIO(NSTRA))
      ALLOCATE (NRECOM(NSTRA))

      WRITE (55,'(A,T25,I15)')
     .      ' CAI ',NSTRA*(8+4)

      CALL INIT_CAI

      RETURN
      END SUBROUTINE ALLOC_CAI


      SUBROUTINE DEALLOC_CAI

      IF (.NOT.ALLOCATED(RATIO)) RETURN

      DEALLOCATE (RATIO)
      DEALLOCATE (NRECOM)

      RETURN
      END SUBROUTINE DEALLOC_CAI


      SUBROUTINE INIT_CAI

      RATIO  = 0.D0
      NRECOM = 0

      RETURN
      END SUBROUTINE INIT_CAI

      END MODULE CAI
C ===== SOURCE: ccona.f
C   6.12.05   AU_TO_CM2 added here (and removed from fpatha, veloel)
C   1.01.06   hplnk_bar = hplnk/2Pi added here (and set in setcon.f)
C  22.12.06   Periodic Table of Elements introduced
C  16.01.06   function FIND_ELEMENT identifies an element in the PTE 
C             and returns the element number

      MODULE CCONA
      USE PRECISION

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CCONA, PTE_TYPE, SET_PTE_ELEMENT, FIND_ELEMENT

      TYPE PTE_TYPE
        CHARACTER(13) :: NAME
        CHARACTER(2) :: ABBR
        REAL(DP) :: EL_MASS, EL_CHARGE
      END TYPE

      REAL(DP), PUBLIC, TARGET, SAVE :: RCONA(43)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R EPS60,   EPS30,   EPS12,    EPS10,    EPS6,      EPS5,
     R PMASSA,  PMASSE,  AMUA,
     R PIA,     PI2A,    PIHA,     PIQU,     PISQ,     PIAI,      SQ2,
     R SQ2I,    DEGRAD,  RADDEG,
     R CVELI2,  CVELAA,  CVEL2A,   ELCHA,    EFACT,     EFCT23,   EVKEL,
     R EIONH,   EIONH2,  EIONHE,
     R EV_TO_J, J_TO_EV, J_TO_ERG, ERG_TO_J, EV_TO_ERG, ERG_TO_EV,
     R HPLANCK, CLIGHT, MUB, HPLNK, HPCL, EV2HZ,
     R AU_TO_CM2, HPLNK_BAR

      TYPE (PTE_TYPE), PUBLIC, SAVE :: PTE(111)

      CONTAINS

      SUBROUTINE ALLOC_CCONA

      EPS60     => RCONA(1)
      EPS30     => RCONA(2)
      EPS12     => RCONA(3)
      EPS10     => RCONA(4)
      EPS6      => RCONA(5)
      EPS5      => RCONA(6)
      PMASSA    => RCONA(7)
      PMASSE    => RCONA(8)
      AMUA      => RCONA(9)
      PIA       => RCONA(10)
      PI2A      => RCONA(11)
      PIHA      => RCONA(12)
      PISQ      => RCONA(13)
      PIAI      => RCONA(14)
      SQ2       => RCONA(15)
      SQ2I      => RCONA(16)
      DEGRAD    => RCONA(17)
      RADDEG    => RCONA(18)
      CVELI2    => RCONA(19)
      CVELAA    => RCONA(20)
      CVEL2A    => RCONA(21)
      ELCHA     => RCONA(22)
      EFACT     => RCONA(23)
      EFCT23    => RCONA(24)
      EVKEL     => RCONA(25)
      EIONH     => RCONA(26)
      EIONH2    => RCONA(27)
      EIONHE    => RCONA(28)
      EV_TO_J   => RCONA(29)
      J_TO_EV   => RCONA(30)
      J_TO_ERG  => RCONA(31)
      ERG_TO_J  => RCONA(32)
      EV_TO_ERG => RCONA(33)
      ERG_TO_EV => RCONA(34)
      HPLANCK   => RCONA(35)
      CLIGHT    => RCONA(36)
      MUB       => RCONA(37)
      PIQU      => RCONA(38)
      HPLNK     => RCONA(39)
      HPCL      => RCONA(40)
      EV2HZ     => RCONA(41)
      AU_TO_CM2 => RCONA(42)
      HPLNK_BAR => RCONA(43)

      RETURN
      END SUBROUTINE ALLOC_CCONA


      SUBROUTINE SET_PTE_ELEMENT (IEL,NAME,AB,EM,CH)

      INTEGER, INTENT(IN) :: IEL
      CHARACTER(*), INTENT(IN) :: NAME, AB
      REAL(DP), INTENT(IN) :: EM, CH

      PTE(IEL)%NAME = NAME
      PTE(IEL)%ABBR = AB
      PTE(IEL)%EL_MASS = EM
      PTE(IEL)%EL_CHARGE = CH

      RETURN
      END SUBROUTINE SET_PTE_ELEMENT



      FUNCTION FIND_ELEMENT(NAME) RESULT(IELEM)

      CHARACTER(2),INTENT(IN) :: NAME
      INTEGER :: IELEM, I

      IELEM = 0
      
      do i = 1,111
         if (pte(i)%abbr == name) then
           ielem = i
           return
         end if
      end do
      
      return
      END FUNCTION FIND_ELEMENT

      END MODULE CCONA
C ===== SOURCE: ccoupl.f
      MODULE CCOUPL

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CCOUPL, DEALLOC_CCOUPL, INIT_CCOUPL

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCCPL(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R FCTE(:), D(:),  FL(:), BMASS(:), XMCP_OLD(:),
     R CHGP,    CHGEE, CHGEI, CHGMOM

      REAL(DP), PUBLIC, SAVE ::
     R B2BREM,  B2RAD, B2QIE, B2VDP

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     I         ICCPL1(:,:), ICCPL2(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I  NDT(:,:),  NINCT(:,:), NIXY(:,:),
     I  NTIN(:,:), NTEN(:,:),  NIFLG(:,:),
     I  NPTC(:,:), NSPZI(:,:), NSPZE(:,:),
     I  NEMOD(:,:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I NTGPRT(:), IFLB(:), NAOTS(:), NAOTT(:),
     I NTARGI, NSTRI,  NFLA,   NCUTB,  NCUTL,  NDXA,   NDYA,
     I NCLMI,  NBLCKI, NPRNVI, NPRTVI, NPRDVI,
     I NMODEI, NFILNN, NCUTB_SAVE,
     I NAINB,  NAOTB

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NAINS(:), NAINT(:)

      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE :: LCCPL(:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LBALAN, LSYMET, LPRSOU,
     L LNLPLG, LNLDRF, LTRCFL, LNLVOL(:)

      INTEGER, PUBLIC, SAVE ::
     I NCOUPL, MCOUPL1, MCOUPL2, LCOUPL


      CONTAINS


      SUBROUTINE ALLOC_CCOUPL (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(RCCPL)) RETURN

        NCOUPL  = 4*NPLS+4+NSTRA
        MCOUPL1 = 10*NSTEP*NPTRGT
        MCOUPL2 = 1*NPLS+NSTEP+17+2*NLIMPS
        LCOUPL  = 6+NSTRA

        ALLOCATE (RCCPL(NCOUPL))
        ALLOCATE (ICCPL1(10*NSTEP,NPTRGT))
        ALLOCATE (ICCPL2(MCOUPL2))
        ALLOCATE (LCCPL(LCOUPL))

        WRITE (55,'(A,T25,I15)')
     .        ' CCOUPL ',NCOUPL*8 + (10*NSTEP*NPTRGT+MCOUPL2)*4
     .                   + LCOUPL*4

        FCTE     => RCCPL(1+0*NPLS : 1*NPLS)
        D        => RCCPL(1+1*NPLS : 2*NPLS)
        FL       => RCCPL(1+2*NPLS : 3*NPLS)
        BMASS    => RCCPL(1+3*NPLS : 4*NPLS)
        XMCP_OLD => RCCPL(1+4*NPLS : 4*NPLS+NSTRA)
        CHGP     => RCCPL(1+4*NPLS+NSTRA)
        CHGEE    => RCCPL(2+4*NPLS+NSTRA)
        CHGEI    => RCCPL(3+4*NPLS+NSTRA)
        CHGMOM   => RCCPL(4+4*NPLS+NSTRA)

        NDT    => ICCPL1(1+0*NSTEP : 1*NSTEP,:)
        NINCT  => ICCPL1(1+1*NSTEP : 2*NSTEP,:)
        NIXY   => ICCPL1(1+2*NSTEP : 3*NSTEP,:)
        NTIN   => ICCPL1(1+3*NSTEP : 4*NSTEP,:)
        NTEN   => ICCPL1(1+4*NSTEP : 5*NSTEP,:)
        NIFLG  => ICCPL1(1+5*NSTEP : 6*NSTEP,:)
        NPTC   => ICCPL1(1+6*NSTEP : 7*NSTEP,:)
        NSPZI  => ICCPL1(1+7*NSTEP : 8*NSTEP,:)
        NSPZE  => ICCPL1(1+8*NSTEP : 9*NSTEP,:)
        NEMOD  => ICCPL1(1+9*NSTEP :10*NSTEP,:)

        NTARGI     => ICCPL2( 1)
        NSTRI      => ICCPL2( 2)
        NFLA       => ICCPL2( 3)
        NCUTB      => ICCPL2( 4)
        NCUTL      => ICCPL2( 5)
        NDXA       => ICCPL2( 6)
        NDYA       => ICCPL2( 7)
        NCLMI      => ICCPL2( 8)
        NBLCKI     => ICCPL2( 9)
        NPRNVI     => ICCPL2(10)
        NPRTVI     => ICCPL2(11)
        NPRDVI     => ICCPL2(12)
        NMODEI     => ICCPL2(13)
        NFILNN     => ICCPL2(14)
        NCUTB_SAVE => ICCPL2(15)
        NAINB      => ICCPL2(16)
        NAOTB      => ICCPL2(17)
        NTGPRT     => ICCPL2(18 : 17+NSTEP)
        IFLB       => ICCPL2(18+NSTEP : 17+NSTEP+NPLS)
        NAOTS      => ICCPL2(18+NSTEP+NPLS :
     .                       17+NSTEP+NPLS+NLIMPS)
        NAOTT      => ICCPL2(18+NSTEP+NPLS+NLIMPS :
     .                       17+NSTEP+NPLS+2*NLIMPS)

        LBALAN => LCCPL(1)
        LSYMET => LCCPL(2)
        LPRSOU => LCCPL(3)
        LNLPLG => LCCPL(4)
        LNLDRF => LCCPL(5)
        LTRCFL => LCCPL(6)
        LNLVOL => LCCPL(7:6+NSTRA)

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(NAINS)) RETURN

        ALLOCATE (NAINS(NAIN))
        ALLOCATE (NAINT(NAIN))

      END IF

      CALL INIT_CCOUPL (ICAL)

      RETURN
      END SUBROUTINE ALLOC_CCOUPL


      SUBROUTINE DEALLOC_CCOUPL

      IF (.NOT.ALLOCATED(RCCPL)) RETURN

      DEALLOCATE (RCCPL)
      DEALLOCATE (ICCPL1)
      DEALLOCATE (ICCPL2)
      DEALLOCATE (LCCPL)

      RETURN
      END SUBROUTINE DEALLOC_CCOUPL


      SUBROUTINE INIT_CCOUPL(ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        RCCPL  = 0._DP
        B2BREM = 0._DP
        B2RAD  = 0._DP
        B2QIE  = 0._DP
        B2VDP  = 0._DP
        ICCPL1 = 0
        ICCPL2 = 0
        LCCPL  = .FALSE.

      ELSE IF (ICAL == 2) THEN

        NAINS = 0
        NAINT = 0

      END IF

      RETURN
      END SUBROUTINE INIT_CCOUPL

      END MODULE CCOUPL
C ===== SOURCE: cestim.f
c   march 19, 2006:  corrected pointer for spttot in "associate_cestim"

      MODULE CESTIM

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CESTIM, DEALLOC_CESTIM, ASSOCIATE_CESTIM,
     P          INIT_CESTIM

      TYPE(SPECT_ARRAY), PUBLIC, ALLOCATABLE, SAVE :: ESTIML(:)
      TYPE(SPECT_ARRAY), PUBLIC, ALLOCATABLE, SAVE :: SMESTL(:)

      INTEGER, PUBLIC, SAVE ::
     I NESTM1, NESTM2, NESTIM

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        ESTIMV(:,:), ESTIMS(:,:)

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R          CEMETERYV(:,:), CEMETERYS(:,:)

C  NESTM1, REAL, VOLUME AVERAGED TALLIES
      REAL(DP), PUBLIC, POINTER, SAVE ::
     R PDENA(:,:), PDENM(:,:), PDENI(:,:), PDENPH(:,:),
     R EDENA(:,:), EDENM(:,:), EDENI(:,:), EDENPH(:,:),
     R PAEL(:),    PAAT(:,:),  PAML(:,:),  PAIO(:,:),  PAPHT(:,:),
     R PAPL(:,:),
     R PMEL(:),    PMAT(:,:),  PMML(:,:),  PMIO(:,:),  PMPHT(:,:),
     R PMPL(:,:),
     R PIEL(:),    PIAT(:,:),  PIML(:,:),  PIIO(:,:),  PIPHT(:,:),
     R PIPL(:,:),
     R PPHEL(:),   PPHAT(:,:), PPHML(:,:), PPHIO(:,:), PPHPHT(:,:),
     R PPHPL(:,:),
     R EAEL(:),  EAAT(:),  EAML(:),  EAIO(:),  EAPHT(:),  EAPL(:),
     R EMEL(:),  EMAT(:),  EMML(:),  EMIO(:),  EMPHT(:),  EMPL(:),
     R EIEL(:),  EIAT(:),  EIML(:),  EIIO(:),  EIPHT(:),  EIPL(:),
     R EPHEL(:), EPHAT(:), EPHML(:), EPHIO(:), EPHPHT(:), EPHPL(:),
     R ADDV(:,:),  COLV(:,:),  SNAPV(:,:),
     R COPV(:,:),  BGKV(:,:),  ALGV(:,:),
     R PGENA(:,:), PGENM(:,:), PGENI(:,:), PGENPH(:,:),
     R EGENA(:,:), EGENM(:,:), EGENI(:,:), EGENPH(:,:),
     R VGENA(:,:), VGENM(:,:), VGENI(:,:), VGENPH(:,:),
     R PPAT(:,:),  PPML(:,:),  PPIO(:,:),  PPPHT(:,:), PPPL(:,:),
     R EPAT(:),    EPML(:),    EPIO(:),    EPPHT(:),   EPPL(:),
     R VXDENA(:,:), VXDENM(:,:), VXDENI(:,:), VXDENPH(:,:), 
     R VYDENA(:,:), VYDENM(:,:), VYDENI(:,:), VYDENPH(:,:), 
     R VZDENA(:,:), VZDENM(:,:), VZDENI(:,:), VZDENPH(:,:),
     R MAPL(:,:), MMPL(:,:), MIPL(:,:), MPHPL(:,:)

C  NESTM2, REAL, SURFACE AVERAGED TALLIES
      REAL(DP), PUBLIC, POINTER, SAVE ::
     R POTAT(:,:),
     R PRFAAT(:,:), PRFMAT(:,:), PRFIAT(:,:), PRFPHAT(:,:),
     R PRFPAT(:,:),
C
     R POTML(:,:),
     R PRFAML(:,:), PRFMML(:,:), PRFIML(:,:), PRFPHML(:,:),
     R PRFPML(:,:),
C
     R POTIO(:,:),
     R PRFAIO(:,:), PRFMIO(:,:), PRFIIO(:,:), PRFPHIO(:,:),
     R PRFPIO(:,:),
C
     R POTPHT(:,:),
     R PRFAPHT(:,:), PRFMPHT(:,:), PRFIPHT(:,:), PRFPHPHT(:,:),
     R PRFPPHT(:,:),
C
     R POTPL(:,:)
C
      REAL(DP), PUBLIC, POINTER, SAVE ::
     R EOTAT(:,:),
     R ERFAAT(:,:), ERFMAT(:,:), ERFIAT(:,:), ERFPHAT(:,:),
     R ERFPAT(:,:),
C
     R EOTML(:,:),
     R ERFAML(:,:), ERFMML(:,:), ERFIML(:,:), ERFPHML(:,:),
     R ERFPML(:,:),
C
     R EOTIO(:,:),
     R ERFAIO(:,:), ERFMIO(:,:), ERFIIO(:,:), ERFPHIO(:,:),
     R ERFPIO(:,:),
C
     R EOTPHT(:,:),
     R ERFAPHT(:,:), ERFMPHT(:,:), ERFIPHT(:,:), ERFPHPHT(:,:),
     R ERFPPHT(:,:),
C
     R EOTPL(:,:),
C
     R SPTAT(:,:), SPTML(:,:),
     R SPTIO(:,:), SPTPHT(:,:), SPTPL(:,:),
     R SPTTOT(:),
     R ADDS(:,:),  ALGS(:,:),
     R SPUMP(:,:)

C  FROM HERE: NO EQUIVALENCE
      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NFIRST(:), NADDV(:),
     I IRESC1(:), IRESC2(:),
     I NFRSTW(:), NADDW(:)

      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     L LIVTALV(:), LIVTALS(:)
      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     L LMISTALV(:), LMISTALS(:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LPDENA, LPDENM, LPDENI, LPDENPH,
     L LEDENA, LEDENM, LEDENI, LEDENPH,
     L LPAEL,  LPAAT,  LPAML,  LPAIO,   LPAPHT,  LPAPL,
     L LPMEL,  LPMAT,  LPMML,  LPMIO,   LPMPHT,  LPMPL,
     L LPIEL,  LPIAT,  LPIML,  LPIIO,   LPIPHT,  LPIPL,
     L LPPHEL, LPPHAT, LPPHML, LPPHIO,  LPPHPHT, LPPHPL,
     L LEAEL,  LEAAT,  LEAML,  LEAIO,   LEAPHT,  LEAPL,
     L LEMEL,  LEMAT,  LEMML,  LEMIO,   LEMPHT,  LEMPL,
     L LEIEL,  LEIAT,  LEIML,  LEIIO,   LEIPHT,  LEIPL,
     L LEPHEL, LEPHAT, LEPHML, LEPHIO,  LEPHPHT, LEPHPL,
     L LADDV,  LCOLV,  LSNAPV,
     L LCOPV,  LBGKV,  LALGV,
     L LPGENA, LPGENM, LPGENI, LPGENPH,
     L LEGENA, LEGENM, LEGENI, LEGENPH,
     L LVGENA, LVGENM, LVGENI, LVGENPH,
     L LPPAT,  LPPML,  LPPIO,  LPPPHT,  LPPPL,
     L LEPAT,  LEPML,  LEPIO,  LEPPHT,  LEPPL,
     L LVXDENA, LVXDENM, LVXDENI, LVXDENPH,
     L LVYDENA, LVYDENM, LVYDENI, LVYDENPH,
     L LVZDENA, LVZDENM, LVZDENI, LVZDENPH,
     L LMAPL,  LMMPL,  LMIPL,  LMPHPL

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LMSPDENA, LMSPDENM, LMSPDENI, LMSPDENPH,
     L LMSEDENA, LMSEDENM, LMSEDENI, LMSEDENPH,
     L LMSPAEL,  LMSPAAT,  LMSPAML,  LMSPAIO,   LMSPAPHT,  LMSPAPL,
     L LMSPMEL,  LMSPMAT,  LMSPMML,  LMSPMIO,   LMSPMPHT,  LMSPMPL,
     L LMSPIEL,  LMSPIAT,  LMSPIML,  LMSPIIO,   LMSPIPHT,  LMSPIPL,
     L LMSPPHEL, LMSPPHAT, LMSPPHML, LMSPPHIO,  LMSPPHPHT, LMSPPHPL,
     L LMSEAEL,  LMSEAAT,  LMSEAML,  LMSEAIO,   LMSEAPHT,  LMSEAPL,
     L LMSEMEL,  LMSEMAT,  LMSEMML,  LMSEMIO,   LMSEMPHT,  LMSEMPL,
     L LMSEIEL,  LMSEIAT,  LMSEIML,  LMSEIIO,   LMSEIPHT,  LMSEIPL,
     L LMSEPHEL, LMSEPHAT, LMSEPHML, LMSEPHIO,  LMSEPHPHT, LMSEPHPL,
     L LMSADDV,  LMSCOLV,  LMSSNAPV,
     L LMSCOPV,  LMSBGKV,  LMSALGV,
     L LMSPGENA, LMSPGENM, LMSPGENI, LMSPGENPH,
     L LMSEGENA, LMSEGENM, LMSEGENI, LMSEGENPH,
     L LMSVGENA, LMSVGENM, LMSVGENI, LMSVGENPH,
     L LMSPPAT,  LMSPPML,  LMSPPIO,  LMSPPPHT,  LMSPPPL,
     L LMSEPAT,  LMSEPML,  LMSEPIO,  LMSEPPHT,  LMSEPPL,
     L LMSVXDENA, LMSVXDENM, LMSVXDENI, LMSVXDENPH,
     L LMSVYDENA, LMSVYDENM, LMSVYDENI, LMSVYDENPH,
     L LMSVZDENA, LMSVZDENM, LMSVZDENI, LMSVZDENPH,
     L LMSMAPL,  LMSMMPL,  LMSMIPL,  LMSMPHPL

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LPOTAT,
     L LPRFAAT, LPRFMAT, LPRFIAT, LPRFPHAT,
     L LPRFPAT,
C
     L LPOTML,
     L LPRFAML, LPRFMML, LPRFIML, LPRFPHML,
     L LPRFPML,
C
     L LPOTIO,
     L LPRFAIO, LPRFMIO, LPRFIIO, LPRFPHIO,
     L LPRFPIO,
C
     L LPOTPHT,
     L LPRFAPHT, LPRFMPHT, LPRFIPHT, LPRFPHPHT,
     L LPRFPPHT,
C
     L LPOTPL

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LMSPOTAT,
     L LMSPRFAAT, LMSPRFMAT, LMSPRFIAT, LMSPRFPHAT,
     L LMSPRFPAT,
C
     L LMSPOTML,
     L LMSPRFAML, LMSPRFMML, LMSPRFIML, LMSPRFPHML,
     L LMSPRFPML,
C
     L LMSPOTIO,
     L LMSPRFAIO, LMSPRFMIO, LMSPRFIIO, LMSPRFPHIO,
     L LMSPRFPIO,
C
     L LMSPOTPHT,
     L LMSPRFAPHT, LMSPRFMPHT, LMSPRFIPHT, LMSPRFPHPHT,
     L LMSPRFPPHT,
C
     L LMSPOTPL
C
      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LEOTAT,
     L LERFAAT, LERFMAT, LERFIAT, LERFPHAT, LERFPAT,
C
     L LEOTML,
     L LERFAML, LERFMML, LERFIML, LERFPHML, LERFPML,
C
     L LEOTIO,
     L LERFAIO, LERFMIO, LERFIIO, LERFPHIO, LERFPIO,
C
     L LEOTPHT,
     L LERFAPHT, LERFMPHT, LERFIPHT, LERFPHPHT, LERFPPHT,
C
     L LEOTPL,
C
     L LSPTAT, LSPTML, LSPTIO, LSPTPHT, LSPTPL,
     L LSPTTOT,
     L LADDS,  LALGS,
     L LSPUMP
C
      LOGICAL, PUBLIC, POINTER, SAVE ::
     L LMSEOTAT,
     L LMSERFAAT, LMSERFMAT, LMSERFIAT, LMSERFPHAT, LMSERFPAT,
C
     L LMSEOTML,
     L LMSERFAML, LMSERFMML, LMSERFIML, LMSERFPHML, LMSERFPML,
C
     L LMSEOTIO,
     L LMSERFAIO, LMSERFMIO, LMSERFIIO, LMSERFPHIO, LMSERFPIO,
C
     L LMSEOTPHT,
     L LMSERFAPHT, LMSERFMPHT, LMSERFIPHT, LMSERFPHPHT, LMSERFPPHT,
C
     L LMSEOTPL,
C
     L LMSSPTAT, LMSSPTML, LMSSPTIO, LMSSPTPHT, LMSSPTPL,
     L LMSSPTTOT,
     L LMSADDS,  LMSALGS,
     L LMSSPUMP

      LOGICAL, PUBLIC, SAVE :: LEA, LEM, LEIO, LEPH
C

      CONTAINS


      SUBROUTINE ALLOC_CESTIM(ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(LIVTALV)) RETURN

        ALLOCATE (LIVTALV(NTALV))
        ALLOCATE (LIVTALS(NTALS))
        ALLOCATE (LMISTALV(NTALV))
        ALLOCATE (LMISTALS(NTALS))

        ALLOCATE (NFIRST(NTALV))
        ALLOCATE (NADDV(NTALV))
        ALLOCATE (IRESC1(NTALV))
        ALLOCATE (IRESC2(NTALV))
        ALLOCATE (NFRSTW(NTALS))
        ALLOCATE (NADDW(NTALS))

        WRITE (55,'(A,T25,I15)')
     .      ' CESTIM ',4*(NTALV+NTALS) + (4*NTALV+2*NTALS)*4

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(ESTIMV)) RETURN

        NESTM1=NVOLTL*NRTAL
        NESTM2=NSRFTL*NLMPGS
        NESTIM=NESTM1+NESTM2

        ALLOCATE (ESTIMV(NVOLTL,NRTAL))
        ALLOCATE (ESTIMS(NSRFTL,NLMPGS))

        ALLOCATE (CEMETERYV(0:0,NRTAL))
        ALLOCATE (CEMETERYS(0:0,NLMPGS))

        WRITE (55,'(A,T25,I15)')
     .      ' CESTIM ',(NESTIM+NRTAL+NLMPGS)*8

      END IF

      CALL INIT_CESTIM(ICAL)

      RETURN
      END SUBROUTINE ALLOC_CESTIM


      SUBROUTINE ASSOCIATE_CESTIM

C  VOLUME AVERAGED TALLIES


      IF (LPDENA) THEN
        PDENA => ESTIMV(NADDV(1)+1:NADDV(2),:)
      ELSE
        PDENA => CEMETERYV(0:0,:)
      END IF
      IF (LPDENM) THEN
        PDENM => ESTIMV(NADDV(2)+1:NADDV(3),:)
      ELSE
        PDENM => CEMETERYV(0:0,:)
      END IF
      IF (LPDENI) THEN
        PDENI => ESTIMV(NADDV(3)+1:NADDV(4),:)
      ELSE
        PDENI => CEMETERYV(0:0,:)
      END IF
      IF (LPDENPH) THEN
        PDENPH => ESTIMV(NADDV(4)+1:NADDV(5),:)
      ELSE
        PDENPH => CEMETERYV(0:0,:)
      END IF

      IF (LEDENA) THEN
        EDENA => ESTIMV(NADDV(5)+1:NADDV(6),:)
      ELSE
        EDENA => CEMETERYV(0:0,:)
      END IF
      IF (LEDENM) THEN
        EDENM => ESTIMV(NADDV(6)+1:NADDV(7),:)
      ELSE
        EDENM => CEMETERYV(0:0,:)
      END IF
      IF (LEDENI) THEN
        EDENI => ESTIMV(NADDV(7)+1:NADDV(8),:)
      ELSE
        EDENI => CEMETERYV(0:0,:)
      END IF
      IF (LEDENPH) THEN
        EDENPH => ESTIMV(NADDV(8)+1:NADDV(9),:)
      ELSE
        EDENPH => CEMETERYV(0:0,:)
      END IF

      IF (LPAEL) THEN
        PAEL => ESTIMV(NADDV(10),:)
      ELSE
        PAEL => CEMETERYV(0,:)
      END IF
      IF (LPAAT) THEN
        PAAT => ESTIMV(NADDV(10)+1:NADDV(11),:)
      ELSE
        PAAT => CEMETERYV(0:0,:)
      END IF
      IF (LPAML) THEN
        PAML => ESTIMV(NADDV(11)+1:NADDV(12),:)
      ELSE
        PAML => CEMETERYV(0:0,:)
      END IF
      IF (LPAIO) THEN
        PAIO => ESTIMV(NADDV(12)+1:NADDV(13),:)
      ELSE
        PAIO => CEMETERYV(0:0,:)
      END IF
      IF (LPAPHT) THEN
        PAPHT => ESTIMV(NADDV(13)+1:NADDV(14),:)
      ELSE
        PAPHT => CEMETERYV(0:0,:)
      END IF
      IF (LPAPL) THEN
        PAPL => ESTIMV(NADDV(14)+1:NADDV(15),:)
      ELSE
        PAPL => CEMETERYV(0:0,:)
      END IF

      IF (LPMEL) THEN
        PMEL => ESTIMV(NADDV(16),:)
      ELSE
        PMEL => CEMETERYV(0,:)
      END IF
      IF (LPMAT) THEN
        PMAT => ESTIMV(NADDV(16)+1:NADDV(17),:)
      ELSE
        PMAT => CEMETERYV(0:0,:)
      END IF
      IF (LPMML) THEN
        PMML => ESTIMV(NADDV(17)+1:NADDV(18),:)
      ELSE
        PMML => CEMETERYV(0:0,:)
      END IF
      IF (LPMIO) THEN
        PMIO => ESTIMV(NADDV(18)+1:NADDV(19),:)
      ELSE
        PMIO => CEMETERYV(0:0,:)
      END IF
      IF (LPMPHT) THEN
        PMPHT => ESTIMV(NADDV(19)+1:NADDV(20),:)
      ELSE
        PMPHT => CEMETERYV(0:0,:)
      END IF
      IF (LPMPL) THEN
        PMPL => ESTIMV(NADDV(20)+1:NADDV(21),:)
      ELSE
        PMPL => CEMETERYV(0:0,:)
      END IF

      IF (LPIEL) THEN
        PIEL => ESTIMV(NADDV(22),:)
      ELSE
        PIEL => CEMETERYV(0,:)
      END IF
      IF (LPIAT) THEN
        PIAT => ESTIMV(NADDV(22)+1:NADDV(23),:)
      ELSE
        PIAT => CEMETERYV(0:0,:)
      END IF
      IF (LPIML) THEN
        PIML => ESTIMV(NADDV(23)+1:NADDV(24),:)
      ELSE
        PIML => CEMETERYV(0:0,:)
      END IF
      IF (LPIIO) THEN
        PIIO => ESTIMV(NADDV(24)+1:NADDV(25),:)
      ELSE
        PIIO => CEMETERYV(0:0,:)
      END IF
      IF (LPIPHT) THEN
        PIPHT => ESTIMV(NADDV(25)+1:NADDV(26),:)
      ELSE
        PIPHT => CEMETERYV(0:0,:)
      END IF
      IF (LPIPL) THEN
        PIPL => ESTIMV(NADDV(26)+1:NADDV(27),:)
      ELSE
        PIPL => CEMETERYV(0:0,:)
      END IF

      IF (LPPHEL) THEN
        PPHEL => ESTIMV(NADDV(28),:)
      ELSE
        PPHEL => CEMETERYV(0,:)
      END IF
      IF (LPPHAT) THEN
        PPHAT => ESTIMV(NADDV(28)+1:NADDV(29),:)
      ELSE
        PPHAT => CEMETERYV(0:0,:)
      END IF
      IF (LPPHML) THEN
        PPHML => ESTIMV(NADDV(29)+1:NADDV(30),:)
      ELSE
        PPHML => CEMETERYV(0:0,:)
      END IF
      IF (LPPHIO) THEN
        PPHIO => ESTIMV(NADDV(30)+1:NADDV(31),:)
      ELSE
        PPHIO => CEMETERYV(0:0,:)
      END IF
      IF (LPPHPHT) THEN
        PPHPHT => ESTIMV(NADDV(31)+1:NADDV(32),:)
      ELSE
        PPHPHT => CEMETERYV(0:0,:)
      END IF
      IF (LPPHPL) THEN
        PPHPL => ESTIMV(NADDV(32)+1:NADDV(33),:)
      ELSE
        PPHPL => CEMETERYV(0:0,:)
      END IF

      IF (LEAEL) THEN
        EAEL => ESTIMV(NADDV(34),:)
      ELSE
        EAEL => CEMETERYV(0,:)
      END IF
      IF (LEAAT) THEN
        EAAT => ESTIMV(NADDV(35),:)
      ELSE
        EAAT => CEMETERYV(0,:)
      END IF
      IF (LEAML) THEN
        EAML => ESTIMV(NADDV(36),:)
      ELSE
        EAML => CEMETERYV(0,:)
      END IF
      IF (LEAIO) THEN
        EAIO => ESTIMV(NADDV(37),:)
      ELSE
        EAIO => CEMETERYV(0,:)
      END IF
      IF (LEAPHT) THEN
        EAPHT => ESTIMV(NADDV(38),:)
      ELSE
        EAPHT => CEMETERYV(0,:)
      END IF
      IF (LEAPL) THEN
        EAPL => ESTIMV(NADDV(39),:)
      ELSE
        EAPL => CEMETERYV(0,:)
      END IF

      IF (LEMEL) THEN
        EMEL => ESTIMV(NADDV(40),:)
      ELSE
        EMEL => CEMETERYV(0,:)
      END IF
      IF (LEMAT) THEN
        EMAT => ESTIMV(NADDV(41),:)
      ELSE
        EMAT => CEMETERYV(0,:)
      END IF
      IF (LEMML) THEN
        EMML => ESTIMV(NADDV(42),:)
      ELSE
        EMML => CEMETERYV(0,:)
      END IF
      IF (LEMIO) THEN
        EMIO => ESTIMV(NADDV(43),:)
      ELSE
        EMIO => CEMETERYV(0,:)
      END IF
      IF (LEMPHT) THEN
        EMPHT => ESTIMV(NADDV(44),:)
      ELSE
        EMPHT => CEMETERYV(0,:)
      END IF
      IF (LEMPL) THEN
        EMPL => ESTIMV(NADDV(45),:)
      ELSE
        EMPL => CEMETERYV(0,:)
      END IF

      IF (LEIEL) THEN
        EIEL => ESTIMV(NADDV(46),:)
      ELSE
        EIEL => CEMETERYV(0,:)
      END IF
      IF (LEIAT) THEN
        EIAT => ESTIMV(NADDV(47),:)
      ELSE
        EIAT => CEMETERYV(0,:)
      END IF
      IF (LEIML) THEN
        EIML => ESTIMV(NADDV(48),:)
      ELSE
        EIML => CEMETERYV(0,:)
      END IF
      IF (LEIIO) THEN
        EIIO => ESTIMV(NADDV(49),:)
      ELSE
        EIIO => CEMETERYV(0,:)
      END IF
      IF (LEIPHT) THEN
        EIPHT => ESTIMV(NADDV(50),:)
      ELSE
        EIPHT => CEMETERYV(0,:)
      END IF
      IF (LEIPL) THEN
        EIPL => ESTIMV(NADDV(51),:)
      ELSE
        EIPL => CEMETERYV(0,:)
      END IF

      IF (LEPHEL) THEN
        EPHEL => ESTIMV(NADDV(52),:)
      ELSE
        EPHEL => CEMETERYV(0,:)
      END IF
      IF (LEPHAT) THEN
        EPHAT => ESTIMV(NADDV(53),:)
      ELSE
        EPHAT => CEMETERYV(0,:)
      END IF
      IF (LEPHML) THEN
        EPHML => ESTIMV(NADDV(54),:)
      ELSE
        EPHML => CEMETERYV(0,:)
      END IF
      IF (LEPHIO) THEN
        EPHIO => ESTIMV(NADDV(55),:)
      ELSE
        EPHIO => CEMETERYV(0,:)
      END IF
      IF (LEPHPHT) THEN
        EPHPHT => ESTIMV(NADDV(56),:)
      ELSE
        EPHPHT => CEMETERYV(0,:)
      END IF
      IF (LEPHPL) THEN
        EPHPL => ESTIMV(NADDV(57),:)
      ELSE
        EPHPL => CEMETERYV(0,:)
      END IF

      IF (LADDV) THEN
        ADDV => ESTIMV(NADDV(NTALA)+1:NADDV(NTALA+1),:)
      ELSE
        ADDV => CEMETERYV(0:0,:)
      END IF
      IF (LCOLV) THEN
        COLV => ESTIMV(NADDV(NTALC)+1:NADDV(NTALC+1),:)
      ELSE
        COLV => CEMETERYV(0:0,:)
      END IF
      IF (LSNAPV) THEN
        SNAPV => ESTIMV(NADDV(NTALT)+1:NADDV(NTALT+1),:)
      ELSE
        SNAPV => CEMETERYV(0:0,:)
      END IF
      IF (LCOPV) THEN
        COPV => ESTIMV(NADDV(NTALM)+1:NADDV(NTALM+1),:)
      ELSE
        COPV => CEMETERYV(0:0,:)
      END IF
      IF (LBGKV) THEN
        BGKV => ESTIMV(NADDV(NTALB)+1:NADDV(NTALB+1),:)
      ELSE
        BGKV => CEMETERYV(0:0,:)
      END IF
      IF (LALGV) THEN
        ALGV => ESTIMV(NADDV(NTALR)+1:NADDV(NTALR+1),:)
      ELSE
        ALGV => CEMETERYV(0:0,:)
      END IF

      IF (LPGENA) THEN
        PGENA => ESTIMV(NADDV(63)+1:NADDV(64),:)
      ELSE
        PGENA => CEMETERYV(0:0,:)
      END IF
      IF (LPGENM) THEN
        PGENM => ESTIMV(NADDV(64)+1:NADDV(65),:)
      ELSE
        PGENM => CEMETERYV(0:0,:)
      END IF
      IF (LPGENI) THEN
        PGENI => ESTIMV(NADDV(65)+1:NADDV(66),:)
      ELSE
        PGENI => CEMETERYV(0:0,:)
      END IF
      IF (LPGENPH) THEN
        PGENPH => ESTIMV(NADDV(66)+1:NADDV(67),:)
      ELSE
        PGENPH => CEMETERYV(0:0,:)
      END IF
      IF (LEGENA) THEN
        EGENA => ESTIMV(NADDV(67)+1:NADDV(68),:)
      ELSE
        EGENA => CEMETERYV(0:0,:)
      END IF
      IF (LEGENM) THEN
        EGENM => ESTIMV(NADDV(68)+1:NADDV(69),:)
      ELSE
        EGENM => CEMETERYV(0:0,:)
      END IF
      IF (LEGENI) THEN
        EGENI => ESTIMV(NADDV(69)+1:NADDV(70),:)
      ELSE
        EGENI => CEMETERYV(0:0,:)
      END IF
      IF (LEGENPH) THEN
        EGENPH => ESTIMV(NADDV(70)+1:NADDV(71),:)
      ELSE
        EGENPH => CEMETERYV(0:0,:)
      END IF
      IF (LVGENA) THEN
        VGENA => ESTIMV(NADDV(71)+1:NADDV(72),:)
      ELSE
        VGENA => CEMETERYV(0:0,:)
      END IF
      IF (LVGENM) THEN
        VGENM => ESTIMV(NADDV(72)+1:NADDV(73),:)
      ELSE
        VGENM => CEMETERYV(0:0,:)
      END IF
      IF (LVGENI) THEN
        VGENI => ESTIMV(NADDV(73)+1:NADDV(74),:)
      ELSE
        VGENI => CEMETERYV(0:0,:)
      END IF
      IF (LVGENPH) THEN
        VGENPH => ESTIMV(NADDV(74)+1:NADDV(75),:)
      ELSE
        VGENPH => CEMETERYV(0:0,:)
      END IF

      IF (LPPAT) THEN
        PPAT => ESTIMV(NADDV(75)+1:NADDV(76),:)
      ELSE
        PPAT => CEMETERYV(0:0,:)
      END IF
      IF (LPPML) THEN
        PPML => ESTIMV(NADDV(76)+1:NADDV(77),:)
      ELSE
        PPML => CEMETERYV(0:0,:)
      END IF
      IF (LPPIO) THEN
        PPIO => ESTIMV(NADDV(77)+1:NADDV(78),:)
      ELSE
        PPIO => CEMETERYV(0:0,:)
      END IF
      IF (LPPPHT) THEN
        PPPHT => ESTIMV(NADDV(78)+1:NADDV(79),:)
      ELSE
        PPPHT => CEMETERYV(0:0,:)
      END IF
      IF (LPPPL) THEN
        PPPL => ESTIMV(NADDV(79)+1:NADDV(80),:)
      ELSE
        PPPL => CEMETERYV(0:0,:)
      END IF

      IF (LEPAT) THEN
        EPAT => ESTIMV(NADDV(81),:)
      ELSE
        EPAT => CEMETERYV(0,:)
      END IF
      IF (LEPML) THEN
        EPML => ESTIMV(NADDV(82),:)
      ELSE
        EPML => CEMETERYV(0,:)
      END IF
      IF (LEPIO) THEN
        EPIO => ESTIMV(NADDV(83),:)
      ELSE
        EPIO => CEMETERYV(0,:)
      END IF
      IF (LEPPHT) THEN
        EPPHT => ESTIMV(NADDV(84),:)
      ELSE
        EPPHT => CEMETERYV(0,:)
      END IF
      IF (LEPPL) THEN
        EPPL => ESTIMV(NADDV(85) ,:)
      ELSE
        EPPL => CEMETERYV(0,:)
      END IF
      IF (LVXDENA) THEN
        VXDENA => ESTIMV(NADDV(85)+1:NADDV(86),:)
      ELSE
        VXDENA => CEMETERYV(0:0,:)
      END IF
      IF (LVXDENM) THEN
        VXDENM => ESTIMV(NADDV(86)+1:NADDV(87),:)
      ELSE
        VXDENM => CEMETERYV(0:0,:)
      END IF
      IF (LVXDENI) THEN
        VXDENI => ESTIMV(NADDV(87)+1:NADDV(88),:)
      ELSE
        VXDENI => CEMETERYV(0:0,:)
      END IF
      IF (LVXDENPH) THEN
        VXDENPH => ESTIMV(NADDV(88)+1:NADDV(89),:)
      ELSE
        VXDENPH => CEMETERYV(0:0,:)
      END IF
      IF (LVYDENA) THEN
        VYDENA => ESTIMV(NADDV(89)+1:NADDV(90),:)
      ELSE
        VYDENA => CEMETERYV(0:0,:)
      END IF
      IF (LVYDENM) THEN
        VYDENM => ESTIMV(NADDV(90)+1:NADDV(91),:)
      ELSE
        VYDENM => CEMETERYV(0:0,:)
      END IF
      IF (LVYDENI) THEN
        VYDENI => ESTIMV(NADDV(91)+1:NADDV(92),:)
      ELSE
        VYDENI => CEMETERYV(0:0,:)
      END IF
      IF (LVYDENPH) THEN
        VYDENPH => ESTIMV(NADDV(92)+1:NADDV(93),:)
      ELSE
        VYDENPH => CEMETERYV(0:0,:)
      END IF
      IF (LVZDENA) THEN
        VZDENA => ESTIMV(NADDV(93)+1:NADDV(94),:)
      ELSE
        VZDENA => CEMETERYV(0:0,:)
      END IF
      IF (LVZDENM) THEN
        VZDENM => ESTIMV(NADDV(94)+1:NADDV(95),:)
      ELSE
        VZDENM => CEMETERYV(0:0,:)
      END IF
      IF (LVZDENI) THEN
        VZDENI => ESTIMV(NADDV(95)+1:NADDV(96),:)
      ELSE
        VZDENI => CEMETERYV(0:0,:)
      END IF
      IF (LVZDENPH) THEN
        VZDENPH => ESTIMV(NADDV(96)+1:NADDV(97),:)
      ELSE
        VZDENPH => CEMETERYV(0:0,:)
      END IF
      IF (LMAPL) THEN
        MAPL => ESTIMV(NADDV(97)+1:NADDV(98),:)
      ELSE
        MAPL => CEMETERYV(0:0,:)
      END IF
      IF (LMMPL) THEN
        MMPL => ESTIMV(NADDV(98)+1:NADDV(99),:)
      ELSE
        MMPL => CEMETERYV(0:0,:)
      END IF
      IF (LMIPL) THEN
        MIPL => ESTIMV(NADDV(99)+1:NADDV(100),:)
      ELSE
        MIPL => CEMETERYV(0:0,:)
      END IF
      IF (LMPHPL) THEN
        MPHPL => ESTIMV(NADDV(100)+1: ,:)
      ELSE
        MPHPL => CEMETERYV(0:0,:)
      END IF


C  SURFACE AVERAGED TALLIES


      IF (LPOTAT) THEN
        POTAT => ESTIMS(1:NADDW(2),:)
      ELSE
        POTAT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFAAT) THEN
        PRFAAT => ESTIMS(NADDW(2)+1:NADDW(3),:)
      ELSE
        PRFAAT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFMAT) THEN
        PRFMAT => ESTIMS(NADDW(3)+1:NADDW(4),:)
      ELSE
        PRFMAT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFIAT) THEN
        PRFIAT => ESTIMS(NADDW(4)+1:NADDW(5),:)
      ELSE
        PRFIAT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPHAT) THEN
        PRFPHAT => ESTIMS(NADDW(5)+1:NADDW(6),:)
      ELSE
        PRFPHAT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPAT) THEN
        PRFPAT => ESTIMS(NADDW(6)+1:NADDW(7),:)
      ELSE
        PRFPAT => CEMETERYS(0:0,:)
      END IF
C
      IF (LPOTML) THEN
        POTML => ESTIMS(NADDW(7)+1:NADDW(8),:)
      ELSE
        POTML => CEMETERYS(0:0,:)
      END IF
      IF (LPRFAML) THEN
        PRFAML => ESTIMS(NADDW(8)+1:NADDW(9),:)
      ELSE
        PRFAML => CEMETERYS(0:0,:)
      END IF
      IF (LPRFMML) THEN
        PRFMML => ESTIMS(NADDW(9)+1:NADDW(10),:)
      ELSE
        PRFMML => CEMETERYS(0:0,:)
      END IF
      IF (LPRFIML) THEN
        PRFIML => ESTIMS(NADDW(10)+1:NADDW(11),:)
      ELSE
        PRFIML => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPHML) THEN
        PRFPHML => ESTIMS(NADDW(11)+1:NADDW(12),:)
      ELSE
        PRFPHML => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPML) THEN
        PRFPML => ESTIMS(NADDW(12)+1:NADDW(13),:)
      ELSE
        PRFPML => CEMETERYS(0:0,:)
      END IF
C
      IF (LPOTIO) THEN
        POTIO => ESTIMS(NADDW(13)+1:NADDW(14),:)
      ELSE
        POTIO => CEMETERYS(0:0,:)
      END IF
      IF (LPRFAIO) THEN
        PRFAIO => ESTIMS(NADDW(14)+1:NADDW(15),:)
      ELSE
        PRFAIO => CEMETERYS(0:0,:)
      END IF
      IF (LPRFMIO) THEN
        PRFMIO => ESTIMS(NADDW(15)+1:NADDW(16),:)
      ELSE
        PRFMIO => CEMETERYS(0:0,:)
      END IF
      IF (LPRFIIO) THEN
        PRFIIO => ESTIMS(NADDW(16)+1:NADDW(17),:)
      ELSE
        PRFIIO => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPHIO) THEN
        PRFPHIO => ESTIMS(NADDW(17)+1:NADDW(18),:)
      ELSE
        PRFPHIO => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPIO) THEN
        PRFPIO => ESTIMS(NADDW(18)+1:NADDW(19),:)
      ELSE
        PRFPIO => CEMETERYS(0:0,:)
      END IF
C
      IF (LPOTPHT) THEN
        POTPHT => ESTIMS(NADDW(19)+1:NADDW(20),:)
      ELSE
        POTPHT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFAPHT) THEN
        PRFAPHT => ESTIMS(NADDW(20)+1:NADDW(21),:)
      ELSE
        PRFAPHT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFMPHT) THEN
        PRFMPHT => ESTIMS(NADDW(21)+1:NADDW(22),:)
      ELSE
        PRFMPHT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFIPHT) THEN
        PRFIPHT => ESTIMS(NADDW(22)+1:NADDW(23),:)
      ELSE
        PRFIPHT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPHPHT) THEN
        PRFPHPHT =>ESTIMS(NADDW(23)+1:NADDW(24),:)
      ELSE
        PRFPHPHT => CEMETERYS(0:0,:)
      END IF
      IF (LPRFPPHT) THEN
        PRFPPHT => ESTIMS(NADDW(24)+1:NADDW(25),:)
      ELSE
        PRFPPHT => CEMETERYS(0:0,:)
      END IF
C
      IF (LPOTPL) THEN
        POTPL => ESTIMS(NADDW(25)+1:NADDW(26),:)
      ELSE
        POTPL => CEMETERYS(0:0,:)
      END IF
C
      IF (LEOTAT) THEN
        EOTAT => ESTIMS(NADDW(26)+1:NADDW(27),:)
      ELSE
        EOTAT => CEMETERYS(0:0,:)
      END IF
      IF (LERFAAT) THEN
        ERFAAT => ESTIMS(NADDW(27)+1:NADDW(28),:)
      ELSE
        ERFAAT => CEMETERYS(0:0,:)
      END IF
      IF (LERFMAT) THEN
        ERFMAT => ESTIMS(NADDW(28)+1:NADDW(29),:)
      ELSE
        ERFMAT => CEMETERYS(0:0,:)
      END IF
      IF (LERFIAT) THEN
        ERFIAT => ESTIMS(NADDW(29)+1:NADDW(30),:)
      ELSE
        ERFIAT => CEMETERYS(0:0,:)
      END IF
      IF (LERFPHAT) THEN
        ERFPHAT => ESTIMS(NADDW(30)+1:NADDW(31),:)
      ELSE
        ERFPHAT => CEMETERYS(0:0,:)
      END IF
      IF (LERFPAT) THEN
        ERFPAT => ESTIMS(NADDW(31)+1:NADDW(32),:)
      ELSE
        ERFPAT => CEMETERYS(0:0,:)
      END IF
C
      IF (LEOTML) THEN
        EOTML => ESTIMS(NADDW(32)+1:NADDW(33),:)
      ELSE
        EOTML => CEMETERYS(0:0,:)
      END IF
      IF (LERFAML) THEN
        ERFAML => ESTIMS(NADDW(33)+1:NADDW(34),:)
      ELSE
        ERFAML => CEMETERYS(0:0,:)
      END IF
      IF (LERFMML) THEN
        ERFMML => ESTIMS(NADDW(34)+1:NADDW(35),:)
      ELSE
        ERFMML => CEMETERYS(0:0,:)
      END IF
      IF (LERFIML) THEN
        ERFIML => ESTIMS(NADDW(35)+1:NADDW(36),:)
      ELSE
        ERFIML => CEMETERYS(0:0,:)
      END IF
      IF (LERFPHML) THEN
        ERFPHML => ESTIMS(NADDW(36)+1:NADDW(37),:)
      ELSE
        ERFPHML => CEMETERYS(0:0,:)
      END IF
      IF (LERFPML) THEN
        ERFPML => ESTIMS(NADDW(37)+1:NADDW(38),:)
      ELSE
        ERFPML => CEMETERYS(0:0,:)
      END IF
C
      IF (LEOTIO) THEN
        EOTIO => ESTIMS(NADDW(38)+1:NADDW(39),:)
      ELSE
        EOTIO => CEMETERYS(0:0,:)
      END IF
      IF (LERFAIO) THEN
        ERFAIO => ESTIMS(NADDW(39)+1:NADDW(40),:)
      ELSE
        ERFAIO => CEMETERYS(0:0,:)
      END IF
      IF (LERFMIO) THEN
        ERFMIO => ESTIMS(NADDW(40)+1:NADDW(41),:)
      ELSE
        ERFMIO => CEMETERYS(0:0,:)
      END IF
      IF (LERFIIO) THEN
        ERFIIO => ESTIMS(NADDW(41)+1:NADDW(42),:)
      ELSE
        ERFIIO => CEMETERYS(0:0,:)
      END IF
      IF (LERFPHIO) THEN
        ERFPHIO => ESTIMS(NADDW(42)+1:NADDW(43),:)
      ELSE
        ERFPHIO => CEMETERYS(0:0,:)
      END IF
      IF (LERFPIO) THEN
        ERFPIO => ESTIMS(NADDW(43)+1:NADDW(44),:)
      ELSE
        ERFPIO => CEMETERYS(0:0,:)
      END IF
C
      IF (LEOTPHT) THEN
        EOTPHT => ESTIMS(NADDW(44)+1:NADDW(45),:)
      ELSE
        EOTPHT => CEMETERYS(0:0,:)
      END IF
      IF (LERFAPHT) THEN
        ERFAPHT => ESTIMS(NADDW(45)+1:NADDW(46),:)
      ELSE
        ERFAPHT => CEMETERYS(0:0,:)
      END IF
      IF (LERFMPHT) THEN
        ERFMPHT => ESTIMS(NADDW(46)+1:NADDW(47),:)
      ELSE
        ERFMPHT => CEMETERYS(0:0,:)
      END IF
      IF (LERFIPHT) THEN
        ERFIPHT => ESTIMS(NADDW(47)+1:NADDW(48),:)
      ELSE
        ERFIPHT => CEMETERYS(0:0,:)
      END IF
      IF (LERFPHPHT) THEN
        ERFPHPHT =>ESTIMS(NADDW(48)+1:NADDW(49),:)
      ELSE
        ERFPHPHT => CEMETERYS(0:0,:)
      END IF
      IF (LERFPPHT) THEN
        ERFPPHT => ESTIMS(NADDW(49)+1:NADDW(50),:)
      ELSE
        ERFPPHT => CEMETERYS(0:0,:)
      END IF
C
      IF (LEOTPL) THEN
        EOTPL => ESTIMS(NADDW(50)+1:NADDW(51),:)
      ELSE
        EOTPL => CEMETERYS(0:0,:)
      END IF
C
      IF (LSPTAT) THEN
        SPTAT => ESTIMS(NADDW(51)+1:NADDW(52),:)
      ELSE
        SPTAT => CEMETERYS(0:0,:)
      END IF
      IF (LSPTML) THEN
        SPTML => ESTIMS(NADDW(52)+1:NADDW(53),:)
      ELSE
        SPTML => CEMETERYS(0:0,:)
      END IF
      IF (LSPTIO) THEN
        SPTIO => ESTIMS(NADDW(53)+1:NADDW(54),:)
      ELSE
        SPTIO => CEMETERYS(0:0,:)
      END IF
      IF (LSPTPHT) THEN
        SPTPHT => ESTIMS(NADDW(54)+1:NADDW(55),:)
      ELSE
        SPTPHT => CEMETERYS(0:0,:)
      END IF
      IF (LSPTPL) THEN
        SPTPL => ESTIMS(NADDW(55)+1:NADDW(56),:)
      ELSE
        SPTPL => CEMETERYS(0:0,:)
      END IF
      IF (LSPTTOT) THEN
        SPTTOT => ESTIMS(NADDW(56)+1,:)
      ELSE
        SPTTOT => CEMETERYS(0,:)
      END IF
      IF (LADDS) THEN
        ADDS => ESTIMS(NADDW(57)+1:NADDW(58),:)
      ELSE
        ADDS => CEMETERYS(0:0,:)
      END IF
      IF (LALGS) THEN
        ALGS => ESTIMS(NADDW(58)+1:NADDW(59),:)
      ELSE
        ALGS => CEMETERYS(0:0,:)
      END IF
      IF (LSPUMP) THEN
        SPUMP => ESTIMS(NADDW(59)+1:,:)
      ELSE
        SPUMP => CEMETERYS(0:0,:)
      END IF

      RETURN
      END SUBROUTINE ASSOCIATE_CESTIM


      SUBROUTINE DEALLOC_CESTIM
C
      IF (ALLOCATED(ESTIMV)) THEN
         DEALLOCATE (ESTIMV)
         DEALLOCATE (ESTIMS)
         IF (NADSPC > 0) DEALLOCATE (ESTIML)
         DEALLOCATE (NFIRST)
         DEALLOCATE (NADDV)
         DEALLOCATE (IRESC1)
         DEALLOCATE (IRESC2)
         DEALLOCATE (NFRSTW)
         DEALLOCATE (NADDW)

         DEALLOCATE (CEMETERYV)
         DEALLOCATE (CEMETERYS)
      END IF

      IF (ALLOCATED(LIVTALV)) THEN
         DEALLOCATE (LIVTALV)
         DEALLOCATE (LIVTALS)
         DEALLOCATE (LMISTALV)
         DEALLOCATE (LMISTALS)
      END IF

      RETURN
      END SUBROUTINE DEALLOC_CESTIM


      SUBROUTINE INIT_CESTIM(ICAL)

      INTEGER, INTENT(IN) :: ICAL
C
      IF (ICAL == 1) THEN

        LIVTALV = .TRUE.
        LIVTALS = .TRUE.
        LMISTALV = .FALSE.
        LMISTALS = .FALSE.

! volume averaged tallies

        LPDENA   => LIVTALV(1)
        LPDENM   => LIVTALV(2)
        LPDENI   => LIVTALV(3)
        LPDENPH  => LIVTALV(4)
        LEDENA   => LIVTALV(5)
        LEDENM   => LIVTALV(6)
        LEDENI   => LIVTALV(7)
        LEDENPH  => LIVTALV(8)
        LPAEL    => LIVTALV(9)
        LPAAT    => LIVTALV(10)
        LPAML    => LIVTALV(11)
        LPAIO    => LIVTALV(12)
        LPAPHT   => LIVTALV(13)
        LPAPL    => LIVTALV(14)
        LPMEL    => LIVTALV(15)
        LPMAT    => LIVTALV(16)
        LPMML    => LIVTALV(17)
        LPMIO    => LIVTALV(18)
        LPMPHT   => LIVTALV(19)
        LPMPL    => LIVTALV(20)
        LPIEL    => LIVTALV(21)
        LPIAT    => LIVTALV(22)
        LPIML    => LIVTALV(23)
        LPIIO    => LIVTALV(24)
        LPIPHT   => LIVTALV(25)
        LPIPL    => LIVTALV(26)
        LPPHEL   => LIVTALV(27)
        LPPHAT   => LIVTALV(28)
        LPPHML   => LIVTALV(29)
        LPPHIO   => LIVTALV(30)
        LPPHPHT  => LIVTALV(31)
        LPPHPL   => LIVTALV(32)
        LEAEL    => LIVTALV(33)
        LEAAT    => LIVTALV(34)
        LEAML    => LIVTALV(35)
        LEAIO    => LIVTALV(36)
        LEAPHT   => LIVTALV(37)
        LEAPL    => LIVTALV(38)
        LEMEL    => LIVTALV(39)
        LEMAT    => LIVTALV(40)
        LEMML    => LIVTALV(41)
        LEMIO    => LIVTALV(42)
        LEMPHT   => LIVTALV(43)
        LEMPL    => LIVTALV(44)
        LEIEL    => LIVTALV(45)
        LEIAT    => LIVTALV(46)
        LEIML    => LIVTALV(47)
        LEIIO    => LIVTALV(48)
        LEIPHT   => LIVTALV(49)
        LEIPL    => LIVTALV(50)
        LEPHEL   => LIVTALV(51)
        LEPHAT   => LIVTALV(52)
        LEPHML   => LIVTALV(53)
        LEPHIO   => LIVTALV(54)
        LEPHPHT  => LIVTALV(55)
        LEPHPL   => LIVTALV(56)
        LADDV    => LIVTALV(57)
        LCOLV    => LIVTALV(58)
        LSNAPV   => LIVTALV(59)
        LCOPV    => LIVTALV(60)
        LBGKV    => LIVTALV(61)
        LALGV    => LIVTALV(62)
        LPGENA   => LIVTALV(63)
        LPGENM   => LIVTALV(64)
        LPGENI   => LIVTALV(65)
        LPGENPH  => LIVTALV(66)
        LEGENA   => LIVTALV(67)
        LEGENM   => LIVTALV(68)
        LEGENI   => LIVTALV(69)
        LEGENPH  => LIVTALV(70)
        LVGENA   => LIVTALV(71)
        LVGENM   => LIVTALV(72)
        LVGENI   => LIVTALV(73)
        LVGENPH  => LIVTALV(74)
        LPPAT    => LIVTALV(75)
        LPPML    => LIVTALV(76)
        LPPIO    => LIVTALV(77)
        LPPPHT   => LIVTALV(78)
        LPPPL    => LIVTALV(79)
        LEPAT    => LIVTALV(80)
        LEPML    => LIVTALV(81)
        LEPIO    => LIVTALV(82)
        LEPPHT   => LIVTALV(83)
        LEPPL    => LIVTALV(84)
        LVXDENA  => LIVTALV(85)
        LVXDENM  => LIVTALV(86)
        LVXDENI  => LIVTALV(87)
        LVXDENPH => LIVTALV(88)
        LVYDENA  => LIVTALV(89)
        LVYDENM  => LIVTALV(90)
        LVYDENI  => LIVTALV(91)
        LVYDENPH => LIVTALV(92)
        LVZDENA  => LIVTALV(93)
        LVZDENM  => LIVTALV(94)
        LVZDENI  => LIVTALV(95)
        LVZDENPH => LIVTALV(96)
        LMAPL    => LIVTALV(97)
        LMMPL    => LIVTALV(98)
        LMIPL    => LIVTALV(99)
        LMPHPL   => LIVTALV(100)
        

        LMSPDENA   => LMISTALV(1)
        LMSPDENM   => LMISTALV(2)
        LMSPDENI   => LMISTALV(3)
        LMSPDENPH  => LMISTALV(4)
        LMSEDENA   => LMISTALV(5)
        LMSEDENM   => LMISTALV(6)
        LMSEDENI   => LMISTALV(7)
        LMSEDENPH  => LMISTALV(8)
        LMSPAEL    => LMISTALV(9)
        LMSPAAT    => LMISTALV(10)
        LMSPAML    => LMISTALV(11)
        LMSPAIO    => LMISTALV(12)
        LMSPAPHT   => LMISTALV(13)
        LMSPAPL    => LMISTALV(14)
        LMSPMEL    => LMISTALV(15)
        LMSPMAT    => LMISTALV(16)
        LMSPMML    => LMISTALV(17)
        LMSPMIO    => LMISTALV(18)
        LMSPMPHT   => LMISTALV(19)
        LMSPMPL    => LMISTALV(20)
        LMSPIEL    => LMISTALV(21)
        LMSPIAT    => LMISTALV(22)
        LMSPIML    => LMISTALV(23)
        LMSPIIO    => LMISTALV(24)
        LMSPIPHT   => LMISTALV(25)
        LMSPIPL    => LMISTALV(26)
        LMSPPHEL   => LMISTALV(27)
        LMSPPHAT   => LMISTALV(28)
        LMSPPHML   => LMISTALV(29)
        LMSPPHIO   => LMISTALV(30)
        LMSPPHPHT  => LMISTALV(31)
        LMSPPHPL   => LMISTALV(32)
        LMSEAEL    => LMISTALV(33)
        LMSEAAT    => LMISTALV(34)
        LMSEAML    => LMISTALV(35)
        LMSEAIO    => LMISTALV(36)
        LMSEAPHT   => LMISTALV(37)
        LMSEAPL    => LMISTALV(38)
        LMSEMEL    => LMISTALV(39)
        LMSEMAT    => LMISTALV(40)
        LMSEMML    => LMISTALV(41)
        LMSEMIO    => LMISTALV(42)
        LMSEMPHT   => LMISTALV(43)
        LMSEMPL    => LMISTALV(44)
        LMSEIEL    => LMISTALV(45)
        LMSEIAT    => LMISTALV(46)
        LMSEIML    => LMISTALV(47)
        LMSEIIO    => LMISTALV(48)
        LMSEIPHT   => LMISTALV(49)
        LMSEIPL    => LMISTALV(50)
        LMSEPHEL   => LMISTALV(51)
        LMSEPHAT   => LMISTALV(52)
        LMSEPHML   => LMISTALV(53)
        LMSEPHIO   => LMISTALV(54)
        LMSEPHPHT  => LMISTALV(55)
        LMSEPHPL   => LMISTALV(56)
        LMSADDV    => LMISTALV(57)
        LMSCOLV    => LMISTALV(58)
        LMSSNAPV   => LMISTALV(59)
        LMSCOPV    => LMISTALV(60)
        LMSBGKV    => LMISTALV(61)
        LMSALGV    => LMISTALV(62)
        LMSPGENA   => LMISTALV(63)
        LMSPGENM   => LMISTALV(64)
        LMSPGENI   => LMISTALV(65)
        LMSPGENPH  => LMISTALV(66)
        LMSEGENA   => LMISTALV(67)
        LMSEGENM   => LMISTALV(68)
        LMSEGENI   => LMISTALV(69)
        LMSEGENPH  => LMISTALV(70)
        LMSVGENA   => LMISTALV(71)
        LMSVGENM   => LMISTALV(72)
        LMSVGENI   => LMISTALV(73)
        LMSVGENPH  => LMISTALV(74)
        LMSPPAT    => LMISTALV(75)
        LMSPPML    => LMISTALV(76)
        LMSPPIO    => LMISTALV(77)
        LMSPPPHT   => LMISTALV(78)
        LMSPPPL    => LMISTALV(79)
        LMSEPAT    => LMISTALV(80)
        LMSEPML    => LMISTALV(81)
        LMSEPIO    => LMISTALV(82)
        LMSEPPHT   => LMISTALV(83)
        LMSEPPL    => LMISTALV(84)
        LMSVXDENA  => LMISTALV(85)
        LMSVXDENM  => LMISTALV(86)
        LMSVXDENI  => LMISTALV(87)
        LMSVXDENPH => LMISTALV(88)
        LMSVYDENA  => LMISTALV(89)
        LMSVYDENM  => LMISTALV(90)
        LMSVYDENI  => LMISTALV(91)
        LMSVYDENPH => LMISTALV(92)
        LMSVZDENA  => LMISTALV(93)
        LMSVZDENM  => LMISTALV(94)
        LMSVZDENI  => LMISTALV(95)
        LMSVZDENPH => LMISTALV(96)
        LMSMAPL    => LMISTALV(97)
        LMSMMPL    => LMISTALV(98)
        LMSMIPL    => LMISTALV(99)
        LMSMPHPL   => LMISTALV(100)

! surface averaged tallies

        LPOTAT    => LIVTALS(1)
        LPRFAAT   => LIVTALS(2)
        LPRFMAT   => LIVTALS(3)
        LPRFIAT   => LIVTALS(4)
        LPRFPHAT  => LIVTALS(5)
        LPRFPAT   => LIVTALS(6)
        LPOTML    => LIVTALS(7)
        LPRFAML   => LIVTALS(8)
        LPRFMML   => LIVTALS(9)
        LPRFIML   => LIVTALS(10)
        LPRFPHML  => LIVTALS(11)
        LPRFPML   => LIVTALS(12)
        LPOTIO    => LIVTALS(13)
        LPRFAIO   => LIVTALS(14)
        LPRFMIO   => LIVTALS(15)
        LPRFIIO   => LIVTALS(16)
        LPRFPHIO  => LIVTALS(17)
        LPRFPIO   => LIVTALS(18)
        LPOTPHT   => LIVTALS(19)
        LPRFAPHT  => LIVTALS(20)
        LPRFMPHT  => LIVTALS(21)
        LPRFIPHT  => LIVTALS(22)
        LPRFPHPHT => LIVTALS(23)
        LPRFPPHT  => LIVTALS(24)
        LPOTPL    => LIVTALS(25)
        LEOTAT    => LIVTALS(26)
        LERFAAT   => LIVTALS(27)
        LERFMAT   => LIVTALS(28)
        LERFIAT   => LIVTALS(29)
        LERFPHAT  => LIVTALS(30)
        LERFPAT   => LIVTALS(31)
        LEOTML    => LIVTALS(32)
        LERFAML   => LIVTALS(33)
        LERFMML   => LIVTALS(34)
        LERFIML   => LIVTALS(35)
        LERFPHML  => LIVTALS(36)
        LERFPML   => LIVTALS(37)
        LEOTIO    => LIVTALS(38)
        LERFAIO   => LIVTALS(39)
        LERFMIO   => LIVTALS(40)
        LERFIIO   => LIVTALS(41)
        LERFPHIO  => LIVTALS(42)
        LERFPIO   => LIVTALS(43)
        LEOTPHT   => LIVTALS(44)
        LERFAPHT  => LIVTALS(45)
        LERFMPHT  => LIVTALS(46)
        LERFIPHT  => LIVTALS(47)
        LERFPHPHT => LIVTALS(48)
        LERFPPHT  => LIVTALS(49)
        LEOTPL    => LIVTALS(50)
        LSPTAT    => LIVTALS(51)
        LSPTML    => LIVTALS(52)
        LSPTIO    => LIVTALS(53)
        LSPTPHT   => LIVTALS(54)
        LSPTPL    => LIVTALS(55)
        LSPTTOT   => LIVTALS(56)
        LADDS     => LIVTALS(57)
        LALGS     => LIVTALS(58)
        LSPUMP    => LIVTALS(59)

        LMSPOTAT    => LMISTALS(1)
        LMSPRFAAT   => LMISTALS(2)
        LMSPRFMAT   => LMISTALS(3)
        LMSPRFIAT   => LMISTALS(4)
        LMSPRFPHAT  => LMISTALS(5)
        LMSPRFPAT   => LMISTALS(6)
        LMSPOTML    => LMISTALS(7)
        LMSPRFAML   => LMISTALS(8)
        LMSPRFMML   => LMISTALS(9)
        LMSPRFIML   => LMISTALS(10)
        LMSPRFPHML  => LMISTALS(11)
        LMSPRFPML   => LMISTALS(12)
        LMSPOTIO    => LMISTALS(13)
        LMSPRFAIO   => LMISTALS(14)
        LMSPRFMIO   => LMISTALS(15)
        LMSPRFIIO   => LMISTALS(16)
        LMSPRFPHIO  => LMISTALS(17)
        LMSPRFPIO   => LMISTALS(18)
        LMSPOTPHT   => LMISTALS(19)
        LMSPRFAPHT  => LMISTALS(20)
        LMSPRFMPHT  => LMISTALS(21)
        LMSPRFIPHT  => LMISTALS(22)
        LMSPRFPHPHT => LMISTALS(23)
        LMSPRFPPHT  => LMISTALS(24)
        LMSPOTPL    => LMISTALS(25)
        LMSEOTAT    => LMISTALS(26)
        LMSERFAAT   => LMISTALS(27)
        LMSERFMAT   => LMISTALS(28)
        LMSERFIAT   => LMISTALS(29)
        LMSERFPHAT  => LMISTALS(30)
        LMSERFPAT   => LMISTALS(31)
        LMSEOTML    => LMISTALS(32)
        LMSERFAML   => LMISTALS(33)
        LMSERFMML   => LMISTALS(34)
        LMSERFIML   => LMISTALS(35)
        LMSERFPHML  => LMISTALS(36)
        LMSERFPML   => LMISTALS(37)
        LMSEOTIO    => LMISTALS(38)
        LMSERFAIO   => LMISTALS(39)
        LMSERFMIO   => LMISTALS(40)
        LMSERFIIO   => LMISTALS(41)
        LMSERFPHIO  => LMISTALS(42)
        LMSERFPIO   => LMISTALS(43)
        LMSEOTPHT   => LMISTALS(44)
        LMSERFAPHT  => LMISTALS(45)
        LMSERFMPHT  => LMISTALS(46)
        LMSERFIPHT  => LMISTALS(47)
        LMSERFPHPHT => LMISTALS(48)
        LMSERFPPHT  => LMISTALS(49)
        LMSEOTPL    => LMISTALS(50)
        LMSSPTAT    => LMISTALS(51)
        LMSSPTML    => LMISTALS(52)
        LMSSPTIO    => LMISTALS(53)
        LMSSPTPHT   => LMISTALS(54)
        LMSSPTPL    => LMISTALS(55)
        LMSSPTTOT   => LMISTALS(56)
        LMSADDS     => LMISTALS(57)
        LMSALGS     => LMISTALS(58)
        LMSSPUMP    => LMISTALS(59)

        NFIRST = 0
        NADDV  = 0
        IRESC1 = 0
        IRESC2 = 0
        NFRSTW = 0
        NADDW  = 0

      ELSE IF (ICAL == 2) THEN

        ESTIMV = 0._DP
        ESTIMS = 0._DP

        CEMETERYV = 0._DP
        CEMETERYS = 0._DP

      END IF

      RETURN
      END SUBROUTINE INIT_CESTIM

      END MODULE CESTIM
C ===== SOURCE: cfplk.f
      MODULE CFPLK
C   parameters for fokker planck collision operator
      USE PRECISION

      IMPLICIT NONE

      PUBLIC

      REAL(DP), PUBLIC, SAVE ::
     R E0PAR, VELPAR, VELPER, VLXPAR, VLYPAR, VLZPAR, SIGPAR, TAUE,
     R BVEC(3), BBX, BBY, BBZ
      LOGICAL, public, save :: LCART

      END MODULE CFPLK
C ===== SOURCE: cgeom.f
      MODULE CGEOM

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CGEOM, DEALLOC_CGEOM, INIT_CGEOM,
     P          CELL_ELEM, CELL_LIST

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        RCGM1(:), RCGM2(:,:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R VOLADD(:), VOLCOR(:), VOLG(:), VOLTAL(:), VOLTOT,
     R AREA(:),   AREAG(:),  CELDIA(:), XCOM(:), YCOM(:),
     R XPOINT(:), YPOINT(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R XPOL(:,:), YPOL(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NPOINT(:,:),   NSTGRD(:), NGHPLS(:,:,:),
     I NGHPOL(:,:,:), NCLTAL(:), INDPOINT(:,:)

      INTEGER, PUBLIC, SAVE :: NCGM1, NCGM2, NNODES

      TYPE :: CELL_ELEM
        INTEGER :: NOCELL
        TYPE(CELL_ELEM), POINTER :: NEXT_CELL
      END TYPE CELL_ELEM

      TYPE :: CELL_LIST
        TYPE(CELL_ELEM), POINTER :: PCELL
      END TYPE CELL_LIST

      TYPE(CELL_LIST), ALLOCATABLE, SAVE, PUBLIC :: COORCELL(:)


      CONTAINS


      SUBROUTINE ALLOC_CGEOM

      IF (ALLOCATED(RCGM1)) RETURN

      NCGM1 = NADD+NBMAX+7*NRAD+NRTAL+1+NLMPGS
      NCGM2 = 2*N1STS*N2NDPLG

      ALLOCATE (RCGM1(NCGM1))
!pb      ALLOCATE (RCGM2(2*N1STS,N2NDPLG))
      ALLOCATE (RCGM2(N1STS,2*N2NDPLG))

      ALLOCATE (NPOINT(2,NPPART))
      ALLOCATE (NSTGRD(NRAD))
      ALLOCATE (NGHPLS(4,N1STS,N2NDPLG))
      ALLOCATE (NGHPOL(4,N1STS,N2NDPLG))
      ALLOCATE (NCLTAL(NRAD))
      ALLOCATE (INDPOINT(N1STS,N2NDPLG))

      ALLOCATE (COORCELL(NRAD))

      WRITE (55,'(A,T25,I15)')
     .      ' CGEOM ',(NCGM1+2*N1STS*N2NDPLG)*8 +
     .                (2*NPPART+2*NRAD+8*N1STS*N2NDPLG)*4

      VOLADD => RCGM1(1 : NADD)
      VOLTAL => RCGM1(1+NADD : NADD+NRTAL)
      VOLCOR => RCGM1(1+NADD+NRTAL : NADD+NRTAL+NBMAX)
      VOLG   => RCGM1(1+NADD+NRTAL+NBMAX : NADD+NRTAL+NBMAX+NRAD)
      AREA   => RCGM1(1+NADD+NRTAL+NBMAX+NRAD : NADD+NRTAL+NBMAX+2*NRAD)
      CELDIA => RCGM1(1+NADD+NRTAL+NBMAX+2*NRAD :
     .                  NADD+NRTAL+NBMAX+3*NRAD)
      XCOM   => RCGM1(1+NADD+NRTAL+NBMAX+3*NRAD :
     .                  NADD+NRTAL+NBMAX+4*NRAD)
      YCOM   => RCGM1(1+NADD+NRTAL+NBMAX+4*NRAD :
     .                  NADD+NRTAL+NBMAX+5*NRAD)
      XPOINT => RCGM1(1+NADD+NRTAL+NBMAX+5*NRAD :
     .                  NADD+NRTAL+NBMAX+6*NRAD)
      YPOINT => RCGM1(1+NADD+NRTAL+NBMAX+6*NRAD :
     .                  NADD+NRTAL+NBMAX+7*NRAD)
      AREAG  => RCGM1(1+NADD+NRTAL+NBMAX+7*NRAD :
     .                  NADD+NRTAL+NBMAX+7*NRAD+NLMPGS)
      VOLTOT => RCGM1(1+NADD+NRTAL+NBMAX+7*NRAD+NLMPGS)

!pb      XPOL => RCGM2(1+0*N1STS:1*N1STS,:)
!pb      YPOL => RCGM2(1+1*N1STS:2*N1STS,:)
      XPOL => RCGM2(:,1:N2NDPLG)
      YPOL => RCGM2(:,1+N2NDPLG:2*N2NDPLG)

      CALL INIT_CGEOM

      RETURN
      END SUBROUTINE ALLOC_CGEOM


      SUBROUTINE DEALLOC_CGEOM

      IF (.NOT.ALLOCATED(RCGM1)) RETURN

      DEALLOCATE (RCGM1)
      DEALLOCATE (RCGM2)

      DEALLOCATE (NPOINT)
      DEALLOCATE (NSTGRD)
      DEALLOCATE (NGHPLS)
      DEALLOCATE (NGHPOL)
      DEALLOCATE (NCLTAL)
      DEALLOCATE (INDPOINT)

      DEALLOCATE (COORCELL)

      RETURN
      END SUBROUTINE DEALLOC_CGEOM


      SUBROUTINE INIT_CGEOM

      INTEGER :: I

      RCGM1    = 0._DP
      RCGM2    = 0._DP

      NPOINT   = 0
      NSTGRD   = 0
      NGHPLS   = 0
      NGHPOL   = 0
      NCLTAL   = 0
      INDPOINT = 0

      DO I=1,NRAD
        NULLIFY (COORCELL(I)%PCELL)
      END DO

      RETURN
      END SUBROUTINE INIT_CGEOM

      END MODULE CGEOM






C ===== SOURCE: cgrid.f
      MODULE CGRID

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CGRID, DEALLOC_CGRID, INIT_CGRID

      INTEGER, PUBLIC, SAVE :: NCGRD, MCGRD

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCGRID(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
C  NCGRD, REAL
     R RSURF(:),  EP1(:),    ELL(:),    TRI(:),    ELLQ(:),
     R RHOSRF(:), RHOZNE(:), RQ(:),
     R PSURF(:),  SINPH(:),  COSPH(:),  PHZONE(:),
     R ZSURF(:),  ZZONE(:),
     R ALPHA,  TANAL,  COSAL,  SINAL,  RMTOR,  ZHALF,  ZFULL,
     R RIA,    RGA,    RAA,    RRA,    XDF,
     R YIA,    YGA,    YAA,    YYA,    DTHET,  YDF,
     R ZIA,    ZGA,    ZAA,    ZZA,    ROA,    DPHI,   ZDF

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICGRID(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
C  MCGRD, INTEGER
     I LEVGEO,
     I NR1ST,  NR1STM,
     I NP2ND,  NP2NDM, NPPLA,  NPPER,
     I NT3RD,  NT3RDM, NTTRA,  NTTRAM, NTPER,
     I NRSEP,  NPSEP,  NTSEP,  NBMLT,  NBMLTP, NRADD,
     I NSURF,  NSURFM, NBLCKS, NSTRD,  NSBOX,
     I NR1P2,  NP2T3,  NR1TAL, NP2TAL, NT3TAL, NSBOX_TAL


      CONTAINS

      SUBROUTINE ALLOC_CGRID

      INTEGER :: IND

      IF (ALLOCATED(RCGRID)) RETURN

      NCGRD=8*N1ST+4*N2ND+2*(N3RD+NTOR)+25
      MCGRD=29

      ALLOCATE (RCGRID(NCGRD))
      ALLOCATE (ICGRID(MCGRD))

      WRITE (55,'(A,T25,I15)')
     .      ' CGRID ',NCGRD*8 + MCGRD*4

      RSURF  => RCGRID(1+0*N1ST : 1*N1ST)
      EP1    => RCGRID(1+1*N1ST : 2*N1ST)
      ELL    => RCGRID(1+2*N1ST : 3*N1ST)
      TRI    => RCGRID(1+3*N1ST : 4*N1ST)
      ELLQ   => RCGRID(1+4*N1ST : 5*N1ST)
      RHOSRF => RCGRID(1+5*N1ST : 6*N1ST)
      RHOZNE => RCGRID(1+6*N1ST : 7*N1ST)
      RQ     => RCGRID(1+7*N1ST : 8*N1ST)
      PSURF  => RCGRID(1+8*N1ST+0*N2ND : 8*N1ST+1*N2ND)
      SINPH  => RCGRID(1+8*N1ST+1*N2ND : 8*N1ST+2*N2ND)
      COSPH  => RCGRID(1+8*N1ST+2*N2ND : 8*N1ST+3*N2ND)
      PHZONE => RCGRID(1+8*N1ST+3*N2ND : 8*N1ST+4*N2ND)
      IND = 8*N1ST+4*N2ND
      ZSURF  => RCGRID(1+IND+0*(N3RD+NTOR) : IND+1*(N3RD+NTOR))
      ZZONE  => RCGRID(1+IND+1*(N3RD+NTOR) : IND+2*(N3RD+NTOR))
      IND = 8*N1ST+4*N2ND+2*(N3RD+NTOR)
      ALPHA  => RCGRID( 1+IND)
      TANAL  => RCGRID( 2+IND)
      COSAL  => RCGRID( 3+IND)
      SINAL  => RCGRID( 4+IND)
      RMTOR  => RCGRID( 5+IND)
      ZHALF  => RCGRID( 6+IND)
      ZFULL  => RCGRID( 7+IND)
      RIA    => RCGRID( 8+IND)
      RGA    => RCGRID( 9+IND)
      RAA    => RCGRID(10+IND)
      RRA    => RCGRID(11+IND)
      XDF    => RCGRID(12+IND)
      YIA    => RCGRID(13+IND)
      YGA    => RCGRID(14+IND)
      YAA    => RCGRID(15+IND)
      YYA    => RCGRID(16+IND)
      DTHET  => RCGRID(17+IND)
      YDF    => RCGRID(18+IND)
      ZIA    => RCGRID(19+IND)
      ZGA    => RCGRID(20+IND)
      ZAA    => RCGRID(21+IND)
      ZZA    => RCGRID(22+IND)
      ROA    => RCGRID(23+IND)
      DPHI   => RCGRID(24+IND)
      ZDF    => RCGRID(25+IND)

      LEVGEO => ICGRID( 1)
      NR1ST  => ICGRID( 2)
      NR1STM => ICGRID( 3)
      NP2ND  => ICGRID( 4)
      NP2NDM => ICGRID( 5)
      NPPLA  => ICGRID( 6)
      NPPER  => ICGRID( 7)
      NT3RD  => ICGRID( 8)
      NT3RDM => ICGRID( 9)
      NTTRA  => ICGRID(10)
      NTTRAM => ICGRID(11)
      NTPER  => ICGRID(12)
      NRSEP  => ICGRID(13)
      NPSEP  => ICGRID(14)
      NTSEP  => ICGRID(15)
      NBMLT  => ICGRID(16)
      NBMLTP => ICGRID(17)
      NRADD  => ICGRID(18)
      NSURF  => ICGRID(19)
      NSURFM => ICGRID(20)
      NBLCKS => ICGRID(21)
      NSTRD  => ICGRID(22)
      NSBOX  => ICGRID(23)
      NR1P2  => ICGRID(24)
      NP2T3  => ICGRID(25)
      NR1TAL => ICGRID(26)
      NP2TAL => ICGRID(27)
      NT3TAL => ICGRID(28)
      NSBOX_TAL=> ICGRID(29)

      CALL INIT_CGRID

      RETURN
      END SUBROUTINE ALLOC_CGRID


      SUBROUTINE DEALLOC_CGRID

      IF (.NOT.ALLOCATED(RCGRID)) RETURN

      DEALLOCATE (RCGRID)
      DEALLOCATE (ICGRID)

      RETURN
      END SUBROUTINE DEALLOC_CGRID


      SUBROUTINE INIT_CGRID

      RCGRID = 0._DP
      ICGRID = 0

      RETURN
      END SUBROUTINE INIT_CGRID

      END MODULE CGRID
C ===== SOURCE: cgrptl.f
      MODULE CGRPTL

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CGRPTL, DEALLOC_CGRPTL, INIT_CGRPTL

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R        XXP2D(:), XXP3D(:),YYP3D(:),
     R        XXP2D_USR(:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R        XCONTOUR(:,:), YCONTOUR(:,:)

      INTEGER, PUBLIC, SAVE ::
     I         IXTL2, IXTL3, IYTL3

      INTEGER, PUBLIC, SAVE ::
     I         NCONTOUR

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I         NCONPOINT(:)

      CONTAINS


      SUBROUTINE ALLOC_CGRPTL

      IF (ALLOCATED(XXP2D)) RETURN

      ALLOCATE (XXP2D(NRADS))
      ALLOCATE (XXP3D(NRADS))
      ALLOCATE (YYP3D(NRADS))
      ALLOCATE (XXP2D_USR(NRADS,NPTAL))

      WRITE (55,'(A,T25,I15)')
     .      ' CGRPTL ',(NPTAL+3)*NRADS*8

      CALL INIT_CGRPTL

      RETURN
      END SUBROUTINE ALLOC_CGRPTL


      SUBROUTINE DEALLOC_CGRPTL

      IF (.NOT.ALLOCATED(XXP2D)) RETURN

      DEALLOCATE (XXP2D)
      DEALLOCATE (XXP3D)
      DEALLOCATE (YYP3D)
      DEALLOCATE (XXP2D_USR)

      RETURN
      END SUBROUTINE DEALLOC_CGRPTL


      SUBROUTINE INIT_CGRPTL

      XXP2D     = 0._DP
      XXP3D     = 0._DP
      YYP3D     = 0._DP
      XXP2D_USR = 0._DP

      RETURN
      END SUBROUTINE INIT_CGRPTL

      END MODULE CGRPTL


C ===== SOURCE: cinit.f
      MODULE CINIT

!  sep-05: specifications for databases added, ndbnames, dbhandle, dbfname
!  jul-06: database handle added for ADAS
      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CINIT, DEALLOC_CINIT, INIT_CINIT,
     .          TDENMODEL, TDENMODAR

      INTEGER, PUBLIC, SAVE ::
     I         NCINIT, MCINIT, LCINIT

      REAL(DP),  PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCINIT(:)
      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICINIT(:)
      LOGICAL, PUBLIC, TARGET, SAVE :: LCNIT(3)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R EP1IN,  EP1CH,  EP1OT,  EXEP1,
     R ELLIN,  ELLOT,  ELLCH,  EXELL,
     R TRIIN,  TRIOT,  TRICH,  EXTRI,
     R TE0,    TE1,    TE2,    TE3,    TE4,   TE5,
     R BP0,    BP1,    BP2,    BP3,    BP4,   BP5,
     R B0,     B1,     B2,     B3,     B4,    B5

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R TI0(:),TI1(:),TI2(:),TI3(:),TI4(:),TI5(:),
     R VX0(:),VX1(:),VX2(:),VX3(:),VX4(:),VX5(:),
     R VY0(:),VY1(:),VY2(:),VY3(:),VY4(:),VY5(:),
     R VZ0(:),VZ1(:),VZ2(:),VZ3(:),VZ4(:),VZ5(:),
     R DI0(:),DI1(:),DI2(:),DI3(:),DI4(:),DI5(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I INDPRO(:),INDGRD(:),INDSRC(:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L NLMACH,NLMLTI,NLMLV

      CHARACTER(66), PUBLIC, SAVE :: CASENAME
      CHARACTER(10), PUBLIC, ALLOCATABLE, SAVE :: CDENMODEL(:)

      TYPE TDENMODEL
        REAL(DP) :: G_BOLTZ, DELTAE, A_CORONA
        INTEGER :: NRE
        INTEGER, POINTER :: ISP(:), ITP(:), ISTR(:)
        CHARACTER(8), POINTER :: FNAME(:)
        CHARACTER(4), POINTER :: H2(:)
        CHARACTER(9), POINTER :: REACTION(:)
        CHARACTER(3), POINTER :: CR(:)
      END TYPE

      TYPE TDENMODAR
        TYPE(TDENMODEL), POINTER :: TDM
      END TYPE

      TYPE(TDENMODAR), PUBLIC, ALLOCATABLE, SAVE :: TDMPAR(:)

      INTEGER, PUBLIC, PARAMETER ::
     I NDBNAMES=13

      CHARACTER(100), PUBLIC, SAVE :: DBFNAME(NDBNAMES)
      CHARACTER(6), PUBLIC, SAVE :: DBHANDLE(NDBNAMES)

      CONTAINS

      SUBROUTINE ALLOC_CINIT

      IF (ALLOCATED(RCINIT)) RETURN

      NCINIT=30+30*NPLS
      MCINIT=12+3+NSTRA
      LCINIT=3

      ALLOCATE (RCINIT(NCINIT))
      ALLOCATE (ICINIT(MCINIT))
      ALLOCATE (CDENMODEL(NPLS))
      ALLOCATE (TDMPAR(NPLS))

      WRITE (55,'(A,T25,I15)')
     .      ' CINIT ',NCINIT*8 + MCINIT*4 +
     .                NPLS*LEN(CDENMODEL(1))

      EP1IN  => RCINIT(1)
      EP1CH  => RCINIT(2)
      EP1OT  => RCINIT(3)
      EXEP1  => RCINIT(4)
      ELLIN  => RCINIT(5)
      ELLOT  => RCINIT(6)
      ELLCH  => RCINIT(7)
      EXELL  => RCINIT(8)
      TRIIN  => RCINIT(9)
      TRIOT  => RCINIT(10)
      TRICH  => RCINIT(11)
      EXTRI  => RCINIT(12)
      TE0    => RCINIT(13)
      TE1    => RCINIT(14)
      TE2    => RCINIT(15)
      TE3    => RCINIT(16)
      TE4    => RCINIT(17)
      TE5    => RCINIT(18)
      BP0    => RCINIT(19)
      BP1    => RCINIT(20)
      BP2    => RCINIT(21)
      BP3    => RCINIT(22)
      BP4    => RCINIT(23)
      BP5    => RCINIT(24)
      B0     => RCINIT(25)
      B1     => RCINIT(26)
      B2     => RCINIT(27)
      B3     => RCINIT(28)
      B4     => RCINIT(29)
      B5     => RCINIT(30)
      TI0    => RCINIT(31         : 30+ 1*NPLS)
      TI1    => RCINIT(31+ 1*npls : 30+ 2*NPLS)
      TI2    => RCINIT(31+ 2*npls : 30+ 3*NPLS)
      TI3    => RCINIT(31+ 3*npls : 30+ 4*NPLS)
      TI4    => RCINIT(31+ 4*npls : 30+ 5*NPLS)
      TI5    => RCINIT(31+ 5*npls : 30+ 6*NPLS)
      VX0    => RCINIT(31+ 6*npls : 30+ 7*NPLS)
      VX1    => RCINIT(31+ 7*npls : 30+ 8*NPLS)
      VX2    => RCINIT(31+ 8*npls : 30+ 9*NPLS)
      VX3    => RCINIT(31+ 9*npls : 30+10*NPLS)
      VX4    => RCINIT(31+10*npls : 30+11*NPLS)
      VX5    => RCINIT(31+11*npls : 30+12*NPLS)
      VY0    => RCINIT(31+12*npls : 30+13*NPLS)
      VY1    => RCINIT(31+13*npls : 30+14*NPLS)
      VY2    => RCINIT(31+14*npls : 30+15*NPLS)
      VY3    => RCINIT(31+15*npls : 30+16*NPLS)
      VY4    => RCINIT(31+16*npls : 30+17*NPLS)
      VY5    => RCINIT(31+17*npls : 30+18*NPLS)
      VZ0    => RCINIT(31+18*npls : 30+19*NPLS)
      VZ1    => RCINIT(31+19*npls : 30+20*NPLS)
      VZ2    => RCINIT(31+20*npls : 30+21*NPLS)
      VZ3    => RCINIT(31+21*npls : 30+22*NPLS)
      VZ4    => RCINIT(31+22*npls : 30+23*NPLS)
      VZ5    => RCINIT(31+23*npls : 30+24*NPLS)
      DI0    => RCINIT(31+24*npls : 30+25*NPLS)
      DI1    => RCINIT(31+25*npls : 30+26*NPLS)
      DI2    => RCINIT(31+26*npls : 30+27*NPLS)
      DI3    => RCINIT(31+27*npls : 30+28*NPLS)
      DI4    => RCINIT(31+28*npls : 30+29*NPLS)
      DI5    => RCINIT(31+29*npls : 30+30*NPLS)

      INDPRO => ICINIT( 1 : 12)
      INDGRD => ICINIT(13 : 15)
      INDSRC => ICINIT(16 : 15+NSTRA)

      NLMACH => LCNIT(1)
      NLMLTI => LCNIT(2)
      NLMLV  => LCNIT(3)

      CALL INIT_CINIT

      RETURN

      END SUBROUTINE ALLOC_CINIT


      SUBROUTINE DEALLOC_CINIT

      IF (.NOT.ALLOCATED(RCINIT)) RETURN

      DEALLOCATE (RCINIT)
      DEALLOCATE (ICINIT)
      DEALLOCATE (CDENMODEL)

      RETURN
      END SUBROUTINE DEALLOC_CINIT


      SUBROUTINE INIT_CINIT

      RCINIT = 0._DP
      ICINIT = 0
      LCNIT  = .FALSE.
      CDENMODEL = REPEAT(' ',LEN(CDENMODEL))
C
C  INITIALIZE GEOMETRY DATA
C
      ELLIN=1._DP
      ELLOT=1._DP
      ELLCH=1._DP
      TRIIN=1._DP
      TRIOT=1._DP
      TRICH=1._DP

C
C  INITIALIZE DATABASE NAMES
C
      DBHANDLE(1) = 'AMJUEL'
      DBHANDLE(2) = 'METHAN'
      DBHANDLE(3) = 'HYDHEL'
      DBHANDLE(4) = 'H2VIBR'
      DBHANDLE(5) = 'SPECTR'
      DBHANDLE(6) = 'PHOTON'
      DBHANDLE(7) = 'PHTNEW'
      DBHANDLE(8) = 'SPUTER'
      DBHANDLE(9) = 'TRIM  '
      DBHANDLE(10) = 'POLARI'
      DBHANDLE(11) = 'gr_ext'
      DBHANDLE(12) = 'mo_ext'
      DBHANDLE(13) = 'ADAS  '
      
      DBFNAME(1) = 'AMJUEL'
      DBFNAME(2) = 'METHANE'
      DBFNAME(3) = 'HYDHEL'
      DBFNAME(4) = 'H2VIBR'
      DBFNAME(5) = 'SPECTR'
      DBFNAME(6) = 'PHOTON'
      DBFNAME(7) = 'PHTNEW'
      DBFNAME(8) = 'SPUTER'
      DBFNAME(9) = 'fort.21'
      DBFNAME(10) = 'POLARI'
      DBFNAME(11) = 'graphite_ext.dat'
      DBFNAME(12) = 'mo_ext.dat'
      DBFNAME(13) = ' '
      
      RETURN
      END SUBROUTINE INIT_CINIT

      END MODULE CINIT
C ===== SOURCE: clast.f
      MODULE CLAST

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CLAST, DEALLOC_CLAST, INIT_CLAST

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R          XCMEAN(:), SGCVMX(:),
     R          XEMEAN(:), SGEVMX(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I         NCMEAN(:),IFLRCX(:),
     I         NEMEAN(:),IFLREL(:)


      CONTAINS


      SUBROUTINE ALLOC_CLAST

      IF (ALLOCATED(XCMEAN)) RETURN

      ALLOCATE (XCMEAN(NRCX))
      ALLOCATE (SGCVMX(NRCX))
      ALLOCATE (XEMEAN(NREL))
      ALLOCATE (SGEVMX(NREL))

      ALLOCATE (NCMEAN(NRCX))
      ALLOCATE (IFLRCX(NRCX))
      ALLOCATE (NEMEAN(NREL))
      ALLOCATE (IFLREL(NREL))

      WRITE (55,'(A,T25,I15)')
     .      ' CLAST ',(2*NRCX*2*NREL)*(8+4)

      CALL INIT_CLAST

      RETURN
      END SUBROUTINE ALLOC_CLAST


      SUBROUTINE DEALLOC_CLAST

      IF (.NOT.ALLOCATED(XCMEAN)) RETURN

      DEALLOCATE (XCMEAN)
      DEALLOCATE (SGCVMX)
      DEALLOCATE (XEMEAN)
      DEALLOCATE (SGEVMX)

      DEALLOCATE (NCMEAN)
      DEALLOCATE (IFLRCX)
      DEALLOCATE (NEMEAN)
      DEALLOCATE (IFLREL)

      RETURN
      END SUBROUTINE DEALLOC_CLAST


      SUBROUTINE INIT_CLAST

      XCMEAN = 0._DP
      SGCVMX = 0._DP
      XEMEAN = 0._DP
      SGEVMX = 0._DP

      NCMEAN = 0
      IFLRCX = 0
      NEMEAN = 0
      IFLREL = 0

      RETURN
      END SUBROUTINE INIT_CLAST

      END MODULE CLAST
C ===== SOURCE: clgin.f
      MODULE CLGIN

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CLGIN, DEALLOC_CLGIN, INIT_CLGIN,
     P          SET_DEF_SURF_DATA

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R RLWMN(:),    RLWMX(:),
     R EWALL(:),    EWBIN(:),    TRANSP(:,:,:),
     R FSHEAT(:),
     R ZNML(:),     ZNCL(:),
     R RECYCF(:,:), RECYCT(:,:),
     R RECPRM(:,:),
     R EXPPL(:,:),  EXPEL(:,:),  EXPIL(:,:),
     R RECYCS(:,:),
     R RECYCC(:,:), SPTPRM(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I ILSWCH(:),     ILEQUI(:),     ILTOR(:),
     I ILSIDE(:),     ILIIN(:),      ILREF(:),
     I ILSPT(:),      ILCOL(:),      ILFIT(:),
     I ILCELL(:),     ILBOX(:),      ILPLG(:),
     I ISPUT(:,:),
     I NLIMII(:),     NLIMIE(:),
     I ISWICH(:,:),   ILBLCK(:),     ILACLL(:),
     I JUMLIM(:),
     I INUMP(:,:),    IRPTA(:,:),    IRPTE(:,:),
     I ISRF(:,:),     ISRT(:,:),     ISRS(:,:),
     I ISRC(:,:),
     I INMP1I(:,:,:), INMP2I(:,:,:), INMP3I(:,:,:),
     I IGFIL(:),
     I IGJUM0(:),     IGJUM1(:,:),   IGJUM2(:,:),   IGJUM3(:,:)

      INTEGER, PUBLIC, SAVE ::
     I NSTSI,
     I NLIMPB


      CONTAINS


      SUBROUTINE ALLOC_CLGIN

      IF (ALLOCATED(RLWMN)) RETURN

      NLIMPB=NLIMPS/NOPTM1+1

      ALLOCATE (RLWMN(0:NLIMPS))
      ALLOCATE (RLWMX(0:NLIMPS))
      ALLOCATE (EWALL(0:NLIMPS))
      ALLOCATE (EWBIN(0:NLIMPS))
      ALLOCATE (TRANSP(NSPZ,2,0:NLIMPS))
      ALLOCATE (FSHEAT(0:NLIMPS))
      ALLOCATE (ZNML(0:NLIMPS))
      ALLOCATE (ZNCL(0:NLIMPS))
      ALLOCATE (RECYCF(NSPZ,0:NLIMPS))
      ALLOCATE (RECYCT(NSPZ,0:NLIMPS))
      ALLOCATE (RECPRM(NSPZ,0:NLIMPS))
      ALLOCATE (EXPPL(NSPZ,0:NLIMPS))
      ALLOCATE (EXPEL(NSPZ,0:NLIMPS))
      ALLOCATE (EXPIL(NSPZ,0:NLIMPS))
      ALLOCATE (RECYCS(NSPZ,0:NLIMPS))
      ALLOCATE (RECYCC(NSPZ,0:NLIMPS))
      ALLOCATE (SPTPRM(NSPZ,0:NLIMPS))

      ALLOCATE (ILSWCH(0:NLIMPS))
      ALLOCATE (ILEQUI(0:NLIMPS))
      ALLOCATE (ILTOR(0:NLIMPS))
      ALLOCATE (ILSIDE(0:NLIMPS))
      ALLOCATE (ILIIN(0:NLIMPS))
      ALLOCATE (ILREF(0:NLIMPS))
      ALLOCATE (ILSPT(0:NLIMPS))
      ALLOCATE (ILCOL(0:NLIMPS))
      ALLOCATE (ILFIT(0:NLIMPS))
      ALLOCATE (ILCELL(0:NLIMPS))
      ALLOCATE (ILBOX(0:NLIMPS))
      ALLOCATE (ILPLG(0:NLIMPS))
      ALLOCATE (ISPUT(2,0:NLIMPS))

      ALLOCATE (NLIMII(NOPTIM))
      ALLOCATE (NLIMIE(NOPTIM))
      ALLOCATE (ISWICH(6,0:NLIMPS))
      ALLOCATE (ILBLCK(0:NLIMPS))
      ALLOCATE (ILACLL(0:NLIMPS))
      ALLOCATE (JUMLIM(0:NLIMPS))
      ALLOCATE (INUMP(NSTS,3))
      ALLOCATE (IRPTA(NSTS,3))
      ALLOCATE (IRPTE(NSTS,3))
      ALLOCATE (ISRF(NSPZ,0:NLIMPS))
      ALLOCATE (ISRT(NSPZ,0:NLIMPS))
      ALLOCATE (ISRS(NSPZ,0:NLIMPS))
      ALLOCATE (ISRC(NSPZ,0:NLIMPS))
      ALLOCATE (INMP1I(0:N1ST,0:N2ND,0:N3RD))
      ALLOCATE (INMP2I(0:N1ST,0:N2ND,0:N3RD))
      ALLOCATE (INMP3I(0:N1ST,0:N2ND,0:N3RD))

      ALLOCATE (IGFIL(0:NLIMPS))
      ALLOCATE (IGJUM0(0:NLIMPS))
      ALLOCATE (IGJUM1(0:NLIMPS,NLIMPB))
      ALLOCATE (IGJUM2(0:NLIMPS,NLIMPB))
      ALLOCATE (IGJUM3(0:NOPTIM,NLIMPB))

      WRITE (55,'(A,T25,I15)')
     .       ' CLGIN ',(NLIMPS+1)*(10*NSPZ+7)*8 +
     .                 (2*NOPTIM+(NLIMPS+1)*(9+4*NSPZ)+9*NSTS+
     .                  (N1ST+1)*(N2ND+1)*(N3RD+1))*4 +
     .                 ((NLIMPS+1)*(2+2*NLIMPB)+
     .                  NLIMPS*(NOPTIM+1))*4

      CALL INIT_CLGIN

      RETURN
      END SUBROUTINE ALLOC_CLGIN


      SUBROUTINE DEALLOC_CLGIN

      IF (.NOT.ALLOCATED(RLWMN)) RETURN

      DEALLOCATE (RLWMN)
      DEALLOCATE (RLWMX)
      DEALLOCATE (EWALL)
      DEALLOCATE (EWBIN)
      DEALLOCATE (TRANSP)
      DEALLOCATE (FSHEAT)
      DEALLOCATE (ZNML)
      DEALLOCATE (ZNCL)
      DEALLOCATE (RECYCF)
      DEALLOCATE (RECYCT)
      DEALLOCATE (RECPRM)
      DEALLOCATE (EXPPL)
      DEALLOCATE (EXPEL)
      DEALLOCATE (EXPIL)
      DEALLOCATE (RECYCS)
      DEALLOCATE (RECYCC)
      DEALLOCATE (SPTPRM)

      DEALLOCATE (ILSWCH)
      DEALLOCATE (ILEQUI)
      DEALLOCATE (ILTOR)
      DEALLOCATE (ILSIDE)
      DEALLOCATE (ILIIN)
      DEALLOCATE (ILREF)
      DEALLOCATE (ILSPT)
      DEALLOCATE (ILCOL)
      DEALLOCATE (ILFIT)
      DEALLOCATE (ILCELL)
      DEALLOCATE (ILBOX)
      DEALLOCATE (ILPLG)
      DEALLOCATE (ISPUT)

      DEALLOCATE (NLIMII)
      DEALLOCATE (NLIMIE)
      DEALLOCATE (ISWICH)
      DEALLOCATE (ILBLCK)
      DEALLOCATE (ILACLL)
      DEALLOCATE (JUMLIM)
      DEALLOCATE (INUMP)
      DEALLOCATE (IRPTA)
      DEALLOCATE (IRPTE)
      DEALLOCATE (ISRF)
      DEALLOCATE (ISRT)
      DEALLOCATE (ISRS)
      DEALLOCATE (ISRC)
      DEALLOCATE (INMP1I)
      DEALLOCATE (INMP2I)
      DEALLOCATE (INMP3I)

      DEALLOCATE (IGFIL)
      DEALLOCATE (IGJUM0)
      DEALLOCATE (IGJUM1)
      DEALLOCATE (IGJUM2)
      DEALLOCATE (IGJUM3)

      RETURN
      END SUBROUTINE DEALLOC_CLGIN


      SUBROUTINE INIT_CLGIN

      RLWMN  = 1.E-5_DP
      RLWMX  = 1.E5_DP
      EWALL  = 0.0388_DP
      EWBIN  = 0._DP
      TRANSP = 0._DP
      FSHEAT = 0._DP
      ZNML   = 5626._DP
      ZNCL   = 0._DP
      RECYCF = 1._DP
      RECYCT = 1._DP
      RECPRM = 0._DP
      EXPPL  = 1._DP
      EXPEL  = 0.5_DP
      EXPIL  = 0._DP
      RECYCS = 1._DP
      RECYCC = 1._DP
      SPTPRM = 0._DP

      ILSWCH = 0
      ILEQUI = 0
      ILTOR  = 0
      ILSIDE = 0
      ILIIN  = 1
      ILREF  = 2
      ILSPT  = 0
      ILCOL  = 1
      ILFIT  = 0
      ILCELL = 0
      ILBOX  = 0
      ILPLG  = 0
      ISPUT  = 0

      NLIMII = 0
      NLIMIE = 0
      ISWICH = 0
      ILBLCK = 0
      ILACLL = 0
      JUMLIM = 0
      INUMP  = 0
      IRPTA  = 0
      IRPTE  = 0
      ISRF   = 0
      ISRT   = 0
      ISRS   = 0
      ISRC   = 0
      INMP1I = 0
      INMP2I = 0
      INMP3I = 0

      IGFIL  = 0
      IGJUM0 = 0
      IGJUM1 = 0
      IGJUM2 = 0
      IGJUM3 = 0

      RETURN
      END SUBROUTINE INIT_CLGIN


      SUBROUTINE SET_DEF_SURF_DATA

      INTEGER :: NBITS, ISTS, IERROR, J, I
C
C  SET DEFAULT 'ADDITIONAL SURFACE' DATA
C
      NBITS=BIT_SIZE(I)
      IF (NOPTM1 > NBITS) THEN
        CALL MASPRM('NOPTM1',6,NOPTM1,'NBITS',5,NBITS,IERROR)
        CALL EXIT_OWN(1)
      END IF
      IF (NLIMPB >= NLIMPS) THEN
        DO J=1,NLIMPS
          IGJUM2(J,J) = 1
        END DO
      ELSE
        DO J=1,NLIMPS
          CALL BITSET (IGJUM2,0,NLIMPS,J,J,1,NBITS)
        END DO
      END IF
C
C  SET DEFAULT 'STANDARD SURFACE' DATA
C
      DO ISTS=1,NSTS
        IRPTA(ISTS,1)=1
        IRPTE(ISTS,1)=MAX(2,N1ST)
        INUMP(ISTS,1)=0
C  DEFAULT POLOIDAL INDICES FOR "NON DEFAULT STANDARD SURFACES"
        IRPTA(ISTS,2)=1
        IRPTE(ISTS,2)=MAX(2,N2ND)
        INUMP(ISTS,2)=0
C  DEFAULT TOROIDAL INDICES FOR "NON DEFAULT STANDARD SURFACES"
        IRPTA(ISTS,3)=1
        IRPTE(ISTS,3)=MAX(2,N3RD)
        INUMP(ISTS,3)=0
      END DO

      RETURN
      END SUBROUTINE SET_DEF_SURF_DATA


      END MODULE CLGIN
C ===== SOURCE: clmsur.f
      MODULE CLMSUR

      USE PRECISION

      IMPLICIT NONE

      PUBLIC

!  data for one particular additional surface MSURF, but without label
!  only used in PLOT.F

      REAL(DP), PUBLIC, SAVE ::
     R A,       B,       C,       D,       E,       F,
     R XL1,     XL2,     YL1,     YL2,
     R AHALB,   BHALB,   XM,      YM,
     R SINA,    COSA,    A0,      A1,      ZL1,     ZL2,     ZPLT,
     R XC1,     XC2,     YC1,     YC2,
     R ALIN(9), XLIN(9), YLIN(9), ZLIN(9),
     R A0S(9),  A1S(9),  A2S(9),  A3S(9),  A4S(9),  A5S(9),
     R A6S(9),  A7S(9),  A8S(9),  A9S(9)

      INTEGER, PUBLIC, SAVE ::
     I MLIN,    MSCN

      END MODULE CLMSUR
C ===== SOURCE: clogau.f
!pb  30.11.06: ltstv added for testing purposes

      MODULE CLOGAU

      USE PRECISION

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CLOGAU

      LOGICAL, PUBLIC, TARGET, SAVE :: LLOGAU(31)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L NLSCL,  NLDRFT, NLCRR,  NLTEST, NLANA,  NLERG,  NLMOVIE, NLPLAS,
     L NLRAD,  NLSLB,  NLCRC,  NLELL,  NLTRI,  NLPLG,  NLGEN,
     L NLFEM,  NLTET,
     L NLPOL,  NLPLY,  NLPLA,  NLPLP,
     L NLTOR,  NLTRZ,  NLTRA,  NLTRT,
     L NLMLT,  NLADD,
     L NLTRIM, LHABER, LRCHRD, LTSTV

      CONTAINS


      SUBROUTINE ALLOC_CLOGAU

      NLSCL   => LLOGAU(1)
      NLDRFT  => LLOGAU(2)
      NLCRR   => LLOGAU(3)
      NLTEST  => LLOGAU(4)
      NLANA   => LLOGAU(5)
      NLERG   => LLOGAU(6)
      NLMOVIE => LLOGAU(7)
      NLPLAS  => LLOGAU(8)
      NLRAD   => LLOGAU(9)
      NLSLB   => LLOGAU(10)
      NLCRC   => LLOGAU(11)
      NLELL   => LLOGAU(12)
      NLTRI   => LLOGAU(13)
      NLPLG   => LLOGAU(14)
      NLGEN   => LLOGAU(15)
      NLFEM   => LLOGAU(16)
      NLTET   => LLOGAU(17)
      NLPOL   => LLOGAU(18)
      NLPLY   => LLOGAU(19)
      NLPLA   => LLOGAU(20)
      NLPLP   => LLOGAU(21)
      NLTOR   => LLOGAU(22)
      NLTRZ   => LLOGAU(23)
      NLTRA   => LLOGAU(24)
      NLTRT   => LLOGAU(25)
      NLMLT   => LLOGAU(26)
      NLADD   => LLOGAU(27)
      NLTRIM  => LLOGAU(28)
      LHABER  => LLOGAU(29)
      LRCHRD  => LLOGAU(30)
      LTSTV   => LLOGAU(31)

      LLOGAU = .FALSE.

      END SUBROUTINE ALLOC_CLOGAU

      END MODULE CLOGAU
C ===== SOURCE: comnnl.f
!pb  31.10.06:  definition of RPART, RPARTC, IPART, IPARTC changed
!               RPART(NPARTT,NPRNL) --> RPART(NPRNL,NPARTT)

      MODULE COMNNL

      USE PRECISION
      USE PARMMOD
!pb      USE COMPRT , ONLY : NPARTT, MPARTT

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMNNL, DEALLOC_COMNNL, INIT_COMNNL

      REAL(DP), PUBLIC, SAVE ::
     R  DTIMV,  DTIMVI, DTIMVN, TIME0

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  RPART(:,:), RPARTC(:,:), RPARTW(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I  IPART(:,:), IPARTC(:,:),
     I  NPRNLS(:)

      INTEGER, PUBLIC, SAVE ::
     I  NPRNLI, IPRNLI, IPRNLS, IPRNL,
     I  NPTST,  NTMSTP, ITMSTP

      INTEGER, PUBLIC, SAVE ::
     I  NCMNNL, MCMNNL


      CONTAINS


      SUBROUTINE ALLOC_COMNNL

      IF (ALLOCATED(RPART)) RETURN

      ALLOCATE (RPART(NPARTT,NPRNL))
      ALLOCATE (RPARTC(NPARTT,NPRNL))
      ALLOCATE (RPARTW(0:NPRNL))

      ALLOCATE (IPART(MPARTT,NPRNL))
      ALLOCATE (IPARTC(MPARTT,NPRNL))
      ALLOCATE (NPRNLS(NSTRA))

      WRITE (55,'(A,T25,I15)')
     .      ' COMNNL ',(2*NPRNL*NPARTT+NPRNL+1)*8 +
     .                 (2*NPRNL*MPARTT+NSTRA)*4

      CALL INIT_COMNNL

      RETURN
      END SUBROUTINE ALLOC_COMNNL


      SUBROUTINE DEALLOC_COMNNL

      IF (.NOT.ALLOCATED(RPART)) RETURN

      DEALLOCATE (RPART)
      DEALLOCATE (RPARTC)
      DEALLOCATE (RPARTW)

      DEALLOCATE (IPART)
      DEALLOCATE (IPARTC)
      DEALLOCATE (NPRNLS)

      RETURN
      END SUBROUTINE DEALLOC_COMNNL


      SUBROUTINE INIT_COMNNL

      RPART  = 0._DP
      RPARTC = 0._DP
      RPARTW = 0._DP

      IPART  = 0
      IPARTC = 0
      NPRNLS = 0

      NPRNLI = 0
      IPRNLI = 0 
      IPRNLS = 0 
      IPRNL  = 0
      NPTST  = 0   
      NTMSTP = 0  
      ITMSTP = 0

      RETURN
      END SUBROUTINE INIT_COMNNL

      END MODULE COMNNL
C ===== SOURCE: comprt.f
!pb  30.10.06:  XNUE removed
      MODULE COMPRT

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMPRT, DEALLOC_COMPRT, INIT_COMPRT, EVENT_TYPE

      TYPE :: EVENT_TYPE
        INTEGER :: NCELL, ITYP, ISPEZ, IFLAG
        REAL(DP) :: E0, WEIGHT
      END TYPE EVENT_TYPE

      TYPE(EVENT_TYPE), PUBLIC, SAVE :: LAST_EVENT

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RPST(:)

      REAL(DP), PUBLIC, POINTER, SAVE :: RPSTT(:)

C NPARTT PARTICLE COORDINATES FOR CENSUS ARRAY
C NPARTC PARTICLE COORDINATES, REAL, (E.G.: SPLITTING)
      REAL(DP), PUBLIC, POINTER, SAVE ::
     R X0,     Y0,     Z0,
     R VEL,    VELX,   VELY,   VELZ,
     R E0,     WEIGHT, TIME,   PHI,
     R XGENER

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R TIMINT(:), TIMPOL(:,:)

      REAL(DP), PUBLIC, SAVE ::
     R TL,     TT,     TS,     TF,     ZT,         ZDT1,
     R CRTX,   CRTY,   CRTZ,   SCOS,   SCOS_SAVE,  WGHTSP, WGHTSC,
     R CRTXG,  CRTYG,  CRTZG

      REAL(DP), PUBLIC, SAVE ::
     R VEL_MEAN, VELX_MEAN, VELY_MEAN, VELZ_MEAN, E0_MEAN

      REAL(DP), PUBLIC, SAVE :: STEMIS, STWEI, DE0_RAYL, DE0_RAYR

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE :: E0_RAY(:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: IPSTD(:)

      INTEGER, PUBLIC, POINTER, SAVE :: IPST(:), IPSTT(:)

C MPARTT PARTICLE COORDINATES FOR CENSUS ARRAY
C MPARTC PARTICLE COORDINATES, INTEGER, (E.G.: SPLITTING)
      INTEGER, PUBLIC, POINTER, SAVE ::
     I NPANU,
     I IPOLG,  IPERID, NCELL,
     I ITIME,  IFPATH, IUPDTE,
     I ISTRA,
     I ISPZ,
     I MRSURF, MPSURF, MTSURF, MASURF, MSURF,
     I MSURFG

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NTIM(:), IIMPOL(:,:), IIMINT(:)

      INTEGER, PUBLIC, SAVE ::
     I NRCELL, NPCELL, NTCELL, NACELL, NBLOCK, NBLCKA, NSTCLL,
     I IC_NEUT, IC_ION,
     I ITYP,   IATM,   IMOL,   IION,   IPLS,   IPHOT,
     I ICOL,   IPOLGN, NINCX,  NINCY,  NINCZ,  NINCA,  NJUMP,
     I IUNIN,  IUNOUT, NIMINT, ITRJ

      LOGICAL, PUBLIC, SAVE ::
     L LGPART, LGLAST, LGTIME,
     L NLSRFX, NLSRFY, NLSRFZ, NLSRFA,
     L NLTRC,  NLSTOR, NLTRJ


      CONTAINS


      SUBROUTINE ALLOC_COMPRT

      IF (ALLOCATED(RPST)) RETURN

      ALLOCATE (RPST(NPARTC))
      ALLOCATE (IPSTD(MPARTC+1))

      ALLOCATE (TIMINT(NRADS))
      ALLOCATE (TIMPOL(N1STS,N2NDPLG))
      ALLOCATE (NTIM(NRADS))
      ALLOCATE (IIMPOL(N1STS,N2NDPLG))
      ALLOCATE (IIMINT(NRADS))

      WRITE (55,'(A,T25,I15)')
     .      ' COMPRT ',(NPARTC+NRADS+N1STS*N2NDPLG)*8 +
     .                 (MPARTC+1+NRADS+N1STS*N2NDPLG+NRADS)*4

      RPSTT => RPST

      X0     => RPST( 1)
      Y0     => RPST( 2)
      Z0     => RPST( 3)
      VEL    => RPST( 4)
      VELX   => RPST( 5)
      VELY   => RPST( 6)
      VELZ   => RPST( 7)
      E0     => RPST( 8)
      WEIGHT => RPST( 9)
      TIME   => RPST(10)
      PHI    => RPST(11)
      XGENER => RPST(12)

      IPST  => IPSTD(2:MPARTC+1)
      IPSTT => IPSTD(1:MPARTT)

      NPANU  => IPSTD( 1)
      IPOLG  => IPSTD( 2)
      IPERID => IPSTD( 3)
      NCELL  => IPSTD( 4)
      ITIME  => IPSTD( 5)
      IFPATH => IPSTD( 6)
      IUPDTE => IPSTD( 7)
      ISTRA  => IPSTD( 8)
      ISPZ   => IPSTD( 9)
      MRSURF => IPSTD(10)
      MPSURF => IPSTD(11)
      MTSURF => IPSTD(12)
      MASURF => IPSTD(13)
      MSURF  => IPSTD(14)
      MSURFG => IPSTD(15)

      CALL INIT_COMPRT

      RETURN
      END SUBROUTINE ALLOC_COMPRT


      SUBROUTINE DEALLOC_COMPRT

      IF (.NOT.ALLOCATED(RPST)) RETURN

      DEALLOCATE (RPST)
      DEALLOCATE (IPSTD)

      DEALLOCATE (TIMINT)
      DEALLOCATE (TIMPOL)
      DEALLOCATE (NTIM)
      DEALLOCATE (IIMPOL)

      RETURN
      END SUBROUTINE DEALLOC_COMPRT


      SUBROUTINE INIT_COMPRT

      RPST   = 0._DP
      IPSTD  = 0._DP

      TIMINT = 0._DP
      TIMPOL = 0._DP
      NTIM   = 0.
      IIMPOL = 0.
      IIMINT = 0.

      TL     = 0._DP
      TT     = 0._DP
      TS     = 0._DP
      TF     = 0._DP
      ZT     = 0._DP
      ZDT1   = 0._DP
      CRTX   = 0._DP
      CRTY   = 0._DP
      CRTZ   = 0._DP
      SCOS   = 0._DP
      SCOS_SAVE  = 0._DP
      WGHTSP = 0._DP
      WGHTSC = 0._DP
      CRTXG  = 0._DP
      CRTYG  = 0._DP
      CRTZG  = 0._DP

      NRCELL = 0
      NPCELL = 0
      NTCELL = 0
      NACELL = 0
      NBLOCK = 0
      NBLCKA = 0
      NSTCLL = 0
      IC_NEUT= 0
      IC_ION = 0
      ITYP   = 0
      IATM   = 0
      IMOL   = 0
      IION   = 0
      IPLS   = 0
      IPHOT  = 0
      ICOL   = 0
      IPOLGN = 0
      NINCX  = 0
      NINCY  = 0
      NINCZ  = 0
      NINCA  = 0
      NJUMP  = 0
      IUNIN  = 0
      IUNOUT = 0
      NIMINT = 0
      ITRJ   = 0

      LGPART = .FALSE.
      LGLAST = .FALSE.
      LGTIME = .FALSE.
      NLSRFX = .FALSE.
      NLSRFY = .FALSE.
      NLSRFZ = .FALSE.
      NLSRFA = .FALSE.
      NLTRC  = .FALSE.
      NLSTOR = .FALSE.
      NLTRJ  = .FALSE.

      LAST_EVENT%IFLAG  = 0
      LAST_EVENT%NCELL  = 0
      LAST_EVENT%ITYP   = 0
      LAST_EVENT%ISPEZ  = 0
      LAST_EVENT%E0     = 0._DP
      LAST_EVENT%WEIGHT = 0._DP

      DE0_RAYL = 0._DP
      DE0_RAYR = 0._DP

      RETURN
      END SUBROUTINE INIT_COMPRT

      END MODULE COMPRT
C ===== SOURCE: comsig.f
      MODULE COMSIG

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMSIG, DEALLOC_COMSIG, INIT_COMSIG

      INTEGER, PUBLIC, SAVE ::
     P         NCMSIG, MCMSIG

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCMSIG(:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R        FUFFER(:,:), ENERGY(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R        XCHORD(:), YCHORD(:), ZCHORD(:),
     R        XPIVOT(:), YPIVOT(:), ZPIVOT(:),
     R        TILINE(:), TINP(:),   EMIN1(:),  EMAX1(:), ESHIFT(:)
      REAL(DP), PUBLIC, ALLOCATABLE :: RECADD(:,:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICMSIG(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I         IPIVOT(:), ICHORD(:),
     I         NSPSTR(:), NSPSPZ(:),
     I         NSPBLC(:), NSPADD(:),
     I         NCHTAL(:), NSPINI(:), NSPEND(:),
     I         NSPSCL(:), NSPNEW(:)
      INTEGER, PUBLIC, ALLOCATABLE :: INTADD(:,:)
      INTEGER, PUBLIC :: NCTSIG

      INTEGER, PUBLIC, SAVE ::
     I         NCHORI,    NCHORD,    NCHENI

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE :: NLSTCHR(:)


      CONTAINS

      SUBROUTINE ALLOC_COMSIG

      IF (ALLOCATED(RCMSIG)) RETURN

      NCMSIG=11*NCHOR
      MCMSIG=11*NCHOR

      ALLOCATE (RCMSIG(NCMSIG))
      ALLOCATE (FUFFER(NCHOR,NCHEN))
      ALLOCATE (ENERGY(NCHEN))
      ALLOCATE (ICMSIG(MCMSIG))
      ALLOCATE (NLSTCHR(NCHOR))

      WRITE (55,'(A,T25,I15)')
     .      ' COMSIG ',(NCMSIG+(NCHOR+1)*NCHEN)+8 + (MCMSIG+NCHOR)*4

      XCHORD => RCMSIG( 0*NCHOR+1 :  1*NCHOR)
      YCHORD => RCMSIG( 1*NCHOR+1 :  2*NCHOR)
      ZCHORD => RCMSIG( 2*NCHOR+1 :  3*NCHOR)
      XPIVOT => RCMSIG( 3*NCHOR+1 :  4*NCHOR)
      YPIVOT => RCMSIG( 4*NCHOR+1 :  5*NCHOR)
      ZPIVOT => RCMSIG( 5*NCHOR+1 :  6*NCHOR)
      TILINE => RCMSIG( 6*NCHOR+1 :  7*NCHOR)
      TINP   => RCMSIG( 7*NCHOR+1 :  8*NCHOR)
      EMIN1  => RCMSIG( 8*NCHOR+1 :  9*NCHOR)
      EMAX1  => RCMSIG( 9*NCHOR+1 : 10*NCHOR)
      ESHIFT => RCMSIG(10*NCHOR+1 : 11*NCHOR)

      IPIVOT => ICMSIG( 0*NCHOR+1 :  1*NCHOR)
      ICHORD => ICMSIG( 1*NCHOR+1 :  2*NCHOR)
      NSPSTR => ICMSIG( 2*NCHOR+1 :  3*NCHOR)
      NSPSPZ => ICMSIG( 3*NCHOR+1 :  4*NCHOR)
      NSPBLC => ICMSIG( 4*NCHOR+1 :  5*NCHOR)
      NSPADD => ICMSIG( 5*NCHOR+1 :  6*NCHOR)
      NCHTAL => ICMSIG( 6*NCHOR+1 :  7*NCHOR)
      NSPINI => ICMSIG( 7*NCHOR+1 :  8*NCHOR)
      NSPEND => ICMSIG( 8*NCHOR+1 :  9*NCHOR)
      NSPSCL => ICMSIG( 9*NCHOR+1 : 10*NCHOR)
      NSPNEW => ICMSIG(10*NCHOR+1 : 11*NCHOR)

      RETURN
      END SUBROUTINE ALLOC_COMSIG


      SUBROUTINE DEALLOC_COMSIG

      IF (.NOT.ALLOCATED(RCMSIG)) RETURN

      DEALLOCATE (RCMSIG)
      DEALLOCATE (FUFFER)
      DEALLOCATE (ENERGY)
      DEALLOCATE (ICMSIG)
      DEALLOCATE (NLSTCHR)

      RETURN
      END SUBROUTINE DEALLOC_COMSIG


      SUBROUTINE INIT_COMSIG

      RCMSIG = 0._DP
      FUFFER = 0._DP
      ENERGY = 0._DP
      ICMSIG = 0
C
C  SET DEFAULTS FOR LINE OF SIGHT INTEGRATION (BLOCK 12)
C
      NSPBLC = 1
      NSPADD = 0
      NSPNEW = 0

      NLSTCHR = .FALSE.

      RETURN
      END SUBROUTINE INIT_COMSIG

      END MODULE COMSIG
C ===== SOURCE: comsou.f
!PB 02.03.06: NLRAY ADDED, 
!             NLRAY=.TRUE. : store trajectories and use ray-tracing for this stratum
      MODULE COMSOU

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMSOU, DEALLOC_COMSOU, INIT_COMSOU

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        RCMSOU(:,:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R FLUX(:),     SCALV(:),    RAYFRAC(:),
     R SORENI(:),   SORENE(:),
     R SORVDX(:),   SORVDY(:),   SORVDZ(:),
     R SORCOS(:),   SORMAX(:),
     R SORCTX(:),   SORCTY(:),   SORCTZ(:),
     R SORWGT(:,:), SOREXP(:,:),
     R SORLIM(:,:), SORIND(:,:), SORIFL(:,:),
     R SORAD1(:,:), SORAD2(:,:), SORAD3(:,:),
     R SORAD4(:,:), SORAD5(:,:), SORAD6(:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R SREC(:,:),   EIO(:,:),    EEL(:,:),   MOM(:,:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     I         ICMSOU(:,:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I IVLSF(:),   ISCLS(:),   ISCLT(:),   ISCL1(:),  ISCL2(:),
     I ISCL3(:),   ISCLB(:),   ISCLA(:),
     I NRSOR(:,:), NPSOR(:,:), NTSOR(:,:),
     I NBSOR(:,:), NASOR(:,:), NISOR(:,:),
     I INDIM(:,:), INSOR(:,:), ISTOR(:,:),
     I NSPEZ(:),   NPTS(:),    NINITL(:),  NEMODS(:),
     I NAMODS(:),  NSRFSI(:),  NRAYEN(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I INGRDA(:,:,:), INGRDE(:,:,:)

      INTEGER, PUBLIC, SAVE ::
     I NSTRAI, NOMSOU, MOMSOU, LOMSOU

      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     L         LCMSOU(:,:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L NLPNT(:),  NLLNE(:),  NLSRF(:),  NLVOL(:),  NLCNS(:),
     L NLMOL(:),  NLATM(:),  NLION(:),  NLPLS(:),  NLPHOT(:),
     L NLAVRP(:), NLAVRT(:), NLSRON(:), NLRAY(:)

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L NLSYMP(:), NLSYMT(:)


      CONTAINS


      SUBROUTINE ALLOC_COMSOU (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(RCMSOU)) RETURN

        NOMSOU=11*NSTRA*NSRFS+13*NSTRA
        MOMSOU=9*NSTRA*NSRFS+15*NSTRA
        LOMSOU=14*NSTRA

        ALLOCATE (RCMSOU(13+11*NSRFS,NSTRA))
        ALLOCATE (ICMSOU(15+9*NSRFS,NSTRA))
        ALLOCATE (LCMSOU(14,NSTRA))

        ALLOCATE (INGRDA(NSRFS,NSTRA,3))
        ALLOCATE (INGRDE(NSRFS,NSTRA,3))

        ALLOCATE (NLSYMP(0:NSTRA))
        ALLOCATE (NLSYMT(0:NSTRA))

        WRITE (55,'(A,T25,I15)')
     .        ' COMSOU ',NOMSOU*8 + (MOMSOU+NSRFS*NSTRA*6)*4 +
     .                  (LOMSOU+2*(NSTRA+1))*4

        FLUX   => RCMSOU( 1,:)
        SCALV  => RCMSOU( 2,:)
        SORENI => RCMSOU( 3,:)
        SORENE => RCMSOU( 4,:)
        SORVDX => RCMSOU( 5,:)
        SORVDY => RCMSOU( 6,:)
        SORVDZ => RCMSOU( 7,:)
        SORCOS => RCMSOU( 8,:)
        SORMAX => RCMSOU( 9,:)
        SORCTX => RCMSOU(10,:)
        SORCTY => RCMSOU(11,:)
        SORCTZ => RCMSOU(12,:)
        RAYFRAC => RCMSOU(13,:)
        SORWGT => RCMSOU(14+ 0*NSRFS : 13+ 1*NSRFS,:)
        SOREXP => RCMSOU(14+ 1*NSRFS : 13+ 2*NSRFS,:)
        SORLIM => RCMSOU(14+ 2*NSRFS : 13+ 3*NSRFS,:)
        SORIND => RCMSOU(14+ 3*NSRFS : 13+ 4*NSRFS,:)
        SORIFL => RCMSOU(14+ 4*NSRFS : 13+ 5*NSRFS,:)
        SORAD1 => RCMSOU(14+ 5*NSRFS : 13+ 6*NSRFS,:)
        SORAD2 => RCMSOU(14+ 6*NSRFS : 13+ 7*NSRFS,:)
        SORAD3 => RCMSOU(14+ 7*NSRFS : 13+ 8*NSRFS,:)
        SORAD4 => RCMSOU(14+ 8*NSRFS : 13+ 9*NSRFS,:)
        SORAD5 => RCMSOU(14+ 9*NSRFS : 13+10*NSRFS,:)
        SORAD6 => RCMSOU(14+10*NSRFS : 13+11*NSRFS,:)

        IVLSF  => ICMSOU( 1,:)
        ISCLS  => ICMSOU( 2,:)
        ISCLT  => ICMSOU( 3,:)
        ISCL1  => ICMSOU( 4,:)
        ISCL2  => ICMSOU( 5,:)
        ISCL3  => ICMSOU( 6,:)
        ISCLB  => ICMSOU( 7,:)
        ISCLA  => ICMSOU( 8,:)
        NSPEZ  => ICMSOU( 9,:)
        NPTS   => ICMSOU(10,:)
        NINITL => ICMSOU(11,:)
        NEMODS => ICMSOU(12,:)
        NAMODS => ICMSOU(13,:)
        NSRFSI => ICMSOU(14,:)
        NRAYEN => ICMSOU(15,:)
        NRSOR  => ICMSOU(16+ 0*NSRFS : 15+ 1*NSRFS,:)
        NPSOR  => ICMSOU(16+ 1*NSRFS : 15+ 2*NSRFS,:)
        NTSOR  => ICMSOU(16+ 2*NSRFS : 15+ 3*NSRFS,:)
        NBSOR  => ICMSOU(16+ 3*NSRFS : 15+ 4*NSRFS,:)
        NASOR  => ICMSOU(16+ 4*NSRFS : 15+ 5*NSRFS,:)
        NISOR  => ICMSOU(16+ 5*NSRFS : 15+ 6*NSRFS,:)
        INDIM  => ICMSOU(16+ 6*NSRFS : 15+ 7*NSRFS,:)
        INSOR  => ICMSOU(16+ 7*NSRFS : 15+ 8*NSRFS,:)
        ISTOR  => ICMSOU(16+ 8*NSRFS : 15+ 9*NSRFS,:)

        NLPNT  => LCMSOU( 1,:)
        NLLNE  => LCMSOU( 2,:)
        NLSRF  => LCMSOU( 3,:)
        NLVOL  => LCMSOU( 4,:)
        NLCNS  => LCMSOU( 5,:)
        NLMOL  => LCMSOU( 6,:)
        NLATM  => LCMSOU( 7,:)
        NLION  => LCMSOU( 8,:)
        NLPLS  => LCMSOU( 9,:)
        NLPHOT => LCMSOU(10,:)
        NLAVRP => LCMSOU(11,:)
        NLAVRT => LCMSOU(12,:)
        NLSRON => LCMSOU(13,:)
        NLRAY  => LCMSOU(14,:)

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(SREC)) RETURN

        ALLOCATE (SREC(0:NPLS,0:NREC))
        ALLOCATE (EIO(0:NPLS,0:NREC))
        ALLOCATE (EEL(0:NPLS,0:NREC))
        ALLOCATE (MOM(0:NPLS,0:NREC))

      END IF

      CALL INIT_COMSOU(ICAL)

      RETURN
      END SUBROUTINE ALLOC_COMSOU


      SUBROUTINE DEALLOC_COMSOU

      IF (ALLOCATED(RCMSOU)) THEN

        DEALLOCATE (RCMSOU)
        DEALLOCATE (ICMSOU)
        DEALLOCATE (LCMSOU)

        DEALLOCATE (INGRDA)
        DEALLOCATE (INGRDE)

        DEALLOCATE (NLSYMP)
        DEALLOCATE (NLSYMT)
      END IF

      IF (ALLOCATED(SREC)) THEN
        DEALLOCATE (SREC)
        DEALLOCATE (EIO)
        DEALLOCATE (EEL)
        DEALLOCATE (MOM)
      END IF

      RETURN
      END SUBROUTINE DEALLOC_COMSOU


      SUBROUTINE INIT_COMSOU (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        RCMSOU = 0._DP
        ICMSOU = 0
        LCMSOU = .FALSE.
        NLSRON = .TRUE.

        INGRDA = 0
        INGRDE = 0

        NLSYMP = .FALSE.
        NLSYMT = .FALSE.

      ELSE IF (ICAL == 2) THEN

        SREC   = 0._DP
        EIO    = 0._DP
        EEL    = 0._DP
        MOM    = 0._DP

      END IF

      RETURN
      END SUBROUTINE INIT_COMSOU

      END MODULE COMSOU
C ===== SOURCE: comspl.f
!pb  31.10.06:  definition of RSPLST, ISPLST changed
!               RSPLST(15,NPARTC) --> RSPLST(NPARTC,15)

      MODULE COMSPL

      USE PRECISION
      USE PARMMOD
!pb      USE COMPRT , ONLY : NPARTC, MPARTC

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMSPL, DEALLOC_COMSPL, INIT_COMSPL

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCMSPL(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R WMINV,    WMINS,     WMINC,     WMINL,     SPLPAR,
     R RNUMB(:), PRMSPL(:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R RSPLST(:,:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICMSPL(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I MAXLEV, NLEVEL,
     I MAXRAD, MAXPOL, MAXTOR, MAXADD,
     I NODES(:), NSSPL(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I ISPLST(:,:)

      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE :: LCMSPL(:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L NLSPLT(:),
     L NLPRCA(:), NLPRCM(:), NLPRCI(:), NLPRCPH(:)

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L NLPRCS(:)

      INTEGER, PUBLIC, SAVE ::
     I NCMSPL, MCMSPL, KCMSPL


      CONTAINS


      SUBROUTINE ALLOC_COMSPL

      IF (ALLOCATED(RCMSPL)) RETURN

      NCMSPL=2*(N1ST+N2ND+N3RD+NLIM)+5
      MCMSPL=N1ST+N2ND+N3RD+NLIM+21
      KCMSPL=N1ST+N2ND+N3RD+NLIM+NATM+NMOL+NION+NPHOT

      ALLOCATE (RCMSPL(NCMSPL))
      ALLOCATE (ICMSPL(MCMSPL))
      ALLOCATE (LCMSPL(KCMSPL))

      ALLOCATE (RSPLST(NPARTC,15))
      ALLOCATE (ISPLST(MPARTC,15))
      ALLOCATE (NLPRCS(0:NLIMPS))

      WRITE (55,'(A,T25,I15)')
     .       ' COMSPL ',(NCMSPL+15*NPARTC)*8 +
     .                  (MCMSPL+15*MPARTC)*4 + (KCMSPL+NLIMPS+1)*4

      WMINV  => RCMSPL(1)
      WMINS  => RCMSPL(2)
      WMINC  => RCMSPL(3)
      WMINL  => RCMSPL(4)
      SPLPAR => RCMSPL(5)
      RNUMB  => RCMSPL(6:5+N1ST+N2ND+N3RD+NLIM)
      PRMSPL => RCMSPL(6+N1ST+N2ND+N3RD+NLIM : NCMSPL)

      MAXLEV => ICMSPL(1)
      NLEVEL => ICMSPL(2)
      MAXRAD => ICMSPL(3)
      MAXPOL => ICMSPL(4)
      MAXTOR => ICMSPL(5)
      MAXADD => ICMSPL(6)
      NODES  => ICMSPL(7:21)
      NSSPL  => ICMSPL(22:MCMSPL)

      NLPRCA => LCMSPL(1:NATM)
      NLPRCM => LCMSPL(1+NATM:NATM+NMOL)
      NLPRCI => LCMSPL(1+NATM+NMOL:NATM+NMOL+NION)
      NLPRCPH=> LCMSPL(1+NATM+NMOL+NION:NATM+NMOL+NION+NPHOT)
      NLSPLT => LCMSPL(1+NATM+NMOL+NION+NPHOT:KCMSPL)

      CALL INIT_COMSPL

      RETURN
      END SUBROUTINE ALLOC_COMSPL


      SUBROUTINE DEALLOC_COMSPL

      IF (.NOT.ALLOCATED(RCMSPL)) RETURN

      DEALLOCATE (RCMSPL)
      DEALLOCATE (ICMSPL)
      DEALLOCATE (LCMSPL)

      DEALLOCATE (RSPLST)
      DEALLOCATE (ISPLST)
      DEALLOCATE (NLPRCS)

      RETURN
      END SUBROUTINE DEALLOC_COMSPL


      SUBROUTINE INIT_COMSPL

      RCMSPL = 0._DP
      ICMSPL = 0
      LCMSPL = .FALSE.

      RSPLST = 0._DP
      ISPLST = 0
      NLPRCS = .FALSE.

      RETURN
      END SUBROUTINE INIT_COMSPL

      END MODULE COMSPL
C ===== SOURCE: comusr.f
      MODULE COMUSR

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMUSR, DEALLOC_COMUSR, INIT_COMUSR

      INTEGER, PUBLIC, SAVE ::
     P NPLPR1, NPLPRM, NSFPRM, NPLPR2,
     P NUSR,   MUSR,   LUSR

      REAL(DP), ALLOCATABLE, PUBLIC, SAVE ::
C  NPLPRM, REAL. THE FIRST NPLPR1 DATA ARE SET IN SUBROUTINE PLASMA
     R        TEIN(:),   TIIN(:,:),   DEIN(:),   DIIN(:,:),
     R        VXIN(:,:), VYIN(:,:),   VZIN(:,:),
     R        BXIN(:),   BYIN(:),     BZIN(:),   BFIN(:),
     R        ADIN(:,:), EDRIFT(:,:), VOL(:),    WGHT(:,:),
     R        BXPERP(:), BYPERP(:),
C  NSFPRM
     R        FLXOUT(:), SAREA(:),
C  NPLPR2, REAL
     R        TEINL(:),  TIINL(:,:),  DEINL(:),  DIINL(:,:), BVIN(:,:),
     R        PARMOM(:,:),
     R        RMASSI(:), RMASSA(:),   RMASSM(:), RMASSP(:),
     R        DIOD(:),   DATD(:),     DMLD(:),   DPLD(:),    DPHD(:),
     R        DION(:),   DATM(:),     DMOL(:),   DPLS(:),    DPHOT(:)

      REAL(DP), PUBLIC, SAVE :: TVAC, DVAC, VVAC, ALLOC

      REAL, PUBLIC, ALLOCATABLE, SAVE ::
     R TEDTEDX(:), TEDTEDY(:), TEDTEDZ(:)

      CHARACTER(8), ALLOCATABLE, PUBLIC, SAVE :: TEXTS(:)

C  MUSR, INTEGER
      INTEGER, PUBLIC, SAVE ::
     I         NSPH  , NPHOTI, NPHOTIM,
     I         NSPA  , NATMI,  NATMIM,
     I         NSPAM , NMOLI,  NMOLIM,
     I         NSPAMI, NIONI,  NIONIM,
     I         NSPTOT, NPLSI,  NPLSIM,
     I         NSNVI,  NCPVI,  NADVI,   NBGVI,
     I         NALVI,  NCLVI,  NADSI,   NALSI, NAINI, NBITS
      INTEGER, ALLOCATABLE, PUBLIC, SAVE ::
     I         NMASSA(:), NCHARA(:), NFOLA(:),  NGENA(:),
     I         NMASSM(:), NCHARM(:), NFOLM(:),  NGENM(:),
     I         NMASSI(:), NCHARI(:), NCHRGI(:), NFOLI(:), NGENI(:),
     I         NMASSP(:), NCHARP(:), NCHRGP(:),
     I         NFOLPH(:), NGENPH(:),
     I         NPRT(:),   ISPEZ(:,:,:,:,:,:),     ISPEZI(:,:),
     I         MPLSTI(:), MPLSV(:)
      INTEGER, ALLOCATABLE, PUBLIC, SAVE ::
     I         ISPZ_BACK(:,:)

C  LUSR, LOGICAL
      LOGICAL, ALLOCATABLE, PUBLIC, SAVE ::
     L         LGVAC(:,:), LGDFT(:)

C FROM HERE ON: NO EQUIVALENCE
      INTEGER, ALLOCATABLE, PUBLIC, SAVE ::
     I         IADVE(:),  IADVS(:), IADVT(:),  IADRC(:),
     I         ICLVE(:),  ICLVS(:), ICLVT(:),  ICLRC(:),
     I         ISNVE(:),  ISNVS(:), ISNVT(:),  ISNRC(:),
     I         ICPVE(:),  ICPVS(:), ICPVT(:),  ICPRC(:),
     I         IBGVE(:),  IBGVS(:), IBGVT(:),  IBGRC(:),
     I         IADSE(:),  IADSS(:), IADST(:),  IADSC(:),
     I         NFRSTP(:), NADDP(:), NSPAN(:),  NSPEN(:)

      INTEGER, PUBLIC, SAVE ::
     I         NMACH, NMODE,  NTCPU,
     I         NFILE, NFILEN, NFILEM, NFILEL, NFILEK, NFILEJ,
     I         NITER, IITER,  NTIME,  ITIMV

      TYPE(SPECT_ARRAY), PUBLIC, ALLOCATABLE, SAVE :: BACK_SPEC(:)
      LOGICAL, PUBLIC, ALLOCATABLE, SAVE :: LSPCCLL(:)


      CONTAINS


      SUBROUTINE ALLOC_COMUSR (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(TEIN)) RETURN

        NSFPRM=2*NLMPGS
        NPLPR1=(8+1*NPLS+NPLSTI+3*NPLSV)*NRAD
        NPLPRM=NPLPR1+(1+1*NPLS+NSPZMC)*NRAD
        NPLPR2=(2+3*NPLS+NPLSTI)*NRAD+
     .          3*(NATM+NMOL+NION+NPLS)+4+NSPZ+2*NPHOT
        NUSR=NPLPRM+NPLPR2+NSFPRM
        MUSR=4*NATM+4*NMOL+5*NION+3*NPLS+25+NSPZ+
     .       6*(1+NPHOTP)*(1+NATMP)*(1+NMOLP)*(1+NIONP)*(1+NPLSP)+NSPZ*6
     .       +2*NPLSI+NSPZ*NPLS
        LUSR=NRAD*(NPLS+2)+NRAD
C
        ALLOCATE (TEIN(NRAD))
        ALLOCATE (TIIN(NPLSTI,NRAD))
        ALLOCATE (DEIN(NRAD))
        ALLOCATE (DIIN(NPLS,NRAD))
        ALLOCATE (VXIN(NPLSV,NRAD))
        ALLOCATE (VYIN(NPLSV,NRAD))
        ALLOCATE (VZIN(NPLSV,NRAD))
        ALLOCATE (BXIN(NRAD))
        ALLOCATE (BYIN(NRAD))
        ALLOCATE (BZIN(NRAD))
        ALLOCATE (BFIN(NRAD))
        ALLOCATE (VOL(NRAD))
        ALLOCATE (WGHT(NSPZMC,NRAD))
        ALLOCATE (BXPERP(NRAD))
        ALLOCATE (BYPERP(NRAD))
        ALLOCATE (FLXOUT(NLMPGS))
        ALLOCATE (SAREA(NLMPGS))
        ALLOCATE (TEINL(NRAD))
        ALLOCATE (TIINL(NPLSTI,NRAD))
        ALLOCATE (BVIN(NPLSV,NRAD))
        ALLOCATE (PARMOM(NPLS,NRAD))
        ALLOCATE (EDRIFT(NPLS,NRAD))
        ALLOCATE (DEINL(NRAD))
        ALLOCATE (DIINL(NPLS,NRAD))
        ALLOCATE (RMASSI(NION))
        ALLOCATE (RMASSA(NATM))
        ALLOCATE (RMASSM(NMOL))
        ALLOCATE (RMASSP(NPLS))
        ALLOCATE (DIOD(NION))
        ALLOCATE (DATD(NATM))
        ALLOCATE (DMLD(NMOL))
        ALLOCATE (DPLD(NPLS))
        ALLOCATE (DPHD(NPHOT))
        ALLOCATE (DION(NION))
        ALLOCATE (DATM(NATM))
        ALLOCATE (DMOL(NMOL))
        ALLOCATE (DPLS(NPLS))
        ALLOCATE (DPHOT(NPHOT))

        ALLOCATE (TEDTEDX(NRTAL))
        ALLOCATE (TEDTEDY(NRTAL))
        ALLOCATE (TEDTEDZ(NRTAL))

        ALLOCATE (TEXTS(NSPZ))
        ALLOCATE (NMASSA(NATM))
        ALLOCATE (NCHARA(NATM))
        ALLOCATE (NFOLA(NATM))
        ALLOCATE (NGENA(NATM))
        ALLOCATE (NMASSM(NMOL))
        ALLOCATE (NCHARM(NMOL))
        ALLOCATE (NFOLM(NMOL))
        ALLOCATE (NGENM(NMOL))
        ALLOCATE (NMASSP(NPLS))
        ALLOCATE (NCHARP(NPLS))
        ALLOCATE (NCHRGP(NPLS))
        ALLOCATE (NMASSI(NION))
        ALLOCATE (NCHARI(NION))
        ALLOCATE (NCHRGI(NION))
        ALLOCATE (NFOLI(NION))
        ALLOCATE (NGENI(NION))
        ALLOCATE (NFOLPH(NPHOT))
        ALLOCATE (NGENPH(NPHOT))
        ALLOCATE (NPRT(NSPZ))
        ALLOCATE (ISPEZ(-1:4,0:NPHOTP,0:NATMP,0:NMOLP,0:NIONP,0:NPLSP))
        ALLOCATE (ISPEZI(NSPZ,-1:4))
        ALLOCATE (MPLSTI(NPLS))
        ALLOCATE (MPLSV(NPLS))
        ALLOCATE (ISPZ_BACK(NSPZ,NPLS))
        ALLOCATE (IADVE(NADV))
        ALLOCATE (IADVS(NADV))
        ALLOCATE (IADVT(NADV))
        ALLOCATE (IADRC(NADV))
        ALLOCATE (ICLVE(NCLV))
        ALLOCATE (ICLVS(NCLV))
        ALLOCATE (ICLVT(NCLV))
        ALLOCATE (ICLRC(NCLV))
        ALLOCATE (ISNVE(NSNV))
        ALLOCATE (ISNVS(NSNV))
        ALLOCATE (ISNVT(NSNV))
        ALLOCATE (ISNRC(NSNV))
        ALLOCATE (IADSE(NADS))
        ALLOCATE (IADSS(NADS))
        ALLOCATE (IADST(NADS))
        ALLOCATE (IADSC(NADS))
        ALLOCATE (NFRSTP(NTALI))
        ALLOCATE (NADDP(NTALI))
        ALLOCATE (NSPAN(NTALV))
        ALLOCATE (NSPEN(NTALV))
        ALLOCATE (LGVAC(NRAD,0:NPLS+1))
        ALLOCATE (LGDFT(NRAD))
        ALLOCATE (LSPCCLL(NRAD))

        WRITE (55,'(A,T25,I15)')
     .        ' COMUSR(1) ',NUSR*8 + MUSR*4 + LUSR*4 + 3*NRTAL*8

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(ADIN)) RETURN

        NPLPR1=(8+1*NPLS+NPLSTI+3*NPLSV)*NRAD
        NPLPRM=NPLPR1+(1+1*NPLS+NSPZMC+NAIN)*NRAD
        ALLOCATE (ADIN(NAIN,NRAD))
        ALLOCATE (ICPVE(NCPV))
        ALLOCATE (ICPVS(NCPV))
        ALLOCATE (ICPVT(NCPV))
        ALLOCATE (ICPRC(NCPV))
        ALLOCATE (IBGVE(NBGV))
        ALLOCATE (IBGVS(NBGV))
        ALLOCATE (IBGVT(NBGV))
        ALLOCATE (IBGRC(NBGV))

        WRITE (55,'(A,T25,I15)')
     .         ' COMUSR(2) ',NAIN*NRAD*8 + 4*(NCPV+NBGV)*4

      END IF

      CALL INIT_COMUSR(ICAL)

      RETURN
      END SUBROUTINE ALLOC_COMUSR


      SUBROUTINE DEALLOC_COMUSR
C
      IF (.NOT.ALLOCATED(TEIN)) RETURN

      DEALLOCATE (TEIN)
      DEALLOCATE (TIIN)
      DEALLOCATE (DEIN)
      DEALLOCATE (DIIN)
      DEALLOCATE (VXIN)
      DEALLOCATE (VYIN)
      DEALLOCATE (VZIN)
      DEALLOCATE (BXIN)
      DEALLOCATE (BYIN)
      DEALLOCATE (BZIN)
      DEALLOCATE (BFIN)
      DEALLOCATE (ADIN)
      DEALLOCATE (VOL)
      DEALLOCATE (WGHT)
      DEALLOCATE (BXPERP)
      DEALLOCATE (BYPERP)
      DEALLOCATE (FLXOUT)
      DEALLOCATE (SAREA)
      DEALLOCATE (TEINL)
      DEALLOCATE (TIINL)
      DEALLOCATE (BVIN)
      DEALLOCATE (PARMOM)
      DEALLOCATE (EDRIFT)
      DEALLOCATE (DEINL)
      DEALLOCATE (DIINL)
      DEALLOCATE (RMASSI)
      DEALLOCATE (RMASSA)
      DEALLOCATE (RMASSM)
      DEALLOCATE (RMASSP)
      DEALLOCATE (DIOD)
      DEALLOCATE (DATD)
      DEALLOCATE (DMLD)
      DEALLOCATE (DPLD)
      DEALLOCATE (DPHD)
      DEALLOCATE (DION)
      DEALLOCATE (DATM)
      DEALLOCATE (DMOL)
      DEALLOCATE (DPLS)
      DEALLOCATE (DPHOT)

      DEALLOCATE (TEDTEDX)
      DEALLOCATE (TEDTEDY)
      DEALLOCATE (TEDTEDZ)

      DEALLOCATE (TEXTS)
      DEALLOCATE (NMASSA)
      DEALLOCATE (NCHARA)
      DEALLOCATE (NFOLA)
      DEALLOCATE (NGENA)
      DEALLOCATE (NMASSM)
      DEALLOCATE (NCHARM)
      DEALLOCATE (NFOLM)
      DEALLOCATE (NGENM)
      DEALLOCATE (NMASSP)
      DEALLOCATE (NCHARP)
      DEALLOCATE (NCHRGP)
      DEALLOCATE (NMASSI)
      DEALLOCATE (NCHARI)
      DEALLOCATE (NCHRGI)
      DEALLOCATE (NFOLI)
      DEALLOCATE (NGENI)
      DEALLOCATE (NFOLPH)
      DEALLOCATE (NGENPH)
      DEALLOCATE (NPRT)
      DEALLOCATE (ISPEZ)
      DEALLOCATE (ISPEZI)
      DEALLOCATE (MPLSTI)
      DEALLOCATE (MPLSV)
      DEALLOCATE (ISPZ_BACK)
      DEALLOCATE (IADVE)
      DEALLOCATE (IADVS)
      DEALLOCATE (IADVT)
      DEALLOCATE (IADRC)
      DEALLOCATE (ICLVE)
      DEALLOCATE (ICLVS)
      DEALLOCATE (ICLVT)
      DEALLOCATE (ICLRC)
      DEALLOCATE (ISNVE)
      DEALLOCATE (ISNVS)
      DEALLOCATE (ISNVT)
      DEALLOCATE (ISNRC)
      DEALLOCATE (ICPVE)
      DEALLOCATE (ICPVS)
      DEALLOCATE (ICPVT)
      DEALLOCATE (ICPRC)
      DEALLOCATE (IBGVE)
      DEALLOCATE (IBGVS)
      DEALLOCATE (IBGVT)
      DEALLOCATE (IBGRC)
      DEALLOCATE (IADSE)
      DEALLOCATE (IADSS)
      DEALLOCATE (IADST)
      DEALLOCATE (IADSC)
      DEALLOCATE (NFRSTP)
      DEALLOCATE (NADDP)
      DEALLOCATE (NSPAN)
      DEALLOCATE (NSPEN)
      DEALLOCATE (LGVAC)
      DEALLOCATE (LGDFT)
      DEALLOCATE (LSPCCLL)

!pb      IF (NBACK_SPEC > 0) DEALLOCATE (BACK_SPEC)
      IF (ALLOCATED(BACK_SPEC)) DEALLOCATE (BACK_SPEC)

      RETURN
      END SUBROUTINE DEALLOC_COMUSR


      SUBROUTINE INIT_COMUSR(ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        TEIN   = 0._DP
        TIIN   = 0._DP
        DEIN   = 0._DP
        DIIN   = 0._DP
        VXIN   = 0._DP
        VYIN   = 0._DP
        VZIN   = 0._DP
        BXIN   = 0._DP
        BYIN   = 0._DP
        BZIN   = 0._DP
        BFIN   = 0._DP
        VOL    = 0._DP
        WGHT   = 1._DP
        BXPERP = 0._DP
        BYPERP = 0._DP
        FLXOUT = 0._DP
        SAREA  = 666._DP
        TEINL  = 0._DP
        TIINL  = 0._DP
        BVIN   = 0._DP
        PARMOM = 0._DP
        EDRIFT = 0._DP
        DEINL  = 0._DP
        DIINL  = 0._DP
        RMASSI = 0._DP
        RMASSA = 0._DP
        RMASSM = 0._DP
        RMASSP = 0._DP
        DIOD   = 0._DP
        DATD   = 0._DP
        DMLD   = 0._DP
        DPLD   = 0._DP
        DPHD   = 0._DP
        DION   = 0._DP
        DATM   = 0._DP
        DMOL   = 0._DP
        DPLS   = 0._DP
        DPHOT  = 0._DP

        TEDTEDX = 0._DP
        TEDTEDY = 0._DP
        TEDTEDZ = 0._DP

        TEXTS  = ' '
        NMASSA = 0
        NCHARA = 0
        NFOLA  = 0
        NGENA  = 0
        NMASSM = 0
        NCHARM = 0
        NFOLM  = 0
        NGENM  = 0
        NMASSP = 0
        NCHARP = 0
        NCHRGP = 0
        NMASSI = 0
        NCHARI = 0
        NCHRGI = 0
        NFOLI  = 0
        NGENI  = 0
        NFOLPH = 0
        NGENPH = 0
        NPRT   = 0
        ISPEZ  = 0
        ISPEZI = 0
        MPLSTI = 0
        MPLSV  = 0
        ISPZ_BACK = 0
        IADVE  = 0
        IADVS  = 0
        IADVT  = 0
        IADRC  = 0
        ICLVE  = 0
        ICLVS  = 0
        ICLVT  = 0
        ICLRC  = 0
        ISNVE  = 0
        ISNVS  = 0
        ISNVT  = 0
        ISNRC  = 0
        IADSE  = 0
        IADSS  = 0
        IADST  = 0
        IADSC  = 0
        NFRSTP = 0
        NADDP  = 0
        NSPAN  = 0
        NSPEN  = 0
        LGVAC  = .FALSE.
        LGDFT  = .FALSE.
        LSPCCLL = .FALSE.

      ELSE IF (ICAL == 2) THEN

        ADIN   = 0._DP
        ICPVE  = 0
        ICPVS  = 0
        ICPVT  = 0
        ICPRC  = 0
        IBGVE  = 0
        IBGVS  = 0
        IBGVT  = 0
        IBGRC  = 0

      END IF

      RETURN
      END SUBROUTINE INIT_COMUSR

      END MODULE COMUSR
C ===== SOURCE: comxs.f
      MODULE COMXS

!  jan-05: natprc_2,..... introduced
!  07.12.05: bugfix: IFTFLG is now available for default reactions too
!                    via dimensioning IFTFLG(-10:NREAC)
!  30.08.06: data structure for reaction data redefined
!  12.10.06: modcol revised
!  19.12.06: test functions added which allow to test if a rate-coefficient
!            is defined via ADAS database

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COMXS, DEALLOC_COMXS,
     .          INIT_CMDTA,  WRITE_CMDTA,   READ_CMDTA,
     .          WRITE_CMAMF, READ_CMAMF, CMDTA_XDR, CMAMF_XDR,
     .          LINE_DATA, GET_REACTION, POLY_DATA,
     .          REACTION_DATA, SET_REACTION_DATA, ADAS_DATA, 
     .          FIT_FORMS, IS_RTC_ADAS, IS_RTCEW_ADAS, IS_RTCMW_ADAS

      TYPE LINE_DATA
        REAL(DP) :: E0, E1, AIK, G1, G2, C2, C3, C4, C6, B12, B21
        REAL(DP) :: C6A(12)
        INTEGER :: IGND, IRCART, IPROFILETYPE, IFREMD, NRJPRT
        INTEGER :: IPLSC6(12)
        CHARACTER(50) :: REACNAME
      END TYPE LINE_DATA

      TYPE ADAS_DATA
        INTEGER :: NDENS, NTEMP
        REAL(DP), POINTER :: DENS(:), TEMP(:), FIT(:,:)
        REAL(DP), POINTER :: DDE(:), DTE(:)
      END TYPE ADAS_DATA

      TYPE POLY_DATA
        INTEGER :: IFEXMN, IFEXMX
        REAL(DP), POINTER :: DBLPOL(:,:)
        REAL(DP) :: RCMN, RCMX, FPARM(6)
      END TYPE POLY_DATA

      TYPE FIT_FORMS
        INTEGER :: IFIT
        TYPE(POLY_DATA), POINTER :: POLY
        TYPE(ADAS_DATA), POINTER :: ADAS
        TYPE(LINE_DATA), POINTER :: LINE
      END TYPE FIT_FORMS

      TYPE REACTION_DATA
        TYPE(FIT_FORMS), POINTER :: POT, CRS, RTC, RTCMW, RTCEW, 
     T                              OTH, PHR
        LOGICAL :: LPOT, LCRS, LRTC, LRTCMW, LRTCEW, LOTH, LPHR
      END TYPE REACTION_DATA


      TYPE(LINE_DATA), POINTER, PUBLIC, SAVE :: REACTION
      INTEGER, PUBLIC, SAVE :: IDREAC

      TYPE(REACTION_DATA), ALLOCATABLE, PUBLIC, SAVE :: REACDAT(:)


      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        XSTOR(:,:), XSTORV(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
c  reaction rates, by reaction
     R SIGVCX(:),   SIGVPI(:),   SIGVEI(:),   SIGVEL(:),
c  energy exchange rates, by reaction
     R ESIGCX(:,:), ESIGPI(:,:), ESIGEI(:,:), ESIGEL(:,:),
c  momentum exchange rates, by reaction
     R VSIGCX(:),   VSIGPI(:),   VSIGEL(:),
c  totals
     R SIGCXT,      SIGPIT,      SIGEIT,      SIGELT,      SIGTOT,
     R SIGBGK,      
c  invers mean free path
     R ZMFPI

      REAL(DP), PUBLIC, SAVE :: ZMFPTHI, TDGTEMX

csw added OTHER (OT) reactions
      REAL(DP), PUBLIC, POINTER, SAVE :: SIGVOT(:),   ESIGOT(:,:),
     R SIGOTT

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R TABDS1(:,:),   TABRC1(:,:),
     R TABPI3(:,:,:), TABCX3(:,:,:), TABEL3(:,:,:),
     R FDLMPI(:),     FDLMCX(:),     FDLMEL(:),
     R ADDPI(:,:),    ADDCX(:,:),    ADDEL(:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R PELDS(:),  PATDS(:,:), PMLDS(:,:), PIODS(:,:), PPLDS(:,:),
     R PELPI(:),  PATPI(:,:), PMLPI(:,:), PIOPI(:,:), PPLPI(:,:),
     R P2ND(:,:), P2NP(:,:),  P2NDS(:),   P2NPI(:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R EELDS1(:,:),   EHVDS1(:,:),   EELRC1(:,:),
     R EPLPI3(:,:,:), EPLCX3(:,:,:), EPLEL3(:,:,:), EPLOT3(:,:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R EATDS(:,:,:), EMLDS(:,:,:), EIODS(:,:,:), EPLDS(:,:),
     R EATPI(:,:),   EMLPI(:,:),   EIOPI(:,:),   EPLPI(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I MODCOL(:,:,:),
     I IESTCX(:,:), IESTEL(:,:), IESTPI(:,:), IESTEI(:,:),
     I NAEII(:),    NMDSI(:),    NIDSI(:),
     I NACXI(:),    NMCXI(:),    NICXI(:),
     I NAELI(:),    NMELI(:),    NIELI(:),
     I NAPII(:),    NMPII(:),    NIPII(:),
     I NAEIIM(:),   NMDSIM(:),   NIDSIM(:),
     I NACXIM(:),   NMCXIM(:),   NICXIM(:),
     I NAELIM(:),   NMELIM(:),   NIELIM(:),
     I NAPIIM(:),   NMPIIM(:),   NIPIIM(:),
     I NPRCI(:),    NPRCIM(:),
     I NPBGKA(:),   NPBGKM(:),   NPBGKI(:), NPBGKP(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NATPRC(:),  NMLPRC(:), NIOPRC(:), NPLPRC(:), NPHPRC(:),
     I NATPRC_2(:),  NMLPRC_2(:), NIOPRC_2(:), NPLPRC_2(:), NPHPRC_2(:),
     I N1STX(:,:), N2NDX(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NSEACX(:,:,:), NSEMCX(:,:,:), NSEICX(:,:,:),
     I NSEAEL(:,:,:), NSEMEL(:,:,:), NSEIEL(:,:,:),
     I NSEPRC(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NREACX(:),NREAPI(:),NREAEL(:),
     I NREAEI(:),JEREAEI(:),NREARC(:),JEREARC(:),
     I NELREI(:),JELREI(:),NREAHV(:),NELREL(:),
     I NELRRC(:),JELRRC(:),NELRPI(:),NELRCX(:),
     I NELROT(:),NREAOT(:),NREACT(:),
     I IPATDS(:,:),IPMLDS(:,:),
     I IPIODS(:,:),IPPLDS(:,:),
     I IPATPI(:,:),IPMLPI(:,:),
     I IPIOPI(:,:),IPPLPI(:,:),
     I LGACX(:,:,:),LGMCX(:,:,:),
     I LGICX(:,:,:),
     I LGAEI(:,:),    LGMEI(:,:),
     I LGIEI(:,:),
     I LGAEL(:,:,:),LGMEL(:,:,:),
     I LGIEL(:,:,:),
     I LGPRC(:,:),
     I LGAPI(:,:,:),LGMPI(:,:,:),
     I LGIPI(:,:,:)

      INTEGER, PUBLIC, SAVE ::
     I NRPII, NREII, NRCXI, NRELI, NRRCI, NRBGI

      INTEGER, PUBLIC, SAVE ::
     I NSTOR1, NSTOR,  NSTORV, NTAB, NDAT, NMDTA, MMDTA, NAMF, MAMF,
     I MSTOR1, MSTOR2, MXCOLLS

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R DELPOT(:),   FACREA(:),
     R FREACA(:,:), FREACM(:,:), FREACI(:,:), FREACP(:,:), FREACPH(:,:),
     R FLDLMA(:,:), FLDLMM(:,:), FLDLMI(:,:), FLDLMP(:,:), FLDLMPH(:,:),
     R EELECA(:,:), EELECM(:,:), EELECI(:,:), EELECP(:,:), EELECPH(:,:),
     R EBULKA(:,:), EBULKM(:,:), EBULKI(:,:), EBULKP(:,:), EBULKPH(:,:),
     R ESCD1A(:,:), ESCD1M(:,:), ESCD1I(:,:), ESCD1P(:,:), ESCD1PH(:,:),
     R ESCD2A(:,:), ESCD2M(:,:), ESCD2I(:,:), ESCD2P(:,:), ESCD2PH(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I ISWR(:),     MODCLF(:),   MASSP(:),    MASST(:),
     I IFTFLG(:,:),
     I NRCP(:),     NRCA(:),     NRCM(:),     NRCI(:),     NRCPH(:),
     I IREACA(:,:), IREACM(:,:), IREACI(:,:), IREACP(:,:), IREACPH(:,:),
     I IBULKA(:,:), IBULKM(:,:), IBULKI(:,:), IBULKP(:,:), IBULKPH(:,:),
     I ISCD1A(:,:), ISCD1M(:,:), ISCD1I(:,:), ISCD1P(:,:), ISCD1PH(:,:),
     I ISCD2A(:,:), ISCD2M(:,:), ISCD2I(:,:), ISCD2P(:,:), ISCD2PH(:,:),
     I ISCD3A(:,:), ISCD3M(:,:), ISCD3I(:,:), ISCD3P(:,:), ISCD3PH(:,:),
     I ISCDEA(:,:), ISCDEM(:,:), ISCDEI(:,:), ISCDEP(:,:), ISCDEPH(:,:),
     I IESTMA(:,:), IESTMM(:,:), IESTMI(:,:), IESTMPH(:,:),
     I IBGKA (:,:), IBGKM (:,:), IBGKI (:,:), IBGKPH (:,:)

      INTEGER, PUBLIC, SAVE ::
     I NREACI

      CHARACTER(50), PUBLIC, ALLOCATABLE, SAVE :: REAC_NAME(:)

      CONTAINS


      SUBROUTINE ALLOC_COMXS (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(XSTORV)) RETURN

        NSTORV = 8
C
        NAMF=9*11*11+11+2*(2*11+6*11)+
     P       NREAC*(9*11+18+ 6*NPHOT+ 6*NATM+ 6*NMOL+ 6*NION+ 6*NPLS)
        MAMF=NREAC*(      8+ 8*NPHOT+ 8*NATM+ 8*NMOL+ 8*NION+ 6*NPLS)+
     P       1*NATM+ 1*NMOL+ 1*NION+ 1*NPLS+ 1 + 
     P       (11+NREAC)*10

        ALLOCATE (XSTORV(NSTORV))

        SIGCXT  => XSTORV(1)
        SIGPIT  => XSTORV(2)
        SIGEIT  => XSTORV(3)
        SIGELT  => XSTORV(4)
        SIGOTT  => XSTORV(5)
        SIGTOT  => XSTORV(6)
        SIGBGK  => XSTORV(7)
        ZMFPI   => XSTORV(8)

        ALLOCATE (NAEII(NATM))
        ALLOCATE (NMDSI(NMOL))
        ALLOCATE (NIDSI(NION))
        ALLOCATE (NACXI(NATM))
        ALLOCATE (NMCXI(NMOL))
        ALLOCATE (NICXI(NION))
        ALLOCATE (NAELI(NATM))
        ALLOCATE (NMELI(NMOL))
        ALLOCATE (NIELI(NION))
        ALLOCATE (NAPII(NATM))
        ALLOCATE (NMPII(NMOL))
        ALLOCATE (NIPII(NION))
        ALLOCATE (NPRCI(NPLS))
        ALLOCATE (NAEIIM(NATM))
        ALLOCATE (NMDSIM(NMOL))
        ALLOCATE (NIDSIM(NION))
        ALLOCATE (NACXIM(NATM))
        ALLOCATE (NMCXIM(NMOL))
        ALLOCATE (NICXIM(NION))
        ALLOCATE (NAELIM(NATM))
        ALLOCATE (NMELIM(NMOL))
        ALLOCATE (NIELIM(NION))
        ALLOCATE (NAPIIM(NATM))
        ALLOCATE (NMPIIM(NMOL))
        ALLOCATE (NIPIIM(NION))
        ALLOCATE (NPRCIM(NPLS))
        ALLOCATE (NPBGKA(NATM))
        ALLOCATE (NPBGKM(NMOL))
        ALLOCATE (NPBGKI(NION))
        ALLOCATE (NPBGKP(NPLS,2))

        ALLOCATE (NSEACX(NATM,NPLS,5))
        ALLOCATE (NSEMCX(NMOL,NPLS,5))
        ALLOCATE (NSEICX(NION,NPLS,5))
        ALLOCATE (NSEAEL(NATM,NPLS,5))
        ALLOCATE (NSEMEL(NMOL,NPLS,5))
        ALLOCATE (NSEIEL(NION,NPLS,5))

        ALLOCATE (DELPOT(NREAC))
        ALLOCATE (FACREA(-10:NREAC))
        ALLOCATE (FREACA(NATM,NREAC))
        ALLOCATE (FREACM(NMOL,NREAC))
        ALLOCATE (FREACI(NION,NREAC))
        ALLOCATE (FREACP(NPLS,NREAC))
        ALLOCATE (FREACPH(NPHOT,NREAC))
        ALLOCATE (FLDLMA(NATM,NREAC))
        ALLOCATE (FLDLMM(NMOL,NREAC))
        ALLOCATE (FLDLMI(NION,NREAC))
        ALLOCATE (FLDLMP(NPLS,NREAC))
        ALLOCATE (FLDLMPH(NPHOT,NREAC))
        ALLOCATE (EELECA(NATM,NREAC))
        ALLOCATE (EELECM(NMOL,NREAC))
        ALLOCATE (EELECI(NION,NREAC))
        ALLOCATE (EELECP(NPLS,NREAC))
        ALLOCATE (EELECPH(NPHOT,NREAC))
        ALLOCATE (EBULKA(NATM,NREAC))
        ALLOCATE (EBULKM(NMOL,NREAC))
        ALLOCATE (EBULKI(NION,NREAC))
        ALLOCATE (EBULKP(NPLS,NREAC))
        ALLOCATE (EBULKPH(NPHOT,NREAC))
        ALLOCATE (ESCD1A(NATM,NREAC))
        ALLOCATE (ESCD1M(NMOL,NREAC))
        ALLOCATE (ESCD1I(NION,NREAC))
        ALLOCATE (ESCD1P(NPLS,NREAC))
        ALLOCATE (ESCD1PH(NPHOT,NREAC))
        ALLOCATE (ESCD2A(NATM,NREAC))
        ALLOCATE (ESCD2M(NMOL,NREAC))
        ALLOCATE (ESCD2I(NION,NREAC))
        ALLOCATE (ESCD2P(NPLS,NREAC))
        ALLOCATE (ESCD2PH(NPHOT,NREAC))

        ALLOCATE (ISWR(NREAC))
        ALLOCATE (MODCLF(NREAC))
        ALLOCATE (MASSP(NREAC))
        ALLOCATE (MASST(NREAC))
        ALLOCATE (IFTFLG(-10:NREAC,0:5))
        ALLOCATE (NRCP(NPLS))
        ALLOCATE (NRCA(NATM))
        ALLOCATE (NRCM(NMOL))
        ALLOCATE (NRCI(NION))
        ALLOCATE (NRCPH(NPHOT))
        ALLOCATE (IREACA(NATM,NREAC))
        ALLOCATE (IREACM(NMOL,NREAC))
        ALLOCATE (IREACI(NION,NREAC))
        ALLOCATE (IREACP(NPLS,NREAC))
        ALLOCATE (IREACPH(NPHOT,NREAC))
        ALLOCATE (IBULKA(NATM,NREAC))
        ALLOCATE (IBULKM(NMOL,NREAC))
        ALLOCATE (IBULKI(NION,NREAC))
        ALLOCATE (IBULKP(NPLS,NREAC))
        ALLOCATE (IBULKPH(NPHOT,NREAC))
        ALLOCATE (ISCD1A(NATM,NREAC))
        ALLOCATE (ISCD1M(NMOL,NREAC))
        ALLOCATE (ISCD1I(NION,NREAC))
        ALLOCATE (ISCD1P(NPLS,NREAC))
        ALLOCATE (ISCD1PH(NPHOT,NREAC))
        ALLOCATE (ISCD2A(NATM,NREAC))
        ALLOCATE (ISCD2M(NMOL,NREAC))
        ALLOCATE (ISCD2I(NION,NREAC))
        ALLOCATE (ISCD2P(NPLS,NREAC))
        ALLOCATE (ISCD2PH(NPHOT,NREAC))
        ALLOCATE (ISCD3A(NATM,NREAC))
        ALLOCATE (ISCD3M(NMOL,NREAC))
        ALLOCATE (ISCD3I(NION,NREAC))
        ALLOCATE (ISCD3P(NPLS,NREAC))
        ALLOCATE (ISCD3PH(NPHOT,NREAC))
        ALLOCATE (ISCDEA(NATM,NREAC))
        ALLOCATE (ISCDEM(NMOL,NREAC))
        ALLOCATE (ISCDEI(NION,NREAC))
        ALLOCATE (ISCDEP(NPLS,NREAC))
        ALLOCATE (ISCDEPH(NPHOT,NREAC))
        ALLOCATE (IESTMA(NATM,NREAC))
        ALLOCATE (IESTMM(NMOL,NREAC))
        ALLOCATE (IESTMI(NION,NREAC))
        ALLOCATE (IESTMPH(NPHOT,NREAC))
        ALLOCATE (IBGKA (NATM,NREAC))
        ALLOCATE (IBGKM (NMOL,NREAC))
        ALLOCATE (IBGKI (NION,NREAC))
        ALLOCATE (IBGKPH(NPHOT,NREAC))

        ALLOCATE (REAC_NAME(NREAC))

        ALLOCATE (REACDAT(-10:NREAC))

        WRITE (55,'(A,T25,I15)')
     .        ' COMXS(1) ',(NSTORV+NAMF)*8 + (MAMF+
     .                      9*(NATM+NMOL+NION)+4*NPLS+
     .                      10*NPLS*(NATM+NMOL+NION))*4 +
     .                      NREAC*LEN(REAC_NAME(1))


      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(XSTOR)) RETURN

        NSTOR1 = NREL+NRCX+NRPI+NRDS
        NSTOR  = NSTOR1+
     .           2*(NREL+NRCX+NRPI)+5*NRDS+
     .           NREL+NRCX+NRPI
C
        NTAB=NSTORDR*(NRDS+NREC)+
     P       NSTORDR*NSTORDT*(NRCX+NREL+NRPI)+
     P       (NPLS+1)*(NRPI+NRCX+NREL)
C
        NDAT=NSTORDR*(2*NRDS+NREC+
     P       NSTORDT*(NRCX+NREL+NRPI+NROT))+
     P      (NRDS+NRPI)*
     P      (NATMP+NMOLP+NIONP+NPLSP+1)+
     P      (NRPI+NRDS)*(NSPZP+1)+
     P       NRPI*  (NATMP+NMOLP+NIONP+NPLSP)+
     P       NRDS*2*(NATMP+NMOLP+NIONP+1)
C
        NMDTA=NTAB+NDAT
C
        MMDTA=7*4*NSPZ*(1+NCOLMC)+3*(NRCX+NREL+NRPI+NRDS)+6+
     P        9*(NATM+NMOL+NION)+4*NPLS+
     P        5*NREC+
     P        6*NRCX+
     P        10*NPLS*(NATM+NMOL+NION)+
     P        10*NREC+
     P        2*NRCX+2*NRPI+2*NREL+5*NRDS+4*NREC+NREAC+
     P        (NRDS+NRPI)*
     P        (NATMP+NMOLP+NIONP+NPLSP)+
C  LG... ARRAYS
     P        (NATMP+NMOLP+NIONP      )*(NRDS+1)+
     P        2*(NATMP+NMOLP+NIONP      )*(NRCX+1)+
     P        2*(NATMP+NMOLP+NIONP      )*(NREL+1)+
     P          (                  NPLSP)*(NREC+1)+
     P        2*(NATMP+NMOLP+NIONP      )*(NRPI+1)


csw added NROT (photon.f)
        MSTOR1 = MAX(NRCX, NRPI, NRDS, NREL, NROT)
csw 18-->21
        MSTOR2 = 21

        MXCOLLS = MAX(NRPI, NRDS, NRCX, NREL, NREC, NROT)

        ALLOCATE (XSTOR(MSTOR1,MSTOR2))

        SIGVCX => XSTOR(:,1)
        SIGVPI => XSTOR(:,2)
        SIGVEI => XSTOR(:,3)
        SIGVEL => XSTOR(:,4)
        SIGVOT => XSTOR(:,19)

        ESIGCX => XSTOR(:,5:6)
        ESIGPI => XSTOR(:,7:8)
        ESIGEI => XSTOR(:,9:13)
        ESIGEL => XSTOR(:,14:15)
        ESIGOT => XSTOR(:,20:21)

        VSIGCX => XSTOR(:,16)
        VSIGPI => XSTOR(:,17)
        VSIGEL => XSTOR(:,18)
c       vsigei  : fehlt noch
c       vsigot  : fehlt noch


        ALLOCATE (TABDS1(NRDS,NSTORDR))
        ALLOCATE (TABRC1(NREC,NSTORDR))
        ALLOCATE (TABPI3(NRPI,NSTORDR,NSTORDT))
        ALLOCATE (TABCX3(NRCX,NSTORDR,NSTORDT))
        ALLOCATE (TABEL3(NREL,NSTORDR,NSTORDT))
        ALLOCATE (FDLMPI(NRPI))
        ALLOCATE (FDLMCX(NRCX))
        ALLOCATE (FDLMEL(NREL))
        ALLOCATE (ADDPI(NRPI,NPLS))
        ALLOCATE (ADDCX(NRCX,NPLS))
        ALLOCATE (ADDEL(NREL,NPLS))

        ALLOCATE (PELDS(NRDS))
        ALLOCATE (PATDS(NRDS,0:NATM))
        ALLOCATE (PMLDS(NRDS,0:NMOL))
        ALLOCATE (PIODS(NRDS,0:NION))
        ALLOCATE (PPLDS(NRDS,0:NPLS))
        ALLOCATE (PELPI(NRPI))
        ALLOCATE (PATPI(NRPI,0:NATM))
        ALLOCATE (PMLPI(NRPI,0:NMOL))
        ALLOCATE (PIOPI(NRPI,0:NION))
        ALLOCATE (PPLPI(NRPI,0:NPLS))
        ALLOCATE (P2ND(NRDS,0:NSPZ))
        ALLOCATE (P2NP(NRPI,0:NSPZ))
        ALLOCATE (P2NDS(NRDS))
        ALLOCATE (P2NPI(NRPI))

        ALLOCATE (EELDS1(NRDS,NSTORDR))
        ALLOCATE (EHVDS1(NRDS,NSTORDR))
        ALLOCATE (EELRC1(NREC,NSTORDR))
        ALLOCATE (EPLPI3(NRPI,NSTORDR,NSTORDT))
        ALLOCATE (EPLCX3(NRCX,NSTORDR,NSTORDT))
        ALLOCATE (EPLEL3(NREL,NSTORDR,NSTORDT))
        ALLOCATE (EPLOT3(NROT,NSTORDR,NSTORDT))

        ALLOCATE (EATPI(NRPI,0:NATM))
        ALLOCATE (EMLPI(NRPI,0:NMOL))
        ALLOCATE (EIOPI(NRPI,0:NION))
        ALLOCATE (EPLPI(NRPI,0:NPLS))
        ALLOCATE (EATDS(NRDS,0:NATM,2))
        ALLOCATE (EMLDS(NRDS,0:NMOL,2))
        ALLOCATE (EIODS(NRDS,0:NION,2))
        ALLOCATE (EPLDS(NRDS,2))

        ALLOCATE (MODCOL(7,0:4,MXCOLLS))
        ALLOCATE (IESTCX(NRCX,3))
        ALLOCATE (IESTEL(NREL,3))
        ALLOCATE (IESTPI(NRPI,3))
        ALLOCATE (IESTEI(NRDS,3))

        ALLOCATE (NATPRC(NREC))
        ALLOCATE (NMLPRC(NREC))
        ALLOCATE (NIOPRC(NREC))
        ALLOCATE (NPLPRC(NREC))
        ALLOCATE (NPHPRC(NREC))
        ALLOCATE (NATPRC_2(NREC))
        ALLOCATE (NMLPRC_2(NREC))
        ALLOCATE (NIOPRC_2(NREC))
        ALLOCATE (NPLPRC_2(NREC))
        ALLOCATE (NPHPRC_2(NREC))
        ALLOCATE (N1STX(NRCX,3))
        ALLOCATE (N2NDX(NRCX,3))

        ALLOCATE (NSEPRC(NREC,5))

        ALLOCATE (NREACX(NRCX))
        ALLOCATE (NREAPI(NRPI))
        ALLOCATE (NREAEL(NREL))
        ALLOCATE (NREAEI(NRDS))
        ALLOCATE (JEREAEI(NRDS))
        ALLOCATE (NREARC(NREC))
        ALLOCATE (JEREARC(NREC))
        ALLOCATE (NELREI(NRDS))
        ALLOCATE (JELREI(NRDS))
        ALLOCATE (NREAHV(NRDS))
        ALLOCATE (NELREL(NREL))
        ALLOCATE (NELRRC(NREC))
        ALLOCATE (JELRRC(NREC))
        ALLOCATE (NELRPI(NRPI))
        ALLOCATE (NELRCX(NRCX))
        ALLOCATE (NELROT(NROT))
        ALLOCATE (NREAOT(NROT))
        ALLOCATE (NREACT(NREAC))
        ALLOCATE (IPATDS(NRDS,0:NATM))
        ALLOCATE (IPMLDS(NRDS,0:NMOL))
        ALLOCATE (IPIODS(NRDS,0:NION))
        ALLOCATE (IPPLDS(NRDS,0:NPLS))
        ALLOCATE (IPATPI(NRPI,0:NATM))
        ALLOCATE (IPMLPI(NRPI,0:NMOL))
        ALLOCATE (IPIOPI(NRPI,0:NION))
        ALLOCATE (IPPLPI(NRPI,0:NPLS))
        ALLOCATE (LGACX(0:NATM,0:NRCX,0:1))
        ALLOCATE (LGMCX(0:NMOL,0:NRCX,0:1))
        ALLOCATE (LGICX(0:NION,0:NRCX,0:1))
        ALLOCATE (LGAEI(0:NATM,0:NRDS))
        ALLOCATE (LGMEI(0:NMOL,0:NRDS))
        ALLOCATE (LGIEI(0:NION,0:NRDS))
        ALLOCATE (LGAEL(0:NATM,0:NREL,0:1))
        ALLOCATE (LGMEL(0:NMOL,0:NREL,0:1))
        ALLOCATE (LGIEL(0:NION,0:NREL,0:1))
        ALLOCATE (LGPRC(0:NPLS,0:NREC))
        ALLOCATE (LGAPI(0:NATM,0:NRPI,0:1))
        ALLOCATE (LGMPI(0:NMOL,0:NRPI,0:1))
        ALLOCATE (LGIPI(0:NION,0:NRPI,0:1))

        WRITE (55,'(A,T25,I15)')
     .        ' COMXS(2) ',(MSTOR1*MSTOR2+NMDTA)*8 +
     .                     (MMDTA -
     .                      9*(NATM+NMOL+NION)-4*NPLS-
     .                      10*NPLS*(NATM+NMOL+NION))*4

      END IF

      CALL INIT_CMDTA (ICAL)

      RETURN
      END SUBROUTINE ALLOC_COMXS


      SUBROUTINE DEALLOC_COMXS

      IF (.NOT.ALLOCATED(XSTOR)) RETURN

      DEALLOCATE (XSTOR)
      DEALLOCATE (XSTORV)


      DEALLOCATE (TABDS1)
      DEALLOCATE (TABRC1)
      DEALLOCATE (TABPI3)
      DEALLOCATE (TABCX3)
      DEALLOCATE (TABEL3)
      DEALLOCATE (FDLMPI)
      DEALLOCATE (FDLMCX)
      DEALLOCATE (FDLMEL)
      DEALLOCATE (ADDPI)
      DEALLOCATE (ADDCX)
      DEALLOCATE (ADDEL)

      DEALLOCATE (PELDS)
      DEALLOCATE (PATDS)
      DEALLOCATE (PMLDS)
      DEALLOCATE (PIODS)
      DEALLOCATE (PPLDS)
      DEALLOCATE (PELPI)
      DEALLOCATE (PATPI)
      DEALLOCATE (PMLPI)
      DEALLOCATE (PIOPI)
      DEALLOCATE (PPLPI)
      DEALLOCATE (P2ND)
      DEALLOCATE (P2NP)
      DEALLOCATE (P2NDS)
      DEALLOCATE (P2NPI)

      DEALLOCATE (EELDS1)
      DEALLOCATE (EHVDS1)
      DEALLOCATE (EELRC1)
      DEALLOCATE (EPLPI3)
      DEALLOCATE (EPLCX3)
      DEALLOCATE (EPLEL3)
      DEALLOCATE (EPLOT3)

      DEALLOCATE (EATPI)
      DEALLOCATE (EMLPI)
      DEALLOCATE (EIOPI)
      DEALLOCATE (EPLPI)
      DEALLOCATE (EATDS)
      DEALLOCATE (EMLDS)
      DEALLOCATE (EIODS)
      DEALLOCATE (EPLDS)

      DEALLOCATE (MODCOL)
      DEALLOCATE (IESTCX)
      DEALLOCATE (IESTEL)
      DEALLOCATE (IESTPI)
      DEALLOCATE (IESTEI)
      DEALLOCATE (NAEII)
      DEALLOCATE (NMDSI)
      DEALLOCATE (NIDSI)
      DEALLOCATE (NACXI)
      DEALLOCATE (NMCXI)
      DEALLOCATE (NICXI)
      DEALLOCATE (NAELI)
      DEALLOCATE (NMELI)
      DEALLOCATE (NIELI)
      DEALLOCATE (NAPII)
      DEALLOCATE (NMPII)
      DEALLOCATE (NIPII)
      DEALLOCATE (NPRCI)
      DEALLOCATE (NAEIIM)
      DEALLOCATE (NMDSIM)
      DEALLOCATE (NIDSIM)
      DEALLOCATE (NACXIM)
      DEALLOCATE (NMCXIM)
      DEALLOCATE (NICXIM)
      DEALLOCATE (NAELIM)
      DEALLOCATE (NMELIM)
      DEALLOCATE (NIELIM)
      DEALLOCATE (NAPIIM)
      DEALLOCATE (NMPIIM)
      DEALLOCATE (NIPIIM)
      DEALLOCATE (NPRCIM)
      DEALLOCATE (NPBGKA)
      DEALLOCATE (NPBGKM)
      DEALLOCATE (NPBGKI)
      DEALLOCATE (NPBGKP)

      DEALLOCATE (NATPRC_2)
      DEALLOCATE (NMLPRC_2)
      DEALLOCATE (NIOPRC_2)
      DEALLOCATE (NPLPRC_2)
      DEALLOCATE (NPHPRC_2)
      DEALLOCATE (NATPRC)
      DEALLOCATE (NMLPRC)
      DEALLOCATE (NIOPRC)
      DEALLOCATE (NPLPRC)
      DEALLOCATE (NPHPRC)
      DEALLOCATE (N1STX)
      DEALLOCATE (N2NDX)

      DEALLOCATE (NSEACX)
      DEALLOCATE (NSEMCX)
      DEALLOCATE (NSEICX)
      DEALLOCATE (NSEAEL)
      DEALLOCATE (NSEMEL)
      DEALLOCATE (NSEIEL)
      DEALLOCATE (NSEPRC)

      DEALLOCATE (NREACX)
      DEALLOCATE (NREAPI)
      DEALLOCATE (NREAEL)
      DEALLOCATE (NREAEI)
      DEALLOCATE (JEREAEI)
      DEALLOCATE (NREARC)
      DEALLOCATE (JEREARC)
      DEALLOCATE (NELREI)
      DEALLOCATE (JELREI)
      DEALLOCATE (NREAHV)
      DEALLOCATE (NELREL)
      DEALLOCATE (NELRRC)
      DEALLOCATE (JELRRC)
      DEALLOCATE (NELRPI)
      DEALLOCATE (NELRCX)
      DEALLOCATE (NELROT)
      DEALLOCATE (NREAOT)
      DEALLOCATE (NREACT)
      DEALLOCATE (IPATDS)
      DEALLOCATE (IPMLDS)
      DEALLOCATE (IPIODS)
      DEALLOCATE (IPPLDS)
      DEALLOCATE (IPATPI)
      DEALLOCATE (IPMLPI)
      DEALLOCATE (IPIOPI)
      DEALLOCATE (IPPLPI)
      DEALLOCATE (LGACX)
      DEALLOCATE (LGMCX)
      DEALLOCATE (LGICX)
      DEALLOCATE (LGAEI)
      DEALLOCATE (LGMEI)
      DEALLOCATE (LGIEI)
      DEALLOCATE (LGAEL)
      DEALLOCATE (LGMEL)
      DEALLOCATE (LGIEL)
      DEALLOCATE (LGPRC)
      DEALLOCATE (LGAPI)
      DEALLOCATE (LGMPI)
      DEALLOCATE (LGIPI)

      DEALLOCATE (DELPOT)
      DEALLOCATE (FACREA)
      DEALLOCATE (FREACA)
      DEALLOCATE (FREACM)
      DEALLOCATE (FREACI)
      DEALLOCATE (FREACP)
      DEALLOCATE (FREACPH)
      DEALLOCATE (FLDLMA)
      DEALLOCATE (FLDLMM)
      DEALLOCATE (FLDLMI)
      DEALLOCATE (FLDLMP)
      DEALLOCATE (FLDLMPH)
      DEALLOCATE (EELECA)
      DEALLOCATE (EELECM)
      DEALLOCATE (EELECI)
      DEALLOCATE (EELECP)
      DEALLOCATE (EELECPH)
      DEALLOCATE (EBULKA)
      DEALLOCATE (EBULKM)
      DEALLOCATE (EBULKI)
      DEALLOCATE (EBULKP)
      DEALLOCATE (EBULKPH)
      DEALLOCATE (ESCD1A)
      DEALLOCATE (ESCD1M)
      DEALLOCATE (ESCD1I)
      DEALLOCATE (ESCD1P)
      DEALLOCATE (ESCD1PH)
      DEALLOCATE (ESCD2A)
      DEALLOCATE (ESCD2M)
      DEALLOCATE (ESCD2I)
      DEALLOCATE (ESCD2P)
      DEALLOCATE (ESCD2PH)

      DEALLOCATE (ISWR)
      DEALLOCATE (MODCLF)
      DEALLOCATE (MASSP)
      DEALLOCATE (MASST)
      DEALLOCATE (IFTFLG)
      DEALLOCATE (NRCP)
      DEALLOCATE (NRCA)
      DEALLOCATE (NRCM)
      DEALLOCATE (NRCI)
      DEALLOCATE (NRCPH)
      DEALLOCATE (IREACA)
      DEALLOCATE (IREACM)
      DEALLOCATE (IREACI)
      DEALLOCATE (IREACP)
      DEALLOCATE (IREACPH)
      DEALLOCATE (IBULKA)
      DEALLOCATE (IBULKM)
      DEALLOCATE (IBULKI)
      DEALLOCATE (IBULKP)
      DEALLOCATE (IBULKPH)
      DEALLOCATE (ISCD1A)
      DEALLOCATE (ISCD1M)
      DEALLOCATE (ISCD1I)
      DEALLOCATE (ISCD1P)
      DEALLOCATE (ISCD1PH)
      DEALLOCATE (ISCD2A)
      DEALLOCATE (ISCD2M)
      DEALLOCATE (ISCD2I)
      DEALLOCATE (ISCD2P)
      DEALLOCATE (ISCD2PH)
      DEALLOCATE (ISCD3A)
      DEALLOCATE (ISCD3M)
      DEALLOCATE (ISCD3I)
      DEALLOCATE (ISCD3P)
      DEALLOCATE (ISCD3PH)
      DEALLOCATE (ISCDEA)
      DEALLOCATE (ISCDEM)
      DEALLOCATE (ISCDEI)
      DEALLOCATE (ISCDEP)
      DEALLOCATE (ISCDEPH)
      DEALLOCATE (IESTMA)
      DEALLOCATE (IESTMM)
      DEALLOCATE (IESTMI)
      DEALLOCATE (IESTMPH)
      DEALLOCATE (IBGKA )
      DEALLOCATE (IBGKM )
      DEALLOCATE (IBGKI )
      DEALLOCATE (IBGKPH)
      DEALLOCATE (REAC_NAME)

      DEALLOCATE (REACDAT)
      RETURN
      END SUBROUTINE DEALLOC_COMXS


      SUBROUTINE INIT_CMDTA (ICAL)

      INTEGER, INTENT(IN) :: ICAL
      INTEGER :: IREAC

      IF (ICAL == 1) THEN
        NAEII   = 0
        NMDSI   = 0
        NIDSI   = 0
        NACXI   = 0
        NMCXI   = 0
        NICXI   = 0
        NAELI   = 0
        NMELI   = 0
        NIELI   = 0
        NAPII   = 0
        NMPII   = 0
        NIPII   = 0
        NPRCI   = 0
        NAEIIM  = 0
        NMDSIM  = 0
        NIDSIM  = 0
        NACXIM  = 0
        NMCXIM  = 0
        NICXIM  = 0
        NAELIM  = 0
        NMELIM  = 0
        NIELIM  = 0
        NAPIIM  = 0
        NMPIIM  = 0
        NIPIIM  = 0
        NPRCIM  = 0
        NPBGKA  = 0
        NPBGKM  = 0
        NPBGKI  = 0
        NPBGKP  = 0

        NSEACX  = 0
        NSEMCX  = 0
        NSEICX  = 0
        NSEAEL  = 0
        NSEMEL  = 0
        NSEIEL  = 0

        DELPOT  = 0._DP
        FACREA  = 0._DP
        FREACA  = 0._DP
        FREACM  = 0._DP
        FREACI  = 0._DP
        FREACP  = 0._DP
        FREACPH = 0._DP
        FLDLMA  = 0._DP
        FLDLMM  = 0._DP
        FLDLMI  = 0._DP
        FLDLMP  = 0._DP
        FLDLMPH = 0._DP
        EELECA  = 0._DP
        EELECM  = 0._DP
        EELECI  = 0._DP
        EELECP  = 0._DP
        EELECPH = 0._DP
        EBULKA  = 0._DP
        EBULKM  = 0._DP
        EBULKI  = 0._DP
        EBULKP  = 0._DP
        EBULKPH = 0._DP
        ESCD1A  = 0._DP
        ESCD1M  = 0._DP
        ESCD1I  = 0._DP
        ESCD1P  = 0._DP
        ESCD1PH = 0._DP
        ESCD2A  = 0._DP
        ESCD2M  = 0._DP
        ESCD2I  = 0._DP
        ESCD2P  = 0._DP
        ESCD2PH = 0._DP

        ZMFPTHI = 0._DP
        TDGTEMX = 1.E-30_DP

        ISWR    = 0
        MODCLF  = 0
        MASSP   = 0
        MASST   = 0
        IFTFLG  = 0
        NRCP    = 0
        NRCA    = 0
        NRCM    = 0
        NRCI    = 0
        NRCPH   = 0
        IREACA  = 0
        IREACM  = 0
        IREACI  = 0
        IREACP  = 0
        IREACPH = 0
        IBULKA  = 0
        IBULKM  = 0
        IBULKI  = 0
        IBULKP  = 0
        IBULKPH = 0
        ISCD1A  = 0
        ISCD1M  = 0
        ISCD1I  = 0
        ISCD1P  = 0
        ISCD1PH = 0
        ISCD2A  = 0
        ISCD2M  = 0
        ISCD2I  = 0
        ISCD2P  = 0
        ISCD2PH = 0
        ISCD3A  = 0
        ISCD3M  = 0
        ISCD3I  = 0
        ISCD3P  = 0
        ISCD3PH = 0
        ISCDEA  = 0
        ISCDEM  = 0
        ISCDEI  = 0
        ISCDEP  = 0
        ISCDEPH = 0
        IESTMA  = 0
        IESTMM  = 0
        IESTMI  = 0
        IESTMPH = 0
        IBGKA   = 0
        IBGKM   = 0
        IBGKI   = 0
        IBGKPH  = 0

        REAC_NAME = REPEAT(' ',LEN(REAC_NAME(1)))

        idreac  = 0

        XSTORV  = 0._DP

        DO IREAC= -10, NREAC
          REACDAT(IREAC)%LPOT   = .FALSE.
          REACDAT(IREAC)%LCRS   = .FALSE.
          REACDAT(IREAC)%LRTC   = .FALSE.
          REACDAT(IREAC)%LRTCMW = .FALSE.
          REACDAT(IREAC)%LRTCEW = .FALSE.
          REACDAT(IREAC)%LOTH   = .FALSE.
          REACDAT(IREAC)%LPHR   = .FALSE.
          NULLIFY(REACDAT(IREAC)%POT)
          NULLIFY(REACDAT(IREAC)%CRS)
          NULLIFY(REACDAT(IREAC)%RTC)
          NULLIFY(REACDAT(IREAC)%RTCMW)
          NULLIFY(REACDAT(IREAC)%RTCEW)
          NULLIFY(REACDAT(IREAC)%OTH)
          NULLIFY(REACDAT(IREAC)%PHR)
        END DO

      ELSE IF (ICAL == 2) THEN

        XSTOR  = 0._DP

        TABDS1  = 0._DP
        TABRC1  = 0._DP
        TABPI3  = 0._DP
        TABCX3  = 0._DP
        TABEL3  = 0._DP
        FDLMPI  = 0._DP
        FDLMCX  = 0._DP
        FDLMEL  = 0._DP
        ADDPI   = 0._DP
        ADDCX   = 0._DP
        ADDEL   = 0._DP

        PELDS   = 0._DP
        PATDS   = 0._DP
        PMLDS   = 0._DP
        PIODS   = 0._DP
        PPLDS   = 0._DP
        PELPI   = 0._DP
        PATPI   = 0._DP
        PMLPI   = 0._DP
        PIOPI   = 0._DP
        PPLPI   = 0._DP
        P2ND    = 0._DP
        P2NP    = 0._DP
        P2NDS   = 0._DP
        P2NPI   = 0._DP

        EELDS1  = 0._DP
        EHVDS1  = 0._DP
        EELRC1  = 0._DP
        EPLPI3  = 0._DP
        EPLCX3  = 0._DP
        EPLEL3  = 0._DP
        EPLOT3  = 0._DP

        EATPI   = 0._DP
        EMLPI   = 0._DP
        EIOPI   = 0._DP
        EPLPI   = 0._DP
        EATDS   = 0._DP
        EMLDS   = 0._DP
        EIODS   = 0._DP
        EPLDS   = 0._DP

        MODCOL  = 0
        IESTCX  = 0
        IESTEL  = 0
        IESTPI  = 0
        IESTEI  = 0

        NATPRC  = 0
        NMLPRC  = 0
        NIOPRC  = 0
        NPLPRC  = 0
        NPHPRC  = 0
        NATPRC_2= 0
        NMLPRC_2= 0
        NIOPRC_2= 0
        NPLPRC_2= 0
        NPHPRC_2= 0
        N1STX   = 0
        N2NDX   = 0

        NRPII   = 0
        NREII   = 0
        NRCXI   = 0
        NRELI   = 0
        NRRCI   = 0
        NRBGI   = 0
        NSEPRC  = 0

        NREACX  = 0
        NREAPI  = 0
        NREAEL  = 0
        NREAEI  = 0
        JEREAEI = 0
        NREARC  = 0
        JEREARC = 0
        NELREI  = 0
        JELREI  = 0
        NREAHV  = 0
        NELREL  = 0
        NELRRC  = 0
        JELRRC  = 0
        NELRPI  = 0
        NELRCX  = 0
        NELROT  = 0
        NREAOT  = 0
        NREACT  = 0
        IPATDS  = 0
        IPMLDS  = 0
        IPIODS  = 0
        IPPLDS  = 0
        IPATPI  = 0
        IPMLPI  = 0
        IPIOPI  = 0
        IPPLPI  = 0
        LGACX   = 0
        LGMCX   = 0
        LGICX   = 0
        LGAEI   = 0
        LGMEI   = 0
        LGIEI   = 0
        LGAEL   = 0
        LGMEL   = 0
        LGIEL   = 0
        LGPRC   = 0
        LGAPI   = 0
        LGMPI   = 0
        LGIPI   = 0

      END IF

      RETURN
      END SUBROUTINE INIT_CMDTA


      SUBROUTINE WRITE_CMDTA

      WRITE (13)
     . TABDS1 ,TABRC1 ,TABPI3 ,TABCX3 ,TABEL3 ,
     . FDLMPI ,FDLMCX ,FDLMEL ,
     . ADDPI  ,ADDCX  ,ADDEL  ,

     . PELDS  ,PATDS  ,PMLDS  ,PIODS  ,PPLDS  ,
     . PELPI  ,PATPI  ,PMLPI  ,PIOPI  ,PPLPI  ,
     . P2ND   ,P2NP   ,P2NDS  ,P2NPI  ,

     . EELDS1 ,EHVDS1 ,EELRC1 ,EPLPI3 ,EPLCX3 ,EPLEL3 ,EPLOT3 ,

     . EATPI  ,EMLPI  ,EIOPI  ,EPLPI  ,
     . EATDS  ,EMLDS  ,EIODS  ,EPLDS

      WRITE (13)
     . MODCOL ,IESTCX ,IESTEL ,IESTPI ,IESTEI ,
     . NAEII  ,NMDSI  ,NIDSI  ,NACXI  ,NMCXI  ,NICXI  ,
     . NAELI  ,NMELI  ,NIELI  ,NAPII  ,NMPII  ,NIPII  ,NPRCI  ,
     . NAEIIM ,NMDSIM ,NIDSIM ,NACXIM ,NMCXIM ,NICXIM ,
     . NAELIM ,NMELIM ,NIELIM ,NAPIIM ,NMPIIM ,NIPIIM ,NPRCIM ,
     . NPBGKA ,NPBGKM ,NPBGKI ,NPBGKP ,
     . NATPRC ,NMLPRC ,NIOPRC ,NPLPRC ,NPHPRC ,
     . NATPRC_2 ,NMLPRC_2 ,NIOPRC_2 ,NPLPRC_2 ,NPHPRC_2 ,
     . N1STX  ,N2NDX  ,

     . NRPII  ,NREII  ,NRCXI  ,NRELI  ,NRRCI  ,NRBGI  ,

     . NSEACX ,NSEMCX ,NSEICX ,NSEAEL ,NSEMEL ,NSEIEL ,NSEPRC ,
     . NREACX ,NREAPI ,NREAEL ,NREAEI ,JEREAEI,NREARC ,JEREARC,
     . NELREI ,JELREI ,NREAHV ,NELREL ,NELRRC ,JELRRC ,NELRPI ,NELRCX ,
     . NELROT ,NREAOT ,NREACT ,
     . IPATDS ,IPMLDS ,IPIODS ,IPPLDS ,IPATPI ,IPMLPI ,IPIOPI ,IPPLPI ,
     . LGACX  ,LGMCX  ,LGICX  ,LGAEI  ,LGMEI  ,LGIEI  ,
     . LGAEL  ,LGMEL  ,LGIEL  ,LGPRC  ,LGAPI  ,LGMPI  ,LGIPI

      RETURN
      END SUBROUTINE WRITE_CMDTA


      SUBROUTINE READ_CMDTA

      READ (13)
     . TABDS1 ,TABRC1 ,TABPI3 ,TABCX3 ,TABEL3 ,
     . FDLMPI ,FDLMCX ,FDLMEL ,
     . ADDPI  ,ADDCX  ,ADDEL  ,

     . PELDS  ,PATDS  ,PMLDS  ,PIODS  ,PPLDS  ,
     . PELPI  ,PATPI  ,PMLPI  ,PIOPI  ,PPLPI  ,
     . P2ND   ,P2NP   ,P2NDS  ,P2NPI  ,

     . EELDS1 ,EHVDS1 ,EELRC1 ,EPLPI3 ,EPLCX3 ,EPLEL3 ,EPLOT3 ,

     . EATPI  ,EMLPI  ,EIOPI  ,EPLPI  ,
     . EATDS  ,EMLDS  ,EIODS  ,EPLDS

      READ (13)
     . MODCOL ,IESTCX ,IESTEL ,IESTPI ,IESTEI ,
     . NAEII  ,NMDSI  ,NIDSI  ,NACXI  ,NMCXI  ,NICXI  ,
     . NAELI  ,NMELI  ,NIELI  ,NAPII  ,NMPII  ,NIPII  ,NPRCI  ,
     . NAEIIM ,NMDSIM ,NIDSIM ,NACXIM ,NMCXIM ,NICXIM ,
     . NAELIM ,NMELIM ,NIELIM ,NAPIIM ,NMPIIM ,NIPIIM ,NPRCIM ,
     . NPBGKA ,NPBGKM ,NPBGKI ,NPBGKP ,
     . NATPRC ,NMLPRC ,NIOPRC ,NPLPRC ,NPHPRC ,
     . NATPRC_2 ,NMLPRC_2 ,NIOPRC_2 ,NPLPRC_2 ,NPHPRC_2 ,
     . N1STX  ,N2NDX  ,

     . NRPII  ,NREII  ,NRCXI  ,NRELI  ,NRRCI  ,NRBGI  ,

     . NSEACX ,NSEMCX ,NSEICX ,NSEAEL ,NSEMEL ,NSEIEL ,NSEPRC ,
     . NREACX ,NREAPI ,NREAEL ,NREAEI ,JEREAEI,NREARC ,JEREARC,
     . NELREI ,JELREI ,NREAHV ,NELREL ,NELRRC ,JELRRC ,NELRPI ,NELRCX ,
     . NELROT ,NREAOT ,NREACT ,
     . IPATDS ,IPMLDS ,IPIODS ,IPPLDS ,IPATPI ,IPMLPI ,IPIOPI ,IPPLPI ,
     . LGACX  ,LGMCX  ,LGICX  ,LGAEI  ,LGMEI  ,LGIEI  ,
     . LGAEL  ,LGMEL  ,LGIEL  ,LGPRC  ,LGAPI  ,LGMPI  ,LGIPI

      RETURN
      END SUBROUTINE READ_CMDTA


      SUBROUTINE CMDTA_XDR (IUN)

      INTEGER, INTENT(IN) :: IUN
      INTEGER :: IHELP(1)
c
      CALL FXDRDBL (IUN,TABDS1,NRDS*NSTORDR)
      CALL FXDRDBL (IUN,TABRC1,NREC*NSTORDR)
      CALL FXDRDBL (IUN,TABPI3,NRPI*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,TABCX3,NRCX*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,TABEL3,NREL*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,FDLMPI,NRPI)
      CALL FXDRDBL (IUN,FDLMCX,NRCX)
      CALL FXDRDBL (IUN,FDLMEL,NREL)
      CALL FXDRDBL (IUN,ADDPI,NRPI*NPLS)
      CALL FXDRDBL (IUN,ADDCX,NRCX*NPLS)
      CALL FXDRDBL (IUN,ADDEL,NREL*NPLS)

      CALL FXDRDBL (IUN,PELDS,NRDS)
      CALL FXDRDBL (IUN,PATDS,NRDS*(NATM+1))
      CALL FXDRDBL (IUN,PMLDS,NRDS*(NMOL+1))
      CALL FXDRDBL (IUN,PIODS,NRDS*(NION+1))
      CALL FXDRDBL (IUN,PPLDS,NRDS*(NPLS+1))
      CALL FXDRDBL (IUN,PELPI,NRPI)
      CALL FXDRDBL (IUN,PATPI,NRPI*(NATM+1))
      CALL FXDRDBL (IUN,PMLPI,NRPI*(NMOL+1))
      CALL FXDRDBL (IUN,PIOPI,NRPI*(NION+1))
      CALL FXDRDBL (IUN,PPLPI,NRPI*(NPLS+1))
      CALL FXDRDBL (IUN,P2ND,NRDS*(NSPZ+1))
      CALL FXDRDBL (IUN,P2NP,NRPI*(NSPZ+1))
      CALL FXDRDBL (IUN,P2NDS,NRDS)
      CALL FXDRDBL (IUN,P2NPI,NRPI)

      CALL FXDRDBL (IUN,EELDS1,NRDS*NSTORDR)
      CALL FXDRDBL (IUN,EHVDS1,NRDS*NSTORDR)
      CALL FXDRDBL (IUN,EELRC1,NREC*NSTORDR)
      CALL FXDRDBL (IUN,EPLPI3,NRPI*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,EPLCX3,NRCX*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,EPLEL3,NREL*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,EPLOT3,NROT*NSTORDR*NSTORDT)
      CALL FXDRDBL (IUN,EATPI,NRPI*(NATM+1))
      CALL FXDRDBL (IUN,EMLPI,NRPI*(NMOL+1))
      CALL FXDRDBL (IUN,EIOPI,NRPI*(NION+1))
      CALL FXDRDBL (IUN,EPLPI,NRPI*(NPLS+1))
      CALL FXDRDBL (IUN,EATDS,NRDS*(NATM+1)*2)
      CALL FXDRDBL (IUN,EMLDS,NRDS*(NMOL+1)*2)
      CALL FXDRDBL (IUN,EIODS,NRDS*(NION+1)*2)
      CALL FXDRDBL (IUN,EPLDS,NRDS*2)

c
      CALL FXDRINT (IUN,MODCOL ,7*5*MXCOLLS)
      CALL FXDRINT (IUN,IESTCX ,3*NRCX)
      CALL FXDRINT (IUN,IESTEL ,3*NREL)
      CALL FXDRINT (IUN,IESTPI ,3*NRPI)
      CALL FXDRINT (IUN,IESTEI ,3*NRDS)
      CALL FXDRINT (IUN,NAEII  ,NATM)
      CALL FXDRINT (IUN,NMDSI  ,NMOL)
      CALL FXDRINT (IUN,NIDSI  ,NION)
      CALL FXDRINT (IUN,NACXI  ,NATM)
      CALL FXDRINT (IUN,NMCXI  ,NMOL)
      CALL FXDRINT (IUN,NICXI  ,NION)
      CALL FXDRINT (IUN,NAELI  ,NATM)
      CALL FXDRINT (IUN,NMELI  ,NMOL)
      CALL FXDRINT (IUN,NIELI  ,NION)
      CALL FXDRINT (IUN,NAPII  ,NATM)
      CALL FXDRINT (IUN,NMPII  ,NMOL)
      CALL FXDRINT (IUN,NIPII  ,NION)
      CALL FXDRINT (IUN,NPRCI  ,NPLS)
      CALL FXDRINT (IUN,NAEIIM ,NATM)
      CALL FXDRINT (IUN,NMDSIM ,NMOL)
      CALL FXDRINT (IUN,NIDSIM ,NION)
      CALL FXDRINT (IUN,NACXIM ,NATM)
      CALL FXDRINT (IUN,NMCXIM ,NMOL)
      CALL FXDRINT (IUN,NICXIM ,NION)
      CALL FXDRINT (IUN,NAELIM ,NATM)
      CALL FXDRINT (IUN,NMELIM ,NMOL)
      CALL FXDRINT (IUN,NIELIM ,NION)
      CALL FXDRINT (IUN,NAPIIM ,NATM)
      CALL FXDRINT (IUN,NMPIIM ,NMOL)
      CALL FXDRINT (IUN,NIPIIM ,NION)
      CALL FXDRINT (IUN,NPRCIM ,NPLS)
      CALL FXDRINT (IUN,NPBGKA ,NATM)
      CALL FXDRINT (IUN,NPBGKM ,NMOL)
      CALL FXDRINT (IUN,NPBGKI ,NION)
      CALL FXDRINT (IUN,NPBGKP ,2*NPLS)
      CALL FXDRINT (IUN,NATPRC ,NREC)
      CALL FXDRINT (IUN,NMLPRC ,NREC)
      CALL FXDRINT (IUN,NIOPRC ,NREC)
      CALL FXDRINT (IUN,NPLPRC ,NREC)
      CALL FXDRINT (IUN,NPHPRC ,NREC)
      CALL FXDRINT (IUN,NATPRC_2 ,NREC)
      CALL FXDRINT (IUN,NMLPRC_2 ,NREC)
      CALL FXDRINT (IUN,NIOPRC_2 ,NREC)
      CALL FXDRINT (IUN,NPLPRC_2 ,NREC)
      CALL FXDRINT (IUN,NPHPRC_2 ,NREC)
      CALL FXDRINT (IUN,N1STX  ,3*NRCX)
      CALL FXDRINT (IUN,N2NDX  ,3*NRCX)

      IHELP(1) = NRPII
      CALL FXDRINT (IUN, IHELP ,1)
      IHELP(1) = NREII
      CALL FXDRINT (IUN, IHELP ,1)
      IHELP(1) = NRCXI
      CALL FXDRINT (IUN, IHELP ,1)
      IHELP(1) = NRELI
      CALL FXDRINT (IUN, IHELP ,1)
      IHELP(1) = NRRCI
      CALL FXDRINT (IUN, IHELP ,1)
      IHELP(1) = NRBGI
      CALL FXDRINT (IUN, IHELP ,1)

      CALL FXDRINT (IUN,NSEACX ,5*NATM*NPLS)
      CALL FXDRINT (IUN,NSEMCX ,5*NMOL*NPLS)
      CALL FXDRINT (IUN,NSEICX ,5*NION*NPLS)
      CALL FXDRINT (IUN,NSEAEL ,5*NATM*NPLS)
      CALL FXDRINT (IUN,NSEMEL ,5*NMOL*NPLS)
      CALL FXDRINT (IUN,NSEIEL ,5*NION*NPLS)
      CALL FXDRINT (IUN,NSEPRC ,5*NREC)
      CALL FXDRINT (IUN,NREACX ,NRCX)
      CALL FXDRINT (IUN,NREAPI ,NRPI)
      CALL FXDRINT (IUN,NREAEL ,NREL)
      CALL FXDRINT (IUN,NREAEI ,NRDS)
      CALL FXDRINT (IUN,JEREAEI,NRDS)
      CALL FXDRINT (IUN,NREARC ,NREC)
      CALL FXDRINT (IUN,JEREARC,NREC)
      CALL FXDRINT (IUN,NELREI ,NRDS)
      CALL FXDRINT (IUN,JELREI ,NRDS)
      CALL FXDRINT (IUN,NREAHV ,NRDS)
      CALL FXDRINT (IUN,NELREL ,NREL)
      CALL FXDRINT (IUN,NELRRC ,NREC)
      CALL FXDRINT (IUN,JELRRC ,NREC)
      CALL FXDRINT (IUN,NELRPI ,NRPI)
      CALL FXDRINT (IUN,NELRCX ,NRCX)
      CALL FXDRINT (IUN,NELROT ,NROT)
      CALL FXDRINT (IUN,NREAOT ,NROT)
      CALL FXDRINT (IUN,NREACT ,NREAC)
      CALL FXDRINT (IUN,IPATDS ,NRDS*(NATM+1))
      CALL FXDRINT (IUN,IPMLDS ,NRDS*(NMOL+1))
      CALL FXDRINT (IUN,IPIODS ,NRDS*(NION+1))
      CALL FXDRINT (IUN,IPPLDS ,NRDS*(NPLS+1))
      CALL FXDRINT (IUN,IPATPI ,NRPI*(NATM+1))
      CALL FXDRINT (IUN,IPMLPI ,NRPI*(NMOL+1))
      CALL FXDRINT (IUN,IPIOPI ,NRPI*(NION+1))
      CALL FXDRINT (IUN,IPPLPI ,NRPI*(NPLS+1))

      CALL FXDRINT (IUN,LGACX  ,2*(NATM+1)*(NRCX+1))
      CALL FXDRINT (IUN,LGMCX  ,2*(NMOL+1)*(NRCX+1))
      CALL FXDRINT (IUN,LGICX  ,2*(NION+1)*(NRCX+1))
      CALL FXDRINT (IUN,LGAEI  ,(NATM+1)*(NRDS+1))
      CALL FXDRINT (IUN,LGMEI  ,(NMOL+1)*(NRDS+1))
      CALL FXDRINT (IUN,LGIEI  ,(NION+1)*(NRDS+1))
      CALL FXDRINT (IUN,LGAEL  ,2*(NATM+1)*(NREL+1))
      CALL FXDRINT (IUN,LGMEL  ,2*(NMOL+1)*(NREL+1))
      CALL FXDRINT (IUN,LGIEL  ,2*(NION+1)*(NREL+1))
      CALL FXDRINT (IUN,LGPRC  ,(NPLS+1)*(NREC+1))
      CALL FXDRINT (IUN,LGAPI  ,2*(NATM+1)*(NRPI+1))
      CALL FXDRINT (IUN,LGMPI  ,2*(NMOL+1)*(NRPI+1))
      CALL FXDRINT (IUN,LGIPI  ,2*(NION+1)*(NRPI+1))

      RETURN
      END SUBROUTINE CMDTA_XDR


      SUBROUTINE WRITE_CMAMF
      
      INTEGER :: IR

      WRITE (13)
     . DELPOT, FACREA, 
     . FREACA, FREACM, FREACI, FREACP, FREACPH,
     . FLDLMA, FLDLMM, FLDLMI, FLDLMP, FLDLMPH,
     . EELECA, EELECM, EELECI, EELECP, EELECPH,
     . EBULKA, EBULKM, EBULKI, EBULKP, EBULKPH,
     . ESCD1A, ESCD1M, ESCD1I, ESCD1P, ESCD1PH,
     . ESCD2A, ESCD2M, ESCD2I, ESCD2P, ESCD2PH,

     . NREACI, ISWR,   MODCLF, MASSP,  MASST,  IFTFLG,
     . NRCP,   NRCA,   NRCM,   NRCI, NRCPH,
     . IREACA, IREACM, IREACI, IREACP, IREACPH,
     . IBULKA, IBULKM, IBULKI, IBULKP, IBULKPH,
     . ISCD1A, ISCD1M, ISCD1I, ISCD1P, ISCD1PH,
     . ISCD2A, ISCD2M, ISCD2I, ISCD2P, ISCD2PH,
     . ISCD3A, ISCD3M, ISCD3I, ISCD3P, ISCD3PH,
     . ISCDEA, ISCDEM, ISCDEI, ISCDEP, ISCDEPH,
     . IESTMA, IESTMM, IESTMI, IESTMPH, IBGKA , IBGKM , IBGKI, IBGKPH

      DO IR=1,NREACI
        WRITE (13) REACDAT(IR)%LPOT,REACDAT(IR)%LCRS,REACDAT(IR)%LRTC,
     .             REACDAT(IR)%LRTCMW,REACDAT(IR)%LRTCEW,
     .             REACDAT(IR)%LOTH,REACDAT(IR)%LPHR
        IF (REACDAT(IR)%LPOT)   CALL WRITE_FIT_FORM(REACDAT(IR)%POT)
        IF (REACDAT(IR)%LCRS)   CALL WRITE_FIT_FORM(REACDAT(IR)%CRS)
        IF (REACDAT(IR)%LRTC)   CALL WRITE_FIT_FORM(REACDAT(IR)%RTC)
        IF (REACDAT(IR)%LRTCMW) CALL WRITE_FIT_FORM(REACDAT(IR)%RTCMW)
        IF (REACDAT(IR)%LRTCEW) CALL WRITE_FIT_FORM(REACDAT(IR)%RTCEW)
        IF (REACDAT(IR)%LOTH)   CALL WRITE_FIT_FORM(REACDAT(IR)%OTH)
        IF (REACDAT(IR)%LPHR)   CALL WRITE_FIT_FORM(REACDAT(IR)%PHR)
      END DO

      RETURN

      CONTAINS 

        SUBROUTINE WRITE_FIT_FORM (RP)
        TYPE(FIT_FORMS),POINTER :: RP
        
        WRITE (13) RP%IFIT

        IF (RP%IFIT < 0) THEN
! DATA FOR PHOTONIC LINE
          WRITE (13) RP%LINE%E0, RP%LINE%E1, RP%LINE%AIK, 
     .               RP%LINE%G1, RP%LINE%G2, RP%LINE%C2, 
     .               RP%LINE%C3, RP%LINE%C4, RP%LINE%C6, 
     .               RP%LINE%B12, RP%LINE%B21, RP%LINE%C6A
          WRITE (13) RP%LINE%IGND, RP%LINE%IRCART, RP%LINE%IPROFILETYPE, 
     .               RP%LINE%IFREMD, RP%LINE%NRJPRT, RP%LINE%IPLSC6
          WRITE (13) RP%LINE%REACNAME

        ELSE IF (RP%IFIT <= 2) THEN
! DATA FOR POLYNOMIAL FIT
          WRITE (13) RP%POLY%IFEXMN,RP%POLY%IFEXMX,
     .               UBOUND(RP%POLY%DBLPOL)
          WRITE (13) RP%POLY%DBLPOL,
     .               RP%POLY%RCMN,RP%POLY%RCMX,RP%POLY%FPARM

        ELSE
! ADAS DATA
        END IF

        END SUBROUTINE WRITE_FIT_FORM

      END SUBROUTINE WRITE_CMAMF


      SUBROUTINE READ_CMAMF
      
      INTEGER :: IR

      READ (13)
     . DELPOT, FACREA, 
     . FREACA, FREACM, FREACI, FREACP, FREACPH,
     . FLDLMA, FLDLMM, FLDLMI, FLDLMP, FLDLMPH,
     . EELECA, EELECM, EELECI, EELECP, EELECPH,
     . EBULKA, EBULKM, EBULKI, EBULKP, EBULKPH,
     . ESCD1A, ESCD1M, ESCD1I, ESCD1P, ESCD1PH,
     . ESCD2A, ESCD2M, ESCD2I, ESCD2P, ESCD2PH,

     . NREACI, ISWR,   MODCLF, MASSP,  MASST,  IFTFLG,
     . NRCP,   NRCA,   NRCM,   NRCI, NRCPH,
     . IREACA, IREACM, IREACI, IREACP, IREACPH,
     . IBULKA, IBULKM, IBULKI, IBULKP, IBULKPH,
     . ISCD1A, ISCD1M, ISCD1I, ISCD1P, ISCD1PH,
     . ISCD2A, ISCD2M, ISCD2I, ISCD2P, ISCD2PH,
     . ISCD3A, ISCD3M, ISCD3I, ISCD3P, ISCD3PH,
     . ISCDEA, ISCDEM, ISCDEI, ISCDEP, ISCDEPH,
     . IESTMA, IESTMM, IESTMI, IESTMPH, IBGKA , IBGKM , IBGKI, IBGKPH

      DO IR=1,NREACI
        READ (13) REACDAT(IR)%LPOT,REACDAT(IR)%LCRS,REACDAT(IR)%LRTC,
     .            REACDAT(IR)%LRTCMW,REACDAT(IR)%LRTCEW,
     .            REACDAT(IR)%LOTH,REACDAT(IR)%LPHR

        IF (REACDAT(IR)%LPOT) CALL READ_FIT_FORM(REACDAT(IR)%POT)
        IF (REACDAT(IR)%LCRS) CALL READ_FIT_FORM(REACDAT(IR)%CRS)
        IF (REACDAT(IR)%LRTC) CALL READ_FIT_FORM(REACDAT(IR)%RTC)
        IF (REACDAT(IR)%LRTCMW) CALL READ_FIT_FORM(REACDAT(IR)%RTCMW)
        IF (REACDAT(IR)%LRTCEW) CALL READ_FIT_FORM(REACDAT(IR)%RTCEW)
        IF (REACDAT(IR)%LOTH) CALL READ_FIT_FORM(REACDAT(IR)%OTH)
        IF (REACDAT(IR)%LPHR) CALL READ_FIT_FORM(REACDAT(IR)%PHR)
      END DO


      RETURN
      CONTAINS 

        SUBROUTINE READ_FIT_FORM (RP)
        TYPE(FIT_FORMS),POINTER :: RP
        INTEGER :: ND, ND2
        
        READ (13) RP%IFIT

        IF (RP%IFIT < 0) THEN
! DATA FOR PHOTONIC LINE
          IF (.NOT.ASSOCIATED(RP%LINE)) ALLOCATE (RP%LINE)
          READ (13) RP%LINE%E0, RP%LINE%E1, RP%LINE%AIK, 
     .              RP%LINE%G1, RP%LINE%G2, RP%LINE%C2, 
     .              RP%LINE%C3, RP%LINE%C4, RP%LINE%C6, 
     .              RP%LINE%B12, RP%LINE%B21, RP%LINE%C6A
          READ (13) RP%LINE%IGND, RP%LINE%IRCART, RP%LINE%IPROFILETYPE, 
     .              RP%LINE%IFREMD, RP%LINE%NRJPRT, RP%LINE%IPLSC6
          READ (13) RP%LINE%REACNAME

        ELSE IF (RP%IFIT <= 2) THEN
! DATA FOR POLYNOMIAL FIT
          IF (.NOT.ASSOCIATED(RP%POLY)) ALLOCATE (RP%POLY)
          IF (ASSOCIATED(RP%POLY%DBLPOL)) DEALLOCATE (RP%POLY%DBLPOL)

          READ (13) RP%POLY%IFEXMN,RP%POLY%IFEXMX,ND,ND2
          ALLOCATE (RP%POLY%DBLPOL(ND,ND2))
          READ (13) RP%POLY%DBLPOL,
     .              RP%POLY%RCMN,RP%POLY%RCMX,RP%POLY%FPARM

        ELSE
! ADAS DATA
        END IF

        END SUBROUTINE READ_FIT_FORM

      END SUBROUTINE READ_CMAMF


      SUBROUTINE CMAMF_XDR (IUN,IFLG)

      INTEGER, INTENT(IN) :: IUN,IFLG
      INTEGER :: IR, IHELP(1)
      LOGICAL :: LHELP(7)

      CALL FXDRDBL (IUN,DELPOT,NREAC)
      CALL FXDRDBL (IUN,FACREA,NREAC+11)
      CALL FXDRDBL (IUN,FREACA,NATM*NREAC)
      CALL FXDRDBL (IUN,FREACM,NMOL*NREAC)
      CALL FXDRDBL (IUN,FREACI,NION*NREAC)
      CALL FXDRDBL (IUN,FREACP,NPLS*NREAC)
      CALL FXDRDBL (IUN,FREACPH,NPHOT*NREAC)
      CALL FXDRDBL (IUN,FLDLMA,NATM*NREAC)
      CALL FXDRDBL (IUN,FLDLMM,NMOL*NREAC)
      CALL FXDRDBL (IUN,FLDLMI,NION*NREAC)
      CALL FXDRDBL (IUN,FLDLMP,NPLS*NREAC)
      CALL FXDRDBL (IUN,FLDLMPH,NPHOT*NREAC)
      CALL FXDRDBL (IUN,EELECA,NATM*NREAC)
      CALL FXDRDBL (IUN,EELECM,NMOL*NREAC)
      CALL FXDRDBL (IUN,EELECI,NION*NREAC)
      CALL FXDRDBL (IUN,EELECP,NPLS*NREAC)
      CALL FXDRDBL (IUN,EELECPH,NPHOT*NREAC)
      CALL FXDRDBL (IUN,EBULKA,NATM*NREAC)
      CALL FXDRDBL (IUN,EBULKM,NMOL*NREAC)
      CALL FXDRDBL (IUN,EBULKI,NION*NREAC)
      CALL FXDRDBL (IUN,EBULKP,NPLS*NREAC)
      CALL FXDRDBL (IUN,EBULKPH,NPHOT*NREAC)
      CALL FXDRDBL (IUN,ESCD1A,NATM*NREAC)
      CALL FXDRDBL (IUN,ESCD1M,NMOL*NREAC)
      CALL FXDRDBL (IUN,ESCD1I,NION*NREAC)
      CALL FXDRDBL (IUN,ESCD1P,NPLS*NREAC)
      CALL FXDRDBL (IUN,ESCD1PH,NPHOT*NREAC)
      CALL FXDRDBL (IUN,ESCD2A,NATM*NREAC)
      CALL FXDRDBL (IUN,ESCD2M,NMOL*NREAC)
      CALL FXDRDBL (IUN,ESCD2I,NION*NREAC)
      CALL FXDRDBL (IUN,ESCD2P,NPLS*NREAC)
      CALL FXDRDBL (IUN,ESCD2PH,NPHOT*NREAC)

      IHELP(1) = NREACI
      CALL FXDRINT (IUN,IHELP,1)
      CALL FXDRINT (IUN,ISWR,NREAC)
      CALL FXDRINT (IUN,MODCLF,NREAC)
      CALL FXDRINT (IUN,MASSP,NREAC)
      CALL FXDRINT (IUN,MASST,NREAC)
      CALL FXDRINT (IUN,IFTFLG,6*NREAC)
      CALL FXDRINT (IUN,NRCP,NPLS)
      CALL FXDRINT (IUN,NRCA,NATM)
      CALL FXDRINT (IUN,NRCM,NMOL)
      CALL FXDRINT (IUN,NRCI,NION)
      CALL FXDRINT (IUN,NRCPH,NPHOT)
      CALL FXDRINT (IUN,IREACA,NATM*NREAC)
      CALL FXDRINT (IUN,IREACM,NMOL*NREAC)
      CALL FXDRINT (IUN,IREACI,NION*NREAC)
      CALL FXDRINT (IUN,IREACP,NPLS*NREAC)
      CALL FXDRINT (IUN,IREACPH,NPHOT*NREAC)
      CALL FXDRINT (IUN,IBULKA,NATM*NREAC)
      CALL FXDRINT (IUN,IBULKM,NMOL*NREAC)
      CALL FXDRINT (IUN,IBULKI,NION*NREAC)
      CALL FXDRINT (IUN,IBULKP,NPLS*NREAC)
      CALL FXDRINT (IUN,IBULKPH,NPHOT*NREAC)
      CALL FXDRINT (IUN,ISCD1A,NATM*NREAC)
      CALL FXDRINT (IUN,ISCD1M,NMOL*NREAC)
      CALL FXDRINT (IUN,ISCD1I,NION*NREAC)
      CALL FXDRINT (IUN,ISCD1P,NPLS*NREAC)
      CALL FXDRINT (IUN,ISCD1PH,NPHOT*NREAC)
      CALL FXDRINT (IUN,ISCD2A,NATM*NREAC)
      CALL FXDRINT (IUN,ISCD2M,NMOL*NREAC)
      CALL FXDRINT (IUN,ISCD2I,NION*NREAC)
      CALL FXDRINT (IUN,ISCD2P,NPLS*NREAC)
      CALL FXDRINT (IUN,ISCD2PH,NPHOT*NREAC)
      CALL FXDRINT (IUN,ISCD3A,NATM*NREAC)
      CALL FXDRINT (IUN,ISCD3M,NMOL*NREAC)
      CALL FXDRINT (IUN,ISCD3I,NION*NREAC)
      CALL FXDRINT (IUN,ISCD3P,NPLS*NREAC)
      CALL FXDRINT (IUN,ISCD3PH,NPHOT*NREAC)
      CALL FXDRINT (IUN,ISCDEA,NATM*NREAC)
      CALL FXDRINT (IUN,ISCDEM,NMOL*NREAC)
      CALL FXDRINT (IUN,ISCDEI,NION*NREAC)
      CALL FXDRINT (IUN,ISCDEP,NPLS*NREAC)
      CALL FXDRINT (IUN,ISCDEPH,NPHOT*NREAC)
      CALL FXDRINT (IUN,IESTMA,NATM*NREAC)
      CALL FXDRINT (IUN,IESTMM,NMOL*NREAC)
      CALL FXDRINT (IUN,IESTMI,NION*NREAC)
      CALL FXDRINT (IUN,IESTMPH,NPHOT*NREAC)
      CALL FXDRINT (IUN,IBGKA ,NATM*NREAC)
      CALL FXDRINT (IUN,IBGKM ,NMOL*NREAC)
      CALL FXDRINT (IUN,IBGKI, NION*NREAC)
      CALL FXDRINT (IUN,IBGKPH,NPHOT*NREAC)

      IF (IFLG == 0) THEN
        DO IR=1,NREACI
          LHELP = (/ REACDAT(IR)%LPOT, REACDAT(IR)%LCRS,
     .               REACDAT(IR)%LRTC, REACDAT(IR)%LRTCMW,
     .               REACDAT(IR)%LRTCEW, REACDAT(IR)%LOTH,
     .               REACDAT(IR)%LPHR /)
          CALL FXDRLOG(IUN,LHELP,7)
          IF (REACDAT(IR)%LPOT) CALL WXDR_FIT_FORM(REACDAT(IR)%POT)
          IF (REACDAT(IR)%LCRS) CALL WXDR_FIT_FORM(REACDAT(IR)%CRS)
          IF (REACDAT(IR)%LRTC) CALL WXDR_FIT_FORM(REACDAT(IR)%RTC)
          IF (REACDAT(IR)%LRTCMW) CALL WXDR_FIT_FORM(REACDAT(IR)%RTCMW)
          IF (REACDAT(IR)%LRTCEW) CALL WXDR_FIT_FORM(REACDAT(IR)%RTCEW)
          IF (REACDAT(IR)%LOTH) CALL WXDR_FIT_FORM(REACDAT(IR)%OTH)
          IF (REACDAT(IR)%LPHR) CALL WXDR_FIT_FORM(REACDAT(IR)%PHR)
        END DO
      ELSE
        LHELP = .FALSE.
        DO IR=1,NREACI
          CALL FXDRLOG(IUN,LHELP,7)
          REACDAT(IR)%LPOT = LHELP(1)
          REACDAT(IR)%LCRS = LHELP(2)
          REACDAT(IR)%LRTC = LHELP(3) 
          REACDAT(IR)%LRTCMW = LHELP(4)
          REACDAT(IR)%LRTCEW = LHELP(5) 
          REACDAT(IR)%LOTH = LHELP(6) 
          REACDAT(IR)%LPHR = LHELP(7) 
          IF (REACDAT(IR)%LPOT) CALL RXDR_FIT_FORM(REACDAT(IR)%POT)
          IF (REACDAT(IR)%LCRS) CALL RXDR_FIT_FORM(REACDAT(IR)%CRS)
          IF (REACDAT(IR)%LRTC) CALL RXDR_FIT_FORM(REACDAT(IR)%RTC)
          IF (REACDAT(IR)%LRTCMW) CALL RXDR_FIT_FORM(REACDAT(IR)%RTCMW)
          IF (REACDAT(IR)%LRTCEW) CALL RXDR_FIT_FORM(REACDAT(IR)%RTCEW)
          IF (REACDAT(IR)%LOTH) CALL RXDR_FIT_FORM(REACDAT(IR)%OTH)
          IF (REACDAT(IR)%LPHR) CALL RXDR_FIT_FORM(REACDAT(IR)%PHR)
        END DO
      END IF

      RETURN

      CONTAINS

        SUBROUTINE WXDR_FIT_FORM(RP)
        TYPE(FIT_FORMS),POINTER :: RP
        INTEGER :: IHELP(17), ND, ND2
        REAL(DP) :: RHELP(23)

        IHELP(1) = RP%IFIT
        CALL FXDRINT (IUN,IHELP,1)
        
        IF (RP%IFIT < 0) THEN
! DATA FOR PHOTONIC LINE
          RHELP(1:11) = (/ RP%LINE%E0, RP%LINE%E1, RP%LINE%AIK, 
     .               RP%LINE%G1, RP%LINE%G2, RP%LINE%C2, 
     .               RP%LINE%C3, RP%LINE%C4, RP%LINE%C6, 
     .               RP%LINE%B12, RP%LINE%B21 /) 
          RHELP(12:23) = RP%LINE%C6A(1:12)

          IHELP(1:5) = (/ RP%LINE%IGND, RP%LINE%IRCART, 
     .                    RP%LINE%IPROFILETYPE, 
     .                    RP%LINE%IFREMD, RP%LINE%NRJPRT /)
          IHELP(6:17) = RP%LINE%IPLSC6

          CALL FXDRDBL (IUN,RHELP,23)
          CALL FXDRINT (IUN,IHELP,17)
          CALL FXDRCHR (IUN,RP%LINE%REACNAME)

        ELSE IF (RP%IFIT <= 2) THEN
! DATA FOR POLYNOMIAL FIT
          ND = UBOUND(RP%POLY%DBLPOL,1)
          ND2 = UBOUND(RP%POLY%DBLPOL,2)
          IHELP(1:4) = (/ RP%POLY%IFEXMN, RP%POLY%IFEXMX, ND, ND2 /) 

          RHELP(1) = RP%POLY%RCMN
          RHELP(2) = RP%POLY%RCMX
          RHELP(3:8) = RP%POLY%FPARM

          CALL FXDRINT (IUN,IHELP,4)
          CALL FXDRDBL (IUN,RP%POLY%DBLPOL,ND*ND2)
          CALL FXDRDBL (IUN,RHELP,8)

        ELSE
! ADAS DATA
        END IF
        
        END SUBROUTINE WXDR_FIT_FORM


        SUBROUTINE RXDR_FIT_FORM(RP)
        TYPE(FIT_FORMS),POINTER :: RP
        INTEGER :: IHELP(17), ND, ND2
        REAL(DP) :: RHELP(23)

        CALL FXDRINT (IUN,IHELP,1)
        RP%IFIT = IHELP(1)

        IF (RP%IFIT < 0) THEN
! DATA FOR PHOTONIC LINE
          IF (.NOT.ASSOCIATED(RP%LINE)) ALLOCATE (RP%LINE)
          CALL FXDRDBL (IUN,RHELP,23)
          CALL FXDRINT (IUN,IHELP,17)
          CALL FXDRCHR (IUN,RP%LINE%REACNAME)

          RP%LINE%E0 = RHELP(1) 
          RP%LINE%E1 = RHELP(2) 
          RP%LINE%AIK = RHELP(3) 
          RP%LINE%G1 = RHELP(4) 
          RP%LINE%G2 = RHELP(5) 
          RP%LINE%C2 = RHELP(6) 
          RP%LINE%C3 = RHELP(7) 
          RP%LINE%C4 = RHELP(8) 
          RP%LINE%C6 = RHELP(9) 
          RP%LINE%B12 = RHELP(10) 
          RP%LINE%B21 = RHELP(11) 
          RP%LINE%C6A(1:12) = RHELP(12:23)

          RP%LINE%IGND  = IHELP(1)
          RP%LINE%IRCART = IHELP(2)
          RP%LINE%IPROFILETYPE = IHELP(3)
          RP%LINE%IFREMD = IHELP(4)
          RP%LINE%NRJPRT = IHELP(5)
          RP%LINE%IPLSC6(1:12) = IHELP(6:17)


        ELSE IF (RP%IFIT <= 2) THEN
! DATA FOR POLYNOMIAL FIT
          
          CALL FXDRINT (IUN,IHELP,4)
          RP%POLY%IFEXMN = IHELP(1)
          RP%POLY%IFEXMX = IHELP(2)
          ND = IHELP(3)
          ND2 = IHELP(4)

          IF (.NOT.ASSOCIATED(RP%POLY)) ALLOCATE (RP%POLY)
          IF (ASSOCIATED(RP%POLY%DBLPOL)) DEALLOCATE (RP%POLY%DBLPOL)
          ALLOCATE (RP%POLY%DBLPOL(ND,ND2))
          CALL FXDRDBL (IUN,RP%POLY%DBLPOL,ND*ND2)

          CALL FXDRDBL (IUN,RHELP,8)
          RP%POLY%RCMN = RHELP(1)
          RP%POLY%RCMX = RHELP(2)
          RP%POLY%FPARM = RHELP(3:8)

        ELSE
! ADAS DATA
        END IF
         
        END SUBROUTINE RXDR_FIT_FORM
      
      END SUBROUTINE CMAMF_XDR


      SUBROUTINE GET_REACTION (IR)

      INTEGER, INTENT(IN) :: IR

      REACTION => REACDAT(IR)%PHR%LINE

      IDREAC = IR

      RETURN
      END SUBROUTINE GET_REACTION


      SUBROUTINE SET_REACTION_DATA(IR,ISW,IFTFLG,RDATA,IUNOUT,LTEST,
     .                             RCMIN, RCMAX, FP, JFEXMN, JFEXMX)

      IMPLICIT NONE
      INTEGER, INTENT(IN) :: IR, ISW, IFTFLG, IUNOUT
      INTEGER, OPTIONAL, INTENT(IN) :: JFEXMN, JFEXMX
      REAL(DP), INTENT(IN) :: RDATA(9,*)
      REAL(DP), OPTIONAL, INTENT(IN) :: RCMIN, RCMAX, FP(6)
      LOGICAL, INTENT(IN) :: LTEST
      INTEGER :: NDIM, NDIM2, I, J, IFIT
      REAL(DP) :: CTEST
      TYPE(POLY_DATA), POINTER :: REA
      INTEGER, SAVE :: ISW2D(7) = (/ 3, 4, 6, 7, 9, 10, 12 /)

      NDIM = 9
      IF (MOD(IFTFLG,100) == 10) NDIM = 1

      NDIM2 = 1
      IF (COUNT(ISW2D == ISW) > 0) NDIM2=9

      IF (LTEST) THEN
        DO J = 1, NDIM2
          CTEST = SUM(ABS(RDATA(1:NDIM,J)))
          IF (CTEST.LE.1.E-30_DP) THEN
            WRITE (iunout,*) 
     .            'ERROR IN SUBROUTINE SET_REACTION_DATA:',
     .            ' ZERO FIT COEFFICIENTS'
            WRITE (iunout,*) 'J,IR = ',J,IR,'  EXIT CALLED!'
            CALL EXIT_OWN(1)
          END IF
        END DO 
      END IF

      ALLOCATE (REA)
      ALLOCATE (REA%DBLPOL(1:NDIM,1:NDIM2))

      REA%RCMN = -HUGE(1._DP)
      REA%RCMX =  HUGE(1._DP)
      REA%FPARM = 0._DP
      REA%IFEXMN = 0
      REA%IFEXMX = 0

      REA%DBLPOL(1:NDIM,1:NDIM2) = RDATA(1:NDIM,1:NDIM2)
      IFIT = 1
      IF (NDIM2 == 9) IFIT = 2

      IF (PRESENT(RCMIN)) REA%RCMN = RCMIN 
      IF (PRESENT(RCMAX)) REA%RCMX = RCMAX 
      IF (PRESENT(FP)) REA%FPARM = FP
      IF (PRESENT(JFEXMN)) REA%IFEXMN = JFEXMN
      IF (PRESENT(JFEXMX)) REA%IFEXMX = JFEXMX

      SELECT CASE(ISW)

      CASE (0)
        IF (REACDAT(IR)%LPOT) THEN
          WRITE (IUNOUT,*) ' POTENTIAL ALREADY SPECIFIED FOR REACTION',
     .                       IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%POT)
        NULLIFY(REACDAT(IR)%POT%ADAS)
        NULLIFY(REACDAT(IR)%POT%LINE)
        REACDAT(IR)%POT%POLY => REA
        REACDAT(IR)%LPOT = .TRUE.
        REACDAT(IR)%POT%IFIT = IFIT
         
      CASE (1)
        IF (REACDAT(IR)%LCRS) THEN
          WRITE (IUNOUT,*) ' CROSS SECTION ALREADY SPECIFIED',
     .                     ' FOR REACTION', IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%CRS)
        NULLIFY(REACDAT(IR)%CRS%ADAS)
        NULLIFY(REACDAT(IR)%CRS%LINE)
        REACDAT(IR)%CRS%POLY => REA
        REACDAT(IR)%LCRS = .TRUE.
        REACDAT(IR)%CRS%IFIT = IFIT
        
      CASE (2:4)
        IF (REACDAT(IR)%LRTC) THEN
          WRITE (IUNOUT,*) ' RATE COEFFICIENT ALREADY SPECIFIED',
     .                     ' FOR REACTION', IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%RTC)
        NULLIFY(REACDAT(IR)%RTC%ADAS)
        NULLIFY(REACDAT(IR)%RTC%LINE)
        REACDAT(IR)%RTC%POLY => REA
        REACDAT(IR)%LRTC = .TRUE.
        REACDAT(IR)%RTC%IFIT = IFIT
        
      CASE (5:7)
        IF (REACDAT(IR)%LRTCMW) THEN
          WRITE (IUNOUT,*) ' MOMEMTUM WEIGHTED RATE COEFFICIENT',
     .                     ' ALREADY SPECIFIED FOR REACTION', IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%RTCMW)
        NULLIFY(REACDAT(IR)%RTCMW%ADAS)
        NULLIFY(REACDAT(IR)%RTCMW%LINE)
        REACDAT(IR)%RTCMW%POLY => REA
        REACDAT(IR)%LRTCMW = .TRUE.
        REACDAT(IR)%RTCMW%IFIT = IFIT
        
      CASE (8:10)
        IF (REACDAT(IR)%LRTCEW) THEN
          WRITE (IUNOUT,*) ' ENERGY WEIGHTED RATE COEFFICIENT',
     .                     ' ALREADY SPECIFIED FOR REACTION', IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%RTCEW)
        NULLIFY(REACDAT(IR)%RTCEW%ADAS)
        NULLIFY(REACDAT(IR)%RTCEW%LINE)
        REACDAT(IR)%RTCEW%POLY => REA
        REACDAT(IR)%LRTCEW = .TRUE.
        REACDAT(IR)%RTCEW%IFIT = IFIT

      CASE (11:12)
        IF (REACDAT(IR)%LOTH) THEN
          WRITE (IUNOUT,*) ' OTHER POLYNOMIAL FIT COEFFICIENTS',
     .                     ' ALREADY SPECIFIED FOR REACTION', IR
          DEALLOCATE (REA)
          IF (IR < 0) RETURN
          WRITE (IUNOUT,*) ' PLEASE CHECK SPECIFICATION OF REACTIONS'
          CALL EXIT_OWN(1)
        END IF
        ALLOCATE (REACDAT(IR)%OTH)
        NULLIFY(REACDAT(IR)%OTH%ADAS)
        NULLIFY(REACDAT(IR)%OTH%LINE)
        REACDAT(IR)%OTH%POLY => REA
        REACDAT(IR)%LOTH = .TRUE.
        REACDAT(IR)%OTH%IFIT = IFIT
        
      CASE DEFAULT
        WRITE (IUNOUT,*) ' WRONG REACTION TYPE SPCIFIED '
        WRITE (IUNOUT,*) ' REACTION NO. ', IR
        WRITE (IUNOUT,*) ' REACTION TYPE H.', ISW
        CALL EXIT_OWN(1)
      END SELECT
      
      RETURN
      END SUBROUTINE SET_REACTION_DATA


      FUNCTION IS_RTC_ADAS (IREAC) RESULT(RES)

      INTEGER, INTENT(IN) :: IREAC
      LOGICAL :: RES

      RES = .FALSE.
      IF (REACDAT(IREAC)%LRTC) THEN
        RES = REACDAT(IREAC)%RTC%IFIT == 3
      END IF

      END FUNCTION IS_RTC_ADAS


      FUNCTION IS_RTCEW_ADAS (IREAC) RESULT(RES)

      INTEGER, INTENT(IN) :: IREAC
      LOGICAL :: RES

      RES = .FALSE.
      IF (REACDAT(IREAC)%LRTCEW) THEN
        RES = REACDAT(IREAC)%RTCEW%IFIT == 3
      END IF

      END FUNCTION IS_RTCEW_ADAS


      FUNCTION IS_RTCMW_ADAS (IREAC) RESULT(RES)

      INTEGER, INTENT(IN) :: IREAC
      LOGICAL :: RES

      RES = .FALSE.
      IF (REACDAT(IREAC)%LRTCMW) THEN
        RES = REACDAT(IREAC)%RTCMW%IFIT == 3
      END IF

      END FUNCTION IS_RTCMW_ADAS

      END MODULE COMXS

C ===== SOURCE: coutau.f
      MODULE COUTAU

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_COUTAU, DEALLOC_COUTAU, INIT_COUTAU, FETCH_OUTAU,
     .          WRITE_COUTAU, READ_COUTAU, INIT_COUTAU_REINIT

! INTEGRALS OF VOLUME AVERAGED TALLIES
      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R PDENAI(:,:), PDENMI(:,:), PDENII(:,:), PDENPHI(:,:),
     R EDENAI(:,:), EDENMI(:,:), EDENII(:,:), EDENPHI(:,:),
     R PAELI(:),    PAATI(:,:),  PAMLI(:,:),  PAIOI(:,:),  PAPHTI(:,:),
     R PAPLI(:,:),
     R PMELI(:),    PMATI(:,:),  PMMLI(:,:),  PMIOI(:,:),  PMPHTI(:,:),
     R PMPLI(:,:),
     R PIELI(:),    PIATI(:,:),  PIMLI(:,:),  PIIOI(:,:),  PIPHTI(:,:),
     R PIPLI(:,:),
     R PPHELI(:),   PPHATI(:,:), PPHMLI(:,:), PPHIOI(:,:), PPHPHTI(:,:),
     R PPHPLI(:,:),
     R EAELI(:),  EAATI(:),  EAMLI(:),  EAIOI(:),  EAPHTI(:), EAPLI(:),
     R EMELI(:),  EMATI(:),  EMMLI(:),  EMIOI(:),  EMPHTI(:), EMPLI(:),
     R EIELI(:),  EIATI(:),  EIMLI(:),  EIIOI(:),  EIPHTI(:), EIPLI(:),
     R EPHELI(:), EPHATI(:), EPHMLI(:), EPHIOI(:), EPHPHTI(:),EPHPLI(:),
     R ADDVI(:,:),
     R COLVI(:,:),  SNAPVI(:,:), COPVI(:,:),  BGKVI(:,:), ALGVI(:,:),
     R PGENAI(:,:), PGENMI(:,:), PGENII(:,:), PGENPHI(:,:),
     R EGENAI(:,:), EGENMI(:,:), EGENII(:,:), EGENPHI(:,:),
     R VGENAI(:,:), VGENMI(:,:), VGENII(:,:), VGENPHI(:,:),
     R PPATI(:,:),  PPMLI(:,:),  PPIOI(:,:),  PPPHTI(:,:), PPPLI(:,:),
     R EPATI(:),    EPMLI(:),    EPIOI(:),    EPPHTI(:),   EPPLI(:),
     R VXDENAI(:,:), VXDENMI(:,:), VXDENII(:,:), VXDENPHI(:,:),
     R VYDENAI(:,:), VYDENMI(:,:), VYDENII(:,:), VYDENPHI(:,:),
     R VZDENAI(:,:), VZDENMI(:,:), VZDENII(:,:), VZDENPHI(:,:),
     R MAPLI(:,:),  MMPLI(:,:),  MIPLI(:,:),  MPHPLI(:,:)

! SURFACE TALLIES
      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R POTATI(:,:), PRFAAI(:,:), PRFMAI(:,:), PRFIAI(:,:), PRFPHAI(:,:),
     R PRFPAI(:,:),
     R POTMLI(:,:), PRFAMI(:,:), PRFMMI(:,:), PRFIMI(:,:), PRFPHMI(:,:),
     R PRFPMI(:,:),
     R POTIOI(:,:), PRFAII(:,:), PRFMII(:,:), PRFIII(:,:), PRFPHII(:,:),
     R PRFPII(:,:),
     R POTPHTI(:,:), PRFAPHTI(:,:), PRFMPHTI(:,:), PRFIPHTI(:,:),
     R PRFPHPHTI(:,:), PRFPPHTI(:,:),
     R POTPLI(:,:)
      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R EOTATI(:,:), ERFAAI(:,:), ERFMAI(:,:), ERFIAI(:,:), ERFPHAI(:,:),
     R ERFPAI(:,:),
     R EOTMLI(:,:), ERFAMI(:,:), ERFMMI(:,:), ERFIMI(:,:), ERFPHMI(:,:),
     R ERFPMI(:,:),
     R EOTIOI(:,:), ERFAII(:,:), ERFMII(:,:), ERFIII(:,:), ERFPHII(:,:),
     R ERFPII(:,:),
     R EOTPHTI(:,:), ERFAPHTI(:,:), ERFMPHTI(:,:), ERFIPHTI(:,:),
     R ERFPHPHTI(:,:), ERFPPHTI(:,:),
     R EOTPLI(:,:),
     R SPTATI(:,:), SPTMLI(:,:), SPTIOI(:,:), SPTPHTI(:,:), SPTPLI(:,:),
     R SPTTTI(:),
     R ADDSI(:,:),  ALGSI(:,:),
     R SPUMPI(:,:)

! INTEGRAL VALUES
      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R WTOTA(:,:),  WTOTM(:,:),  WTOTI(:,:),  WTOTP(:,:),  WTOTPH(:,:),
     R WTOTE(:),
     R ETOTA(:),    ETOTM(:),    ETOTI(:),    ETOTP(:),    ETOTPH(:),
     R XMCP(:),     FLUXT(:),    FLXFAC(:),   EELFI(:,:),
     R PTRASH(:),   ETRASH(:),
     R FASCL(:),    FMSCL(:),    FISCL(:),    FPHSCL(:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NADDI(:),  NFRSTI(:), NDDWI(:),  NFRTWI(:),
     I NFSTVI(:), NFSTWI(:), NFSTPI(:)

      INTEGER, PUBLIC, SAVE ::
     I NOUTA1, NOUTA2, NOUTAS, NOUTAU, NOUTTL

      CONTAINS


      SUBROUTINE ALLOC_COUTAU

      IF (ALLOCATED(PDENAI)) RETURN

      NOUTA1 = NVLTLP*NSTRAP
      NOUTA2 = NSFTLP*NSTRAP
      NOUTAS = (1*NPHOTP+1*NATMP+1*NMOLP+1*NPLSP+2*NIONP+15)*NSTRAP
      NOUTAU = NOUTA1+NOUTA2+NOUTAS
      NOUTTL = 3*(NTALV+NTALS)+NTALI

      ALLOCATE (PDENAI(0:NATM,0:NSTRA))
      ALLOCATE (PDENMI(0:NMOL,0:NSTRA))
      ALLOCATE (PDENII(0:NION,0:NSTRA))
      ALLOCATE (PDENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (EDENAI(0:NATM,0:NSTRA))
      ALLOCATE (EDENMI(0:NMOL,0:NSTRA))
      ALLOCATE (EDENII(0:NION,0:NSTRA))
      ALLOCATE (EDENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (PAELI(0:NSTRA))
      ALLOCATE (PAATI(0:NATM,0:NSTRA))
      ALLOCATE (PAMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PAIOI(0:NION,0:NSTRA))
      ALLOCATE (PAPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PAPLI(0:NPLS,0:NSTRA))
      ALLOCATE (PMELI(0:NSTRA))
      ALLOCATE (PMATI(0:NATM,0:NSTRA))
      ALLOCATE (PMMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PMIOI(0:NION,0:NSTRA))
      ALLOCATE (PMPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PMPLI(0:NPLS,0:NSTRA))
      ALLOCATE (PIELI(0:NSTRA))
      ALLOCATE (PIATI(0:NATM,0:NSTRA))
      ALLOCATE (PIMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PIIOI(0:NION,0:NSTRA))
      ALLOCATE (PIPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PIPLI(0:NPLS,0:NSTRA))
      ALLOCATE (PPHELI(0:NSTRA))
      ALLOCATE (PPHATI(0:NATM,0:NSTRA))
      ALLOCATE (PPHMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PPHIOI(0:NION,0:NSTRA))
      ALLOCATE (PPHPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PPHPLI(0:NPLS,0:NSTRA))

      ALLOCATE (EAELI(0:NSTRA))
      ALLOCATE (EAATI(0:NSTRA))
      ALLOCATE (EAMLI(0:NSTRA))
      ALLOCATE (EAIOI(0:NSTRA))
      ALLOCATE (EAPHTI(0:NSTRA))
      ALLOCATE (EAPLI(0:NSTRA))
      ALLOCATE (EMELI(0:NSTRA))
      ALLOCATE (EMATI(0:NSTRA))
      ALLOCATE (EMMLI(0:NSTRA))
      ALLOCATE (EMIOI(0:NSTRA))
      ALLOCATE (EMPHTI(0:NSTRA))
      ALLOCATE (EMPLI(0:NSTRA))
      ALLOCATE (EIELI(0:NSTRA))
      ALLOCATE (EIATI(0:NSTRA))
      ALLOCATE (EIMLI(0:NSTRA))
      ALLOCATE (EIIOI(0:NSTRA))
      ALLOCATE (EIPHTI(0:NSTRA))
      ALLOCATE (EIPLI(0:NSTRA))
      ALLOCATE (EPHELI(0:NSTRA))
      ALLOCATE (EPHATI(0:NSTRA))
      ALLOCATE (EPHMLI(0:NSTRA))
      ALLOCATE (EPHIOI(0:NSTRA))
      ALLOCATE (EPHPHTI(0:NSTRA))
      ALLOCATE (EPHPLI(0:NSTRA))
      ALLOCATE (ADDVI(0:NADV,0:NSTRA))
      ALLOCATE (COLVI(0:NCLV,0:NSTRA))
      ALLOCATE (SNAPVI(0:NSNV,0:NSTRA))
      ALLOCATE (COPVI(0:NCPV,0:NSTRA))
      ALLOCATE (BGKVI(0:NBGV,0:NSTRA))
      ALLOCATE (ALGVI(0:NALV,0:NSTRA))
      ALLOCATE (PGENAI(0:NATM,0:NSTRA))
      ALLOCATE (PGENMI(0:NMOL,0:NSTRA))
      ALLOCATE (PGENII(0:NION,0:NSTRA))
      ALLOCATE (PGENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (EGENAI(0:NATM,0:NSTRA))
      ALLOCATE (EGENMI(0:NMOL,0:NSTRA))
      ALLOCATE (EGENII(0:NION,0:NSTRA))
      ALLOCATE (EGENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (VGENAI(0:NATM,0:NSTRA))
      ALLOCATE (VGENMI(0:NMOL,0:NSTRA))
      ALLOCATE (VGENII(0:NION,0:NSTRA))
      ALLOCATE (VGENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (PPATI(0:NATM,0:NSTRA))
      ALLOCATE (PPMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PPIOI(0:NION,0:NSTRA))
      ALLOCATE (PPPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PPPLI(0:NPLS,0:NSTRA))
      ALLOCATE (EPATI(0:NSTRA))
      ALLOCATE (EPMLI(0:NSTRA))
      ALLOCATE (EPIOI(0:NSTRA))
      ALLOCATE (EPPHTI(0:NSTRA))
      ALLOCATE (EPPLI(0:NSTRA))
      ALLOCATE (VXDENAI(0:NATM,0:NSTRA))
      ALLOCATE (VXDENMI(0:NMOL,0:NSTRA))
      ALLOCATE (VXDENII(0:NION,0:NSTRA))
      ALLOCATE (VXDENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (VYDENAI(0:NATM,0:NSTRA))
      ALLOCATE (VYDENMI(0:NMOL,0:NSTRA))
      ALLOCATE (VYDENII(0:NION,0:NSTRA))
      ALLOCATE (VYDENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (VZDENAI(0:NATM,0:NSTRA))
      ALLOCATE (VZDENMI(0:NMOL,0:NSTRA))
      ALLOCATE (VZDENII(0:NION,0:NSTRA))
      ALLOCATE (VZDENPHI(0:NPHOT,0:NSTRA))
      ALLOCATE (MAPLI(0:NPLS,0:NSTRA))
      ALLOCATE (MMPLI(0:NPLS,0:NSTRA))
      ALLOCATE (MIPLI(0:NPLS,0:NSTRA))
      ALLOCATE (MPHPLI(0:NPLS,0:NSTRA))

      ALLOCATE (POTATI(0:NATM,0:NSTRA))
      ALLOCATE (PRFAAI(0:NATM,0:NSTRA))
      ALLOCATE (PRFMAI(0:NATM,0:NSTRA))
      ALLOCATE (PRFIAI(0:NATM,0:NSTRA))
      ALLOCATE (PRFPHAI(0:NATM,0:NSTRA))
      ALLOCATE (PRFPAI(0:NATM,0:NSTRA))
      ALLOCATE (POTMLI(0:NMOL,0:NSTRA))
      ALLOCATE (PRFAMI(0:NMOL,0:NSTRA))
      ALLOCATE (PRFMMI(0:NMOL,0:NSTRA))
      ALLOCATE (PRFIMI(0:NMOL,0:NSTRA))
      ALLOCATE (PRFPHMI(0:NMOL,0:NSTRA))
      ALLOCATE (PRFPMI(0:NMOL,0:NSTRA))
      ALLOCATE (POTIOI(0:NION,0:NSTRA))
      ALLOCATE (PRFAII(0:NION,0:NSTRA))
      ALLOCATE (PRFMII(0:NION,0:NSTRA))
      ALLOCATE (PRFIII(0:NION,0:NSTRA))
      ALLOCATE (PRFPHII(0:NION,0:NSTRA))
      ALLOCATE (PRFPII(0:NION,0:NSTRA))
      ALLOCATE (POTPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PRFAPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PRFMPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PRFIPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PRFPHPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (PRFPPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (POTPLI(0:NPLS,0:NSTRA))
      ALLOCATE (EOTATI(0:NATM,0:NSTRA))
      ALLOCATE (ERFAAI(0:NATM,0:NSTRA))
      ALLOCATE (ERFMAI(0:NATM,0:NSTRA))
      ALLOCATE (ERFIAI(0:NATM,0:NSTRA))
      ALLOCATE (ERFPHAI(0:NATM,0:NSTRA))
      ALLOCATE (ERFPAI(0:NATM,0:NSTRA))
      ALLOCATE (EOTMLI(0:NMOL,0:NSTRA))
      ALLOCATE (ERFAMI(0:NMOL,0:NSTRA))
      ALLOCATE (ERFMMI(0:NMOL,0:NSTRA))
      ALLOCATE (ERFIMI(0:NMOL,0:NSTRA))
      ALLOCATE (ERFPHMI(0:NMOL,0:NSTRA))
      ALLOCATE (ERFPMI(0:NMOL,0:NSTRA))
      ALLOCATE (EOTIOI(0:NION,0:NSTRA))
      ALLOCATE (ERFAII(0:NION,0:NSTRA))
      ALLOCATE (ERFMII(0:NION,0:NSTRA))
      ALLOCATE (ERFIII(0:NION,0:NSTRA))
      ALLOCATE (ERFPHII(0:NION,0:NSTRA))
      ALLOCATE (ERFPII(0:NION,0:NSTRA))
      ALLOCATE (EOTPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (ERFAPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (ERFMPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (ERFIPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (ERFPHPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (ERFPPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (EOTPLI(0:NPLS,0:NSTRA))
      ALLOCATE (SPTATI(0:NATM,0:NSTRA))
      ALLOCATE (SPTMLI(0:NMOL,0:NSTRA))
      ALLOCATE (SPTIOI(0:NION,0:NSTRA))
      ALLOCATE (SPTPHTI(0:NPHOT,0:NSTRA))
      ALLOCATE (SPTPLI(0:NPLS,0:NSTRA))
      ALLOCATE (SPTTTI(0:NSTRA))
      ALLOCATE (ADDSI(0:NADS,0:NSTRA))
      ALLOCATE (ALGSI(0:NALS,0:NSTRA))
      ALLOCATE (SPUMPI(0:NSPZ,0:NSTRA))

      ALLOCATE (WTOTA(0:NATM,0:NSTRA))
      ALLOCATE (WTOTM(0:NMOL,0:NSTRA))
      ALLOCATE (WTOTI(0:NION,0:NSTRA))
      ALLOCATE (WTOTP(0:NPLS,0:NSTRA))
      ALLOCATE (WTOTPH(0:NPHOT,0:NSTRA))
      ALLOCATE (WTOTE(0:NSTRA))
      ALLOCATE (ETOTA(0:NSTRA))
      ALLOCATE (ETOTM(0:NSTRA))
      ALLOCATE (ETOTI(0:NSTRA))
      ALLOCATE (ETOTP(0:NSTRA))
      ALLOCATE (ETOTPH(0:NSTRA))
      ALLOCATE (XMCP(0:NSTRA))
      ALLOCATE (FLUXT(0:NSTRA))
      ALLOCATE (FLXFAC(0:NSTRA))
      ALLOCATE (EELFI(0:NION,0:NSTRA))
      ALLOCATE (PTRASH(0:NSTRA))
      ALLOCATE (ETRASH(0:NSTRA))
      ALLOCATE (FASCL(0:NSTRA))
      ALLOCATE (FMSCL(0:NSTRA))
      ALLOCATE (FISCL(0:NSTRA))
      ALLOCATE (FPHSCL(0:NSTRA))

      ALLOCATE (NADDI(NTALV))
      ALLOCATE (NFRSTI(NTALV))
      ALLOCATE (NDDWI(NTALS))
      ALLOCATE (NFRTWI(NTALS))
      ALLOCATE (NFSTVI(NTALV))
      ALLOCATE (NFSTWI(NTALS))
      ALLOCATE (NFSTPI(NTALI))

      WRITE (55,'(A,T25,I15)')
     .       ' COUTAU ',NOUTAU*8 + NOUTTL*4

      NADDI  = 0
      NFRSTI = 0
      NDDWI  = 0
      NFRTWI = 0
      NFSTVI = 0
      NFSTWI = 0
      NFSTPI = 0

      RETURN
      END SUBROUTINE ALLOC_COUTAU


      SUBROUTINE DEALLOC_COUTAU

      IF (.NOT.ALLOCATED(PDENAI)) RETURN

      DEALLOCATE (PDENAI)
      DEALLOCATE (PDENMI)
      DEALLOCATE (PDENII)
      DEALLOCATE (PDENPHI)
      DEALLOCATE (EDENAI)
      DEALLOCATE (EDENMI)
      DEALLOCATE (EDENII)
      DEALLOCATE (EDENPHI)
      DEALLOCATE (PAELI)
      DEALLOCATE (PAATI)
      DEALLOCATE (PAMLI)
      DEALLOCATE (PAIOI)
      DEALLOCATE (PAPHTI)
      DEALLOCATE (PAPLI)
      DEALLOCATE (PMELI)
      DEALLOCATE (PMATI)
      DEALLOCATE (PMMLI)
      DEALLOCATE (PMIOI)
      DEALLOCATE (PMPHTI)
      DEALLOCATE (PMPLI)
      DEALLOCATE (PIELI)
      DEALLOCATE (PIATI)
      DEALLOCATE (PIMLI)
      DEALLOCATE (PIIOI)
      DEALLOCATE (PIPHTI)
      DEALLOCATE (PIPLI)
      DEALLOCATE (PPHELI)
      DEALLOCATE (PPHATI)
      DEALLOCATE (PPHMLI)
      DEALLOCATE (PPHIOI)
      DEALLOCATE (PPHPHTI)
      DEALLOCATE (PPHPLI)

      DEALLOCATE (EAELI)
      DEALLOCATE (EAATI)
      DEALLOCATE (EAMLI)
      DEALLOCATE (EAIOI)
      DEALLOCATE (EAPHTI)
      DEALLOCATE (EAPLI)
      DEALLOCATE (EMELI)
      DEALLOCATE (EMATI)
      DEALLOCATE (EMMLI)
      DEALLOCATE (EMIOI)
      DEALLOCATE (EMPHTI)
      DEALLOCATE (EMPLI)
      DEALLOCATE (EIELI)
      DEALLOCATE (EIATI)
      DEALLOCATE (EIMLI)
      DEALLOCATE (EIPHTI)
      DEALLOCATE (EIIOI)
      DEALLOCATE (EIPLI)
      DEALLOCATE (EPHELI)
      DEALLOCATE (EPHATI)
      DEALLOCATE (EPHMLI)
      DEALLOCATE (EPHPHTI)
      DEALLOCATE (EPHIOI)
      DEALLOCATE (EPHPLI)
      DEALLOCATE (ADDVI)
      DEALLOCATE (COLVI)
      DEALLOCATE (SNAPVI)
      DEALLOCATE (COPVI)
      DEALLOCATE (BGKVI)
      DEALLOCATE (ALGVI)
      DEALLOCATE (PGENAI)
      DEALLOCATE (PGENMI)
      DEALLOCATE (PGENII)
      DEALLOCATE (PGENPHI)
      DEALLOCATE (EGENAI)
      DEALLOCATE (EGENMI)
      DEALLOCATE (EGENII)
      DEALLOCATE (EGENPHI)
      DEALLOCATE (VGENAI)
      DEALLOCATE (VGENMI)
      DEALLOCATE (VGENII)
      DEALLOCATE (VGENPHI)
      DEALLOCATE (PPATI)
      DEALLOCATE (PPMLI)
      DEALLOCATE (PPIOI)
      DEALLOCATE (PPPHTI)
      DEALLOCATE (PPPLI)
      DEALLOCATE (EPATI)
      DEALLOCATE (EPMLI)
      DEALLOCATE (EPIOI)
      DEALLOCATE (EPPHTI)
      DEALLOCATE (EPPLI)
      DEALLOCATE (VXDENAI)
      DEALLOCATE (VXDENMI)
      DEALLOCATE (VXDENII)
      DEALLOCATE (VXDENPHI)
      DEALLOCATE (VYDENAI)
      DEALLOCATE (VYDENMI)
      DEALLOCATE (VYDENII)
      DEALLOCATE (VYDENPHI)
      DEALLOCATE (VZDENAI)
      DEALLOCATE (VZDENMI)
      DEALLOCATE (VZDENII)
      DEALLOCATE (VZDENPHI)
      DEALLOCATE (MAPLI)
      DEALLOCATE (MMPLI)
      DEALLOCATE (MIPLI)
      DEALLOCATE (MPHPLI)

      DEALLOCATE (POTATI)
      DEALLOCATE (PRFAAI)
      DEALLOCATE (PRFMAI)
      DEALLOCATE (PRFIAI)
      DEALLOCATE (PRFPHAI)
      DEALLOCATE (PRFPAI)
      DEALLOCATE (POTMLI)
      DEALLOCATE (PRFAMI)
      DEALLOCATE (PRFMMI)
      DEALLOCATE (PRFIMI)
      DEALLOCATE (PRFPHMI)
      DEALLOCATE (PRFPMI)
      DEALLOCATE (POTIOI)
      DEALLOCATE (PRFAII)
      DEALLOCATE (PRFMII)
      DEALLOCATE (PRFIII)
      DEALLOCATE (PRFPHII)
      DEALLOCATE (PRFPII)
      DEALLOCATE (POTPHTI)
      DEALLOCATE (PRFAPHTI)
      DEALLOCATE (PRFMPHTI)
      DEALLOCATE (PRFIPHTI)
      DEALLOCATE (PRFPHPHTI)
      DEALLOCATE (PRFPPHTI)
      DEALLOCATE (POTPLI)
      DEALLOCATE (EOTATI)
      DEALLOCATE (ERFAAI)
      DEALLOCATE (ERFMAI)
      DEALLOCATE (ERFIAI)
      DEALLOCATE (ERFPHAI)
      DEALLOCATE (ERFPAI)
      DEALLOCATE (EOTMLI)
      DEALLOCATE (ERFAMI)
      DEALLOCATE (ERFMMI)
      DEALLOCATE (ERFIMI)
      DEALLOCATE (ERFPHMI)
      DEALLOCATE (ERFPMI)
      DEALLOCATE (EOTIOI)
      DEALLOCATE (ERFAII)
      DEALLOCATE (ERFMII)
      DEALLOCATE (ERFIII)
      DEALLOCATE (ERFPHII)
      DEALLOCATE (ERFPII)
      DEALLOCATE (EOTPHTI)
      DEALLOCATE (ERFAPHTI)
      DEALLOCATE (ERFMPHTI)
      DEALLOCATE (ERFIPHTI)
      DEALLOCATE (ERFPHPHTI)
      DEALLOCATE (ERFPPHTI)
      DEALLOCATE (EOTPLI)
      DEALLOCATE (SPTATI)
      DEALLOCATE (SPTMLI)
      DEALLOCATE (SPTIOI)
      DEALLOCATE (SPTPHTI)
      DEALLOCATE (SPTPLI)
      DEALLOCATE (SPTTTI)
      DEALLOCATE (ADDSI)
      DEALLOCATE (ALGSI)
      DEALLOCATE (SPUMPI)

      DEALLOCATE (WTOTA)
      DEALLOCATE (WTOTM)
      DEALLOCATE (WTOTI)
      DEALLOCATE (WTOTP)
      DEALLOCATE (WTOTPH)
      DEALLOCATE (WTOTE)
      DEALLOCATE (ETOTA)
      DEALLOCATE (ETOTM)
      DEALLOCATE (ETOTI)
      DEALLOCATE (ETOTP)
      DEALLOCATE (ETOTPH)
      DEALLOCATE (XMCP)
      DEALLOCATE (FLUXT)
      DEALLOCATE (FLXFAC)
      DEALLOCATE (EELFI)
      DEALLOCATE (PTRASH)
      DEALLOCATE (ETRASH)
      DEALLOCATE (FASCL)
      DEALLOCATE (FMSCL)
      DEALLOCATE (FISCL)
      DEALLOCATE (FPHSCL)

      DEALLOCATE (NADDI)
      DEALLOCATE (NFRSTI)
      DEALLOCATE (NDDWI)
      DEALLOCATE (NFRTWI)
      DEALLOCATE (NFSTVI)
      DEALLOCATE (NFSTWI)
      DEALLOCATE (NFSTPI)

      RETURN
      END SUBROUTINE DEALLOC_COUTAU


      SUBROUTINE INIT_COUTAU

      INTEGER, SAVE :: IFRST=0

      PDENAI  = 0._DP
      PDENMI  = 0._DP
      PDENII  = 0._DP
      PDENPHI = 0._DP
      EDENAI  = 0._DP
      EDENMI  = 0._DP
      EDENII  = 0._DP
      EDENPHI = 0._DP
      PAELI   = 0._DP
      PAATI   = 0._DP
      PAMLI   = 0._DP
      PAIOI   = 0._DP
      PAPHTI  = 0._DP
      PAPLI   = 0._DP
      PMELI   = 0._DP
      PMATI   = 0._DP
      PMMLI   = 0._DP
      PMIOI   = 0._DP
      PMPHTI  = 0._DP
      PMPLI   = 0._DP
      PIELI   = 0._DP
      PIATI   = 0._DP
      PIMLI   = 0._DP
      PIIOI   = 0._DP
      PIPHTI  = 0._DP
      PIPLI   = 0._DP
      PPHELI  = 0._DP
      PPHATI  = 0._DP
      PPHMLI  = 0._DP
      PPHIOI  = 0._DP
      PPHPHTI = 0._DP
      PPHPLI  = 0._DP

      EAELI   = 0._DP
      EAATI   = 0._DP
      EAMLI   = 0._DP
      EAIOI   = 0._DP
      EAPHTI  = 0._DP
      EAPLI   = 0._DP
      EMELI   = 0._DP
      EMATI   = 0._DP
      EMMLI   = 0._DP
      EMIOI   = 0._DP
      EMPHTI  = 0._DP
      EMPLI   = 0._DP
      EIELI   = 0._DP
      EIATI   = 0._DP
      EIMLI   = 0._DP
      EIIOI   = 0._DP
      EIPHTI  = 0._DP
      EIPLI   = 0._DP
      EPHELI  = 0._DP
      EPHATI  = 0._DP
      EPHMLI  = 0._DP
      EPHIOI  = 0._DP
      EPHPHTI = 0._DP
      EPHPLI  = 0._DP
      ADDVI   = 0._DP
      COLVI   = 0._DP
      SNAPVI  = 0._DP
      COPVI   = 0._DP
      BGKVI   = 0._DP
      ALGVI   = 0._DP
      PGENAI  = 0._DP
      PGENMI  = 0._DP
      PGENII  = 0._DP
      PGENPHI = 0._DP
      EGENAI  = 0._DP
      EGENMI  = 0._DP
      EGENII  = 0._DP
      EGENPHI = 0._DP
      VGENAI  = 0._DP
      VGENMI  = 0._DP
      VGENII  = 0._DP
      VGENPHI = 0._DP
      PPATI  = 0._DP
      PPMLI  = 0._DP
      PPIOI  = 0._DP
      PPPHTI = 0._DP
      PPPLI = 0._DP
      EPATI  = 0._DP
      EPMLI  = 0._DP
      EPIOI  = 0._DP
      EPPHTI = 0._DP
      EPPLI = 0._DP
      VXDENAI  = 0._DP
      VXDENMI  = 0._DP
      VXDENII  = 0._DP
      VXDENPHI = 0._DP
      VYDENAI  = 0._DP
      VYDENMI  = 0._DP
      VYDENII  = 0._DP
      VYDENPHI = 0._DP
      VZDENAI  = 0._DP
      VZDENMI  = 0._DP
      VZDENII  = 0._DP
      VZDENPHI = 0._DP
      MAPLI    = 0._DP
      MMPLI    = 0._DP
      MIPLI    = 0._DP
      MPHPLI    = 0._DP

      POTATI = 0._DP
      PRFAAI = 0._DP
      PRFMAI = 0._DP
      PRFIAI = 0._DP
      PRFPHAI= 0._DP
      PRFPAI = 0._DP
      POTMLI = 0._DP
      PRFAMI = 0._DP
      PRFMMI = 0._DP
      PRFIMI = 0._DP
      PRFPHMI= 0._DP
      PRFPMI = 0._DP
      POTIOI = 0._DP
      PRFAII = 0._DP
      PRFMII = 0._DP
      PRFIII = 0._DP
      PRFPHII= 0._DP
      PRFPII = 0._DP
      POTPHTI= 0._DP
      PRFAPHTI= 0._DP
      PRFMPHTI= 0._DP
      PRFIPHTI= 0._DP
      PRFPHPHTI=0._DP
      PRFPPHTI= 0._DP
      POTPLI = 0._DP
      EOTATI = 0._DP
      ERFAAI = 0._DP
      ERFMAI = 0._DP
      ERFIAI = 0._DP
      ERFPHAI= 0._DP
      ERFPAI = 0._DP
      EOTMLI = 0._DP
      ERFAMI = 0._DP
      ERFMMI = 0._DP
      ERFIMI = 0._DP
      ERFPHMI= 0._DP
      ERFPMI = 0._DP
      EOTIOI = 0._DP
      ERFAII = 0._DP
      ERFMII = 0._DP
      ERFIII = 0._DP
      ERFPHII= 0._DP
      ERFPII = 0._DP
      EOTPHTI = 0._DP
      ERFAPHTI = 0._DP
      ERFMPHTI = 0._DP
      ERFIPHTI = 0._DP
      ERFPHPHTI= 0._DP
      ERFPPHTI = 0._DP
      EOTPLI = 0._DP
      SPTATI = 0._DP
      SPTMLI = 0._DP
      SPTIOI = 0._DP
      SPTPHTI = 0._DP
      SPTPLI = 0._DP
      SPTTTI = 0._DP
      ADDSI  = 0._DP
      ALGSI  = 0._DP
      SPUMPI = 0._DP

      WTOTA  = 0._DP
      WTOTM  = 0._DP
      WTOTI  = 0._DP
      WTOTP  = 0._DP
      WTOTPH = 0._DP
      WTOTE  = 0._DP
      ETOTA  = 0._DP
      ETOTM  = 0._DP
      ETOTI  = 0._DP
      ETOTP  = 0._DP
      ETOTPH = 0._DP
      FLUXT  = 0._DP
      FLXFAC = 0._DP
      EELFI  = 0._DP
      PTRASH = 0._DP
      ETRASH = 0._DP
      FASCL  = 0._DP
      FMSCL  = 0._DP
      FISCL  = 0._DP
      FPHSCL  = 0._DP

      IF (IFRST == 0) THEN
        XMCP   = 0._DP
        IFRST = 1
      END IF

      RETURN

C     The following ENTRY is for reinitialization of EIRENE
      
      ENTRY INIT_COUTAU_REINIT
      IFRST = 0
      return
      END SUBROUTINE INIT_COUTAU


      SUBROUTINE WRITE_COUTAU (OUTAU,IUNOUT)
      REAL(DP) :: OUTAU(:)
      INTEGER, INTENT(IN) :: IUNOUT
      INTEGER :: IA, IE

      IF (SIZE(OUTAU) < NOUTAU) THEN
        WRITE (iunout,*) 
     .  ' SIZE OF ARRAY OUTAU TOO SMALL IN WRITE_COUTAU '
        WRITE (iunout,*) ' OUTAU(',NOUTAU,') REQUIRED '
        CALL EXIT_OWN(1)
      END IF

      IA = 1
      IE = IA - 1 + SIZE(PDENAI)
      OUTAU(IA:IE) = PACK(PDENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENMI)
      OUTAU(IA:IE) = PACK(PDENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENII)
      OUTAU(IA:IE) = PACK(PDENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENPHI)
      OUTAU(IA:IE) = PACK(PDENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENAI)
      OUTAU(IA:IE) = PACK(EDENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENMI)
      OUTAU(IA:IE) = PACK(EDENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENII)
      OUTAU(IA:IE) = PACK(EDENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENPHI)
      OUTAU(IA:IE) = PACK(EDENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAELI)
      OUTAU(IA:IE) = PACK(PAELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAATI)
      OUTAU(IA:IE) = PACK(PAATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAMLI)
      OUTAU(IA:IE) = PACK(PAMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAIOI)
      OUTAU(IA:IE) = PACK(PAIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAPHTI)
      OUTAU(IA:IE) = PACK(PAPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PAPLI)
      OUTAU(IA:IE) = PACK(PAPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMELI)
      OUTAU(IA:IE) = PACK(PMELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMATI)
      OUTAU(IA:IE) = PACK(PMATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMMLI)
      OUTAU(IA:IE) = PACK(PMMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMIOI)
      OUTAU(IA:IE) = PACK(PMIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMPHTI)
      OUTAU(IA:IE) = PACK(PMPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PMPLI)
      OUTAU(IA:IE) = PACK(PMPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIELI)
      OUTAU(IA:IE) = PACK(PIELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIATI)
      OUTAU(IA:IE) = PACK(PIATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIMLI)
      OUTAU(IA:IE) = PACK(PIMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIIOI)
      OUTAU(IA:IE) = PACK(PIIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIPHTI)
      OUTAU(IA:IE) = PACK(PIPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PIPLI)
      OUTAU(IA:IE) = PACK(PIPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHELI)
      OUTAU(IA:IE) = PACK(PPHELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHATI)
      OUTAU(IA:IE) = PACK(PPHATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHMLI)
      OUTAU(IA:IE) = PACK(PPHMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHIOI)
      OUTAU(IA:IE) = PACK(PPHIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHPHTI)
      OUTAU(IA:IE) = PACK(PPHPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHPLI)
      OUTAU(IA:IE) = PACK(PPHPLI ,.TRUE.)




      IA = IE + 1
      IE = IA - 1 + SIZE(EAELI)
      OUTAU(IA:IE) = PACK(EAELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EAATI)
      OUTAU(IA:IE) = PACK(EAATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EAMLI)
      OUTAU(IA:IE) = PACK(EAMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EAIOI)
      OUTAU(IA:IE) = PACK(EAIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EAPHTI)
      OUTAU(IA:IE) = PACK(EAPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EAPLI)
      OUTAU(IA:IE) = PACK(EAPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMELI)
      OUTAU(IA:IE) = PACK(EMELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMATI)
      OUTAU(IA:IE) = PACK(EMATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMMLI)
      OUTAU(IA:IE) = PACK(EMMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMIOI)
      OUTAU(IA:IE) = PACK(EMIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMPHTI)
      OUTAU(IA:IE) = PACK(EMPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EMPLI)
      OUTAU(IA:IE) = PACK(EMPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIELI)
      OUTAU(IA:IE) = PACK(EIELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIATI)
      OUTAU(IA:IE) = PACK(EIATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIMLI)
      OUTAU(IA:IE) = PACK(EIMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIIOI)
      OUTAU(IA:IE) = PACK(EIIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIPHTI)
      OUTAU(IA:IE) = PACK(EIPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EIPLI)
      OUTAU(IA:IE) = PACK(EIPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHELI)
      OUTAU(IA:IE) = PACK(EPHELI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHATI)
      OUTAU(IA:IE) = PACK(EPHATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHMLI)
      OUTAU(IA:IE) = PACK(EPHMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHIOI)
      OUTAU(IA:IE) = PACK(EPHIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHPHTI)
      OUTAU(IA:IE) = PACK(EPHPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHPLI)
      OUTAU(IA:IE) = PACK(EPHPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ADDVI)
      OUTAU(IA:IE) = PACK(ADDVI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(COLVI)
      OUTAU(IA:IE) = PACK(COLVI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SNAPVI)
      OUTAU(IA:IE) = PACK(SNAPVI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(COPVI)
      OUTAU(IA:IE) = PACK(COPVI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(BGKVI)
      OUTAU(IA:IE) = PACK(BGKVI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ALGVI)
      OUTAU(IA:IE) = PACK(ALGVI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENAI)
      OUTAU(IA:IE) = PACK(PGENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENMI)
      OUTAU(IA:IE) = PACK(PGENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENII)
      OUTAU(IA:IE) = PACK(PGENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENPHI)
      OUTAU(IA:IE) = PACK(PGENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENAI)
      OUTAU(IA:IE) = PACK(EGENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENMI)
      OUTAU(IA:IE) = PACK(EGENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENII)
      OUTAU(IA:IE) = PACK(EGENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENPHI)
      OUTAU(IA:IE) = PACK(EGENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENAI)
      OUTAU(IA:IE) = PACK(VGENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENMI)
      OUTAU(IA:IE) = PACK(VGENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENII)
      OUTAU(IA:IE) = PACK(VGENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENPHI)
      OUTAU(IA:IE) = PACK(VGENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPATI)
      OUTAU(IA:IE) = PACK(PPATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPMLI)
      OUTAU(IA:IE) = PACK(PPMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPIOI)
      OUTAU(IA:IE) = PACK(PPIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPPHTI)
      OUTAU(IA:IE) = PACK(PPPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PPPLI)
      OUTAU(IA:IE) = PACK(PPPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPATI)
      OUTAU(IA:IE) = PACK(EPATI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPMLI)
      OUTAU(IA:IE) = PACK(EPMLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPIOI)
      OUTAU(IA:IE) = PACK(EPIOI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPPHTI)
      OUTAU(IA:IE) = PACK(EPPHTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EPPLI)
      OUTAU(IA:IE) = PACK(EPPLI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENAI)
      OUTAU(IA:IE) = PACK(VXDENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENMI)
      OUTAU(IA:IE) = PACK(VXDENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENII)
      OUTAU(IA:IE) = PACK(VXDENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENPHI)
      OUTAU(IA:IE) = PACK(VXDENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENAI)
      OUTAU(IA:IE) = PACK(VYDENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENMI)
      OUTAU(IA:IE) = PACK(VYDENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENII)
      OUTAU(IA:IE) = PACK(VYDENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENPHI)
      OUTAU(IA:IE) = PACK(VYDENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENAI)
      OUTAU(IA:IE) = PACK(VZDENAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENMI)
      OUTAU(IA:IE) = PACK(VZDENMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENII)
      OUTAU(IA:IE) = PACK(VZDENII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENPHI)
      OUTAU(IA:IE) = PACK(VZDENPHI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(MAPLI)
      OUTAU(IA:IE) = PACK(MAPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(MMPLI)
      OUTAU(IA:IE) = PACK(MMPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(MIPLI)
      OUTAU(IA:IE) = PACK(MIPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(MPHPLI)
      OUTAU(IA:IE) = PACK(MPHPLI,.TRUE.)




      IA = IE + 1
      IE = IA - 1 + SIZE(POTATI)
      OUTAU(IA:IE) = PACK(POTATI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAAI)
      OUTAU(IA:IE) = PACK(PRFAAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMAI)
      OUTAU(IA:IE) = PACK(PRFMAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIAI)
      OUTAU(IA:IE) = PACK(PRFIAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHAI)
      OUTAU(IA:IE) = PACK(PRFPHAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPAI)
      OUTAU(IA:IE) = PACK(PRFPAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(POTMLI)
      OUTAU(IA:IE) = PACK(POTMLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAMI)
      OUTAU(IA:IE) = PACK(PRFAMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMMI)
      OUTAU(IA:IE) = PACK(PRFMMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIMI)
      OUTAU(IA:IE) = PACK(PRFIMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHMI)
      OUTAU(IA:IE) = PACK(PRFPHMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPMI)
      OUTAU(IA:IE) = PACK(PRFPMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(POTIOI)
      OUTAU(IA:IE) = PACK(POTIOI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAII)
      OUTAU(IA:IE) = PACK(PRFAII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMII)
      OUTAU(IA:IE) = PACK(PRFMII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIII)
      OUTAU(IA:IE) = PACK(PRFIII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHII)
      OUTAU(IA:IE) = PACK(PRFPHII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPII)
      OUTAU(IA:IE) = PACK(PRFPII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(POTPHTI)
      OUTAU(IA:IE) = PACK(POTPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAPHTI)
      OUTAU(IA:IE) = PACK(PRFAPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMPHTI)
      OUTAU(IA:IE) = PACK(PRFMPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIPHTI)
      OUTAU(IA:IE) = PACK(PRFIPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHPHTI)
      OUTAU(IA:IE) = PACK(PRFPHPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPPHTI)
      OUTAU(IA:IE) = PACK(PRFPPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(POTPLI)
      OUTAU(IA:IE) = PACK(POTPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTATI)
      OUTAU(IA:IE) = PACK(EOTATI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAAI)
      OUTAU(IA:IE) = PACK(ERFAAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMAI)
      OUTAU(IA:IE) = PACK(ERFMAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIAI)
      OUTAU(IA:IE) = PACK(ERFIAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHAI)
      OUTAU(IA:IE) = PACK(ERFPHAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPAI)
      OUTAU(IA:IE) = PACK(ERFPAI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTMLI)
      OUTAU(IA:IE) = PACK(EOTMLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAMI)
      OUTAU(IA:IE) = PACK(ERFAMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMMI)
      OUTAU(IA:IE) = PACK(ERFMMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIMI)
      OUTAU(IA:IE) = PACK(ERFIMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHMI)
      OUTAU(IA:IE) = PACK(ERFPHMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPMI)
      OUTAU(IA:IE) = PACK(ERFPMI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTIOI)
      OUTAU(IA:IE) = PACK(EOTIOI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAII)
      OUTAU(IA:IE) = PACK(ERFAII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMII)
      OUTAU(IA:IE) = PACK(ERFMII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIII)
      OUTAU(IA:IE) = PACK(ERFIII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHII)
      OUTAU(IA:IE) = PACK(ERFPHII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPII)
      OUTAU(IA:IE) = PACK(ERFPII,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTPHTI)
      OUTAU(IA:IE) = PACK(EOTPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAPHTI)
      OUTAU(IA:IE) = PACK(ERFAPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMPHTI)
      OUTAU(IA:IE) = PACK(ERFMPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIPHTI)
      OUTAU(IA:IE) = PACK(ERFIPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHPHTI)
      OUTAU(IA:IE) = PACK(ERFPHPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPPHTI)
      OUTAU(IA:IE) = PACK(ERFPPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTPLI)
      OUTAU(IA:IE) = PACK(EOTPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTATI)
      OUTAU(IA:IE) = PACK(SPTATI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTMLI)
      OUTAU(IA:IE) = PACK(SPTMLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTIOI)
      OUTAU(IA:IE) = PACK(SPTIOI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTPHTI)
      OUTAU(IA:IE) = PACK(SPTPHTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTPLI)
      OUTAU(IA:IE) = PACK(SPTPLI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTTTI)
      OUTAU(IA:IE) = PACK(SPTTTI,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ADDSI)
      OUTAU(IA:IE) = PACK(ADDSI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ALGSI)
      OUTAU(IA:IE) = PACK(ALGSI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(SPUMPI)
      OUTAU(IA:IE) = PACK(SPUMPI,.TRUE.)




      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTA)
      OUTAU(IA:IE) = PACK(WTOTA ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTM)
      OUTAU(IA:IE) = PACK(WTOTM ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTI)
      OUTAU(IA:IE) = PACK(WTOTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTPH)
      OUTAU(IA:IE) = PACK(WTOTPH ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTP)
      OUTAU(IA:IE) = PACK(WTOTP ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTE)
      OUTAU(IA:IE) = PACK(WTOTE ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTA)
      OUTAU(IA:IE) = PACK(ETOTA ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTM)
      OUTAU(IA:IE) = PACK(ETOTM ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTI)
      OUTAU(IA:IE) = PACK(ETOTI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTPH)
      OUTAU(IA:IE) = PACK(ETOTPH ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTP)
      OUTAU(IA:IE) = PACK(ETOTP ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(XMCP)
      OUTAU(IA:IE) = PACK(XMCP  ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FLUXT)
      OUTAU(IA:IE) = PACK(FLUXT ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FLXFAC)
      OUTAU(IA:IE) = PACK(FLXFAC,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(EELFI)
      OUTAU(IA:IE) = PACK(EELFI ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(PTRASH)
      OUTAU(IA:IE) = PACK(PTRASH,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(ETRASH)
      OUTAU(IA:IE) = PACK(ETRASH,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FASCL)
      OUTAU(IA:IE) = PACK(FASCL ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FMSCL)
      OUTAU(IA:IE) = PACK(FMSCL ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FISCL)
      OUTAU(IA:IE) = PACK(FISCL ,.TRUE.)

      IA = IE + 1
      IE = IA - 1 + SIZE(FPHSCL)
      OUTAU(IA:IE) = PACK(FPHSCL ,.TRUE.)

      IF (IE /= NOUTAU) THEN
        WRITE (iunout,*) ' ERROR IN WRITE_COUTAU '
        WRITE (iunout,*) ' NOUTAU = ',NOUTAU,' IE = ',IE
        CALL EXIT_OWN(1)
      END IF

      RETURN
      END SUBROUTINE WRITE_COUTAU


      SUBROUTINE READ_COUTAU (OUTAU, IUNOUT)
      REAL(DP) :: OUTAU(:)
      INTEGER, INTENT(IN) :: IUNOUT
      INTEGER :: IA, IE

      IF (SIZE(OUTAU) < NOUTAU) THEN
        WRITE (iunout,*) 
     .  ' SIZE OF ARRAY OUTAU TOO SMALL IN READ_COUTAU '
        WRITE (iunout,*) ' OUTAU(',NOUTAU,') REQUIRED '
        CALL EXIT_OWN(1)
      END IF

      IA = 1
      IE = IA - 1 + SIZE(PDENAI)
      PDENAI = RESHAPE(OUTAU(IA:IE),SHAPE(PDENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENMI)
      PDENMI = RESHAPE(OUTAU(IA:IE),SHAPE(PDENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENII)
      PDENII = RESHAPE(OUTAU(IA:IE),SHAPE(PDENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PDENPHI)
      PDENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(PDENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENAI)
      EDENAI = RESHAPE(OUTAU(IA:IE),SHAPE(EDENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENMI)
      EDENMI = RESHAPE(OUTAU(IA:IE),SHAPE(EDENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENII)
      EDENII = RESHAPE(OUTAU(IA:IE),SHAPE(EDENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(EDENPHI)
      EDENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(EDENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAELI)
      PAELI  = RESHAPE(OUTAU(IA:IE),SHAPE(PAELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAATI)
      PAATI  = RESHAPE(OUTAU(IA:IE),SHAPE(PAATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAMLI)
      PAMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PAMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAIOI)
      PAIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(PAIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAPHTI)
      PAPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PAPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PAPLI)
      PAPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PAPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMELI)
      PMELI  = RESHAPE(OUTAU(IA:IE),SHAPE(PMELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMATI)
      PMATI  = RESHAPE(OUTAU(IA:IE),SHAPE(PMATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMMLI)
      PMMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PMMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMIOI)
      PMIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(PMIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMPHTI)
      PMPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PMPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PMPLI)
      PMPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PMPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIELI)
      PIELI  = RESHAPE(OUTAU(IA:IE),SHAPE(PIELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIATI)
      PIATI  = RESHAPE(OUTAU(IA:IE),SHAPE(PIATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIMLI)
      PIMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PIMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIIOI)
      PIIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(PIIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIPHTI)
      PIPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PIPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PIPLI)
      PIPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PIPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHELI)
      PPHELI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPHELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHATI)
      PPHATI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPHATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHMLI)
      PPHMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPHMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHIOI)
      PPHIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPHIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHPHTI)
      PPHPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PPHPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPHPLI)
      PPHPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPHPLI ))




      IA = IE + 1
      IE = IA - 1 + SIZE(EAELI)
      EAELI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EAATI)
      EAATI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EAMLI)
      EAMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EAIOI)
      EAIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EAPHTI)
      EAPHTI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAPHTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EAPLI)
      EAPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EAPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMELI)
      EMELI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMATI)
      EMATI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMMLI)
      EMMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMIOI)
      EMIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMPHTI)
      EMPHTI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMPHTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EMPLI)
      EMPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EMPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIELI)
      EIELI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIATI)
      EIATI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIMLI)
      EIMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIIOI)
      EIIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIPHTI)
      EIPHTI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIPHTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EIPLI)
      EIPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EIPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHELI)
      EPHELI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHELI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHATI)
      EPHATI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHMLI)
      EPHMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHIOI)
      EPHIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHPHTI)
      EPHPHTI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHPHTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPHPLI)
      EPHPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPHPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ADDVI)
      ADDVI  = RESHAPE(OUTAU(IA:IE),SHAPE(ADDVI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(COLVI)
      COLVI  = RESHAPE(OUTAU(IA:IE),SHAPE(COLVI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(SNAPVI)
      SNAPVI = RESHAPE(OUTAU(IA:IE),SHAPE(SNAPVI))

      IA = IE + 1
      IE = IA - 1 + SIZE(COPVI)
      COPVI  = RESHAPE(OUTAU(IA:IE),SHAPE(COPVI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(BGKVI)
      BGKVI  = RESHAPE(OUTAU(IA:IE),SHAPE(BGKVI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ALGVI)
      ALGVI  = RESHAPE(OUTAU(IA:IE),SHAPE(ALGVI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENAI)
      PGENAI = RESHAPE(OUTAU(IA:IE),SHAPE(PGENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENMI)
      PGENMI = RESHAPE(OUTAU(IA:IE),SHAPE(PGENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENII)
      PGENII = RESHAPE(OUTAU(IA:IE),SHAPE(PGENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PGENPHI)
      PGENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(PGENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENAI)
      EGENAI = RESHAPE(OUTAU(IA:IE),SHAPE(EGENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENMI)
      EGENMI = RESHAPE(OUTAU(IA:IE),SHAPE(EGENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENII)
      EGENII = RESHAPE(OUTAU(IA:IE),SHAPE(EGENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(EGENPHI)
      EGENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(EGENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENAI)
      VGENAI = RESHAPE(OUTAU(IA:IE),SHAPE(VGENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENMI)
      VGENMI = RESHAPE(OUTAU(IA:IE),SHAPE(VGENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENII)
      VGENII = RESHAPE(OUTAU(IA:IE),SHAPE(VGENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(VGENPHI)
      VGENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(VGENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPATI)
      PPATI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPMLI)
      PPMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPIOI)
      PPIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPPHTI)
      PPPHTI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPPHTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PPPLI)
      PPPLI  = RESHAPE(OUTAU(IA:IE),SHAPE(PPPLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPATI)
      EPATI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPATI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPMLI)
      EPMLI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPMLI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPIOI)
      EPIOI  = RESHAPE(OUTAU(IA:IE),SHAPE(EPIOI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPPHTI)
      EPPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(EPPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EPPLI)
      EPPLI = RESHAPE(OUTAU(IA:IE),SHAPE(EPPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENAI)
      VXDENAI = RESHAPE(OUTAU(IA:IE),SHAPE(VXDENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENMI)
      VXDENMI = RESHAPE(OUTAU(IA:IE),SHAPE(VXDENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENII)
      VXDENII = RESHAPE(OUTAU(IA:IE),SHAPE(VXDENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(VXDENPHI)
      VXDENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(VXDENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENAI)
      VYDENAI = RESHAPE(OUTAU(IA:IE),SHAPE(VYDENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENMI)
      VYDENMI = RESHAPE(OUTAU(IA:IE),SHAPE(VYDENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENII)
      VYDENII = RESHAPE(OUTAU(IA:IE),SHAPE(VYDENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(VYDENPHI)
      VYDENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(VYDENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENAI)
      VZDENAI = RESHAPE(OUTAU(IA:IE),SHAPE(VZDENAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENMI)
      VZDENMI = RESHAPE(OUTAU(IA:IE),SHAPE(VZDENMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENII)
      VZDENII = RESHAPE(OUTAU(IA:IE),SHAPE(VZDENII))

      IA = IE + 1
      IE = IA - 1 + SIZE(VZDENPHI)
      VZDENPHI = RESHAPE(OUTAU(IA:IE),SHAPE(VZDENPHI))

      IA = IE + 1
      IE = IA - 1 + SIZE(MAPLI)
      MAPLI = RESHAPE(OUTAU(IA:IE),SHAPE(MAPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(MMPLI)
      MMPLI = RESHAPE(OUTAU(IA:IE),SHAPE(MMPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(MIPLI)
      MIPLI = RESHAPE(OUTAU(IA:IE),SHAPE(MIPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(MPHPLI)
      MPHPLI = RESHAPE(OUTAU(IA:IE),SHAPE(MPHPLI))



      IA = IE + 1
      IE = IA - 1 + SIZE(POTATI)
      POTATI = RESHAPE(OUTAU(IA:IE),SHAPE(POTATI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAAI)
      PRFAAI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFAAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMAI)
      PRFMAI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFMAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIAI)
      PRFIAI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFIAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHAI)
      PRFPHAI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPHAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPAI)
      PRFPAI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(POTMLI)
      POTMLI = RESHAPE(OUTAU(IA:IE),SHAPE(POTMLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAMI)
      PRFAMI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFAMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMMI)
      PRFMMI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFMMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIMI)
      PRFIMI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFIMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHMI)
      PRFPHMI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPHMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPMI)
      PRFPMI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(POTIOI)
      POTIOI = RESHAPE(OUTAU(IA:IE),SHAPE(POTIOI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAII)
      PRFAII = RESHAPE(OUTAU(IA:IE),SHAPE(PRFAII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMII)
      PRFMII = RESHAPE(OUTAU(IA:IE),SHAPE(PRFMII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIII)
      PRFIII = RESHAPE(OUTAU(IA:IE),SHAPE(PRFIII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHII)
      PRFPHII = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPHII))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPII)
      PRFPII = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPII))

      IA = IE + 1
      IE = IA - 1 + SIZE(POTPHTI)
      POTPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(POTPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFAPHTI)
      PRFAPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFAPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFMPHTI)
      PRFMPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFMPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFIPHTI)
      PRFIPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFIPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPHPHTI)
      PRFPHPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPHPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(PRFPPHTI)
      PRFPPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(PRFPPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(POTPLI)
      POTPLI = RESHAPE(OUTAU(IA:IE),SHAPE(POTPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTATI)
      EOTATI = RESHAPE(OUTAU(IA:IE),SHAPE(EOTATI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAAI)
      ERFAAI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFAAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMAI)
      ERFMAI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFMAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIAI)
      ERFIAI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFIAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHAI)
      ERFPHAI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPHAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPAI)
      ERFPAI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPAI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTMLI)
      EOTMLI = RESHAPE(OUTAU(IA:IE),SHAPE(EOTMLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAMI)
      ERFAMI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFAMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMMI)
      ERFMMI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFMMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIMI)
      ERFIMI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFIMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHMI)
      ERFPHMI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPHMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPMI)
      ERFPMI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPMI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTIOI)
      EOTIOI = RESHAPE(OUTAU(IA:IE),SHAPE(EOTIOI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAII)
      ERFAII = RESHAPE(OUTAU(IA:IE),SHAPE(ERFAII))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMII)
      ERFMII = RESHAPE(OUTAU(IA:IE),SHAPE(ERFMII))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIII)
      ERFIII = RESHAPE(OUTAU(IA:IE),SHAPE(ERFIII))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHII)
      ERFPHII = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPHII))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPII)
      ERFPII = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPII))

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTPHTI)
      EOTPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(EOTPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFAPHTI)
      ERFAPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFAPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFMPHTI)
      ERFMPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFMPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFIPHTI)
      ERFIPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFIPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPHPHTI)
      ERFPHPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPHPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ERFPPHTI)
      ERFPPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(ERFPPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(EOTPLI)
      EOTPLI = RESHAPE(OUTAU(IA:IE),SHAPE(EOTPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTATI)
      SPTATI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTATI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTMLI)
      SPTMLI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTMLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTIOI)
      SPTIOI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTIOI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTPHTI)
      SPTPHTI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTPHTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTPLI)
      SPTPLI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTPLI))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPTTTI)
      SPTTTI = RESHAPE(OUTAU(IA:IE),SHAPE(SPTTTI))

      IA = IE + 1
      IE = IA - 1 + SIZE(ADDSI)
      ADDSI  = RESHAPE(OUTAU(IA:IE),SHAPE(ADDSI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ALGSI)
      ALGSI  = RESHAPE(OUTAU(IA:IE),SHAPE(ALGSI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(SPUMPI)
      SPUMPI = RESHAPE(OUTAU(IA:IE),SHAPE(SPUMPI))




      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTA)
      WTOTA  = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTA ))

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTM)
      WTOTM  = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTM ))

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTI)
      WTOTI  = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTPH)
      WTOTPH = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTPH))

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTP)
      WTOTP  = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTP ))

      IA = IE + 1
      IE = IA - 1 + SIZE(WTOTE)
      WTOTE  = RESHAPE(OUTAU(IA:IE),SHAPE(WTOTE ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTA)
      ETOTA  = RESHAPE(OUTAU(IA:IE),SHAPE(ETOTA ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTM)
      ETOTM  = RESHAPE(OUTAU(IA:IE),SHAPE(ETOTM ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTI)
      ETOTI  = RESHAPE(OUTAU(IA:IE),SHAPE(ETOTI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTPH)
      ETOTPH = RESHAPE(OUTAU(IA:IE),SHAPE(ETOTPH))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETOTP)
      ETOTP  = RESHAPE(OUTAU(IA:IE),SHAPE(ETOTP ))

      IA = IE + 1
      IE = IA - 1 + SIZE(XMCP)
      XMCP   = RESHAPE(OUTAU(IA:IE),SHAPE(XMCP  ))

      IA = IE + 1
      IE = IA - 1 + SIZE(FLUXT)
      FLUXT  = RESHAPE(OUTAU(IA:IE),SHAPE(FLUXT ))

      IA = IE + 1
      IE = IA - 1 + SIZE(FLXFAC)
      FLXFAC = RESHAPE(OUTAU(IA:IE),SHAPE(FLXFAC))

      IA = IE + 1
      IE = IA - 1 + SIZE(EELFI)
      EELFI  = RESHAPE(OUTAU(IA:IE),SHAPE(EELFI ))

      IA = IE + 1
      IE = IA - 1 + SIZE(PTRASH)
      PTRASH = RESHAPE(OUTAU(IA:IE),SHAPE(PTRASH))

      IA = IE + 1
      IE = IA - 1 + SIZE(ETRASH)
      ETRASH = RESHAPE(OUTAU(IA:IE),SHAPE(ETRASH))

      IA = IE + 1
      IE = IA - 1 + SIZE(FASCL)
      FASCL  = RESHAPE(OUTAU(IA:IE),SHAPE(FASCL ))

      IA = IE + 1
      IE = IA - 1 + SIZE(FMSCL)
      FMSCL  = RESHAPE(OUTAU(IA:IE),SHAPE(FMSCL ))

      IA = IE + 1
      IE = IA - 1 + SIZE(FISCL)
      FISCL  = RESHAPE(OUTAU(IA:IE),SHAPE(FISCL ))

      IA = IE + 1
      IE = IA - 1 + SIZE(FPHSCL)
      FPHSCL  = RESHAPE(OUTAU(IA:IE),SHAPE(FPHSCL ))

      IF (IE /= NOUTAU) THEN
        WRITE (iunout,*) ' ERROR IN READ_COUTAU '
        WRITE (iunout,*) ' NOUTAU = ',NOUTAU,' IE = ',IE
        CALL EXIT_OWN(1)
      END IF

      RETURN
      END SUBROUTINE READ_COUTAU


      SUBROUTINE FETCH_OUTAU (OUTAU,ITAL,ISP,ISTRA,IUNOUT)
      REAL(DP) :: OUTAU
      INTEGER, INTENT(IN) :: ITAL, ISP, ISTRA, IUNOUT

      SELECT CASE (ITAL)
      CASE (1)
        OUTAU = PDENAI(ISP,ISTRA)
      CASE (2)
        OUTAU = PDENMI(ISP,ISTRA)
      CASE (3)
        OUTAU = PDENII(ISP,ISTRA)
      CASE (4)
        OUTAU = PDENPHI(ISP,ISTRA)
      CASE (5)
        OUTAU = EDENAI(ISP,ISTRA)
      CASE (6)
        OUTAU = EDENMI(ISP,ISTRA)
      CASE (7)
        OUTAU = EDENII(ISP,ISTRA)
      CASE (8)
        OUTAU = EDENPHI(ISP,ISTRA)
      CASE (9)
        OUTAU = PAELI(ISTRA)
      CASE (10)
        OUTAU = PAATI(ISP,ISTRA)
      CASE (11)
        OUTAU = PAMLI(ISP,ISTRA)
      CASE (12)
        OUTAU = PAIOI(ISP,ISTRA)
      CASE (13)
        OUTAU = PAPHTI(ISP,ISTRA)
      CASE (14)
        OUTAU = PAPLI(ISP,ISTRA)
      CASE (15)
        OUTAU = PMELI(ISTRA)
      CASE (16)
        OUTAU = PMATI(ISP,ISTRA)
      CASE (17)
        OUTAU = PMMLI(ISP,ISTRA)
      CASE (18)
        OUTAU = PMIOI(ISP,ISTRA)
      CASE (19)
        OUTAU = PMPHTI(ISP,ISTRA)
      CASE (20)
        OUTAU = PMPLI(ISP,ISTRA)
      CASE (21)
        OUTAU = PIELI(ISTRA)
      CASE (22)
        OUTAU = PIATI(ISP,ISTRA)
      CASE (23)
        OUTAU = PIMLI(ISP,ISTRA)
      CASE (24)
        OUTAU = PIIOI(ISP,ISTRA)
      CASE (25)
        OUTAU = PIPHTI(ISP,ISTRA)
      CASE (26)
        OUTAU = PIPLI(ISP,ISTRA)
      CASE (27)
        OUTAU = PPHELI(ISTRA)
      CASE (28)
        OUTAU = PPHATI(ISP,ISTRA)
      CASE (29)
        OUTAU = PPHMLI(ISP,ISTRA)
      CASE (30)
        OUTAU = PPHIOI(ISP,ISTRA)
      CASE (31)
        OUTAU = PPHPHTI(ISP,ISTRA)
      CASE (32)
        OUTAU = PPHPLI(ISP,ISTRA)
      CASE (33)
        OUTAU = EAELI(ISTRA)
      CASE (34)
        OUTAU = EAATI(ISTRA)
      CASE (35)
        OUTAU = EAMLI(ISTRA)
      CASE (36)
        OUTAU = EAIOI(ISTRA)
      CASE (37)
        OUTAU = EAPHTI(ISTRA)
      CASE (38)
        OUTAU = EAPLI(ISTRA)
      CASE (39)
        OUTAU = EMELI(ISTRA)
      CASE (40)
        OUTAU = EMATI(ISTRA)
      CASE (41)
        OUTAU = EMMLI(ISTRA)
      CASE (42)
        OUTAU = EMIOI(ISTRA)
      CASE (43)
        OUTAU = EMPHTI(ISTRA)
      CASE (44)
        OUTAU = EMPLI(ISTRA)
      CASE (45)
        OUTAU = EIELI(ISTRA)
      CASE (46)
        OUTAU = EIATI(ISTRA)
      CASE (47)
        OUTAU = EIMLI(ISTRA)
      CASE (48)
        OUTAU = EIIOI(ISTRA)
      CASE (49)
        OUTAU = EIPHTI(ISTRA)
      CASE (50)
        OUTAU = EIPLI(ISTRA)
      CASE (51)
        OUTAU = EPHELI(ISTRA)
      CASE (52)
        OUTAU = EPHATI(ISTRA)
      CASE (53)
        OUTAU = EPHMLI(ISTRA)
      CASE (54)
        OUTAU = EPHIOI(ISTRA)
      CASE (55)
        OUTAU = EPHPHTI(ISTRA)
      CASE (56)
        OUTAU = EPHPLI(ISTRA)
      CASE (57)
        OUTAU = ADDVI(ISP,ISTRA)
      CASE (58)
        OUTAU = COLVI(ISP,ISTRA)
      CASE (59)
        OUTAU = SNAPVI(ISP,ISTRA)
      CASE (60)
        OUTAU = COPVI(ISP,ISTRA)
      CASE (61)
        OUTAU = BGKVI(ISP,ISTRA)
      CASE (62)
        OUTAU = ALGVI(ISP,ISTRA)
      CASE (63)
        OUTAU = PGENAI(ISP,ISTRA)
      CASE (64)
        OUTAU = PGENMI(ISP,ISTRA)
      CASE (65)
        OUTAU = PGENII(ISP,ISTRA)
      CASE (66)
        OUTAU = PGENPHI(ISP,ISTRA)
      CASE (67)
        OUTAU = EGENAI(ISP,ISTRA)
      CASE (68)
        OUTAU = EGENMI(ISP,ISTRA)
      CASE (69)
        OUTAU = EGENII(ISP,ISTRA)
      CASE (70)
        OUTAU = EGENPHI(ISP,ISTRA)
      CASE (71)
        OUTAU = VGENAI(ISP,ISTRA)
      CASE (72)
        OUTAU = VGENMI(ISP,ISTRA)
      CASE (73)
        OUTAU = VGENII(ISP,ISTRA)
      CASE (74)
        OUTAU = VGENPHI(ISP,ISTRA)
      CASE (75)
        OUTAU = PPATI(ISP,ISTRA)
      CASE (76)
        OUTAU = PPMLI(ISP,ISTRA)
      CASE (77)
        OUTAU = PPIOI(ISP,ISTRA)
      CASE (78)
        OUTAU = PPPHTI(ISP,ISTRA)
      CASE (79)
        OUTAU = PPPLI(ISP,ISTRA)
      CASE (80)
        OUTAU = EPATI(ISTRA)
      CASE (81)
        OUTAU = EPMLI(ISTRA)
      CASE (82)
        OUTAU = EPIOI(ISTRA)
      CASE (83)
        OUTAU = EPPHTI(ISTRA)
      CASE (84)
        OUTAU = EPPLI(ISTRA)
      CASE (85)
        OUTAU = VXDENAI(ISP,ISTRA)
      CASE (86)
        OUTAU = VXDENMI(ISP,ISTRA)
      CASE (87)
        OUTAU = VXDENII(ISP,ISTRA)
      CASE (88)
        OUTAU = VXDENPHI(ISP,ISTRA)
      CASE (89)
        OUTAU = VYDENAI(ISP,ISTRA)
      CASE (90)
        OUTAU = VYDENMI(ISP,ISTRA)
      CASE (91)
        OUTAU = VYDENII(ISP,ISTRA)
      CASE (92)
        OUTAU = VYDENPHI(ISP,ISTRA)
      CASE (93)
        OUTAU = VZDENAI(ISP,ISTRA)
      CASE (94)
        OUTAU = VZDENMI(ISP,ISTRA)
      CASE (95)
        OUTAU = VZDENII(ISP,ISTRA)
      CASE (96)
        OUTAU = VZDENPHI(ISP,ISTRA)
      CASE (97)
        OUTAU = MAPLI(ISP,ISTRA)
      CASE (98)
        OUTAU = MMPLI(ISP,ISTRA)
      CASE (99)
        OUTAU = MIPLI(ISP,ISTRA)
      CASE (100)
        OUTAU = MPHPLI(ISP,ISTRA)
      CASE DEFAULT
        WRITE (iunout,*) ' WRONG TALLY NUMBER IN FETCH_OUTAU '
        WRITE (iunout,*) ' 0 RETURNED '
        OUTAU = 0
      END SELECT

      RETURN
      END SUBROUTINE FETCH_OUTAU

      END MODULE COUTAU
C ===== SOURCE: cpes.f
      MODULE CPES

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CPES, DEALLOC_CPES, INIT_CPES

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I         NPESTR(:), NPESTA(:),
     I         NSTRPE(:)

      INTEGER, PUBLIC, SAVE ::
     I         NSTEFF, nprs, my_pe

      LOGICAL, PUBLIC, SAVE :: LIDENT


      CONTAINS


      SUBROUTINE ALLOC_CPES

      IF (ALLOCATED(NPESTR)) RETURN

      ALLOCATE (NPESTR(0:NSTRA))
      ALLOCATE (NPESTA(0:NSTRA))
      ALLOCATE (NSTRPE(0:NRPES-1))

      WRITE (55,'(A,T25,I15)')
     .      ' CPES ',(2*(NSTRA+1)+NRPES)*4

      CALL INIT_CPES

      RETURN
      END SUBROUTINE ALLOC_CPES


      SUBROUTINE DEALLOC_CPES

      IF (.NOT.ALLOCATED(NPESTR)) RETURN

      DEALLOCATE (NPESTR)
      DEALLOCATE (NPESTA)
      DEALLOCATE (NSTRPE)

      RETURN
      END SUBROUTINE DEALLOC_CPES


      SUBROUTINE INIT_CPES

      NPESTR = 0
      NPESTA = 0
      NSTRPE = 0

      RETURN
      END SUBROUTINE INIT_CPES

      END MODULE CPES
C ===== SOURCE: cpl3d.f
      MODULE CPL3D

      USE PRECISION

      IMPLICIT NONE

      PUBLIC

*COMDECK CPL3D
      REAL(DP), PUBLIC, SAVE ::
     R ANGLE1, ANGLE2, ANGLE3,
     R RMT,    WIN,    WINJ

      INTEGER, PUBLIC, SAVE ::
     I IPLAA(5,4), IPLEA(5,4), IPLTA(5),
     I IPLAS(3,4), IPLES(3,4), IPLTS(3)

      LOGICAL, PUBLIC, SAVE ::
     L PL3A(5), PL3S(3), PLBOX

      END MODULE CPL3D
C ===== SOURCE: cplmsk.f
      MODULE CPLMSK

      USE PRECISION

      IMPLICIT NONE

      PUBLIC

      REAL(DP), PUBLIC, SAVE ::
     R        X0PL, Y0PL

      REAL(SP), PUBLIC, SAVE ::
     R        LENX,   LENY,   MINX,   MINY,   MAXX,   MAXY,
     R        STPSZX, STPSZY

      INTEGER, PUBLIC, SAVE ::
     I         INTNRX, INTNRY, MINLX,  MINLY,  MAXLX,  MAXLY

      LOGICAL, PUBLIC, SAVE ::
     L         LOGX,   LOGY,   GRIDX,  GRIDY,  FITX,   FITY

      END MODULE CPLMSK
C ===== SOURCE: cplot.f
cdr  28.4.04:  NHSTS introduced (select species for trajectory plot)
      MODULE CPLOT

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CPLOT, DEALLOC_CPLOT, INIT_CPLOT

      REAL(DP), PUBLIC, SAVE ::
     R CH2X0, CH2Y0, CH2Z0, CH2MX, CH2MY,
     R CH3X0, CH3Y0, CH3Z0, CH3MX, CH3MY, CH3MZ,
     R XN2D,  YN2D,  FX2D,  FY2D,  RAPSDEL

      REAL(DP), PUBLIC,SAVE ::
     R CUTPLANE(4)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R TALZMI(:), TALZMA(:),
     R TALXMI(:), TALXMA(:),
     R TALYMI(:), TALYMA(:),
     R TALW1(:),  TALW2(:),
     R FCABS1(:), FCABS2(:)

      INTEGER, PUBLIC, SAVE ::
     I NPLINR, NPLOTR, NPLDLR, NPLINP, NPLOTP, NPLDLP,
     I NPLINT, NPLOTT, NPLDLT,
     I NVOLPL,
     I ISYPLT(8), ILINIE, IRAPS, NRAPS, IPLANE,
     I IPRADR, IPPOLR, IPTORR

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NPTALI(:,:),
     I NSPTAL(:),   ISPTAL(:,:),
     I NPLIN2(:,:), NPLOT2(:,:), NPLDL2(:,:),
     I IPROJ3(:,:),
     I NPLI13(:,:), NPLO13(:,:),
     I NPLI23(:,:), NPLO23(:,:),
     I NHSTS(:)

      LOGICAL, PUBLIC, SAVE ::
     L NLPL2D, NLPL3D,
     L PL1ST,  PL2ND,  PL3RD,  PLADD,   PLHST,   PLCUT(3),
     L PLCHOR, PLSPEC, PLSTOR, PLNUMV,  PLNUMS,  PLARR,
     L LPRADR, LPPOLR, LPTORR, LRAPS3D, LR3DCON, LRPSCUT

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L PLTSRC(:),
     L PLTL2D(:), PLTL3D(:), PLTLLG(:), PLTLER(:),
     L LHIST2(:), LSMOT2(:),
     L LHIST3(:), LCNTR3(:), LSMOT3(:), LRAPS3(:),
     L LVECT3(:), LRPVC3(:),
     L LPRAD3(:), LPPOL3(:), LPTOR3(:)

      CONTAINS


      SUBROUTINE ALLOC_CPLOT

      IF (ALLOCATED(TALZMI)) RETURN

      ALLOCATE (TALZMI(NPTAL))
      ALLOCATE (TALZMA(NPTAL))
      ALLOCATE (TALXMI(NPTAL))
      ALLOCATE (TALXMA(NPTAL))
      ALLOCATE (TALYMI(NPTAL))
      ALLOCATE (TALYMA(NPTAL))
      ALLOCATE (TALW1(NPTAL))
      ALLOCATE (TALW2(NPTAL))
      ALLOCATE (FCABS1(NPTAL))
      ALLOCATE (FCABS2(NPTAL))

      ALLOCATE (NPTALI(NPTAL,NPLT))
      ALLOCATE (NSPTAL(NPTAL))
      ALLOCATE (ISPTAL(NPTAL,NPLT))
      ALLOCATE (NPLIN2(NPTAL,NPLT))
      ALLOCATE (NPLOT2(NPTAL,NPLT))
      ALLOCATE (NPLDL2(NPTAL,NPLT))
      ALLOCATE (IPROJ3(NPTAL,NPLT))
      ALLOCATE (NPLI13(NPTAL,NPLT))
      ALLOCATE (NPLO13(NPTAL,NPLT))
      ALLOCATE (NPLI23(NPTAL,NPLT))
      ALLOCATE (NPLO23(NPTAL,NPLT))
      ALLOCATE (NHSTS(0:NSPZ))

      ALLOCATE (PLTSRC(0:NSTRA))
      ALLOCATE (PLTL2D(NPTAL))
      ALLOCATE (PLTL3D(NPTAL))
      ALLOCATE (PLTLLG(NPTAL))
      ALLOCATE (PLTLER(NPTAL))
      ALLOCATE (LHIST2(NPTAL))
      ALLOCATE (LSMOT2(NPTAL))
      ALLOCATE (LHIST3(NPTAL))
      ALLOCATE (LCNTR3(NPTAL))
      ALLOCATE (LSMOT3(NPTAL))
      ALLOCATE (LRAPS3(NPTAL))
      ALLOCATE (LVECT3(NPTAL))
      ALLOCATE (LRPVC3(NPTAL))
      ALLOCATE (LPRAD3(NPTAL))
      ALLOCATE (LPPOL3(NPTAL))
      ALLOCATE (LPTOR3(NPTAL))

      CALL INIT_CPLOT

      WRITE (55,'(A,T25,I15)')
     .      ' CPLOT ',10*NPTAL*8 + (10*NPLT+1)*NPTAL*4 +
     .                (NSTRA+1+15)*NPTAL+NSPZ*4

      RETURN

      END SUBROUTINE ALLOC_CPLOT


      SUBROUTINE DEALLOC_CPLOT

      IF (.NOT.ALLOCATED(TALZMI)) RETURN

      DEALLOCATE (TALZMI)
      DEALLOCATE (TALZMA)
      DEALLOCATE (TALXMI)
      DEALLOCATE (TALXMA)
      DEALLOCATE (TALYMI)
      DEALLOCATE (TALYMA)
      DEALLOCATE (TALW1)
      DEALLOCATE (TALW2)
      DEALLOCATE (FCABS1)
      DEALLOCATE (FCABS2)

      DEALLOCATE (NPTALI)
      DEALLOCATE (NSPTAL)
      DEALLOCATE (ISPTAL)
      DEALLOCATE (NPLIN2)
      DEALLOCATE (NPLOT2)
      DEALLOCATE (NPLDL2)
      DEALLOCATE (IPROJ3)
      DEALLOCATE (NPLI13)
      DEALLOCATE (NPLO13)
      DEALLOCATE (NPLI23)
      DEALLOCATE (NPLO23)
      DEALLOCATE (NHSTS)

      DEALLOCATE (PLTSRC)
      DEALLOCATE (PLTL2D)
      DEALLOCATE (PLTL3D)
      DEALLOCATE (PLTLLG)
      DEALLOCATE (PLTLER)
      DEALLOCATE (LHIST2)
      DEALLOCATE (LSMOT2)
      DEALLOCATE (LHIST3)
      DEALLOCATE (LCNTR3)
      DEALLOCATE (LSMOT3)
      DEALLOCATE (LRAPS3)
      DEALLOCATE (LVECT3)
      DEALLOCATE (LRPVC3)
      DEALLOCATE (LPRAD3)
      DEALLOCATE (LPPOL3)
      DEALLOCATE (LPTOR3)
      RETURN

      END SUBROUTINE DEALLOC_CPLOT


      SUBROUTINE INIT_CPLOT

      TALZMI = 0._DP
      TALZMA = 0._DP
      TALXMI = 0._DP
      TALXMA = 0._DP
      TALYMI = 0._DP
      TALYMA = 0._DP
      TALW1  = 0._DP
      TALW2  = 0._DP
      FCABS1 = 0._DP
      FCABS2 = 0._DP

      CUTPLANE = 0._DP

      NPTALI = 0
      NSPTAL = 0
      ISPTAL = 0
      NPLIN2 = 0
      NPLOT2 = 0
      NPLDL2 = 0
      IPROJ3 = 0
      NPLI13 = 0
      NPLO13 = 0
      NPLI23 = 0
      NPLO23 = 0
      NHSTS  = 0

      NLPL2D  = .FALSE.
      NLPL3D  = .FALSE.
      PL1ST   = .FALSE.
      PL2ND   = .FALSE.
      PL3RD   = .FALSE.
      PLADD   = .FALSE.
      PLHST   = .FALSE.
      PLCUT   = .FALSE.
      PLCHOR  = .FALSE.
      PLSPEC  = .FALSE.
      PLSTOR  = .FALSE.
      PLNUMV  = .FALSE.
      PLNUMS  = .FALSE.
      PLARR   = .FALSE.
      LPRADR  = .FALSE.
      LPPOLR  = .FALSE.
      LPTORR  = .FALSE.
      LRAPS3D = .FALSE.
      LR3DCON = .FALSE.
      LRPSCUT = .FALSE.

      PLTSRC = .FALSE.
      PLTL2D = .FALSE.
      PLTL3D = .FALSE.
      PLTLLG = .FALSE.
      PLTLER = .FALSE.
      LHIST2 = .FALSE.
      LSMOT2 = .FALSE.
      LHIST3 = .FALSE.
      LCNTR3 = .FALSE.
      LSMOT3 = .FALSE.
      LRAPS3 = .FALSE.
      LVECT3 = .FALSE.
      LRPVC3 = .FALSE.
      LPRAD3 = .FALSE.
      LPPOL3 = .FALSE.
      LPTOR3 = .FALSE.

      XN2D=-8.
      YN2D=12.
      FX2D=1.
      FY2D=1.

      RETURN

      END SUBROUTINE INIT_CPLOT

      END MODULE CPLOT
C ===== SOURCE: cpolyg.f
      MODULE CPOLYG

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CPOLYG, DEALLOC_CPOLYG, INIT_CPOLYG

      INTEGER, PUBLIC, SAVE :: NCPLYG, NCPLY2, MCPLYG

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        RCPLYG(:,:), RCPLY2(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
C NCPLYG, REAL
     R VPLX(:,:),  VPLY(:,:),
     R VVTX(:,:),  VVTY(:,:),
     R PLNX(:,:),  PLNY(:,:),
     R BGL(:,:),   BGLP(:,:),
     R PPLNX(:,:), PPLNY(:,:),
     R XPCOR,  YPCOR,  ZPCOR,  PLREFL

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICPLYG(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I NRPLG,  NPPLG


      CONTAINS


      SUBROUTINE ALLOC_CPOLYG

      IF (ALLOCATED(RCPLYG)) RETURN

      NCPLYG = N1STS*10*N2NDPLG
      NCPLY2 = 4
      MCPLYG = 2

      ALLOCATE (RCPLYG(10*N1STS,N2NDPLG))
      ALLOCATE (RCPLY2(NCPLY2))
      ALLOCATE (ICPLYG(MCPLYG))

      WRITE (55,'(A,T25,I15)')
     .       ' CPOLYG ',(NCPLYG+NCPLY2)*8 + MCPLYG*4

C NCPLYG, REAL
      VPLX  => RCPLYG(1+0*N1STS :  1*N1STS,:)
      VPLY  => RCPLYG(1+1*N1STS :  2*N1STS,:)
      VVTX  => RCPLYG(1+2*N1STS :  3*N1STS,:)
      VVTY  => RCPLYG(1+3*N1STS :  4*N1STS,:)
      PLNX  => RCPLYG(1+4*N1STS :  5*N1STS,:)
      PLNY  => RCPLYG(1+5*N1STS :  6*N1STS,:)
      BGL   => RCPLYG(1+6*N1STS :  7*N1STS,:)
      BGLP  => RCPLYG(1+7*N1STS :  8*N1STS,:)
      PPLNX => RCPLYG(1+8*N1STS :  9*N1STS,:)
      PPLNY => RCPLYG(1+9*N1STS : 10*N1STS,:)

      XPCOR  => RCPLY2(1)
      YPCOR  => RCPLY2(2)
      ZPCOR  => RCPLY2(3)
      PLREFL => RCPLY2(4)

C MCPLYG, INTEGER
      NRPLG => ICPLYG(1)
      NPPLG => ICPLYG(2)

      CALL INIT_CPOLYG

      RETURN
      END SUBROUTINE ALLOC_CPOLYG


      SUBROUTINE DEALLOC_CPOLYG

      IF (.NOT.ALLOCATED(RCPLYG)) RETURN

      DEALLOCATE (RCPLYG)
      DEALLOCATE (RCPLY2)
      DEALLOCATE (ICPLYG)

      RETURN
      END SUBROUTINE DEALLOC_CPOLYG


      SUBROUTINE INIT_CPOLYG

      RCPLYG = 0._DP
      RCPLY2 = 0._DP
      ICPLYG = 0

      RETURN
      END SUBROUTINE INIT_CPOLYG

      END MODULE CPOLYG
C ===== SOURCE: crand.f
      MODULE CRAND

      USE PRECISION

      IMPLICIT NONE

      PUBLIC

      REAL(DP), DIMENSION(64), PUBLIC, SAVE ::
     R FG1, FG2, FG3,
     R FM1, FM2, FM3,
     R FC1, FC2, FC3,
     R FI1, FI2, FI3

      INTEGER, PUBLIC, SAVE ::
     I INIV1,  INIV2,  INIV3,  INIV4,  IRNDVC, IRNDVH,
     I INTMAX, ISEEDR

      END MODULE CRAND
C ===== SOURCE: crech.f
!  16.01.07  subroutine for reinitialisation of point list introduced


      MODULE CRECH

      USE PRECISION

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: PPOINT,
     .          FIRST_POINT, LAST_POINT,
     .          INSTOR, INUMS, INOSF,
     .          LZR, CRECH_REINIT 

      TYPE :: PPOINT
        REAL(DP) :: XPL2D, YPL2D
        INTEGER :: NPL2D, NUMSUR
        TYPE(PPOINT), POINTER :: NXTPNT
      END TYPE PPOINT

      TYPE(PPOINT), POINTER :: FIRST_POINT, LAST_POINT
      INTEGER, SAVE :: INSTOR=0, INUMS, INOSF
      LOGICAL :: LZR

      contains

C     The following subroutine is for reinitialization of EIRENE (DMH)

      SUBROUTINE CRECH_REINIT
      IMPLICIT NONE
      TYPE(PPOINT), POINTER :: CUR

      CUR => FIRST_POINT
      DO WHILE (ASSOCIATED(CUR))
         FIRST_POINT => CUR
         CUR => CUR%NXTPNT
         DEALLOCATE(FIRST_POINT)
      END DO

      NULLIFY(FIRST_POINT)
      NULLIFY(LAST_POINT)

      INSTOR=0
      return
      end subroutine CRECH_REINIT
      

      END MODULE CRECH
C ===== SOURCE: cref.f
      MODULE CREF

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CREF, DEALLOC_CREF, INIT_CREF

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCREF(:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ICREF(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R RPROB0,    ERMIN,     ERCUT,
     R ENAR(:),   DENAR(:),  WIAR(:),   DWIAR(:),  RAAR(:),
     R DRAAR(:),
     R TM(:),     TC(:),     WM(:),     WC(:),    ERDC(:),  HFTR3F(:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R RINTEG(:), EINTEG(:), AINTEG(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I INE, INEM, INW, INWM, INR, INRM, NFLR

      INTEGER, PUBLIC, SAVE :: NCREF, MCREF

      LOGICAL, PUBLIC, SAVE :: LTRMOL

      CHARACTER(72), PUBLIC, ALLOCATABLE, SAVE :: REFFIL(:)


      CONTAINS


      SUBROUTINE ALLOC_CREF

      IF (ALLOCATED(RCREF)) RETURN

      NCREF = 3+12+11+7+6+5+4+5*NHD6+NHD5
      MCREF  = 7

      ALLOCATE (RCREF(NCREF))
      ALLOCATE (ICREF(MCREF))
      ALLOCATE (REFFIL(NHD6))

      ALLOCATE (RINTEG(0:NLIMPS))
      ALLOCATE (EINTEG(0:NLIMPS))
      ALLOCATE (AINTEG(0:NLIMPS))

      WRITE (55,'(A,T25,I15)')
     .       ' CREF ',(NCREF+3*(NLIMPS+1))*8 + MCREF*4 + NHD6*72

      RPROB0    => RCREF(1)
      ERMIN     => RCREF(2)
      ERCUT     => RCREF(3)
      ENAR      => RCREF(4:15)
      DENAR     => RCREF(16:26)
      WIAR      => RCREF(27:33)
      DWIAR     => RCREF(34:39)
      RAAR      => RCREF(40:44)
      DRAAR     => RCREF(45:48)
      TM        => RCREF(49+0*NHD6 : 48+1*NHD6)
      TC        => RCREF(49+1*NHD6 : 48+2*NHD6)
      WM        => RCREF(49+2*NHD6 : 48+3*NHD6)
      WC        => RCREF(49+3*NHD6 : 48+4*NHD6)
      ERDC      => RCREF(49+4*NHD6 : 48+5*NHD6)
      HFTR3F    => RCREF(49+5*NHD6 : 48+5*NHD6+NHD5)

      INE  => ICREF(1)
      INEM => ICREF(2)
      INW  => ICREF(3)
      INWM => ICREF(4)
      INR  => ICREF(5)
      INRM => ICREF(6)
      NFLR => ICREF(7)

      CALL INIT_CREF

      RETURN
      END SUBROUTINE ALLOC_CREF


      SUBROUTINE DEALLOC_CREF

      IF (.NOT.ALLOCATED(RCREF)) RETURN

      DEALLOCATE (RCREF)
      DEALLOCATE (ICREF)
      DEALLOCATE (REFFIL)

      DEALLOCATE (RINTEG)
      DEALLOCATE (EINTEG)
      DEALLOCATE (AINTEG)

      RETURN
      END SUBROUTINE DEALLOC_CREF


      SUBROUTINE INIT_CREF

      RCREF  = 0._DP
      ICREF  = 0
      REFFIL = ' '

      RINTEG = 0._DP
      EINTEG = 0._DP
      AINTEG = 0._DP

      RETURN
      END SUBROUTINE INIT_CREF


      END MODULE CREF
C ===== SOURCE: crefmod.f
      MODULE CREFMOD

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CREFMOD, DEALLOC_CREFMOD, INIT_CREFMOD

      REAL(DP), ALLOCATABLE, PUBLIC :: HFTR0(:,:,:),
     .                               HFTR1(:,:,:,:),
     .                               HFTR2(:,:,:,:,:),
     .                               HFTR3(:,:,:,:,:,:)


      CONTAINS


      SUBROUTINE ALLOC_CREFMOD

      IF (ALLOCATED(HFTR0)) RETURN

      ALLOCATE (HFTR0(NHD1,NHD2,NHD6))
      ALLOCATE (HFTR1(NHD1,NHD2,NHD3,NHD6))
      ALLOCATE (HFTR2(NHD1,NHD2,NHD3,NHD4,NHD6))
      ALLOCATE (HFTR3(NHD1,NHD2,NHD3,NHD4,NHD5,NHD6))

      WRITE (55,'(A,T25,I15)')
     .      ' CREFMOD ',(NHD1*NHD2*NHD6*(1+NHD3*(1+NHD4*
     .                   (1+NHD5))))*8

      CALL INIT_CREFMOD

      RETURN
      END SUBROUTINE ALLOC_CREFMOD


      SUBROUTINE DEALLOC_CREFMOD

      IF (.NOT.ALLOCATED(HFTR0)) RETURN

      DEALLOCATE (HFTR0)
      DEALLOCATE (HFTR1)
      DEALLOCATE (HFTR2)
      DEALLOCATE (HFTR3)

      RETURN
      END SUBROUTINE DEALLOC_CREFMOD


      SUBROUTINE INIT_CREFMOD

      HFTR0 = 0._DP
      HFTR1 = 0._DP
      HFTR2 = 0._DP
      HFTR3 = 0._DP

      RETURN
      END SUBROUTINE INIT_CREFMOD

      END MODULE CREFMOD


C ===== SOURCE: csdvi.f
      MODULE CSDVI

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSDVI, DEALLOC_CSDVI, INIT_CSDVI

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        SDVI1(:,:), SDVI2(:,:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R SIGMA(:,:),    SGMS(:),
     R SIGMAW(:,:),   SGMWS(:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R SIGMAC(:,:,:), SGMCS(:,:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     I         ISDVI(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I IIH(:),    IGH(:),
     I IIHW(:),   IGHW(:),
     I ICOV(:),
     I NSIGI,     NSIGVI,   NSIGSI, NSIGCI, NSIGI_BGK, NSIGI_COP,
     I NSIGI_SPC,
C SPEED UP OF SUBROUTINE STATIS
     I IMETCL(:), ICLMT(:), NCLMT, NCLMTS

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I IIHC(:,:), IGHC(:,:)

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L LMETSP(:)

      INTEGER, PUBLIC, SAVE ::
     I NSDVI1, NSDVI2, NSDVC1, NSDVC2, NSDVI, MSDVI


      CONTAINS


      SUBROUTINE ALLOC_CSDVI (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(SDVI1)) RETURN

        NSDVI1 = NSD*(NRTAL+1)
        NSDVI2 = NSDW*(NLIMPS+1)
        NSDVC1 = 3*NCV*NRTAL
        NSDVC2 = 3*NCV
        NSDVI  = NSDVI1+NSDVI2+NSDVC1+NSDVC2
        MSDVI  = NSD*2+NSDW*2+NCV+7+2*NRTAL+2


        ALLOCATE (SDVI1(NSD,NRTAL+1))
        ALLOCATE (SDVI2(NSDW,NLIMPS+1))
        ALLOCATE (SIGMAC(0:2,NCV,NRTAL))
        ALLOCATE (SGMCS(0:2,NCV))

        ALLOCATE (ISDVI(MSDVI))
        ALLOCATE (IIHC(2,NCV))
        ALLOCATE (IGHC(2,NCV))

        WRITE (55,'(A,T25,I15)')
     .        ' CSDVI ',(NSD*(NRTAL+1) + NSDW*(NLIMPS+1) +
     .                   (NRTAL+1)*3*NCV)*8 +
     .                  (MSDVI+4*NCV)*4

        SIGMA  => SDVI1(:,1:NRTAL)
        SGMS   => SDVI1(:,NRTAL+1)

        SIGMAW => SDVI2(:,1:NLIMPS)
        SGMWS  => SDVI2(:,NLIMPS+1)

        NSIGI     => ISDVI(1)
        NSIGVI    => ISDVI(2)
        NSIGSI    => ISDVI(3)
        NSIGCI    => ISDVI(4)
        NSIGI_BGK => ISDVI(5)
        NSIGI_COP => ISDVI(6)
        NSIGI_SPC => ISDVI(7)
        NCLMT     => ISDVI(8)
        NCLMTS    => ISDVI(9)
        IIH       => ISDVI(10                  : 9+  NSD)
        IGH       => ISDVI(10+  NSD            : 9+2*NSD)
        IIHW      => ISDVI(10+2*NSD            : 9+2*NSD+  NSDW)
        IGHW      => ISDVI(10+2*NSD+  NSDW     : 9+2*NSD+2*NSDW)
        ICOV      => ISDVI(10+2*NSD+2*NSDW     : 9+2*NSD+2*NSDW+NCV)
        IMETCL    => ISDVI(10+2*NSD+2*NSDW+NCV :
     .                     9+2*NSD+2*NSDW+NCV+NRTAL)
        ICLMT     => ISDVI(10+2*NSD+2*NSDW+NCV+NRTAL : MSDVI)

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(LMETSP)) RETURN

!pb        ALLOCATE (LMETSP(N1MX+NSNV))
        ALLOCATE (LMETSP(NSPZTOT+NSNV))

      END IF

      CALL INIT_CSDVI (ICAL)

      RETURN
      END SUBROUTINE ALLOC_CSDVI


      SUBROUTINE DEALLOC_CSDVI

      IF (.NOT.ALLOCATED(SDVI1)) RETURN

      DEALLOCATE (SDVI1)
      DEALLOCATE (SDVI2)
      DEALLOCATE (SIGMAC)
      DEALLOCATE (SGMCS)

      DEALLOCATE (ISDVI)
      DEALLOCATE (IIHC)
      DEALLOCATE (IGHC)

      DEALLOCATE (LMETSP)

      RETURN
      END SUBROUTINE DEALLOC_CSDVI


      SUBROUTINE INIT_CSDVI (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        SDVI1  = 0._DP
        SDVI2  = 0._DP
        SIGMAC = 0._DP
        SGMCS  = 0._DP

        ISDVI  = 0
        IIHC   = 0
        IGHC   = 0

      ELSE IF (ICAL == 2) THEN

        LMETSP = .FALSE.

      END IF

      RETURN
      END SUBROUTINE INIT_CSDVI

      END MODULE CSDVI
C ===== SOURCE: csdvi_bgk.f
      MODULE CSDVI_BGK

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSDVI_BGK, DEALLOC_CSDVI_BGK, INIT_CSDVI_BGK

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  SIGMA_BGK(:,:), SGMS_BGK(:),
     R  STV_BGK(:,:),   STVS_BGK(:),
     R  SDVIA_BGK(:,:), EE_BGK(:,:), EES_BGK(:)

      INTEGER, PUBLIC, SAVE ::
     I  NBGV_STAT, NSBGK, NBGVI_STAT


      CONTAINS


      SUBROUTINE ALLOC_CSDVI_BGK

      IF (ALLOCATED(SIGMA_BGK)) RETURN

      NBGV_STAT=(NBGV+2*(NATM+NMOL))*NSWIT+1
      NSBGK=NBGV_STAT*NRTALS

      ALLOCATE (SIGMA_BGK(NBGV_STAT,NRTALS))
      ALLOCATE (SGMS_BGK(NBGV_STAT))
      ALLOCATE (STV_BGK(NBGV_STAT,NRTALS))
      ALLOCATE (STVS_BGK(NBGV_STAT))
      ALLOCATE (SDVIA_BGK(NBGV_STAT,NRTALS))
      ALLOCATE (EE_BGK(NBGV_STAT,NRTALS))
      ALLOCATE (EES_BGK(NBGV_STAT))

      WRITE (55,'(A,T25,I15)')
     .      ' CSDVI_BGK ',(4*NRTALS+3)*NBGV_STAT*8

      CALL INIT_CSDVI_BGK

      RETURN
      END SUBROUTINE ALLOC_CSDVI_BGK


      SUBROUTINE DEALLOC_CSDVI_BGK

      IF (.NOT.ALLOCATED(SIGMA_BGK)) RETURN

      DEALLOCATE (SIGMA_BGK)
      DEALLOCATE (SGMS_BGK)
      DEALLOCATE (STV_BGK)
      DEALLOCATE (STVS_BGK)
      DEALLOCATE (SDVIA_BGK)
      DEALLOCATE (EE_BGK)
      DEALLOCATE (EES_BGK)

      RETURN
      END SUBROUTINE DEALLOC_CSDVI_BGK


      SUBROUTINE INIT_CSDVI_BGK

      SIGMA_BGK = 0._DP
      SGMS_BGK  = 0._DP
      STV_BGK   = 0._DP
      STVS_BGK  = 0._DP
      SDVIA_BGK = 0._DP
      EE_BGK    = 0._DP
      EES_BGK   = 0._DP

      RETURN
      END SUBROUTINE INIT_CSDVI_BGK

      END MODULE CSDVI_BGK
C ===== SOURCE: csdvi_cop.f
      MODULE CSDVI_COP

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSDVI_COP, DEALLOC_CSDVI_COP, INIT_CSDVI_COP

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  SIGMA_COP(:,:), SGMS_COP(:),
     R  STV_COP(:,:),   STVS_COP(:),
     R  SDVIA_COP(:,:), EE_COP(:,:), EES_COP(:)

      INTEGER, PUBLIC, SAVE :: NCPVI_STAT


      CONTAINS


      SUBROUTINE ALLOC_CSDVI_COP

      IF (ALLOCATED(SIGMA_COP)) RETURN

      ALLOCATE (SIGMA_COP(NCPV_STAT,NRTALS))
      ALLOCATE (STV_COP(NCPV_STAT,NRTALS))
      ALLOCATE (SDVIA_COP(NCPV_STAT,NRTALS))
      ALLOCATE (EE_COP(NCPV_STAT,NRTALS))

      ALLOCATE (SGMS_COP(NCPV_STAT))
      ALLOCATE (STVS_COP(NCPV_STAT))
      ALLOCATE (EES_COP(NCPV_STAT))

      WRITE (55,'(A,T25,I15)')
     .       ' CSDVI_COP ',(4*NRTALS+3)*NCPV_STAT*8

      CALL INIT_CSDVI_COP

      RETURN
      END SUBROUTINE ALLOC_CSDVI_COP


      SUBROUTINE DEALLOC_CSDVI_COP

      IF (.NOT.ALLOCATED(SIGMA_COP)) RETURN

      DEALLOCATE (SIGMA_COP)
      DEALLOCATE (STV_COP)
      DEALLOCATE (SDVIA_COP)
      DEALLOCATE (EE_COP)

      DEALLOCATE (SGMS_COP)
      DEALLOCATE (STVS_COP)
      DEALLOCATE (EES_COP)

      RETURN
      END SUBROUTINE DEALLOC_CSDVI_COP


      SUBROUTINE INIT_CSDVI_COP

      SIGMA_COP = 0._DP
      STV_COP   = 0._DP
      SDVIA_COP = 0._DP
      EE_COP    = 0._DP

      SGMS_COP  = 0._DP
      STVS_COP  = 0._DP
      EES_COP   = 0._DP

      RETURN
      END SUBROUTINE INIT_CSDVI_COP

      END MODULE CSDVI_COP
C ===== SOURCE: cspei.f
      MODULE CSPEI

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSPEI, DEALLOC_CSPEI, INIT_CSPEI,
     P          ALLOC_BCKGRND, DEALLOC_BCKGRND, INIT_BCKGRND

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R  SMESTV(:,:), SMESTS(:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  STV(:,:), STVW(:,:), STVC(:,:,:),
     R  STVS(:),  STVWS(:),  STVCS(:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R  EE(:,:),    FF(:,:),
     R  EES(:),     FFS(:),
     R  SDVIA(:,:), SDVIAW(:,:), SDVIAC(:,:,:)

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R  PLASMA_BCKGRND(:,:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     .  TEINTF(:),   TIINTF(:,:), DIINTF(:,:),
     .  VXINTF(:,:), VYINTF(:,:), VZINTF(:,:),
     .  BXINTF(:),   BYINTF(:),   BZINTF(:),   BFINTF(:),
     .  VLINTF(:),   ADINTF(:,:)

      INTEGER, PUBLIC, SAVE :: IESTR

      INTEGER, PUBLIC, SAVE ::
     I  NIDC, NIDV, NIDS


      CONTAINS


      SUBROUTINE ALLOC_CSPEI

      IF (ALLOCATED(SMESTV)) RETURN

      IF (NSMSTRA > 0) THEN
        NIDV=NVOLTL
        NIDS=NSRFTL
      ELSE
        NIDV=1
        NIDS=1
      END IF

      ALLOCATE (SMESTV(NIDV,NRTAL))
      ALLOCATE (SMESTS(NIDS,NLMPGS))

      ALLOCATE (STV(NSD,NRTAL))
      ALLOCATE (STVW(NSDW,NLIMPS))
      ALLOCATE (STVC(0:2,NCV,NRTAL))
      ALLOCATE (STVS(NSD))
      ALLOCATE (STVWS(NSDW))
      ALLOCATE (STVCS(0:2,NCV))
      ALLOCATE (EE(NSD,NRTAL))
      ALLOCATE (FF(NSDW,NLIMPS))
      ALLOCATE (EES(NSD))
      ALLOCATE (FFS(NSDW))
      ALLOCATE (SDVIA(NSD,NRTAL))
      ALLOCATE (SDVIAW(NSDW,NLIMPS))
      ALLOCATE (SDVIAC(2,NCV,NRTAL))

      WRITE (55,'(A,T25,I15)')
     .       ' CSPEI ',(NIDV*NRTAL+(3*NSD+5*NCV)*NRTAL +
     .                  NIDS*NLMPGS + 3*NSDW*NLIMPS + 2*NSD +
     .                  2*NSDW + 3*NCV)*8

      CALL INIT_CSPEI

      RETURN
      END SUBROUTINE ALLOC_CSPEI


      SUBROUTINE DEALLOC_CSPEI

      IF (.NOT.ALLOCATED(SMESTV)) RETURN

      DEALLOCATE (SMESTV)
      DEALLOCATE (SMESTS)

      DEALLOCATE (STV)
      DEALLOCATE (STVW)
      DEALLOCATE (STVC)
      DEALLOCATE (STVS)
      DEALLOCATE (STVWS)
      DEALLOCATE (STVCS)
      DEALLOCATE (EE)
      DEALLOCATE (FF)
      DEALLOCATE (EES)
      DEALLOCATE (FFS)
      DEALLOCATE (SDVIA)
      DEALLOCATE (SDVIAW)
      DEALLOCATE (SDVIAC)

      RETURN
      END SUBROUTINE DEALLOC_CSPEI


      SUBROUTINE INIT_CSPEI

      SMESTV = 0._DP
      SMESTS = 0._DP

      STV    = 0._DP
      STVW   = 0._DP
      STVC   = 0._DP
      STVS   = 0._DP
      STVWS  = 0._DP
      STVCS  = 0._DP
      EE     = 0._DP
      FF     = 0._DP
      EES    = 0._DP
      FFS    = 0._DP
      SDVIA  = 0._DP
      SDVIAW = 0._DP
      SDVIAC = 0._DP

      RETURN
      END SUBROUTINE INIT_CSPEI


      SUBROUTINE ALLOC_BCKGRND

c      NIDC=1*NPLS+NAIN+6+NPLSTI+3*NPLSV ! bug, SL, 31.12.2018
      NIDC=1*NPLS+NAIN+6+NPLSTI+4*NPLSV

      IF (.NOT.ALLOCATED(PLASMA_BCKGRND)) THEN

        ALLOCATE(PLASMA_BCKGRND(NIDC,NRAD))

        TEINTF => PLASMA_BCKGRND(1+0+0*NPLS             , :)
        TIINTF => PLASMA_BCKGRND(1+1+0*NPLS        :
     .                           1+0+0*NPLS+NPLSTI, :)
        DIINTF => PLASMA_BCKGRND(1+1+0*NPLS+NPLSTI :
     .                           1+0+1*NPLS+NPLSTI, :)
        VXINTF => PLASMA_BCKGRND(1+1+1*NPLS+NPLSTI+0*NPLSV :
     .                           1+0+1*NPLS+NPLSTI+1*NPLSV, :)
        VYINTF => PLASMA_BCKGRND(1+1+1*NPLS+NPLSTI+1*NPLSV :
     .                           1+0+1*NPLS+NPLSTI+2*NPLSV, :)
        VZINTF => PLASMA_BCKGRND(1+1+1*NPLS+NPLSTI+2*NPLSV :
     .                           1+0+1*NPLS+NPLSTI+3*NPLSV, :)
        BXINTF => PLASMA_BCKGRND(1+1+1*NPLS+NPLSTI+3*NPLSV, :)
        BYINTF => PLASMA_BCKGRND(1+2+1*NPLS+NPLSTI+3*NPLSV, :)
        BZINTF => PLASMA_BCKGRND(1+3+1*NPLS+NPLSTI+3*NPLSV, :)
        BFINTF => PLASMA_BCKGRND(1+4+1*NPLS+NPLSTI+3*NPLSV, :)
        VLINTF => PLASMA_BCKGRND(1+5+1*NPLS+NPLSTI+3*NPLSV, :)
        ADINTF => PLASMA_BCKGRND(1+6+1*NPLS+NPLSTI+3*NPLSV :
     .                             6+1*NPLS+NPLSTI+4*NPLSV+NAIN, :)

        CALL INIT_BCKGRND

      END IF

      RETURN
      END SUBROUTINE ALLOC_BCKGRND


      SUBROUTINE DEALLOC_BCKGRND

      IF (ALLOCATED(PLASMA_BCKGRND)) DEALLOCATE(PLASMA_BCKGRND)

      NULLIFY(TEINTF)
      NULLIFY(TIINTF)
      NULLIFY(DIINTF)
      NULLIFY(VXINTF)
      NULLIFY(VYINTF)
      NULLIFY(VZINTF)
      NULLIFY(BXINTF)
      NULLIFY(BYINTF)
      NULLIFY(BZINTF)
      NULLIFY(BFINTF)
      NULLIFY(VLINTF)
      NULLIFY(ADINTF)

      RETURN
      END SUBROUTINE DEALLOC_BCKGRND


      SUBROUTINE INIT_BCKGRND

      PLASMA_BCKGRND = 0._DP

      RETURN
      END SUBROUTINE INIT_BCKGRND

      END MODULE CSPEI


C ===== SOURCE: cspez.f
      MODULE CSPEZ

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSPEZ, DEALLOC_CSPEZ, INIT_CSPEZ

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE ::
     L LOGATM(:,:), LOGION(:,:),
     L LOGMOL(:,:), LOGPLS(:,:), LOGPHOT(:,:)


      CONTAINS

      SUBROUTINE ALLOC_CSPEZ

      IF (ALLOCATED(LOGATM)) RETURN

      ALLOCATE (LOGATM(0:NATM,0:NSTRA))
      ALLOCATE (LOGION(0:NION,0:NSTRA))
      ALLOCATE (LOGMOL(0:NMOL,0:NSTRA))
      ALLOCATE (LOGPLS(0:NPLS,0:NSTRA))
      ALLOCATE (LOGPHOT(0:NPHOT,0:NSTRA))

      WRITE (55,'(A,T25,I15)')
     .      ' CSPEZ ', (NSTRA+1)*(NPHOT+NATM+NION+NMOL+NPLS+5)*4

      CALL INIT_CSPEZ

      RETURN
      END SUBROUTINE ALLOC_CSPEZ


      SUBROUTINE DEALLOC_CSPEZ

      IF (.NOT.ALLOCATED(LOGATM)) RETURN

      DEALLOCATE (LOGATM)
      DEALLOCATE (LOGION)
      DEALLOCATE (LOGMOL)
      DEALLOCATE (LOGPLS)
      DEALLOCATE (LOGPHOT)

      RETURN
      END SUBROUTINE DEALLOC_CSPEZ


      SUBROUTINE INIT_CSPEZ

      LOGATM  = .FALSE.
      LOGION  = .FALSE.
      LOGMOL  = .FALSE.
      LOGPLS  = .FALSE.
      LOGPHOT = .FALSE.

      RETURN
      END SUBROUTINE INIT_CSPEZ

      END MODULE CSPEZ
C ===== SOURCE: cstep.f
      MODULE CSTEP
c  step functions for specification of incident fluxes on
c                 surfaces, with spatial resolution along surface
C    FLSTEP: total ion particle flux at sheath entrance (s.e.)
C    ELSTEP: total ion energy flux   at sheath entrance (s.e.)
C    RRSTEP: abszissa, i.e. arclength along target (cm)
c
c  JET-2005: patch 1
c  9.9.05:  new step function parameters: 
c    festep,fistep,shstep,vpstep,mcstep
c    festep: electron energy flux at sheath entrance (s.e.) is festep*testep
c            e.g.: flstep=4.5= 2 + 2.5 (2: maxwellian energy flux, 2.5: sheath)
c    fistep: thermal part of ion energy flux at s.e. is fistep*tistep
c            e.g.: fistep= 2.5 (drifting maxwellian thermal energy flux,
c                               with Mach=1 (or: ion thermal veloc=1 ?).
c    shstep: sheath multiplier:  sheath potential is shstep*testep
c            e.g.: shstep= 2.5 (hydrogen, M=1, Te=Ti, single fluid)
c            e.g.: shstep= 2.8 (deuteron, M=1, Te=Ti, single fluid)
c    vpstep: parallel to B-field drift velocity (cm/s) at s.e.
c    mcstep: mach number of parallel flow at s.e.
c
c   there is now a certain redundancy of information on plasma
c   conditions along target surfaces. This may facilitate consistency
c   checks for boundary conditions in case of coupling to edge plasma codes.
C  11.11.05:  ve and eltot introduced, to provide energy flux step function
c
c
      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CSTEP, DEALLOC_CSTEP, INIT_CSTEP

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R FLSTEP(:,:,:), ELSTEP(:,:,:), FLTOT(:,:), ELTOT(:,:),
     R VF(:,:,:),  VE(:,:,:),   QUOT(:,:,:),   ADD(:,:,:),
     R QUOTI(:,:,:),  ADDIV(:,:,:),
     R TESTEP(:,:),   TISTEP(:,:,:), RRSTEP(:,:),
     R VXSTEP(:,:,:), VYSTEP(:,:,:), VZSTEP(:,:,:),
     R DISTEP(:,:,:), FESTEP(:,:),   FISTEP(:,:,:),
     R SHSTEP(:,:),   VPSTEP(:,:,:), MCSTEP(:,:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I IRSTEP(:,:), IPSTEP(:,:), ITSTEP(:,:),
     I IASTEP(:,:), IBSTEP(:,:), IGSTEP(:,:),
     I ISTUF(:),
     I NSMAX(:),    NSPSTI(:),   NSPSTE(:)

      INTEGER, PUBLIC, SAVE ::
     .   NSTPP1, NSTPP2, NSTPP3 , NSTPP4

      CONTAINS


      SUBROUTINE ALLOC_CSTEP

      IF (ALLOCATED(FLSTEP)) RETURN

      NSTPP1=(NSPZ+1)*NSTEP*NGITT
      NSTPP2=NSTEP*NGITT
      NSTPP3=NPLS*NSTEP*NGITT
      NSTPP4=(NSPZ+1)*NSTEP

      ALLOCATE (FLSTEP(0:NSPZ,NSTEP,NGITT))
      ALLOCATE (ELSTEP(0:NSPZ,NSTEP,NGITT))
      ALLOCATE (FLTOT (0:NSPZ,NSTEP))
      ALLOCATE (VF    (0:NSPZ,NSTEP,NGITT))
c   next 2 tallies added nov. 05      !dr
      ALLOCATE (ELTOT (0:NSPZ,NSTEP))
      ALLOCATE (VE    (0:NSPZ,NSTEP,NGITT))
      ALLOCATE (QUOT  (0:NSPZ,NSTEP,NGITT))
      ALLOCATE (ADD   (0:NSPZ,NSTEP,NGITT))
      ALLOCATE (QUOTI (0:NSPZ,NSTEP,NGITT))
      ALLOCATE (ADDIV (0:NSPZ,NSTEP,NGITT))
      ALLOCATE (TESTEP(NSTEP,NGITT))
      ALLOCATE (TISTEP(NPLSTI,NSTEP,NGITT))
      ALLOCATE (RRSTEP(NSTEP,NGITT))
      ALLOCATE (VXSTEP(NPLSV,NSTEP,NGITT))
      ALLOCATE (VYSTEP(NPLSV,NSTEP,NGITT))
      ALLOCATE (VZSTEP(NPLSV,NSTEP,NGITT))
      ALLOCATE (DISTEP(NPLS,NSTEP,NGITT))
c  next 5 tallies added sept. 05     !dr
      ALLOCATE (FESTEP(NSTEP,NGITT))
      ALLOCATE (SHSTEP(NSTEP,NGITT))
      ALLOCATE (FISTEP(NPLS,NSTEP,NGITT))
      ALLOCATE (MCSTEP(NPLS,NSTEP,NGITT))
      ALLOCATE (VPSTEP(NPLSV,NSTEP,NGITT))

      ALLOCATE (IRSTEP(NSTEP,NGITT))
      ALLOCATE (IPSTEP(NSTEP,NGITT))
      ALLOCATE (ITSTEP(NSTEP,NGITT))
      ALLOCATE (IASTEP(NSTEP,NGITT))
      ALLOCATE (IBSTEP(NSTEP,NGITT))
      ALLOCATE (IGSTEP(NSTEP,NGITT))
      ALLOCATE (ISTUF(NSTEP))
      ALLOCATE (NSMAX(NSTEP))
      ALLOCATE (NSPSTI(NSTEP))
      ALLOCATE (NSPSTE(NSTEP))

      WRITE (55,'(A,T25,I15)')
     .       ' CSTEP ',(8*NSTPP1+2*NSTPP4+4*NSTPP2+3*NSTPP3 +
     .                  (NPLSTI+4*NPLSV)*NSTPP2)*8 +
     .                 (6*NSTPP2+4*NSTEP)*4

      CALL INIT_CSTEP

      RETURN
      END SUBROUTINE ALLOC_CSTEP


      SUBROUTINE DEALLOC_CSTEP

      IF (.NOT.ALLOCATED(FLSTEP)) RETURN

      DEALLOCATE (FLSTEP)
      DEALLOCATE (ELSTEP)
      DEALLOCATE (FLTOT)
      DEALLOCATE (VF)
      DEALLOCATE (ELTOT)
      DEALLOCATE (VE)
      DEALLOCATE (QUOT)
      DEALLOCATE (ADD)
      DEALLOCATE (QUOTI)
      DEALLOCATE (ADDIV)
      DEALLOCATE (TESTEP)
      DEALLOCATE (TISTEP)
      DEALLOCATE (RRSTEP)
      DEALLOCATE (VXSTEP)
      DEALLOCATE (VYSTEP)
      DEALLOCATE (VZSTEP)
      DEALLOCATE (DISTEP)
      DEALLOCATE (FESTEP)
      DEALLOCATE (SHSTEP)
      DEALLOCATE (FISTEP)
      DEALLOCATE (MCSTEP)
      DEALLOCATE (VPSTEP)

      DEALLOCATE (IRSTEP)
      DEALLOCATE (IPSTEP)
      DEALLOCATE (ITSTEP)
      DEALLOCATE (IASTEP)
      DEALLOCATE (IBSTEP)
      DEALLOCATE (IGSTEP)
      DEALLOCATE (ISTUF)
      DEALLOCATE (NSMAX)
      DEALLOCATE (NSPSTI)
      DEALLOCATE (NSPSTE)

      RETURN
      END SUBROUTINE DEALLOC_CSTEP


      SUBROUTINE INIT_CSTEP

      FLSTEP = 0._DP
      ELSTEP = 0._DP
      FLTOT  = 0._DP
      VF     = 0._DP
      ELTOT  = 0._DP
      VE     = 0._DP
      QUOT   = 0._DP
      ADD    = 0._DP
      QUOTI  = 0._DP
      ADDIV  = 0._DP
      TESTEP = 0._DP
      TISTEP = 0._DP
      RRSTEP = 0._DP
      VXSTEP = 0._DP
      VYSTEP = 0._DP
      VZSTEP = 0._DP
      DISTEP = 0._DP
      FESTEP = 0._DP
      FISTEP = 0._DP
      SHSTEP = 0._DP
      MCSTEP = 0._DP
      VPSTEP = 0._DP

      IRSTEP = 0
      IPSTEP = 0
      ITSTEP = 0
      IASTEP = 0
      IBSTEP = 0
      IGSTEP = 0
      ISTUF  = 0
      NSMAX  = 0
      NSPSTI = 0
      NSPSTE = 0

      RETURN
      END SUBROUTINE INIT_CSTEP

      END MODULE CSTEP
C ===== SOURCE: ctetra.f
      MODULE CTETRA

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CTETRA, DEALLOC_CTETRA, INIT_CTETRA,
     P          TET_ELEM, TET_LISTE

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     R        RCTET1(:,:), RCTET2(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R  XTETRA(:),  YTETRA(:),  ZTETRA(:),
     R  VTETX(:,:), VTETY(:,:), VTETZ(:,:),
     R  PTETX(:,:), PTETY(:,:), PTETZ(:,:),
     R  XTCEN(:),   YTCEN(:),   ZTCEN(:),
     R  RINCRC(:,:),
     R  RTCEN(:), STCEN(:), TTCEN(:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE ::
     I         ICTET1(:,:), ICTET2(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I  NTECK(:,:),  NTBAR(:,:), NTSEITE(:,:),
     I  INMTIT(:,:), ncltet(:),
     I  NCOOR, NTET, nr1ori, np2ori, nt3ori, ITETHAND, ntet_collaps

      INTEGER, PUBLIC, SAVE :: NCTET1, NCTET2, MCTET1, MCTET2, MCLSTR=0

      TYPE :: TET_ELEM
        INTEGER :: NOTET
        TYPE(TET_ELEM), POINTER :: NEXT_TET
      END TYPE TET_ELEM

      TYPE :: TET_LISTE
        TYPE(TET_ELEM), POINTER :: PTET
      END TYPE TET_LISTE

      TYPE(TET_LISTE), ALLOCATABLE, SAVE, PUBLIC :: COORTET(:)

      CONTAINS


      SUBROUTINE ALLOC_CTETRA

      IF (ALLOCATED(RCTET1)) RETURN

      NCTET1 = (3*6+4*4+3+3)*NTETRA
      NCTET2 = 3*NCOORD
      MCTET1 = (4*4+1)*NTETRA
      MCTET2 = 7

      ALLOCATE (RCTET1(40,NTETRA))
      ALLOCATE (RCTET2(NCTET2))
      ALLOCATE (ICTET1(17,NTETRA))
      ALLOCATE (ICTET2(MCTET2))

      WRITE (55,'(A,T25,I15)')
     .       ' CTETRA ',(40*NTETRA+NCTET2)*8 +
     .                  (17*NTETRA+MCTET2)*4

      VTETX  => RCTET1( 1 :  6,:)
      VTETY  => RCTET1( 7 : 12,:)
      VTETZ  => RCTET1(13 : 18,:)
      PTETX  => RCTET1(19 : 22,:)
      PTETY  => RCTET1(23 : 26,:)
      PTETZ  => RCTET1(27 : 30,:)
      XTCEN  => RCTET1(31,:)
      YTCEN  => RCTET1(32,:)
      ZTCEN  => RCTET1(33,:)
      RINCRC => RCTET1(34 : 37,:)
      RTCEN  => RCTET1(38,:)
      STCEN  => RCTET1(39,:)
      TTCEN  => RCTET1(40,:)

      XTETRA => RCTET2(1+0*NCOORD : 1*NCOORD)
      YTETRA => RCTET2(1+1*NCOORD : 2*NCOORD)
      ZTETRA => RCTET2(1+2*NCOORD : 3*NCOORD)

      NTECK   => ICTET1( 1 : 4,:)
      NTBAR   => ICTET1( 5 : 8,:)
      NTSEITE => ICTET1( 9 : 12,:)
      INMTIT  => ICTET1(13 : 16,:)
      ncltet  => ICTET1(17,:)

      NCOOR    => ICTET2(1)
      NTET     => ICTET2(2)
      nr1ori   => ICTET2(3)
      np2ori   => ICTET2(4)
      nt3ori   => ICTET2(5)
      ITETHAND => ICTET2(6)
      ntet_collaps => ICTET2(7)

      CALL INIT_CTETRA

      RETURN
      END SUBROUTINE ALLOC_CTETRA


      SUBROUTINE DEALLOC_CTETRA

      IF (.NOT.ALLOCATED(RCTET1)) RETURN

      DEALLOCATE (RCTET1)
      DEALLOCATE (RCTET2)
      DEALLOCATE (ICTET1)
      DEALLOCATE (ICTET2)

      RETURN
      END SUBROUTINE DEALLOC_CTETRA


      SUBROUTINE INIT_CTETRA

      RCTET1 = 0._DP
      RCTET2 = 0._DP
      ICTET1 = 0
      ICTET2 = 0

      RETURN
      END SUBROUTINE INIT_CTETRA

      END MODULE CTETRA
C ===== SOURCE: ctext.f
      MODULE CTEXT

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CTEXT, DEALLOC_CTEXT, INIT_CTEXT

      CHARACTER(72), PUBLIC, ALLOCATABLE, SAVE ::
     C TXTSFL(:),   TXTTAL(:,:), TXTPLS(:,:),
     C TXTSOU(:),   TXTSIG(:),
     C TXTTLW(:,:),
     C CHRTAL(:),   CHRTLS(:)

      CHARACTER(72), PUBLIC, SAVE :: TXTRUN

      CHARACTER(24), PUBLIC, ALLOCATABLE, SAVE ::
     C TXTUNT(:,:), TXTSPC(:,:),
     C TXTPUN(:,:), TXTPSP(:,:),
     C TXTUNW(:,:), TXTSPW(:,:),
     C TEXTLA(:),   TEXTLS(:)


      CONTAINS


      SUBROUTINE ALLOC_CTEXT (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        IF (ALLOCATED(TXTSFL)) RETURN

        ALLOCATE (TXTSFL(NLIMPS))
        ALLOCATE (TXTSOU(NSTRA))
        ALLOCATE (TXTSIG(NCHOR))
        ALLOCATE (TXTTLW(N2MX,NTALS))
        ALLOCATE (CHRTAL(NALV))
        ALLOCATE (CHRTLS(NALS))
        ALLOCATE (TXTUNW(N2MX,NTALS))
        ALLOCATE (TXTSPW(N2MX,NTALS))
        ALLOCATE (TEXTLA(5))
        ALLOCATE (TEXTLS(3))

        WRITE (55,'(A,T25,I15)')
     .        ' CTEXT(1) ',(NLIMPS+NSTRA+NCHOR+N2MX*NTALS+NALV+
     .                      NALS)*72 +
     .                     (2*N2MX*NTALS+8)*24

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(TXTTAL)) RETURN

        ALLOCATE (TXTTAL(N1MX,NTALV))
        ALLOCATE (TXTPLS(N1MX,NTALI))
        ALLOCATE (TXTSPC(N1MX,NTALV))
        ALLOCATE (TXTUNT(N1MX,NTALV))
        ALLOCATE (TXTPSP(N1MX,NTALI))
        ALLOCATE (TXTPUN(N1MX,NTALI))

        WRITE (55,'(A,T25,I15)')
     .        ' CTEXT(2) ',N1MX*(NTALV*NTALI)*72 +
     .                     2*N1MX*(NTALV+NTALI)*24

      END IF

      CALL INIT_CTEXT (ICAL)

      RETURN
      END SUBROUTINE ALLOC_CTEXT


      SUBROUTINE DEALLOC_CTEXT

      IF (.NOT.ALLOCATED(TXTSFL)) RETURN

      DEALLOCATE (TXTSFL)
      DEALLOCATE (TXTTAL)
      DEALLOCATE (TXTPLS)
      DEALLOCATE (TXTSOU)
      DEALLOCATE (TXTSIG)
      DEALLOCATE (TXTTLW)
      DEALLOCATE (CHRTAL)
      DEALLOCATE (CHRTLS)
      DEALLOCATE (TXTSPC)
      DEALLOCATE (TXTUNT)
      DEALLOCATE (TXTPSP)
      DEALLOCATE (TXTPUN)
      DEALLOCATE (TXTUNW)
      DEALLOCATE (TXTSPW)
      DEALLOCATE (TEXTLA)
      DEALLOCATE (TEXTLS)

      RETURN
      END SUBROUTINE DEALLOC_CTEXT


      SUBROUTINE INIT_CTEXT (ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        TXTSFL = ' '
        TXTSOU = ' '
        TXTSIG = ' '
        TXTTLW = ' '
        CHRTAL = ' '
        CHRTLS = ' '
        TXTUNW = ' '
        TXTSPW = ' '
        TEXTLA = ' '
        TEXTLS = ' '

      ELSE IF (ICAL == 2) THEN

        TXTTAL = ' '
        TXTPLS = ' '
        TXTSPC = ' '
        TXTUNT = ' '
        TXTPSP = ' '
        TXTPUN = ' '

      END IF

      RETURN
      END SUBROUTINE INIT_CTEXT

      END MODULE CTEXT


C ===== SOURCE: ctrcei.f
      MODULE CTRCEI

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CTRCEI, DEALLOC_CTRCEI, INIT_CTRCEI

      LOGICAL, PUBLIC, TARGET, ALLOCATABLE, SAVE :: LTRCEI(:)

      LOGICAL, PUBLIC, POINTER, SAVE ::
     L TRCPLT, TRCHST, TRCNAL, TRCMOD, TRCSIG,
     L TRCGRD, TRCSUR, TRCREF, TRCFLE, TRCAMD,
     L TRCINT, TRCLST, TRCSOU, TRCREC, TRCTIM,
     L TRCBLA, TRCBLP, TRCBLE, TRCBLM, TRCBLI,
     L TRCBLPH, TRCTAL

      LOGICAL, PUBLIC, ALLOCATABLE, SAVE :: TRCSRC(:)

      INTEGER, PUBLIC, TARGET, ALLOCATABLE, SAVE :: ITRCEI(:)

      INTEGER, PUBLIC, POINTER, SAVE ::
     I NPRTLV(:), NPRTLS(:), NPRSRF(:),
     I NVOLPR,    NFLAGV(:), NTLVFL(:),
     I NSURPR,    NFLAGS(:), NTLSFL(:),
     I I1TRC,     I2TRC,     NSPCPR

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NSPEZV(:,:), NSPEZS(:,:)

      INTEGER, PUBLIC, SAVE :: MCTRC, LCTRC

      CONTAINS


      SUBROUTINE ALLOC_CTRCEI

      IF (ALLOCATED(LTRCEI)) RETURN

      MCTRC=5+300+4*NLIMPS
      LCTRC=22

      ALLOCATE (LTRCEI(LCTRC))
      ALLOCATE (ITRCEI(MCTRC))
      ALLOCATE (TRCSRC(0:NSTRA))
      ALLOCATE (NSPEZV(100,2))
      ALLOCATE (NSPEZS(NLIMPS,2))

      WRITE (55,'(A,T25,I15)')
     .       ' CTRCEI ',(LCTRC+(NSTRA+1))*4
      WRITE (55,'(A,T25,I15)')
     .       ' CTRCEI ',(MCTRC+200+2*NLIMPS)*4

      TRCPLT => LTRCEI( 1)
      TRCHST => LTRCEI( 2)
      TRCNAL => LTRCEI( 3)
      TRCMOD => LTRCEI( 4)
      TRCSIG => LTRCEI( 5)
      TRCGRD => LTRCEI( 6)
      TRCSUR => LTRCEI( 7)
      TRCREF => LTRCEI( 8)
      TRCFLE => LTRCEI( 9)
      TRCAMD => LTRCEI(10)
      TRCINT => LTRCEI(11)
      TRCLST => LTRCEI(12)
      TRCSOU => LTRCEI(13)
      TRCREC => LTRCEI(14)
      TRCTIM => LTRCEI(15)
      TRCBLA => LTRCEI(16)
      TRCBLP => LTRCEI(17)
      TRCBLE => LTRCEI(18)
      TRCBLM => LTRCEI(19)
      TRCBLI => LTRCEI(20)
      TRCBLPH=> LTRCEI(21)
      TRCTAL => LTRCEI(22)

      NPRTLV => ITRCEI(  1 : 100)
      NFLAGV => ITRCEI(101 : 200)
      NTLVFL => ITRCEI(201 : 300)
      NPRTLS => ITRCEI(301        : 300+  NLIMPS)
      NPRSRF => ITRCEI(301+  NLIMPS : 300+2*NLIMPS)
      NFLAGS => ITRCEI(301+2*NLIMPS : 300+3*NLIMPS)
      NTLSFL => ITRCEI(301+3*NLIMPS : 300+4*NLIMPS)
      NVOLPR => ITRCEI(301+4*NLIMPS)
      NSURPR => ITRCEI(302+4*NLIMPS)
      I1TRC  => ITRCEI(303+4*NLIMPS)
      I2TRC  => ITRCEI(304+4*NLIMPS)
      NSPCPR => ITRCEI(305+4*NLIMPS)

      CALL INIT_CTRCEI

      RETURN
      END SUBROUTINE ALLOC_CTRCEI


      SUBROUTINE DEALLOC_CTRCEI

      IF (.NOT.ALLOCATED(LTRCEI)) RETURN

      DEALLOCATE (LTRCEI)
      DEALLOCATE (ITRCEI)
      DEALLOCATE (TRCSRC)
      DEALLOCATE (NSPEZV)
      DEALLOCATE (NSPEZS)

      RETURN
      END SUBROUTINE DEALLOC_CTRCEI


      SUBROUTINE INIT_CTRCEI

      LTRCEI = .FALSE.
      ITRCEI = 0
      TRCSRC = .FALSE.
      NSPEZV = 0
      NSPEZS = 0
      NFLAGV = 1

      RETURN
      END SUBROUTINE INIT_CTRCEI

      END MODULE CTRCEI
C ===== SOURCE: ctrig.f
      MODULE CTRIG

!pb 07.12.06: use POINTER rather than ALLOCATABLE in datatype definition
!pb           at this place ALLOCATABLE is allowed only in FORTRAN 2000

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CTRIG, DEALLOC_CTRIG, INIT_CTRIG,
     P          TRI_ELEM, TRI_LISTE, TRI_SURF

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R XTRIAN(:),  YTRIAN(:),
     R VTRIX(:,:), VTRIY(:,:), PTRIX(:,:), PTRIY(:,:)

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I NECKE(:,:), NCHBAR(:,:), NSEITE(:,:),
     I INMTI(:,:), INSPAT(:,:), IXTRI(:), IYTRI(:)

      INTEGER, PUBLIC, SAVE ::
     I NRKNOT, NTRII, NCTRIG, MCTRIG


      TYPE :: TRI_ELEM
        INTEGER :: NOTRI
        TYPE(TRI_ELEM), POINTER :: NEXT_TRI
      END TYPE TRI_ELEM

      TYPE :: TRI_LISTE
        TYPE(TRI_ELEM), POINTER :: PTRI
      END TYPE TRI_LISTE

      TYPE :: TRI_SURF
        INTEGER :: NUMTR
        INTEGER, POINTER :: ITRIAS(:), ITRISI(:)
        REAL(DP), POINTER :: BGLT(:)
      END TYPE TRI_SURF

      TYPE(TRI_LISTE), ALLOCATABLE, SAVE, PUBLIC :: COORTRI(:)
      
      TYPE(TRI_SURF), ALLOCATABLE, PUBLIC, SAVE :: SURF_TRIAN(:)

      CONTAINS


      SUBROUTINE ALLOC_CTRIG

      IF (ALLOCATED(XTRIAN)) RETURN

      NCTRIG = 2*NKNOTS+4*3*NTRIS
      MCTRIG = (5*3+2)*NTRIS+2

      ALLOCATE (XTRIAN(NKNOTS))
      ALLOCATE (YTRIAN(NKNOTS))
      ALLOCATE (VTRIX(3,NTRIS))
      ALLOCATE (VTRIY(3,NTRIS))
      ALLOCATE (PTRIX(3,NTRIS))
      ALLOCATE (PTRIY(3,NTRIS))

      ALLOCATE (NECKE(3,NTRIS))
      ALLOCATE (NCHBAR(3,NTRIS))
      ALLOCATE (NSEITE(3,NTRIS))
      ALLOCATE (INMTI(3,NTRIS))
      ALLOCATE (INSPAT(3,NTRIS))
      ALLOCATE (IXTRI(NTRIS))
      ALLOCATE (IYTRI(NTRIS))

      ALLOCATE (SURF_TRIAN(NLIMPS))

      WRITE (55,'(A,T25,I15)')
     .       ' CTRIG ',NCTRIG*8+MCTRIG*4

      CALL INIT_CTRIG

      RETURN
      END SUBROUTINE ALLOC_CTRIG


      SUBROUTINE DEALLOC_CTRIG

      IF (.NOT.ALLOCATED(XTRIAN)) RETURN

      DEALLOCATE (XTRIAN)
      DEALLOCATE (YTRIAN)
      DEALLOCATE (VTRIX)
      DEALLOCATE (VTRIY)
      DEALLOCATE (PTRIX)
      DEALLOCATE (PTRIY)

      DEALLOCATE (NECKE)
      DEALLOCATE (NCHBAR)
      DEALLOCATE (NSEITE)
      DEALLOCATE (INMTI)
      DEALLOCATE (INSPAT)
      DEALLOCATE (IXTRI)
      DEALLOCATE (IYTRI)
      
      DEALLOCATE (SURF_TRIAN)

      RETURN
      END SUBROUTINE DEALLOC_CTRIG


      SUBROUTINE INIT_CTRIG

      XTRIAN = 0._DP
      YTRIAN = 0._DP
      VTRIX  = 0._DP
      VTRIY  = 0._DP
      PTRIX  = 0._DP
      PTRIY  = 0._DP

      NECKE  = 0
      NCHBAR = 0
      NSEITE = 0
      INMTI  = 0
      INSPAT = 0
      IXTRI = 0
      IYTRI = 0

      SURF_TRIAN(:)%NUMTR = 0

      RETURN
      END SUBROUTINE INIT_CTRIG

      END MODULE CTRIG






C ===== SOURCE: ctsurf.f
      MODULE CTSURF

      USE PRECISION

      IMPLICIT NONE

      PRIVATE

      INTEGER, ALLOCATABLE, PUBLIC :: IDROB(:,:), ISEEOB(:,:)
      INTEGER, PUBLIC :: NTETSUR

      REAL(DP), ALLOCATABLE, PUBLIC :: RTETMIN(:,:)

      END MODULE CTSURF
C ===== SOURCE: cupd.f
      MODULE CUPD

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CUPD, DEALLOC_CUPD, INIT_CUPD
      PUBLIC :: CELL_INFO, TRAJECT, TRAJECT_ARRAY, CELL_INSERT, 
     .          CELL_DELETE, CLEAR_TRAJECTORY

      TYPE CELL_INFO
        REAL(DP) :: FLIGHT
        INTEGER :: NO_CELL
        TYPE(CELL_INFO), POINTER :: NEXTC, PREVC
      END TYPE CELL_INFO
      

      TYPE TRAJECT
        REAL(DP) :: VX, VY, VZ, WGHT
        REAL(DP) :: P1(3), P2(3)
        INTEGER :: NCOU_CELL, IND_EVENT, NO_SURF, TYP
        TYPE(CELL_INFO), POINTER :: CELLS
      END TYPE TRAJECT

      TYPE TRAJECT_ARRAY
        TYPE(TRAJECT), POINTER :: TRJ
      END TYPE TRAJECT_ARRAY

      TYPE(TRAJECT_ARRAY), PUBLIC, ALLOCATABLE, SAVE :: TRAJ(:)

      REAL(DP), PUBLIC, SAVE ::
     R X00, Y00, Z00, X01, Y01, Z01

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R ALPD(:), BLPD(:), CLPD(:)

      INTEGER, PUBLIC, SAVE ::
     I NCOUP, NCOUT,  NCOU,   NNTCLL,
     I IRCELL, IPCELL, ITCELL, ISRFCL

      INTEGER, PUBLIC, ALLOCATABLE, SAVE ::
     I JUPC(:),   KUPC(:),   NUPC(:),
     I NCOUNP(:), NCOUNT(:),
     I LUPC(:),   MUPC(:)

      CONTAINS


      SUBROUTINE ALLOC_CUPD

      IF (ALLOCATED(ALPD)) RETURN

      ALLOCATE (ALPD(N2ND))
      ALLOCATE (BLPD(N3RD))
      ALLOCATE (CLPD(N2ND+N3RD))

      ALLOCATE (JUPC(N2ND))
      ALLOCATE (KUPC(N3RD))
      ALLOCATE (NUPC(N2ND+N3RD))
      ALLOCATE (NCOUNP(N2ND+N3RD))
      ALLOCATE (NCOUNT(N2ND+N3RD))
      ALLOCATE (LUPC(N2ND))
      ALLOCATE (MUPC(N2ND))

      WRITE (55,'(A,T25,I15)')
     .      ' CUPD ',2*(N2ND+N3RD)*8
      WRITE (55,'(A,T25,I15)')
     .      ' CUPD ',(4*(N2ND+N3RD)+2*N2ND)*4

      CALL INIT_CUPD

      RETURN

      END SUBROUTINE ALLOC_CUPD


      SUBROUTINE DEALLOC_CUPD

      IF (.NOT.ALLOCATED(ALPD)) RETURN

      DEALLOCATE (ALPD)
      DEALLOCATE (BLPD)
      DEALLOCATE (CLPD)

      DEALLOCATE (JUPC)
      DEALLOCATE (KUPC)
      DEALLOCATE (NUPC)
      DEALLOCATE (NCOUNP)
      DEALLOCATE (NCOUNT)
      DEALLOCATE (LUPC)
      DEALLOCATE (MUPC)

      RETURN

      END SUBROUTINE DEALLOC_CUPD


      SUBROUTINE INIT_CUPD

      ALPD   = 0._DP
      BLPD   = 0._DP
      CLPD   = 0._DP

      JUPC   = 0
      KUPC   = 0
      NUPC   = 0
      NCOUNP = 0
      NCOUNT = 0
      LUPC   = 0
      MUPC   = 0
      NNTCLL = 0

      X00 = -75.75E20_DP
      Y00 = -75.75E20_DP
      Z00 = -75.75E20_DP
      X01 = -75.75E20_DP
      Y01 = -75.75E20_DP
      Z01 = -75.75E20_DP

      RETURN

      END SUBROUTINE INIT_CUPD


      SUBROUTINE CELL_INSERT (ICHOR,NEW_CELL)

      INTEGER, INTENT(IN) :: ICHOR
      TYPE(CELL_INFO), POINTER :: NEW_CELL

      IF (.NOT.ASSOCIATED(TRAJ(ICHOR)%TRJ%CELLS)) THEN

        NEW_CELL%NEXTC => NEW_CELL
        NEW_CELL%PREVC => NEW_CELL
        TRAJ(ICHOR)%TRJ%CELLS => NEW_CELL

      ELSE 

        NEW_CELL%NEXTC => TRAJ(ICHOR)%TRJ%CELLS
        NEW_CELL%PREVC => TRAJ(ICHOR)%TRJ%CELLS%PREVC
        TRAJ(ICHOR)%TRJ%CELLS%PREVC%NEXTC => NEW_CELL
        TRAJ(ICHOR)%TRJ%CELLS%PREVC => NEW_CELL

      END IF

      END SUBROUTINE CELL_INSERT


      SUBROUTINE CELL_DELETE (ICHOR,CUR)

      INTEGER, INTENT(IN) :: ICHOR
      TYPE(CELL_INFO), POINTER :: CUR

      IF (ASSOCIATED(CUR%NEXTC,CUR%PREVC)) THEN
        
! only one element in cell list
        NULLIFY(TRAJ(ICHOR)%TRJ%CELLS)

      ELSE 

        IF (ASSOCIATED(TRAJ(ICHOR)%TRJ%CELLS,CUR)) THEN
! first element in cell list is going to be deleted 
! therefore adjust head pointer to list
          TRAJ(ICHOR)%TRJ%CELLS => CUR%NEXTC
        END IF

        CUR%NEXTC%PREVC => CUR%PREVC
        CUR%PREVC%NEXTC => CUR%NEXTC

      END IF

      NULLIFY(CUR%NEXTC)
      NULLIFY(CUR%PREVC)
      DEALLOCATE(CUR)
      NULLIFY(CUR)

      END SUBROUTINE CELL_DELETE


      SUBROUTINE CLEAR_TRAJECTORY (ICHOR)

      INTEGER, INTENT(IN) :: ICHOR
      TYPE(CELL_INFO), POINTER :: CUR, CURDEL

      CUR => TRAJ(ICHOR)%TRJ%CELLS
      NULLIFY(CUR%PREVC%NEXTC)
      
      NULLIFY(TRAJ(ICHOR)%TRJ%CELLS)

      DO WHILE (ASSOCIATED(CUR))

        CURDEL => CUR
        CUR => CUR%NEXTC

        NULLIFY(CURDEL%NEXTC)
        NULLIFY(CURDEL%PREVC)
        DEALLOCATE(CURDEL)

      END DO

      TRAJ(ICHOR)%TRJ%NCOU_CELL = 0
      TRAJ(ICHOR)%TRJ%NO_SURF = 0
      TRAJ(ICHOR)%TRJ%VX = 0._DP
      TRAJ(ICHOR)%TRJ%VY = 0._DP
      TRAJ(ICHOR)%TRJ%VZ = 0._DP
      TRAJ(ICHOR)%TRJ%WGHT = 0._DP
      TRAJ(ICHOR)%TRJ%P1 = 0._DP
      TRAJ(ICHOR)%TRJ%P2 = 0._DP

      END SUBROUTINE CLEAR_TRAJECTORY

      END MODULE CUPD
C ===== SOURCE: czt1.f
      MODULE CZT1

      USE PRECISION
      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_CZT1, DEALLOC_CZT1, INIT_CZT1

      REAL(DP), PUBLIC, TARGET, ALLOCATABLE, SAVE :: RCZT1(:), RCZT2(:)

      REAL(DP), PUBLIC, POINTER, SAVE ::
     R RSQDVI(:), CVRSSI(:), ALMASI(:),
     R RSQDVP(:), CVRSSP(:), ALMASP(:),
     R RSQDVA(:), CVRSSA(:), ALMASA(:),
     R RSQDVM(:), CVRSSM(:), ALMASM(:),
     R DEFCX(:),  EEFCX(:),
     R DEFEL(:),  EEFEL(:),
     R DEFPI(:),  EEFPI(:),
     R DENE,      DENI

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R ZT1(:,:),  ZRG(:,:)

      INTEGER, PUBLIC, SAVE :: NZT1, NZT2


      CONTAINS


      SUBROUTINE ALLOC_CZT1(ICAL)

      INTEGER, INTENT(IN) :: ICAL
      INTEGER IND

      IF (ICAL == 1) THEN

        IF (ALLOCATED(RCZT1)) RETURN

        NZT1=2+NION*3+NPLS*3+NATM*3+NMOL*3

        ALLOCATE (RCZT1(NZT1))
        ALLOCATE (ZT1(NPLS,NRAD))
        ALLOCATE (ZRG(NPLS,NRAD))

        WRITE (55,'(A,T25,I15)')
     .        ' CZT1(1) ',(NZT1+2*NPLS*NRAD)*8

        IND = 0
        RSQDVI => RCZT1(1+IND+0*NION : IND+1*NION)
        CVRSSI => RCZT1(1+IND+1*NION : IND+2*NION)
        ALMASI => RCZT1(1+IND+2*NION : IND+3*NION)

        IND = IND+3*NION
        RSQDVP => RCZT1(1+IND+0*NPLS : IND+1*NPLS)
        CVRSSP => RCZT1(1+IND+1*NPLS : IND+2*NPLS)
        ALMASP => RCZT1(1+IND+2*NPLS : IND+3*NPLS)

        IND = IND+3*NPLS
        RSQDVA => RCZT1(1+IND+0*NATM : IND+1*NATM)
        CVRSSA => RCZT1(1+IND+1*NATM : IND+2*NATM)
        ALMASA => RCZT1(1+IND+2*NATM : IND+3*NATM)

        IND = IND+3*NATM
        RSQDVM => RCZT1(1+IND+0*NMOL : IND+1*NMOL)
        CVRSSM => RCZT1(1+IND+1*NMOL : IND+2*NMOL)
        ALMASM => RCZT1(1+IND+2*NMOL : IND+3*NMOL)

        IND = IND+3*NMOL
        DENE   => RCZT1(1+IND)
        DENI   => RCZT1(2+IND)

      ELSE IF (ICAL == 2) THEN

        IF (ALLOCATED(RCZT2)) RETURN

        NZT2=2*NREL+2*NRCX+2*NRPI

        ALLOCATE (RCZT2(NZT2))

        WRITE (55,'(A,T25,I15)')
     .         ' CZT1(2) ',NZT2*8

        IND = 0
        DEFCX  => RCZT2(1+IND+0*NRCX : IND+1*NRCX)
        EEFCX  => RCZT2(1+IND+1*NRCX : IND+2*NRCX)

        IND = IND+2*NRCX
        DEFEL  => RCZT2(1+IND+0*NREL : IND+1*NREL)
        EEFEL  => RCZT2(1+IND+1*NREL : IND+2*NREL)

        IND = IND+2*NREL
        DEFPI  => RCZT2(1+IND+0*NRPI : IND+1*NRPI)
        EEFPI  => RCZT2(1+IND+1*NRPI : IND+2*NRPI)

      END IF

      CALL INIT_CZT1(ICAL)

      RETURN
      END SUBROUTINE ALLOC_CZT1


      SUBROUTINE DEALLOC_CZT1

      IF (.NOT.ALLOCATED(RCZT1)) RETURN

      DEALLOCATE (RCZT1)
      DEALLOCATE (RCZT2)
      DEALLOCATE (ZT1)
      DEALLOCATE (ZRG)

      RETURN
      END SUBROUTINE DEALLOC_CZT1


      SUBROUTINE INIT_CZT1(ICAL)

      INTEGER, INTENT(IN) :: ICAL

      IF (ICAL == 1) THEN

        RCZT1 = 0._DP
        ZT1   = 0._DP
        ZRG   = 0._DP

      ELSE IF (ICAL == 2) THEN

        RCZT2 = 0._DP

      END IF

      RETURN
      END SUBROUTINE INIT_CZT1

      END MODULE CZT1





C ===== SOURCE: eirbra.f
      MODULE EIRBRA

C  NEUTRAL SOURCE TERMS: SNI,SMO,SEE,SEI (EIRENE ---> BRAAMS)

      USE PRECISION
!pb      USE PARMMOD

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: ALLOC_EIRBRA, DEALLOC_EIRBRA, INIT_EIRBRA

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R SNI(:,:,:,:), SMO(:,:,:,:),
     R SEE(:,:,:),   SEI(:,:,:)

      REAL(DP), PUBLIC, ALLOCATABLE, SAVE ::
     R VOLSUMN(:), VOLSUMM(:), VOLSUMEI(:), VOLSUMEE(:)

      INTEGER, SAVE :: NDXD, NDYD, NFLD, NSTRAD

C AK
      REAL(DP),PUBLIC,ALLOCATABLE,SAVE ::
     .                srcstrn(:),flxspci(:,:),
     .                srccrfc(:,:)
c*** srcstrn: intensities of different neutral sources (fluxt)
c*** flxspci: fluxes of plasma ions to the recycling surfaces
c*** srccrfc: source correction factors (from infcop)

C AK END

      CONTAINS


      SUBROUTINE ALLOC_EIRBRA(NDXP, NDYP, NFL, NSTRA)

      INTEGER, INTENT(IN) :: NDXP, NDYP, NFL, NSTRA

      IF (ALLOCATED(SNI)) RETURN

      NDXD = NDXP+1
      NDYD = NDYP+1
      NFLD = NFL
      NSTRAD = NSTRA

      ALLOCATE (SNI(0:NDXD,0:NDYD,NFLD,NSTRAD))
      ALLOCATE (SMO(0:NDXD,0:NDYD,NFLD,NSTRAD))
      ALLOCATE (SEE(0:NDXD,0:NDYD,NSTRAD))
      ALLOCATE (SEI(0:NDXD,0:NDYD,NSTRAD))

      ALLOCATE (VOLSUMN(NSTRA))
      ALLOCATE (VOLSUMM(NSTRA))
      ALLOCATE (VOLSUMEI(NSTRA))
      ALLOCATE (VOLSUMEE(NSTRA))

      WRITE (55,'(A,T25,I15)')
     .             ' EIRBRA ',((NDXD+1)*(NDYD+1)*NSTRAD*2*NFLD+
     .                        4*NSTRA)*8

      CALL INIT_EIRBRA

      RETURN
      END SUBROUTINE ALLOC_EIRBRA


      SUBROUTINE DEALLOC_EIRBRA

      IF (.NOT.ALLOCATED(SNI)) RETURN

      DEALLOCATE (SNI)
      DEALLOCATE (SMO)
      DEALLOCATE (SEE)
      DEALLOCATE (SEI)

      DEALLOCATE (VOLSUMN)
      DEALLOCATE (VOLSUMM)
      DEALLOCATE (VOLSUMEI)
      DEALLOCATE (VOLSUMEE)

      RETURN
      END SUBROUTINE DEALLOC_EIRBRA


      SUBROUTINE INIT_EIRBRA

      SNI = 0._DP
      SMO = 0._DP
      SEE = 0._DP
      SEI = 0._DP

      VOLSUMN  = 0._DP
      VOLSUMM  = 0._DP
      VOLSUMEI = 0._DP
      VOLSUMEE = 0._DP

      RETURN
      END SUBROUTINE INIT_EIRBRA

      END MODULE EIRBRA


C ===== SOURCE: module_avltree.f
!****************************************
!* Description:
!*   Implementiert einen AVL-Baum
!*   in Fortran
!* nach einer Vorlage von
!* Author:
!*   Daniel Hottinger <hodaniel@iiic.ethz.ch>
!*   Department of Computer Science, ETH Zurich
!*   SS 2001
!* Licence: GNU GPL v2 or later
!* Created: Mon May 14 20:16:37 CEST 2001
!* Last update: Tue May 29 20:32:47 CEST 2001
!* Changes:
!*   2001-05-29 Added Search
!****************************************

      MODULE module_avltree

      USE PRECISION
      USE CCONA

      implicit none

      private

      public :: NewTree, DestroyTree, Insert, Search, Remove

      integer, parameter :: less = -1,
     .                      equal = 0,
     .                      more = 1

      type, public :: TAVLNode
        integer :: balance
        type(TAVLNode), pointer :: left, right
        real(dp) :: xco, yco, zco, dist
        integer :: ind
      end type TAVLNode

      type, public :: TAVLTree
        type(TAVLNode), pointer :: root
      end type TAVLTree


      contains

!****************************************
!* Speicherverwaltung
!****************************************

      FUNCTION NewNode(X, Y, Z, DST, IND) RESULT(NODE)

      REAL(DP), INTENT(IN) :: X, Y, Z, DST
      INTEGER, INTENT(INOUT) :: IND
      TYPE(TAVLNode), POINTER :: NODE

      allocate (node)
      node%balance = 0
      NULLIFY(node%left)
      NULLIFY(node%right)
      node%xco = x
      node%yco = y
      node%zco = z
      node%dist = dst
      node%ind = ind

      END FUNCTION NewNode


      RECURSIVE SUBROUTINE DestroyNode(node)

      type(tavlnode), pointer :: node
      type(tavlnode), pointer :: cur, l, r

      IF (ASSOCIATED(node)) THEN
         if (associated(node%left)) then
           l => node%left
           call DestroyNode (l)
           nullify(node%left)
         end if
         if (associated(node%right)) then
           r => node%right
           call DestroyNode (r)
           nullify(node%right)
         end if
         cur => node
         if (associated(cur)) DEALLOCATE(cur)
         NULLIFY(node)
      END IF

      END SUBROUTINE DestroyNode


      FUNCTION NewTree () result(tree)

      type (tavltree), pointer :: tree

      ALLOCATE (tree)
      NULLIFY (tree%root)

      END FUNCTION NewTree


      SUBROUTINE DestroyTree (tree)

      type (tavltree), pointer :: tree

      IF (ASSOCIATED(tree)) THEN
         call DestroyNode(tree%root)
         DEALLOCATE(tree)
      END IF
      END SUBROUTINE DestroyTree


!****************************************
!* Rotationen
!****************************************

!****************************************
!* n(l,r(rl,rr)) =>
!* r(n(l,rl),rr)
!*
!*   n                r
!*  / `_           _.' \
!* l    r    =>   n     rr
!*     / \       / \
!*    rl  rr    l   rl
!****************************************

      FUNCTION RotLeft(node) result(right)

      type(TAVLNode), POINTER :: node
      type(TAVLNode), POINTER :: left, right
      integer :: abal, bbal

      left => node%left
      right => node%right

      node%right => right%left
      right%left => node

      abal = node%balance
      bbal = right%balance

      IF (bbal <= EQUAL) THEN
         IF (abal >= MORE) THEN
            right%balance = bbal - 1
         ELSE
            right%balance = abal + bbal - 2
         END IF
         node%balance = abal - 1
      ELSE
         IF (abal <= bbal) THEN
            right%balance = abal - 2
         ELSE
            right%balance = bbal - 1
         END IF
         node%balance = abal - bbal - 1
      END IF

      END FUNCTION RotLeft


!****************************************
!* n(l(ll,lr),r) =>
!* l(ll,n(lr,r))
!*
!*       n        l
!*    _.' \      / `_
!*   l     r => ll   n
!*  / \             / \
!* ll  lr          lr  r
!****************************************

      FUNCTION RotRight(node) RESULT(left)

      type(TAVLNode), pointer :: node
      type(TAVLNode), pointer :: left, right
      integer :: abal, bbal

      left => node%left
      right => node%right

      node%left => left%right
      left%right => node

      abal = node%balance
      bbal = left%balance

      IF (bbal <= EQUAL) THEN
         IF (abal < bbal) THEN
            left%balance = bbal + 1
         ELSE
            left%balance = abal + 2
         END IF
         node%balance = abal - bbal + 1
      ELSE
         IF (abal <= LESS) THEN
            left%balance = bbal + 1
         ELSE
            left%balance = abal + bbal + 2
         END IF
         node%balance = abal + 1
      END IF
      END FUNCTION RotRight


!****************************************
!* Ausbalancieren
!****************************************

!****************************************
!* Beispiel: (Doppelrotation)
!* 2(1,6(5(4),7)) =>
!* 2(1,5(4,6(,7))) =>
!* 5(2(1,4),6(,7))
!*
!*   2             2
!*  / `-._        / `_            5
!* 1      6      1    5          / \
!*       / \  =>     / \    =>  2   6
!*      5   7       4   6       ^    \
!*     /                 \     1 4    7
!*    4                   7
!****************************************

      FUNCTION BalanceNode(node) result(retnode)

      type(TAVLNode), pointer :: node, retnode

      IF (node%balance < LESS) THEN
         IF (node%left%balance > EQUAL) THEN
            node%left => RotLeft(node%left)
         END IF
         retnode => RotRight(node)
      ELSEIF (node%balance > MORE) THEN
         IF (node%right%balance < EQUAL) THEN
            node%right => RotRight(node%right) ! siehe Beispiel
         END IF
         retnode => RotLeft(node)
      END IF
      END FUNCTION BalanceNode


! Called after a node of node^.left was removed
      FUNCTION RestoreLeftBalance(node, oldbalance) result(retnode)

      type(TAVLNode), pointer :: node
      type(TAVLNode), pointer :: retnode
      integer :: oldbalance

      IF (.NOT.ASSOCIATED(node%left)) THEN
         node%balance = node%balance + 1
      ELSEIF ((node%left%balance /= oldbalance) .AND.
     .        (node%left%balance == 0)) THEN
    ! left tree shrunk
         node%balance = node%balance + 1
      END IF
      IF (node%balance > MORE) THEN
         retnode => BalanceNode(node)
      ELSE
         retnode => node
      END IF

      END FUNCTION RestoreLeftBalance


! Called after a node of node^.right was removed
      FUNCTION RestoreRightBalance(node, oldbalance) result(retnode)
      type(TAVLNode), pointer :: node
      integer :: oldbalance
      type(TAVLNode), pointer :: retnode

      IF (.NOT.ASSOCIATED(node%right)) THEN
         node%balance = node%balance - 1
      ELSEIF ((node%right%balance /= oldbalance) .AND.
     .        (node%right%balance == 0)) THEN
         ! right tree shrunk
         node%balance = node%balance - 1
      END IF
      IF (node%balance > LESS) THEN
         retnode => BalanceNode(node)
      ELSE
         retnode => node
      END IF
      END FUNCTION RestoreRightBalance


      RECURSIVE FUNCTION RemoveNodeMostLeft(node, leftmost)
     .          result(retnode)

      type(TAVLNode), pointer :: node, leftmost
      integer :: oldbalance
      type(TAVLNode), pointer :: retnode

      IF (.NOT.ASSOCIATED(node%left)) THEN
         leftmost => node
         retnode => node%right
         RETURN
      END IF

      oldbalance = node%left%balance
      node%left => RemoveNodeMostLeft(node%left, leftmost)
      retnode => RestoreLeftBalance(node, oldbalance)

      END FUNCTION RemoveNodeMostLeft


!****************************************
!* grundlegende Operationen
!****************************************


      RECURSIVE FUNCTION InsertNode(node, x, y, z, dst, ind, inserted)
     .          result(retnode)

      type (TAVLNode), pointer :: node, retnode
      real(dp), intent(in) :: x, y, z, dst
      integer, intent(inout) :: ind
      logical, intent(INOUT) :: INSERTED

      integer :: relation, oldbalance

      IF (.NOT.ASSOCIATED(node)) THEN
         inserted = .TRUE.
         retnode => NewNode(x, y, z, dst, ind)
         RETURN
      END IF

      relation = cmp(x, y, z, node%xco, node%yco, node%zco, node%dist)
      IF (relation == EQUAL) THEN
         ! Don't insert dublicate key/value
         inserted = .FALSE.
         ind = node%ind
         retnode => node
         RETURN
      ELSEIF (relation == LESS) THEN
         IF (ASSOCIATED(node%left)) THEN
            oldbalance = node%left%balance
            node%left => InsertNode(node%left,x,y,z,dst,ind,inserted)
            IF ((oldbalance /= node%left%balance) .AND.
     .          (node%left%balance /= 0)) THEN
            ! Tree has grown
            node%balance = node%balance - 1
            END IF
         ELSE
            inserted = .TRUE.
            node%left => NewNode(x, y, z, dst, ind)
            node%balance = node%balance - 1
         END IF
      ELSEIF (relation == MORE) THEN
         IF (ASSOCIATED(node%right)) THEN
            oldbalance = node%right%balance
            node%right => InsertNode(node%right,x,y,z,dst,ind,inserted)
            IF ((oldbalance /= node%right%balance) .AND.
     .          (node%right%balance /= 0)) THEN
               ! Tree has grown
               node%balance = node%balance + 1
            END IF
         ELSE
            inserted = .TRUE.
            node%right => NewNode(x, y, z, dst, ind)
            node%balance = node%balance + 1
         END IF
      ENDIF

      IF (inserted) THEN
         IF (ABS(node%balance) > 1) THEN
            node => BalanceNode(node)
         END IF
      END IF

      retnode => node

      END Function InsertNode


      SUBROUTINE Insert(tree, x, y, z, dst, ind, inserted)

      type(TAVLTree), pointer :: tree
      real(dp) :: x, y, z, dst
      integer :: ind
      logical :: inserted

      IF (ASSOCIATED(tree)) THEN
         inserted = .FALSE.
         tree%root => InsertNode(tree%root, x, y, z, dst, ind, inserted)
!         call traverse (tree%root,0)
      END IF
      END SUBROUTINE Insert


!pb      RECURSIVE INTEGER Function SearchNode(node, x, y, z)
      RECURSIVE INTEGER Function SearchNode(node, x, y, z) RESULT (nr)

      type (TAVLNode), pointer :: node
      real(dp), intent(in) :: x, y, z

      integer :: relation, ind

      IF (.NOT.ASSOCIATED(node)) THEN
!pb         SearchNode = 0
         nr = 0
         RETURN
      END IF

      relation = cmp(x, y, z, node%xco, node%yco, node%zco, node%dist)
      IF (relation == EQUAL) THEN
         ind = node%ind
      ELSEIF (relation == LESS) THEN
         ind = SearchNode(node%left, x, y, z)
      ELSE
         ind = SearchNode(node%right, x, y, z)
      END IF

!pb      SearchNode = ind
      nr = ind

      END Function SearchNode


      Integer Function Search(tree, x, y, z)

      type (TAVLTree), pointer :: tree
      real(dp), intent(in) :: x, y, z

      Search = 0
      IF (ASSOCIATED(tree)) THEN
         Search = SearchNode(tree%root, x, y, z)
      END IF
      END FUNCTION Search

!****************************************
!* Beispiel:
!* n(l(:,:),r(rl(rll,rlr),rr)) =>
!* n(l(:,:),r(rl(,rlr),rr)) =>
!* rll(l(:,:),r(rl(,rlr),rr))
!*    n                    n                 rll
!*   / `--...___          / `-..__          /   `-..__
!*  l           r        l        r        l          r
!*  ^      __.-' \   =>  ^   __.-' \   =>  ^     __.-' \
!* : :    rl      rr    : : rl      rr    : :   rl      rr
!*      _'  \                 \                   \
!*     rll   rlr               rlr                 rlr
!****************************************

      RECURSIVE Function RemoveNode(node, x, y, z) result(retnode)

      type (TAVLNode), pointer :: node, retnode
      real(dp), intent(in) :: x, y, z

      integer :: relation, oldbalance
      type (TAVLNode), pointer :: garbage, newroot

      IF (.NOT.ASSOCIATED(node)) THEN
         NULLIFY(retnode)
         RETURN
      END IF

      relation = cmp(x, y, z, node%xco, node%yco, node%zco, node%dist)
      IF (relation == EQUAL) THEN
         garbage => node
         IF (.NOT.ASSOCIATED(node%right)) THEN
            retnode => node%left
         ELSE
            oldbalance = node%right%balance
            ! new right node is the leftmost of the right tree
            ! Beispiel
            node%right => RemoveNodeMostLeft(node%right, newroot)
            newroot%left => node%left
            newroot%right => node%right
            newroot%balance = node%balance
            retnode => RestoreRightBalance(newroot, oldbalance)
         END IF
         ! free *only* the removed node
         Nullify(garbage%right)
         Nullify(garbage%left)
         CALL DestroyNode(garbage)
      ELSEIF (relation == LESS) THEN
         IF (ASSOCIATED(node%left)) THEN
            oldbalance = node%left%balance
            node%left => RemoveNode(node%left, x, y, z)
            retnode => RestoreLeftBalance(node, oldbalance)
         END IF
      ELSEIF (relation == MORE) THEN
         IF (ASSOCIATED(node%right)) THEN
            oldbalance = node%right%balance
            node%right => RemoveNode(node%right, x, y, z)
            retnode => RestoreRightBalance(node, oldbalance)
         END IF
      END IF

      END FUNCTION RemoveNode


      Subroutine Remove(tree, x, y, z)

      type (TAVLTree), pointer :: tree
      real(dp), intent(in) :: x, y, z

      IF (ASSOCIATED(tree)) THEN
         tree%root => RemoveNode(tree%root, x, y, z)
      END IF
      END SUBROUTINE Remove


!****************************************
!* Debug
!****************************************

      RECURSIVE SUBROUTINE Traverse(node,iunout)

      type (TAVLNode), pointer :: node, retnode
      integer, intent(in) :: iunout

      IF (ASSOCIATED(node)) THEN
         if (abs(node%balance) > 2) then
            write (iunout,*) node%balance,node%ind
            write (iunout,*) node%xco, node%yco, node%zco
         end if
!         write (iunout,*) node%balance,node%ind, node%xco, node%yco, 
!     .                    node%zco
         IF (ASSOCIATED(node%left) .OR. ASSOCIATED(node%right)) THEN
!            Write (iunout,*) "("
            Call Traverse(node%left,iunout)
!            IF (ASSOCIATED(node%right))  THEN
!               Write (iunout,*) ","
!            END IF
            Call Traverse(node%right,iunout)
!            Write (iunout,*) ")"
         END IF
      END IF

      END SUBROUTINE Traverse


      Subroutine Dump(tree)
      type(TAVLTree), pointer :: tree

      call Traverse(tree%root,0)
      END SUBROUTINE Dump


      integer function cmp (x1, y1, z1, x2, y2, z2, dist)

      real(dp), intent(in) :: x1, y1, z1, x2, y2, z2, dist
      real(dp) :: dx, dy, dz

!      IF ( (X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2 < 1.D-10) THEN
!      IF ( SQRT((X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2)/dist < EPS5) THEN
      IF ( ((X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2)/dist**2 < EPS10) THEN
         cmp = equal
      else
!         if (abs(x1-x2) > 1.E-5) then
         if (abs(x1-x2)/max(x1,x2,eps10) > eps5) then
            cmp=merge(less,more,x1 < x2)
!         else if (abs(y1-y2) > 1.e-5) then
         else if (abs(y1-y2)/max(y1,y2,eps10) > eps5) then
            cmp=merge(less,more,y1 < y2)
         else
            cmp=merge(less,more,z1 < z2)
         end if
      end if

      return
      end function cmp


      integer function cmp_old (x1, y1, z1, x2, y2, z2)

      real(dp), intent(in) :: x1, y1, z1, x2, y2, z2
      real(dp) :: dx, dy, dz

      IF ( (X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2 < 1.D-10) THEN
         cmp_old = equal
      else
         dx=x1-x2
         if (abs(dx) < 1.E-5) then
!  x1 = x2
            dy=y1-y2
            if (abs(dy) < 1.E-5) then
!  x1 = x2 & y1 = y2
               dz=z1-z2
               if (abs(dz) < 1.E-5) then
!  x1 = x2 & y1 = y2 & z1 = z2
                  cmp_old = equal
               else if (dz < 0.d0) then
!  x1 = x2 & y1 = y2 & z1 < z2
                  cmp_old = less
               else
!  x1 = x2 & y1 = y2 & z1 > z2
                  cmp_old = more
               end if
            else if (dy < 0.d0) then
!  x1 = x2 & y1 < y2
               cmp_old = less
            else
!  x1 = x2 & y1 > y2
               cmp_old = more
            end if
         else if (dx < 0.d0) then
!  x1 < x2
            cmp_old = less
         else
!  x1 > x2
            cmp_old = more
         end if
      end if

      end function cmp_old


      END MODULE module_avltree


C ===== SOURCE: parmmod.f
!pb  18.12.06:  NPARTC and NPARTT reduced because of cancelation of XNUE
      MODULE PARMMOD

      USE PRECISION

      IMPLICIT NONE

      PRIVATE

      PUBLIC :: SET_PARMMOD, COLLECT_PARM, DISTRIB_PARM,
     P          EIRENE_SPECTRUM, SPECT_ARRAY,
     P          ASSIGNMENT(=)

      INTEGER, PUBLIC, PARAMETER ::
     P         NPARTC=12, NPARTT=12,
     P         MPARTC=14, MPARTT=9

      INTEGER, PUBLIC, SAVE ::
     I N1ST,   N2ND,   N3RD,   NADD,   NTOR,
     I NRTAL,  NLIM,   NSTS,
     I NPLG,   NPPART, NKNOT,  NTRI,   NTETRA, NCOORD,
     I NOPTIM, NOPTM1

      INTEGER, PUBLIC, SAVE ::
     I NSTRA,  NSRFS,  NSTEP

      INTEGER, PUBLIC, SAVE ::
     I NATM,   NMOL,   NION,   NPLS,   NPHOT,  NADV,   NADS,
     I NCLV,   NSNV,   NALV,   NALS,   NAIN,   NCOP,   NBGK,  NADSPC,
     I NPLSTI, NPLSV,  NBACK_SPEC 

      INTEGER, PUBLIC, SAVE ::
     I NSD,    NSDW,   NCV

      INTEGER, PUBLIC, SAVE ::
     I NREAC,  NREC,   NRDS,   NRCX,   NREL,   NRPI,   NROT

      INTEGER, PUBLIC, SAVE ::
     I NHD1,   NHD2,   NHD3,   NHD4,   NHD5,   NHD6

      INTEGER, PUBLIC, SAVE ::
     I NCHOR,  NCHEN

      INTEGER, PUBLIC, SAVE ::
     I NDX,    NDY,    NFL,    NDXP,   NDYP,   NPTRGT

      INTEGER, PUBLIC, SAVE ::
     I NPRNL

      INTEGER, PUBLIC, SAVE ::
     I NTRJ


      INTEGER, PUBLIC, SAVE ::
     I NGEOM_USR, NCOUP_INPUT, NSMSTRA, NSTORAM, NGSTAL, NRPES

      INTEGER, PUBLIC, SAVE ::
     I NRAD,   NSWIT,   N1F,    N2F,    N3F,    NGITT,  NGITTP,
     I NRADS,  N2NDPLG, N1STS,  N2NDS,  NTRIS,  NKNOTS, NRTALS

      INTEGER, PUBLIC, SAVE ::
     I NGTSFT, NLIMPS, NLMPGS

      INTEGER, PUBLIC, SAVE ::
     I NCPV,   NBGV,   NBMAX,   NPTAL,  NCPV_STAT, NSCOP

      INTEGER, PUBLIC, SAVE ::
     I NSTRAP

      INTEGER, PUBLIC, SAVE ::
     I NIONP,  NATMP,  NMOLP,
     I NPLSP,  NPHOTP, NADVP,  NADSP,
     I NCLVP,  NALVP,  NALSP,
     I NSNVP,  NCPVP,  NBGVP,
     I NTALI,  NTALN,  NTALO,  NTALV,
     I NTALA,  NTALC,  NTALT,
     I NTALM,  NTALB,  NTALR,
     I NTALS,  NTLSA,  NTLSR,  NTALW,
     I N1MX,   N2MX,   NSPZ,   NSPZP, NSPZMC, NCOLMC, NSPZTOT

      INTEGER, PUBLIC, SAVE ::
     I NVOLTL, NVLTLP,
     I NSRFTL, NSFTLP

      INTEGER, PUBLIC, SAVE ::
     I NH0,    NH1,    NH2,    NH3

      INTEGER, PUBLIC, SAVE ::
     I NHSTOR, NSTORDT, NSTORDR

      INTEGER, PUBLIC, SAVE ::
     I NPLT

      INTEGER, PUBLIC, SAVE :: INT_PARM(200)



      PRIVATE :: SPEC_TO_SPEC
      TYPE EIRENE_SPECTRUM
        REAL(DP) :: SPCMIN, SPCMAX, SPCDEL, SPCDELI, SPCINT, ESP_MIN,
     .              ESP_MAX, ESP_00, SPC_XPLT,SPC_YPLT,SPC_SAME,
     .              SPCVX, SPCVY, SPCVZ
        REAL(DP) :: SGMS, STVS, EES
        INTEGER :: NSPC, ISPCTYP, ISPCSRF, IPRTYP, IPRSP, IMETSP,
     .             ISRFCLL, IDIREC
        REAL(DP), DIMENSION(:), POINTER :: SPC, SDV, SGM
      END TYPE EIRENE_SPECTRUM

      TYPE SPECT_ARRAY
        TYPE(EIRENE_SPECTRUM), POINTER :: PSPC
      END TYPE SPECT_ARRAY

      INTERFACE ASSIGNMENT(=)  ! DEFINE ASSIGNMENT
        MODULE PROCEDURE SPEC_TO_SPEC
      END INTERFACE



      CONTAINS


      SUBROUTINE SET_PARMMOD(ICAL)

      INTEGER, INTENT(IN) :: ICAL

!PB   INCLUDE 'PARMUSR'

      IF (ICAL == 1) THEN
C
C  GEOMETRY
C
        NRAD=MAX(N1ST*N2ND*N3RD,NTRI,NTETRA)+NADD+1
        IF (NRTAL==0) NRTAL=NRAD

C  ELIMINATE SOME ARRAYS IN CASE OF LEVGEO=5 OPTION (GEOMETRY OUTSIDE EIRENE-COD
        NSWIT=1-NGEOM_USR

C  IDENTIFY: WHICH GRIDS ARE THERE? N1F=0 OR N1F=1, IF N1ST=1, OR GT 1, RESP.
        N1F=1-1/N1ST
        N2F=1-1/N2ND
        N3F=1-1/N3RD
C
        IF (NGITT <= 1) NGITT=N1ST*N2ND*N3F+N1ST*N3RD*N2F+N2ND*N3RD*N1F
        NGITTP=NGITT+1
C
        NRADS=NSWIT*NRAD+(1-NSWIT)*1
        NRTALS=NSWIT*NRTAL+(1-NSWIT)*1
        N2NDPLG=NSWIT*(N2ND*N2F+NPLG*(1-N2F))+(1-NSWIT)*1
        N1STS=NSWIT*N1ST+(1-NSWIT)*1
        N2NDS=NSWIT*N2ND+(1-NSWIT)*1
        NTRIS=NSWIT*NTRI+(1-NSWIT)*1
        NKNOTS=NSWIT*NKNOT+(1-NSWIT)*1
C
C TALLIES
C
C  SPATIALLY RESOLVED SURFACE TALLIES?
        NGTSFT=NGSTAL*NGITT
        NLIMPS=NLIM+NSTS
        NLMPGS=NLIM+NSTS+NGTSFT*NSTS
C
C  GENERATION LIMIT TALLIES
C
        NBMAX=10
        NPTAL=30

C  PRIMARY SOURCE
        NSTRAP=NSTRA+1

C  SPECIES AND TALLIES  NTALV: TOTAL NUMBER OF VOLUME TALLIES
C                           NTALA: INDEX OF THE ADDITIONAL TRACKLENGTH
C                                  ESTIMATED TALLY
C                           NTALC: INDEX OF THE ADDITIONAL COLLISION
C                                  ESTIMATED TALLY
C                           NTALT: INDEX OF THE TIME DEP. TALLY
C                                  (SNAPSHOT ESTIMATOR)
C                           NTALM: INDEX OF THE TALLIES FOR COUPLING,
C                                  (E.G. MOMENTUM SOURCES)
C                           NTALB: INDEX OF THE BGK TALLY
C                           NTALR: INDEX OF THE ALGEBRAIC TALLY
C                       NTALS: TOTAL NUMBER OF SURFACE TALLIES
C                           NTLSA: INDEX OF THE ADDITIONAL TALLY
C                                  (TRACKLENGTH AND COLLISION ESTIMATORS
C                                   ARE IDENTICAL FOR SURFACE AVERAGES)
C                           NTLSR: INDEX OF THE ALGEBRAIC TALLY
C                       NTALI: TOTAL NUMBER OF INPUT TALLIES
C                           NTALN: INDEX OF THE ADDITIONAL INPUT TALLIES
C                           NTALO: INDEX OF THE CELL VOLUME TALLIES
C                       NTALW: TOTAL NUMBER OF SURFACE TALLIES
        NIONP=NION+1
        NATMP=NATM+1
        NMOLP=NMOL+1
        NPLSP=NPLS+1
        NPHOTP=NPHOT+1
        NADVP=NADV+1
        NADSP=NADS+1
        NCLVP=NCLV+1
        NALVP=NALV+1
        NALSP=NALS+1
        NSNVP=NSNV+1

        NTALI=17
        NTALN=12
        NTALO=14
        NTALV=100
        NTALA=57   ! NTALV-27, WITH NTALV=84
        NTALC=58   ! NTALV-26, WITH NTALV=84
        NTALT=59   ! NTALV-25, WITH NTALV=84
        NTALM=60   ! NTALV-24, WITH NTALV=84
        NTALB=61   ! NTALV-23, WITH NTALV=84
        NTALR=62   ! NTALV-22, WITH NTALV=84
        NTALS=59
        NTLSA=NTALS-2
        NTLSR=NTALS-1
        N2MX=MAX(NPHOT,NATM,NMOL,NION,NPLS,NADS,NALS)
        NSPZ=NPHOT+NATM+NMOL+NION+NPLS
        NSPZP=NSPZ+1
        NSPZMC=NPHOT+NATM+NMOL+NION


C  TOTAL NUMBER OF SURFACE AVERAGED TALLIES
C  SET IN SETPRM ACCORDING TO THE LIVING TALLIES SPECIFIED IN LIVTALS
        NSFTLP=13*NATMP+13*NMOLP+13*NIONP+13*NPHOTP+3*NPLSP+1+
     P        1*NADSP+1*NALSP+1*NSPZP

C  SURFACE REFLECTION DATA
        NHD1=12
        NHD2=7
        NHD3=5
        NHD4=5
        NHD5=5

C  ATOMIC DATA STORAGE
C  NSTORAM=0     : --> NHSTOR=0 --> NSTORDT=1,      NSTORDR=1
C  NSTORAM=1,...9: --> NHSTOR=1 --> NSTORDT=NSTORAM,NSTORDR=NRAD
        NHSTOR=1-1/(NSTORAM+1)
        NSTORDT=NHSTOR*NSTORAM+(1-NHSTOR)*1
        NSTORDR=NHSTOR*NRAD+   (1-NHSTOR)*1

! NUMBER OF TRAJECTORIES THAT CAN BE STORED 
        NTRJ = 1

C
      ELSE IF (ICAL == 2) THEN

!pb        NCPV=NCOP*NPLS
        NBGV=NBGK*3
        NCPVP=NCPV+1
        NBGVP=NBGV+1
        NCOLMC=NPLS+NRDS+NREC
        N1MX=NPHOT+NATM+NMOL+NION+NPLS+NADV+NALV+NCLV+NCPV+NBGV
!PB        N1MX=MAX(NPHOT,NATM,NMOL,NION,NPLS,NADV,NALV,NCLV,NCPV,NBGV)
        NSPZTOT=NPHOT+NATM+NMOL+NION+NPLS+NADV+NALV+NCLV+NCPV+NBGV
C  TOTAL NUMBER OF VOLUME AVERAGED TALLIES
C  SET IN SETPRM ACCORDING TO LIVING TALLIES SPECIFIED IN LIVTALV
!pb        NVOLTL=6*NATM+6*NMOL+6*NION+6*NPHOT+1*NADV+1*NCLV+
!pb     P         1*NSNV+1*NCPV+1*NALV+1*NBGV+
!pb     P         4*NPLS+3*(NATM+NMOL+NION+NPHOT)+
!pb     P         NATM+NMOL+NION+NPHOT
!pb        IF (NATM > 0) NVOLTL = NVOLTL + 8
!pb        IF (NMOL > 0) NVOLTL = NVOLTL + 8
!pb        IF (NION > 0) NVOLTL = NVOLTL + 8
!pb        IF (NPHOT > 0) NVOLTL = NVOLTL + 8
        NVLTLP=6*NATMP+6*NMOLP+6*NIONP+6*NPHOTP+1*NADVP+1*NCLVP+
     P         1*NSNVP+1*NCPVP+1*NALVP+1*NBGVP+
     P         4*NPLSP+28+3*(NATMP+NMOLP+NIONP+NPHOTP)+
     P         NATMP+NMOLP+NIONP+NPHOTP+NPLSP+5+
     P         3*(NATMP+NMOLP+NIONP+NPHOTP)+4*NPLSP
        NCPV_STAT=(NCPV+NPLS+2)*NSWIT+1
        NSCOP=NCPV_STAT*NRTALS

      END IF

      RETURN
      END SUBROUTINE SET_PARMMOD


      SUBROUTINE COLLECT_PARM

      INT_PARM = 0

      INT_PARM(  1) = N1ST
      INT_PARM(  2) = N2ND
      INT_PARM(  3) = N3RD
      INT_PARM(  4) = NADD
      INT_PARM(  5) = NTOR
      INT_PARM(  6) = NRTAL
      INT_PARM(  7) = NLIM
      INT_PARM(  8) = NSTS
      INT_PARM(  9) = NPLG
      INT_PARM( 10) = NPPART
      INT_PARM( 11) = NKNOT
      INT_PARM( 12) = NTRI
      INT_PARM( 13) = NTETRA
      INT_PARM( 14) = NCOORD
      INT_PARM( 15) = NOPTIM
      INT_PARM( 16) = NOPTM1

      INT_PARM( 17) = NSTRA
      INT_PARM( 18) = NSRFS
      INT_PARM( 19) = NSTEP

      INT_PARM( 20) = NATM
      INT_PARM( 21) = NMOL
      INT_PARM( 22) = NION
      INT_PARM( 23) = NPLS
      INT_PARM( 24) = NPHOT
      INT_PARM( 25) = NADV
      INT_PARM( 26) = NADS
      INT_PARM( 27) = NCLV
      INT_PARM( 28) = NSNV
      INT_PARM( 29) = NALV
      INT_PARM( 30) = NALS
      INT_PARM( 31) = NAIN
      INT_PARM( 32) = NCOP
      INT_PARM( 33) = nbgk

      INT_PARM( 34) = NSD
      INT_PARM( 35) = NSDW
      INT_PARM( 36) = NCV

      INT_PARM( 37) = NREAC
      INT_PARM( 38) = NREC
      INT_PARM( 39) = NRDS
      INT_PARM( 40) = NRCX
      INT_PARM( 41) = NREL
      INT_PARM( 42) = NRPI

      INT_PARM( 43) = NHD1
      INT_PARM( 44) = NHD2
      INT_PARM( 45) = NHD3
      INT_PARM( 46) = NHD4
      INT_PARM( 47) = NHD5
      INT_PARM( 48) = NHD6

      INT_PARM( 49) = NCHOR
      INT_PARM( 50) = NCHEN

      INT_PARM( 51) = NDX
      INT_PARM( 52) = NDY
      INT_PARM( 53) = NFL
      INT_PARM( 54) = NDXP
      INT_PARM( 55) = NDYP
      INT_PARM( 56) = NPTRGT

      INT_PARM( 57) = NPRNL


      INT_PARM( 58) = NGEOM_USR
      INT_PARM( 59) = NCOUP_INPUT
      INT_PARM( 60) = NSMSTRA
      INT_PARM( 61) = NSTORAM
      INT_PARM( 62) = NGSTAL
      INT_PARM( 63) = NRPES

      INT_PARM( 64) = NRAD
      INT_PARM( 65) = NSWIT
      INT_PARM( 66) = N1F
      INT_PARM( 67) = N2F
      INT_PARM( 68) = N3F
      INT_PARM( 69) = NGITT
      INT_PARM( 70) = NGITTP
      INT_PARM( 71) = NRADS
      INT_PARM( 72) = N2NDPLG
      INT_PARM( 73) = N1STS
      INT_PARM( 74) = N2NDS
      INT_PARM( 75) = NTRIS
      INT_PARM( 76) = NKNOTS
      INT_PARM( 77) = NRTALS

      INT_PARM( 78) = NGTSFT
      INT_PARM( 79) = NLIMPS
      INT_PARM( 80) = NLMPGS

      INT_PARM( 81) = NCPV
      INT_PARM( 82) = NBGV
      INT_PARM( 83) = NBMAX
      INT_PARM( 84) = NPTAL
      INT_PARM( 85) = NCPV_STAT
      INT_PARM( 86) = NSCOP

      INT_PARM( 87) = NSTRAP

      INT_PARM( 88) = NIONP
      INT_PARM( 89) = NATMP
      INT_PARM( 90) = NMOLP
      INT_PARM( 91) = NPLSP
      INT_PARM( 92) = NPHOTP
      INT_PARM( 93) = NADVP
      INT_PARM( 94) = NADSP
      INT_PARM( 95) = NCLVP
      INT_PARM( 96) = NALVP
      INT_PARM( 97) = NALSP
      INT_PARM( 98) = NSNVP
      INT_PARM( 99) = NCPVP
      INT_PARM(100) = NBGVP
      INT_PARM(101) = NTALI
      INT_PARM(102) = NTALN
      INT_PARM(103) = NTALO
      INT_PARM(104) = NTALV
      INT_PARM(105) = NTALA
      INT_PARM(106) = NTALC
      INT_PARM(107) = NTALT
      INT_PARM(108) = NTALM
      INT_PARM(109) = NTALB
      INT_PARM(110) = NTALR
      INT_PARM(111) = NTALS
      INT_PARM(112) = NTLSA
      INT_PARM(113) = NTLSR
      INT_PARM(114) = NTALW
      INT_PARM(115) = N1MX
      INT_PARM(116) = N2MX
      INT_PARM(117) = NSPZ
      INT_PARM(118) = NSPZP
      INT_PARM(119) = NSPZMC
      INT_PARM(120) = NCOLMC
      INT_PARM(121) = NSPZTOT

      INT_PARM(122) = NVOLTL
      INT_PARM(123) = NVLTLP
      INT_PARM(124) = NSRFTL
      INT_PARM(125) = NSFTLP


      INT_PARM(126) = NH0
      INT_PARM(127) = NH1
      INT_PARM(128) = NH2
      INT_PARM(129) = NH3

      INT_PARM(130) = NHSTOR
      INT_PARM(131) = NSTORDT
      INT_PARM(132) = NSTORDR

      INT_PARM(133) = NPLT

      INT_PARM(134) = NROT
      INT_PARM(135) = NADSPC

      INT_PARM(136) = NPLSTI
      INT_PARM(137) = NPLSV
      INT_PARM(138) = NTRJ
      INT_PARM(139) = NBACK_SPEC

      RETURN
      END SUBROUTINE COLLECT_PARM


      SUBROUTINE DISTRIB_PARM

      N1ST        = INT_PARM(  1)
      N2ND        = INT_PARM(  2)
      N3RD        = INT_PARM(  3)
      NADD        = INT_PARM(  4)
      NTOR        = INT_PARM(  5)
      NRTAL       = INT_PARM(  6)
      NLIM        = INT_PARM(  7)
      NSTS        = INT_PARM(  8)
      NPLG        = INT_PARM(  9)
      NPPART      = INT_PARM( 10)
      NKNOT       = INT_PARM( 11)
      NTRI        = INT_PARM( 12)
      NTETRA      = INT_PARM( 13)
      NCOORD      = INT_PARM( 14)
      NOPTIM      = INT_PARM( 15)
      NOPTM1      = INT_PARM( 16)

      NSTRA       = INT_PARM( 17)
      NSRFS       = INT_PARM( 18)
      NSTEP       = INT_PARM( 19)

      NATM        = INT_PARM( 20)
      NMOL        = INT_PARM( 21)
      NION        = INT_PARM( 22)
      NPLS        = INT_PARM( 23)
      NPHOT       = INT_PARM( 24)
      NADV        = INT_PARM( 25)
      NADS        = INT_PARM( 26)
      NCLV        = INT_PARM( 27)
      NSNV        = INT_PARM( 28)
      NALV        = INT_PARM( 29)
      NALS        = INT_PARM( 30)
      NAIN        = INT_PARM( 31)
      NCOP        = INT_PARM( 32)
      NBGK        = INT_PARM( 33)

      NSD         = INT_PARM( 34)
      NSDW        = INT_PARM( 35)
      NCV         = INT_PARM( 36)

      NREAC       = INT_PARM( 37)
      NREC        = INT_PARM( 38)
      NRDS        = INT_PARM( 39)
      NRCX        = INT_PARM( 40)
      NREL        = INT_PARM( 41)
      NRPI        = INT_PARM( 42)

      NHD1        = INT_PARM( 43)
      NHD2        = INT_PARM( 44)
      NHD3        = INT_PARM( 45)
      NHD4        = INT_PARM( 46)
      NHD5        = INT_PARM( 47)
      NHD6        = INT_PARM( 48)

      NCHOR       = INT_PARM( 49)
      NCHEN       = INT_PARM( 50)

      NDX         = INT_PARM( 51)
      NDY         = INT_PARM( 52)
      NFL         = INT_PARM( 53)
      NDXP        = INT_PARM( 54)
      NDYP        = INT_PARM( 55)
      NPTRGT      = INT_PARM( 56)

      NPRNL       = INT_PARM( 57)


      NGEOM_USR   = INT_PARM( 58)
      NCOUP_INPUT = INT_PARM( 59)
      NSMSTRA     = INT_PARM( 60)
      NSTORAM     = INT_PARM( 61)
      NGSTAL      = INT_PARM( 62)
      NRPES       = INT_PARM( 63)

      NRAD        = INT_PARM( 64)
      NSWIT       = INT_PARM( 65)
      N1F         = INT_PARM( 66)
      N2F         = INT_PARM( 67)
      N3F         = INT_PARM( 68)
      NGITT       = INT_PARM( 69)
      NGITTP      = INT_PARM( 70)
      NRADS       = INT_PARM( 71)
      N2NDPLG     = INT_PARM( 72)
      N1STS       = INT_PARM( 73)
      N2NDS       = INT_PARM( 74)
      NTRIS       = INT_PARM( 75)
      NKNOTS      = INT_PARM( 76)
      NRTALS      = INT_PARM( 77)

      NGTSFT      = INT_PARM( 78)
      NLIMPS      = INT_PARM( 79)
      NLMPGS      = INT_PARM( 80)

      NCPV        = INT_PARM( 81)
      NBGV        = INT_PARM( 82)
      NBMAX       = INT_PARM( 83)
      NPTAL       = INT_PARM( 84)
      NCPV_STAT   = INT_PARM( 85)
      NSCOP       = INT_PARM( 86)

      NSTRAP      = INT_PARM( 87)

      NIONP       = INT_PARM( 88)
      NATMP       = INT_PARM( 89)
      NMOLP       = INT_PARM( 90)
      NPLSP       = INT_PARM( 91)
      NPHOTP      = INT_PARM( 92)
      NADVP       = INT_PARM( 93)
      NADSP       = INT_PARM( 94)
      NCLVP       = INT_PARM( 95)
      NALVP       = INT_PARM( 96)
      NALSP       = INT_PARM( 97)
      NSNVP       = INT_PARM( 98)
      NCPVP       = INT_PARM( 99)
      NBGVP       = INT_PARM(100)
      NTALI       = INT_PARM(101)
      NTALN       = INT_PARM(102)
      NTALO       = INT_PARM(103)
      NTALV       = INT_PARM(104)
      NTALA       = INT_PARM(105)
      NTALC       = INT_PARM(106)
      NTALT       = INT_PARM(107)
      NTALM       = INT_PARM(108)
      NTALB       = INT_PARM(109)
      NTALR       = INT_PARM(110)
      NTALS       = INT_PARM(111)
      NTLSA       = INT_PARM(112)
      NTLSR       = INT_PARM(113)
      NTALW       = INT_PARM(114)
      N1MX        = INT_PARM(115)
      N2MX        = INT_PARM(116)
      NSPZ        = INT_PARM(117)
      NSPZP       = INT_PARM(118)
      NSPZMC      = INT_PARM(119)
      NCOLMC      = INT_PARM(120)
      NSPZTOT     = INT_PARM(121)

      NVOLTL      = INT_PARM(122)
      NVLTLP      = INT_PARM(123)
      NSRFTL      = INT_PARM(124)
      NSFTLP      = INT_PARM(125)


      NH0         = INT_PARM(126)
      NH1         = INT_PARM(127)
      NH2         = INT_PARM(128)
      NH3         = INT_PARM(129)

      NHSTOR      = INT_PARM(130)
      NSTORDT     = INT_PARM(131)
      NSTORDR     = INT_PARM(132)

      NPLT        = INT_PARM(133)

      NROT        = INT_PARM(134)
      NADSPC      = INT_PARM(135)

      NPLSTI      = INT_PARM(136)
      NPLSV       = INT_PARM(137)
      NTRJ        = INT_PARM(138)
      NBACK_SPEC  = INT_PARM(139)

      RETURN
      END SUBROUTINE DISTRIB_PARM


      SUBROUTINE SPEC_TO_SPEC (SPECA, SPECB)

      TYPE(EIRENE_SPECTRUM), INTENT(OUT) :: SPECA
      TYPE(EIRENE_SPECTRUM), INTENT(IN) :: SPECB

      SPECA%SPCMIN  = SPECB%SPCMIN
      SPECA%SPCMAX  = SPECB%SPCMAX
      SPECA%SPCDEL  = SPECB%SPCDEL
      SPECA%SPCDELI = SPECB%SPCDELI
      SPECA%SPCINT  = SPECB%SPCINT
      SPECA%ESP_MIN = SPECB%ESP_MIN
      SPECA%ESP_MAX = SPECB%ESP_MAX
      SPECA%ESP_00  = SPECB%ESP_00
      SPECA%SPC_XPLT= SPECB%SPC_XPLT
      SPECA%SPC_YPLT= SPECB%SPC_YPLT
      SPECA%SPC_SAME= SPECB%SPC_SAME
      SPECA%SPCVX   = SPECB%SPCVX
      SPECA%SPCVY   = SPECB%SPCVY
      SPECA%SPCVZ   = SPECB%SPCVZ
      SPECA%SGMS    = SPECB%SGMS
      SPECA%STVS    = SPECB%STVS
      SPECA%EES     = SPECB%EES
      SPECA%NSPC    = SPECB%NSPC
      SPECA%ISPCTYP = SPECB%ISPCTYP
      SPECA%ISPCSRF = SPECB%ISPCSRF
      SPECA%IPRTYP  = SPECB%IPRTYP
      SPECA%IPRSP   = SPECB%IPRSP
      SPECA%IMETSP  = SPECB%IMETSP
      SPECA%ISRFCLL = SPECB%ISRFCLL
      SPECA%IDIREC  = SPECB%IDIREC
      SPECA%SPC     = SPECB%SPC
      IF (ASSOCIATED(SPECA%SDV)) THEN
        SPECA%SDV     = SPECB%SDV
        SPECA%SGM     = SPECB%SGM
      END IF
      END SUBROUTINE SPEC_TO_SPEC



      END MODULE PARMMOD
C ===== SOURCE: precision.f
      MODULE PRECISION

      PUBLIC :: DP, SP

      INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(13)
      INTEGER, PARAMETER :: SP = SELECTED_REAL_KIND(6)

      END MODULE PRECISION
