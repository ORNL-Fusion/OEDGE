
MODULE mod_grid
  use global_parameters
  IMPLICIT none

  include 'cell_type'

  PRIVATE


  !real,allocatable,pointer,public,save :: rs(:,:),zs(:,:),bratio(:,:)
  !real,allocatable,pointer,public,save :: karea(:,:),kvols(:,:)
  !real,allocatable,pointer,public,save :: korpg(:,:),rvertp(:,:),zvertp(:,:),nvertp(:)
  !real,allocatable,pointer,public,save :: sonnetik(:,:),sonnetir(:,:)


  !PUBLIC :: ALLOC_GRID, DEALLOC_GRID



  !...  Variables to store the knot indices in the sonnet grid file, for use when
  !     loading B2 data from Rhozansky:
  INTEGER, PUBLIC, ALLOCATABLE, SAVE :: sonnetik(:,:),sonnetir(:,:)


      TYPE type_grid
        INTEGER :: nrs                                     ! number of rings   
        integer,allocatable :: nks(:)                      ! cells/ring  
        type(type_cell),allocatable :: knot(:)      ! cell data
        integer,allocatable :: imap(:,:)    ! korpg/direct cell reference
        integer,allocatable :: sonnetmap(:,:) ! index map to the original sonnet data
        ! grid allows for up to 2 xpoints
        integer :: nxpt
        real :: rxpt(2),zxpt(2)
        real :: rcenter,zcenter
        integer :: ns
        integer:: irsep
        integer,allocatable :: ring_type(:)
        !
        ! Ring-types:   1- primary separatrix
        !               2- secondary separatrix
        !               3- outer boundary
        !               4- inner boundary
        !
       
      ENDTYPE type_grid

      type(type_grid),target,save :: grid

      integer,parameter :: numzone = 5
      REAL*8 ,  PARAMETER :: TOL = 1.0D-06

      integer :: nknot
      type (type_cell),pointer :: knot(:)
      integer,pointer          :: imap(:,:)
      integer,pointer :: nrs,nks(:)


CONTAINS

  subroutine allocate_grid(maxnrs,maxnks)
    implicit none
    integer :: maxnrs,maxnks

    allocate(grid%nks(maxnrs))
    allocate(grid%knot(maxnrs*maxnks))
    allocate(grid%imap(maxnks,maxnrs))
    allocate(grid%ring_type(maxnrs))
    allocate(grid%sonnetmap(maxnks,maxnrs))

    knot = grid%knot
    imap = grid%imap
    nrs  = grid%nrs
    nks  = grid%nks


  end subroutine allocate_grid

  subroutine deallocate_grid
    implicit none
    if (allocated(grid%nks)) deallocate(grid%nks)
    if (allocated(grid%knot))deallocate(grid%knot)
    if (allocated(grid%imap))deallocate(grid%imap)
    if (allocated(grid%ring_type))deallocate(grid%ring_type)
    if (allocated(grid%sonnetmap))deallocate(grid%sonnetmap)
  end subroutine deallocate_grid


  subroutine calc_cell_area(knot)
        use global_parameters
    implicit none
    !
    !      This routine calculates the area of the cell represented by the knot
    !
    !

    type (type_cell) :: knot

    integer :: icur,inext
    real*8 :: area = 0.0



    do icur = 1,knot%nv

       if (icur == knot%nv) then 
          inext = 1
       else
          inext = icur + 1
       endif

       area = area + (knot%rv(inext)*knot%zv(icur)  - knot%rv(icur)*knot%zv(inext))

    end do

    area = 0.5 * abs(area)

    knot%area = area

    knot%vol = 2.0 * PI * knot%rcen * area

  end subroutine calc_cell_area



      subroutine rzshift(knot,rshift,zshift)
        implicit none
        !
        ! Shift the R,Z coordinates of the cell geometry data
        !

        type(type_cell) :: knot
        real :: rshift,zshift
        
        integer :: in

        knot%rcen = knot%rcen + rshift
        knot%zcen = knot%zcen + zshift

        do in = 1,knot%nv
           knot%rv(in) = knot%rv(in) + rshift
           knot%zv(in) = knot%zv(in) + zshift
        end do 

      end subroutine rzshift



      subroutine ReadSonnetCells(gridunit)
        use global_parameters
        implicit none
        
        INTEGER,intent(in) ::  gridunit
        character(len=100) :: buffer


        !...  Find the start of the cell/knot information in the grid file:
        WRITE(buffer,'(100X)')
        DO WHILE (buffer(4:8).NE.'=====')
           READ(gridunit,'(A10)',END=98) buffer
        ENDDO

        !...  Read the knot data:
        nknot = 0
        DO WHILE(nknot.EQ.0.OR.buffer(4:10).EQ.'Element')
           nknot = nknot + 1
           READ(gridunit,80,END=97) knot(nknot)%index,&
                knot(nknot)%ik   ,knot(nknot)%ir,&
                knot(nknot)%rv(2),knot(nknot)%zv(2),&
                knot(nknot)%rv(3),knot(nknot)%zv(3)
           READ(gridunit,81,END=97) knot(nknot)%bratio,&
                knot(nknot)%rcen ,knot(nknot)%zcen
           READ(gridunit,82,END=97) knot(nknot)%rv(1),knot(nknot)%zv(1),&
                knot(nknot)%rv(4),knot(nknot)%zv(4)

           knot(nknot)%nv = 4
           knot(nknot)%xpt= 0
           !
           ! Calculate the cell area and volume
           !
           call calc_cell_area(knot(nknot))

           !...    Dividing line:       
           READ(gridunit,*)
           READ(gridunit,'(A10)',END=20) buffer
           BACKSPACE(gridunit)
        ENDDO

80      FORMAT(10X,I5,4X,I3,1x,i3,4x,e17.10e2,1x,e17.10e2,8x,e17.10e2,1x,E17.10E2)
81      FORMAT(18x,e17.10e2,14x,e17.10e2,1x,e17.10e2)
82      FORMAT(30x,e17.10e2,1x,e17.10e2,8x,e17.10e2,1x,e17.10e2)


        !...  Continuation for end of file condition

20      CONTINUE

        return

97      CALL ER('ReadSonnetCells','Unexpected end-of-file',*99)
98      CALL ER('ReadSonnetCells','Problem accessing grid file',*99)

!99      WRITE(0,*) 'IXPT:',ixpt(1),ixpt(2)
99      continue
        STOP  

      end subroutine ReadSonnetCells


      subroutine ReadSonnetGridHeaders(gridunit,rshift,zshift,ix_cell_offset)
        implicit none
        integer :: gridunit
        character(len=100) :: buffer
        real :: rshift,zshift
        integer :: ix_cell_offset
        !
        ! Read the header section of a sonnet style generalized grid
        !
        !
        ! Ignore these headers for a generalised grid
        !        
        ! slmod begin - tr
        !...  Check if it is a quasi-double-null grid:
        !     READ(gridunit,'(A100)') buffer
        !      IF     (buffer(1:17).EQ.'QUASI-DOUBLE-NULL') THEN  ! A couple of DIII-D grid still using this...
        !         CALL ReadQuasiDoubleNull(gridunit,ik,ir,rshift,zshift,
        !     .                            indexiradj)
        !         GOTO 300
        !      ELSEIF (buffer(1:16).EQ.'GENERALISED_GRID') THEN
        !         CALL ReadGeneralisedGrid(gridunit,ik,ir,rshift,zshift,
        !     .                            indexiradj)
        !         GOTO 300
        !      ELSE
        !        BACKSPACE(gridunit)
        !      ENDIF
        !

        ! slmod end
        !
        !     Read in lines until '======'
        !
        !      write (6,*) 'Working ... '
        !
100     read(gridunit,'(a100)',end=1000) buffer
        !
        !     Scan through any header information - the grid comes after the
        !     row of '======= ... '
        !
        !     If the characteristic grid numbers are in the grid header - extract
        !     them for later use.
        !
        ! jdemod - These numbers are not significant for a generalised grid
        !
        !
        !      if (buffer(1:5).eq.'GEOM:'.or.&
        !         buffer(1:5).eq.'Geom:'.or.&
        !         buffer(1:5).eq.'geom:') then
        !
        !        The agreed upon order for the GEOM: line if it is present
        !        is the following ...
        !
        !        GEOM:  #rings  #cutring    #knots   #cutpoint1  #cutpoint2
        !
        !         read (buffer(6:),*) maxrings,cutring,maxkpts,cutpt1,cutpt2
        !
        !        Check for existence of private plasma for grid - this process will
        !        INCLUDE the boundary cells in the core.
        !
        !        Setting these values to 1 and maxkpts will also result in a grid
        !        without a PFZ but in this case the boundary cells will be stripped 
        !        from the core rings.
        !
        !         if ((cutpt1.eq.0.or.cutpt1.eq.1)) then 
        !            nopriv = .true.
        !         else
        !            nopriv = .false.
        !         endif
        !
        !      endif
        !
        !
        !
        if (buffer(1:12).eq.'CELL_OFFSET:'.or.&
             buffer(1:12).eq.'Cell_Offset:'.or.&
             buffer(1:12).eq.'cell_offset:') then
           !
           !        If this line is present it specifies the IX offset into the 
           !        grid where the target virtual cells can be found. The boundary
           !        cells at the edge of the grid are stripped and the entire 
           !        grid shifted so that the embedded boundary cells are moved to 
           !        the ends. This process is repeated with the background plasma
           !        data before the call to maptodiv.  
           !
           read (buffer(13:),*) ix_cell_offset
           !
           !         write(0,*) 'IX_CELL_OFFSET:',ix_cell_offset
           !
        endif
        !
        !     Check also for grid shift/displacement information
        !
        if (buffer(1:6).eq.'SHIFT:'.or.&
             buffer(1:6).eq.'Shift:'.or.&
             buffer(1:6).eq.'shift:') then
           !
           !        The data is RSHIFT ZSHIFT
           !
           read (buffer(7:),*) rshift,zshift
           !
        endif
        !
        if (buffer(4:8).ne.'=====') goto 100



1000 continue



      end subroutine ReadSonnetGridHeaders

      
      subroutine ReadJetCells


      end subroutine ReadJetCells



      subroutine ReadAsdexCells


      end subroutine ReadAsdexCells


      subroutine ReadIterCells



      end subroutine ReadIterCells

      subroutine read_psi(gridunit)
        implicit none
        integer :: gridunit


      end subroutine read_psi

      subroutine read_walls(gridunit)
        implicit none 
        integer :: gridunit


      end subroutine read_walls




      SUBROUTINE ReadGeneralisedGrid(gridunit,rshift,zshift,indexiradj)
        use global_parameters
        IMPLICIT none

        INTEGER,intent(in) ::  gridunit
        integer :: indexiradj
        REAL,intent(in) ::     rshift,zshift

        !      INCLUDE 'params'
        !      INCLUDE 'cgeom'
        !      INCLUDE 'comtor'
        !      INCLUDE 'slcom'
        !      INCLUDE 'pindata'

        !..TMP
        !      CHARACTER title*174,desc*1024,job*72,equil*60
        !      REAL      facta(-1:MAXIZS),factb(-1:MAXIZS)


        INTEGER ::  nknot,z1,r1,kind,nxpt
        integer :: index1,index2,temp_val
        integer :: index_xpt(0:2),cell_xpt(0:2),cell_on_boundary(0:2)
        integer ::  izone(NUMZONE+1,NUMZONE)

        integer :: index_core(0:2)
        integer :: ring_xpt(0:2)

        integer ::  ikmax,irmax,ir1
        integer ::  numpsi,ikpsi(MAXNRS),irpsi(MAXNRS)
        LOGICAL ::  cont,deleteknot,output,swap
        REAL    ::  area,valpsi(MAXNRS)

        ! REAL(long)  ::  rvdp(4),zvdp(4),areadp

        !
        !     Required variables
        !
        !
        CHARACTER(len=1000) :: buffer

        real :: rspan,zspan
        real :: vrmin,vrmax,vzmin,vzmax

        integer :: knot_cnt

        integer :: in,iv,nlim,i1,i2,ixpt,tmpnks
        integer :: ix_cell_offset
        logical :: connected

        !
        ! Local data useful while building the grid
        !
        integer :: ik,ir
        !integer :: nrs,nks(maxnrs)
        integer :: irsep,irwall,irtrap,irsep2
        integer :: first_pfr_ring

        INTEGER, ALLOCATABLE :: imap(:,:)

        TYPE(type_cell),ALLOCATABLE :: knot(:)

        type(type_cell) :: temp_knot

        !
        !     jdemod - flag for turning on and off debugging output
        !
        output = .TRUE.

        !
        ! Initialization
        !
        connected = .false.
        ix_cell_offset = 0
        rshift = 0.0
        zshift = 0.0

        call allocate_grid(maxnrs,maxnks)

        call ReadSonnetGridFileHeaders(gridunit,rshift,zshift,ix_cell_offset)

        call ReadSonnetCells(gridunit)

        IF (output) then
           write(0,*) 'CELLS READ IN:', nknot,&
                       knot(nknot)%ir,knot(nknot)%ik
           write(6,*) 'CELLS READ IN:', nknot,&
                       knot(nknot)%ir,knot(nknot)%ik
        endif


        call read_psi(gridunit)

        call read_walls(gridunit)



        !...  R,Z shifts:

        do in = 1,nknot
           call rzshift(knot(in),rshift,zshift)
        end do


        !
        ! jde - finding the maxumum ik and ir from the sonnet grid indices 
        !

        ikmax = 0
        irmax = 0

        DO knot_cnt = 1, nknot
           IF (knot(knot_cnt)%ik.GT.ikmax) ikmax = knot(knot_cnt)%ik
           IF (knot(knot_cnt)%ir.GT.irmax) irmax = knot(knot_cnt)%ir
        ENDDO

        IF (output) then
           write(0,*) 'IKMAX,IRMAX:', ikmax,irmax
           write(6,*) 'IKMAX,IRMAX:', ikmax,irmax
        endif

        !...  Mark zero volume cells to be ignored
        !
        DO knot_cnt = 1,nknot
           !
           !        Check cell areas for zero or extremely small volumes. 
           !        Mark these cells to be ignored
           !                  
           if (knot(knot_cnt)%area < tol) then 
              knot(knot_cnt)%ignore = .true.
              IF (output) then
                 WRITE(0,*) 'KNOT MARKED IGNORE',knot_cnt
                 WRITE(6,*) 'KNOT MARKED IGNORE',knot_cnt
              endif
           else
              knot(knot_cnt)%ignore = .false. 
           endif

        end do


        !...  Assign knot sector (for improved efficiency in the search routines):

        vrmin =  HI
        vrmax = -HI
        vzmin =  HI
        vzmax = -HI

        !
        ! Find the max and min R,Z for the grid
        !
        DO in = 1, nknot      
           DO iv = 1, knot(in)%nv

              IF (knot(in)%rv(iv).LT.vrmin) vrmin = knot(in)%rv(iv)
              IF (knot(in)%rv(iv).GT.vrmax) vrmax = knot(in)%rv(iv)

              IF (knot(in)%zv(iv).LT.vzmin) vzmin = knot(in)%zv(iv)
              IF (knot(in)%zv(iv).GT.vzmax) vzmax = knot(in)%zv(iv)

           ENDDO
        ENDDO

        !
        ! Create a slightly larger box 
        !
        ! Note: this may need modifying if we use auto-generated extended grids
        !
        vrmin = vrmin - 0.001
        vrmax = vrmax + 0.001
        vzmin = vzmin - 0.001
        vzmax = vzmax + 0.001
        !
        !     jdemod
        !
        IF (output) then
           WRITE(0,*) 'GRID RMIN,RMAX,ZMIN,ZMAX:',vrmin,vrmax,vzmin,vzmax
           WRITE(6,*) 'GRID RMIN,RMAX,ZMIN,ZMAX:',vrmin,vrmax,vzmin,vzmax
        endif
        !
        !...  Assign knot to a search zone depending on its R,Z center coordinates
        ! 

        rspan = (vrmax - vrmin) / REAL(NUMZONE)
        zspan = (vzmax - vzmin) / REAL(NUMZONE)
        DO in = 1, nknot
           knot(in)%rzone = INT( (knot(in)%rcen - vrmin) / rspan ) + 1
           knot(in)%zzone = INT( (knot(in)%zcen - vzmin) / zspan ) + 1
           !        WRITE(0,*) 'SPAN:',in,knot(in)%rzone,knot(in)%zzone

        ENDDO

        !...  Index cells by zone, work now for saved time later:
        kind = 1
        DO z1 = 1, NUMZONE
           DO r1 = 1, NUMZONE
              izone(r1,z1) = kind
              DO in = kind, nknot
                 IF     (knot(in)%rzone.EQ.r1.AND.knot(in)%zzone.EQ.z1) THEN
                    IF (in.EQ.kind) THEN
                       !...            Do nothing:
                    ELSE
                       !...            Swap knots:
                       !               Maybe use direct assignment ? should work for simple compound types
                       !
                       temp_knot = knot(kind)                       
                       knot(kind) = knot(in)
                       knot(in) = temp_knot

                       !CALL MoveKnot(knot(kind),knot(0)   )
                       !CALL MoveKnot(knot(i1)  ,knot(kind))
                       !CALL MoveKnot(knot(0)   ,knot(i1)  )
                       !                WRITE(0,*) 'ZONING SWAP:',kind,i1
                    ENDIF
                    kind = kind + 1
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        !...  
        !     
        DO z1 = 1, NUMZONE-1
           izone(NUMZONE+1,z1) = izone(1,z1+1)
        ENDDO
        izone(NUMZONE+1,NUMZONE) = nknot + 1

        !      DO i1 = 1, nknot
        !        WRITE(0,*) 'ZONED:',i1,knot(i1)%rzone,knot(i1)%zzone
        !      ENDDO
        !      DO z1 = 1, NUMZONE+1
        !        DO r1 = 1, NUMZONE+1
        !          WRITE(0,*) 'IZONE:',izone(r1,z1) 
        !        ENDDO
        !      ENDDO

        !...  Search for x-point(s):
        !
        !     jdemod - it appears that the X-point finding algorithm used is the following:
        !            - the only cells on the grid which can have an identical vertex - both index and value 
        !              and not be the same cell must occur at the Xpoint - the shared vertex in this 
        !              case IS the Xpoint. This is the condition tested for when FindKnot is called with 
        !              a 1. Search efficiency has been enhanced by using the zones set up above. 
        !            - Zero volume cells would be an issue with this algorithm - code above this has 
        !              apparently removed zero volume cells where vertices 3=2 and 1=4 - however, it would 
        !              appear that boundary rings around the plasma and in the core/PFZ have not been 
        !              removed.
        !
        !      what about a limiter grid? 

        nxpt = 0
        DO index1 = 1, nknot

           ! if cell has already been associated with an Xpoint then cycle
           IF (knot(index1)%xpt.NE.0) CYCLE

           IF (nxpt.EQ.2) THEN
              WRITE(0,*)
              WRITE(0,*) '--------------------------------------------'
              WRITE(0,*) '-   MORE THAN 2 XPTS FOUND, IGNORING...    -'
              WRITE(0,*) '--------------------------------------------'
              WRITE(0,*)
              EXIT
           ENDIF

           ! condition =6 - find matching knot 2
           CALL FindKnot(nknot,knot,NUMZONE,izone,6,index1,index2)
           !CALL FindKnot(nknot,knot,NUMZONE,izone,1,i1,i2)

           ! cell found if index2.ne.-1
           IF (index2.NE.-1) THEN
              !
              !     jdemod - the code appears to assume that the midplane is at 0.0 - this 
              !              should probably be replaced with the zc value defining the 
              !              center of the confined plasma. 
              !
              !...      Select the appropriate cell, whichever is closest to the midplane will
              !         be the cell associated with the core (which we want to build first):

              ! First Xpoint down
              IF    (knot(index1)%zcen.LT.0.0.AND.knot(index2)%zcen.LT.0.0) THEN

                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,'(a,2i6,4(1x,g12.5))') 'XPT DN:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                    WRITE(6,'(a,2i6,4(1x,g12.5))') 'XPT DN:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                 endif

                 nxpt = nxpt + 1

                 ! If cell index1 is closer to center
                 IF (knot(index1)%zcen.GT.knot(index2)%zcen) THEN

                    index_xpt(nxpt) = index1
                    knot(index1)%xpt = index2
                    knot(index2)%xpt = index1

                    ! if cell index2 is closer to center
                 ELSE
                    index_xpt(nxpt) = index2
                    knot(index1)%xpt = index2
                    knot(index2)%xpt = index1

                 ENDIF

                 ! Upper xpoint
              ELSEIF(knot(index1)%zcen.GT.0.0.AND.knot(index2)%zcen.GT.0.0) THEN
                 nxpt = nxpt + 1

                 ! jdemod
                 IF (output) then 
                    WRITE(0,'(a,2i6,4(1x,g12.5))') 'XPT UP:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                    WRITE(6,'(a,2i6,4(1x,g12.5))') 'XPT UP:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                 endif

                 IF (knot(index1)%zcen.LT.knot(index2)%zcen) THEN
                    ! knot index1 is closer to center 
                    index_xpt(nxpt) = index1
                    knot(index1)%xpt = index2
                    knot(index2)%xpt = index1

                 ELSE
                    ! knot index2 is closer to the center
                    index_xpt(nxpt) = index2
                    knot(index1)%xpt = index2
                    knot(index2)%xpt = index1
                 ENDIF
              ELSE
                 CALL ER('Readgeneralisedgrid','Unrecognized x-point configuration - cells span Z=0.0',*99)
              ENDIF
           ENDIF
        ENDDO

        !...  No x-points found, for some reason:
        IF (nxpt.EQ.0) then 
           ! Add code to handle limiter geometries
           ! Neither of the vertex 1 or 2 methods will find the limiter tip
           ! vertex 1 = vertex 4 WILL find the limiter tip but only for conditions
           ! where there are no divertor legs - 1=4 is not unique when Xpoints are
           ! present.

           CALL ER('Readgeneralisedgrid','No x-points found',*99)

           ! There should be only one limiter tip in the grid 



           nlim = 0
           DO index1 = 1, nknot

              ! if cell has already been associated with an Xpoint then cycle
              IF (knot(index1)%xpt.NE.0) CYCLE

              IF (nlim.gt.1) THEN
                 WRITE(0,*)
                 WRITE(0,*) '------------------------------------------------------'
                 WRITE(0,*) '-   MORE THAN ONE LIMITER TIP FOUND:: STOPPING...    -'
                 WRITE(0,*) '------------------------------------------------------'
                 WRITE(0,*)
                 stop
              ENDIF

              ! condition = 7 - find vertex 1 = vertex 4 but vertex 2 not equal to vertex 3
              CALL FindKnot(nknot,knot,NUMZONE,izone,7,index1,index2)
              !CALL FindKnot(nknot,knot,NUMZONE,izone,1,i1,i2)

              ! cell found if index2.ne.-1
              IF (index2.NE.-1) THEN
                 !
                 !     jdemod - the code appears to assume that the midplane is at 0.0 - this 
                 !              should probably be replaced with the zc value defining the 
                 !              center of the confined plasma. 
                 !
                 !...      Select the appropriate cell, whichever is closest to the midplane will
                 !         be the cell associated with the core (which we want to build first):

                 !
                 ! Xpoint up and down is not relevant for a limiter
                 !


                 IF (output) then 
                    WRITE(0,'(a,2i6,4(1x,g12.5))') 'XPT DN:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                    WRITE(6,'(a,2i6,4(1x,g12.5))') 'XPT DN:',index1,index2,&
                         knot(index1)%rv(1),knot(index1)%zv(1),&
                         knot(index1)%zcen,knot(index2)%zcen
                 endif

                 nlim = nlim + 1

                 ! If cell index1 is closer to center

                 index_xpt(nxpt) = index1
                 knot(index1)%xpt = index2
                 knot(index2)%xpt = index1
              ENDIF
           ENDDO


        endif

        IF (output) THEN
           DO index1 = 1, nxpt
              WRITE(0,'(a,5i6)') 'XPTS:',index1,&
                   index_xpt(index1),knot(index_xpt(index1))%index,&
                   knot(index_xpt(index1))%xpt,&
                   knot(knot(index_xpt(index1))%xpt)%index
              WRITE(6,'(a,5i6)') 'XPTS:',index1,&
                   index_xpt(index1),knot(index_xpt(index1))%index,&
                   knot(index_xpt(index1))%xpt,&
                   knot(knot(index_xpt(index1))%xpt)%index
           ENDDO
           DO index1 = 1, nlim
              WRITE(0,'(a,5i6)') 'LIM TIP:',index1,&
                   index_xpt(index1),knot(index_xpt(index1))%index,&
                   knot(index_xpt(index1))%xpt,&
                   knot(knot(index_xpt(index1))%xpt)%index
              WRITE(6,'(a,5i6)') 'LIM TIP:',index1,&
                   index_xpt(index1),knot(index_xpt(index1))%index,&
                   knot(index_xpt(index1))%xpt,&
                   knot(knot(index_xpt(index1))%xpt)%index
           ENDDO
        ENDIF



        !
        !     jdemod - the Xpoint finding algorithm returns the two cells that share the 
        !              Xpoint vertex as index 1. One of these cells should be the cell
        !              in the SOL adjacent to the first cell on the core ring at the
        !              Xpoint. The second of these cells is below the Xpoint adjacent to 
        !              PFZ. By using the cell "closer to the midplane" it should choose
        !              the cell adjacent to the confined plasma - the cell sharing the side
        !              with vertices where 1 = 2 and 4 = 3 should be the first cell on the 
        !              core ring. 
        !
        !              The code then walks inward from the Xpoint finding the cell on the
        !              innermost core ring corresponding to the first cell on the ring at the 
        !              Xpoint. The variable cxpt records the number of rings from the Xpoint
        !              to the innermost ring. If this value is the same for two different
        !              Xpoints then the grid is a connected double null. If not - the difference
        !              in the two values should define the number of rings in the secondary 
        !              plasma between the two Xpoints for the DDN plasma configuration. 
        !
        !...  Searching for the start of the core center ring:
        !
        !     jdemod - when using cells in the main SOL for finding the center of the core there is
        !              a problem when the center point of the cell adjacent to the PFZ is inverted 
        !              relative to the Xpoint location. This can happen for grids with a strikepoint that
        !              is closer to Z=0.0 than the Xpoint. However, using cells that are actually in 
        !              the core and pfz by using a different vertex for Xpoint detection allows this 
        !              problem to be avoided. The definition of cxpt needs to be revised to accomodate this.
        !


        !
        ring_xpt = 0
        index_core = 0

        DO in = 1, nxpt
           index1 = index_xpt(in)
           cont = .TRUE.
           DO WHILE (cont)
              ! increment ring count
              ring_xpt(in) = ring_xpt(in) + 1
              cont = .FALSE.
              !
              !     jdemod - when the search has moved all the way inward and 
              !              can no longer find a cell with a matching side then
              !              i2=-1 is returned and the code moves onto any other
              !              Xpoints. 
              !
              CALL FindKnot(nknot,knot,NUMZONE,izone,2,index1,index2)

              IF (index2.NE.-1) THEN
                 cont = .TRUE.
                 index1 = index2 
                 index_core(in) = index2
              ENDIF
           ENDDO
           !
           !       jdemod
           IF (output) then 
              WRITE(0,*) 'CORE xpt:',in,index_xpt(in),ring_xpt(in),index_core(in)
              WRITE(0,'(a,i6,10(1x,g12.5))') 'CELL1:',index_xpt(in),&
                   knot(index_xpt(in))%rcen,  knot(index_xpt(in))%zcen          
              WRITE(0,'(a,i6,10(1x,g12.5))') 'CELL2:',index_core(in),&
                   knot(index_core(in))%rcen,  knot(index_core(in))%zcen          

              WRITE(6,*) 'CORE xpt:',in,index_xpt(in),ring_xpt(in),index_core(in)
              WRITE(6,'(a,i6,10(1x,g12.5))') 'CELL1:',index_xpt(in),&
                   knot(index_xpt(in))%rcen,  knot(index_xpt(in))%zcen          
              WRITE(6,'(a,i6,10(1x,g12.5))') 'CELL2:',index_core(in),&
                   knot(index_core(in))%rcen,  knot(index_core(in))%zcen          

           endif
           !        IF (output) WRITE(0,*) 'Ring_xpt:',ixpt(i3),ring_xpt(i3),icore(i3)
        ENDDO



        IF (nxpt.GT.1) THEN
           !...    Check that the x-points are ordered properly, with the primary x-point
           !       at index 1, and whether or not the double-null grid is connected:
           swap = .FALSE.
           IF     (nxpt.GT.1.AND.ring_xpt(1).EQ.ring_xpt(2)) THEN
              !...      Connected double null
              !...      List lower XPoint first
              IF (knot(index_xpt(1))%zcen.GT.knot(index_xpt(2))%zcen) swap = .TRUE.
              connected = .TRUE.
              !
              !         jdemod
              !
              IF (output) then 
                 WRITE(0,*) 'CONNECTED DN DETECTED'
                 WRITE(6,*) 'CONNECTED DN DETECTED'
              endif


           ELSEIF (nxpt.GT.1.AND.ring_xpt(1).GT.ring_xpt(2)) THEN
              !
              ! The primary xpoint is the one bounding the confined plasma - it will have
              ! a smaller ring index for the cell counting from the 
              ! innermost confined plasma ring. 
              !
              swap = .TRUE.
              connected = .FALSE.
           ENDIF
           IF (swap) THEN
              !
              !         jdemod
              IF (output) then 
                 WRITE(0,*) 'SWAPPING X-POINTS'
                 WRITE(6,*) 'SWAPPING X-POINTS'
              endif
              !          IF (output) WRITE(0,*) 'SWAPPING X-POINTS'
              temp_val = index_xpt (1)
              index_xpt (1) = index_xpt (2)
              index_xpt (2) = temp_val

              temp_val  = ring_xpt (1)
              ring_xpt (1)  = ring_xpt (2)
              ring_xpt (2)  = temp_val

              temp_val  = index_core(1)
              index_core(1) = index_core(2)
              index_core(2) = temp_val

           ENDIF
        ENDIF

        !...  Make sure that x-point knot indices are ordered properly, with the inner (lower radius)
        !     of each pair listed in IXPT:
        !      DO i1 = 1, nxpt
        !        IF (knot(ixpt(i1))%rcen.GT.knot(knot(ixpt(i1))%xpt)%rcen) THEN
        !          jdemod
        !          IF (output) then 
        !              WRITE(0,*) 'SWAPPING X-POINT PAIR',i1
        !              WRITE(6,*) 'SWAPPING X-POINT PAIR',i1
        !          endif       
        !          IF (output) WRITE(0,*) 'SWAPPING X-POINT PAIR',i1
        !          ixpt(i1) = knot(ixpt(i1))%xpt
        !        ENDIF
        !      ENDDO

        !...  Location of the primary separatrix is known:
        ! Add one to index since ring_xpt is the count for the last ring in the confined plasma

        irsep  = ring_xpt(1) +1 
        !irsep2 = irsep

        !...  Build the grid:
        !
        !     jdemod
        IF (output) then 
           WRITE(0,*) 'PROCESSING CORE RINGS'
           WRITE(6,*) 'PROCESSING CORE RINGS'
        endif

        !...  Start with the core rings:
        ik = 1
        ir = 1
        index1 = index_core(1) 
        DO WHILE(ir.LT.irsep)
           !
           ! First cell of core is mapped from Xpoint inward
           !
           imap(1,ir) = index1

           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.

              !...      Move along the ring:
              CALL FindKnot(nknot,knot,NUMZONE,izone,3,index1,index2)
              IF (index2.NE.-1) THEN
                 IF (index2.NE.imap(1,ir)) THEN
                    index1 = index2 
                    ik = ik + 1
                    imap(ik,ir) = index1
                    cont = .TRUE.
                    !
                    !             jdemod
                    IF (output) then 
                       WRITE(0,'(a,4i6,5(1x,g12.5))') 'CORE MAP:',&
                            ik,ir,i1,imap(1,ir),&
                            knot(i1)%rcen,knot(i1)%zcen
                       WRITE(6,'(a,4i6,5(1x,g12.5))') 'CORE MAP:',&
                            ik,ir,i1,imap(1,ir),&
                            knot(i1)%rcen,knot(i1)%zcen
                    endif
                    !              IF (output) WRITE(0,*) 'CORE MAP:',ik,ir,i1
                 ENDIF
              ELSE
                 CALL ER('Readgeneralisedgrid','CORE RING: Problem stepping along ring: Bad IK step',*99)
              ENDIF

           ENDDO

           nks(ir) = ik
           !...    Step outward one ring still in the core - from first cell in ring:        
           CALL FindKnot(nknot,knot,NUMZONE,izone,4,imap(1,ir),index2)
           IF (index2.NE.-1) THEN        
              index1 = index2
              ik = 1
              ir = ir + 1
           ELSE
              CALL ER('Readgeneralisedgrid','CORE RING: Problem stepping out one ring: Bad IR step',*99)
           ENDIF
        ENDDO

        !...  SOL rings: 
        !
        !     jdemod
        IF (output) then 
           WRITE(0,*) 'PROCESSING SOL RINGS'
           WRITE(6,*) 'PROCESSING SOL RINGS'
        endif
        !      IF (output) WRITE(0,*) 'PROCESSING SOL RINGS'
        !
        !     jdemod - Doesn't this assume an Xpoint down configuration? At least as far as the 
        !              "high field side" reference goes? I think the code itself still works. 
        !

        !...  Step out of the core on the high field side (note: if primary Xpoint is at the top this would not be the case)
        !
        !
        index1 = imap(1,irsep-1)
        CALL FindKnot(nknot,knot,NUMZONE,izone,4,index1,index2)
        !
        write(0,*) 'SOL RINGS:',irsep,index1,index2,knot(index2)%rcen,knot(index2)%zcen
        !
        IF (index2.NE.-1) THEN  
           !...    Move down to the target:
           index1 = index2
           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.
              CALL FindKnot(nknot,knot,NUMZONE,izone,5,index1,index2)
              IF (index2.NE.-1) THEN 
                 index1 = index2
                 cont = .TRUE.
              ENDIF
           ENDDO
        ELSE
           CALL ER('Readgeneralisedgrid','SOL RING: Problem stepping out into SOL: Bad IR step to SOL',*99)
        ENDIF
        !...  Target located, start mapping the SOL:
        ik = 1
        ir = irsep
        imap(ik,ir) = index1
        cont = .TRUE.
        DO WHILE(cont)
           cont = .FALSE.
           !...    Move along the ring to the other end:
           CALL FindKnot(nknot,knot,NUMZONE,izone,3,index1,index2)
           IF (index2.NE.-1) THEN
              index1 = index2 
              ik = ik + 1
              imap(ik,ir) = index1
              cont = .TRUE.
              !
              !         jdemod
              IF (output) then 
                 WRITE(0,'(a,4i6,5(1x,g12.5))') 'INNER SOL MAP:',&
                             ik,ir,index1,imap(1,ir),&
                             knot(index1)%rcen,knot(index1)%zcen
                 WRITE(6,'(a,4i6,5(1x,g12.5))') 'INNER SOL MAP:',&
                             ik,ir,index1,imap(1,ir),&
                             knot(index1)%rcen,knot(index1)%zcen
              endif

           ENDIF
           !...    Step radially outward if ring is finished:
           IF (.NOT.cont) THEN
              nks(ir) = ik
              index1 = imap(1,ir)
              CALL FindKnot(nknot,knot,NUMZONE,izone,4,i1,i2)          
              IF (index2.NE.-1) THEN
                 index1 = index2
                 ik = 1
                 ir = ir + 1
                 imap(ik,ir) = i1
                 cont = .TRUE.
                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,'(a,4i6,5(1x,g12.5))') 'INNER SOL MAP:NEW RING:',&
                                ik,ir,index1,imap(1,ir),&
                                knot(index1)%rcen,knot(index1)%zcen
                    WRITE(6,'(a,4i6,5(1x,g12.5))') 'INNER SOL MAP:NEW RING:',&
                                ik,ir,index1,imap(1,ir),&
                                knot(index1)%rcen,knot(index1)%zcen
                 endif

              ENDIF
           ENDIF
        ENDDO

        !
        ! For a single null will have just mapped the SOL out to the "wall" ring. 
        ! For a double null with lower primary Xpoint will have just mapped the high field side SOL rings
        ! For a double null with upper primary xpoint will have just mapped the low field side SOL rings
        !

        irwall = ir
        irtrap = ir + 1
        nrs = ir

        !
        ! The following code is only used for double null grids - it is required to map the second SOL rings
        !
        IF (nxpt.GT.1) THEN
           !
           !       jdemod
           IF (output) then
              WRITE(0,*) 'PROCESSING LOW FIELD SOL'
              WRITE(6,*) 'PROCESSING LOW FIELD SOL'
           endif

           !...    Process the low field side looking for any rings that
           !       were not processed when looking around the high field side (which
           !       is usually the case for double-nulls):
           !...    Register all knots that have been mapped to the grid:
           !
           DO ir = 1, nrs
              DO ik = 1, nks(ir)
                 knot(imap(ik,ir))%map = 1
              ENDDO
           ENDDO
           !
           !     jdemod - why not use - i1=imap(nks(irsep-1),irsep-1) ?
           !
           !...    Start with the first cell on the outer-most core ring and move to 
           !       the last cell on the same ring:
           !
           index1 = imap(1,irsep-1)
           CALL FindKnot(nknot,knot,NUMZONE,izone,5,i1,i2)

           write (0,*) 'Checking map:',index2,imap(nks(irsep-1),irsep-1)

           IF (index2.EQ.-1)  CALL ER('Readgeneralisedgrid',&
                &'CORE MAP: Problem finding LFS cell adjacent to Xpt: Should not happen',*99)

           index1 = index2

           !...    Move into the SOL - crossing rings moving outward into SOL
           CALL FindKnot(nknot,knot,NUMZONE,izone,4,index1,index2)
           IF (index2.NE.-1) THEN
              index1 = index2
              IF (knot(index2)%map.EQ.1) THEN  
                 !...        Keep moving outward until a cell with no assigned mapping is
                 !           found:
                 cont = .TRUE.
                 DO WHILE(cont)
                    cont = .FALSE.
                    CALL FindKnot(nknot,knot,NUMZONE,izone,4,index1,index2)
                    IF (index2.NE.-1) THEN 
                       index1 = index2
                       IF (knot(index1)%map.NE.0) cont = .TRUE.
                    ELSE
                       !...            Either an error or a single-null grid is being tested:
                       STOP 'ERROR: UNMAPPED CELL CONNECTS TO MAPPED CELL: SINGLE NULL GRID BEING TESTED OR ERROR?'
                    ENDIF
                 ENDDO
              ENDIF
           ELSE
              CALL ER('Readgeneralisedgrid','SOL RINGS: Problem mapping to LFS SOL: Bad IR step to SOL',*99)
           ENDIF

           !...    An unmapped cell has been found, proceed to target:
           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.
              CALL FindKnot(nknot,knot,NUMZONE,izone,5,index1,index2)
              IF (index2.NE.-1) THEN 
                 index1 = index2
                 cont = .TRUE.
              ENDIF
           ENDDO

           !...    Target located, start mapping the low field SOL:
           ik = 1
           ir = nrs + 1

           IF (connected) irsep2 = ir

           imap(ik,ir) = index1
           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.
              !...      Move along the ring:
              CALL FindKnot(nknot,knot,NUMZONE,izone,3,index1,index2)
              IF (index2.NE.-1) THEN
                 index1 = index2 
                 ik = ik + 1
                 imap(ik,ir) = i1
                 cont = .TRUE.
                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,'(a,4i6,5(1x,g12.5))') 'OUTER SOL MAP:',&
                         ik,ir,index1,imap(1,ir),&
                         knot(index1)%rcen,knot(index1)%zcen
                    WRITE(6,'(a,4i6,5(1x,g12.5))') 'OUTER SOL MAP:',&
                         ik,ir,index1,imap(1,ir),&
                         knot(index1)%rcen,knot(index1)%zcen
                 endif

              ENDIF

              !...      Step radially outward if ring is finished:
              IF (.NOT.cont) THEN
                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,*) 'STEPPING OUT: SECOND SOL',ik,ir,index1
                    WRITE(6,*) 'STEPPING OUT: SECOND SOL',ik,ir,index1
                 endif

                 nks(ir) = ik
                 index1 = imap(1,ir)
                 CALL FindKnot(nknot,knot,NUMZONE,izone,4,i1,i2)          
                 IF (index2.NE.-1) THEN
                    index1 = index2
                    ik = 1
                    ir = ir + 1
                    imap(ik,ir) = index1
                    cont = .TRUE.
                    !
                    !             jdemod
                    IF (output) then 
                       WRITE(0,*) 'OUTER SOL MAP NEW RING:',ik,ir,index1
                       WRITE(6,*) 'OUTER SOL MAP NEW RING:',ik,ir,index1
                    endif

                 ELSE
                    !...          Assume the outer boundary of the grid:
                    !
                    !             jdemod
                    IF (output) then 
                       WRITE(0,*) 'ASSUMING OUTER GRID BOUNDARY'
                       WRITE(6,*) 'ASSUMING OUTER GRID BOUNDARY'
                    endif

                 ENDIF
              ENDIF
           ENDDO

           ! Note: These should really be irtrap2, irwall2 ...


           irwall = ir
           irtrap = ir + 1
           nrs = ir

           !...    Register all knots that have been mapped to the grid: - could change this to be set as we go along
           DO ir = 1, nrs
              DO ik = 1, nks(ir)
                 knot(imap(ik,ir))%map = 1
              ENDDO
           ENDDO

           !
           !       jdemod
           IF (output) then 
              WRITE(0,*) 'PROCESSING SECONDARY PFZ'
              WRITE(6,*) 'PROCESSING SECONDARY PFZ'
           endif

           !...    Process the secondary x-point PFR, which is just considered part of the
           !       SOL for generalized grids:

           index1 = knot(index_xpt(2))%xpt

           !        i1 = ixpt(2)
           !...    Move into the PFR:
           !  Note: using vertex 2 - this cell is already in the PFR

           !CALL FindKnot(nknot,knot,NUMZONE,izone,2,i1,i2)
           !IF (i2.EQ.-1)  CALL ER('Readgeneralisedgrid','PFR2 problems',*99)
           ! But it is not at the target
           !
           !i1 = i2
           !

           !ik = 1
           !ir = nrs + 1
           !imap(ik,ir) = i1

           !...    Proceed to target:
           !
           !       jdemod
           IF (output) then 
              WRITE(0,*) 'LOOKING FOR PFR2 TARGET'
              WRITE(6,*) 'LOOKING FOR PFR2 TARGET'
           endif

           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.
              CALL FindKnot(nknot,knot,NUMZONE,izone,5,index1,index2)
              IF (index2.NE.-1) THEN 
                 index1 = index2
                 cont = .TRUE.
              ENDIF
           ENDDO


           !cont = .TRUE.
           !DO WHILE(cont)
           !   cont = .FALSE.
           !   CALL FindKnot(nknot,knot,NUMZONE,izone,5,index1,index2)
           !
           !         jdemod
           !   IF (output) then 
           !      WRITE(0,*) 'MOVING',index1,index2
           !      WRITE(6,*) 'MOVING',index1,index2
           !   endif

           !  IF (index2.NE.-1) THEN 
           !      index1 = index2
           !      ik = ik + 1
           !      imap(ik,ir) = i1
           !      cont = .TRUE.
           !   ENDIF
           !ENDDO

           !...    Target located, start mapping the secondary PFR:
           !
           !       jdemod
           IF (output) then 
              WRITE(0,*) 'PFR2 TARGET LOCATED'
              WRITE(6,*) 'PFR2 TARGET LOCATED'
           endif

           ik = 1
           ir = nrs + 1
           imap(ik,ir) = index1

           cont = .TRUE.
           DO WHILE(cont)
              cont = .FALSE.
              !...      Move along the ring:
              CALL FindKnot(nknot,knot,NUMZONE,izone,3,index1,index2)
              !
              !         jdemod
              IF (output) then 
                 WRITE(0,*) 'MOVING',index1,index2
                 WRITE(6,*) 'MOVING',index1,index2
              endif

              IF (index2.NE.-1) THEN
                 index1 = index2 
                 ik = ik + 1
                 imap(ik,ir) = index1
                 cont = .TRUE.
                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,*) '2ND PFR MAP:',ik,ir,index1,knot(index1)%zcen
                    WRITE(6,*) '2ND PFR MAP:',ik,ir,index1,knot(index1)%zcen
                 endif

              ENDIF
              !...      Step radially outward if ring is finished:
              IF (.NOT.cont) THEN
                 nks(ir) = ik
                 index1 = imap(1,ir)
                 CALL FindKnot(nknot,knot,NUMZONE,izone,2,index1,index2)          
                 IF (index2.NE.-1) THEN
                    index1 = index2
                    ik = 1
                    ir = ir + 1
                    imap(ik,ir) = index1
                    cont = .TRUE.
                    !
                    !             jdemod
                    IF (output) then  
                       WRITE(0,*) '2ND PFR MAP NEW RING:',ik,ir,index1,&
                            knot(index1)%zcen
                       WRITE(6,*) '2ND PFR MAP NEW RING:',ik,ir,index1,&
                            knot(index1)%zcen
                    endif
                    !ELSE
                    !   ...          Assume the outer boundary of the grid:
                 ENDIF
              ENDIF
           ENDDO

           !
           ! These assignments are not meaningful
           !

           irwall = ir
           irtrap = ir + 1
           nrs = ir

        ENDIF ! Done processing double-null rings





        !IF (.FALSE.) THEN   ! DEBUG
        !   nks(ir) = ik
        !   irwall = ir
        !   irtrap = ir + 1
        !   nrs = ir
        !   id = 0
        !   DO ir = 1, nrs
        !      DO ik = 1, nks(ir)        
        !         i1 = imap(ik,ir)
        !         rs(ik,ir) = knot(i1)%rcen
        !         zs(ik,ir) = knot(i1)%zcen
        !         bratio(ik,ir) = knot(i1)%bratio
        !         id = id + 1
        !         korpg(ik,ir) = id
        !         nvertp(id) = knot(i1)%nv
        !         DO i2 = 1, nvertp(id)
        !            rvertp(i2,id) = knot(i1)%rv(i2)
        !            zvertp(i2,id) = knot(i1)%zv(i2)
        !         ENDDO
        !      ENDDO
        !   ENDDO
        !   ikto = -1
        !   ikti = -1
        !   DO ik = 1, nks(irsep)
        !      IF (connected) THEN
        !         IF (imap(ik,irsep).EQ.ixpt(1)          ) ikto = ik    ! Not sure this will always work... 
        !         IF (imap(ik,irsep).EQ.knot(ixpt(2))%xpt) ikti = ik -1
        !         c            IF (imap(ik,irsep).EQ.ixpt(1)) ikto = ik - 1  ! Not sure this will always work...
        !         c            IF (imap(ik,irsep).EQ.ixpt(2)) ikti = ik     
        !      ENDIF
        !   ENDDO
        !   CALL SaveSolution
        !   CALL OutputData(86,'MAST!')
        !   title = '...'
        !   desc  = 'Call to STORE from DumpGrid'
        !   job   = 'Call to STORE from DumpGrid'
        !   equil = 'Call to STORE from DumpGrid'
        !   WRITE(0,*) 'CALLING STORE'
        !   CALL Store(title,desc,1,job,equil,facta,factb,1,1)
        !   WRITE(0,*) 'FUN WITH MAST GRIDS!'
        !   STOP
        !ENDIF


        !
        !     jdemod
        !
        IF (output) then 
           WRITE(0,*) 'PROCESSING PRIMARY PFZ'
           WRITE(6,*) 'PROCESSING PRIMARY PFZ'
        endif

        !...  Process the primary x-point PFR:
        index1 = knot(ixpt(1))%xpt
        !     This index should already be inside the PFR
        !...  Move into the PFR:
        !CALL FindKnot(nknot,knot,NUMZONE,izone,2,i1,i2)
        !
        !IF (i2.EQ.-1) &
        !  CALL ER('Readgeneralisedgrid','PFR1 problems',*99)
        !
        !     jdemod
        IF (output) then
           WRITE(0,*) '  IN PRIMARY PFZ',knot(index1)%index
           WRITE(6,*) '  IN PRIMARY PFZ',knot(index1)%index
        endif

        !i1 = i2
        !...  Proceed to target:
        cont = .TRUE.
        DO WHILE(cont)
           cont = .FALSE.
           CALL FindKnot(nknot,knot,NUMZONE,izone,5,index1,index2)
           !        jdemod
           !IF (output) then 
           !   WRITE(0,*) '  TO TARGET',index1,index2
           !   WRITE(0,*) '  TO TARGET',knot(index1)%index
           !   WRITE(0,*) '  TO TARGET',knot(index2)%index
           !   WRITE(6,*) '  TO TARGET',index1,index2
           !   WRITE(6,*) '  TO TARGET',knot(index1)%index
           !   WRITE(6,*) '  TO TARGET',knot(index2)%index
           !endif

           IF (index2.NE.-1) THEN 
              index1 = index2
              cont = .TRUE.
           ENDIF
        ENDDO
        !...  Target located, start mapping the primary PFR:
        !     
        !     jdemod
        IF (output) then 
           WRITE(0,*) 'PROCESSING PRIMARY PFZ, TARGET LOCATED'
           WRITE(6,*) 'PROCESSING PRIMARY PFZ, TARGET LOCATED'
        endif

        ! record the last ring before processing the primary PFZ since the rings in the
        ! primary pfz need to be reordered to place the nrs ring adjacent to the separatrix
        ! this requirement may change
        first_pfr_ring=nrs+1

        ik = 1
        ir = nrs + 1
        imap(ik,ir) = index1
        cont = .TRUE.
        DO WHILE(cont)
           cont = .FALSE.
           !...    Move along the ring:
           CALL FindKnot(nknot,knot,NUMZONE,izone,3,index1,index2)
           IF (index2.NE.-1) THEN
              index1 = index2 
              ik = ik + 1
              imap(ik,ir) = index1
              cont = .TRUE.
              !          jdemod
                        IF (output) then 
                           WRITE(0,*) '1ST PFR MAP:',ik,ir,index1,knot(index1)%zcen
                           WRITE(6,*) '1ST PFR MAP:',ik,ir,index1,knot(index1)%zcen
                        endif

           ENDIF
           !...    Step "inward" (in PFR->wall) if ring is finished:
           IF (.NOT.cont) THEN
              nks(ir) = ik
              index1 = imap(1,ir)
              CALL FindKnot(nknot,knot,NUMZONE,izone,2,index1,index2)          
              IF (index2.NE.-1) THEN
                 index1 = index2
                 ik = 1
                 ir = ir + 1
                 imap(ik,ir) = index1
                 cont = .TRUE.
                 !
                 !           jdemod
                 IF (output) then 
                    WRITE(0,'(a,4i6,5(1x,g12.5))') 'PRIM PFZ MAP:',&
                                ik,ir,index1,imap(1,ir),&
                                knot(index1)%rcen,knot(index1)%zcen
                    WRITE(6,'(a,4i6,5(1x,g12.5))') 'PRIM PFZ MAP:',&
                                ik,ir,index1,imap(1,ir),&
                                knot(index1)%rcen,knot(index1)%zcen
                 endif

              !ELSE
              !   ...        Assume the outer boundary of the grid:
              ENDIF
              !         jdemod
              !IF (output) then 
              !   WRITE(0,*) 'PROCESSING PRIMARY PFZ, BUZZING...'
              !   WRITE(6,*) 'PROCESSING PRIMARY PFZ, BUZZING...'
              !endif

           ENDIF
        ENDDO

        nrs = ir

        !...  Need to reorder the rings in the primary PFZ:
        ! jde - have to look into removing this requirement - it should not matter that the ring
        !       next to the separatrix in the PFZ is ring NRS but it may be hard coded in a number 
        !       of places - most specifically when calculating the walls and targets. 
        ! 
        ! reorganize by adjusting imap - swapping ring data in primary pfz
        !

        DO in = 0, (nrs-first_pfr_ring+1)/2-1
           !
           !       jdemod
           IF (output) then
              WRITE(0,*) 'SWAP RINGS=',in,first_pfr_ring+in,nrs-in
              WRITE(0,*) 'SWAP RINGS=',in,first_pfr_ring+in,nrs-in
           endif

           tmpnks = nks(first_pfr_ring+in)
           DO ik = 1, nks(first_pfr_ring+in)
              imap(ik,0) = imap(ik,first_pfr_ring+in)
           ENDDO

           nks(first_pfr_ring+in) = nks(nrs-in)
           DO ik = 1, nks(nrs-in)
              imap(ik,first_pfr_ring+in) = imap(ik,nrs-in)
           ENDDO

           nks(nrs-in) = tmpnks
           DO ik = 1, tmpnks
              imap(ik,nrs-in) = imap(ik,0)
           ENDDO
        ENDDO


        !...  Put grid together:
        !     jdemod
        IF (output) then 
           WRITE(0,*) 'PUTTING GRID TOGETHER'
           WRITE(6,*) 'PUTTING GRID TOGETHER'
        endif

        call assign_global_geometry_data(gridunit)

        return

97      CALL ER('Readgeneralisedgrid','Unexpected end-of-file',*99)
98      CALL ER('Readgeneralisedgrid','Problem accessing grid file',*99)
99      WRITE(0,*) 'IXPT:',ixpt(1),ixpt(2)
        STOP  
      END SUBROUTINE ReadGeneralisedGrid


      SUBROUTINE FindKnot(nknot,knot,NUMZONE,izone,condition,index1,index2)
        use global_parameters
        IMPLICIT none
        !
        !     Inputs:
        !     nknot - number of knots in knot/cell array
        !     knot  - array of knots/cells
        !     NUMZONE - number of zones for making search faster
        !     izone - zone index array (NUMZONE+1,NUMZONE) - each zone runs from the cells
        !             listed in the izone arrays cell_start=izone(ir,iz) to cell_end=izone(ir+1,iz)-1
        !     condition - search condition to be met by target cell
        !     index1    - index of initial cell
        !     index2    - index of matching cell (OUTPUT)
        !
        !     jdemod
        !
        !     Condition=1 finds two different knots which have the same 
        !                 R,Z values for knot number 1. This condition
        !                 should only occur at an Xpoint for two cells in the 
        !                 inner/outer SOL
        !
        !     NOTE: The cells sharing vertex 1 or 4 will be in the inner and outer SOL
        !           The cells sharing vertex 2 or 3 will be in the core and PFZ
        !
        !           There seems to be a bug in the code when finding the innermost
        !           core ring - using vertex 1 finds a cell in the main SOL adjacent
        !           to the core. Stepping inward will usually work if the cell 
        !           next to the core is chosen - however, if the separatrix is unusual
        !           it could be that the Z coordinate of the cell adjacent to the PFZ
        !           will be closer to the center of the plasma and thus the wrong cell
        !           will be chosen to find the center of the grid. In order to fix this, 
        !           the test vertex for the XPoint should be set to 2 or 3 so that 
        !           cells inside and outside the core are chosen - more clearly above 
        !           and below the Xpoints. I'll have to check and see if this has an
        !           impact on the calculations for double null grids. 
        !
        !
        !     Condition=2 finds knot 1=2 and knot 4=3 for test cell vs. other cells
        !
        !     Condition=3 finds knot 3=2 and knot 4=1 for test cell vs. other cells
        !
        !     Condition=4 finds knot 2=1 and knot 3=4 for test cell vs. other cells
        !
        !     Condition=5 finds knot 1=4 and knot 2=3 for test cell vs. other cells
        !
        !     Condition=6 finds two different knots which have the same 
        !                 R,Z values for knot number 2. This condition
        !                 should only occur at an Xpoint for two cells - one in core/one in pfz
        !
        !     Condition=7 finds knot 1=4 bit no other knots matching - 
        !                 for detection of limiter tip in limiter geometries
        !                 Only used after no Xpoints are found
        !

        INTEGER,intent(in) ::  nknot,index1,NUMZONE,izone(NUMZONE+1,NUMZONE),condition
        integer,intent(out) :: index2
        TYPE(type_cell),intent(in) :: knot(0:nknot)      

        REAL*8, PARAMETER :: DTOL=1.0D-06


        integer :: i1,i2,r1,z1   ! local variables - index and zone 

        !
        !     jdemod - Logical for debugging
        !
        logical :: output
        !
        output = .false.

        i1 = index1

        ! initialize output to -1 
        index2 = -1

        !
        ! Exit if data is requested for an ignored cell - this shouldn't happen
        !
        if (knot(index1)%ignore) then 
           write(0,*) 'ERROR: FINDKNOT: Data requested for ignored cell:', index1
           return
        endif

        if (condition.ne.1.and.output) then 

           write(6,'(a,100i8)') 'FINDKNOT1:',nknot,NUMZONE,condition,index1,index2
           !write(6,'(a,100i8)') 'FINDKNOT2:',izone

           write(0,'(a,100i8)') 'FINDKNOT1:',nknot,NUMZONE,condition,index1,index2
           !write(0,'(a,100i8)') 'FINDKNOT:',izone

        endif

        !
        ! Loop through adjacent zones to save searching the entire grid all the time - this will 
        ! only fail for large cells whose vertices might span multiple zone - possibly include full
        ! grid fall back search? Leave out for now since end of ring conditions and wall conditions are
        ! detected by no cells satisfying the search criteria
        !
        DO z1 = knot(i1)%zzone-1, knot(i1)%zzone+1
           IF (z1.LT.1.OR.z1.GT.NUMZONE) CYCLE
           DO r1 = knot(i1)%rzone-1, knot(i1)%rzone+1
              IF (r1.LT.1.OR.r1.GT.NUMZONE) CYCLE  

              ! search cell index loop
              DO i2 = izone(r1,z1), izone(r1+1,z1)-1

                 if (output) then 
                    write(6,'(a,15i8)') 'IZONE:',i1,z1,r1,i2,izone(r1,z1),izone(r1+1,z1)-1
                 endif

                 IF (i1.EQ.i2) CYCLE

                 ! bypass ignored cells
                 if (knot(i2)%ignore) cycle

                 IF     (condition.EQ.1.AND.ABS(knot(i1)%rv(1)-knot(i2)%rv(1)).LT.DTOL.AND.&
                                          & ABS(knot(i1)%zv(1)-knot(i2)%zv(1)).LT.DTOL) THEN
                 ! checking for a match to cell vertex 1 

                    IF (sloutput) WRITE(0,*) 'XPOINT SOL:',i1,i2
                    if (output) then
                       WRITE(0,*) 'XPOINT SOL:',i1,i2
                       WRITE(6,*) 'XPOINT SOL:',i1,i2
                    endif

                    index2 = i2
                    RETURN

                 ELSEIF (condition.EQ.2.AND.&
                      ABS(knot(i1)%rv(1)-knot(i2)%rv(2)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(1)-knot(i2)%zv(2)).LT.DTOL.AND.&
                      ABS(knot(i1)%rv(4)-knot(i2)%rv(3)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(4)-knot(i2)%zv(3)).LT.DTOL) THEN
                    ! checking for vertex 1=2 and 4=3 - match to inward side 41 of current cell

                    if (output) then 
                       WRITE(0,*) 'SIDE INWARD 41:',i1,i2
                       WRITE(6,*) 'SIDE INWARD 41:',i1,i2
                    endif

                    index2 = i2
                    RETURN


                 ELSEIF (condition.EQ.3.AND.&
                      ABS(knot(i1)%rv(3)-knot(i2)%rv(2)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(3)-knot(i2)%zv(2)).LT.DTOL.AND.&
                      ABS(knot(i1)%rv(4)-knot(i2)%rv(1)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(4)-knot(i2)%zv(1)).LT.DTOL) THEN
                     ! checking for vertex 3=2 and 4=1 - match to upward side 34 of current cell

                    if (output) then 
                       WRITE(0,*) 'SIDE UP 34:',i1,i2
                       WRITE(6,*) 'SIDE UP 34:',i1,i2
                    endif

                    index2 = i2
                    RETURN


                 ELSEIF (condition.EQ.4.AND.&
                      ABS(knot(i1)%rv(2)-knot(i2)%rv(1)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(2)-knot(i2)%zv(1)).LT.DTOL.AND.&
                      ABS(knot(i1)%rv(3)-knot(i2)%rv(4)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(3)-knot(i2)%zv(4)).LT.DTOL) THEN
                    ! checking for vertex 2=1 and 3=4 - match to outward side 23 of current cell


                    if (output) then 
                       WRITE(0,*) 'SIDE OUTWARD 23:',i1,i2
                       WRITE(6,*) 'SIDE OUTWARD 23:',i1,i2
                    endif

                    index2 = i2
                    RETURN

                 ELSEIF (condition.EQ.5.AND.&
                      ABS(knot(i1)%rv(1)-knot(i2)%rv(4)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(1)-knot(i2)%zv(4)).LT.DTOL.AND.&
                      ABS(knot(i1)%rv(2)-knot(i2)%rv(3)).LT.DTOL.AND.&
                      ABS(knot(i1)%zv(2)-knot(i2)%zv(3)).LT.DTOL) THEN
                    ! checking for vertex 1=4 and 2=3 - match to downward side 12 of current cell

                    if (output) then
                       WRITE(0,*) 'SIDE DOWN 12:',i1,i2
                       WRITE(6,*) 'SIDE DOWN 12:',i1,i2
                    endif

                    index2 = i2
                    RETURN


                    !
                 ELSEIF     (condition.EQ.6.AND.&
                                  ABS(knot(i1)%rv(2)-knot(i2)%rv(2)).LT.DTOL.AND.&
                                  ABS(knot(i1)%zv(2)-knot(i2)%zv(2)).LT.DTOL) THEN
                    !     jdemod - Add vertex 2 for Xpoint detection for core rings so that the cells found
                    !              will be clearly above and below the Xpoint
                    !
                    ! checking for a match to cell vertex 2.

                    IF (sloutput) WRITE(0,*) 'XPOINT CORE/PFZ:',i1,i2
                    if (output) then
                       WRITE(0,*) 'XPOINT CORE/PFZ:',i1,i2
                       WRITE(6,*) 'XPOINT CORE/PFZ:',i1,i2
                    endif

                    index2 = i2
                    RETURN


                 ELSEIF     (condition.EQ.7.AND.&
                                  ABS(knot(i1)%rv(1)-knot(i2)%rv(4)).LT.DTOL.AND.&
                                  ABS(knot(i1)%zv(1)-knot(i2)%zv(4)).LT.DTOL.and.&
                                  abs(knot(i1)%rv(2)-knot(i2)%rv(3)).gt.dtol.and.&
                                  abs(knot(i1)%zv(2)-knot(i2)%zv(3)).gt.dtol)  THEN

                    ! checking for vertex 1 = vertex 4 but vertex 2 not equal to vertex 3
                    ! - useful for limiter tip detection after Xpoint grid has been
                    ! elimitated

                    IF (sloutput) WRITE(0,*) 'XPOINT CORE/PFZ:',i1,i2
                    if (output) then
                       WRITE(0,*) 'XPOINT CORE/PFZ:',i1,i2
                       WRITE(6,*) 'XPOINT CORE/PFZ:',i1,i2
                    endif

                    index2 = i2
                    RETURN

                 ENDIF

              ENDDO
           ENDDO
        ENDDO

      END SUBROUTINE FindKnot



      SUBROUTINE MoveKnot(knot1,knot2)
        IMPLICIT none

        TYPE(type_cell) :: knot1,knot2      

        INTEGER i1

        knot2%index  = knot1%index
        knot2%ik     = knot1%ik
        knot2%ir     = knot1%ir
        knot2%nv     = knot1%nv
        knot2%rzone  = knot1%rzone
        knot2%zzone  = knot1%zzone
        knot2%xpt    = knot1%xpt
        knot2%map    = knot1%map

        knot2%rcen   = knot1%rcen
        knot2%zcen   = knot1%zcen
        knot2%bratio = knot1%bratio
        DO i1 = 1, knot1%nv
           knot2%rv(i1) = knot1%rv(i1)
           knot2%zv(i1) = knot1%zv(i1)
        ENDDO

        knot2%area = knot1%area
        knot2%vol = knot1%vol
        knot2%ignore = knot1%ignore

      END SUBROUTINE MoveKnot



      subroutine assign_global_geometry_data(gridunit,maxnrs,maxnks,connected)
        use mod_cgeom
        implicit none
        integer :: gridunit,maxnrs,maxnks
        logical :: connected
        


        integer :: id,ir,ik,iv
        integer :: index1

        CALL ALLOC_SONNET_INDEX_GRID(MAXNKS,MAXNRS)

        id = 0
        DO ir = 1, nrs
           DO ik = 1, nks(ir)        
              index1 = imap(ik,ir)
              rs(ik,ir) = knot(index1)%rcen
              zs(ik,ir) = knot(index1)%zcen
              bratio(ik,ir) = knot(index1)%bratio
              id = id + 1
              korpg(ik,ir) = id
              nvertp(id) = knot(index1)%nv
              DO iv = 1, nvertp(id)
                 rvertp(i2,id) = knot(index1)%rv(iv)
                 zvertp(i2,id) = knot(index1)%zv(iv)
              ENDDO
              !...      Store these in case B2 data from Rhozansky is being loaded:
              sonnetik(ik,ir) = knot(index1)%ik 
              sonnetir(ik,ir) = knot(index1)%ir
           ENDDO
        ENDDO

        !...  Set NPOLYP: 0 
        npolyp  = id
        vpolmin = (MAXNKS*MAXNRS - npolyp) / 2 + npolyp
        vpolyp  = vpolmin

        !...  Find IKTO,IKTI:
        !     Need to check into the generality of these
        ikto = -1
        ikti = -1

        DO ik = 1, nks(irsep)
           IF (connected) THEN
              IF (imap(ik,irsep).EQ.index_xpt(1)     ) ikto = ik    ! Not sure this will always work..
              IF (imap(ik,irsep).EQ.knot(iindex_xpt(2))%xpt) ikti = ik - 1
              !          IF (imap(ik,irsep).EQ.index_xpt(1)) ikto = ik      ! Not sure this will always work...
              !          IF (imap(ik,irsep).EQ.index_xpt(2)) ikti = ik - 1
              !          IF (imap(ik,irsep).EQ.knot(index_xpt(2))%xpt) ikti = ik - 1  ! Not sure this will always work...
           ELSE
              IF (imap(ik,irsep).EQ.index_xpt(1)          ) ikto = ik - 1
              IF (imap(ik,irsep).EQ.knot(index_xpt(1))%xpt) ikti = ik 
           ENDIF
        ENDDO


        IF (ikto.EQ.-1.OR.ikti.EQ.-1)   CALL ER('Readgeneralisedgrid','IKTI or IKTO not found',*99)

        !...  Add virtual rings 1 (core boundary), IRWALL (SOL) and IRTRAP (PFZ):
        !     Need to adjust these to work on the grid in this module
        !
        CALL InsertRing(1,BEFORE,PERMANENT)
        CALL InsertRing(nrs-irsep+2,AFTER,PERMANENT)
        CALL InsertRing(nrs-irsep+3,BEFORE,PERMANENT)

        !     CUTPT1
        !     CUTPT2
        !     MAXKPTS
        !     MAXRINGS
        !     CUTRING
        !
        nopriv = .FALSE.

        !cutpt1 = ikto
        !cutpt2 = ikti             ! These are semi-bogus for a connected double-null...?
        !cutring = irsep - 1
        !maxkpts = nks(irsep)
        !maxrings = irwall
        !indexiradj = 1

        !...TMP
        !      ik = 1
        !      ir = nrs + 1
        !      nks(ir) = 1 
        !      imap(ik,ir) = i2
        !      irwall = ir
        !      irtrap = ir + 1
        !      nrs = ir 
        !      WRITE(0,*) 'i2:',i2,knot(i2)%map

        !IF (.NOT..TRUE.) THEN
        !   c        id = 0
        !   c        DO ir = 1, nrs
        !   c          DO ik = 1, nks(ir)        
        !   c            i1 = imap(ik,ir)
        !   c            rs(ik,ir) = knot(i1)%rcen
        !   c            zs(ik,ir) = knot(i1)%zcen
        !   c            bratio(ik,ir) = knot(i1)%bratio
        !   c            id = id + 1
        !   c            korpg(ik,ir) = id
        !   c            nvertp(id) = knot(i1)%nv
        !   c            DO i2 = 1, nvertp(id)
        !   c              rvertp(i2,id) = knot(i1)%rv(i2)
        !   c              zvertp(i2,id) = knot(i1)%zv(i2)
        !   c            ENDDO
        !   c          ENDDO
        !   c        ENDDO
        !   CALL SaveSolution
        !   CALL OutputData(86,'MAST!')
        !   title = '...'
        !   desc  = 'Call to STORE from DumpGrid'
        !   job   = 'Call to STORE from DumpGrid'
        !   equil = 'Call to STORE from DumpGrid'
        !   WRITE(0,*) 'CALLING STORE'
        !   CALL Store(title,desc,1,job,equil,facta,factb,1,1)
        !   WRITE(0,*) 'FUN WITH MAST GRIDS!'
        !   STOP
        !ENDIF

        
        call readpsi



        !DEALLOCATE(knot)
        !DEALLOCATE(imap)

        !      IF (nrs.EQ.60) THEN
        !        WRITE(0,*)
        !        WRITE(0,*) '--------------------------------------------------'
        !        WRITE(0,*) 'HARDCODING IRSEP2 = 30 (FOR IR = 60) '
        !        WRITE(0,*) '--------------------------------------------------'
        !        WRITE(0,*)
        !        irsep2 = 35
        !      ENDIF

        !...  For consistency with original SONNET code in tau.d6a:
        ir = maxrings
        ik = maxkpts

        RETURN

99      write(0,*) 'Assign_global_geometry_data: ERROR ENCOUNTERED'
        stop


      end subroutine assign_global_geometry_data



        subroutine readpsi

        !...  Add virtual boundary cells, which will be stripped off later:
        !IF (ctargopt.EQ.0.OR.ctargopt.EQ.1.OR.ctargopt.EQ.2.OR.ctargopt.EQ.3.OR.ctargopt.EQ.6)  CALL AddPoloidalBoundaryCells      

        !...  Look for PSIn data for full double null grids (code mostly 
        !     from tau.d6a):
        !READ(gridunit,'(A)',END=25) buffer

        !IF (buffer(1:16).EQ.'PSI-DOUBLE-NULLd') THEN   ! direct assignment to each ring, post mortem...
        !   READ(buffer(17:),*) numpsi
           !...    The PSI values are to be loaded in TailorGrid...glorious hack!
        !   DO i1 = 1, numpsi
        !      READ(gridunit,*,END=97)
        !   ENDDO
        !ELSEIF (buffer(1:15).EQ.'PSI-DOUBLE-NULL') THEN
        !   READ(buffer(16:),*) numpsi
        !   !...    The PSI values are listed with one on each line
        !   !       indexed by knot and ring index based on the SONNET 
        !   !       grid coordinates:
        !   DO i1 = 1, numpsi
        !      READ(gridunit,*,END=97) ikpsi(i1),irpsi(i1),valpsi(i1)
        !   ENDDO
        !   !...    Assign to grid rings:
        !   DO ir = 2, irwall-1
        !      !...      (Need the "-1" because a virtual core ring has been added to the grid)
        !      ir1 = knot(imap(1,ir-1))%ir 
        !      DO i1 = 1, numpsi
        !         IF (irpsi(i1).EQ.ir1) EXIT
        !      ENDDO
        !      IF (i1.EQ.numpsi+1)    CALL ER('Readgeneralisedgrid','Problem with PSIn',*99)
        !      !          WRITE(0,*) '--',ir,valpsi(i1)
        !      psitarg(ir,1) = valpsi(i1)
        !      psitarg(ir,2) = valpsi(i1)
        !      IF (ir.LT.irsep) THEN
        !         psitarg(ir-1+irtrap,1) = valpsi(i1)
        !         psitarg(ir-1+irtrap,2) = valpsi(i1)
        !      ENDIF
        !   ENDDO
        !   WRITE(0,*)
        !   WRITE(0,*) '--------------------------------------------------'
        !   WRITE(0,*) 'BOGUS PSITARG -- ALSO USING INNER TARGET DATA ONLY'
        !   WRITE(0,*) '--------------------------------------------------'
        !   WRITE(0,*)
        !ELSE
        !   BACKSPACE gridunit
        !ENDIF
!25      CONTINUE

      end subroutine readpsi





      SUBROUTINE ALLOC_SONNET_INDEX_GRID(MAXNKS,MAXNRS)
        INTEGER, INTENT(IN) :: MAXNKS,MAXNRS
        !     INTEGER, INTENT(IN) :: nrs,nks(nrs)
        !     INTEGER :: maxnks,ir
        IF (ALLOCATED(sonnetik)) THEN
           WRITE(0,*) 'ERROR MOD_GRID: Grid arrays already allocated'
           WRITE(0,*) 'HALTING CODE'
           STOP
        ELSE
           !     maxnks = 0                   ! Find shorthand way of doing this... 
           !     DO ir = 1, nrs
           !     maxnks = MAX(maxnks,nks(ir))
           !     ENDDO
           !     ALLOCATE(sonnetik(maxnks,nrs+3))       
           !     ALLOCATE(sonnetir(maxnks,nrs+3))      
           ALLOCATE(sonnetik(MAXNKS,MAXNRS))
           ALLOCATE(sonnetir(MAXNKS,MAXNRS))      
        ENDIF
        RETURN
      END SUBROUTINE ALLOC_SONNET_INDEX_GRID


      SUBROUTINE DEALLOC_SONNET_INDEX_GRID
        IF (ALLOCATED(sonnetik)) THEN
           DEALLOCATE(sonnetik)       
           DEALLOCATE(sonnetir)       
        ENDIF
        RETURN
      END SUBROUTINE DEALLOC_SONNET_INDEX_GRID

      




    END MODULE mod_grid
