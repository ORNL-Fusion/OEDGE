c     Krieger IPP 2012 - fixed INTEL name conflict: ranf->ranf_eirene
C
C
C        **************
C        *            *
C        * STATISTICS *
C        *            *
C        **************
C
C       SUBROUTINE STATIS
C       SUBROUTINE COVAR
C       SUBROUTINE FGAUSS
C       SUBROUTINE FMAXWL
C       SUBROUTINE FCOSIN
C       SUBROUTINE FISOTR
C       FUNCTION THOMP(UB,EMAX)
C
C
C
C
      SUBROUTINE STATIS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CUPD'
      INCLUDE 'CCONA'
      INCLUDE 'COMUSR'
      INCLUDE 'COUTAU'
      INCLUDE 'CLOGAU'
      INCLUDE 'CGRID'
      INCLUDE 'CSDVI'
      INCLUDE 'CESTIM'
      INCLUDE 'CSPEI'
      DIMENSION
     .  STV(NSD,NRAD),STVW(NSDW,NLIMPS),
     .  STVS(NSD),STVWS(NSDW),
     .  STVC(0:2,NCV,NRAD),
     .  STVCS(0:2,NCV)
      DIMENSION
     .  SDVIA (NSD,NRAD),    EE(NSD,NRAD),    EES(NSD),
     .  SDVIAW(NSDW,NLIMPS), FF(NSDW,NLIMPS), FFS(NSDW),
     .  SDVIAC(2,NCV,NRAD)
      DIMENSION ESTIM1(NESTM1),ESTIM2(NESTM2)
      DIMENSION VECTOR(NRAD)
      DIMENSION VECTRC(2,NRAD)
      DIMENSION IADD(NSD),    IGFF(NSD),
     .          IADDW(NSDW),  IGFFW(NSDW),
     .          IADDC(2,NCV), IGFFC(2,NCV)
      DIMENSION IND(NRAD,8),IIND(NRAD),INDSS(NRAD,8)
      DIMENSION SD(0:NRAD),SDC(2,0:NRAD)
      LOGICAL LP,LT
C
      EQUIVALENCE
     .(RWK(1+NESTIM*NSMSTRA                         ),STV(1,1)),
     .(RWK(1+NESTIM*NSMSTRA+NSD* NRAD               ),STVW(1,1)),
     .(RWK(1+NESTIM*NSMSTRA+NSD* NRAD   +NSDW*NLIMPS),STVS(1)),
     .(RWK(1+NESTIM*NSMSTRA+NSD*(NRAD+1)+NSDW*NLIMPS),STVWS(1))
C
      EQUIVALENCE
     . (RWK(NID3P                                        ),EE(1,1)),
     . (RWK(NID3P+NSD* NRAD                              ),FF(1,1)),
     . (RWK(NID3P+NSD* NRAD   +NSDW* NLIMPS   +2*NCV*NRAD),EES(1)),
     . (RWK(NID3P+NSD*(NRAD+1)+NSDW* NLIMPS   +2*NCV*NRAD),FFS(1))
      PARAMETER(NNID3=
     .          NID3+NSD*(NRAD+1)+NSDW*(NLIMPS+1)+2*NCV*(NRAD+1))
C
      EQUIVALENCE
     . (RWK(NNID3+1                     ),SDVIA(1,1)),
     . (RWK(NNID3+1+NSD*NRAD            ),SDVIAW(1,1)),
     . (RWK(NNID3+1+NSD*NRAD+NSDW*NLIMPS),SDVIAC(1,1,1))
C
      EQUIVALENCE (ESTIM1(1),PDENA(1,1))
      EQUIVALENCE (ESTIM2(1),POTAT(1,1))
C
      SAVE
C
      ENTRY STATS0

      IMETCL = 0
      NCLMT = 0
      LMETSP = .FALSE.

      IF (NSIGI.EQ.0) RETURN
C
      CALL INDTAL(IND,NRAD,NR1ST,NP2ND,NT3RD,NBMLT)
      DO IR=1,NSBOX
        IIND(IR)=0
        IIN=0
        DO J=1,8
          IF (IND(IR,J).NE.0) THEN
            IIND(IR)=IIND(IR)+1
            IIN=IIN+1
            INDSS(IR,IIN)=J
          ENDIF
        ENDDO
      ENDDO
C
      DO 101 J=1,NSIGVI
        IGFF(J)=NFIRST(IIH(J))
        IADD(J)=NADDV(IIH(J))*NRAD
101   CONTINUE
C
      DO 102 J=1,NSIGCI
        IGFFC(1,J)=NFIRST(IIHC(1,J))
        IGFFC(2,J)=NFIRST(IIHC(2,J))
        IADDC(1,J)=NADDV(IIHC(1,J))*NRAD
        IADDC(2,J)=NADDV(IIHC(2,J))*NRAD
102   CONTINUE
C
      DO 108 J=1,NSIGSI
        IGFFW(J)=NFRSTW(IIHW(J))
        IADDW(J)=NADDW(IIHW(J))*NLMPGS
108   CONTINUE
C
      RETURN
C
      ENTRY STATS1(NBIN,NRIN,NPIN,NTIN,NSIN,LP,LT)
C
      NSB=NBIN
      NR1=NRIN
      NP2=NPIN
      NT3=NTIN
      NRW=NSIN

      IF ((NSIGVI > 0) .OR. (NSIGCI > 0)) THEN
       NCLMTS = NCLMT
       DO I=1,NCLMT
         IR = ICLMT(I)
         DO IIN=2,IIND(IR)
           J=INDSS(IR,IIN)
           IRU=IND(IR,J)
           IF (IMETCL(IRU) == 0) THEN
             NCLMTS = NCLMTS+1
             IMETCL(IRU) = NCLMTS
             ICLMT(NCLMTS) = IRU
           END IF
         END DO
       END DO
      END IF
C
C
      IF (NSIGVI.EQ.0) GOTO 1020
C
      DO 1012 IC=1,NSIGVI
        INP=IADD(IC)
        IGF=IGFF(IC)
        IGS=IGH(IC)
        ITL=IIH(IC)
        IF (NSPAN(ITL) == 0) THEN
          ISCO = 1
        ELSE
          ISCO = 0
          IF (IGS == 0) THEN
            IF ( ANY(LMETSP(NSPAN(ITL):NSPEN(ITL))) ) ISCO = 1
          ELSE
            IF (LMETSP(NSPAN(ITL)+IGS-1)) ISCO = 1
          END IF
        END IF
        IF (ISCO == 0) GOTO 1012
C
        IF (.NOT.LP.AND..NOT.LT) GOTO 1005
        IF (IGS.LE.0) THEN
          IGI=1
          IGE=IGF
        ELSE
          IGI=IGS
          IGE=IGS
        ENDIF
        IF (LP) THEN
          NSYM=NP2
          NSYH=(NSYM-1)/2
          DO 1003 IG=IGI,IGE
          DO 1003 IR=1,NR1
          DO 1003 IT=1,NT3
          DO 1003 IP=1,NSYH
                J1=IR+((IT-1)*NP2+IP-1)*NR1
                J2=IR+((IT-1)*NP2+NSYM-IP-1)*NR1
                INDEX1=INP+(J1-1)*IGF+IG
                INDEX2=INP+(J2-1)*IGF+IG
                SAV=(ESTIM1(INDEX1)+ESTIM1(INDEX2))*0.5
                ESTIM1(INDEX1)=SAV
                ESTIM1(INDEX2)=SAV
1003      CONTINUE
        ENDIF
        IF (LT) THEN
          NSYM=NT3
          NSYH=(NSYM-1)/2
          DO 1004 IG=IGI,IGE
          DO 1004 IR=1,NR1
          DO 1004 IP=1,NP2
          DO 1004 IT=1,NSYH
                J1=IR+((IT-1)*NP2+IP-1)*NR1
                J2=IR+((NSYM-IT-1)*NP2+IP-1)*NR1
                INDEX1=INP+(J1-1)*IGF+IG
                INDEX2=INP+(J2-1)*IGF+IG
                SAV=(ESTIM1(INDEX1)+ESTIM1(INDEX2))*0.5
                ESTIM1(INDEX1)=SAV
                ESTIM1(INDEX2)=SAV
1004      CONTINUE
        ENDIF
1005    CONTINUE
C
        IF (IGS.NE.0) THEN
           DO ICO = 1,NCLMT
             IR = ICLMT(ICO)
             INDX=INP+(IR-1)*IGF+IGS
             VECTOR(ICO)=ESTIM1(INDX)
           END DO
        ELSE
          DO 1014 ICO=1,NCLMT
            VECTOR(ICO)=0.
1014      CONTINUE
          DO 1015 IS=1,IGF
          DO 1015 ICO=1,NCLMT
            IR = ICLMT(ICO)
            INDX=INP+(IR-1)*IGF+IS
            VECTOR(ICO)=VECTOR(ICO)+ESTIM1(INDX)
1015      CONTINUE
        ENDIF

        SD1S = 0.D0
        SD = 0.D0
        DO ICO = 1,NCLMT
          IR = ICLMT(ICO)
          SD1 = VECTOR(ICO)-SDVIA(IC,IR)
          SD1S=SD1S+SD1
          SDVIA(IC,IR)=VECTOR(ICO)
          SD(IR) = SD1
          DO IIN=2,IIND(IR)
            J=INDSS(IR,IIN)
            IRU=IND(IR,J)
            SD(IRU)=SD(IRU)+SD1
          END DO
        END DO

        DO ICO = 1,NCLMTS
          IR = ICLMT(ICO)
!         IMETCL(IR) = 0
          SD1=SD(IR)
          SIGMA(IC,IR)=SIGMA(IC,IR)+SD1*SD1
        END DO
        SGMS(IC)=SGMS(IC)+SD1S*SD1S
1012  CONTINUE
C
C
1020  CONTINUE
      IF (NSIGSI.EQ.0) GOTO 1030
      DO 1022 IC=1,NSIGSI
        INP=IADDW(IC)
        IGF=IGFFW(IC)
        IGS=IGHW(IC)
        IF (IGS.NE.0) THEN
          DO 1023 IR=1,NRW
            INDX=INP+(IR-1)*IGF+IGS
            VECTOR(IR)=ESTIM2(INDX)
1023      CONTINUE
        ELSE
          DO 1024 IR=1,NRW
            VECTOR(IR)=0.
1024      CONTINUE
          DO 1025 IS=1,IGF
          DO 1025 IR=1,NRW
            INDX=INP+(IR-1)*IGF+IS
            VECTOR(IR)=VECTOR(IR)+ESTIM2(INDX)
1025      CONTINUE
        ENDIF
C
        SD1S=0.
        DO 1021 IR=1,NRW
          SD1=VECTOR(IR)-SDVIAW(IC,IR)
          SD1S=SD1S+SD1
          SIGMAW(IC,IR)=SIGMAW(IC,IR)+SD1*SD1
          SDVIAW(IC,IR)=VECTOR(IR)
1021    CONTINUE
        SGMWS(IC)=SGMWS(IC)+SD1S*SD1S
1022  CONTINUE
C
1030  CONTINUE
C
      IF (NSIGCI.EQ.0) GOTO 1050
C
      DO 1032 IC=1,NSIGCI
        ITL1=IIHC(1,IC)
        ITL2=IIHC(2,IC)
        IF (NSPAN(ITL1) == 0) THEN
          ISCO1 = 1
        ELSE
          ISCO1 = 0
          IF (IGHC(1,IC) == 0) THEN
            IF ( ANY(LMETSP(NSPAN(ITL1):NSPEN(ITL1))) ) ISCO1 = 1
          ELSE
            IF (LMETSP(NSPAN(ITL1)+IGHC(1,IC)-1)) ISCO1 = 1
          END IF
        END IF
        IF (NSPAN(ITL2) == 0) THEN
          ISCO2 = 1
        ELSE
          ISCO2 = 0
          IF (IGHC(2,IC) == 0) THEN
            IF ( ANY(LMETSP(NSPAN(ITL2):NSPEN(ITL2))) ) ISCO2 = 1
          ELSE
            IF (LMETSP(NSPAN(ITL2)+IGHC(2,IC)-1)) ISCO2 = 1
          END IF
        END IF
        IF (ISCO1+ISCO2 == 0) GOTO 1032
C
        DO 1037 I=1,2
          INP=IADDC(I,IC)
          IGF=IGFFC(I,IC)
          IGS=IGHC(I,IC)
C
          IF (.NOT.LP.AND..NOT.LT) GOTO 1035
          IF (IGS.LE.0) THEN
            IGI=1
            IGE=IGF
          ELSE
            IGI=IGS
            IGE=IGS
          ENDIF
          IF (LP) THEN
            NSYM=NP2
            NSYH=(NSYM-1)/2
            DO 1033 IG=IGI,IGE
            DO 1033 IR=1,NR1
            DO 1033 IT=1,NT3
            DO 1033 IP=1,NSYH
                  J1=IR+((IT-1)*NP2+IP-1)*NR1
                  J2=IR+((IT-1)*NP2+NSYM-IP-1)*NR1
                  INDEX1=INP+(J1-1)*IGF+IG
                  INDEX2=INP+(J2-1)*IGF+IG
                  SAV=(ESTIM1(INDEX1)+ESTIM1(INDEX2))*0.5
                  ESTIM1(INDEX1)=SAV
                  ESTIM1(INDEX2)=SAV
1033        CONTINUE
          ENDIF
          IF (LT) THEN
            NSYM=NT3
            NSYH=(NSYM-1)/2
            DO 1034 IG=IGI,IGE
            DO 1034 IR=1,NR1
            DO 1034 IP=1,NP2
            DO 1034 IT=1,NSYH
                  J1=IR+((IT-1)*NP2+IP-1)*NR1
                  J2=IR+((NSYM-IT-1)*NP2+IP-1)*NR1
                  INDEX1=INP+(J1-1)*IGF+IG
                  INDEX2=INP+(J2-1)*IGF+IG
                  SAV=(ESTIM1(INDEX1)+ESTIM1(INDEX2))*0.5
                  ESTIM1(INDEX1)=SAV
                  ESTIM1(INDEX2)=SAV
1034        CONTINUE
          ENDIF
1035      CONTINUE
C
          IF (IGS.NE.0) THEN
            DO ICO = 1,NCLMT
              IR = ICLMT(ICO)
              INDX=INP+(IR-1)*IGF+IGS
              VECTRC(I,ICO)=ESTIM1(INDX)
            END DO
          ELSE
            DO 1044 ICO=1,NCLMT
              VECTRC(I,ICO)=0.
1044        CONTINUE
            DO 1045 IS=1,IGF
            DO 1045 ICO=1,NCLMT
              IR = ICLMT(ICO)
              INDX=INP+(IR-1)*IGF+IS
              VECTRC(I,ICO)=VECTRC(I,ICO)+ESTIM1(INDX)
1045        CONTINUE
          ENDIF
1037    CONTINUE
C
C
        SD1S = 0.D0
        SD2S = 0.D0
        SDC = 0.D0
        DO ICO = 1,NCLMT
          IR = ICLMT(ICO)
          SD1 = VECTRC(1,ICO)-SDVIAC(1,IC,IR)
          SD2 = VECTRC(2,ICO)-SDVIAC(2,IC,IR)
          SD1S=SD1S+SD1
          SD2S=SD2S+SD2
          SDVIAC(1,IC,IR)=VECTRC(1,ICO)
          SDVIAC(2,IC,IR)=VECTRC(2,ICO)
          SDC(1,IR) = SD1
          SDC(2,IR) = SD2
          DO IIN=2,IIND(IR)
            J=INDSS(IR,IIN)
            IRU=IND(IR,J)
            SDC(1,IRU)=SDC(1,IRU)+SD1
            SDC(2,IRU)=SDC(2,IRU)+SD2
          END DO
        END DO
C
        DO ICO = 1,NCLMTS
          IR = ICLMT(ICO)
!         IMETCL(IR) = 0
          SD1=SDC(1,IR)
          SD2=SDC(2,IR)
          SIGMAC(0,IC,IR)=SIGMAC(0,IC,IR)+SD1*SD2
          SIGMAC(1,IC,IR)=SIGMAC(1,IC,IR)+SD1*SD1
          SIGMAC(2,IC,IR)=SIGMAC(2,IC,IR)+SD2*SD2
        END DO
        SGMCS(0,IC)=SGMCS(0,IC)+SD1S*SD2S
        SGMCS(1,IC)=SGMCS(1,IC)+SD1S*SD1S
        SGMCS(2,IC)=SGMCS(2,IC)+SD2S*SD2S
1032  CONTINUE
C
C
1050  CONTINUE
!     NCLMT = 0
      RETURN
C
      ENTRY STATS2(XN,FSIG,ZFLUX)
C
C  1. FALL  ALLE BEITRAEGE GLEICHES VORZEICHEN: SIG ZWISCHEN 0 UND 1
C  2. FALL  NEGATIVE UND POSITIVE BEITRAGE KOMMEN VOR:
C           LT. FORMEL SIND AUCH WERTE GROESSER 1  MOEGLICH.
C
      XNM=XN-1.
      IF (XNM.LE.0.D0) RETURN
      ZFLUXQ=ZFLUX*ZFLUX
C
      IF (NSIGVI.EQ.0) GOTO 2200
C
      DO 2112 IC=1,NSIGVI
        INP=IADD(IC)
        IGF=IGFF(IC)
        IGS=IGH(IC)
        IF (IGS.NE.0) THEN
          DO 2113 IR=1,NSB
            INDX=INP+(IR-1)*IGF+IGS
            VECTOR(IR)=ESTIM1(INDX)
2113      CONTINUE
        ELSE
          DO 2114 IR=1,NSB
            VECTOR(IR)=0.
2114      CONTINUE
          DO 2115 IS=1,IGF
          DO 2115 IR=1,NSB
            INDX=INP+(IR-1)*IGF+IS
            VECTOR(IR)=VECTOR(IR)+ESTIM1(INDX)
2115      CONTINUE
        ENDIF
C
        SD=0.
        DS=0.
        DO 2011 IR=1,NSB
          SD1=VECTOR(IR)
          DS=DS+SD1
          DO 2016 IIN=1,IIND(IR)
            J=INDSS(IR,IIN)
            IRU=IND(IR,J)
            SD(IRU)=SD(IRU)+SD1
2016      CONTINUE
2011    CONTINUE
C
        DO 2111 IR=1,NSB
          D=SD(IR)
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMA(IC,IR)-DD/XN)
C RELATIV STANDARD DEVIATION
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMA(IC,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STV(IC,IR)=STV(IC,IR)+SG2*ZFLUXQ/XNM/XN
          EE(IC,IR)=EE(IC,IR)+D*ZFLUX/XN
2111    CONTINUE
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMS(IC)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMS(IC)=SG*FSIG
C
        STVS(IC)=STVS(IC)+SG2*ZFLUXQ/XNM/XN
        EES(IC)=EES(IC)+DS*ZFLUX/XN
2112  CONTINUE
C
2200  CONTINUE
      IF (NSIGSI.EQ.0) GOTO 2300
      DO 2212 IC=1,NSIGSI
        INP=IADDW(IC)
        IGF=IGFFW(IC)
        IGS=IGHW(IC)
        DS=0.
        IF (IGS.NE.0) THEN
          DO 2213 IR=1,NRW
            INDX=INP+(IR-1)*IGF+IGS
            VECTOR(IR)=ESTIM2(INDX)
2213      CONTINUE
        ELSE
          DO 2214 IR=1,NRW
            VECTOR(IR)=0.
2214      CONTINUE
          DO 2215 IS=1,IGF
          DO 2215 IR=1,NRW
            INDX=INP+(IR-1)*IGF+IS
            VECTOR(IR)=VECTOR(IR)+ESTIM2(INDX)
2215      CONTINUE
        ENDIF
        DO 2211 IR=1,NRW
          D=VECTOR(IR)
          DS=DS+D
          DD=D*D
          DA=ABS(D)
          SG2=MAX(0.D0,SIGMAW(IC,IR)-DD/XN)
          SG=SQRT(SG2)/(DA+EPS60)
          SIGMAW(IC,IR)=SG*FSIG
C CUMULATED VARIANCE FOR SUM OVER STRATA
          STVW(IC,IR)=STVW(IC,IR)+SG2*ZFLUXQ/XNM/XN
          FF(IC,IR)=FF(IC,IR)+D*ZFLUX/XN
2211    CONTINUE
        D2S=DS*DS
        DSA=ABS(DS)
        SG2=MAX(0.D0,SGMWS(IC)-D2S/XN)
        SG=SQRT(SG2)/(DSA+EPS60)
        SGMWS(IC)=SG*FSIG
C
        STVWS(IC)=STVWS(IC)+SG2*ZFLUXQ/XNM/XN
        FFS(IC)=FFS(IC)+DS*ZFLUX/XN
2212  CONTINUE
C
2300  CONTINUE
C
      IF (NSIGCI.EQ.0) GOTO 2400
C
      DO 2312 IC=1,NSIGCI
        DO 2317 I=1,2
          INP=IADDC(I,IC)
          IGF=IGFFC(I,IC)
          IGS=IGHC(I,IC)
          IF (IGS.NE.0) THEN
            DO 2313 IR=1,NSB
              INDX=INP+(IR-1)*IGF+IGS
              VECTRC(I,IR)=ESTIM1(INDX)
2313        CONTINUE
          ELSE
            DO 2314 IR=1,NSB
              VECTRC(I,IR)=0.
2314        CONTINUE
            DO 2315 IS=1,IGF
            DO 2315 IR=1,NSB
              INDX=INP+(IR-1)*IGF+IS
              VECTRC(I,IR)=VECTRC(I,IR)+ESTIM1(INDX)
2315        CONTINUE
          ENDIF
2317    CONTINUE
C
        SDC=0.
        DS1=0.
        DS2=0.
        DO 2311 IR=1,NSB
          SD1=VECTRC(1,IR)
          SD2=VECTRC(2,IR)
          DS1=DS1+SD1
          DS2=DS2+SD2
          DO 2316 IIN=1,IIND(IR)
            J=INDSS(IR,IIN)
            IRU=IND(IR,J)
            SDC(1,IRU)=SDC(1,IRU)+SD1
            SDC(2,IRU)=SDC(2,IRU)+SD2
2316      CONTINUE
2311    CONTINUE
        DO 2411 IR=1,NSB
          D1=SDC(1,IR)
          D2=SDC(2,IR)
          DD12=D1*D2
          DD11=D1*D1
          DD22=D2*D2
          DA1=ABS(D1)
          DA2=ABS(D2)
          SG12=         SIGMAC(0,IC,IR)-DD12/XN
          SG1 =MAX(0.D0,SIGMAC(1,IC,IR)-DD11/XN)
          SG2 =MAX(0.D0,SIGMAC(2,IC,IR)-DD22/XN)
C ABSOLUTE STANDARD DEVIATION AND COVARIANCES
          SIGMAC(0,IC,IR)=SG12/XNM/XN
          SIGMAC(1,IC,IR)=SQRT(SG1/XNM/XN)
          SIGMAC(2,IC,IR)=SQRT(SG2/XNM/XN)
2411    CONTINUE
        D2S12=DS1*DS2
        D2S11=DS1*DS1
        D2S22=DS2*DS2
        DSA1=ABS(DS1)
        DSA2=ABS(DS2)
        SG12=         SGMCS(0,IC)-D2S12/XN
        SG1 =MAX(0.D0,SGMCS(1,IC)-D2S11/XN)
        SG2 =MAX(0.D0,SGMCS(2,IC)-D2S22/XN)
        SGMCS(0,IC)=SG12/XNM/XN
        SGMCS(1,IC)=SQRT(SG1/XNM/XN)
        SGMCS(2,IC)=SQRT(SG2/XNM/XN)
2312  CONTINUE
C
2400  RETURN
      END
C
C
      SUBROUTINE COVAR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CSDVI'
      INCLUDE 'CESTIM'
      DIMENSION SCOV(NCV)
      DIMENSION BB1(NESTIM)
      EQUIVALENCE (BB1(1),PDENA(1,1))
      SAVE
C
      ENTRY COVAR0
      IHIST=0
      RETURN
C
C  AT THIS ENTRY: INDCOV.GE.1, I.E. IHIST.LT.NHIST
      ENTRY COVAR1
C
      IHIST=IHIST+1
C      DO 100 J=1,NCOV
C        COV(J,IHIST)=BB1(ICOV(J))-SCOV(J)
C100     SCOV(J)=BB1(ICOV(J))
C      INDCOV=INDCOV-1
      RETURN
C
      ENTRY COVAR2
      RETURN
      END
C
      SUBROUTINE FGAUSS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A GAUSSIAN
C  AND RETURN THEM IN THE ARRAYS FG1,FG2,FG3
C  IT FIRST GENERATES IRNDVC PAIRS, AND THEN IRNDVC/2 PAIRS
C  THIS ROUTINE IS CALLED IF INIV2=0. IT RETURNS INIV2=IRNDVC
C
      INCLUDE 'CRAND'
      DATA PI2/6.283185/
C
C    THIS FUNCTION SAMPLES FROM A GAUSSIAN OF THE
C    FORM EXP(-(X-ZA)**2/(2.*ZS**2))/(ZS*SQRT(2*PI))
C    ZA=0.
C    ZS=1.
C
C  IT IS THE BOX-MUELLER METHOD
C
C
      DO 1 JJ=1,IRNDVC
C   1. COMPUTE THE SINE AND COSINE OF 2*PI*RAN(1)
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FG1(JJ)=ZT*ZSIN
        FG2(JJ)=ZT*ZCOS
1     CONTINUE
C
      DO 2 JJ=1,IRNDVH
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FG3(JJ)=ZT*ZSIN
        FG3(JJ+IRNDVH)=ZT*ZCOS
2     CONTINUE
C
      INIV2=IRNDVC
      RETURN
      END
C
      SUBROUTINE FMAXWL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  SAMPLE IRNDVC RANDOM NUMBERS FROM A GAUSSIAN FLUX V*FMAX(V)
C  AND RETURN THEM THE ARRAY FM1
C  SAMPLE IRNDVC PAIRS OF RANDOM NUMBER FROM A GAUSSIAN
C  AND RETURN THEM IN THE ARRAYS FM2 AND FM3
C  THIS ROUTINE IS CALLED WHEN INIV1.EQ.0. IT RESETS INIV1=IRNDVC
C
      INCLUDE 'CRAND'
      DATA PI2/6.283185/
C
C  THIS FUNCTION SAMPLES FROM A GAUSSIAN OF THE
C  FORM EXP(-(X-ZA)**2/(2.*ZS**2))/(ZS*SQRT(2*PI))
C  ZA=0.
C  ZS=1.
C
C  IT IS THE BOX-MUELLER METHOD
C
C
      DO 1 JJ=1,IRNDVC
C   1. COMPUTE THE SINE AND COSINE OF 2*PI*RAN(1)
C
        ZZ=PI2*RANF_EIRENE( )
        ZSIN=SIN(ZZ)
        ZCOS=COS(ZZ)
C
        AR=LOG(RANF_EIRENE( ))
        ZT=SQRT(-(AR+AR))
        FM2(JJ)=ZT*ZSIN
        FM3(JJ)=ZT*ZCOS
1     CONTINUE
C
C  SAMPLE FROM MAXWELLIAN FLUX BY INVERSION RULE
C
      DO 2 JJ=1,IRNDVC
        AR=LOG(RANF_EIRENE( ))
        FM1(JJ)=SQRT(-(AR+AR))
2     CONTINUE
      INIV1=IRNDVC
      RETURN
      END
C
      SUBROUTINE FCOSIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A COSINE POLAR AND
C  AN EQUI AZIMUTAL DISTRIBUTION
C  AND RETURN THEM IN THE ARRAYS FC1,FC2,FC3
C  THIS ROUTINE IS CALLED, IF INIV4=0, AND IT RETURNS INIV4=IRNDVC
C
      INCLUDE 'CRAND'
      DATA PI2/6.283185/
C
      DO 100 J=1,IRNDVC
        ZTHET=PI2*RANF_EIRENE( )
        ZSTHET=SIN(ZTHET)
        ZCTHET=COS(ZTHET)
        A=RANF_EIRENE( )
        ZCPHI=SQRT(A)
        ZSPHI=SQRT(1.-A)
        FC1(J)=-ZCPHI
        FC2(J)=ZSPHI*ZCTHET
        FC3(J)=ZSPHI*ZSTHET
100   CONTINUE
      INIV4=IRNDVC
      RETURN
      END
C
      SUBROUTINE FISOTR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  SAMPLE IRNDVC TRIPLES OF RANDOM NUMBER FROM A 3D ISOTROPIC
C  DISTRIBUTION
C  AND RETURN THEM IN THE ARRAYS FI1,FI2,FI3
C  THIS ROUTINE IS CALLED, IF INIV3=0, AND IT RETURNS INIV3=IRNDVC
C
      INCLUDE 'CRAND'
      DATA PI2/6.283185/
C
      DO 100 J=1,IRNDVC
        ZEP1=RANF_EIRENE( )
        ZEP2=RANF_EIRENE( )
C  THETA
        ZTHETA=PI2*ZEP2
        ZCTHET=COS(ZTHETA)
        ZSTHET=SIN(ZTHETA)
C  PHI
        ZCPHI=ZEP1+ZEP1-1.
        ZSPHI=SQRT(1.-ZCPHI*ZCPHI)
C
        FI1(J)=ZCPHI
        FI2(J)=ZSPHI*ZSTHET
        FI3(J)=ZSPHI*ZCTHET
100   CONTINUE
      INIV3=IRNDVC
      RETURN
      END
C
      FUNCTION THOMP(UB,EMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  RANDOM NUMBER "E" FROM A THOMPSON FUNCTION F(E,UB,EMAX)
C  F(E,UB,EMAX)=CONST*E/(E+UB)**3,  0<E<EMAX
C  CONST=UB/(0.5*1./(EMAX/UB+1.)**2-1./(EMAX/UB+1.)+0.5)
C
      EMU=1./(EMAX/UB+1.)
      BETAD2=1./(EMU*EMU-EMU-EMU+1.)
C
      A=RANF_EIRENE()
      ARG=A/BETAD2
      E=UB/(1.-SQRT(ARG))-UB
      THOMP=E
C
      RETURN
      END
C
C     SUBROUTINE SAMPNT
C     SUBROUTINE SAMLNE
C     SUBROUTINE SAMSRF
C     SUBROUTINE SAMVOL
C
      SUBROUTINE SAMPNT (NLPT,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,WEISPZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'COMSOU'
      INCLUDE 'CGRID'
      INCLUDE 'CTRIG'
      INCLUDE 'COMUSR'
      INCLUDE 'CLOGAU'
      INCLUDE 'CCONA'
      DIMENSION TIWL(*),DIWL(*),VXWL(*),VYWL(*),VZWL(*),WEISPZ(*)
C
      IPOINT=NLPT
      X0=SORAD1(IPOINT,ISTRA)
      Y0=SORAD2(IPOINT,ISTRA)
      Z0=SORAD3(IPOINT,ISTRA)
      IF (NLTRA) PHI=SORAD3(IPOINT,ISTRA)*DEGRAD
      MRSURF=0
      MPSURF=0
      MTSURF=0
      MASURF=0
      NLSRFX=.FALSE.
      NLSRFY=.FALSE.
      NLSRFZ=.FALSE.
      NLSRFA=.FALSE.
      IF (NRSOR(IPOINT,ISTRA).GT.0.OR.NASOR(IPOINT,ISTRA).GT.0) THEN
        NRCELL=NRSOR(IPOINT,ISTRA)
        NACELL=NASOR(IPOINT,ISTRA)
        IPOLG =NISOR(IPOINT,ISTRA)
      ELSEIF (NRSOR(IPOINT,ISTRA).EQ.0.AND.
     .        NASOR(IPOINT,ISTRA).EQ.0) THEN
        NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,.FALSE.,.FALSE.,NPANU,
     .               'SAMPNT      ')
        NACELL=0
      ELSE
        GOTO 991
      ENDIF
      NTCELL=1
      IF (NLTOR.AND.NACELL.EQ.0) THEN
        IF (NLTRZ) THEN
          IF (NTSOR(NLPT,ISTRA).GT.0) THEN
C  NTCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NTSOR
            NTCELL=NTSOR(NLPT,ISTRA)
          ELSEIF (NTSOR(NLPT,ISTRA).EQ.0) THEN
C  NTCELL IS COMPUTED IN STANDARD MESH
            NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'SAMPNT      ')
          ELSE
            GOTO 991
          ENDIF
        ELSEIF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
C  FIND Z0,NTCELL FROM X01,PHI
          NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'SAMPNT      ')
          IF (NTCELL.LE.0.OR.NTCELL.GT.NT3RDM) THEN
            WRITE (6,*) 'NTCELL OUT OF RANGE IN SAMPNT '
            WRITE (6,*) PHI,ZHALF
            CALL EXIT
          ENDIF
          X01=X0+RMTOR
          CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
        ELSEIF (NLTRT) THEN
          WRITE (6,*) 'NLTRT: TO BE WRITTEN IN SAMPNT '
          CALL EXIT
        ENDIF
      ELSE
        IF (NLTRA) THEN
C  FIND Z0, NT,  FROM X0,PHI
          NT=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMPNT      ')
          IF (NT.LE.0.OR.NT.GT.NTTRAM) THEN
            WRITE (6,*) 'NT OUT OF RANGE IN SAMPNT '
            WRITE (6,*) PHI,ZFULL
            CALL EXIT
          ENDIF
          X01=X0+RMTOR
          CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
        ELSEIF (NLTRT) THEN
          WRITE (6,*) 'NLTRT: TO BE WRITTEN IN SAMPNT '
          CALL EXIT
        ENDIF
      ENDIF
C
      NPCELL=1
      IF (NLPOL.AND.NACELL.EQ.0) THEN
        IF (NPSOR(NLPT,ISTRA).GT.0) THEN
C  NPCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NPSOR
          NPCELL=NPSOR(NLPT,ISTRA)
        ELSEIF (NPSOR(NLPT,ISTRA).EQ.0) THEN
C  NPCELL IS COMPUTED IN STANDARD MESH
          IF (LEVGEO.EQ.1) THEN
            NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'SAMPNT')
          ELSEIF (LEVGEO.EQ.2) THEN
            IF (NLCRC) THEN
              WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
              NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'SAMPNT')
            ELSE
              NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'SAMPNT')
            ENDIF
          ELSEIF (LEVGEO.EQ.3) THEN
            NPCELL=IPOLG
          ELSE
            WRITE (6,*) 'ERROR EXIT FROM SAMPNT. NLPOL ',LEVGEO
            CALL EXIT
          ENDIF
        ELSE
          GOTO 991
        ENDIF
      ENDIF
C
      NBLOCK=NBSOR(IPOINT,ISTRA)
      NBLOCK=MAX0(1,NBLOCK)
      NBLOCK=MIN0(NBLOCK,NBMLT)
C
      IF (NRCELL.GT.0) NACELL=0
      IF (NACELL.GT.0) NBLOCK=NBMLTP
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
      TEWL=TEIN(NCELL)
      DO 13 IPLS=1,NPLSI
        TIWL(IPLS)=TIIN(IPLS,NCELL)
        VXWL(IPLS)=VXIN(IPLS,NCELL)
        VYWL(IPLS)=VYIN(IPLS,NCELL)
        VZWL(IPLS)=VZIN(IPLS,NCELL)
        DIWL(IPLS)=DIIN(IPLS,NCELL)
13    CONTINUE
C
      DO 20 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
20    CONTINUE
      IF (NSPEZ(ISTRA).LE.0) THEN
C  ANALOG SAMPLING DISTRIBUTION NOT AVAILABLE FOR POINT SOURCE
        GOTO 992
      ENDIF
C
      CRTX=SORAD4(IPOINT,ISTRA)
      CRTY=SORAD5(IPOINT,ISTRA)
      CRTZ=SORAD6(IPOINT,ISTRA)
      CNORM=SQRT(CRTX**2+CRTY**2+CRTZ**2)+EPS60
      CRTX=CRTX/CNORM
      CRTY=CRTY/CNORM
      CRTZ=CRTZ/CNORM
C
      RETURN
991   CONTINUE
      WRITE (6,*) 'ERROR IN SAMPNT                               '
      CALL EXIT
992   CONTINUE
      WRITE (6,*) 'ERROR IN SAMPNT, NSPEZ OUT OF RANGE           '
      CALL EXIT
      END
C
      SUBROUTINE SAMSRF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  THIS SUBROUTINE SAMPLES THE INITIAL CO-ORDINATES OF A PARTICLE
C  HISTORY, WHICH STARTS ON A SURFACE
C
      INCLUDE 'PARMMOD'
      INCLUDE 'CGEOM'
      INCLUDE 'COMPRT'
      INCLUDE 'CUPD'
      INCLUDE 'CSTEP'
      INCLUDE 'COMSOU'
      INCLUDE 'CTRCEI'
      INCLUDE 'CGRID'
      INCLUDE 'CADGEO'
      INCLUDE 'CLGIN'
      INCLUDE 'COMUSR'
      INCLUDE 'CLOGAU'
      INCLUDE 'CPOLYG'
      INCLUDE 'CCONA'
      INCLUDE 'CTRIG'
      DIMENSION INDTEC(3*NSRFS),ZZ(3),ALEFT(3,NSRFS),BRGHT(3,NSRFS),
     .          XI(3,NSRFS),XE(3,NSRFS)
      DIMENSION VXWL(*),VYWL(*),VZWL(*),TIWL(*),DIWL(*),WEISPZ(*)
      LOGICAL LOGTST
c slmod begin - tr
      INTEGER CHKVAC
      LOGICAL STATUS,CHKTRA,MESSAGE
      DATA message /.TRUE./

      SAVE NNOTIFY,message
c slmod end
      SAVE INDTEC,ZZ,ALEFT,BRGHT,XI,XE
C
C  INITIALIZE DATA FOR SURFACE SAMPLING FOR STRATUM NO. ISTRA
C
      ENTRY SAMSF0
      IERROR=0
      IF (output) WRITE(0,*) 'MARK: IN SAMSF0'
C
C  LOOP OVER SOURCE SURFACES: ISRFS
C
      DO 1 ISRFS=1,NSRFSI(ISTRA)
C
        ISOR=SORLIM(ISRFS,ISTRA)
C
        IF (SORLIM(ISRFS,ISTRA).GT.0.AND.INDIM(ISRFS,ISTRA).EQ.1.) THEN
          IF (INGRDA(ISRFS,ISTRA,1).NE.INGRDE(ISRFS,ISTRA,1)) THEN
            WRITE (6,*) 'WARNING FROM SAMSF0, ISTRA= ',ISTRA
            WRITE (6,*) 'NEW INPUT FOR INGRDA,INGRDE....'
            WRITE (6,*) 'AUTOMATIC CORRECTION CARRIED OUT '
            INGRDA(ISRFS,ISTRA,2)=INGRDA(ISRFS,ISTRA,1)
            INGRDE(ISRFS,ISTRA,2)=INGRDE(ISRFS,ISTRA,1)
            INGRDA(ISRFS,ISTRA,1)=INSOR(ISRFS,ISTRA)
            INGRDE(ISRFS,ISTRA,1)=INSOR(ISRFS,ISTRA)
          ENDIF
        ENDIF
C  HAS THIS SURFACE SOURCE A PREPROGRAMMED DISTRIBUTION
C
        IF (ISOR.LE.0) THEN
          ISR=ISRFS
          ISTR=ISTRA
c slmod begin - not tr (fix in 02)
c          CALL SM0USR(ISR,ISTR)
c
          CALL SM0USR(ISR,ISTR,
     .                SORAD1(ISR,ISTR),SORAD2(ISR,ISTR),
     .                SORAD3(ISR,ISTR),SORAD4(ISR,ISTR),
     .                SORAD5(ISR,ISTR),SORAD6(ISR,ISTR))
c slmod end
          GOTO 1
        ENDIF
C  YES
        NL1J=ISRFS
        NL2J=NL1J+NSRFS
        NL3J=NL2J+NSRFS
        INDTEC(NL1J)=IDEZ(ISOR,1,4)
        INDTEC(NL2J)=IDEZ(ISOR,2,4)
        INDTEC(NL3J)=IDEZ(ISOR,3,4)
C
C  DEFINE LEFT AND RIGHT BOUNDARY OF SAMPLING INTERVALS.
C
        IF (INDIM(ISRFS,ISTRA).EQ.1) THEN
C  SOURCE ON RADIAL SURFACE: SAMPLE SECOND AND THIRD CO-ORDINATE,
C                            COMPUTE FIRST CO-ORDINATE
C
          INDTEC(NL1J)=0
C
          ISGRD2=INGRDA(ISRFS,ISTRA,2)+INGRDE(ISRFS,ISTRA,2)
          ISGRD3=INGRDA(ISRFS,ISTRA,3)+INGRDE(ISRFS,ISTRA,3)
          IF (LEVGEO.EQ.3.AND.ISGRD2.GT.0) THEN
            IS1=MAX0(1,INGRDA(ISRFS,ISTRA,2))
            IS2=MIN0(NP2ND,INGRDE(ISRFS,ISTRA,2))
            ALEFT(2,ISRFS)=BGL(INSOR(ISRFS,ISTRA),IS1)
            BRGHT(2,ISRFS)=BGL(INSOR(ISRFS,ISTRA),IS2)
 
            IF (output) WRITE(0,*) 
     .        'MARK: BGL',INSOR(ISRFS,ISTRA),is1,
     .        BGL(INSOR(ISRFS,ISTRA),IS1),BGL(INSOR(ISRFS,ISTRA),IS2)

          ELSEIF (LEVGEO.EQ.4) THEN
            ALEFT(2,ISRFS)=RRSTEP(IDINT(SORIND(ISRFS,ISTRA)),1)
            BRGHT(2,ISRFS)=RRSTEP(IDINT(SORIND(ISRFS,ISTRA)),
     .                            NSMAX(IDINT(SORIND(ISRFS,ISTRA))))
          ELSE
            ALEFT(2,ISRFS)=SORAD3(ISRFS,ISTRA)
            BRGHT(2,ISRFS)=SORAD4(ISRFS,ISTRA)
          ENDIF
          ALEFT(3,ISRFS)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.2) THEN
C  SOURCE ON POLOIDAL SURFACE: SAMPLE FIRST AND THIRD CO-ORDINATE,
C                              COMPUTE SECOND CO-ORDINATE
C
          INDTEC(NL2J)=0
C
          ISGRD1=INGRDA(ISRFS,ISTRA,1)+INGRDE(ISRFS,ISTRA,1)
          ISGRD3=INGRDA(ISRFS,ISTRA,3)+INGRDE(ISRFS,ISTRA,3)
          IF (LEVGEO.EQ.3.AND.ISGRD1.GT.0) THEN
            IS1=MAX0(1,INGRDA(ISRFS,ISTRA,1))
            IS2=MIN0(NR1ST,INGRDE(ISRFS,ISTRA,1))
            ALEFT(1,ISRFS)=BGLP(IS1,INSOR(ISRFS,ISTRA))
            BRGHT(1,ISRFS)=BGLP(IS2,INSOR(ISRFS,ISTRA))
          ELSE
            ALEFT(1,ISRFS)=SORAD1(ISRFS,ISTRA)
            BRGHT(1,ISRFS)=SORAD2(ISRFS,ISTRA)
          ENDIF
          ALEFT(3,ISRFS)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.3) THEN
C  SOURCE ON TOROIDAL SURFACE: SAMPLE FIRST AND SECOND CO-ORDINATE,
C                              COMPUTE THIRD CO-ORDINATE
C
          INDTEC(NL3J)=0
C
          ISGRD1=INGRDA(ISRFS,ISTRA,1)+INGRDE(ISRFS,ISTRA,1)
          ISGRD2=INGRDA(ISRFS,ISTRA,2)+INGRDE(ISRFS,ISTRA,2)
C         IF (LEVGEO.EQ.3.AND.ISGRD1.GT.0) THEN
C         ELSE
            ALEFT(1,ISRFS)=SORAD1(ISRFS,ISTRA)
            BRGHT(1,ISRFS)=SORAD2(ISRFS,ISTRA)
C         ENDIF
          ALEFT(2,ISRFS)=SORAD3(ISRFS,ISTRA)
          BRGHT(2,ISRFS)=SORAD4(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.4) THEN
C  SOURCE ON RADIAL AND POLOIDAL SURFACES:
C      SAMPLE ARC-LENGTH AND THIRD CO-ORDINATE,
C      COMPUTE FIRST AND SECOND CO-ORDINATE FROM ARCLENGTH
C
          INDTEC(NL2J)=0
C
          IF (SORIND(ISRFS,ISTRA).NE.0.AND.
     .        NSMAX(IDINT(SORIND(ISRFS,ISTRA))).NE.0) THEN
            ALEFT(1,ISRFS)=RRSTEP(ISTRA,1)
            BRGHT(1,ISRFS)=
     .            RRSTEP(ISTRA,NSMAX(IDINT(SORIND(ISRFS,ISTRA))))
          ELSE
            WRITE (6,*) ' ERROR IN SAMSRF '
            WRITE (6,*) ' INDIM=4 ONLY FORESEEN WITH STEPFUNCTION '
            CALL EXIT
          ENDIF
          ALEFT(3,ISRFS)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
        IF (INDIM(ISRFS,ISTRA).EQ.0) THEN
C  SOURCE ON ADDITIONAL SURFACE
          ALEFT(1,ISRFS)=SORAD1(ISRFS,ISTRA)
          BRGHT(1,ISRFS)=SORAD2(ISRFS,ISTRA)
          ALEFT(2,ISRFS)=SORAD3(ISRFS,ISTRA)
          BRGHT(2,ISRFS)=SORAD4(ISRFS,ISTRA)
          ALEFT(3,ISRFS)=SORAD5(ISRFS,ISTRA)
          BRGHT(3,ISRFS)=SORAD6(ISRFS,ISTRA)
        ENDIF
C
C  IS A STEP FUNCTION REQUIRED?
C
        IF (INDTEC(NL1J).NE.4.AND.INDTEC(NL2J).NE.4.AND.
     .      INDTEC(NL3J).NE.4) GOTO 1
C
C  YES. CHECK INPUT DATA AND STORAGE
C
        ISTEP=SORIND(ISRFS,ISTRA)
C
        IF (ISTEP.EQ.0) THEN
          WRITE (6,*) 'ERROR IN PRIMARY SOURCE DATA '
          WRITE (6,*) 'STEPFUNCTION REQUIRED FOR SOURCE SURFACE '
          WRITE (6,*) 'NO. ', INSOR(ISRFS,ISTRA),' BUT SORIND.EQ.0.'
          CALL EXIT
        ELSEIF (ISTEP.GT.NSTEP) THEN
          CALL MASPRM('NSTEP',5,NSTEP,'ISTEP',5,ISTEP,IERROR)
          CALL EXIT
        ENDIF
C
        IF (ISTUF(ISTEP).EQ.0) THEN
          IF (NR1ST.GT.NGITT) THEN
            CALL MASPRM('NGITT',5,NGITT,'NR1ST',5,NR1ST,IERROR)
            CALL EXIT
          ELSEIF (ISTEP.GT.NBLCKS) THEN
            CALL MASPRM('NBLCKS',6,NBLCKS,'ISTEP',5,ISTEP,IERROR)
            CALL EXIT
          ENDIF
        ENDIF
C
C  HAS THIS STEPFUNCTION STILL TO BE INITIALIZED?
C
        IF (ISTUF(ISTEP).EQ.0) THEN
C
C  YES
C  INITIALIZE STEPFUNCTION NO. ISTEP BY DEFAULT MODEL:
C  DEFAULT MODEL FOR ISTEP: NPLSI STEP FUNCTIONS FROM BULK ION FLUXES
C
C  FIRST: RADIAL STEP FUNCTION:
          IF (INDTEC(NL1J).EQ.4) THEN
C
C  USE X-OR RADIAL DISTRIBUTION OF ION FLUX 0.5*NI(R)*CS (AMP/CM**2)
C  WITH: CS=SOUND SPEED FOR SPECIES IPLS
C  IN STANDARD GEOMETRY BLOCK  IBLOCK=ISTEP
C  IN CASE OF NLPLG: SAMPLE ON POLOIDAL POLYGON INSOR(ISRFS,ISTRA)
C
            DO 3 K=1,NR1STM
              IRSTEP(ISTEP,K)=K
              IASTEP(ISTEP,K)=0
              IBSTEP(ISTEP,K)=ISTEP
              IPSTEP(ISTEP,K)=1
              ITSTEP(ISTEP,K)=1
              IF (LEVGEO.EQ.1) THEN
                RRSTEP(ISTEP,K)=RSURF(K)
              ELSEIF (LEVGEO.EQ.2) THEN
                RRSTEP(ISTEP,K)=RHOSRF(K)
              ELSEIF (LEVGEO.EQ.3) THEN
                RRSTEP(ISTEP,K)=BGLP(K,INSOR(ISRFS,ISTRA))
              ELSEIF (LEVGEO.GE.4) THEN
                GOTO 3
              ENDIF
C
              NBLCKA=NSTRD*(IBSTEP(ISTEP,K)-1)+IASTEP(ISTEP,K)
              NCELL=IRSTEP(ISTEP,K)+
     .            ((IPSTEP(ISTEP,K)-1)+(ITSTEP(ISTEP,K)-1)*NP2T3)*
     .             NR1P2+NBLCKA
              TESTEP(ISTEP,K)=TEIN(NCELL)
              DO 2 IPLS=1,NPLSI
                TISTEP(IPLS,ISTEP,K)=TIIN(IPLS,NCELL)
                VXSTEP(IPLS,ISTEP,K)=VXIN(IPLS,NCELL)
                VYSTEP(IPLS,ISTEP,K)=VYIN(IPLS,NCELL)
                VZSTEP(IPLS,ISTEP,K)=VZIN(IPLS,NCELL)
                DISTEP(IPLS,ISTEP,K)=DIIN(IPLS,NCELL)
                CS=CVEL2A*SQRT((TIIN(IPLS,NCELL)+TEIN(NCELL))/
     .             RMASSP(IPLS))
                FLSTEP(IPLS,ISTEP,K)=ELCHA*0.5*DIIN(IPLS,NCELL)*CS
2             CONTINUE
3           CONTINUE
C  LAST INTERVAL BOUNDARY FOR SAMPLING DISTRIBUTION
            IF (LEVGEO.EQ.1) THEN
              RRSTEP(ISTEP,NR1ST)=RSURF(NR1ST)
            ELSEIF (LEVGEO.EQ.2) THEN
              RRSTEP(ISTEP,NR1ST)=RHOSRF(NR1ST)
            ELSEIF (LEVGEO.EQ.3) THEN
              RRSTEP(ISTEP,NR1ST)=BGLP(NR1ST,INSOR(ISRFS,ISTRA))
            ELSEIF (LEVGEO.GE.4) THEN
              WRITE (6,*) 'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
              WRITE (6,*) 'LEVGEO.LE.3 OPTION. '
              WRITE (6,*) 'CALL EXIT '
              CALL EXIT
            ENDIF
            FL=STEP(1,NPLSI,NR1ST,ISTEP)
C
          ELSEIF (INDTEC(NL2J).EQ.4) THEN
            WRITE (6,*) 'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
            WRITE (6,*) 'SAMPLING OF RADIAL CO-ORDINATE '
            WRITE (6,*) 'DEFINE STEP FUNCTION ELSEWHERE, EG. IN SAMUSR'
            WRITE (6,*) 'CALL EXIT '
            CALL EXIT
C
          ELSEIF (INDTEC(NL3J).EQ.4) THEN
            WRITE (6,*) 'DEFAULT STEP FUNCTIONS ONLY AVAILABLE FOR'
            WRITE (6,*) 'SAMPLING OF RADIAL CO-ORDINATE '
            WRITE (6,*) 'DEFINE STEP FUNCTION ELSEWHERE, EG. IN SAMUSR'
            WRITE (6,*) 'CALL EXIT '
            CALL EXIT
          ENDIF
C
        ENDIF
C
        IF (TRCSOU) THEN
          WRITE (6,*) 'FUNCTION STEP NO. ',ISTEP,': '
          WRITE (6,'(1X,A3,A12,7(2X,A7,I2,A1:))')
     .    '  K','  RRSTEP    ',('FLSTEP(',IPLS,'): AMP/CM**2',
     .    IPLS=1,NPLSI)
          NSMX=NSMAX(ISTEP)
          DO 4 K=1,NSMX-1
            WRITE (6,'(1X,I3,1P,10(E12.4:))')
     .               K,RRSTEP(ISTEP,K),
     .               (FLSTEP(IPLS,ISTEP,K),IPLS=1,NPLSI)
4         CONTINUE
          WRITE (6,'(1X,I3,1P,2E12.4)') NSMX,RRSTEP(ISTEP,NSMX)
          CALL LEER(1)
          WRITE (6,*) 'FLUX FLSTEP INTEGRATED ALONG RRSTEP: '
          DO 5 IPLS=1,NPLSI
            FLX=0.
            DO 6 K=1,NSMX-1
              DELR=RRSTEP(ISTEP,K+1)-RRSTEP(ISTEP,K)
              FLX=FLX+FLSTEP(IPLS,ISTEP,K)*DELR
6           CONTINUE
            CALL MASJ1R('IPLS,FLUX       ',IPLS,FLX)
5         CONTINUE
          CALL LEER(2)
        ENDIF
C
C
C  STEP FUNCTION INITIALISATION FINISHED.
C  NEXT: STORE SOME DATA TO SPEED UP SAMPLING FROM STEP FUNCTION
C
        ISPZ=0
        IF (NSPEZ(ISTRA).GT.0) ISPZ=NSPEZ(ISTRA)
C
        IF (ISPZ.GT.0.AND.ISPZ.LT.NSPSTI(ISTEP)) GOTO 991
        IF (               ISPZ.GT.NSPSTE(ISTEP)) GOTO 991
C
        IF (INDTEC(NL1J).EQ.4) THEN
          XI(1,ISRFS)=STEP0(ISPZ,ISTEP,ALEFT(1,ISRFS))
          XE(1,ISRFS)=STEP0(ISPZ,ISTEP,BRGHT(1,ISRFS))
        ELSEIF (INDTEC(NL2J).EQ.4) THEN
          XI(2,ISRFS)=STEP0(ISPZ,ISTEP,ALEFT(2,ISRFS))
          XE(2,ISRFS)=STEP0(ISPZ,ISTEP,BRGHT(2,ISRFS))
        ELSEIF (INDTEC(NL3J).EQ.4) THEN
          XI(3,ISRFS)=STEP0(ISPZ,ISTEP,ALEFT(3,ISRFS))
          XE(3,ISRFS)=STEP0(ISPZ,ISTEP,BRGHT(3,ISRFS))
        ENDIF
C
1     CONTINUE
C
      IF (TRCSOU) CALL LEER(2)
      IF (output) WRITE(0,*) 'MARK: LEAVING SAMSF0'
      RETURN
C
      ENTRY SAMSF1(NLSF,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,WEISPZ)
      IF (output) WRITE(0,*) 'MARK: IN SAMSF1'
C
      ICOUNT=0
100   CONTINUE
      ICOUNT=ICOUNT+1
C
C   NLSF=SURFACE INDEX IN (NSRFS ) SOURCE  ARRAYS
C
      JCALC=0
      ISTEP=0
C
      DO 101 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
101   CONTINUE
C
C   USER SUPPLIED GENERATOR FOR X0,Y0,Z0. ONLY ONE CALL
C   FOR ALL 3 CO-ORDINATES. SUBR. SURTST IS NOT CALLED!
C
      IF (SORLIM(NLSF,ISTRA).LT.0.D0) THEN
c slmod begin - not tr
c...
        STOP 'WHEN WAS I USING THIS?'

        CALL SM1USR(NLSF,X0,Y0,Z0,INSOR(NLSF,ISTRA),
     .              SORAD1(NLSF,ISTRA),SORAD2(NLSF,ISTRA),
     .              SORAD3(NLSF,ISTRA),SORAD4(NLSF,ISTRA),
     .              SORAD5(NLSF,ISTRA),SORAD6(NLSF,ISTRA),
c
c        CALL SM1USR(NLSF,X0,Y0,Z0,
c     .              SORAD1(NLSF,ISTRA),SORAD2(NLSF,ISTRA),
c     .              SORAD3(NLSF,ISTRA),SORAD4(NLSF,ISTRA),
c     .              SORAD5(NLSF,ISTRA),SORAD6(NLSF,ISTRA),
c slmod end
     .              IRUSR,IPUSR,ITUSR,IAUSR,IBUSR,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,WEISPZ)
        ISTEP=-1
        GOTO 1500
      ENDIF
C
      DO 1000 J=1,3
        IK=NLSF+(J-1)*NSRFS
        GOTO (10,20,30,40),INDTEC(IK)
C   ZZ(JCALC) IS TO BE CALCULATED FROM SURFACE-EQUATION
          IF (JCALC.NE.0) GOTO 997
          JCALC=J
          GOTO 1000
C   DELTA DISTRIBUTION AT CENTER OF INTERVALL
10      CONTINUE
          ZZ(J)=(ALEFT(J,NLSF)+BRGHT(J,NLSF))*0.5
          GOTO 1000
C   UNIFORM DISTRIBUTION IN THIS CO-ORDINATE
20      CONTINUE
          ZZ(J)=RANF_EIRENE( )*(BRGHT(J,NLSF)-ALEFT(J,NLSF))+
     .          ALEFT(J,NLSF)
          GOTO 1000
C   EXPONENTIAL DECAY WITH LENGTH XLAMDA, FOR ONE CO-ORDINATE ONLY
30      CONTINUE
          DELTA=BRGHT(J,NLSF)-ALEFT(J,NLSF)
          XLAMDA=SOREXP(NLSF,ISTRA)
          ZM=DELTA/XLAMDA
          ZH=MOD(-LOG(RANF_EIRENE( )),ZM)
          ZZ(J)=XLAMDA*ZH+ALEFT(J,NLSF)
          GOTO 1000
C   STEPFUNCTION NO. ISTEP, FOR ONE CO-ORDINATE ONLY
40      CONTINUE
          ISTEP=SORIND(NLSF,ISTRA)
          RNF=XI(J,NLSF)+RANF_EIRENE( )*(XE(J,NLSF)-XI(J,NLSF))
          ZZ(J)=STEP1(IINDEX,ISTEP,RNF,NSPEZ(ISTRA))
          GOTO 1000
1000  CONTINUE
C
      IPOLG=1
C
1500  CONTINUE
C
C  1500---2000
C  IN CASE OF DEFAULT SAMPLING:
C    TWO OUT OF THE THREE CO-ORDINATES ZZ(1),ZZ(2),ZZ(3) ARE
C    SAMPLED.
C    FIND 3RD CO-ORDINATE FROM SURFACE EQUATION
C    CONVERT ZZ(1), ZZ(2), ZZ(3) TO CARTHESIAN CO-ORDINATES X0,Y0,Z0
C  IN CASE OF USER SUPPLIED SAMPLING:
C    THE THREE CARTHESIAN CO-ORDINATES X0,Y0,Z0 ARE GIVEN NOW
C    ONLY SURFACE FLAGS NLSRFX,...MRSURF,.... MUST BE SET
C
      IF (INDIM(NLSF,ISTRA).EQ.0) THEN
C  BIRTH POINT ON ADDITIONAL SURFACE, ZZ( ) ARE CARTHESIAN
        NLSRFX=.FALSE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        MTSURF=0
        MPSURF=0
        MRSURF=0
        MASURF=INSOR(NLSF,ISTRA)
        ILTR=ILTOR(MASURF)
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
C
        IF (JCALC.EQ.1) THEN
C  FIND X CO-ORDINATE X0 FROM Y=Y0 AND Z=Z0 ON SURFACE NO. MASURF
          Y0=ZZ(2)
c slmod begin - tr
          IF (NLTRA.AND.ILTR.NE.0) THEN
            PHI=ZZ(3)*DEGRAD
            Z0=X0*DTAN(PHI)
          ELSEIF (NLTRZ.OR. ILTR.NE.0) THEN
c
c          IF (NLTRZ.OR.     ILTR.NE.0) THEN
c slmod end
C Z0 IS GIVEN IN LOCAL CO-ORDINATE SYSTEM ILTOR
            Z0=ZZ(3)
          ELSEIF (NLTRA.AND.ILTR.EQ.0) THEN
            PHI=ZZ(3)*DEGRAD
C Z0 IS IRRELEVANT HERE, AND IS DETERMINED LATER FROM PHI
          ELSEIF (NLTRT.AND.ILTR.EQ.0) THEN
            PHI=ZZ(3)*DEGRAD
C Z0 IS IRRELEVANT HERE, AND IS DETERMINED LATER FROM PHI
          ENDIF
          IF (JUMLIM(MASURF).NE.0) THEN
            IF (ABS(A1LM(MASURF)).LE.EPS12) GOTO 993
            AN=-1./A1LM(MASURF)
            X0=(A0LM(MASURF)+Y0*A2LM(MASURF)+Z0*A3LM(MASURF))*AN
          ELSE
            S=A4LM(MASURF)
            Q=A0LM(MASURF)+(A2LM(MASURF)+A5LM(MASURF)*Y0)*Y0+
     .        (A3LM(MASURF)+A6LM(MASURF)*Z0+A9LM(MASURF)*Y0)*Z0
            P=A1LM(MASURF)+A7LM(MASURF)*Y0+A8LM(MASURF)*Z0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN X
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                X0=PH
              ELSEIF (DET.GT.0.D0) THEN
                X0=PH+SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) X0=PH-SQRT(DET)
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN X
              X0=Q/P
            ELSE
C  INDEPENDENT OF X
              GOTO 993
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR X0?
          X0TEST=ABS(ALEFT(1,NLSF)-BRGHT(1,NLSF))
          IF (X0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(1,NLSF).GT.X0.OR.BRGHT(1,NLSF).LT.X0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (6,*) 'WARNING FROM SAMSRF FROM X0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF
        ELSEIF (JCALC.EQ.2) THEN
C    FIND Y CO-ORDINATE Y0 FROM X=X0 AND Z=Z0 ON SURFACE NO. MASURF
          X0=ZZ(1)
c slmod begin - tr
          IF     (NLTRA.AND.ILTR.NE.0) THEN
            PHI=ZZ(3)*DEGRAD
            Z0=X0*DTAN(PHI)
          ELSEIF (NLTRZ.OR. ILTR.NE.0) THEN
c
c          IF (NLTRZ.OR.     ILTR.NE.0) THEN
c slmod end
C Z0 IS GIVEN IN LOCAL CO-ORDINATE SYSTEM ILTOR
            Z0=ZZ(3)
          ELSEIF (NLTRA.AND.ILTR.EQ.0) THEN
            PHI=ZZ(3)*DEGRAD
C           Z0=??, TO BE FOUND FROM X01,PHI LATER
          ELSEIF (NLTRT.AND.ILTR.EQ.0) THEN
            PHI=ZZ(3)*DEGRAD
C           Z0=??, TO BE FOUND FROM X01,PHI LATER
          ENDIF
          IF (JUMLIM(MASURF).NE.0) THEN
            IF (ABS(A2LM(MASURF)).LE.EPS12) GOTO 993
            AN=-1./A2LM(MASURF)
            Y0=(A0LM(MASURF)+X0*A1LM(MASURF)+Z0*A3LM(MASURF))*AN
          ELSE
            S=A5LM(MASURF)
            Q=A0LM(MASURF)+(A1LM(MASURF)+A4LM(MASURF)*X0)*X0+
     .        (A3LM(MASURF)+A6LM(MASURF)*Z0+A8LM(MASURF)*X0)*Z0
            P=A2LM(MASURF)+A7LM(MASURF)*X0+A9LM(MASURF)*Z0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN Y
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                Y0=PH
              ELSEIF (DET.GT.0.D0) THEN
                Y0=PH+SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) Y0=PH-SQRT(DET)
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN Y
              Y0=Q/P
            ELSE
C  INDEPENDENT OF Y
              GOTO 993
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR Y0?
          Y0TEST=ABS(ALEFT(2,NLSF)-BRGHT(2,NLSF))
          IF (Y0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(2,NLSF).GT.Y0.OR.BRGHT(2,NLSF).LT.Y0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (6,*) 'WARNING FROM SAMSRF FROM Y0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF
        ELSEIF (JCALC.EQ.3) THEN
C    FIND Z CO-ORDINATE Z0 FROM X=X0 AND Y=Y0 ON SURFACE NO. MASURF
          X0=ZZ(1)
          Y0=ZZ(2)
c slmod begin - not tr
          IF     (NLTRA.AND.ILTR.NE.0) THEN
            STOP 'PROBLEM A'
            PHI=ZZ(3)*DEGRAD
            Z0=X0*DTAN(PHI)
          ELSEIF ((NLTRA.OR.NLTRT).AND.ILTR.EQ.0) THEN
            GOTO 993
          ELSEIF (JUMLIM(MASURF).NE.0) THEN
c
c          IF ((NLTRA.OR.NLTRT).AND.ILTR.EQ.0) GOTO 993
c          IF (JUMLIM(MASURF).NE.0) THEN
c slmod end
            IF (ABS(A3LM(MASURF)).LE.EPS12) GOTO 993
            AN=-1./A3LM(MASURF)
            Z0=(A0LM(MASURF)+X0*A1LM(MASURF)+Y0*A2LM(MASURF))*AN
          ELSE
            S= A6LM(MASURF)
            Q= A0LM(MASURF)+(A1LM(MASURF)+A4LM(MASURF)*X0)*X0+
     .        (A2LM(MASURF)+A5LM(MASURF)*Y0+A7LM(MASURF)*X0)*Y0
            P= A3LM(MASURF)+A8LM(MASURF)*X0+A9LM(MASURF)*Y0
            IF (ABS(S).GT.EPS12) THEN
C  SECOND ORDER IN Z
              AN=1./S
              Q=Q*AN
              P=P*AN
              PH=-P*0.5
              DET=PH*PH-Q
              IF (DET.LT.0.D0) THEN
                GOTO 999
              ELSEIF (DET.EQ.0.D0) THEN
                Z0=PH
              ELSEIF (DET.GT.0.D0) THEN
                Z0=PH+SQRT(DET)
                CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
                IF (.NOT.LOGTST) Z0=PH-SQRT(DET)
              ENDIF
            ELSEIF (ABS(P).GT.EPS12) THEN
C  FIRST ORDER IN Z
              Z0=Q/P
            ELSE
C  INDEPENDENT OF Z
              GOTO 993
            ENDIF
          ENDIF
C  CARRY OUT RANGE TEST FOR Z0?
          Z0TEST=ABS(ALEFT(3,NLSF)-BRGHT(3,NLSF))
          IF (Z0TEST.LT.1.D-10) GOTO 2000
          IF (ALEFT(3,NLSF).GT.Z0.OR.BRGHT(3,NLSF).LT.Z0) THEN
            IF (ICOUNT.LT.1000) GOTO 100
            WRITE (6,*) 'WARNING FROM SAMSRF, Z0TEST, ICOUNT=1000 '
            LGPART=.FALSE.
            RETURN
          ENDIF
C
        ELSE
          X0=ZZ(1)
          Y0=ZZ(2)
          Z0=ZZ(3)
        ENDIF
C
c slmod begin - tr        
c... SURTST was reporting that some neutral launches from additional
c    surfaces, in the toroidal approximation, were not actually on the 
c    surface.  This happened very rarely, so the call to this routine
c    was turned off: 
        IF (.NOT.(NLTRA.AND.ILTR.NE.0)) THEN
c        IF (.TRUE..OR..NOT.(NLTRA.AND.ILTR.NE.0)) THEN
          CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
          IF (.NOT.LOGTST) WRITE(0,*) 'PHI:',z0,phi/degrad,iltr 
          IF (.NOT.LOGTST) GOTO 998
        ENDIF
c
c        CALL SURTST(X0,Y0,Z0,MASURF,LOGTST)
c        IF (.NOT.LOGTST) GOTO 998
c slmod end
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.1) THEN
C  BIRTH POINT ON STANDARD RADIAL SURFACE  MRSURF
C  Y- OR POLOIDAL AND Z- OR TOROIDAL CO-ORDINATES MUST BE SAMPLED
C  X-OR RADIAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
        NLSRFX=.TRUE.
        NLSRFY=.FALSE.
        NLSRFZ=.FALSE.
        MRSURF=INSOR(NLSF,ISTRA)
        MPSURF=0
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.2.OR.JCALC.EQ.3) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=RSURF(MRSURF)
          Y0=ZZ(2)
        ELSEIF (LEVGEO.EQ.2) THEN
          X0=RSURF(MRSURF)*COS(ZZ(2)*DEGRAD)+EP1(MRSURF)
          Y0=RSURF(MRSURF)*SIN(ZZ(2)*DEGRAD)*ELL(MRSURF)
        ELSEIF (LEVGEO.EQ.3) THEN
          BL=ZZ(2)
          DO 1501 I=1,NPPLG
            DO 1501 J=NPOINT(1,I),NPOINT(2,I)
            IF (BL.LE.BGL(MRSURF,J)) GOTO 1502
1501      CONTINUE
          GOTO 996
1502      CONTINUE
          IPLG=J-1
          D=BL-BGL(MRSURF,IPLG)
          VVX=VPLX(MRSURF,IPLG)
          VVY=VPLY(MRSURF,IPLG)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1) THEN
            X0=XVERT(MRSURF,IPLG,1)+D*VVX*VVI
            Y0=YVERT(MRSURF,IPLG,1)+D*VVY*VVI
          ELSE
            X0=XPOL(MRSURF,IPLG)+D*VVX*VVI
            Y0=YPOL(MRSURF,IPLG)+D*VVY*VVI
          ENDIF
c
c          X0=XPOL(MRSURF,IPLG)+D*VVX*VVI
c          Y0=YPOL(MRSURF,IPLG)+D*VVY*VVI
c slmod end
        ELSEIF (LEVGEO.EQ.4) THEN
          IF (ISTEP.LE.0) GOTO 995
          BL=ZZ(2)
          MRSURF=IRSTEP(ISTEP,IINDEX)
          IPLG=IPSTEP(ISTEP,IINDEX)
          D=BL-RRSTEP(ISTEP,IINDEX)
          VVX=VTRIX(IPLG,MRSURF)
          VVY=VTRIY(IPLG,MRSURF)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
          X0=XTRIAN(NECKE(IPLG,MRSURF))+D*VVX*VVI
          Y0=YTRIAN(NECKE(IPLG,MRSURF))+D*VVY*VVI
        ELSEIF (LEVGEO.EQ.5) THEN
          WRITE (6,*) 'ERROR EXIT FROM SAMSRF. NLPOL ',LEVGEO
          CALL EXIT
        ENDIF
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.2) THEN
C  BIRTH POINT ON STANDARD POLOIDAL SURFACE MPSURF
C  X-OR RADIAL CO-ORDINATE AND Z-OR TOROIDAL CO-ORDINATE MUST BE SAMPLED
C  Y-OR POLOIDAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
        NLSRFX=.FALSE.
        NLSRFY=.TRUE.
        NLSRFZ=.FALSE.
        MRSURF=0
        MPSURF=INSOR(NLSF,ISTRA)
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.3) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=ZZ(1)
          Y0=PSURF(MPSURF)
        ELSEIF (LEVGEO.EQ.2) THEN
          IF (NLCRC) THEN
            X0=ZZ(1)*COSPH(MPSURF)
            Y0=ZZ(1)*SINPH(MPSURF)
          ELSE
            GOTO 992
          ENDIF
        ELSEIF (LEVGEO.EQ.3) THEN
          BL=ZZ(1)
          DO 1601 J=2,NR1ST
            IF (BL.LE.BGLP(J,MPSURF)) GOTO 1602
1601      CONTINUE
          GOTO 996
1602      CONTINUE
          IPLG=J-1
          D=BL-BGLP(IPLG,MPSURF)
          VVX=VVTX(IPLG,MPSURF)
          VVY=VVTY(IPLG,MPSURF)
          VVI=1./SQRT(VVX*VVX+VVY*VVY)
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1) THEN
            X0=XVERT(IPLG,MPSURF,1)+D*VVX*VVI
            Y0=YVERT(IPLG,MPSURF,1)+D*VVY*VVI
          ELSE
            X0=XPOL(IPLG,MPSURF)+D*VVX*VVI
            Y0=YPOL(IPLG,MPSURF)+D*VVY*VVI
          ENDIF
c
c          X0=XPOL(IPLG,MPSURF)+D*VVX*VVI
c          Y0=YPOL(IPLG,MPSURF)+D*VVY*VVI
c slmod end
        ENDIF
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.3) THEN
C  BIRTH POINT ON STANDARD TOROIDAL SURFACE
C  X-OR RADIAL CO-ORDINATE AND Y-OR TOROIDAL CO-ORDINATE MUST BE SAMPLED
C  Z-OR TOROIDAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
        NLSRFX=.FALSE.
        NLSRFY=.FALSE.
        NLSRFZ=.TRUE.
        MRSURF=0
        MPSURF=0
        MTSURF=INSOR(NLSF,ISTRA)
        MASURF=0
        ILTR=0
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.2) GOTO 993
C
        IF (LEVGEO.EQ.1) THEN
          X0=ZZ(1)
          Y0=ZZ(2)
          Z0=ZSURF(MTSURF)
          IF (NLTRA) PHI=ZSURF(MTSURF)
        ELSEIF (LEVGEO.EQ.2) THEN
          X0=ZZ(1)*COS(ZZ(2)*DEGRAD)
          Y0=ZZ(1)*SIN(ZZ(2)*DEGRAD)
          Z0=ZSURF(MTSURF)
          IF (NLTRA) PHI=ZSURF(MTSURF)
          IF (.NOT.NLCRC) GOTO 992
        ELSE
C  TO BE WRITTEN
          WRITE (6,*) 'ERROR IN SAMPLE, SOURCE ON TOR. SURFACE'
          CALL EXIT
        ENDIF
C
      ELSEIF (INDIM(NLSF,ISTRA).EQ.4) THEN
C  BIRTH POINT ON STANDARD RADIAL OR POLOIDAL SURFACE
C  X-OR RADIAL CO-ORDINATE AND Z-OR TOROIDAL CO-ORDINATE MUST BE SAMPLED
C  Y-OR POLOIDAL CO-ORDINATE IS COMPUTED FROM SURFACE EQUATION
C  X CO-ORDINATE IS SAMPLED FROM STEP FUNCTION
        IF (ISTEP.LE.0) GOTO 995
        NLSRFZ=.FALSE.
        MTSURF=0
        MASURF=0
        ILTR=0
        IF (SORLIM(NLSF,ISTRA).LT.0.D0) GOTO 2000
        IF (JCALC.EQ.1.OR.JCALC.EQ.3) GOTO 993
C
        BL=ZZ(1)
        DO 1701 J=2,NSMAX(ISTEP)
          IF (BL.LE.RRSTEP(ISTEP,J)) GOTO 1702
1701    CONTINUE
        GOTO 996
1702    CONTINUE
        IPLG=J-1
        D=BL-RRSTEP(ISTEP,IPLG)
        IF (LEVGEO.EQ.4) THEN
          IF (IGSTEP(ISTEP,IPLG).LT.200000) THEN
            NLSRFX=.TRUE.
            NLSRFY=.FALSE.
            MPSURF=0
            MRSURF=IGSTEP(ISTEP,IPLG)-100000
            WRITE (6,*) 'SAMSRF: OPTION INDIM=4 NOT READY'
            CALL EXIT
            ISIDE=IPSTEP(ISTEP,IPLG)
            VVX=VTRIX(ISIDE,MRSURF)
            VVY=VTRIY(ISIDE,MRSURF)
            VVI=1./SQRT(VVX*VVX+VVY*VVY)
            X0=XTRIAN(NECKE(ISIDE,MRSURF))+D*VVX*VVI
            Y0=YTRIAN(NECKE(ISIDE,MRSURF))+D*VVY*VVI
          ELSE
C  NO POLOIDAL PART FOR TRIANGLES
            GOTO 992
          ENDIF
        ELSEIF (LEVGEO.EQ.3) THEN
          IF (IGSTEP(ISTEP,IPLG).LT.200000) THEN
C  RADIAL PART
            NLSRFX=.TRUE.
            NLSRFY=.FALSE.
            MPSURF=0
            MRSURF=IGSTEP(ISTEP,IPLG)-100000
            VVX=VPLX(MRSURF,IPSTEP(ISTEP,IPLG))
            VVY=VPLY(MRSURF,IPSTEP(ISTEP,IPLG))
            VVI=1./SQRT(VVX*VVX+VVY*VVY)
c slmod begin - grid - tr
            IF (GRIDOPT.EQ.1) THEN
              X0=XVERT(MRSURF,IPSTEP(ISTEP,IPLG),1)+D*VVX*VVI
              Y0=YVERT(MRSURF,IPSTEP(ISTEP,IPLG),1)+D*VVY*VVI
            ELSE
              X0=XPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVX*VVI
              Y0=YPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVY*VVI
            ENDIF
c
c           X0=XPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVX*VVI
c           Y0=YPOL(MRSURF,IPSTEP(ISTEP,IPLG))+D*VVY*VVI
c slmod end
          ELSE
C  POLOIDAL PART
            NLSRFX=.FALSE.
            NLSRFY=.TRUE.
            MRSURF=0
            MPSURF=IGSTEP(ISTEP,IPLG)-200000
            VVX=VVTX(IRSTEP(ISTEP,IPLG),MPSURF)
            VVY=VVTY(IRSTEP(ISTEP,IPLG),MPSURF)
            VVI=1./SQRT(VVX*VVX+VVY*VVY)
c slmod begin - grid - tr
            IF (GRIDOPT.EQ.1) THEN
              X0=XVERT(IRSTEP(ISTEP,IPLG),MPSURF,1)+D*VVX*VVI
              Y0=YVERT(IRSTEP(ISTEP,IPLG),MPSURF,1)+D*VVY*VVI
            ELSE
              X0=XPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVX*VVI
              Y0=YPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVY*VVI
            ENDIF
c
c            X0=XPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVX*VVI
c            Y0=YPOL(IRSTEP(ISTEP,IPLG),MPSURF)+D*VVY*VVI
c slmod end
          ENDIF
        ELSE
          GOTO 992
        ENDIF
        IF (NLTRZ) THEN
          Z0=ZZ(3)
        ELSEIF (NLTRA) THEN
          PHI=ZZ(3)*DEGRAD
        ELSEIF (NLTRT) THEN
          PHI=ZZ(3)*DEGRAD
        ENDIF
      ENDIF
C
C  FIND ZONE NUMBER NRCELL, NACELL ,NBLOCK AND IPOLG
C
2000  CONTINUE
C
      IF (NASOR(NLSF,ISTRA).GT.0.AND.NRSOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL=0
C  IPOLG=0
C  NBLOCK=NBMLTP
C  NACELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NASOR
        NACELL=NASOR(NLSF,ISTRA)
        NRCELL=0
        NBLOCK=NBMLTP
        IPOLG=0
c slmod begin - tr - new
      ELSEIF (NASOR(NLSF,ISTRA).LE.-1.AND.NRSOR(NLSF,ISTRA).EQ.0) THEN
C PARICLE IS PUFFED FROM AN ADDITIONAL SURFACE 

C SEARCH VACUUM GRID TO FIND WHICH ADDITIONAL CELL THE PARTICLE IS BEING
C LAUNCHED INTO
        IF (NLTRA) THEN
          IF (NLTOR) THEN
            WRITE(0,*) 'DEVELOPMENT REQUIRED'
            STOP
          ELSE
            PHISEG=PI2A/DBLE(NTTRA-1)
            IF (ILTR.NE.0) THEN
              NTRSEG=ILTR
            ELSE
              WRITE(0,*) 'PHI:',phi
              NTRSEG=INT((PHI+0.5D0*PHISEG)/PHISEG)+
     .               MAX(0,NINT(DSIGN(1.0D0,PHI+0.5D0*PHISEG)))
              PHI=PHI-DBLE(NTRSEG-1)*PHISEG
              IF (message) THEN
                WRITE(0,*) 'CHECK THAT THIS WORKS FOR FULL TOROIDAL '//
     .                     'GRID'
                message = .FALSE.
              ENDIF
              STOP 'FIX THIS. CHECK BPORT CASES. PERHAPS BUT IS NEW.'
c              STOP 'CHECK THAT THIS WORKS FOR FULL TOROIDAL GRID'

c...TEMPORARY FIX FOR BAD PHI FROM ADDITIONAL SURFACE
c   SOURCES THAT ARE INFINITE IN EXTENT - THESE SOURCES
C   ARE NOT GENERALLY USEABLE BECAUSE OF THE PHI PROBLEM
              IF (NTRSEG.LT.1.OR.NTRSEG.GT.NTTRA-1) THEN
                PHI = 0.0D0
                NTRSEG=2
                IF (NNOTIFY.EQ.0) THEN
                  NNOTIFY=1
                  WRITE(0,*) 
                  WRITE(0,*) '***********************'
                  WRITE(0,*) '* OVERRIDE OF NTRSEG *'
                  WRITE(0,*) '***********************'
                  WRITE(0,*) 
                ENDIF
              ENDIF

            ENDIF
            PHI=DMAX1(-0.49D0*PHISEG,DMIN1(0.49D0*PHISEG,PHI))
            Z0=X0*DTAN(PHI)
          ENDIF
        ENDIF
        IF (OPTVAC.GT.0) THEN
          ILOSS=0
2001      IF (NLTRA) THEN
            IF (NLTOR) THEN
            ELSE
              TOR=(PHI+DBLE(NTRSEG-1)*PHISEG)*RADDEG
c...          Special case for (almost) full toroidal grid:
              IF (NTRSEG.EQ.1.AND.TOR.LT.0.0D0) TOR = TOR + 360.0D0
            ENDIF
          ELSE
            TOR=Z0
          ENDIF
          NACELL=CHKVAC(-1,NASOR(NLSF,ISTRA),X0,Y0,TOR,4,NPANU)

c          WRITE(0,*) 'HASOR:',NACELL,Y0,TOR,NTRSEG

          IF (NACELL.EQ.-1.OR.NACELL.EQ.-2) THEN
            WRITE(0,*) 'COULD NOT FIND ADDITIONAL CELL WHEN '//
     .                 'LAUNCHING SURFACE NEUTRAL'
            WRITE(6,*) 'COULD NOT FIND ADDITIONAL CELL WHEN '//
     .                 'LAUNCHING SURFACE NEUTRAL'
c TRY A NEW Z0 VALUE -- THE SEARCH ROUTINE SHOULD REALLY BE IMPROVED
            IF (NLTRA) THEN
              IF (NLTOR) THEN
              ELSE
c...            Move the launch point slightly:
                PHI=PHI+0.001D0*DSIGN(1.0D0,RANF_EIRENE()-0.5D0)
                PHI=DMAX1(-0.49D0*PHISEG,DMIN1(0.49D0*PHISEG,PHI))
                Z0=X0*DTAN(PHI)
              ENDIF
            ELSE
              Z0=ZAA*RANF_EIRENE() 
            ENDIF
            ILOSS=ILOSS+1
            IF (ILOSS.EQ.10) THEN
              WRITE(6,*) 'ERROR: SOURCE SEEMS POORLY DEFINED'
              NACELL=1
            ELSE
              GOTO 2001
            ENDIF
          ENDIF
          NRCELL=0
          NBLOCK=NBMLTP
          IPOLG=0
        ELSE
          WRITE(6,*) 'ERROR: VACUUM GRID NOT DEFINED'
          CALL GREND
        ENDIF
c slmod end
      ELSEIF (NRSOR(NLSF,ISTRA).GT.0.AND.NASOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NRSOR
C  IPOLG  IS EXPLICITLY DEFINED BY INPUT VARIABLE NISOR
C  NBLOCK IS EXPLICITLY DEFINED BY INPUT VARIABLE NBSOR
C  NACELL=0
        NRCELL=NRSOR(NLSF,ISTRA)
        NBLOCK=NBSOR(NLSF,ISTRA)
        IPOLG=NISOR(NLSF,ISTRA)
        NACELL=0
      ELSEIF (NRSOR(NLSF,ISTRA).EQ.0.AND.NASOR(NLSF,ISTRA).EQ.0) THEN
C  NRCELL IS COMPUTED IN STANDARD MESH
C  IPOLG IS COMPUTED IN STANDARD MESH
C  NBLOCK IS EXPLICITLY DEFINED BY INPUT VARIABLE NBSOR
C  NACELL=0
        IF (NLSRFX) THEN
          NRCELL=MIN0(NR1STM,MRSURF)
          IAN=MRSURF
          NDUM=LEARC1(X0,Y0,Z0,IPOLG,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .        'SAMSRF      ')
        ELSEIF (NLSRFY) THEN
          IPOLG=MIN0(NP2NDM,MPSURF)
          IAN=MPSURF
          NRCELL=LEARC1(X0,Y0,Z0,IDUM,IAN,IEN,NLSRFX,NLSRFY,NPANU,
     .                  'SAMSRF      ')
        ELSE
          NRCELL=LEARC1(X0,Y0,Z0,IPOLG,1,NR1STM,NLSRFX,NLSRFY,NPANU,
     .                  'SAMSRF      ')
        ENDIF
        NACELL=0
        NBLOCK=NBSOR(NLSF,ISTRA)
      ELSEIF (NRSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NRCELL IS FOUND FROM STEPFUNCTION DATA
C  IPOLG IS FOUND FROM STEPFUNCTION DATA
C  NBLOCK IS FOUND FROM STEPFUNCTION DATA
C  NACELL IS FOUND FROM STEPFUNCTION DATA
        NRCELL=IRSTEP(ISTEP,IINDEX)
        IPOLG =IPSTEP(ISTEP,IINDEX)
c slmod begin - tr - new
c GERMANY:

        IF (NLTRA) THEN
c...      Over-ride toroidal launch coordinate:
          IF (NLTOR) THEN
          ELSE
            PHISEG=2.0D0*PIA/DBLE(NTTRA-1)
            IF (ILBLCK(NLIMI).EQ.998) THEN
c...          Periodic toroidal boundaries detected:
              SEG1=DBLE(ILTOR(NLIMI-1))-1.0D0
              SEG2=DBLE(ILTOR(NLIMI  ))-1.0D0
              IF (SEG1.GT.SEG2) SEG1=SEG1-DBLE(NTTRA-1)
              PHI1=ATAN2(P1(3,NLIMI-1),P1(1,NLIMI-1))+SEG1*PHISEG
              PHI2=ATAN2(P1(3,NLIMI  ),P1(1,NLIMI  ))+SEG2*PHISEG
c...          Special case for (almost) full toroidal grid:
              IF (SEG2.EQ.0.0D0.AND.PHI2.LT.0.0D0) PHI2 = PHI2 + PI2A
            ELSE
              PHI1=0.0D0
              PHI2=2.0D0*PIA
            ENDIF
            PHI=PHI1+DMAX1(0.001D0,DMIN1(0.999D0,RANF_EIRENE()))*
     .               (PHI2-PHI1)
            NTRSEG=INT((PHI+0.5D0*PHISEG)/PHISEG)+
     .             MAX(0,NINT(DSIGN(1.0D0,PHI+0.5D0*PHISEG)))
c...        Special case for (almost) full toroidal grid:
            IF (NTRSEG.EQ.NTTRA) THEN
c              WRITE(0,*) 'DEBUG A:',phi1*RADDEG,phi2*RADDEG
c              WRITE(0,*) 'DEBUG A:',phi*RADDEG,ntrseg
c              IF (ntrseg.EQ.61) STOP 'BAD'
c              IF (phi*180.0/3.1415.GT.357.0) STOP 'EXAMPLE'
              NTRSEG=1
              PHI=PHI-PI2A
            ENDIF
            PHI=PHI-DBLE(NTRSEG-1)*PHISEG
            PHI=DMAX1(-0.49D0*PHISEG,DMIN1(0.49D0*PHISEG,PHI))
            Z0=X0*DTAN(PHI)
            IF (NTRSEG.LT.1) NTRSEG=NTRSEG+NTTRA-1
          ENDIF
        ENDIF

c               WRITE(0,*) '----->:',SEG1,SEG2
c               WRITE(0,*) 'LAUNCH:',PHI1*180.0/PIA,PHI2*180.0/PIA  
c               WRITE(0,*) 'LAUNCH:',PHI*180/PIA,PHI3*180.0/PIA
c               WRITE(0,*) 'LAUNCH:',PHISEG*180.0/PIA,NTRSEG

        IF     (NBSOR(NLSF,ISTRA).EQ.999.AND.NLMLT) THEN
c...      Do not allow the particle to be launched from the gap
c         in the outer target:

          STATUS=.FALSE.
          DO WHILE (.NOT.STATUS)
            STATUS=.TRUE.
            IF (IPOLG.EQ.141.AND.EIRNTRANS.GT.0.AND.CHKTRA(Z0,-1)) THEN
c...          This IF condition is specific to grid SL2:
              DO I1=1,EIRNTRANS              
                IF (.NOT.STATUS) CYCLE
                IND=IDNINT(EIRTRANS(I1,1))
                IF (NRCELL.GE.IRPTA(IND,1).AND.
     .              NRCELL.LT.IRPTE(IND,1)) THEN
                  IF (NLTRZ) THEN
c...                Find a new Z value randomly along the toroidal length:
c                    WRITE(0,*) 'MOVING LAUNCH',NRCELL,IND,Z0
                    Z0=ZAA*RANF_EIRENE() 
                  ELSEIF (NLTRA) THEN
c...                Launch the particle beside the gap in the target, to reflect
c                   the bevel geometry:
                    PHISEG=2.0D0*PIA/DBLE(NTTRA-1)
                    PHI=1.001*EIRTRANS(I1,3)*DEGRAD
                    NTRSEG=INT((PHI+0.5D0*PHISEG)/PHISEG)+
     .                     MAX(0,NINT(DSIGN(1.0D0,PHI+0.5D0*PHISEG)))
c...                Special case for (almost) full toroidal grid:
                    IF (NTRSEG.EQ.NTTRA) THEN
                      WRITE(0,*) 'BIG ANGLE SHIFT A'
                      NTRSEG=1 
                      PHI=PHI-PI2A
                    ENDIF
                    PHI=PHI-DBLE(NTRSEG-1)*PHISEG
                    PHI=DMAX1(-0.49D0*PHISEG,DMIN1(0.49D0*PHISEG,PHI))
                    Z0=X0*DTAN(PHI)
                  ELSE
                    STOP 'DEVELOPMENT'
                  ENDIF
                  STATUS=.FALSE.
                ENDIF
              ENDDO
            ENDIF
          ENDDO
          IF (NLTRA) THEN
            IF (NLTOR) THEN
            ELSE
              CALL CHKSTD(PHI,NBLOCK)
c              WRITE(0,*) 'NBLOCK:',phi/degrad,nblock
            ENDIF
          ELSE
            CALL CHKSTD(Z0,NBLOCK)
          ENDIF
        ELSEIF (NBSOR(NLSF,ISTRA).GT.0) THEN
          NBLOCK=NBSOR(NLSF,ISTRA)
        ELSE
          NBLOCK=IBSTEP(ISTEP,IINDEX)
        ENDIF
c
c        NBLOCK=IBSTEP(ISTEP,IINDEX)
c slmod end
        NACELL=IASTEP(ISTEP,IINDEX)
      ELSEIF (NRSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NRCELL IS TRANSFERRED FROM SUBR. SAMUSR
C  IPOLG IS TRANSFERRED FROM SUBR. SAMUSR
C  NBLOCK IS TRANSFERRED FROM SUBR. SAMUSR
C  NACELL IS TRANSFERRED FROM SUBR. SAMUSR
        NRCELL=IRUSR
        NACELL=IAUSR
        NBLOCK=IBUSR
        IPOLG =IPUSR
      ELSE
        GOTO 999
      ENDIF
C
      NTCELL=1
      IF (NLTOR.AND.NACELL.EQ.0) THEN
        IF (NLTRZ) THEN
          IF (NTSOR(NLSF,ISTRA).GT.0) THEN
C  NTCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NTSOR
            NTCELL=NTSOR(NLSF,ISTRA)
          ELSEIF (NTSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NTCELL IS FOUND FROM STEPFUNCTION DATA
            NTCELL=ITSTEP(ISTEP,IINDEX)
          ELSEIF (NTSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NTCELL IS TRANSFERRED FROM SUBR. SAMUSR
            NTCELL=ITUSR
          ELSEIF (NTSOR(NLSF,ISTRA).EQ.0) THEN
C  NTCELL IS COMPUTED IN STANDARD MESH
            NTCELL=LEARCA(Z0,ZSURF,1,NT3RD,1,'SAMSRF      ')
          ELSE
            GOTO 999
          ENDIF
        ELSEIF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
          IF (ILTR.GT.0) THEN
C  Z0 IS A CARTHESIAN CO-ORDINATE IN LOCAL SYSTEM ILTOR=ILTR
C  FIND PHI,NTCELL AND THEN X0,Z0 IN NTCELL
            CALL FZRTOR(X0,Z0,ILTR,XR,PHI,NT,.FALSE.,0)
            NTCELL=NT
            IF (NTCELL.NE.ILTR)
     .        CALL FZRTRI(X0,Z0,NTCELL,XR,PHI,NTCELL)
          ELSEIF (ILTR.EQ.0) THEN
C  FIND Z0,NTCELL FROM X01,PHI
            NTCELL=LEARCA(PHI,ZSURF,1,NT3RD,1,'SAMSRF      ')
            IF (NTCELL.LE.0.OR.NTCELL.GT.NT3RDM) THEN
              WRITE (6,*) 'NTCELL OUT OF RANGE IN SAMSRF '
              WRITE (6,*) PHI,ZHALF
              CALL EXIT
            ENDIF
            X01=X0+RMTOR
            CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
          ENDIF
        ELSEIF (NLTRT) THEN
          WRITE (6,*) 'NLTRT: TO BE WRITTEN IN SAMSRF '
          CALL EXIT
        ENDIF
      ELSE
C       IF (NLTRZ) THEN
C  ALL DONE
        IF (NLTRA) THEN
C  NTSOR NOT AVAILABLE FOR NLTRA OPTION
          IF (ILTR.GT.0) THEN
C  Z0 IS A CARTHESIAN CO-ORDINATE IN LOCAL SYSTEM ILTOR
C  FIND PHI,NT AND THEN X0,Z0 IN CELL NT
            CALL FZRTOR(X0,Z0,ILTR,XR,PHI,NT,.FALSE.,0)
            IF (NT.NE.ILTR)
     .        CALL FZRTRI(X0,Z0,NT,XR,PHI,NT)
          ELSEIF (ILTR.EQ.0) THEN
C  FIND Z0, NT,  FROM X0,PHI
            NT=LEARCA(PHI,ZSURF,1,NTTRA,1,'SAMSRF      ')
            IF (NT.LE.0.OR.NT.GT.NTTRAM) THEN
              WRITE (6,*) 'NT OUT OF RANGE IN SAMSRF '
              WRITE (6,*) PHI,ZFULL
              CALL EXIT
            ENDIF
            X01=X0+RMTOR
c slmod begin - tr
c...TEMP!  WHAT IS UP WITH FZRTRI?  JUST ADD SEG_DEG / 2 to PHI?
c...not setting Z0 here, since I currently set it above for the
c   sources I am using, and FZTRI does not seem to be working properly (in my little world)
            IF (NLTOR) THEN
              CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
            ELSE
            ENDIF
c
c            CALL FZRTRI(X0,Z0,NT,X01,PHI,NT)
c slmod end
          ENDIF
        ELSEIF (NLTRT) THEN
          WRITE (6,*) 'NLTRT: TO BE WRITTEN IN SAMSRF '
          CALL EXIT
        ENDIF
      ENDIF
C
      NPCELL=1
      IF (NLPOL.AND.NACELL.EQ.0) THEN
        IF (NPSOR(NLSF,ISTRA).GT.0) THEN
C  NPCELL IS EXPLICITLY DEFINED BY INPUT VARIABLE NPSOR
          NPCELL=NPSOR(NLSF,ISTRA)
        ELSEIF (NPSOR(NLSF,ISTRA).LT.0.AND.ISTEP.GT.0) THEN
C  NPCELL IS FOUND FROM STEPFUNCTION DATA
          NPCELL=IPSTEP(ISTEP,IINDEX)
        ELSEIF (NPSOR(NLSF,ISTRA).LT.0.AND.ISTEP.LT.0) THEN
C  NPCELL IS TRANSFERRED FROM SUBR. SAMUSR
          NPCELL=IPUSR
        ELSEIF (NPSOR(NLSF,ISTRA).EQ.0) THEN
C  NPCELL IS COMPUTED IN STANDARD MESH
          IF (LEVGEO.EQ.1) THEN
            NPCELL=LEARCA(Y0,PSURF,1,NP2ND,1,'SAMSRF')
          ELSEIF (LEVGEO.EQ.2) THEN
            IF (NLCRC) THEN
              WINK=MOD(ATAN2(Y0,X0)+PI2A-PSURF(1),PI2A)+PSURF(1)
              NPCELL=LEARCA(WINK,PSURF,1,NP2ND,1,'SAMSRF')
            ELSE
              IF (NLSRFY) THEN
                NPCELL=MIN0(NP2NDM,MPSURF)
              ELSE
                NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'SAMSRF')
              ENDIF
            ENDIF
          ELSEIF (LEVGEO.EQ.3) THEN
            IF (NLSRFY) THEN
              NPCELL=MIN0(NP2NDM,MPSURF)
            ELSE
              NPCELL=LEARC2(X0,Y0,NRCELL,NPANU,'SAMSRF')
            ENDIF
          ELSE
            WRITE (6,*) 'ERROR EXIT FROM SAMSRF. NLPOL ',LEVGEO
            CALL EXIT
          ENDIF
        ELSE
          GOTO 999
        ENDIF
      ENDIF
C
      NBLOCK=MAX0(1,NBLOCK)
      NBLOCK=MIN0(NBLOCK,NBMLT)
      IF (NRCELL.GT.0) NACELL=0
      IF (NACELL.GT.0) NBLOCK=NBMLTP
      NBLCKA=NSTRD*(NBLOCK-1)+NACELL
      NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
      IF (ISTEP.GT.0) THEN
        TEWL=TESTEP(ISTEP,IINDEX)
        DO 3010 IPLS=1,NPLSI
          TIWL(IPLS)=TISTEP(IPLS,ISTEP,IINDEX)
          VXWL(IPLS)=VXSTEP(IPLS,ISTEP,IINDEX)
          VYWL(IPLS)=VYSTEP(IPLS,ISTEP,IINDEX)
          VZWL(IPLS)=VZSTEP(IPLS,ISTEP,IINDEX)
          DIWL(IPLS)=DISTEP(IPLS,ISTEP,IINDEX)
3010    CONTINUE
      ELSEIF (ISTEP.LE.0) THEN
        TEWL=TEIN(NCELL)
        DO 3020 IPLS=1,NPLSI
          TIWL(IPLS)=TIIN(IPLS,NCELL)
          VXWL(IPLS)=VXIN(IPLS,NCELL)
          VYWL(IPLS)=VYIN(IPLS,NCELL)
          VZWL(IPLS)=VZIN(IPLS,NCELL)
          DIWL(IPLS)=DIIN(IPLS,NCELL)
3020    CONTINUE
      ENDIF
C
C  SET ANALOG SPECIES INDEX DISTRIBUTION WEISPZ
C
      IF (NSPEZ(ISTRA).LE.0) THEN
        IF (ISTEP.GT.0) THEN
C  WEISPZ FROM STEP FUNCTION
          DO 4100 ISPZ=NSPSTI(ISTEP),NSPSTE(ISTEP)
            WEISPZ(ISPZ)=FLSTEP(ISPZ,ISTEP,IINDEX)/
     .                   FLSTEP(0,   ISTEP,IINDEX)
4100      CONTINUE
          DO ISPZ=1,NSPSTI(ISTEP)-1
            WEISPZ(ISPZ)=0.D0
          ENDDO
          DO ISPZ=NSPSTE(ISTEP)+1,NSPZ
            WEISPZ(ISPZ)=0.D0
          ENDDO
        ELSE
C  WEISPZ NOT DEFINED
        ENDIF
      ENDIF
C
      IF (output) WRITE(0,*) 'MARK: LEAVING SAMSF1'
      RETURN
991   CONTINUE
      WRITE (6,*) ' ERROR IN SAMSRF '
      WRITE (6,*) 'SPECIES INDEX DISTRIBUTION NOT KNOWN'
      CALL EXIT
992   CONTINUE
      WRITE (6,*) ' ERROR IN SAMSRF '
      WRITE (6,*) 'INDIM, LEVGEO: ',INDIM(NLSF,ISTRA),LEVGEO
      WRITE (6,*) ' THIS CASE IS TO BE WRITTEN '
      CALL EXIT
993   CONTINUE
      WRITE (6,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (6,*) 'SOURCE ON STANDARD SURFACE BUT INVALID "JCALC"'
      WRITE (6,*) 'CHANGE INPUT FLAG "INDTEC"'
      CALL EXIT
994   CONTINUE
      WRITE (6,*) 'ERROR IN SAMPLE. EXIT CALLED'
      WRITE (6,*) 'ARCLENGTH REQUIRED ON STANDARD SURFACE BUT LEVGEO'
      WRITE (6,*) 'IS NOT = 3. THIS OPTION IS STILL TO BE WRITTEN'
      CALL EXIT
995   CONTINUE
      WRITE (6,*) ' ERROR IN SAMSRF '
      WRITE (6,*) 'INDIM, LEVGEO: ',INDIM(NLSF,ISTRA),LEVGEO
      WRITE (6,*) ' AND NO STEP FUNCTION FOR COMPUTING THE BIRTH PLACE'
      WRITE (6,*) ' THIS CASE IS TO BE WRITTEN '
      CALL EXIT
996   CONTINUE
      WRITE (6,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (6,*) 'ARCLENGTH BL GREATER THAN THE LENGTH OF THE '
      WRITE (6,*) 'POLYGONE    BL = ',BL
      CALL EXIT
997   CONTINUE
      WRITE (6,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (6,*) 'CHECK INPUT OF SORLIM, BECAUSE EIRENE TRIES TO'
      WRITE (6,*) 'COMPUTE MORE THAN ONE VARIABLES FROM THE SURFACE'
      WRITE (6,*) 'EQUATION'
      CALL EXIT
998   CONTINUE
      WRITE (6,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (6,*) 'X0,Y0,Z0 ',X0,Y0,Z0
      WRITE (6,*) 'BUT OUTSIDE THE VALID AREA OF THIS SURFACE'
      CALL EXIT
999   CONTINUE
      WRITE (6,*) 'ERROR IN SAMSRF. EXIT CALLED'
      WRITE (6,*) 'INITIAL CELL NUMBER INVALID OR DET NEGATIVE'
      WRITE (6,*) 'X0,Y0,Z0,DET ',X0,Y0,Z0,DET
      WRITE (6,*) 'ISTEP ',ISTEP
      WRITE (6,*) 'NBLOCK,NACELL,NRCELL ',NBLOCK,NACELL,NRCELL
      WRITE (6,*) 'NPCELL,NTCELL,IPOLG ',NPCELL,NTCELL,IPOLG
      CALL EXIT
      END
C
      SUBROUTINE SAMVOL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'CGRID'
      INCLUDE 'CGEOM'
      INCLUDE 'CPOLYG'
      INCLUDE 'CCONA'
      INCLUDE 'CLOGAU'
      INCLUDE 'CTRCEI'
      INCLUDE 'COMSOU'
      INCLUDE 'COMUSR'
      INCLUDE 'CZT1'
      INCLUDE 'COMXS'
      INCLUDE 'CSPEI'
      INCLUDE 'CTRIG'
c slmod begin - not tr
      INCLUDE 'CLGIN'
      INCLUDE 'CADGEO'
      COMMON /MULCOM/ IOPT1
c slmod end
C
      DIMENSION TIWL(NPLS),DIWL(NPLS),
     .          VXWL(NPLS),VYWL(NPLS),VZWL(NPLS)
      DIMENSION WEISPZ(*)
      DIMENSION FREC(0:NREC,0:NRAD)
      DIMENSION VSOURC(NSTRA,0:NRAD),ISOURC(NSTRA,0:NRAD),
     .          ICMX(0:NSRFS,NSTRA)
      REAL*8    MOM(0:NPLS,0:NREC)
      DIMENSION RQ21(N1ST),PS21(N2ND)
      DIMENSION ASIMP(2,NRAD),D(3)
      DIMENSION AREAP(N1ST,N2NDPLG)
      EQUIVALENCE (AREA(1),AREAP(1,1))
      SAVE
C
C  AT ENTRY SAMVL0:
C    DEFINE THE CUMULATIVE DISTRIBUTION FUNCTION
C    FREC(IRRC,ICELL) FOR EACH VOLUME SOURCE DISTRIBUTION, FOR SAMPLING
C    THE CELL INDEX ICELL OF THE VOLUME SOURCE PARTICLE.
C
C    A FEW GEOMETRICAL CONSTANTS FOR RANDOM SAMPLING
C    OF THE STARTING POINT IN EACH CELL ARE COMPUTED
C
C    THE SOURCE STRENGTH FLUX(ISTRA) IS MODIFIED FOR THE
C    STRATA WITH NLVOL(ISTRA)=.TRUE.
C
C  AT ENTRY SAMVL1:
C    THE INITIAL CO-ORDINATES OF A TEST FLIGHT ARE SAMPLED,
C    AND THE CELL NUMBERS ARE COMPUTED
C
      ENTRY SAMVL0
C
      DO 1 IREC=0,NREC
        DO  J=0,NSBOX
          FREC(IREC,J)=0.
        ENDDO
        DO 1 IPLS=0,NPLS
          SREC(IPLS,IREC)=0.
1     CONTINUE
C
      DO 2 IPLS=1,NPLSI
        IF (LGPRC(IPLS,0).EQ.0) GOTO 2
        DO 3 IIRC=1,NPRCI(IPLS)
          IRRC=LGPRC(IPLS,IIRC)
          DO 3 J=1,NSBOX
            SUM=0.
C  EXCLUDE DEAD CELLS (GRID CUTS, ISOLATED CELLS FROM COUPLE_.., ETC)
C  EXCLUDE IPLS-VACUUM CELLS
            IF (NSTGRD(J).EQ.0.AND..NOT.LGVAC(J,IPLS)) THEN
              IF (NSTORDR >= NRAD) THEN
c slmod begin - tr
c...            If cylcindrical geometry is being used, then
c               still use toroidal volumes when calculating the
c               volume recombination source rate:
                IF (NLTRZ) THEN
                  SUM=TABRC1(IRRC,J)*DIIN(IPLS,J)*VOL2(J)*ELCHA
                ELSE
                  SUM=TABRC1(IRRC,J)*DIIN(IPLS,J)*VOL (J)*ELCHA
                ENDIF
c...            Scale by local opacity multiplier:
                IF (IOPT1.EQ.2) SUM=SUM*TABRCM(IRRC,J)
c
c                SUM=TABRC1(IRRC,J)*DIIN(IPLS,J)*VOL(J)*ELCHA
c slmod end
              ELSE
                SUM=FTABRC1(IRRC,J)*DIIN(IPLS,J)*VOL(J)*ELCHA
              ENDIF
            ENDIF
            FREC(IRRC,J)=FREC(IRRC,J-1)+SUM
            SREC(IPLS,IRRC)=SREC(IPLS,IRRC)+SUM
3       CONTINUE
2     CONTINUE
C  SUM OVER SPECIES AND RECOMBINATION TYP INDICES
      DO 4 IPLS=1,NPLSI
        IF (LGPRC(IPLS,0).EQ.0) GOTO 4
        DO 5 IIRC=1,NPRCI(IPLS)
          IRRC=LGPRC(IPLS,IIRC)
          SREC(IPLS,0)=SREC(IPLS,0)+SREC(IPLS,IRRC)
          SREC(0,IRRC)=SREC(0,IRRC)+SREC(IPLS,IRRC)
          SREC(0,0)   =SREC(0,0)   +SREC(IPLS,IRRC)
          DO 5 J=1,NSBOX
            FREC(0,J)=FREC(0,J)+FREC(IRRC,J)
5       CONTINUE
4     CONTINUE
C
C
      IF (TRCSOU) THEN
        DO 9 IPLS=1,NPLSI
          EIO(IPLS,0)=0.
          EEL(IPLS,0)=0.
          MOM(IPLS,0)=0.
          DO 9 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            EIO(IPLS,IRRC)=0.
            EEL(IPLS,IRRC)=0.
            MOM(IPLS,IRRC)=0.
9       CONTINUE
C
        DO 7 IPLS=1,NPLSI
          CNDYNP=AMUA*RMASSP(IPLS)
          IF (LGPRC(IPLS,0).EQ.0) GOTO 7
          DO 6 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            DO 6 J=1,NSBOX
              REC=FREC(IRRC,J)-FREC(IRRC,J-1)
              EIO(IPLS,IRRC)=EIO(IPLS,IRRC)-
     .                      (1.5*TIIN(IPLS,J)+EDRIFT(IPLS,J))*REC
              EIO(IPLS,0)   =EIO(IPLS,0)-
     .                      (1.5*TIIN(IPLS,J)+EDRIFT(IPLS,J))*REC
              VPARA=VXIN(IPLS,J)*BXIN(J)+VYIN(IPLS,J)*BYIN(J)+
     .              VZIN(IPLS,J)*BZIN(J)
              PIADD=VPARA*CNDYNP*SIGN(1.D0,VPARA)
              MOM(IPLS,IRRC)=MOM(IPLS,IRRC)-PIADD*REC
              MOM(IPLS,0)   =MOM(IPLS,0   )-PIADD*REC
6         CONTINUE
C
          DO 8 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            DO 8 J=1,NSBOX
              IF (NSTORDR >= NRAD) THEN
                EELRC = EELRC1(IRRC,J)
              ELSE
                EELRC = FEELRC1(IRRC,J)
              END IF
              EEL(IPLS,IIRC)=EEL(IPLS,IIRC)+
     .               EELRC*DIIN(IPLS,J)*VOL(J)*ELCHA
              EEL(IPLS,0)=EEL(IPLS,0)+
     .               EELRC*DIIN(IPLS,J)*VOL(J)*ELCHA
8         CONTINUE
C
7       CONTINUE
        CALL LEER(1)
        WRITE (6,*) 'DIAGNOSTICS FROM SUBR. SAMVOL: '
        CALL LEER(1)
        WRITE (6,*) 'RECOMBINATION ION PARTICLE LOSS (AMP): '
        DO 10 IPLS=1,NPLSI
          DO 11 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASJ2R('IPLS,IRRC,SREC          ',
     .                   IPLS,IRRC,-SREC(IPLS,IRRC))
11        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASJ2R('IPLS,TOT.,SREC(IPLS,0)  ',
     .                   IPLS,0,-SREC(IPLS,0))
          ENDIF
10      CONTINUE
        CALL LEER(1)
        WRITE (6,*) 'RECOMBINATION ION ENERGY LOSS (WATT): '
        DO 12 IPLS=1,NPLSI
          DO 13 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASJ2R('IPLS,IRRC,EIO           ',
     .                   IPLS,IRRC,EIO(IPLS,IRRC))
13        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASJ2R('IPLS,TOT.,EIO(IPLS,0)   ',
     .                   IPLS,0,EIO(IPLS,0))
          ENDIF
12      CONTINUE
        CALL LEER(1)
        WRITE (6,*) 'RECOMBINATION ELECTRON ENERGY LOSS (WATT): '
        DO 14 IPLS=1,NPLSI
          DO 15 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASJ2R('IPLS,IRRC,EEL           ',
     .                   IPLS,IRRC,EEL(IPLS,IRRC))
15        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASJ2R('IPLS,TOT.,EEL(IPLS,0)   ',
     .                   IPLS,0,EEL(IPLS,0))
          ENDIF
14      CONTINUE
        CALL LEER(1)
        WRITE (6,*) 'RECOMBINATION PARALLEL MOMENTUM LOSS : '
        DO 16 IPLS=1,NPLSI
          DO 17 IIRC=1,NPRCI(IPLS)
            IRRC=LGPRC(IPLS,IIRC)
            CALL MASJ2R('IPLS,IRRC,MOM           ',
     .                   IPLS,IRRC,MOM(IPLS,IRRC))
17        CONTINUE
          IF (NPRCI(IPLS).GT.1) THEN
            CALL MASJ2R('IPLS,TOT.,MOM(IPLS,0)   ',
     .                   IPLS,0,MOM(IPLS,0))
          ENDIF
16      CONTINUE
        CALL LEER(1)
      ENDIF
C
C  SET TOTAL SOURCE STRENGTH FOR STRATA WITH NLVOL(ISTRA)=.TRUE.
C  AND SORLIM.GT.0 (VOLUME RECOMBINATION SOURCE, NLPLS=TRUE)
      DO 50 ISTRA=1,NSTRAI
        IF (output)
     .  WRITE(0,*) 'MARK: SAMVOL: 01 ISTRA,NLVOL,NLPLS = ',
     .             ISTRA,NLVOL(ISTRA),NLPLS(ISTRA)
        IF (NLVOL(ISTRA).AND.NLPLS(ISTRA)) THEN
          IPLS=NSPEZ(ISTRA)
          IF (IPLS.LE.0.OR.IPLS.GT.NPLSI) THEN
            WRITE (6,*) 'SOURCE SPECIES INDEX NSPEZ OUT OF RANGE'
            WRITE (6,*) 'ISTRA, NSPEZ(ISTRA) ',ISTRA,NSPEZ(ISTRA)
            CALL EXIT
          ENDIF
          SUMM=0.D0
          EISUMM=0.D0
          VSOURC(ISTRA,0)=0.D0
          ICMX(0,ISTRA)=0
          IC=0
          DO 53 ISRFSI=1,NSRFSI(ISTRA)
            IF (SORLIM(ISRFSI,ISTRA).GT.0.) THEN
              J=ISRFSI
              I=ISTRA
              IF (INGRDA(J,I,1).LE.0..OR.INGRDE(J,I,1).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (6,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (6,*) 'NEW INPUT FOR INGRDA(.,.,1),INGRDE(.,.,1)'
                WRITE (6,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(J,I,1)=1
                INGRDE(J,I,1)=MAX0(1,NR1ST)
                CALL LEER(1)
              ENDIF
              IF (INGRDA(J,I,2).LE.0..OR.INGRDE(J,I,2).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (6,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (6,*) 'NEW INPUT FOR INGRDA(.,.,2),INGRDE(.,.,2)'
                WRITE (6,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(J,I,2)=1
                INGRDE(J,I,2)=MAX0(1,NP2ND)
                CALL LEER(1)
              ENDIF
              IF (INGRDA(J,I,3).LE.0..OR.INGRDE(J,I,3).LE.0.D0) THEN
                CALL LEER(1)
                WRITE (6,*) 'WARNING FROM SAMVL0, ISTRA= ',ISTRA
                WRITE (6,*) 'NEW INPUT FOR INGRDA(.,.,3),INGRDE(.,.,3)'
                WRITE (6,*) 'AUTOMATIC CORRECTION CARRIED OUT '
                INGRDA(J,I,3)=1
                INGRDE(J,I,3)=MAX0(1,NT3RD)
                CALL LEER(1)
              ENDIF
            ENDIF
C  REDEFINE SREC, FREC TO ACCOUNT FOR INGRDA(ISRFSI,ISTRA,...)
C                                     INGRDE(ISRFSI,ISTRA,...)
            IF (SORLIM(ISRFSI,ISTRA).LT.0) THEN
              ISR=ISRFSI
              ISTR=ISTRA
c slmod begin - not tr (already fixed)
c              CALL SM0USR(ISR,ISTR)
c
              CALL SM0USR(ISR,ISTR,
     .                    SORAD1(ISR,ISTR),SORAD2(ISR,ISTR),
     .                    SORAD3(ISR,ISTR),SORAD4(ISR,ISTR),
     .                    SORAD5(ISR,ISTR),SORAD6(ISR,ISTR))
c slmod end
            ELSE
              I=ISRFSI
              SUM=0.D0
              EISUM=0.D0
              ICC=0
              IF (NPRCI(IPLS).EQ.0) THEN
                WRITE (6,*) 'NO DEFAULT VOLUME SOURCE DISTRIBUTION'
                WRITE (6,*) 'DEFINED. SUBSTRATUM TURNED OFF'
                WRITE (6,*) 'IPLS,ISRFSI,ISTRA ',IPLS,ISRFSI,ISTRA
                SORWGT(ISRFSI,ISTRA)=0.D0
                GOTO 53
              ENDIF
              IF (NLRAD) THEN
                IR1=MAX0(1,INGRDA(I,ISTRA,1))
                IR2=MIN0(NR1ST,INGRDE(I,ISTRA,1))
              ELSE
                IR1=1
                IR2=2
              ENDIF
              IF (NLPOL) THEN
                IP1=MAX0(1,INGRDA(I,ISTRA,2))
                IP2=MIN0(NP2ND,INGRDE(I,ISTRA,2))
              ELSE
                IP1=1
                IP2=2
              ENDIF
c slmod begin - tr
              NPCNT=NP2T3
c slmod end
              IF (NLTOR) THEN
                IT1=MAX0(1,INGRDA(I,ISTRA,3))
                IT2=MIN0(NT3RD,INGRDE(I,ISTRA,3))
c slmod begin - tr
c...          Needed to have scaling of recombination source using contributions
c             from each NBLOCK:
              ELSEIF (NLMLT) THEN
                IT1=1
                IT2=NBMLT+1
                NPCNT=NP2ND
c slmod end
              ELSE
                IT1=1
                IT2=2
              ENDIF
C
              ISTEP=SORIND(ISRFSI,ISTRA)
              DO 52 IIRC=1,NPRCI(IPLS)
                IRRC=LGPRC(IPLS,IIRC)
                IF (ISTEP.NE.IRRC) GOTO 52
C  RECOMBINATION DISTRIBUTION "IRRC" CONTRIBUTES TO THIS SUB-STRATUM
                DO 51 IR=IR1,IR2-1
                  DO 51 IP=IP1,IP2-1
                    DO 51 IT=IT1,IT2-1
c slmod begin - tr
                      NCELL=IR+((IP-1)+(IT-1)*NPCNT)*NR1P2
c
c                      NCELL=IR+((IP-1)+(IT-1)*NP2T3)*NR1P2
c slmod end
                      ADD=FREC(IRRC,NCELL)-FREC(IRRC,NCELL-1)
C  INDIRECT ADDRESSING
                      IF (ADD.GT.0.D0) THEN
                        ICC=ICC+1
                        IC=IC+1
                        IF (IC.GT.NRAD) THEN
                          WRITE (6,*) 'OVERFLOW IN SAMVOL '
                          CALL EXIT
                        ENDIF
                        ISOURC(ISTRA,IC)=NCELL
                        VSOURC(ISTRA,IC)=VSOURC(ISTRA,IC-1)+ADD
                        SUM=SUM+ADD
                        EISUM=EISUM-
     .                    (1.5*TIIN(IPLS,NCELL)+EDRIFT(IPLS,NCELL))*ADD
                      ENDIF
51              CONTINUE
52            CONTINUE
              SORWGT(ISRFSI,ISTRA)=SUM
              CALL LEER(1)
              WRITE (6,*) 'SUB-STRATUM WEIGHT REDEFINED '
              CALL MASJ2R ('ISRFSI,ISTRA,SORWGT     ',ISRFSI,ISTRA,SUM)
              IF (TRCSOU) THEN
                CALL MASJ3 ('IRRC,IPLS,ICC           ',
     .                       IRRC,IPLS,ICC)
                CALL LEER(1)
              ENDIF
              SUMM=SUMM+SUM
              EISUMM=EISUMM+EISUM
              ICMX(ISRFSI,ISTRA)=ICMX(ISRFSI-1,ISTRA)+ICC
            ENDIF
53        CONTINUE
C
          IF (SUMM.GT.0.D0) THEN
            FLUX(ISTRA)=SUMM
            ICTOT=IC
            WRITE (6,*) 'SOURCE STRENGTH REDEFINED '
            CALL MASJR2('ISTRA, FLUX, EIFLUX     ',
     .                   ISTRA,FLUX(ISTRA),EISUMM)
            IF (TRCSOU) CALL MASJ1('ICTOT   ',ICTOT)
            CALL LEER(1)
          ENDIF
        ENDIF
50    CONTINUE
C
C  PREPARE SOME GEOMETRICAL CONSTANTS FOR RANDOM SAMPLING IN STANDARD MESH CELLS
      IF (LEVGEO.EQ.2) THEN
        IF (NLPOL) THEN
          DO 54 IP=1,NP2NDM
            PS21(IP)=PSURF(IP+1)-PSURF(IP)
54        CONTINUE
        ENDIF
        DO 55 IR=1,NR1STM
          RQ21(IR)=RQ(IR+1)-RQ(IR)
55      CONTINUE
      ENDIF
C
      IF (LEVGEO.EQ.3) THEN
        IT=1
        DO 56 IR=1,NR1ST-1
        DO 56 IP=1,NP2ND-1
          IND=IR+((IP-1)+(IT-1)*NP2T3)*NR1P2
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1) THEN
            X1=XVERT(IR,IP  ,1)
            X2=XVERT(IR,IP+1,1)
            X3=XVERT(IR,IP+1,2)
            Y1=YVERT(IR,IP  ,1)
            Y2=YVERT(IR,IP+1,1)
            Y3=YVERT(IR,IP+1,2)
          ELSE
            X1=XPOL(IR,IP)
            X2=XPOL(IR,IP+1)
            X3=XPOL(IR+1,IP+1)
            Y1=YPOL(IR,IP)
            Y2=YPOL(IR,IP+1)
            Y3=YPOL(IR+1,IP+1)
          ENDIF
c
c         X1=XPOL(IR,IP)
c         X2=XPOL(IR,IP+1)
c         X3=XPOL(IR+1,IP+1)
c         Y1=YPOL(IR,IP)
c         Y2=YPOL(IR,IP+1)
c         Y3=YPOL(IR+1,IP+1)
c slmod end
          ASIMP(1,IND)=0.5*(X1*(Y2-Y3)+X2*(Y3-Y1)+X3*(Y1-Y2))
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1) THEN
            X1=XVERT(IR,IP  ,2)
            X2=XVERT(IR,IP  ,1)
            X3=XVERT(IR,IP+1,2)
            Y1=YVERT(IR,IP  ,2)
            Y2=YVERT(IR,IP  ,1)
            Y3=YVERT(IR,IP+1,2)
          ELSE
            X1=XPOL(IR+1,IP)
            X2=XPOL(IR,IP)
            X3=XPOL(IR+1,IP+1)
            Y1=YPOL(IR+1,IP)
            Y2=YPOL(IR,IP)
            Y3=YPOL(IR+1,IP+1)
          ENDIF
c
c          X1=XPOL(IR+1,IP)
c          X2=XPOL(IR,IP)
c          X3=XPOL(IR+1,IP+1)
c          Y1=YPOL(IR+1,IP)
c          Y2=YPOL(IR,IP)
c          Y3=YPOL(IR+1,IP+1)
c slmod end
          ASIMP(2,IND)=0.5*(X1*(Y2-Y3)+X2*(Y3-Y1)+X3*(Y1-Y2))
56      CONTINUE
      ENDIF
C
      RETURN
C
C  AT THIS POINT: CALLED FROM PARTICLE LOOP TO INITIALIZE TEST FLIGHT
C
      ENTRY SAMVL1(NVLM,TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,WEISPZ)
C
C  USER SUPPLIED SOURCE
C
      IF (SORLIM(NVLM,ISTRA).LT.0) THEN
c slmod begin - not tr (already fixed)
c        CALL SM1USR(NVLM,ISTRA,X0,Y0,Z0,
c
        CALL SM1USR(NVLM,X0,Y0,Z0,
     .              SORAD1(NVLM,ISTRA),SORAD2(NVLM,ISTRA),
     .              SORAD3(NVLM,ISTRA),SORAD4(NVLM,ISTRA),
     .              SORAD5(NVLM,ISTRA),SORAD6(NVLM,ISTRA),
c slmod end
     .              IRUSR,IPUSR,ITUSR,IAUSR,IBUSR,
     .              TIWL,TEWL,DIWL,VXWL,VYWL,VZWL,WEISPZ)
        NRCELL=IRUSR
        NPCELL=IPUSR
        NTCELL=ITUSR
        NACELL=IAUSR
        NBLOCK=IBUSR
        NBLCKA=NSTRD*(NBLOCK-1)+NACELL
        NCELL=NRCELL+((NPCELL-1)+(NTCELL-1)*NP2T3)*NR1P2+NBLCKA
C
        MTSURF=0
        NLSRFZ=.FALSE.
        MPSURF=0
        NLSRFY=.FALSE.
        MRSURF=0
        NLSRFX=.FALSE.
        RETURN
      ENDIF
C
C  VOLUME RECOMBINATION SOURCE
C
C  TENTATIVELY ASSUME: A BULK ION WILL BE GENERATED
      LGPART=.TRUE.
      ITYP=4
C
      IF (.NOT.NLPLS(ISTRA)) GOTO 999
C
      ICOUNT=0
100   CONTINUE
      ICOUNT=ICOUNT+1
C
      IPLS=NSPEZ(ISTRA)
C
C  IDENTIFY TYPE "ISTEP" OF REC. PROCESS
C
      ISTEP=SORIND(NVLM,ISTRA)
C
C
C  FIND CELL NUMBER: NCELL
C
      IC1=ICMX(NVLM-1,ISTRA)
      IC2=ICMX(NVLM,ISTRA)
      ZEP1=VSOURC(ISTRA,IC1)+
     .     RANF_EIRENE()*(VSOURC(ISTRA,IC2)-VSOURC(ISTRA,IC1))
      DO 135 ICELL=IC1+1,IC2
        IF (ZEP1.LE.VSOURC(ISTRA,ICELL)) GOTO 136
135   CONTINUE
      GOTO 991
136   CONTINUE
      NCELL=ISOURC(ISTRA,ICELL)
C
      IF (NCELL.GT.NSURF) GOTO 991
C
C  A CELL NUMBER NCELL HAS NOW BEEN SAMPLED
C
      CALL NCELLN(NCELL,NRCELL,NPCELL,NTCELL,NACELL,NBLOCK,
     .            NR1ST,NP2ND,NT3RD,NBMLT,NLRAD,NLPOL,NLTOR)
C
C  FIND TOROIDAL CO-ORDINATE IN NTCELL
C
      IF (.NOT.NLTOR) THEN
        IF (NLTRZ) THEN
c slmod begin - tr
c GERMANY:
c... The recombination source always assigned Z0=0.0, but this
c    is not consistent with the 3D box wth reflecting Z end surfaces,
c    which has a problem with particles intersecting a surface at Z=0.0 (and
c    so the Z value of the bounding surface is 1 mm instead of 0.0):
          Z0=SORAD5(NVLM,ISTRA)+RANF_EIRENE()*(SORAD6(NVLM,ISTRA)-
     .                                  SORAD5(NVLM,ISTRA))

          IF (NBSOR(NVLM,ISTRA).EQ.999.AND.NLMLT) THEN
c            IF (NLTRA) THEN
c              IF (NLTOR) THEN
c              ELSE
c                CALL CHKSTD(0.0D0,0.0D0,PHI,NPANU,NBLOCK)
c              ENDIF
c            ELSE
              


              CALL CHKSTD(Z0,NBLOCK)

c...BUG:
                NBLCKA=NSTRD*(NBLOCK-1)+NACELL


c            ENDIF
          ENDIF
c
c          Z0=0.
c slmod end
        ELSEIF (NLTRA) THEN
c slmod begin - tr - new
          IF (.NOT.NLTOR) THEN
            PHISEG=2.0D0*PIA/DBLE(NTTRA-1)
            IF (ILBLCK(NLIMI).EQ.998) THEN
c...          Periodic toroidal boundaries detected:
              SEG1=DBLE(ILTOR(NLIMI-1))-1.0D0
              SEG2=DBLE(ILTOR(NLIMI  ))-1.0D0
c...          
              IF (SEG1.GT.SEG2) SEG1=SEG1-DBLE(NTTRA-1)
              PHI1=ATAN2(P1(3,NLIMI-1),P1(1,NLIMI-1))+SEG1*PHISEG
              PHI2=ATAN2(P1(3,NLIMI  ),P1(1,NLIMI  ))+SEG2*PHISEG
c...          Special case for (almost) full toroidal grid:
              IF (SEG2.EQ.0.0D0.AND.PHI2.LT.0.0D0) PHI2 = PHI2 + PI2A
            ELSE
              PHI1=0.0D0
              PHI2=2.0D0*PIA
            ENDIF
            PHI=PHI1+DMAX1(0.001D0,DMIN1(0.999D0,RANF_EIRENE()))*
     .               (PHI2-PHI1)
            NTRSEG=INT((PHI+0.5D0*PHISEG)/PHISEG)+
     .             MAX(0,NINT(DSIGN(1.0D0,PHI+0.5D0*PHISEG)))
c...        Special case for (almost) full toroidal grid:
            IF (NTRSEG.EQ.NTTRA) THEN
c              WRITE(0,*) 'DEBUG B:',phi1*RADDEG,phi2*RADDEG
c              WRITE(0,*) 'DEBUG B:',phi*RADDEG,ntrseg
c              IF (ntrseg.EQ.61) STOP 'BAD'
c              IF (phi*180.0/3.1415.GT.357.0) STOP 'EXAMPLE'
              NTRSEG=1
              PHI=PHI-PI2A
            ENDIF
            PHI=PHI-DBLE(NTRSEG-1)*PHISEG
            PHI=DMAX1(-0.45D0*PHISEG,DMIN1(0.45D0*PHISEG,PHI))
            IF (NTRSEG.LT.1) NTRSEG=NTRSEG+NTTRA-1
            IF (NBSOR(NVLM,ISTRA).EQ.999.AND.NLMLT) THEN
              Z0=(X0+RMTOR)*DTAN(PHI)
              CALL CHKSTD(Z0,NBLOCK)

c...BUG (NOT NECESSARILY A REAL ONE): THIS NEEDS TO BE DEFINED?
                NBLCKA=NSTRD*(NBLOCK-1)+NACELL
            ENDIF
            ZRM1=0.
          ELSE
C  TACTICALLY ASSUME: PARTICLE STARTS IN LOCAL TOR. BASIS CELL NO.1
            ZRM1=0.
            PHI=ZRM1+RANF_EIRENE()*ZFULL
C           Z0=??, TO BE FOUND FROM X01,PHI LATER
          ENDIF
c
cC  TACTICALLY ASSUME: PARTICLE STARTS IN LOCAL TOR. BASIS CELL NO.1
c          ZRM1=0.
c          PHI=ZRM1+RANF_EIRENE()*ZFULL
cC         Z0=??, TO BE FOUND FROM X01,PHI LATER
c slmod end
        ELSEIF (NLTRT) THEN
          GOTO 999
        ENDIF
      ELSEIF (NLTOR) THEN
C  SAMPLE IN CELL NTCELL
        IF (NLTRZ) THEN
          Z0=ZSURF(NTCELL)+RANF_EIRENE()*(ZSURF(NTCELL+1)-ZSURF(NTCELL))
        ELSEIF (NLTRT) THEN
          PHI=ZSURF(NTCELL)+RANF_EIRENE()*
     .                      (ZSURF(NTCELL+1)-ZSURF(NTCELL))
C         Z0=??, TO BE FOUND FROM X01,PHI LATER
        ELSEIF (NLTRA) THEN
          ZRM1=ZFULL*(NTCELL-1)
          PHI=ZRM1+RANF_EIRENE()*ZFULL
C         Z0=??, TO BE FOUND FROM X01,PHI LATER
        ENDIF
      ENDIF
C
C  FIND RADIAL AND POLOIDAL CO-ORDINATE
C
      IF (LEVGEO.EQ.1) THEN
        GOTO 999
      ELSEIF (LEVGEO.EQ.2) THEN
        IF (NLCRC) THEN
C  POLOIDAL CO-ORDINATE
          IF (NLPOL) THEN
            WINK=PSURF(NPCELL)+RANF_EIRENE( )*PS21(NPCELL)
          ELSEIF (.NOT.NLPOL) THEN
            WINK=RANF_EIRENE( )*PI2A
          ENDIF
C  RADIAL CO-ORDINATE
          RR=SQRT(RQ(NRCELL)+RANF_EIRENE( )*RQ21(NRCELL))
C
          X0=RR*COS(WINK)
          Y0=RR*SIN(WINK)
        ELSEIF (NLELL) THEN
CDR NOT READY. STRICKLY, PHI AND R ARE CORRELATED. USE
CDR            MARGINAL AND CONDITIONAL DISTRIBUTION F1(R) AND
CDR            F2(PHI, GIVEN R)
C  POLOIDAL CO-ORDINATE
          IF (NLPOL) THEN
            WINK=PSURF(NPCELL)+RANF_EIRENE( )*PS21(NPCELL)
          ELSEIF (.NOT.NLPOL) THEN
            WINK=RANF_EIRENE( )*PI2A
          ENDIF
C  RADIAL CO-ORDINATE
          RR=SQRT(RQ(NRCELL)+RANF_EIRENE( )*RQ21(NRCELL))
C
          RRI=RSURF(NRCELL)
          RRD=RSURF(NRCELL+1)-RRI
          RRN=(RR-RRI)/RRD
C
          ELR=ELL(NRCELL)+RRN*(ELL(NRCELL+1)-ELL(NRCELL))
          EPR=EP1(NRCELL)+RRN*(EP1(NRCELL+1)-EP1(NRCELL))
          X0=RR*COS(WINK)+EPR
          Y0=RR*SIN(WINK)*ELR
        ELSEIF (NLTRI) THEN
          GOTO 999
        ENDIF
      ELSEIF (LEVGEO.EQ.3.OR.LEVGEO.EQ.4) THEN
        IF (LEVGEO.EQ.3) THEN
          IF (.NOT.NLPOL) THEN
            GOTO 999
          ENDIF
          ZEP1=AREAP(NRCELL,NPCELL)*RANF_EIRENE()
          IF (ZEP1.LE.ASIMP(1,NCELL)) THEN
C   PUNKT IN DREIECK 1
c slmod begin - grid - tr
            IF (GRIDOPT.EQ.1) THEN
              X1=XVERT(NRCELL,NPCELL  ,1)
              X2=XVERT(NRCELL,NPCELL+1,1)
              X3=XVERT(NRCELL,NPCELL+1,2)
              Y1=YVERT(NRCELL,NPCELL  ,1)
              Y2=YVERT(NRCELL,NPCELL+1,1)
              Y3=YVERT(NRCELL,NPCELL+1,2)
            ELSE
              X1=XPOL(NRCELL,NPCELL)
              X2=XPOL(NRCELL,NPCELL+1)
              X3=XPOL(NRCELL+1,NPCELL+1)
              Y1=YPOL(NRCELL,NPCELL)
              Y2=YPOL(NRCELL,NPCELL+1)
              Y3=YPOL(NRCELL+1,NPCELL+1)
            ENDIF
c
c            X1=XPOL(NRCELL,NPCELL)
c            X2=XPOL(NRCELL,NPCELL+1)
c            X3=XPOL(NRCELL+1,NPCELL+1)
c            Y1=YPOL(NRCELL,NPCELL)
c            Y2=YPOL(NRCELL,NPCELL+1)
c            Y3=YPOL(NRCELL+1,NPCELL+1)
c slmod end
          ELSE
C   PUNKT IN DREIECK 2
c slmod begin - grid - tr
            IF (GRIDOPT.EQ.1) THEN
              X1=XVERT(NRCELL,NPCELL  ,2)
              X2=XVERT(NRCELL,NPCELL  ,1)
              X3=XVERT(NRCELL,NPCELL+1,2)
              Y1=YVERT(NRCELL,NPCELL  ,2)
              Y2=YVERT(NRCELL,NPCELL  ,1)
              Y3=YVERT(NRCELL,NPCELL+1,2)
            ELSE
              X1=XPOL(NRCELL+1,NPCELL)
              X2=XPOL(NRCELL,NPCELL)
              X3=XPOL(NRCELL+1,NPCELL+1)
              Y1=YPOL(NRCELL+1,NPCELL)
              Y2=YPOL(NRCELL,NPCELL)
              Y3=YPOL(NRCELL+1,NPCELL+1)
            ENDIF
c
c            X1=XPOL(NRCELL+1,NPCELL)
c            X2=XPOL(NRCELL,NPCELL)
c            X3=XPOL(NRCELL+1,NPCELL+1)
c            Y1=YPOL(NRCELL+1,NPCELL)
c            Y2=YPOL(NRCELL,NPCELL)
c            Y3=YPOL(NRCELL+1,NPCELL+1)
c slmod end
          ENDIF
          IPOLG=NPCELL
        ELSEIF (LEVGEO.EQ.4) THEN
          X1=XTRIAN(NECKE(1,NCELL))
          X2=XTRIAN(NECKE(2,NCELL))
          X3=XTRIAN(NECKE(3,NCELL))
          Y1=YTRIAN(NECKE(1,NCELL))
          Y2=YTRIAN(NECKE(2,NCELL))
          Y3=YTRIAN(NECKE(3,NCELL))
        ENDIF
C   CONVEX POLYTOP SAMPLING
C   L.DEVROYE, "NON UNIFORM RANDOM VARIATE GENERATION", SPRINGER
C   1986, P 568
        R1=RANF_EIRENE()
        R2=RANF_EIRENE()
        RMA=MAX(R1,R2)
        RMI=MIN(R1,R2)
        D(1)=RMI
        D(2)=RMA-RMI
        D(3)=1.-RMA
        X0=D(1)*X1+D(2)*X2+D(3)*X3
        Y0=D(1)*Y1+D(2)*Y2+D(3)*Y3
      ELSEIF (LEVGEO.EQ.5) THEN
        WRITE (6,*) 'ERROR EXIT FROM SAMVOL. LEVGEO ',LEVGEO
        CALL EXIT
      ENDIF
C
      IF (NLTRA) THEN
C  FIND Z0 FROM X01,PHI IN LOCAL TOROIDAL CELL NTCELL
c slmod begin - tr
        IF (.NOT.NLTOR) THEN
c...Z0 defined above
          X01=X0+RMTOR
          Z0=X01*DTAN(PHI)
        ELSE
          X01=X0+RMTOR
          CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
        ENDIF
c
c        X01=X0+RMTOR
c        CALL FZRTRI(X0,Z0,NTCELL,X01,PHI,NTCELL)
c slmod end        
      ENDIF
C
      MTSURF=0
      NLSRFZ=.FALSE.
      MPSURF=0
      NLSRFY=.FALSE.
      MRSURF=0
      NLSRFX=.FALSE.
C
C  NEXT: ANALOG SPECIES INDEX DISTRIBUTION: WEISPZ(IPL)
C
      DO 630 ISPZ=1,NSPZ
        WEISPZ(ISPZ)=-1.
630   CONTINUE
C
C  NOT IN USE ANYMORE, SINCE IPL INDEX IN FREC HAS BEEN REMOVED.
C  CURRENTLY: ONLY SINGLE SPECIES VOLUME SOURCES POSSIBLE
C  MULTI SPECIES VOL-SOURCES HAVE TO BE TREATED BY STRATIFIED SAMPLING
C     IF (NSPEZ(ISTRA).LE.0) THEN
C       IF (NCELL.EQ.1) THEN
C         DO 640 IPL=1,NPLSI
C           WEISPZ(IPL)=(FREC(IPL,IREC,1))/
C    .                  (FREC(0,  IREC,1))
C           IF (WEISPZ(IPL).LT.0) GOTO 991
640       CONTINUE
C       ELSE
C         DO 645 IPL=1,NPLSI
C           WEISPZ(IPL)=(FREC(IPL,IREC,NCELL)-FREC(IPL,IREC,NCELL-1))/
C    .                  (FREC(0,  IREC,NCELL)-FREC(0,  IREC,NCELL-1))
C           IF (WEISPZ(IPL).LT.0) GOTO 991
645       CONTINUE
C       ENDIF
C     ENDIF
C
      CRTX=SORAD4(NVLM,ISTRA)
      CRTY=SORAD5(NVLM,ISTRA)
      CRTZ=SORAD6(NVLM,ISTRA)
      CNORM=SQRT(CRTX**2+CRTY**2+CRTZ**2)+EPS60
      CRTX=CRTX/CNORM
      CRTY=CRTY/CNORM
      CRTZ=CRTZ/CNORM
C
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN SAMVOL'
      CALL EXIT
991   CONTINUE
      WRITE (6,*) 'SAMPLING ERROR IN SAMVOL'
      WRITE (6,*) 'NCELL,NSURF,NSBOX ',NCELL,NSURF,NSBOX
      CALL EXIT
997   CONTINUE
      WRITE (6,*) 'SORIND (=IREC) OUT OF RANGE IN SAMVOL'
      WRITE (6,*) 'IREC,NREC ',IREC,NREC
      CALL EXIT
999   CONTINUE
      WRITE (6,*) 'UNWRITTEN OPTION IN SAMVOL'
      CALL EXIT
      END
C
      SUBROUTINE SURTST(X,Y,Z,N,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'PARMMOD'
      INCLUDE 'CADGEO'
C  THIS SUBROUTINE TESTS, WHETHER A POINT X,Y,Z FULLFILLS THE
C  THE BOUNDARY CONDITIONS FOR THE ADDITIONAL SURFACE NO. N OR NOT
      LOGICAL L
      L=.TRUE.
      IF (RLB(N).EQ.1..OR.RLB(N).EQ.1.5) THEN
               L=L.AND.XLIMS1(N,1).LE.X.AND.X.LE.XLIMS2(N,1)
     .            .AND.YLIMS1(N,1).LE.Y.AND.Y.LE.YLIMS2(N,1)
     .            .AND.ZLIMS1(N,1).LE.Z.AND.Z.LE.ZLIMS2(N,1)
        IF (RLB(N).EQ.1.5) L=.NOT.L
      ELSEIF (RLB(N).LE.0.D0) THEN
        DO 1 I=1,ILIN(N)
           L=L.AND.
     .       ALIMS(N,I)+XLIMS(N,I)*X+YLIMS(N,I)*Y+ZLIMS(N,I)*Z.LE.0.
1       CONTINUE
        DO 2 I=1,ISCN(N)
           L=L.AND.
     .        ALIMS0(N,I)+XLIMS1(N,I)*X+YLIMS1(N,I)*Y+ZLIMS1(N,I)*Z
     .       +XLIMS2(N,I)*X*X+YLIMS2(N,I)*Y*Y+ZLIMS2(N,I)*Z*Z
     .       +XLIMS3(N,I)*X*Y+YLIMS3(N,I)*X*Z+ZLIMS3(N,I)*Y*Z.LE.0.
2       CONTINUE
      ELSEIF (RLB(N).GE.3.) THEN
        XMS1=X*PS13(1,N)+Y*PS13(2,N)+Z*PS13(3,N)+P1A(N)
        XLS1=X*PS23(1,N)+Y*PS23(2,N)+Z*PS23(3,N)+P2A(N)
        L=XMS1.GE.0..AND.XLS1.GE.0..AND.XMS1+XLS1.LE.1.
        IF (RLB(N).GE.4.AND..NOT.L) THEN
          XMS2=X*PS24(1,N)+Y*PS24(2,N)+Z*PS24(3,N)+P1B(N)
          XLS2=X*PS34(1,N)+Y*PS34(2,N)+Z*PS34(3,N)+P2B(N)
          L=XMS2.GE.0..AND.XLS2.GE.0..AND.XMS2+XLS2.LE.1.
          IF (RLB(N).GE.5.AND..NOT.L) THEN
            XMS3=X*PS35(1,N)+Y*PS35(2,N)+Z*PS35(3,N)+P1C(N)
            XLS3=X*PS45(1,N)+Y*PS45(2,N)+Z*PS45(3,N)+P2C(N)
            L=XMS3.GE.0..AND.XLS3.GE.0..AND.XMS3+XLS3.LE.1.
          ENDIF
        ENDIF
      ELSE
        WRITE (6,*) 'ERROR IN SUBROUTINE SURTST. RLB= ',RLB(N)
        CALL EXIT
      ENDIF
      RETURN
      END
C
C
      FUNCTION STEP(NSPZI,NSPZE,NS,ISTEP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C   SET  CUMULATIVE DISTRIBUTION FUNCTION VF(I),I=1,NS; VF(1)=0;
C   VF(NS)=1. ON THE GRID RRSTEP(I),I=1,NS
C   FROM PIECEWISE CONSTANT DISTRIBUTION DENSITY FLSTEP(..,I),I=1,NS-1
C   FLSTEP(0,..,I) IS THE VALUE OF THE NON NORMALIZED DENSITY IN THE
C   INTERVALL RRSTEP(I)<X<=RRSTEP(I+1), AFTER SUMMATION OVER THE
C   FIRST (SPECIES) INDEX ISPZ=NSPZI,NSPZE
C
C   THE NORMALIZING FACTOR: INTEGR. FLSTEP(0,X) DX  IS RETURNED AS
C   "STEP"
      INCLUDE 'PARMMOD'
      INCLUDE 'CTRCEI'
      INCLUDE 'CSTEP'
      INCLUDE 'CCONA'
      INCLUDE 'COMUSR'
      DIMENSION VF(0:NSPZ,NSTEP,NGITT),QUOT(0:NSPZ,NSTEP,NGITT),
     .          ADD(0:NSPZ,NSTEP,NGITT),
     .          QUOTI(0:NSPZ,NSTEP,NGITT),ADDIV(0:NSPZ,NSTEP,NGITT)
      DIMENSION SP0(NPLS,NGITT),SP1(NPLS,NGITT),SP2(NPLS,NGITT),
     .          SP3(NPLS,NGITT),SP4(NPLS,NGITT),SP5(NPLS,NGITT),
     .          IP0(NGITT),IP1(NGITT),IP2(NGITT),IP3(NGITT),IP4(NGITT)
      LOGICAL NLINV
      SAVE
C
      IF (output) WRITE(0,*) 'MARK: STEP SUBROUTINE'
      IF (NSPZE.GT.NSPZ) GOTO 991
      IF (NSPZI.LT.1) GOTO 991
      NSM=NS-1
      NSMAX(ISTEP)=NS
      NSPSTI(ISTEP)=NSPZI
      NSPSTE(ISTEP)=NSPZE
C
      NLINV=.FALSE.
1     CONTINUE
      IF (NLINV) THEN
        DO 2 J=1,NS
          SP0(1,J)=RRSTEP(ISTEP,J)
2       CONTINUE
        DO 3 J=1,NS
          RRSTEP(ISTEP,J)=SP0(1,NS-J+1)
3       CONTINUE
        DO 4 ISPZ=NSPZI,NSPZE
          DO 4 J=1,NSM
            SP0(ISPZ,J)=FLSTEP(ISPZ,ISTEP,J)
4       CONTINUE
        DO 8 IPLS=1,NPLSI
          DO 8 J=1,NSM
            SP1(IPLS,J)=VXSTEP(IPLS,ISTEP,J)
            SP2(IPLS,J)=VYSTEP(IPLS,ISTEP,J)
            SP3(IPLS,J)=VZSTEP(IPLS,ISTEP,J)
            SP4(IPLS,J)=DISTEP(IPLS,ISTEP,J)
            SP5(IPLS,J)=TISTEP(IPLS,ISTEP,J)
8       CONTINUE
        DO 5 ISPZ=NSPZI,NSPZE
          DO 5 J=1,NSM
            FLSTEP(ISPZ,ISTEP,J)=SP0(ISPZ,NSM-J+1)
5       CONTINUE
        DO 9 IPLS=1,NPLSI
          DO 9 J=1,NSM
            VXSTEP(IPLS,ISTEP,J)=SP1(IPLS,NSM-J+1)
            VYSTEP(IPLS,ISTEP,J)=SP2(IPLS,NSM-J+1)
            VZSTEP(IPLS,ISTEP,J)=SP3(IPLS,NSM-J+1)
            DISTEP(IPLS,ISTEP,J)=SP4(IPLS,NSM-J+1)
            TISTEP(IPLS,ISTEP,J)=SP5(IPLS,NSM-J+1)
9       CONTINUE
        DO 6 J=1,NSM
          SP0(1,J)=TESTEP(ISTEP,J)
          IP0(J)=IRSTEP(ISTEP,J)
          IP1(J)=IPSTEP(ISTEP,J)
          IP2(J)=ITSTEP(ISTEP,J)
          IP3(J)=IASTEP(ISTEP,J)
          IP4(J)=IBSTEP(ISTEP,J)
6       CONTINUE
        DO 7 J=1,NSM
          TESTEP(ISTEP,J)=SP0(1,NSM-J+1)
          IRSTEP(ISTEP,J)=IP0(NSM-J+1)
          IPSTEP(ISTEP,J)=IP1(NSM-J+1)
          ITSTEP(ISTEP,J)=IP2(NSM-J+1)
          IASTEP(ISTEP,J)=IP3(NSM-J+1)
          IBSTEP(ISTEP,J)=IP4(NSM-J+1)
7       CONTINUE
      ENDIF
C
      DO 10 J=1,NSM
        FLSTEP(0,ISTEP,J)=0.
        DO 11 ISPZ=NSPZI,NSPZE
          FLSTEP(0,ISTEP,J)=FLSTEP(0,ISTEP,J)+FLSTEP(ISPZ,ISTEP,J)
11      CONTINUE
        DO ISPZ=NSPZE+1,NSPZ
          FLSTEP(ISPZ,ISTEP,J)=0.
        ENDDO
        DO ISPZ=1,NSPZI-1
          FLSTEP(ISPZ,ISTEP,J)=0.
        ENDDO
10    CONTINUE
C
      DO 20 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 20
        VF(ISPZ,ISTEP,1)=0.
        DO 21 J=2,NS
          DELR=RRSTEP(ISTEP,J)-RRSTEP(ISTEP,J-1)
          IF (DELR.LT.0.D0) THEN
            IF (NLINV) GOTO 993
C  INVERT COMPLETE STEPFUNCTION ISTEP (ONLY ONCE)
            IF (TRCSOU)
     .      WRITE (6,*) 'STEPFUNCTION NO. ISTEP= ',ISTEP,' REVERSED'
            NLINV=.TRUE.
            GOTO 1
          ENDIF
          VF(ISPZ,ISTEP,J)=VF(ISPZ,ISTEP,J-1)+
     .                      FLSTEP(ISPZ,ISTEP,J-1)*DELR
c slmod begin - tr
          WRITE(6,*) 'DEBUG FLSTEP ',j,VF(ISPZ,ISTEP,J),
     .      FLSTEP(ISPZ,ISTEP,J),
     .      FLSTEP(ISPZ,ISTEP,J-1),DELR,istep
c slmod end
          IF (VF(ISPZ,ISTEP,J).LT.VF(ISPZ,ISTEP,J-1)) GOTO 994
21      CONTINUE
20    CONTINUE
C  STEPFUNCTION "VF" NO. ISTEP IS DEFINED NOW
C
C  NORMALIZE VF TO 1.
      STEP=VF(0,ISTEP,NS)
C
      DO 25 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 25
        FLTOT(ISPZ,ISTEP)=VF(ISPZ,ISTEP,NS)
        IF (FLTOT(ISPZ,ISTEP).LE.0.D0) THEN
          WRITE (6,*) 'WARNING FROM FUNCTION "STEP"'
          WRITE (6,*) 'DENSITY FUNCTION FLSTEP(ISPZ,ISTEP) VANISHES'
          WRITE (6,*) 'ISPZ,ISTEP ',ISPZ,ISTEP
        ENDIF
25    CONTINUE
C
      DO 30 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 30
        DO 31 J=1,NS
31        VF(ISPZ,ISTEP,J)=VF(ISPZ,ISTEP,J)/(FLTOT(ISPZ,ISTEP)+EPS60)
30      CONTINUE
C
C  SET SOME ARRAYS TO SPEED UP SAMPLING FROM VF(ISPZ,ISTEP,...)
      DO 40 ISPZ=0,NSPZ
        IF (ISPZ.GT.NSPZE.OR.(ISPZ.LT.NSPZI.AND.ISPZ.GT.0)) GOTO 40
        DO 41 J=1,NSM
c slmod begin - not done - not tr
        IF (output) THEN
          WRITE(0,*) 'STEP: J,NSM= ',j,nsm

          WRITE(0,*) 'DEBUG: VF ',j,nsm,
     .    VF(ISPZ,ISTEP,J+1),VF(ISPZ,ISTEP,J),EPS60,
     .    ((VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J))+EPS30),
     .    RRSTEP(ISTEP,J+1),RRSTEP(ISTEP,J),
     .    (RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J)+EPS60)

          WRITE(6,*) 'DEBUG: VF ',j,nsm,
     .    VF(ISPZ,ISTEP,J+1),VF(ISPZ,ISTEP,J),EPS60,

     .    ((VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J))+EPS30),

     .    RRSTEP(ISTEP,J+1),RRSTEP(ISTEP,J),
     .    (RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J)+EPS60)

        ENDIF
c slmod end
          QUOT(ISPZ,ISTEP,J)=(RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J))/
     .               (VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J)+EPS60)
          ADD (ISPZ,ISTEP,J)=-QUOT(ISPZ,ISTEP,J)*VF(ISPZ,ISTEP,J)+
     .                         RRSTEP(ISTEP,J)
          QUOTI(ISPZ,ISTEP,J)=(VF(ISPZ,ISTEP,J+1)-VF(ISPZ,ISTEP,J))/
     .                   (RRSTEP(ISTEP,J+1)-RRSTEP(ISTEP,J)+EPS60)
          ADDIV(ISPZ,ISTEP,J)=-QUOTI(ISPZ,ISTEP,J)*RRSTEP(ISTEP,J)+
     .                          VF(ISPZ,ISTEP,J)
41      CONTINUE
40    CONTINUE
C
      IF (ISTUF(ISTEP).NE.0) THEN
        WRITE (6,*) 'WARNING FROM FUNCTION STEP: VF(ISTEP) IS   '
        WRITE (6,*) 'OVERWRITTEN. ISTEP= ',ISTEP
      ENDIF
      ISTUF(ISTEP)=1
      IF (TRCSOU) THEN
        WRITE (6,*) 'STEPFUNCTION NO. ISTEP= ',ISTEP,' INITIALISED'
        CALL LEER(1)
      ENDIF
      RETURN
C
      ENTRY STEP0(NSPZ1,ISTEP,X)
      IF (output) WRITE(0,*) 'MARK: STEP0 ENTRY'
      ISPZ1=NSPZ1
C
C   COMPUTE VF(X) NO. ISTEP BY LINEAR INTERPOLATION
C
      IF (ISPZ1.LT.0) GOTO 990
      IF (ISPZ1.GT.0.AND.ISPZ1.LT.NSPSTI(ISTEP)) GOTO 990
      IF (ISPZ1.GT.NSPSTE(ISTEP)) GOTO 990
C
      IF (ISTEP.LE.0.OR.ISTEP.GT.NSTEP) GOTO  990
      IF (ISTUF(ISTEP).EQ.0) GOTO 990
C
      NS1=NSMAX(ISTEP)
      IF (X.LT.RRSTEP(ISTEP,1)) THEN
        WRITE (6,*) 'X OUT OF RANGE IN STEP0, X,RRSTEP(1) ',X,
     .               RRSTEP(ISTEP,1)
        STEP0=0.
      ELSEIF (X.GT.RRSTEP(ISTEP,NS1)) THEN
        WRITE (6,*) 'X OUT OF RANGE IN STEP0, X,RRSTEP(NS1) ',X,
     .               RRSTEP(ISTEP,NS1)
        STEP0=1.
      ELSE
        IND=LEARCA(X,RRSTEP,NSTEP,NS1,ISTEP,'STEP0       ')
        STEP0=ADDIV(ISPZ1,ISTEP,IND)+X*QUOTI(ISPZ1,ISTEP,IND)
      ENDIF
      RETURN
C
      ENTRY STEP1(IINDEX,ISTEP,Y,NSPZ1)
      IF (output) WRITE(0,*) 'MARK: STEP1 ENTRY'
      ISPZ1=NSPZ1
C
C  INVERT FUNCTION VF(ISPZ1,X)=Y. NO. ISTEP, E.G.
C  SAMPLE FROM VF WITH Y=RANF_EIRENE,  RRSTEP(ISTEP,1)<=X<=RRSTEP(ISTEP,NS1)
C  RETURN THE VALUE X AS STEP1, AND THE INTERVAL NUMBER IINDEX OF
C  THE INTERVAL CONTAINING THIS X.
C
      IF (ISTEP.LE.0.OR.ISTEP.GT.NSTEP) GOTO  990
      IF (ISTUF(ISTEP).EQ.0) GOTO 990
C
      IF (ISPZ1.LT.0) ISPZ1=0
      IF (ISPZ1.GT.0.AND.ISPZ1.LT.NSPSTI(ISTEP)) ISPZ1=0
      IF (ISPZ1.GT.NSPSTE(ISTEP)) ISPZ1=0
C
      NS1=NSMAX(ISTEP)
      DO 100 J=2,NS1
        JJ=J
        IF (Y.LE.VF(ISPZ1,ISTEP,J)) GOTO 110
100   CONTINUE
110   JJM=JJ-1
      IINDEX=JJM
      XX=ADD(ISPZ1,ISTEP,JJM)+Y*QUOT(ISPZ1,ISTEP,JJM)
      STEP1=XX
c slmod begin - new - debug - tr
      IF (output) WRITE(0,*) 'MARK: END OF STEP'
c slmod end
      RETURN
C
990   CONTINUE
      WRITE (6,*) 'ERROR IN FUNCTION STEP, ISTEP= ',ISTEP
      CALL EXIT
991   CONTINUE
      WRITE (6,*) 'PARAMETER ERROR IN FUNCTION STEP '
      WRITE (6,*) 'NSPZE MUST BE .LE. NSPZ '
      WRITE (6,*) 'NSPZI MUST BE .GE. 1    '
      WRITE (6,*) 'NSPZI,NSPZE,NSPZ = ',NSPZI,NSPZE,NSPZ
      CALL EXIT
993   CONTINUE
      WRITE (6,*) 'ERROR IN FUNCTION STEP, ISTEP= ',ISTEP
      WRITE (6,*) 'RRSTEP NEITHER MONOTONICALLY INCREASING NOR'
      WRITE (6,*) 'DECREASING'
      CALL EXIT
994   CONTINUE
      WRITE (6,*) 'ERROR IN FUNCTION "STEP" '
      WRITE (6,*) 'VF IS NOT MONOTONICALLY INCREASING'
      WRITE (6,*) 'POSSIBLE REASON: FLSTEP NEGATIVE SOMEWHERE? '
      WRITE (6,*) 'ISTEP, J ',ISTEP,J
      WRITE (6,*) ' I   RRSTEP     VF '
      DO 995 I=1,J
        WRITE (6,'(1X,I3,1P,5E12.4)') I,RRSTEP(ISTEP,I),(VF(IS,ISTEP,I),
     .                                 IS=NSPZI,NSPZE)
995   CONTINUE
      CALL EXIT
      END
C
C
C      FUNCTION LEARC1 (X,Y,Z,IPO,IAN,IEN,LOGX,LOGY,NP,TEXT)
C      FUNCTION LEARC2 (X,Y,    IR,                ,NP,TEXT)
C      SUBROUTINE FZRTOR(X,Z,NOLD,XNEW,PH,NNEW,LTEST,NTEST)
C      SUBROUTINE FZRTRA(X,Z,PH,NNEW)
C      SUBROUTINE FZRTRI(X,Z,NNEW,XOLD,PH,NOLD)
C      FUNCTION AREAA (R,N,ARCA,YR,EP1R)
C
      FUNCTION LEARC1 (X,Y,Z,IPO,IAN,IEN,LOGX,LOGY,NP,TEXT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   LOGX=TRUE: PARTICLE IS ON A RADIAL SURFACE
C   LOGY=TRUE: PARTICLE IS ON A POLOIDAL SURFACE
C
C   FIND RADIAL MESHPOINT NUMBER LEARC1,
C   (AND POLYGON INDEX IPO, IF NLPLG)
C   IF .NOT.LOGX AND .NOT.LOGY
C     SEARCH IN RADIAL CELLS IAN AND IEN, I.E.
C     SEARCH BETWEEN (!!!) RADIAL SURFACES IAN AND IEN+1
C     THIS SEARCH COVERS THE WHOLE POLOIDAL RANGE
C   IF LOGX
C     SEARCH ON (!!!) RADIAL SURF. IAN FOR POLOIDAL MESH NUMBER IPO
C   IF LOGY
C     SEARCH ON (!!!) POLOIDAL SURF. IAN FOR RADIAL MESH NUMBER LEARC1
C
      INCLUDE 'PARMMOD'
      INCLUDE 'CGRID'
      INCLUDE 'CGEOM'
      INCLUDE 'CCONA'
      INCLUDE 'CPOLYG'
      INCLUDE 'CLOGAU'
      INCLUDE 'CTRIG'
c slmod begin - not tr
      INCLUDE 'COMPRT'
c slmod end
      DIMENSION ERR1(N2NDPLG),ERR2(N2NDPLG),ERR3(N2NDPLG),
     .          ERR4(N2NDPLG),ERR5(N2NDPLG),ERR6(N2NDPLG),
     .          ERR7(N1ST)
      DIMENSION D12(N1ST,N2NDPLG),D12I(N1ST,N2NDPLG),
     .          D14(N1ST,N2NDPLG),D14I(N1ST,N2NDPLG)
      CHARACTER*(*) TEXT
      LOGICAL LOGX,LOGY
CTK DATENSTRUKTUR FUER DREIECKS UND VIERECKSGITTER
      TYPE :: CELL
        INTEGER :: TRIANGLE
        TYPE(CELL),POINTER :: NEXT
      END TYPE CELL

      TYPE :: CELL4
        INTEGER :: IX
        INTEGER :: IY
        TYPE(CELL4),POINTER :: NEXT
      END TYPE CELL4

      TYPE :: POIFELD
        TYPE (CELL),POINTER :: P
      END TYPE POIFELD

      TYPE :: POI4
        TYPE (CELL4),POINTER :: P
      END TYPE POI4

      TYPE (POIFELD) :: HELPCUR(4)
      TYPE (POIFELD) :: HEADS(100,100)
      TYPE (CELL),POINTER :: CUR
      TYPE (POI4) :: HELPCUR4(4)
      TYPE (POI4) :: HEADS4(100,100)
      TYPE (CELL4),POINTER :: CUR4,HELPP
c slmod begin - grid - tr
      INTEGER VP1
c slmod end
CTK ENDE DER DATENSTRUKTUR
      SAVE
      DATA IFIRST /0/
C
c slmod begin - debug - tr
      IF (printopt.GE.1.AND.printopt.LE.10) THEN
        WRITE(6,'(4X,A)')
     .    'LEARC1: (X,Y,IPO,IAN,IEN,LOGX,LOGY,NP,TEXT)'
        WRITE(6,'(10X,2F9.3,2X,I3,2X,2I3,2X,2L2,2X,I4,2X,A)')
     .    x,y,ipo,ian,ien,logx,logy,np,text

        IF (.NOT.LOGX.AND..NOT.LOGY) THEN
          WRITE(6,'(4X,A)') 'LEARC1: *** ERROR! BROAD SEARCH DOES '//
     .                      'NOT WORK ***'
          WRITE(0,'(4X,A)') 'LEARC1: *** ERROR! BROAD SEARCH DOES '//
     .                      'NOT WORK ***'
        ENDIF
      ENDIF

      IF (gridopt.EQ.1.AND.text.NE.'STDCOL'.AND.
     .                     text.NE.'ADDCOL  '.AND.
     .                     text.NE.'TORCOL 1') THEN
        WRITE(0,*) 'WARNING (Learc1): Function call of unknown ',
     .             'origin'
        WRITE(0,*) '     TEXT = ''',text,''''

        WRITE(6,*) 'WARNING (Learc1): Function call of unknown ',
     .             'origin'
        WRITE(6,*) '     TEXT = ''',text,''''
      ENDIF
c slmod end
      IA=IAN
      IE=IEN
C
      IF (LEVGEO.EQ.4) THEN
C
        IF (IFIRST.EQ.0) THEN
          IFIRST = 1
          DO I=1,100
            DO J=1,100
              NULLIFY(HEADS(I,J)%P)
            ENDDO
          ENDDO
          XMIN=MINVAL(XTRIAN(1:NRKNOT))-EPS5
          YMIN=MINVAL(YTRIAN(1:NRKNOT))-EPS5
          XMAX=MAXVAL(XTRIAN(1:NRKNOT))+EPS5
          YMAX=MAXVAL(YTRIAN(1:NRKNOT))+EPS5
          DISTX=(XMAX-XMIN)/100.D0
          DISTY=(YMAX-YMIN)/100.D0
C         WRITE(6,*) 'XMIN, XMAX, DISTX ',XMIN, XMAX, DISTX
C         WRITE(6,*) 'YMIN, YMAX, DISTY ',YMIN, YMAX, DISTY
          DO I=1,NTRII
            XTRMIN = MIN(XTRIAN(NECKE(1,I)),XTRIAN(NECKE(2,I)),
     .                   XTRIAN(NECKE(3,I)))
            XTRMAX = MAX(XTRIAN(NECKE(1,I)),XTRIAN(NECKE(2,I)),
     .                   XTRIAN(NECKE(3,I)))
            YTRMIN = MIN(YTRIAN(NECKE(1,I)),YTRIAN(NECKE(2,I)),
     .                   YTRIAN(NECKE(3,I)))
            YTRMAX = MAX(YTRIAN(NECKE(1,I)),YTRIAN(NECKE(2,I)),
     .                   YTRIAN(NECKE(3,I)))
            DELTAX=XTRMIN-XMIN
            IHEADX1=INT(DELTAX/DISTX)+1
            DELTAX=XTRMAX-XMIN
            IHEADX2=MAX(IHEADX1,INT(DELTAX/DISTX)+1)
            DELTAY=YTRMIN-YMIN
            IHEADY1=INT(DELTAY/DISTY)+1
            DELTAY=YTRMAX-YMIN
            IHEADY2=MAX(IHEADY1,INT(DELTAY/DISTY)+1)
            DO IX=IHEADX1,IHEADX2
              DO IY=IHEADY1,IHEADY2
                ALLOCATE(CUR)
                CUR%TRIANGLE = I
                CUR%NEXT => HEADS(IX,IY)%P
                HEADS(IX,IY)%P => CUR
              ENDDO
            ENDDO
          ENDDO
        ENDIF
C
C  END OF IFIRST SEGMENT FOR TRIANGELS
C
        DELTAX=X-XMIN
        IHEADX2 = 0
        IF (ABS(MOD(DELTAX,DISTX)) .LT. EPS5) THEN
          IHEADX2=INT(DELTAX/DISTX)
        ENDIF
        IHEADX1=INT(DELTAX/DISTX)+1
        DELTAY=Y-YMIN
        IHEADY2 = 0
        IF (ABS(MOD(DELTAY,DISTY)) .LT. EPS5) THEN
          IHEADY2=INT(DELTAY/DISTY)
        ENDIF
        IHEADY1=INT(DELTAY/DISTY)+1

        HELPCUR(1)%P => HEADS(IHEADX1,IHEADY1)%P
        IF (IHEADX2 .GT. 0) THEN
          HELPCUR(2)%P => HEADS(IHEADX2,IHEADY1)%P
        ELSE
          NULLIFY(HELPCUR(2)%P)
        ENDIF
        IF (IHEADY2 .GT. 0) THEN
          HELPCUR(3)%P => HEADS(IHEADX1,IHEADY2)%P
        ELSE
          NULLIFY(HELPCUR(3)%P)
        ENDIF
        IF ((IHEADX2 .GT. 0) .AND. (IHEADY2 .GT. 0)) THEN
          HELPCUR(4)%P => HEADS(IHEADX2,IHEADY2)%P
        ELSE
          NULLIFY(HELPCUR(4)%P)
        ENDIF

        DO J=1,4
          DO WHILE (ASSOCIATED(HELPCUR(J)%P))
            I = HELPCUR(J)%P%TRIANGLE
            DET1 = (XTRIAN(NECKE(1,I))-X)*(YTRIAN(NECKE(2,I))-Y)-
     .             (YTRIAN(NECKE(1,I))-Y)*(XTRIAN(NECKE(2,I))-X)
            DET2 = (XTRIAN(NECKE(2,I))-X)*(YTRIAN(NECKE(3,I))-Y)-
     .             (YTRIAN(NECKE(2,I))-Y)*(XTRIAN(NECKE(3,I))-X)
            DET3 = (XTRIAN(NECKE(3,I))-X)*(YTRIAN(NECKE(1,I))-Y)-
     .             (YTRIAN(NECKE(3,I))-Y)*(XTRIAN(NECKE(1,I))-X)
            DET1=MIN(0.D0,DET1+EPS10)
            DET2=MIN(0.D0,DET2+EPS10)
            DET3=MIN(0.D0,DET3+EPS10)
            IF (ABS(DET1+DET2+DET3) .LT. EPS10) IM = I
            HELPCUR(J)%P => HELPCUR(J)%P%NEXT
          ENDDO
        ENDDO
C       WRITE (6,*) ' IM ',IM
        IF (IM.LT.1.OR.IM.GT.NTRII) THEN
          WRITE (6,*) 'NO TRIANGLE FOUND IN LEARC1 FOR '
          WRITE (6,*) 'X = ',X,' Y = ',Y
          WRITE (6,*) 'LEARC1 CALLED FROM SUBR. ',TEXT
          WRITE (6,*) 'NPANU,IM= ',NP,IM
        ENDIF
        LEARC1=IM
C
      ELSEIF (LEVGEO.EQ.3) THEN
C
        IF (IFIRST.EQ.0) THEN
          IFIRST=1
          DO 1 I=1,NR1ST
            DO 2 L=1,NP2NDM
c slmod begin - grid - tr
              IF (GRIDOPT.EQ.1) THEN
c Is this correct...?  Seesm that things are dependant on where
c the particle is coming from... need to build this in to the
c decision making...
c Replace with separatrix ring... and move above...
c
c...note: arbitrary - fix
                IF (I.GT.DIVSUR.AND.
     .              .NOT.(OPTCONMAP.EQ.1.AND.RADMAP(I).EQ.0)) THEN
                  IR1 = I - 1
                  VP1 = 2
                ELSE
                  IR1 = I
                  VP1 = 1
                ENDIF

                D12(I,L)=SQRT((XVERT(IR1,L,VP1)-XVERT(IR1,L+1,VP1))**2+
     .                        (YVERT(IR1,L,VP1)-YVERT(IR1,L+1,VP1))**2)

                DUM = SQRT((XPOL(I,L)-XPOL(I,L+1))**2+
     .                     (YPOL(I,L)-YPOL(I,L+1))**2)
                CALL CHECKNUM('zick1',i,l,d12(i,l),DUM)
              ELSE
                D12(I,L)=SQRT((XPOL(I,L)-XPOL(I,L+1))**2+
     .                        (YPOL(I,L)-YPOL(I,L+1))**2)
              ENDIF


c
c              D12(I,L)=SQRT((XPOL(I,L)-XPOL(I,L+1))**2+
c     .                      (YPOL(I,L)-YPOL(I,L+1))**2)
c slmod end
              D12I(I,L)=1./(ABS(D12(I,L))+EPS60)
2           CONTINUE
1         CONTINUE
          DO 3 I=1,NR1STM
            DO 4 L=1,NP2ND
c slmod begin - grid - tr
              IF (GRIDOPT.EQ.1) THEN
                D14(I,L)=SQRT((XVERT(I,L,1)-XVERT(I,L,2))**2+
     .                        (YVERT(I,L,1)-YVERT(I,L,2))**2)

                DUM = SQRT((XPOL(I,L)-XPOL(I+1,L))**2+
     .                     (YPOL(I,L)-YPOL(I+1,L))**2)
                CALL CHECKNUM('ZICK2',I,L,D14(I,L),DUM)
              ELSE
                D14(I,L)=SQRT((XPOL(I,L)-XPOL(I+1,L))**2+
     .                        (YPOL(I,L)-YPOL(I+1,L))**2)
              ENDIF
c
c              D14(I,L)=SQRT((XPOL(I,L)-XPOL(I+1,L))**2+
c     .                      (YPOL(I,L)-YPOL(I+1,L))**2)
c slmod end
              D14I(I,L)=1./(ABS(D14(I,L))+EPS60)
4           CONTINUE
3         CONTINUE
C
          DO I=1,100
            DO J=1,100
c slmod begin - not tr
c...problem for PGI compiler with -Mvect=prefetch
c slmod end
              NULLIFY(HEADS4(I,J)%P)
            ENDDO
          ENDDO
c slmod begin - f90 - not tr
          XMIN=1.D60
          YMIN=1.D60
          XMAX=-1.D60
          YMAX=-1.D60
c
c          XMIN=1.E60
c          YMIN=1.E60
c          XMAX=-1.E60
c          YMAX=-1.E60
c slmod end
          DO I=1,NR1ST
            DO L=1,NP2ND
c slmod begin - grid - tr
              IF (GRIDOPT.EQ.1) THEN
c...note: arbitrary - fix
                IF (I.GT.DIVSUR.AND.
     .              .NOT.(OPTCONMAP.EQ.1.AND.RADMAP(I).EQ.0)) THEN
                  IR1 = I - 1
                  VP1 = 2
                ELSE
                  IR1 = I
                  VP1 = 1
                ENDIF
                XMIN = MIN(XMIN,XVERT(IR1,L,VP1))
                YMIN = MIN(YMIN,YVERT(IR1,L,VP1))
                XMAX = MAX(XMAX,XVERT(IR1,L,VP1))
                YMAX = MAX(YMAX,YVERT(IR1,L,VP1))
              ELSE
                XMIN = MIN(XMIN,XPOL(I,L))
                YMIN = MIN(YMIN,YPOL(I,L))
                XMAX = MAX(XMAX,XPOL(I,L))
                YMAX = MAX(YMAX,YPOL(I,L))
              ENDIF
c
c              XMIN = MIN(XMIN,XPOL(I,L))
c              YMIN = MIN(YMIN,YPOL(I,L))
c              XMAX = MAX(XMAX,XPOL(I,L))
c              YMAX = MAX(YMAX,YPOL(I,L))
c slmod end
            ENDDO
          ENDDO
          XMIN = XMIN - EPS5
          XMAX = XMAX + EPS5
          YMIN = YMIN - EPS5
          YMAX = YMAX + EPS5
          DISTX=(XMAX-XMIN)/100.
          DISTY=(YMAX-YMIN)/100.
C
          DO I=1,NR1STM
            DO K=1,NPPLG
            DO L=NPOINT(1,K),NPOINT(2,K)-1
c slmod begin - tr
              IF (GRIDOPT.EQ.1) THEN
                XCMIN=MIN(XVERT(I,L  ,1),XVERT(I,L  ,2),
     .                    XVERT(I,L+1,2),XVERT(I,L+1,1))
                XCMAX=MAX(XVERT(I,L  ,1),XVERT(I,L  ,2),
     .                    XVERT(I,L+1,2),XVERT(I,L+1,1))
                YCMIN=MIN(YVERT(I,L  ,1),YVERT(I,L  ,2),
     .                    YVERT(I,L+1,2),YVERT(I,L+1,1))
                YCMAX=MAX(YVERT(I,L  ,1),YVERT(I,L  ,2),
     .                    YVERT(I,L+1,2),YVERT(I,L+1,1))
              ELSE
                XCMIN=MIN(XPOL(I  ,L  ),XPOL(I+1,L  ),
     .                    XPOL(I+1,L+1),XPOL(I  ,L+1))
                XCMAX=MAX(XPOL(I  ,L  ),XPOL(I+1,L  ),
     .                    XPOL(I+1,L+1),XPOL(I  ,L+1))
                YCMIN=MIN(YPOL(I  ,L  ),YPOL(I+1,L  ),
     .                    YPOL(I+1,L+1),YPOL(I  ,L+1))
                YCMAX=MAX(YPOL(I  ,L  ),YPOL(I+1,L  ),
     .                    YPOL(I+1,L+1),YPOL(I  ,L+1))
              ENDIF
c
c              XCMIN=MIN(XPOL(I,L),XPOL(I+1,L),XPOL(I+1,L+1),XPOL(I,L+1))
c              XCMAX=MAX(XPOL(I,L),XPOL(I+1,L),XPOL(I+1,L+1),XPOL(I,L+1))
c              YCMIN=MIN(YPOL(I,L),YPOL(I+1,L),YPOL(I+1,L+1),YPOL(I,L+1))
c              YCMAX=MAX(YPOL(I,L),YPOL(I+1,L),YPOL(I+1,L+1),YPOL(I,L+1))
c slmod end
              DELTAX=XCMIN-XMIN
              IHEADX1=INT(DELTAX/DISTX)+1
              DELTAX=XCMAX-XMIN
              IHEADX2=MAX(IHEADX1,INT(DELTAX/DISTX)+1)
              DELTAY=YCMIN-YMIN
              IHEADY1=INT(DELTAY/DISTY)+1
              DELTAY=YCMAX-YMIN
              IHEADY2=MAX(IHEADY1,INT(DELTAY/DISTY)+1)
              DO IX=IHEADX1,IHEADX2
                DO IY=IHEADY1,IHEADY2
                  ALLOCATE(CUR4)
                  CUR4%IX = I
                  CUR4%IY = L
                  CUR4%NEXT => HEADS4(IX,IY)%P
                  HEADS4(IX,IY)%P => CUR4
                ENDDO
              ENDDO
            ENDDO
            ENDDO
          ENDDO
        ENDIF
C
C  END OF IFIRST SEGMENT FOR QUADRANGELS
C
        INUM=0
        DELTAX=X-XMIN
        IHEADX2 = 0
        IF (ABS(MOD(DELTAX,DISTX)) .LT. EPS5) THEN
          IHEADX2=INT(DELTAX/DISTX)
        ENDIF
        IHEADX1=INT(DELTAX/DISTX)+1
        DELTAY=Y-YMIN
        IHEADY2 = 0
        IF (ABS(MOD(DELTAY,DISTY)) .LT. EPS5) THEN
          IHEADY2=INT(DELTAY/DISTY)
        ENDIF
        IHEADY1=INT(DELTAY/DISTY)+1
c slmod begin - debug - not tr
        IF (IHEADX1.GT.100) STOP 'LEARC1: IHEADX1 TOO LARGE'
c slmod end
        HELPCUR4(1)%P => HEADS4(IHEADX1,IHEADY1)%P
        IF (IHEADX2 .GT. 0) THEN
          HELPCUR4(2)%P => HEADS4(IHEADX2,IHEADY1)%P
        ELSE
          NULLIFY(HELPCUR4(2)%P)
        ENDIF
        IF (IHEADY2 .GT. 0) THEN
          HELPCUR4(3)%P => HEADS4(IHEADX1,IHEADY2)%P
        ELSE
          NULLIFY(HELPCUR4(3)%P)
        ENDIF
        IF ((IHEADX2 .GT. 0) .AND. (IHEADY2 .GT. 0)) THEN
          HELPCUR4(4)%P => HEADS4(IHEADX2,IHEADY2)%P
        ELSE
          NULLIFY(HELPCUR4(4)%P)
        ENDIF
        ERRMIN=1.D30
c slmod begin - not tr


c        WRITE(6,'(A,I6,2L4)') 
c     .    '??-->',NPANU,LOGX,LOGY

c slmod end
        IF (LOGX) THEN
          IEP=IA
          GOTO 500
        ENDIF
        IF (LOGY) THEN
          IEP=IA
          GOTO 750
        ENDIF
C
c slmod begin - debug - not tr
        IF (printopt.EQ.2) WRITE(6,'(4X,A)') 'LEARC1: Checkpoint A'
c slmod end
        DO J=1,4
          HELPP => HELPCUR4(J)%P
          DO WHILE (ASSOCIATED(HELPP))
            I = HELPP%IX
            L = HELPP%IY
            IF ((I.LT.IA) .OR. (I.GT.IE) .OR. (L.GT.NP2NDM)) GOTO 20
c slmod begin - tr
            IF (GRIDOPT.EQ.1) THEN
              X1=XVERT(I,L  ,1)
              Y1=YVERT(I,L  ,1)
              X2=XVERT(I,L+1,1)
              Y2=YVERT(I,L+1,1)
              X3=XVERT(I,L+1,2)
              Y3=YVERT(I,L+1,2)
              X4=XVERT(I,L  ,2)
              Y4=YVERT(I,L  ,2)
            ELSE
              X1=XPOL(I,L)
              Y1=YPOL(I,L)
              X2=XPOL(I,L+1)
              Y2=YPOL(I,L+1)
              X3=XPOL(I+1,L+1)
              Y3=YPOL(I+1,L+1)
              X4=XPOL(I+1,L)
              Y4=YPOL(I+1,L)
            ENDIF
c
c            X1=XPOL(I,L)
c            Y1=YPOL(I,L)
c            X2=XPOL(I,L+1)
c            Y2=YPOL(I,L+1)
c            X3=XPOL(I+1,L+1)
c            Y3=YPOL(I+1,L+1)
c            X4=XPOL(I+1,L)
c            Y4=YPOL(I+1,L)
c slmod end
            XMX2=X-X2
            YMY2=Y-Y2
            TX=X1-X2
            TY=Y1-Y2
            UX=X3-X2
            UY=Y3-Y2
            DET=TX*UY-TY*UX-EPS60
            DET1=XMX2*UY-YMY2*UX
            DET2=TX*YMY2-TY*XMX2
            ERR1(L)=DET1/DET
            ERR2(L)=DET2/DET
            XMX4=X-X4
            YMY4=Y-Y4
            VX=X3-X4
            VY=Y3-Y4
            WX=X1-X4
            WY=Y1-Y4
            DES=VX*WY-VY*WX-EPS60
            DET3=XMX4*WY-YMY4*WX
            DET4=VX*YMY4-VY*XMX4
            ERR3(L)=DET3/DES
            ERR4(L)=DET4/DES
            ERR5(L)=ERR1(L)+ERR2(L)
            ERR6(L)=ERR3(L)+ERR4(L)
            E5=ERR5(L)
            E6=ERR6(L)
            IF (E5.LT.1..AND.ERR1(L).GT.0..AND.ERR2(L).GT.0.D0) THEN
              INUM=INUM+1
              IM=I
              LM=L
            ELSEIF (E6.LT.1..AND.ERR3(L).GT.0..AND.ERR4(L).GT.0.D0) THEN
              INUM=INUM+1
              IM=I
              LM=L
            ENDIF
20          HELPP => HELPP%NEXT
          ENDDO
        ENDDO
C
        IF (INUM.EQ.1) GOTO 1000
        IEP=IE+1
C
C  CHECK FOR NEAREST BOUNDARY, BECAUSE NO VALID CELL INDEX FOUND
C  FIRST TRY RADIAL SURFACES
C  THIS SECTION ALSO: IF LOGX, CHECK ON RADIAL SURFACE IA
500     CONTINUE
        DO J=1,4
          HELPP => HELPCUR4(J)%P
          DO WHILE (ASSOCIATED(HELPP))
            I = HELPP%IX
            L = HELPP%IY
c slmod begin - debug - tr
            IF (printopt.EQ.2) WRITE(6,'(4X,A,5I4)')
     .        'LEARC1: (I,IA,IEP,L,NP2NDM) ',i,ia,iep,l,np2ndm
c slmod end
121         IF (L.GT.NP2NDM) GOTO 21
c slmod begin - tr
c...note: Move this to top of routine
            IF (GRIDOPT.EQ.1) THEN
              IF (I.GT.DIVSUR.AND.
     .            .NOT.(OPTCONMAP.EQ.1.AND.RADMAP(I).EQ.0)) THEN
                IR1 = I - 1
                VP1 = 2
              ELSE
                IR1 = I
                VP1 = 1
              ENDIF

c              WRITE(0,*) 'NPANU=',npanu

                               


c...Skip virtual cells:
              IF (RVRTAG(IR1,L).EQ.1) THEN
                ERR1(L)=1.0E+30
                GOTO 21
              ENDIF
              XMX1=X-XVERT(IR1,L  ,VP1)
              YMY1=Y-YVERT(IR1,L  ,VP1)
              XMX2=X-XVERT(IR1,L+1,VP1)
              YMY2=Y-YVERT(IR1,L+1,VP1)

              CALL CHECKNUM('zing1',i,l  ,xmx1,X-XPOL(I,L  ))
              CALL CHECKNUM('zing2',i,l+1,xmx2,X-XPOL(I,L+1))
              CALL CHECKNUM('zing3',i,l  ,ymy1,Y-YPOL(I,L  ))
              CALL CHECKNUM('zing4',i,l  ,ymy2,Y-YPOL(I,L+1))
            ELSE
              XMX1=X-XPOL(I,L)
              YMY1=Y-YPOL(I,L)
              XMX2=X-XPOL(I,L+1)
              YMY2=Y-YPOL(I,L+1)
            ENDIF


c                IF (I.LE.7) 
c     .             WRITE(6,'(A,6I6)') 
c     .             '-->',NPANU,NRCELL,I,IR1,DIVSUR,GRIDOPT




c
c            XMX1=X-XPOL(I,L)
c            YMY1=Y-YPOL(I,L)
c            XMX2=X-XPOL(I,L+1)
c            YMY2=Y-YPOL(I,L+1)
c slmod end
            D1=SQRT(XMX1*XMX1+YMY1*YMY1)
            D2=SQRT(XMX2*XMX2+YMY2*YMY2)
            ERR1(L)=ABS(D1+D2-D12(I,L))*D12I(I,L)
c slmod begin - debug - tr
            IF (printopt.EQ.2)
     .        WRITE(6,'(4X,A,4I5,1P,E15.8)')
     .          'LEARC1: Searching (I,L,IR1,VP1,ERR1) ',
     .          i,l,ir1,vp1,err1(l)
c slmod end
            IF (ERR1(L).LT.ERRMIN) THEN
              IMARK=I
              LMARK=L
              ERRMIN=ERR1(L)
            ENDIF
21          CONTINUE
c slmod begin - grid - tr
c...note: Arbitrary (replace with separatrix)
            IF (I.GT.DIVSUR.AND.I.LE.NR1STM) THEN
              IF (printopt.EQ.2)
     .          WRITE(6,'(4X,A)') 'LEARC1: Incrementing I'

c              WRITE(6,*) '--> Incrementing I',I+1
c
c            IF (I .EQ. NR1STM) THEN
c slmod end
              I = I+1
              GOTO 121
            ENDIF
            HELPP => HELPP%NEXT
          ENDDO
        ENDDO
        IM=IMARK
        LM=LMARK
        IF (ERRMIN.LE.EPS10) GOTO 1000
        IF (LOGX) GOTO 800
        IA=1
        IEP=NP2ND
C
C  NEXT TRY POLOIDAL SURFACES
C  THIS SECTION ALSO: IF LOGY, CHECK ON POLOID. SURFACE IA  (750...)
700     CONTINUE
c slmod begin - debug - tr
        IF (printopt.EQ.2) WRITE(6,'(4X,A)') 'LEARC1: Checkpoint C'
c slmod end
        DO J=1,4
          HELPP => HELPCUR4(J)%P
          DO WHILE (ASSOCIATED(HELPP))
            I = HELPP%IX
            L = HELPP%IY
221         IF ((I .LT. IAN) .OR. (I .GT. IEN)) GOTO 22
c slmod begin - tr
            IF (GRIDOPT.EQ.1) THEN
              XMX1=X-XVERT(I,L,1)
              YMY1=Y-YVERT(I,L,1)
              XMX4=X-XVERT(I,L,2)
              YMY4=Y-YVERT(I,L,2)

              CALL CHECKNUM('zing5',i,l,xmx1,X-XPOL(I  ,L))
              CALL CHECKNUM('zing6',i,l,xmx4,X-XPOL(I+1,L))
              CALL CHECKNUM('zing7',i,l,ymy1,Y-YPOL(I  ,L))
              CALL CHECKNUM('zing8',i,l,ymy4,Y-YPOL(I+1,L))
            ELSE
              XMX1=X-XPOL(I,L)
              YMY1=Y-YPOL(I,L)
              XMX4=X-XPOL(I+1,L)
              YMY4=Y-YPOL(I+1,L)
            ENDIF
c
c            XMX1=X-XPOL(I,L)
c            YMY1=Y-YPOL(I,L)
c            XMX4=X-XPOL(I+1,L)
c            YMY4=Y-YPOL(I+1,L)
c slmod end
            DX1=SQRT(XMX1*XMX1+YMY1*YMY1)
            DX4=SQRT(XMX4*XMX4+YMY4*YMY4)
            ERR4(L)=ABS(DX1+DX4-D14(I,L))*D14I(I,L)
            IF (ERR4(L).LT.ERRMIN) THEN
              IMARK=I
              LMARK=L
              ERRMIN=ERR4(L)
            ENDIF
22          CONTINUE
            DO KH=1,NPPLG
              IF (L .EQ. NPOINT(2,KH)-1) THEN
                L = L + 1
                GOTO 221
              ENDIF
            ENDDO
            HELPP => HELPP%NEXT
          ENDDO
        ENDDO
        IM=IMARK
        LM=LMARK
        IF (ERRMIN.LE.EPS10) GOTO 1000
        GOTO 800
C
750     CONTINUE
        DO J=1,4
          HELPP => HELPCUR4(J)%P
          DO WHILE (ASSOCIATED(HELPP))
            I = HELPP%IX
            L = HELPP%IY
            IF (I .GT. NR1STM) GOTO 23
c slmod begin - tr
            IF (GRIDOPT.EQ.1) THEN
              XMX1=X-XVERT(I,IA,1)
              YMY1=Y-YVERT(I,IA,1)
              XMX4=X-XVERT(I,IA,2)
              YMY4=Y-YVERT(I,IA,2)

              CALL CHECKNUM('zing9 ',i,ia,xmx1,X-XPOL(I  ,IA))
              CALL CHECKNUM('zing10',i,ia,xmx4,X-XPOL(I+1,IA))
              CALL CHECKNUM('zing11',i,ia,ymy1,Y-YPOL(I  ,IA))
              CALL CHECKNUM('zing12',i,ia,ymy4,Y-YPOL(I+1,IA))
            ELSE
              XMX1=X-XPOL(I,IA)
              YMY1=Y-YPOL(I,IA)
              XMX4=X-XPOL(I+1,IA)
              YMY4=Y-YPOL(I+1,IA)
            ENDIF
c
c            XMX1=X-XPOL(I,IA)
c            YMY1=Y-YPOL(I,IA)
c            XMX4=X-XPOL(I+1,IA)
c            YMY4=Y-YPOL(I+1,IA)
c slmod end
            DX1=SQRT(XMX1*XMX1+YMY1*YMY1)
            DX4=SQRT(XMX4*XMX4+YMY4*YMY4)
            ERR7(I)=ABS(DX1+DX4-D14(I,IA))*D14I(I,IA)
            IF (ERR7(I).LT.ERRMIN) THEN
              IMARK=I
              LMARK=IA
              ERRMIN=ERR7(I)
            ENDIF
23          HELPP => HELPP%NEXT
          ENDDO
        ENDDO
        IM=IMARK
        LM=LMARK
        IF (ERRMIN.LE.EPS10) GOTO 1000
C
800     CONTINUE
        IF (INUM.EQ.0.AND.ERRMIN.GT.EPS10) THEN
          CALL MASAGE ('X,Y OUT OF RANGE IN LEARC1                   ')
          CALL MASR2('X,Y             ',X,Y)
          WRITE (6,*) 'LEARC1 CALLED FROM SUBR. ',TEXT
          WRITE (6,*) 'ERRMIN= ',ERRMIN
          WRITE (6,*) 'NPANU,IM,LM= ',NP,IM,LM
          WRITE (6,*) 'IAN,IEN,LOGX,LOGY ',IAN,IEN,LOGX,LOGY
c slmod begin - debug - not tr
c          STOP 'LEARC1'
c slmod end
        ELSEIF (INUM.GT.1.AND.ERRMIN.GT.EPS10) THEN
          CALL MASAGE ('WARNING FROM LEARC1, INUM.GT.1               ')
          CALL MASR2('X,Y             ',X,Y)
          WRITE (6,*) 'LEARC1 CALLED FROM SUBR. ',TEXT
          WRITE (6,*) 'ERRMIN= ',ERRMIN
          WRITE (6,*) 'NPANU,INUM,IM,LM= ',NP,INUM,IM,LM
          WRITE (6,*) 'IAN,IEN,LOGX,LOGY ',IAN,IEN,LOGX,LOGY
        ENDIF
C
1000    CONTINUE
C
        LEARC1=IM
        IPO=LM
C
      ELSEIF (LEVGEO.EQ.2) THEN
C
        LEARC1=0
        IF (LOGX) RETURN
        IF (LOGY) THEN
          IA=1
          IE=NR1STM
        ENDIF
        YQ=Y*Y
        DO 10 J=IA,IE
          I=J+1
          IM=J
          XQ1=X-EP1(I)
          XQ=XQ1*XQ1
          ATQ=XQ+YQ/ELLQ(I)
          IF (ATQ.LT.RQ(I)) GOTO 15
10      CONTINUE
        IF (ATQ.LE.RQ(I)+EPS12) GOTO 15
C
        CALL MASAGE ('X,Y OUT OF RANGE IN LEARC1                   ')
        CALL MASR2('X,Y             ',X,Y)
        WRITE (6,*) ATQ,RQ(NSURF)
        WRITE (6,*) 'LEARC1 CALLED FROM SUBR. ',TEXT
        CALL EXIT
C
15      CONTINUE
        LEARC1=IM
C
      ELSEIF (LEVGEO.EQ.1) THEN
C
        LEARC1=0
        IF (LOGX) RETURN
        IF (LOGY) THEN
          IA=1
          IE=NR1STM
        ENDIF
        IM=1
        IF (NR1ST.LT.2) GOTO 250
        DO 200 J=IA,IE
          I=J+1
          IM=J
          IF (X.LT.RSURF(I)) GOTO 250
200     CONTINUE
        IF (X.LE.RSURF(I)+EPS12) GOTO 250
C
        CALL MASAGE ('X OUT OF RANGE IN LEARC1                   ')
        CALL MASR2('X,Y             ',X,Y)
        WRITE (6,*) 'LEARC1 CALLED FROM SUBR. ',TEXT
        CALL EXIT
C
250     CONTINUE
        LEARC1=IM
C
      ELSEIF (LEVGEO.EQ.5) THEN
C
C  GENERAL GEOMETRY OPTION: PROVIDE CELL NUMBER, GIVEN THE POSITION
C
        LEARC1=LEAUSR(X,Y,Z)
C
      ENDIF
C
      RETURN
      END
C
      FUNCTION LEARC2(X,Y,NR,NP,TEXT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C  THIS SUBROUTINE FINDS THE POLYGON INDEX "IPOLG"
C  ASSUMING THAT X,Y IS IN THE RADIAL ZONE NR
      INCLUDE 'PARMMOD'
      INCLUDE 'CGRID'
      INCLUDE 'CGEOM'
      INCLUDE 'CCONA'
      INCLUDE 'CPOLYG'
      DIMENSION ERR1(N2NDPLG),ERR2(N2NDPLG),ERR3(N2NDPLG),
     .          ERR4(N2NDPLG),ERR5(N2NDPLG),ERR6(N2NDPLG)
      DIMENSION X1(N1ST-1,N2ND),Y1(N1ST-1,N2ND),X2(N1ST-1,N2ND),
     .          Y2(N1ST-1,N2ND),X3(N1ST-1,N2ND),Y3(N1ST-1,N2ND),
     .          X4(N1ST-1,N2ND),Y4(N1ST-1,N2ND),
     .          TX(N1ST-1,N2ND),TY(N1ST-1,N2ND),
     .          UX(N1ST-1,N2ND),UY(N1ST-1,N2ND),DET(N1ST-1,N2ND),
     .          VY1(N1ST-1,N2ND),WY1(N1ST-1,N2ND),
     .          WX1(N1ST-1,N2ND),DWY(N1ST-1,N2ND),
     .          HELP(N1ST-1,N2ND),
     .          D12(N1ST-1,N2ND),D14(N1ST-1,N2ND),
     .          D32(N1ST-1,N2ND),D34(N1ST-1,N2ND)
      CHARACTER*(*) TEXT
      SAVE
      DATA IFIRST /0/
C
c slmod begin - debug - tr
      IF (printopt.GE.1.AND.printopt.LE.10) THEN
        WRITE(6,'(4X,A                 )') 'LEARC2: (X,Y,NR,NP,TEXT)'
        WRITE(6,'(10X,2F9.3,2X,2I5,2X,A)')           x,y,nr,np,text
      ENDIF
c slmod end
      IF (IFIRST .EQ. 0) THEN
        IFIRST = 1
        DO 10 N=1,NR1STM
          DO 10 K=1,NPPLG
            DO 10 L=NPOINT(1,K),NPOINT(2,K)-1
c slmod begin - grid - tr
              IF (GRIDOPT.EQ.1) THEN

                IF (RVRTAG(NR,L).EQ.1) THEN
                  IF (PRINTOPT.GE.1.AND.PRINTOPT.LE.10)
     .              WRITE(6,'(4X,A,2I4)') 'LEARC2:     Skipping'//
     .                                    ' radial surface ',NR,L
                  GOTO 10
                ENDIF

                X1(N,L)=XVERT(N,L  ,1)
                Y1(N,L)=YVERT(N,L  ,1)
                X2(N,L)=XVERT(N,L+1,1)
                Y2(N,L)=YVERT(N,L+1,1)
                X3(N,L)=XVERT(N,L+1,2)
                Y3(N,L)=YVERT(N,L+1,2)
                X4(N,L)=XVERT(N,L  ,2)
                Y4(N,L)=YVERT(N,L  ,2)
              ELSE
                X1(N,L)=XPOL(N,L)
                Y1(N,L)=YPOL(N,L)
                X2(N,L)=XPOL(N,L+1)
                Y2(N,L)=YPOL(N,L+1)
                X3(N,L)=XPOL(N+1,L+1)
                Y3(N,L)=YPOL(N+1,L+1)
                X4(N,L)=XPOL(N+1,L)
                Y4(N,L)=YPOL(N+1,L)
              ENDIF
c
c              X1(N,L)=XPOL(N,L)
c              Y1(N,L)=YPOL(N,L)
c              X2(N,L)=XPOL(N,L+1)
c              Y2(N,L)=YPOL(N,L+1)
c              X3(N,L)=XPOL(N+1,L+1)
c              Y3(N,L)=YPOL(N+1,L+1)
c              X4(N,L)=XPOL(N+1,L)
c              Y4(N,L)=YPOL(N+1,L)
c slmod end
              TX(N,L)=X1(N,L)-X2(N,L)
              TY(N,L)=Y1(N,L)-Y2(N,L)
              UX(N,L)=X3(N,L)-X2(N,L)
              UY(N,L)=Y3(N,L)-Y2(N,L)
              DET(N,L)=1./(TX(N,L)*UY(N,L)-TY(N,L)*UX(N,L)-EPS60)
C
              VX1=X4(N,L)-X1(N,L)
              VY1(N,L)=Y4(N,L)-Y1(N,L)
              WX1(N,L)=X3(N,L)-X1(N,L)
              WY1(N,L)=Y3(N,L)-Y1(N,L)
              DWY(N,L)=1./(WY1(N,L)+EPS60)
              HELP(N,L)=1./(VX1*WY1(N,L)-VY1(N,L)*WX1(N,L))
C
              VX2=X3(N,L)-X4(N,L)
              VY2=Y3(N,L)-Y4(N,L)
              WX2=X1(N,L)-X4(N,L)
              WY2=Y1(N,L)-Y4(N,L)
              D12(N,L)=SQRT(TX(N,L)*TX(N,L)+TY(N,L)*TY(N,L))
              D32(N,L)=SQRT(UX(N,L)*UX(N,L)+UY(N,L)*UY(N,L))
              D34(N,L)=SQRT(VX2*VX2+VY2*VY2)
              D14(N,L)=SQRT(WX2*WX2+WY2*WY2)
10      CONTINUE
      ENDIF
C
C  END OF IFIRST LOOP
C
      INUM=0
C
      DO 100 K=1,NPPLG
      DO 101 L=NPOINT(1,K),NPOINT(2,K)-1
        XMX2=X-X2(NR,L)
        YMY2=Y-Y2(NR,L)
        DET1=XMX2*UY(NR,L)-YMY2*UX(NR,L)
        DET2=TX(NR,L)*YMY2-TY(NR,L)*XMX2
        ERR1(L)=DET1*DET(NR,L)
        ERR2(L)=DET2*DET(NR,L)
C
        XMX1=X-X1(NR,L)
        YMY1=Y-Y1(NR,L)
        ERR3(L)=(XMX1*WY1(NR,L)-YMY1*WX1(NR,L))*HELP(NR,L)
        ERR4(L)=(YMY1-VY1(NR,L)*ERR3(L))*DWY(NR,L)
        ERR5(L)=ERR1(L)+ERR2(L)
        ERR6(L)=ERR3(L)+ERR4(L)
101   CONTINUE
      IF (LEVGEO .EQ. 2) THEN
        DO 102 L=NPOINT(1,K),NPOINT(2,K)-1
102       ERR6(L)=0.
      ENDIF
      DO 100 L=NPOINT(1,K),NPOINT(2,K)-1
c slmod begin - grid - tr
        IF (GRIDOPT.EQ.1.AND.RVRTAG(NR,L).EQ.1) THEN
          IF (PRINTOPT.GE.1.AND.PRINTOPT.LE.10)
     .      WRITE(6,'(4X,A,2I4)') 'LEARC2:     Skipping '//
     .                            'radial cell ',NR,L
          GOTO 100
        ENDIF
c slmod end
        IF (ERR4(L).GT.1.D30) THEN
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1) THEN
            X2N=XVERT(NR,L  ,1)
            Y2N=YVERT(NR,L  ,1)
            X3N=XVERT(NR,L+1,1)
            Y3N=YVERT(NR,L+1,1)
            X4N=XVERT(NR,L+1,2)
            Y4N=YVERT(NR,L+1,2)
            X1N=XVERT(NR,L  ,2)
            Y1N=YVERT(NR,L  ,2)
          ELSE
            X2N=XPOL(NR,L)
            Y2N=YPOL(NR,L)
            X3N=XPOL(NR,L+1)
            Y3N=YPOL(NR,L+1)
            X4N=XPOL(NR+1,L+1)
            Y4N=YPOL(NR+1,L+1)
            X1N=XPOL(NR+1,L)
            Y1N=YPOL(NR+1,L)
          ENDIF
c
c          X2N=XPOL(NR,L)
c          Y2N=YPOL(NR,L)
c          X3N=XPOL(NR,L+1)
c          Y3N=YPOL(NR,L+1)
c          X4N=XPOL(NR+1,L+1)
c          Y4N=YPOL(NR+1,L+1)
c          X1N=XPOL(NR+1,L)
c          Y1N=YPOL(NR+1,L)
c slmod end
          TXN=X1N-X2N
          TYN=Y1N-Y2N
          UXN=X3N-X2N
          UYN=Y3N-Y2N
          DETN=1./(TXN*UYN-TYN*UXN-EPS60)

          VX1=X4N-X1N
          VY1N=Y4N-Y1N
          WX1N=X3N-X1N
          WY1N=Y3N-Y1N
          DWYN=1./(WY1N+EPS60)
          HELPN=1./(VX1*WY1N-VY1N*WX1N)

          XMX2=X-X2N
          YMY2=Y-Y2N
          DET1=XMX2*UYN-YMY2*UXN
          DET2=TXN*YMY2-TYN*XMX2
          ERR1(L)=DET1*DETN
          ERR2(L)=DET2*DETN
C
          XMX1=X-X1N
          YMY1=Y-Y1N
          ERR3(L)=(XMX1*WY1N-YMY1*WX1N)*HELPN
          ERR4(L)=(YMY1-VY1N*ERR3(L))*DWYN
          ERR5(L)=ERR1(L)+ERR2(L)
          ERR6(L)=ERR3(L)+ERR4(L)
        ENDIF
        IF (ERR5(L).LT.1..AND.ERR1(L).GT.0..AND.ERR2(L).GT.0.) THEN
          INUM=INUM+1
          IM=NR
          LM=L
        ELSEIF (ERR6(L).LT.1..AND.ERR3(L).GE.0..AND.ERR4(L).GE.0.) THEN
          INUM=INUM+1
          IM=NR
          LM=L
        ENDIF
100   CONTINUE
C
      ERRMIN=1.D30
      IF (INUM.NE.1) THEN
C  CHECK FOR NEAREST BOUNDARY, BECAUSE NO VALID CELL INDEX FOUND
        DO 110 K=1,NPPLG
        DO 111 L=NPOINT(1,K),NPOINT(2,K)-1
          XMX1=X-X1(NR,L)
          YMY1=Y-Y1(NR,L)
          XMX2=X-X2(NR,L)
          YMY2=Y-Y2(NR,L)
          XMX3=X-X3(NR,L)
          YMY3=Y-Y3(NR,L)
          XMX4=X-X4(NR,L)
          YMY4=Y-Y4(NR,L)
          DX1=SQRT(XMX1*XMX1+YMY1*YMY1)
          DX2=SQRT(XMX2*XMX2+YMY2*YMY2)
          DX3=SQRT(XMX3*XMX3+YMY3*YMY3)
          DX4=SQRT(XMX4*XMX4+YMY4*YMY4)
          ERR1(L)=ABS(DX1+DX2-D12(NR,L))
          ERR2(L)=ABS(DX2+DX3-D32(NR,L))
          ERR3(L)=ABS(DX3+DX4-D34(NR,L))
          ERR4(L)=ABS(DX1+DX4-D14(NR,L))
111     CONTINUE
        IF (LEVGEO .EQ. 2) THEN
          ERR1(L)=ERRMIN
          ERR3(L)=ERRMIN
        ENDIF
        DO 110 L=NPOINT(1,K),NPOINT(2,K)-1
c slmod begin - grid - tr
          IF (GRIDOPT.EQ.1.AND.RVRTAG(NR,L).EQ.1) THEN
            IF (PRINTOPT.GE.1.AND.PRINTOPT.LE.10)
     .        WRITE(6,'(4X,A,2I4)') 'LEARC2:     Skipping '//
     .                              'radial surface ',NR,L
            GOTO 110
          ENDIF
c slmod end
          IF (ERR1(L).LT.ERRMIN) THEN
            IMARK=NR
            LMARK=L
            ERRMIN=ERR1(L)
          ENDIF
          IF (ERR2(L).LT.ERRMIN) THEN
            IMARK=NR
            LMARK=L+1
            ERRMIN=ERR2(L)
          ENDIF
          IF (ERR3(L).LT.ERRMIN) THEN
            IMARK=NR+1
            LMARK=L
            ERRMIN=ERR3(L)
          ENDIF
          IF (ERR4(L).LT.ERRMIN) THEN
            IMARK=NR
            LMARK=L
            ERRMIN=ERR4(L)
          ENDIF
110     CONTINUE
        IM=IMARK
        LM=LMARK
      ENDIF
C
      IF (INUM.EQ.0.AND.ERRMIN.GT.EPS5) THEN
        CALL MASAGE ('X,Y OUT OF RANGE IN LEARC2                   ')
        CALL MASR2('X,Y             ',X,Y)
        WRITE (6,*) 'LEARC2 CALLED FROM SUBR. ',TEXT
        WRITE (6,*) 'ERRMIN= ',ERRMIN
        WRITE (6,*) 'NPANU,IM,LM= ',NP,IM,LM
      ELSEIF (INUM.GT.1.AND.ERRMIN.GT.EPS5) THEN
        CALL MASAGE ('WARNING FROM LEARC2, INUM.GT.1               ')
        CALL MASR2('X,Y             ',X,Y)
        WRITE (6,*) 'LEARC2 CALLED FROM SUBR. ',TEXT
        WRITE (6,*) 'ERRMIN= ',ERRMIN
        WRITE (6,*) 'NPANU,INUM,IM,LM= ',NP,INUM,IM,LM
      ENDIF
C
      LEARC2=LM
C
      RETURN
      END
C
      SUBROUTINE FZRTOR(X,Z,NOLD,XNEW,PH,NNEW,LTEST,NTEST)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C  INPUT :
C    X     : X CO-ORDINATE
C    Z     : Z CO-ORDINATE
C    NOLD  : X AND Z ARE GIVEN IN LOCAL SYSTEM NOLD
C  OUTPUT:
C    PH   : TOROIDAL ANGLE (0<=PH<2PI)
C    NNEW  : TOROIDAL ZONE NUMBER (1 <= NNEW <= NTTRAM)
C    XNEW  : X CO-ORDINATE IN LOCAL SYSTEM OF CELL NNEW
C  IF LTEST: TEST IF NNEW=NTEST, NTEST IS INPUT (EXPECTED VALUE OF NNEW)
C
C  FROM LOCAL CO-ORDINATES X,Z IN THE TOROIDAL CELL NUMBER NOLD
C
      INCLUDE 'PARMMOD'
      INCLUDE 'COMPRT'
      INCLUDE 'CCONA'
      INCLUDE 'CGRID'
      LOGICAL LTEST
C
      XOLD=X+RMTOR
      ZOLD=Z
C  TOROIDAL ANGLE PH AND NEW TOROIDAL CELL NUMBER
      Z1=ZSURF(1)
      PH=MOD(ZZONE(NOLD)+ATAN2(ZOLD,XOLD)+PI2A-Z1,PI2A)+Z1
      NNEW=LEARCA(PH,ZSURF,1,NTTRA,1,'FZRTOR ')
      NNEW=MIN(NTTRAM,NNEW)
C  RADIAL CO-ORDINATE
      RR=SQRT(XOLD*XOLD+ZOLD*ZOLD)
C  LOCAL CO-ORDINATES IN CELL NNEW
      WLOC=PH-ZZONE(NNEW)
      XNEW=RR*COS(WLOC)
      IF (LTEST) THEN
        IF (NTEST.NE.NNEW) THEN
C  POSITION ON (NEAR) TOROIDAL SURFACE?
          IF (ABS(PH-ZSURF(NTEST)).GT.EPS12.AND.
     .        ABS(PH-ZSURF(NTEST+1)).GT.EPS12) THEN
            WRITE (6,*) 'ERROR IN FZRTOR: WRONG TOROIDAL CELL INDEX'
            WRITE (6,*) 'XOLD,ZOLD,XNEW,PH  ',XOLD,ZOLD,XNEW,PH
            WRITE (6,*) 'NNEW,NTST ',NNEW,NTEST
            WRITE (6,*) 'ABS(PH-ZSURF(NTST)),ABS(PH-ZSURF(NTST+1))'
            WRITE (6,*)  ABS(PH-ZSURF(NTEST)),ABS(PH-ZSURF(NTEST+1))
            WEIGHT=0.
            LGPART=.FALSE.
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END
C
      SUBROUTINE FZRTRA(X,Z,PH,NNEW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INCLUDE 'PARMMOD'
      INCLUDE 'CCONA'
      INCLUDE 'CGRID'
C
C  FIND X,Z, NNEW,   FROM X,PH   (X=X??)
      Z1=ZSURF(1)
      PH=MOD(PH+PI2A-Z1,PI2A)+Z1
      NNEW=LEARCA(PH,ZSURF,1,NTTRA,1,'FZRTRA ')
      IF (NNEW.LE.0.OR.NNEW.GT.NTTRAM) THEN
        WRITE (6,*) 'NT OUT OF RANGE IN FZRTRA '
        WRITE (6,*) PH,ZHALF,NNEW
        CALL EXIT
      ENDIF
      X01=X+RMTOR
      CALL FZRTRI(X,Z,NNEW,X01,PH,NNEW)
      RETURN
      END
C
      SUBROUTINE FZRTRI(X0,Z0,NNEW,XOLD,PH,NOLD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  CALCULATE THE LOCAL CO-ORDINATES X0,Z0 IN ZONE NNEW
C
C  FROM THE CELL NUMBER NOLD,
C       THE X CO-ORDINATE XOLD (=X+RMTOR) IN THAT CELL
C       THE TOROIDAL ANGLE PH
C
C  INPUT : XOLD,PH,NOLD, NNEW
C  OUTPUT: X0,Z0
C
      INCLUDE 'PARMMOD'
      INCLUDE 'CCONA'
      INCLUDE 'CGRID'
C
      Z1=ZSURF(1)
      WTH=MOD(PH+PI2A-Z1,PI2A)+Z1
      WLOC1=WTH-ZZONE(NOLD)
      RR=XOLD/COS(WLOC1)
C
      WLOC2=WTH-ZZONE(NNEW)
      XNEW=RR*COS(WLOC2)
      X0=XNEW-RMTOR
      Z0=TAN(WLOC2)*XNEW
      RETURN
      END
C
      FUNCTION AREAA (R,N,ARCA,Y,EP1R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C   FOR LEVGEO=2 OPTION
C
C   THIS FUNCTION INTERPOLATES LINEAR STANDARD MESH PARAMETERS ON POINTS
C   LYING BETWEEN THE SURFACES OF THIS MESH
C   AND EVALUATES THE ENCLOSED (CROSS SECTIONAL) AREA AND THE ARCLENGTH
C
C  INPUT:
C     R
C     N MUST BE GIVEN SUCH THAT RSURF(N)<=R<=RSURF(N+1)
C  OUTPUT:
C     AREAA(R)=AREA WITHIN EIRENE-SURFACE LABELED BY R (RSURF)
C                   I.E. CROSS SECTIONAL AREA (CM**2)
C     ARCA(R)=ARCLENGTH AT R
C             ARCLENGTH
C     Y(R)
C     EP1R(R)
C     ELLR(R)
C     TRIA(R) (TO BE WRITTEN)
C
      INCLUDE 'PARMMOD'
      INCLUDE 'CGRID'
      INCLUDE 'CCONA'
      INCLUDE 'CLOGAU'
C
      IF (R.EQ.0.D0) THEN
        Y=0.
        AREAA=0.
        ARCA=0.
        ELLR=ELL(1)
        EP1R=EP1(1)
        RETURN
      ENDIF
      NP=N+1
      RRI=RSURF(N)
      RRD=RSURF(NP)-RRI
      RRN=(R-RRI)/RRD
C
      ELLR=ELL(N)+RRN*(ELL(NP)-ELL(N))
      EP1R=EP1(N)+RRN*(EP1(NP)-EP1(N))
      Y=ELLR*R
C
      APB=R+Y
      XL1=(R-Y)/APB
      XL12=XL1*XL1
      XL14=XL12*XL12
      Q1=(16.-0.75*XL14)/(64.-16.*XL12)
C
      AREAA=PIA*Y*R
      ARCA=APB*Q1*PIA*4.
C
      RETURN
      END
C
C
C
C
C
C        ************
C        *  OUTPUT  *
C        ************
C
C      SUBROUTINE OUTPLA
C      SUBROUTINE OUTEIR (INDOUT)
C      SUBROUTINE OUTFLX (INDOUT)
C      SUBROUTINE WRREC
C      SUBROUTINE WRSNAP
C      SUBROUTINE GETSCL (ISTRA,FATM,FMOL,FION)
C
C
