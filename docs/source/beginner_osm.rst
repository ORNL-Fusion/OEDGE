Generating an OSM-EIRENE Plasma Background
==========================================

  .. note::

    This tutorial includes multiple downloadable files, such as data, grids, etc. Links are included where they are needed or you can download all the files ahead of time here:

    - `167196: Extended grid <https://drive.google.com/file/d/1F3O5wcy5rUo6oAmoXTo5HtM0xLp6pghY/view?usp=sharing>`_
    - `167196: OMFITprofiles core data <https://drive.google.com/file/d/1qdtjbjQlnTvOuQPEppOrcy9XilCM3gtB/view?usp=drive_link>`_
    - `167195: Thomson scattering data <https://drive.google.com/file/d/1iQrM5MuFF49h9NZXzLUR0I_8LFeUQ_Po/view?usp=sharing>`_
    - `167195: RCP Data <https://drive.google.com/file/d/1tTrXwEYJzFgsmewp9bPrh4EbCHRreywC/view?usp=sharing>`_

Starting a run
--------------

Now we are ready to generate a plasma background using OSM-EIRENE. The process involves building up an input file from nothing and gradually adding various layer of complexity that are required to obtain agreement with experimental data. To begin, we will generate a meaningless background plasma just to demonstrate the workflow.

First `download the grid made by the extended grid generator <https://drive.google.com/file/d/1F3O5wcy5rUo6oAmoXTo5HtM0xLp6pghY/view?usp=sharing>`_ and place it in your ``[iris username]/shots`` directory (e.g., with Filezilla). Using your favorite text editor, such as ``geany``, open up a blank document on iris. Add the following lines and save the document as ``d3d-167196-osm-v1.d6i``:

  .. code-block::

    $
    $ Required to indicate extended grid generated by Fuse.
    $
    '{GRID FILE}      File name of the fluid grid to be loaded'  'fort.4' 
    '{GRID FORMAT}                                            '  2        
    '{EXIT}'
    $
    $ Plasma background options
    $
    '+S21  SOLTEST 0 run normally, -1 test SOL opt            ' -1

Lines the start with a $ are comments and ignored by OEDGE. The first three lines that involve options in { } brackets are specific to extended grids. We will not cover these types of options anymore in this tutorial beyond just mentioning they are needed for grids made with the fuse grid generator. The rest of the input options take the form seen in in option S21. See the following note.

  .. note::
    **Anatomy of an input option**
    
    The most basic input options consist of three things: A tag, a description, and a value. In the above, the tag is +S21, the description is "SOLTEST 0 run normally, -1 test SOL opt" and the value is -1. Every input option has a unique tag and the description is arbitrary and used only to make the input file human-readable. All the input options can be found on this website at :doc:`input`. For instance, documentation for the grid option is found at :ref:`S21`. Some tags start with a "+", while others start with an "*". This is due to historical reasons, but as far as the user is concerned the options are treated the same and there is no repeat arguments, e.g., There is no \*S21 tag, only an +S21.

Save the input file. The general run command for OEDGE on iris is as follows:

  .. code-block:: console

    $ ./rundiv_master.sh <DIV input file> <OUT input file> <geometry file name> <fluid plasma filename extension - optional> <CFD solution - optional> <DIVIMP solution - optional>"

For our specific instance, we run by replacing the unused files with "none":

  .. code-block:: console

    $ ./rundiv_master.sh d3d-167196-osm-v1 none grid_d3d_167196_3000_v1 none none none

This command submits the run using the slurm scheduler on iris. You can track the status of your jobs by typing ``wq`` at the terminal. The progress of the simulation can be tracked by opening up the ``d3d-167196-osm-v1.output`` text file. 

To recap our progress to this point:

  - We created a barebones input file and told OEDGE that we are using an extended grid
  - We set input option :ref:`S21` = -1. Following the link to the documentation for :ref:`S21` tells us that only a plasma background is being generated. Tracking impurities via DIVIMP is not performed when this is set to -1. 
  - We saved our input file and submitted it to iris and looked at the output in the ``.output`` file.

Once the run is finished, we need to visualize the results. This is covered in the next section.

Visualizing results
-------------------

All OEDGE results are stored in the results folder. For our purposes, we only need the .dat and .nc files. The first is a human-readable summary of the simulation, and the latter is a NetCDF file containing the data. Copy these two files into the same directory to your own local machine using a file transfer service of your choice (:ref:`instructions using Filezilla with the fusion VPN here<File Transfer with iris (with fusion VPN)>`). 

Open up the plotting GUI, click Browse... for the NetCDF file and find your .nc file. From the dropdown you can select various quantities to make a 2D plot from, assuming these quantites were calculated in the simulation. So Electron Temperature will generate a 2D plot, but Impurity Density will throw an error since we did not run DIVIMP. The Plot Options... Dialogue allows you to change some of the plot settings such as the colorbar scale or to plot a specific charge state for plot options that allow it. A 2D plot of the plasma density is shown below.

  .. image:: dens_ex1.png
    :width: 500

Any of the 2D quantities can also be plotted along a specific "ring". A ring represents a given flux surface of the grid in the poloidal plane. For example, say we wanted to plot the variation of the electron temperature along the first ring outside of the core. This would be ring number 16 as mentioned in the message box of the GUI. Select Electron Temperature from the dropdown, enter 16 in the Along Ring box and press the corresponding Plot button next to Along Ring.

  .. image:: along_te1.png
    :width: 500

The electron temperature is plotted against the parallel distance along the field line, S. S=0 corresponds to either the inner our outer target. Figuring this out generally becomes clear during the plasma constraning process, but for this example S=0 is the inner target. We will not go into details with the rest of the GUI options as any further functionality is best explored by calling the plotting functions from within custom python scripts. More on that later.

Adding experimental data to OSM
--------------------------------------

So far, our simulation was ran with default values for hundreds of other input options. Fortunately, we do not need to worry about most of these options and only a subset are needed for making a reliable plasma background. The first step of any OSM background is passing in the available Langmuir probe data. We will use Langmuir probe data from the previous discharge, #167195, because the outer strike point was swept back and forth between 4,000-5,000 ms to fill in the Langmuir probe data for all the flux surfaces. This is very common in well-designed experiments.

The goal is to load the Langmuir probe data and identify which flux surface, or ring, the data is applicable to. You are free to approach this however you'd like, but a simple helper script is included within the repository at ``python-plots/map_lps_to_grid.py.`` On your own machine, you can call the script as such:

  .. code-block:: console

    $ python map_lps_to_grid.py 167195 4000 5000 /path/to/file.nc

Where ``/path/to/file.nc`` is the full path to the NetCDF file from above. This has only been tested assuming you are connected through the fusion VPN (sorry for those without it). With the above command, the script will output the probe number and label of each probe. It falls onto the user to figure out where each probe is located in the machine (Langmuir probe naming convention has changed throughout the years, which combined with all the possible plasma shapes on DIII-D makes it nearly impossible to automate this process). For this example, probes 23, 25, 29, 31, 33, 35, 51 and 53 are on the outer target and 131 is on the inner target. We call the script again and pass in the locations of each probe to perform the mapping:

  .. code-block:: console

    python map_lps_to_grid.py 167195 4000 5000 /path/to/file.nc -o 23 25 29 31 33 35 51 53 -i 131 -n 5

The option ``-n 5`` is just to lower the threshold for how many data points in needed in a ring to output the average value for. Within the directory a file ``167195_4000_5000.csv`` is created with the desired data. You may open this up in Excel to help visualize what the data include. A plot of the electron temperature with rings number is shown below.

  .. image:: excel_ plot_te.png
    :width: 500

Note that instead of plasma density we are outputting the saturation current, jsat. OEDGE accepts either, but jsat is preferable (see input option :ref:`Q32`). There is significantly less data available for the inner target. In fact, when we plug this into our input file we will actually copy the outer target data for the inner. This is a common approach within OEDGE and is fine as long as your study does not focus on the inner target. But before we do this, we need to gather data for the core. 

For this tutorial we use OMFITprofiles to get the core data from Thomson scattering because of the advanced data filtering and fitting tools within it. A tutorial on OMFITprofiles is beyond the scope of this tutorial. The data is exportable in a NetCDF format. `You can download the needed NetCDF file for this tutorial here <https://drive.google.com/file/d/1qdtjbjQlnTvOuQPEppOrcy9XilCM3gtB/view?usp=drive_link>`_. The following helper script, also located in ``python-plots/oedge`` will create a csv file with the required information.

  .. code-block:: console

    $ python map_omfitprof_to_grid.py 2500 5000 /path/to/oedgefile.nc /path/to/omfitfile.nc

A file called ``omfit_mapped_to_oedge.csv`` is created in the same directory. The core temperature data plotted against psin with the ring numbers above each data point is shown below.

  .. image:: excel_core_te.png
    :width: 500

We are now ready to copy/paste our mapped data into our input file. The outer and inner target data is passed in via options :ref:`Q34` and :ref:`Q35`, respectively. The syntax for the input file is as follows:

  .. code-block:: console

    '+P03 Plasma Decay Option  4=Data input at targets        '  4
    '+Q32 Langmuir Probe Switch     0=ne  1=jsat              '  1
    '+Q34 ' 'Probe data at outer target                       '
    'Ring    Te     Ti         ne/jsat         Number of rows:'  36        
        9    1.40     1.40    1.76E+03
       10    2.45     2.45    5.61E+03
       11    3.75     3.75    8.84E+03
       12    4.00     4.00    1.28E+04
       13    5.77     5.77    1.87E+04
       14    22.88   22.88    7.60E+04
       15    28.79   28.79    1.54E+05
       16    37.59   37.59    1.87E+05
       17    35.45   35.45    2.09E+05
       18    31.99   31.99    2.17E+05
       19    18.55   18.55    1.54E+05
       20    13.77   13.77    1.52E+05
       21    11.20   11.20    1.52E+05
       22    10.71   10.71    1.36E+05
       23    10.22   10.22    9.57E+04
       24    9.84     9.84    5.97E+04
       25    9.04     9.04    4.18E+04
       26    9.16     9.16    3.09E+04
       27    8.47     8.47    2.55E+04
       28    7.82     7.82    2.63E+04
       29    7.87     7.87    2.57E+04
       37    8.03     8.03    1.86E+04
       38    8.16     8.16    1.87E+04
       43    7.28     7.28    2.27E+04
       66    7.53     7.53    1.64E+04
       67    7.66     7.66    1.42E+04
       68    8.34     8.34    1.19E+04
       69    8.79     8.79    9.82E+03
       70    8.40     8.40    8.60E+03
       71    7.11     7.11    6.29E+03
       72    3.50     3.50    4.23E+03
      110    1.77     1.77    3.88E+03
      111    2.82     2.82    6.88E+03
      112    3.73     3.73    1.08E+04
      113    5.40     5.40    1.60E+04
      114   16.72    16.72    4.84E+04
    '+Q36 ' 'Probe data at inner target                       '
    'Ring      Te       Ti     ne/jsat             Number of rows:'  36    
    [same as above, inner = outer]

We have assumed Te = Ti. We added switch :ref:`P03` "Plasma Decay Option". There are historical reasons for this name, but long story short setting this to 4 tells OEDGE to look for the target conditons for each ring from option :ref:`Q34`. We also added :ref:`Q32` to tell OEDGE we have input the jsat values instead of ne. The core data is passed in as follows:

  .. code-block:: console

    '+P02 Core Data Option  1=Input for each ring (Q37)       '  1
    '+Q37 ' 'CORE Plasma Data                                 '
    'Ring       Te        Ti         ne    Vb  Number of rows:'  15
        1   461.96    461.96   2.58E+19     0
        2   461.96    461.96   2.58E+19     0
        3   384.40    384.40   2.46E+19     0
        4   323.06    323.06   2.32E+19     0
        5   269.25    269.25   2.18E+19     0
        6   229.03    229.03   2.06E+19     0
        7   199.53    199.53   1.94E+19     0
        8   166.73    166.73   1.76E+19     0
        9   135.62    135.62   1.59E+19     0
       10   110.34    110.34   1.47E+19     0
       11    91.47     91.47   1.38E+19     0
       12    78.20     78.20   1.31E+19     0
       13    69.15     69.15   1.25E+19     0
       14    63.39     63.39   1.21E+19     0
       15    59.78     59.78   1.19E+19     0


The core data contains an extra column of the parallel velocity if that data is available, but this is generally optional and not critical so we set it to 0 (this data could be obtained via CER for those who are dedicated). We added switch :ref:`P02` and set it equal to 1. Like above, this just tells OEDGE to look for the data for core rings in input option :ref:`Q37`. Data in the core region is constant along each ring, though some of the other options for :ref:`P02` enable some variation along the ring if desired. 

Save the input file and run using the same command. Re-running without changing the filename will overwrite all the previous files and helps cut down on memory usage.

Now that we have a SOL solution built using the target Langmuir probe data, we need to compare it to other experimental data within the SOL. This generally means the "upstream" Thomson scattering data, but we also have reciprocating Langmuir probe (RCP) data at the outer midplane as well. To begin, we use the "fastTS" module in OMFIT to get the Thomson scattering data because it has ELM filtering capabilities (not needed for this discharge). Running with default values seems to be appropriate for this discharge. 

  .. code-clock:: python

    import pickle
    import numpy as np
    from os.path import expanduser
    
    root = OMFIT['fastTS']['OUTPUTS']['current']['filtered_TS']
    shot = int(OMFIT['fastTS']['OUTPUTS']['current']['filtered_TS']['shot'])
    
    output = {}
    for sysname in ["core", "divertor", "tangential"]:
        sys = root[sysname]
        tmp = {}
        tmp["time"] = np.array(sys["time"])
        tmp["r"] = np.array(sys["r"])
        tmp["z"] = np.array(sys["z"])
        tmp["te"] = np.array(sys["temp"])
        tmp["ne"] = np.array(sys["density"])
        tmp["te_err"] = np.array(sys["temp_e"])
        tmp["ne_err"] = np.array(sys["density_e"])
        tmp["psin"] = np.array(sys["psin_TS"])
        tmp["chord"] = np.array(sys["chord_index"])
    
        output[sysname] = tmp
    
    home = expanduser("~")
    fname = "{}/ts_{}.pickle".format(home, shot)
    with open(fname, "wb") as f:
        pickle.dump(output, f)

This saves the Thomson data as a pickled python dictionary in a file called ``ts_167195.pickle``. You can `download it here <https://drive.google.com/file/d/1iQrM5MuFF49h9NZXzLUR0I_8LFeUQ_Po/view?usp=sharing>`_. 

The RCP data from 167195 can be `downloaded here <https://drive.google.com/file/d/1tTrXwEYJzFgsmewp9bPrh4EbCHRreywC/view?usp=sharing>`_. 

We will use the ``oedge_plots`` module to extract the ne and Te data from the simulation along the path of the Thomson scattering and RCP locations and compare to the respective experimental data. A script demonstrating this is shown below:

  .. code-block:: python

    import oedge_plots
    import pickle
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    
    # Load Thomson scattering data.
    corets_shift = 0.0
    ts_path = "/Users/zamperini/Documents/d3d_work/divimp_files/oedge_tutorial/ts_167195.pickle"
    with open(ts_path, "rb") as f:
        ts = pickle.load(f)
    ts_plot = {"core": {}, "divertor": {}, "tangential": {}}
    for sys in ts.keys():
        tmp = ts[sys]
        mask = np.logical_and(tmp["time"] >= 2500, tmp["time"] <= 5000)
        ts_plot[sys]["time"] = tmp["time"][mask]
        for key in ["te", "te_err", "ne", "ne_err", "psin"]:
            if sys == "core" and key == "psin":
                ts_plot[sys][key] = tmp[key][:, mask] + corets_shift
            else:
                ts_plot[sys][key] = tmp[key][:, mask]
        ts_plot[sys]["chord"] = tmp["chord"]
    
    # Load the RCP data. Data has already been shifted inward by 1.5 cm due to EFIT uncertainties.
    rcp_path = "/Users/zamperini/Documents/d3d_work/divimp_files/oedge_tutorial/rcp_156195_2.csv"
    rcp = pd.read_csv(rcp_path)
    
    # Load OEDGE run and extract a series of profiles along the locations of TS and RCP.
    op_path = "/Users/zamperini/Documents/d3d_work/divimp_files/oedge_tutorial/d3d-167196-osm-v1.nc"
    op = oedge_plots.OedgePlots(op_path)
    op_tsc_te = op.fake_probe(1.94, 1.94, 0.67, 0.85, data="Te", plot="psin", show_plot=False, rings_only=False)
    op_tsc_ne = op.fake_probe(1.94, 1.94, 0.67, 0.85, data="ne", plot="psin", show_plot=False, rings_only=False)
    op_tsd_te = op.fake_probe(1.484, 1.484, -0.82, -1.17, data="Te", plot="psin", show_plot=False, rings_only=False)
    op_tsd_ne = op.fake_probe(1.484, 1.484, -0.82, -1.17, data="ne", plot="psin", show_plot=False, rings_only=False)
    op_rcp_te = op.fake_probe(2.18, 2.30, -0.188, -0.188, data="Te", plot="psin", show_plot=False, rings_only=False)
    op_rcp_ne = op.fake_probe(2.18, 2.30, -0.188, -0.188, data="ne", plot="psin", show_plot=False, rings_only=False)
    
    # Now we do our comparison plots.
    fig, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, figsize=(8, 5))
    
    # Core TS Te.
    x = ts_plot["core"]["psin"].flatten()
    y = ts_plot["core"]["te"].flatten()
    yerr = ts_plot["core"]["te_err"].flatten()
    ax1.errorbar(x, y, yerr, elinewidth=1, ecolor="k", color="k", markersize=15, lw=0)
    ax1.plot(op_tsc_te["psin"], op_tsc_te["Te"], color="tab:red")
    ax1.set_xlabel("Psin")
    ax1.set_title("Core TS Te")
    ax1.set_xlim([0.99, 1.15])
    ax1.set_ylim([0, 100])
    
    # Core TS ne.
    x = ts_plot["core"]["psin"].flatten()
    y = ts_plot["core"]["ne"].flatten()
    yerr = ts_plot["core"]["ne_err"].flatten()
    ax4.errorbar(x, y, yerr, elinewidth=1, ecolor="k", color="k", markersize=15, lw=0)
    ax4.plot(op_tsc_ne["psin"], op_tsc_ne["ne"], color="tab:red")
    ax4.set_xlabel("Psin")
    ax4.set_title("Core TS ne")
    ax4.set_xlim([0.99, 1.15])
    ax4.set_ylim([0, 2.0e19])
    
    # Divertor TS Te
    x = ts_plot["divertor"]["psin"].flatten()
    y = ts_plot["divertor"]["te"].flatten()
    yerr = ts_plot["divertor"]["te_err"].flatten()
    ax2.errorbar(x, y, yerr, elinewidth=1, ecolor="k", color="k", markersize=15, lw=0)
    ax2.plot(op_tsd_te["psin"], op_tsd_te["Te"], color="tab:red")
    ax2.set_xlabel("Psin")
    ax2.set_title("Divertor TS Te")
    ax2.set_xlim([0.99, 1.03])
    ax2.set_ylim([0, 100])
    
    # Divertor TS ne
    x = ts_plot["divertor"]["psin"].flatten()
    y = ts_plot["divertor"]["ne"].flatten()
    yerr = ts_plot["divertor"]["ne_err"].flatten()
    ax5.errorbar(x, y, yerr, elinewidth=1, ecolor="k", color="k", markersize=15, lw=0)
    ax5.plot(op_tsd_ne["psin"], op_tsd_ne["ne"], color="tab:red")
    ax5.set_xlabel("Psin")
    ax5.set_title("Divertor TS ne")
    ax5.set_xlim([0.99, 1.03])
    ax5.set_ylim([0, 1e20])
    
    # RCP Te.
    x = rcp["psin"].values
    y = rcp["Te(eV)"].values
    ax3.scatter(x, y, s=15, color="k")
    ax3.plot(op_rcp_te["psin"], op_rcp_te["Te"], color="tab:red", marker=".")
    ax3.set_xlabel("Psin")
    ax3.set_title("RCP Te")
    # ax3.axvline(2.2367, color="k", linestyle="--")
    ax3.set_xlim([0.99, 1.3])
    ax3.set_ylim([0, 50])
    
    # RCP ne.
    x = rcp["psin"].values
    y = rcp["Ne(E18 m-3)"].values * 1e18
    ax6.scatter(x, y, s=15, color="k")
    ax6.plot(op_rcp_ne["psin"], op_rcp_ne["ne"], color="tab:red", marker=".")
    ax6.set_xlabel("Psin")
    ax6.set_title("RCP ne")
    # ax6.axvline(2.2367, color="k", linestyle="--")
    ax6.set_xlim([0.99, 1.3])
    ax6.set_ylim([0, 2e19])
    
    fig.tight_layout()
    fig.show()

Running the script results in:

  .. image:: compare1.png
    :width: 500

The agreement in Te among the three diagnostic is relatively decent, but the ne agreement is poor. OEDGE generally overshoots the experimental ne data. 

Obtaining agreement with experimental data - SOL 22
---------------------------------------------------

The default plasmer solver within OEDGE is called "SOL 22". SOL 22 is a 1D fluid solver that solves the 1D fluid equation "from the targets up". By succesively solving the 1D fluid equation for each flux tube, or ring, a 2D plasma background is constructed. The solutions from one ring do not influence any others, and since we are only solving the 1D fluid equations anomalous transport coefficients (:math:`D_r` and :math:`\Chi_r`) are not needed. This is a big strength of the 1D fluid approach. SOL 22 contains a number of options to control its behavior. These options represent experimental unknowns, either due to lack/error of measurement or simply physics that are not well-understood yet. Our input file uses all defaults, which results in a barebones SOL 22 simulation. We can do better.

First, let us tell SOL 22 to iterate with EIRENE (`P36`_ = 1). By default SOL 22 uses a set of simple analytic prescriptions for particle sources for the first iteration, and then uses EIRENE for further iterations. We also will turn off momentum losses (`267`_ = 0) for now since they are on by default. Momentum losses within a flux tube can increase the density further upstream and the fact that we are overshooting the experimental density suggests we may have too strong of momentum losses near the target within our simulation. We add the following lines at the bottom of our input file:

  .. code-block:: console

    $
    $ Plasma background options - SOL 22
    $
    '+P36  Calculate SOL iteratively? 0-No 1-Yes              '  1
    '+267  Switch: Momentum loss    0-Off 1-Rect 2-Exp        '  0

Our match to experimental data is shown below.

  .. image:: compare2.png
    :width: 500

This is better, but there is still some work to be done. There are different approaches one can take to improve agreement. Here we take the most straightforward approach by manually assigning momentum loss "friction fractions" :math`F_{fric}` on each individual flux tube. See the documentation for `267`_ for a definition of :math`F_{fric}`. For a grid such as ours, with almost 100 rings in the SOL, this can be a time-consuming process but it generally is not too complicated. To save time, we will outline a semi-empirical method that can be used to automatically assign :math`F_{fric}` along each flux tube.

Assigning flux tube momentum losses
===================================

The outline of this method is to perform a scan in :math`F_{fric}` to build a mapping between :math`F_{fric}` and upstream density for our simulation. We then determine the precise value for the :math`F_{fric}` needed to force agreement with experimental data. We will use the RCP data as our experimental constraint, this should leave us close enough to the Thomson data.

Begin by turning momentum loss back on with an expoentially decaying away from the target momentum source (`267`_ = 2, consult the documentation for details). We will assign :math`F_{fric}` for the entire SOL with `242`_, where lower values correspond to larger amounts of momentum loss. Our SOL 22 options now look as such:

  .. code-block:: console
 
    $
    $ Plasma background options - SOL 22
    $
    '+P36  Calculate SOL iteratively? 0-No 1-Yes              '  1
    '+267  Switch: Momentum loss    0-Off 1-On                '  2
    '+242  Friction factor for Momentum loss formula          '  0.05

Save this file as ``d3d-167196-osm-v1-mom1.d6i`` to designate it as part of the :math`F_{fric}` scan. Change :math`F_{fric}` to 0.10 and save the file as ``d3d-167196-osm-v1-mom2.d6i``. Continue in steps of 0.05 until you reach :math`F_{fric}` = 0.95 for a total of 19 different ``-momX`` files. Run every background with the same run command as before taking care to change the input file name for each command. This could easily be automated. If you are motivated enough to do this email Shawn and I'll add it to the guide!

  .. note::

    Why are we assigning momentum losses? Aren't those included in EIRENE?

    Sort of. OEDGE is coupled to EIRENE07, as in a version from 2007. This version had questionable output with momentum losses turned on. It is possible that newer versions of EIRENE have resolved this issue, but EIRENE is a notoriously difficult code to understand and run, let alone to couple with another code. Future upgrades to OEDGE will certainly include coupling to a newer version of EIRENE, but for now the above workflow is good enough for obtaining experimentally constrained background plasmas. 
